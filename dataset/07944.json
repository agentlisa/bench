{
  "Title": "[M-04] removeValidator() and removeMinter() may fail due to exceeding gas limit",
  "Content": "\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/OperatorRegistry.sol#L113-L118>\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L84-L89>\n\n### Vulnerability Details\n\n#### removeValidator() and removeMinter() may fail due to exceeding gas limit\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/OperatorRegistry.sol#L113-L118>\n\n                for (uint256 i = 0; i < original_validators.length; ++i) {\n                    if (i != remove_idx) {\n                        validators.push(original_validators[i]);\n                    }\n                }\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/ERC20/ERC20PermitPermissionedMint.sol#L84-L89>\n\n            for (uint i = 0; i < minters_array.length; i++){ \n                if (minters_array[i] == minter_address) {\n                    minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                    break;\n                }\n            }\n\nThe `removeValidator()` is used to remove a validator from the array `validators`.\n\nThere is an unbounded loop in `removeValidator()` such that if the `validators` array gets sufficiently large, this function call will fail due to exceeding the gas limit.\n\nThe same issue exists in the `removeMinter()` function. If `minters_array` gets large, the function call will fail.\n\n**[FortisFortuna (Frax) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/12#issuecomment-1257294786):**\n > Technically correct, but in practice, the number of minters will always remain low. If it becomes an issue, we can designate one minter as a \"pre-minter\" that has a batch of tokens minted to it beforehand, then auxiliary contracts can connect to that instead of ERC20PermitPermissionedMint.sol instead.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/12#issuecomment-1278206459):**\n > I think Medium is appropriate here, given this could impact the functionality of the protocol. \n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/12#issuecomment-1279848072):**\n > Wouldn't call this a risk to the functionality of the protocol, because sender can always send enough gas, and validator array gets truncated every time on is popped for use.\n >\n> Unbounded for-loops should be handled with care but not sure a realistic impact can be demonstrated here to qualify for Medium.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-09-frax",
  "Code": [
    {
      "filename": "src/OperatorRegistry.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================= OperatorRegistry =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n\nimport \"./Utils/Owned.sol\";\n\n/// @title Keeps track of validators used for ETH 2.0 staking\n/// @notice A permissioned owner can add and removed them at will\ncontract OperatorRegistry is Owned {\n\n    struct Validator {\n        bytes pubKey;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    Validator[] validators; // Array of unused / undeposited validators that can be used at a future time\n    bytes curr_withdrawal_pubkey; // Pubkey for ETH 2.0 withdrawal creds. If you change it, you must empty the validators array\n    address public timelock_address;\n\n    constructor(address _owner, address _timelock_address, bytes memory _withdrawal_pubkey) Owned(_owner) {\n        timelock_address = _timelock_address;\n        curr_withdrawal_pubkey = _withdrawal_pubkey;\n    }\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    /// @notice Add a new validator\n    /** @dev You should verify offchain that the validator is indeed valid before adding it\n        Reason we don't do that here is for gas */\n    function addValidator(Validator calldata validator) public onlyByOwnGov {\n        validators.push(validator);\n        emit ValidatorAdded(validator.pubKey, curr_withdrawal_pubkey);\n    }\n\n    /// @notice Add multiple new validators in one function call\n    /** @dev You should verify offchain that the validators are indeed valid before adding them\n        Reason we don't do that here is for gas */\n    function addValidators(Validator[] calldata validatorArray) external onlyByOwnGov {\n        uint arrayLength = validatorArray.length;\n        for (uint256 i = 0; i < arrayLength; ++i) {\n            addValidator(validatorArray[i]);\n        }\n    }\n\n    /// @notice Swap the location of one validator with another\n    function swapValidator(uint256 from_idx, uint256 to_idx) public onlyByOwnGov {\n        // Get the original values\n        Validator memory fromVal = validators[from_idx];\n        Validator memory toVal = validators[to_idx];\n\n        // Set the swapped values\n        validators[to_idx] = fromVal;\n        validators[from_idx] = toVal;\n\n        emit ValidatorsSwapped(fromVal.pubKey, toVal.pubKey, from_idx, to_idx);\n    }\n\n    /// @notice Remove validators from the end of the validators array, in case they were added in error\n    function popValidators(uint256 times) public onlyByOwnGov {\n        // Loop through and remove validator entries at the end\n        for (uint256 i = 0; i < times; ++i) {\n            validators.pop();\n        }\n\n        emit ValidatorsPopped(times);\n    }\n\n    /** @notice Remove a validator from the array. If dont_care_about_ordering is true,  \n        a swap and pop will occur instead of a more gassy loop */ \n    function removeValidator(uint256 remove_idx, bool dont_care_about_ordering) public onlyByOwnGov {\n        // Get the pubkey for the validator to remove (for informational purposes)\n        bytes memory removed_pubkey = validators[remove_idx].pubKey;\n\n        // Less gassy to swap and pop\n        if (dont_care_about_ordering){\n            // Swap the (validator to remove) with the (last validator in the array)\n            swapValidator(remove_idx, validators.length - 1);\n\n            // Pop off the validator to remove, which is now at the end of the array\n            validators.pop();\n        }\n        // More gassy, loop\n        else {\n            // Save the original validators\n            Validator[] memory original_validators = validators;\n\n            // Clear the original validators list\n            delete validators;\n\n            // Fill the new validators array with all except the value to remove\n            for (uint256 i = 0; i < original_validators.length; ++i) {\n                if (i != remove_idx) {\n                    validators.push(original_validators[i]);\n                }\n            }\n        }\n\n        emit ValidatorRemoved(removed_pubkey, remove_idx, dont_care_about_ordering);\n    }\n\n    // Internal\n    /// @dev Remove the last validator from the validators array and return its information\n    function getNextValidator()\n        internal\n        returns (\n            bytes memory pubKey,\n            bytes memory withdrawalCredentials,\n            bytes memory signature,\n            bytes32 depositDataRoot\n        )\n    {\n        // Make sure there are free validators available\n        uint numVals = numValidators();\n        require(numVals != 0, \"Validator stack is empty\");\n\n        // Pop the last validator off the array\n        Validator memory popped = validators[numVals - 1];\n        validators.pop();\n\n        // Return the validator's information\n        pubKey = popped.pubKey;\n        withdrawalCredentials = curr_withdrawal_pubkey;\n        signature = popped.signature;\n        depositDataRoot = popped.depositDataRoot;\n    }\n\n    /// @notice Return the information of the i'th validator in the registry\n    function getValidator(uint i) \n        view\n        external\n        returns (\n            bytes memory pubKey,\n            bytes memory withdrawalCredentials,\n            bytes memory signature,\n            bytes32 depositDataRoot\n        )\n    {\n        Validator memory v = validators[i];\n\n        // Return the validator's information\n        pubKey = v.pubKey;\n        withdrawalCredentials = curr_withdrawal_pubkey;\n        signature = v.signature;\n        depositDataRoot = v.depositDataRoot;\n    }\n\n    /// @notice Returns a Validator struct of the given inputs to make formatting addValidator inputs easier\n    function getValidatorStruct(\n        bytes memory pubKey, \n        bytes memory signature, \n        bytes32 depositDataRoot\n    ) external pure returns (Validator memory) {\n        return Validator(pubKey, signature, depositDataRoot);\n    }\n\n    /// @notice Requires empty validator stack as changing withdrawal creds invalidates signature\n    /// @dev May need to call clearValidatorArray() first\n    function setWithdrawalCredential(bytes memory _new_withdrawal_pubkey) external onlyByOwnGov {\n        require(numValidators() == 0, \"Clear validator array first\");\n        curr_withdrawal_pubkey = _new_withdrawal_pubkey;\n\n        emit WithdrawalCredentialSet(_new_withdrawal_pubkey);\n    }\n\n    /// @notice Empties the validator array\n    /// @dev Need to do this before setWithdrawalCredential()\n    function clearValidatorArray() external onlyByOwnGov {\n        delete validators;\n\n        emit ValidatorArrayCleared();\n    }\n\n    /// @notice Returns the number of validators\n    function numValidators() public view returns (uint256) {\n        return validators.length;\n    }\n\n    /// @notice Set the timelock contract\n    function setTimelock(address _timelock_address) external onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\");\n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    event TimelockChanged(address timelock_address);\n    event WithdrawalCredentialSet(bytes _withdrawalCredential);\n    event ValidatorAdded(bytes pubKey, bytes withdrawalCredential);\n    event ValidatorArrayCleared();\n    event ValidatorRemoved(bytes pubKey, uint256 remove_idx, bool dont_care_about_ordering);\n    event ValidatorsPopped(uint256 times);\n    event ValidatorsSwapped(bytes from_pubKey, bytes to_pubKey, uint256 from_idx, uint256 to_idx);\n    event KeysCleared();\n}"
    },
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    },
    {
      "filename": "src/OperatorRegistry.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================= OperatorRegistry =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n\nimport \"./Utils/Owned.sol\";\n\n/// @title Keeps track of validators used for ETH 2.0 staking\n/// @notice A permissioned owner can add and removed them at will\ncontract OperatorRegistry is Owned {\n\n    struct Validator {\n        bytes pubKey;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    Validator[] validators; // Array of unused / undeposited validators that can be used at a future time\n    bytes curr_withdrawal_pubkey; // Pubkey for ETH 2.0 withdrawal creds. If you change it, you must empty the validators array\n    address public timelock_address;\n\n    constructor(address _owner, address _timelock_address, bytes memory _withdrawal_pubkey) Owned(_owner) {\n        timelock_address = _timelock_address;\n        curr_withdrawal_pubkey = _withdrawal_pubkey;\n    }\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    /// @notice Add a new validator\n    /** @dev You should verify offchain that the validator is indeed valid before adding it\n        Reason we don't do that here is for gas */\n    function addValidator(Validator calldata validator) public onlyByOwnGov {\n        validators.push(validator);\n        emit ValidatorAdded(validator.pubKey, curr_withdrawal_pubkey);\n    }\n\n    /// @notice Add multiple new validators in one function call\n    /** @dev You should verify offchain that the validators are indeed valid before adding them\n        Reason we don't do that here is for gas */\n    function addValidators(Validator[] calldata validatorArray) external onlyByOwnGov {\n        uint arrayLength = validatorArray.length;\n        for (uint256 i = 0; i < arrayLength; ++i) {\n            addValidator(validatorArray[i]);\n        }\n    }\n\n    /// @notice Swap the location of one validator with another\n    function swapValidator(uint256 from_idx, uint256 to_idx) public onlyByOwnGov {\n        // Get the original values\n        Validator memory fromVal = validators[from_idx];\n        Validator memory toVal = validators[to_idx];\n\n        // Set the swapped values\n        validators[to_idx] = fromVal;\n        validators[from_idx] = toVal;\n\n        emit ValidatorsSwapped(fromVal.pubKey, toVal.pubKey, from_idx, to_idx);\n    }\n\n    /// @notice Remove validators from the end of the validators array, in case they were added in error\n    function popValidators(uint256 times) public onlyByOwnGov {\n        // Loop through and remove validator entries at the end\n        for (uint256 i = 0; i < times; ++i) {\n            validators.pop();\n        }\n\n        emit ValidatorsPopped(times);\n    }\n\n    /** @notice Remove a validator from the array. If dont_care_about_ordering is true,  \n        a swap and pop will occur instead of a more gassy loop */ \n    function removeValidator(uint256 remove_idx, bool dont_care_about_ordering) public onlyByOwnGov {\n        // Get the pubkey for the validator to remove (for informational purposes)\n        bytes memory removed_pubkey = validators[remove_idx].pubKey;\n\n        // Less gassy to swap and pop\n        if (dont_care_about_ordering){\n            // Swap the (validator to remove) with the (last validator in the array)\n            swapValidator(remove_idx, validators.length - 1);\n\n            // Pop off the validator to remove, which is now at the end of the array\n            validators.pop();\n        }\n        // More gassy, loop\n        else {\n            // Save the original validators\n            Validator[] memory original_validators = validators;\n\n            // Clear the original validators list\n            delete validators;\n\n            // Fill the new validators array with all except the value to remove\n            for (uint256 i = 0; i < original_validators.length; ++i) {\n                if (i != remove_idx) {\n                    validators.push(original_validators[i]);\n                }\n            }\n        }\n\n        emit ValidatorRemoved(removed_pubkey, remove_idx, dont_care_about_ordering);\n    }\n\n    // Internal\n    /// @dev Remove the last validator from the validators array and return its information\n    function getNextValidator()\n        internal\n        returns (\n            bytes memory pubKey,\n            bytes memory withdrawalCredentials,\n            bytes memory signature,\n            bytes32 depositDataRoot\n        )\n    {\n        // Make sure there are free validators available\n        uint numVals = numValidators();\n        require(numVals != 0, \"Validator stack is empty\");\n\n        // Pop the last validator off the array\n        Validator memory popped = validators[numVals - 1];\n        validators.pop();\n\n        // Return the validator's information\n        pubKey = popped.pubKey;\n        withdrawalCredentials = curr_withdrawal_pubkey;\n        signature = popped.signature;\n        depositDataRoot = popped.depositDataRoot;\n    }\n\n    /// @notice Return the information of the i'th validator in the registry\n    function getValidator(uint i) \n        view\n        external\n        returns (\n            bytes memory pubKey,\n            bytes memory withdrawalCredentials,\n            bytes memory signature,\n            bytes32 depositDataRoot\n        )\n    {\n        Validator memory v = validators[i];\n\n        // Return the validator's information\n        pubKey = v.pubKey;\n        withdrawalCredentials = curr_withdrawal_pubkey;\n        signature = v.signature;\n        depositDataRoot = v.depositDataRoot;\n    }\n\n    /// @notice Returns a Validator struct of the given inputs to make formatting addValidator inputs easier\n    function getValidatorStruct(\n        bytes memory pubKey, \n        bytes memory signature, \n        bytes32 depositDataRoot\n    ) external pure returns (Validator memory) {\n        return Validator(pubKey, signature, depositDataRoot);\n    }\n\n    /// @notice Requires empty validator stack as changing withdrawal creds invalidates signature\n    /// @dev May need to call clearValidatorArray() first\n    function setWithdrawalCredential(bytes memory _new_withdrawal_pubkey) external onlyByOwnGov {\n        require(numValidators() == 0, \"Clear validator array first\");\n        curr_withdrawal_pubkey = _new_withdrawal_pubkey;\n\n        emit WithdrawalCredentialSet(_new_withdrawal_pubkey);\n    }\n\n    /// @notice Empties the validator array\n    /// @dev Need to do this before setWithdrawalCredential()\n    function clearValidatorArray() external onlyByOwnGov {\n        delete validators;\n\n        emit ValidatorArrayCleared();\n    }\n\n    /// @notice Returns the number of validators\n    function numValidators() public view returns (uint256) {\n        return validators.length;\n    }\n\n    /// @notice Set the timelock contract\n    function setTimelock(address _timelock_address) external onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\");\n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    event TimelockChanged(address timelock_address);\n    event WithdrawalCredentialSet(bytes _withdrawalCredential);\n    event ValidatorAdded(bytes pubKey, bytes withdrawalCredential);\n    event ValidatorArrayCleared();\n    event ValidatorRemoved(bytes pubKey, uint256 remove_idx, bool dont_care_about_ordering);\n    event ValidatorsPopped(uint256 times);\n    event ValidatorsSwapped(bytes from_pubKey, bytes to_pubKey, uint256 from_idx, uint256 to_idx);\n    event KeysCleared();\n}"
    },
    {
      "filename": "src/ERC20/ERC20PermitPermissionedMint.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}"
    }
  ]
}