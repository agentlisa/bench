{
  "Title": "[L02] Constants not explicitly declared",
  "Content": "Throughout the codebase there are many occurrences of literal values being used with unexplained meaning. This makes areas of the code more difficult to understand. Some examples include:\n\n\n* The literal value `1e18` is used throughout the codebase to add accuracy to calculations. However, the lack of comments and explanation around this makes it hard to track whether or not a value is correctly scaled at the end of a calculation.\n* The literal value `-1` is often used to represent the [maximum integer](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/SmartYield.sol#L494), but this use is generally something that needs to be inferred.\n* The literal values `49201150733`, `3` and `5760` used on [line 26 of `IController.sol`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/IController.sol#L26). While there are comments above this line that give them some context, the source of the values remains unclear.\n\n\nLiteral values in the codebase without an explanation as to their meaning make the code harder to read, understand, and maintain for developers, auditors and external contributors alike.\n\n\nConsider defining a `constant` variable for every literal value used and giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended.\n\n\n**Update**: *Fixed in [PR#43](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/pull/43). The referenced PR is based on commits that include other changes to the codebase which have not been reviewed by OpenZeppelin.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/SmartYield.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"hardhat/console.sol\";\n\n// TODO:\n// investigate comp value + spot price + rate = min(MAX, oracle, spot)\n// more tests\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./lib/math/MathUtils.sol\";\n\nimport \"./Governed.sol\";\nimport \"./IController.sol\";\nimport \"./oracle/IYieldOraclelizable.sol\";\nimport \"./ISmartYield.sol\";\n\nimport \"./IProvider.sol\";\n\nimport \"./model/IBondModel.sol\";\nimport \"./oracle/IYieldOracle.sol\";\nimport \"./IBond.sol\";\nimport \"./JuniorToken.sol\";\n\ncontract SmartYield is\n    JuniorToken,\n    ISmartYield\n{\n    using SafeMath for uint256;\n\n    // controller address\n    address public controller;\n\n    // address of IProviderPool\n    address public pool;\n\n    // senior BOND (NFT)\n    address public seniorBond; // IBond\n\n    // junior BOND (NFT)\n    address public juniorBond; // IBond\n\n    // underlying amount in matured and liquidated juniorBonds\n    uint256 public underlyingLiquidatedJuniors;\n\n    // tokens amount in unmatured juniorBonds or matured and unliquidated\n    uint256 public tokensInJuniorBonds;\n\n    // latest SeniorBond Id\n    uint256 public seniorBondId;\n\n    // latest JuniorBond Id\n    uint256 public juniorBondId;\n\n    // last index of juniorBondsMaturities that was liquidated\n    uint256 public juniorBondsMaturitiesPrev;\n    // list of junior bond maturities (timestamps)\n    uint256[] public juniorBondsMaturities;\n\n    // checkpoints for all JuniorBonds matureing at (timestamp) -> (JuniorBondsAt)\n    // timestamp -> JuniorBondsAt\n    mapping(uint256 => JuniorBondsAt) public juniorBondsMaturingAt;\n\n    // metadata for senior bonds\n    // bond id => bond (SeniorBond)\n    mapping(uint256 => SeniorBond) public seniorBonds;\n\n    // metadata for junior bonds\n    // bond id => bond (JuniorBond)\n    mapping(uint256 => JuniorBond) public juniorBonds;\n\n    // pool state / average bond\n    // holds rate of payment by juniors to seniors\n    SeniorBond public abond;\n\n    bool public _setup;\n\n    constructor(\n      string memory name_,\n      string memory symbol_\n    )\n      JuniorToken(name_, symbol_)\n    {}\n\n    function setup(\n      address controller_,\n      address pool_,\n      address seniorBond_,\n      address juniorBond_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"SY: already setup\"\n        );\n\n        controller = controller_;\n        pool = pool_;\n        seniorBond = seniorBond_;\n        juniorBond = juniorBond_;\n\n        _setup = true;\n    }\n\n    // externals\n\n    // buy at least _minTokens with _underlyingAmount, before _deadline passes\n    function buyTokens(\n      uint256 underlyingAmount_,\n      uint256 minTokens_,\n      uint256 deadline_\n    )\n      external override\n    {\n        _beforeProviderOp();\n\n        require(\n          false == IController(controller).PAUSED_BUY_JUNIOR_TOKEN(),\n          \"SY: buyTokens paused\"\n        );\n\n        require(\n          this.currentTime() <= deadline_,\n          \"SY: buyTokens deadline\"\n        );\n\n        uint256 fee = MathUtils.fractionOf(underlyingAmount_, IController(controller).FEE_BUY_JUNIOR_TOKEN());\n        uint256 getsTokens = (underlyingAmount_ - fee) * 1e18 / this.price();\n\n        require(\n          getsTokens >= minTokens_,\n          \"SY: buyTokens minTokens\"\n        );\n\n        // ---\n\n        IProvider(pool)._takeUnderlying(msg.sender, underlyingAmount_);\n        IProvider(pool)._depositProvider(underlyingAmount_, fee);\n        _mint(msg.sender, getsTokens);\n    }\n\n    // sell _tokens for at least _minUnderlying, before _deadline and forfeit potential future gains\n    function sellTokens(\n      uint256 tokenAmount_,\n      uint256 minUnderlying_,\n      uint256 deadline_\n    )\n      external override\n    {\n        _beforeProviderOp();\n\n        require(\n          this.currentTime() <= deadline_,\n          \"SY: sellTokens deadline\"\n        );\n\n        // share of these tokens in the debt\n        uint256 debtShare = tokenAmount_ * 1e18 / totalSupply();\n        // debt share is forfeit, and only diff is returned to user\n        uint256 toPay = (tokenAmount_ * this.price() - this.abondDebt() * debtShare) / 1e18;\n\n        require(\n          toPay >= minUnderlying_,\n          \"SY: sellTokens minUnderlying\"\n        );\n\n        // ---\n\n        _burn(msg.sender, tokenAmount_);\n        IProvider(pool)._withdrawProvider(toPay, 0);\n        IProvider(pool)._sendUnderlying(msg.sender, toPay);\n    }\n\n    // Purchase a senior bond with principalAmount_ underlying for forDays_, buyer gets a bond with gain >= minGain_ or revert. deadline_ is timestamp before which tx is not rejected.\n    function buyBond(\n        uint256 principalAmount_,\n        uint256 minGain_,\n        uint256 deadline_,\n        uint16 forDays_\n    )\n      external override\n    {\n        _beforeProviderOp();\n\n        require(\n          false == IController(controller).PAUSED_BUY_SENIOR_BOND(),\n          \"SY: buyBond paused\"\n        );\n\n        require(\n          this.currentTime() <= deadline_,\n          \"SY: buyBond deadline\"\n        );\n\n        require(\n            0 < forDays_ && forDays_ <= IController(controller).BOND_LIFE_MAX(),\n            \"SY: buyBond forDays\"\n        );\n\n        uint256 gain = this.bondGain(principalAmount_, forDays_);\n\n        require(\n          gain >= minGain_,\n          \"SY: buyBond minGain\"\n        );\n\n        require(\n          gain > 0,\n          \"SY: buyBond gain 0\"\n        );\n\n        require(\n          gain < this.underlyingLoanable(),\n          \"SY: buyBond underlyingLoanable\"\n        );\n\n        uint256 issuedAt = this.currentTime();\n\n        // ---\n\n        IProvider(pool)._takeUnderlying(msg.sender, principalAmount_);\n        IProvider(pool)._depositProvider(principalAmount_, 0);\n\n        SeniorBond memory b =\n            SeniorBond(\n                principalAmount_,\n                gain,\n                issuedAt,\n                uint256(1 days) * uint256(forDays_) + issuedAt,\n                false\n            );\n\n        _mintBond(msg.sender, b);\n    }\n\n    // buy an nft with tokenAmount_ jTokens, that matures at abond maturesAt\n    function buyJuniorBond(\n      uint256 tokenAmount_,\n      uint256 maxMaturesAt_,\n      uint256 deadline_\n    )\n      external override\n    {\n        uint256 maturesAt = 1 + abond.maturesAt / 1e18;\n\n        require(\n          this.currentTime() <= deadline_,\n          \"SY: buyJuniorBond deadline\"\n        );\n\n        require(\n          maturesAt <= maxMaturesAt_,\n          \"SY: buyJuniorBond maxMaturesAt\"\n        );\n\n        JuniorBond memory jb = JuniorBond(\n          tokenAmount_,\n          maturesAt\n        );\n\n        // ---\n\n        _takeTokens(msg.sender, tokenAmount_);\n        _mintJuniorBond(msg.sender, jb);\n\n        // if abond.maturesAt is past we can liquidate, but juniorBondsMaturingAt might have already been liquidated\n        if (this.currentTime() >= maturesAt) {\n            JuniorBondsAt memory jBondsAt = juniorBondsMaturingAt[jb.maturesAt];\n\n            if (jBondsAt.price == 0) {\n                _liquidateJuniorsAt(jb.maturesAt);\n            } else {\n                // juniorBondsMaturingAt was previously liquidated,\n                _burn(address(this), jb.tokens); // burns user's locked tokens reducing the jToken supply\n                underlyingLiquidatedJuniors += jb.tokens * jBondsAt.price / 1e18;\n                _unaccountJuniorBond(jb);\n            }\n            return this.redeemJuniorBond(juniorBondId);\n        }\n    }\n\n    // Redeem a senior bond by it's id. Anyone can redeem but owner gets principal + gain\n    function redeemBond(\n      uint256 bondId_\n    )\n      external override\n    {\n        _beforeProviderOp();\n\n        require(\n            this.currentTime() >= seniorBonds[bondId_].maturesAt,\n            \"SY: redeemBond not matured\"\n        );\n\n        // bondToken.ownerOf will revert for burned tokens\n        address payTo = IBond(seniorBond).ownerOf(bondId_);\n        uint256 payAmnt = seniorBonds[bondId_].gain + seniorBonds[bondId_].principal;\n        uint256 fee = MathUtils.fractionOf(seniorBonds[bondId_].gain, IController(controller).FEE_REDEEM_SENIOR_BOND());\n        payAmnt -= fee;\n\n        // ---\n\n        if (seniorBonds[bondId_].liquidated == false) {\n            seniorBonds[bondId_].liquidated = true;\n            _unaccountBond(seniorBonds[bondId_]);\n        }\n\n        // bondToken.burn will revert for already burned tokens\n        IBond(seniorBond).burn(bondId_);\n        delete seniorBonds[bondId_];\n\n        IProvider(pool)._withdrawProvider(payAmnt, fee);\n        IProvider(pool)._sendUnderlying(payTo, payAmnt);\n    }\n\n    // once matured, redeem a jBond for underlying\n    function redeemJuniorBond(uint256 jBondId_)\n        external override\n    {\n        _beforeProviderOp();\n\n        JuniorBond memory jb = juniorBonds[jBondId_];\n        require(\n            jb.maturesAt <= this.currentTime(),\n            \"SY: redeemJuniorBond maturesAt\"\n        );\n\n        JuniorBondsAt memory jBondsAt = juniorBondsMaturingAt[jb.maturesAt];\n\n        // blows up if already burned\n        address payTo = IBond(juniorBond).ownerOf(jBondId_);\n        uint256 payAmnt = jBondsAt.price * jb.tokens / 1e18;\n\n        // ---\n\n        _burnJuniorBond(jBondId_);\n        IProvider(pool)._withdrawProvider(payAmnt, 0);\n        IProvider(pool)._sendUnderlying(payTo, payAmnt);\n        underlyingLiquidatedJuniors -= payAmnt;\n    }\n\n\n    function providerRatePerDay()\n      external view virtual override\n    returns (uint256)\n    {\n        return MathUtils.min(\n          IController(controller).BOND_MAX_RATE_PER_DAY(),\n          IYieldOracle(IController(controller).oracle()).consult(1 days)\n        );\n    }\n\n    // given a principal amount and a number of days, compute the guaranteed bond gain, excluding principal\n    function bondGain(uint256 principalAmount_, uint16 forDays_)\n      external view override\n    returns (uint256)\n    {\n        return IBondModel(IController(controller).bondModel()).gain(address(this), principalAmount_, forDays_);\n    }\n\n  // /externals\n\n  // publics\n\n    function currentTime()\n      public view virtual override\n    returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // jToken price * 1e18\n    function price()\n      public view override\n    returns (uint256)\n    {\n        uint256 ts = totalSupply();\n        return (ts == 0) ? 1e18 : (this.underlyingJuniors() * 1e18) / ts;\n    }\n\n    function underlyingTotal()\n      public view virtual override\n    returns(uint256)\n    {\n      return IProvider(pool).underlyingBalance() - IProvider(pool).underlyingFees() - underlyingLiquidatedJuniors;\n    }\n\n    function underlyingJuniors()\n      public view virtual override\n    returns (uint256)\n    {\n        return this.underlyingTotal() - abond.principal - this.abondPaid();\n    }\n\n    function underlyingLoanable()\n      public view virtual override\n    returns (uint256)\n    {\n        // underlyingTotal - abond.principal - abond.gain - queued withdrawls\n        return this.underlyingTotal() - abond.principal - abond.gain - (tokensInJuniorBonds * this.price() / 1e18);\n    }\n\n    function abondGain()\n      public view override\n    returns (uint256)\n    {\n        return abond.gain;\n    }\n\n    function abondPaid()\n      public view override\n    returns (uint256)\n    {\n        uint256 ts = this.currentTime() * 1e18;\n        if (ts <= abond.issuedAt || (abond.maturesAt <= abond.issuedAt)) {\n          return 0;\n        }\n\n        uint256 d = abond.maturesAt - abond.issuedAt;\n        return (this.abondGain() * MathUtils.min(ts - abond.issuedAt, d)) / d;\n    }\n\n    function abondDebt()\n      public view override\n    returns (uint256)\n    {\n        return this.abondGain() - this.abondPaid();\n    }\n\n  // /publics\n\n  // internals\n\n    function _beforeProviderOp() internal {\n      // this modifier will be added to the begginging of all (write) functions.\n      // The first tx after a queued liquidation's timestamp will trigger the liquidation\n      // reducing the jToken supply, and setting aside owed_dai for withdrawals\n      for (uint256 i = juniorBondsMaturitiesPrev; i < juniorBondsMaturities.length; i++) {\n          if (this.currentTime() >= juniorBondsMaturities[i]) {\n              _liquidateJuniorsAt(juniorBondsMaturities[i]);\n              juniorBondsMaturitiesPrev = i + 1;\n          } else {\n              break;\n          }\n      }\n    }\n\n    function _liquidateJuniorsAt(uint256 timestamp_)\n      internal\n    {\n        JuniorBondsAt storage jBondsAt = juniorBondsMaturingAt[timestamp_];\n\n        require(\n          jBondsAt.tokens > 0,\n          \"SY: nothing to liquidate\"\n        );\n\n        require(\n          jBondsAt.price == 0,\n          \"SY: already liquidated\"\n        );\n\n        jBondsAt.price = this.price();\n\n        // ---\n\n        underlyingLiquidatedJuniors += jBondsAt.tokens * jBondsAt.price / 1e18;\n        _burn(address(this), jBondsAt.tokens); // burns Junior locked tokens reducing the jToken supply\n        tokensInJuniorBonds -= jBondsAt.tokens;\n    }\n\n    // removes matured seniorBonds from being accounted in abond\n    function unaccountBonds(uint256[] memory bondIds_) public override {\n      for (uint256 f = 0; f < bondIds_.length; f++) {\n        if (\n            this.currentTime() > seniorBonds[bondIds_[f]].maturesAt &&\n            seniorBonds[bondIds_[f]].liquidated == false\n        ) {\n            seniorBonds[bondIds_[f]].liquidated = true;\n            _unaccountBond(seniorBonds[bondIds_[f]]);\n        }\n      }\n    }\n\n    function _mintBond(address to_, SeniorBond memory bond_)\n      internal\n    {\n        require(\n          seniorBondId < uint256(-1),\n          \"SY: _mintBond\"\n        );\n\n        seniorBondId++;\n        seniorBonds[seniorBondId] = bond_;\n        _accountBond(bond_);\n        IBond(seniorBond).mint(to_, seniorBondId);\n    }\n\n    // when a new bond is added to the pool, we want:\n    // - to average abond.maturesAt (the earliest date at which juniors can fully exit), this shortens the junior exit date compared to the date of the last active bond\n    // - to keep the price for jTokens before a bond is bought ~equal with the price for jTokens after a bond is bought\n    function _accountBond(SeniorBond memory b_)\n      internal\n    {\n        uint256 _now = this.currentTime() * 1e18;\n\n        uint256 newDebt = this.abondDebt() + b_.gain;\n        // for the very first bond or the first bond after abond maturity: this.abondDebt() = 0 => newMaturesAt = b.maturesAt\n        uint256 newMaturesAt = (abond.maturesAt * this.abondDebt() + b_.maturesAt * 1e18 * b_.gain) / newDebt;\n\n        // timestamp = timestamp - tokens * d / tokens\n        uint256 newIssuedAt = newMaturesAt.sub(uint256(1) + ((abond.gain + b_.gain) * (newMaturesAt - _now)) / newDebt, \"SY: liquidate some seniorBonds\");\n\n        abond = SeniorBond(\n          abond.principal + b_.principal,\n          abond.gain + b_.gain,\n          newIssuedAt,\n          newMaturesAt,\n          false\n        );\n    }\n\n    // when a bond is redeemed from the pool, we want:\n    // - for abond.maturesAt (the earliest date at which juniors can fully exit) to remain the same as before the redeem\n    // - to keep the price for jTokens before a bond is bought ~equal with the price for jTokens after a bond is bought\n    function _unaccountBond(SeniorBond memory b_)\n      internal\n    {\n        uint256 now_ = this.currentTime() * 1e18;\n\n        if ((now_ >= abond.maturesAt)) {\n          // abond matured\n          // this.abondDebt() == 0\n          abond = SeniorBond(\n            abond.principal - b_.principal,\n            abond.gain - b_.gain,\n            now_ - (abond.maturesAt - abond.issuedAt),\n            now_,\n            false\n          );\n\n          return;\n        }\n\n        // timestamp = timestamp - tokens * d / tokens\n        uint256 newIssuedAt = abond.maturesAt.sub(uint256(1) + (abond.gain - b_.gain) * (abond.maturesAt - now_) / this.abondDebt(), \"SY: liquidate some seniorBonds\");\n\n        abond = SeniorBond(\n          abond.principal - b_.principal,\n          abond.gain - b_.gain,\n          newIssuedAt,\n          abond.maturesAt,\n          false\n        );\n    }\n\n    function _mintJuniorBond(address to_, JuniorBond memory jb_)\n      internal\n    {\n        require(\n          juniorBondId < uint256(-1),\n          \"SY: _mintJuniorBond\"\n        );\n\n        juniorBondId++;\n        juniorBonds[juniorBondId] = jb_;\n\n        _accountJuniorBond(jb_);\n        IBond(juniorBond).mint(to_, juniorBondId);\n    }\n\n    function _accountJuniorBond(JuniorBond memory jb_)\n      internal\n    {\n        tokensInJuniorBonds += jb_.tokens;\n\n        JuniorBondsAt storage jBondsAt = juniorBondsMaturingAt[jb_.maturesAt];\n        uint256 tmp;\n\n        if (jBondsAt.tokens == 0 && this.currentTime() < jb_.maturesAt) {\n          juniorBondsMaturities.push(jb_.maturesAt);\n          for (uint256 i = juniorBondsMaturities.length - 1; i >= MathUtils.max(1, juniorBondsMaturitiesPrev); i--) {\n            if (juniorBondsMaturities[i] > juniorBondsMaturities[i - 1]) {\n              break;\n            }\n            tmp = juniorBondsMaturities[i - 1];\n            juniorBondsMaturities[i - 1] = juniorBondsMaturities[i];\n            juniorBondsMaturities[i] = tmp;\n          }\n        }\n\n        jBondsAt.tokens += jb_.tokens;\n    }\n\n    function _burnJuniorBond(uint256 bondId_) internal {\n        //JuniorBond memory jb = juniorBonds[bondId_];\n\n        //_unaccountJuniorBond(jb);\n        // blows up if already burned\n        IBond(juniorBond).burn(bondId_);\n    }\n\n    function _unaccountJuniorBond(JuniorBond memory jb_) internal {\n        tokensInJuniorBonds -= jb_.tokens;\n        JuniorBondsAt storage jBondsAt = juniorBondsMaturingAt[jb_.maturesAt];\n        jBondsAt.tokens -= jb_.tokens;\n    }\n\n    function _takeTokens(address _from, uint256 _amount) internal {\n        // TODO: optimization, use _transfer() gas + no approve\n        require(\n            transferFrom(_from, address(this), _amount),\n            \"SY: _takeTokens transferFrom\"\n        );\n    }\n\n  // /internals\n\n}"
    },
    {
      "filename": "contracts/IController.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./Governed.sol\";\n\ncontract IController is Governed {\n\n    address public oracle; // IYieldOracle\n\n    address public bondModel; // IBondModel\n\n    address public feesOwner; // fees are sent here\n\n    // reward for calling harvest 3%\n    uint256 public HARVEST_REWARD = 3 * 1e16; // 3%\n\n    // fee for buying jTokens\n    uint256 public FEE_BUY_JUNIOR_TOKEN = 3 * 1e16; // 3%\n\n    // fee for redeeming a sBond\n    uint256 public FEE_REDEEM_SENIOR_BOND = 3 * 1e16; // 3%\n\n    // max rate per day for sBonds\n    // k * supplyRatePerBlock * blocksPerDay\n    uint256 public BOND_MAX_RATE_PER_DAY = 3 * 49201150733 * 5760; // APY ~30% / year\n\n    // max duration of a purchased sBond\n    uint16 public BOND_LIFE_MAX = 90; // in days\n\n    bool public PAUSED_BUY_JUNIOR_TOKEN = false;\n\n    bool public PAUSED_BUY_SENIOR_BOND = false;\n\n    constructor() Governed() { }\n\n    function setHarvestReward(uint256 newValue_)\n      public\n      onlyDaoOrGuardian\n    {\n        HARVEST_REWARD = newValue_;\n    }\n\n    function setBondMaxRatePerDay(uint256 newVal_)\n      external\n      onlyDaoOrGuardian\n    {\n      BOND_MAX_RATE_PER_DAY = newVal_;\n    }\n\n    function setBondLifeMax(uint16 newVal_)\n      external\n      onlyDaoOrGuardian\n    {\n      BOND_LIFE_MAX = newVal_;\n    }\n\n    function setFeeBuyJuniorToken(uint256 newVal_)\n      external\n      onlyDaoOrGuardian\n    {\n      FEE_BUY_JUNIOR_TOKEN = newVal_;\n    }\n\n    function setFeeRedeemSeniorBond(uint256 newVal_)\n      external\n      onlyDaoOrGuardian\n    {\n      FEE_REDEEM_SENIOR_BOND = newVal_;\n    }\n\n    function setPaused(bool buyJToken_, bool buySBond_)\n      external\n      onlyDaoOrGuardian\n    {\n      PAUSED_BUY_JUNIOR_TOKEN = buyJToken_;\n      PAUSED_BUY_SENIOR_BOND = buySBond_;\n    }\n\n    function setOracle(address newVal_)\n      external\n      onlyDaoOrGuardian\n    {\n      oracle = newVal_;\n    }\n\n    function setBondModel(address newVal_)\n      external\n      onlyDaoOrGuardian\n    {\n      bondModel = newVal_;\n    }\n\n    function setFeesOwner(address newVal_)\n      external\n      onlyDaoOrGuardian\n    {\n      feesOwner = newVal_;\n    }\n}"
    }
  ]
}