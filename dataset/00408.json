{
  "Title": "H-3: BBLiquidation::_liquidateUser liquidator can bypass protocol fee on liquidation by returning returnedShare == borrowShare",
  "Content": "# Issue H-3: BBLiquidation::_liquidateUser liquidator can bypass protocol fee on liquidation by returning returnedShare == borrowShare \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/33 \n\n## Found by \ncergyk, duc\n## Summary\nWhen a liquidator liquidates a position on BigBang/Singularity market, they do not get the full liquidationBonus amount, but a callerShare which depends on the efficiency of the liquidation. \n\nHowever since this share is taken after the liquidator has swapped the seized collateral to an asset amount, the liquidator can simply choose to return enough asset to repay the borrow, reducing the extra amount to zero.\n\nIn that case the protocol fee and the caller share would be zero, but the liquidator has seized the full liquidation bonus during the swap.\n\n## Vulnerability Detail\n\nWe can see that after the collateral has been seized from the liquidatee, the full amount of collateral with the liquidation bonus is sent to an arbitrary `liquidationReceiver` during `_swapCollateralWithAsset`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLiquidation.sol#L262-L263\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLiquidation.sol#L152-L159\n\n\nThe liquidator can choose to send back only `borrowAmount` of asset, effectively keeping excess collateral to himself\n\n## Impact\nLiquidator steals the due fee from protocol during liquidation \n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider adding a slippage control to the swap executed by the liquidator (e.g the liquidator must return at least 105% of `borrowAmount`, when seizing 110% of equivalent collateral)\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nMedium.\nThe issue seems to be valid. However the user is not able to steal the full collateral, but only the bonus part, out of which he would have taken 90% anyway.\n\n**nevillehuang**\n\nrequest poc\n\n**sherlock-admin3**\n\nPoC requested from @CergyK\n\nRequests remaining: **3**\n\n**CergyK**\n\nPoc shared in a private repository\n\nThe poc demonstrates how a malicious liquidator can bypass protocol fees which as @cryptotechmaker noted are at least 10% of liquidation bonus, but can be 20% in the worst case.\n\nSince no prerequisite is needed to do that on any liquidation, and the loss of fees incurred on the protocol is unbounded, this warrants high severity IMO \n\n**CergyK**\n\nCoincidentally, the POC also demonstrates #32, since the price move used puts the user in bad debt but liquidation succeeds\n\n**nevillehuang**\n\n@cryptotechmaker Did you have a chance to look at this? I'm not sure if bypassing fees is high severity, I think I am inclined to keep medium\n\n**cryptotechmaker**\n\nYes, it's a valid issue @nevillehuang \n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/378.\n\n**CergyK**\n\nEscalate\n\nThis should be of high severity, as demonstrated, it enables to bypass protocol fees on any liquidation.\nFor reference, issue #148 which claims freezing of the same protocol fees is rated as high\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This should be of high severity, as demonstrated, it enables to bypass protocol fees on any liquidation.\n> For reference, issue #148 which claims freezing of the same protocol fees is rated as high\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@CergyK Fair enough, the impact is similar to #148 so could be high severity (albeit protocol fees are not locked, just completely lost)\n\n**cvetanovv**\n\nI agree with the escalation. The impact is the same as #148.\n\n**cvetanovv**\n\nPlanning to accept the escalation and make this issue a valid High.\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [CergyK](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/33/#issuecomment-2031295607): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLiquidation.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IMarketLiquidatorReceiver} from \"tapioca-periph/interfaces/bar/IMarketLiquidatorReceiver.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\n\n// solhint-disable max-line-length\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLiquidation is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NothingToLiquidate();\n    error LengthMismatch();\n    error ForbiddenAction();\n    error OnCollateralReceiverFailed();\n    error BadDebt();\n    error NotEnoughCollateral();\n    error Solvent();\n    error AmountNotValid();\n    error InsufficientLiquidationBonus();\n    error NotAuthorized();\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n\n    function liquidateBadDebt(\n        address user,\n        address from,\n        address receiver,\n        IMarketLiquidatorReceiver liquidatorReceiver,\n        bytes calldata liquidatorReceiverData,\n        bool swapCollateral\n    ) external onlyOwner {\n        _updateOracleRateForLiquidations();\n\n        //check from whitelist status\n        {\n            bool isWhitelisted = ICluster(penrose.cluster()).isWhitelisted(0, from);\n            if (!isWhitelisted) revert NotAuthorized();\n        }\n\n        // accrue before liquidation\n        _accrue();\n        penrose.reAccrueBigBangMarkets();\n\n        // compute borrow amount with bonus\n        uint256 elasticPart = totalBorrow.toElastic(userBorrowPart[user], false);\n        uint256 borrowAmountWithBonus = elasticPart + (elasticPart * liquidationMultiplier) / FEE_PRECISION;\n        uint256 requiredCollateral =\n            yieldBox.toShare(collateralId, (borrowAmountWithBonus * exchangeRate) / EXCHANGE_RATE_PRECISION, false);\n\n        uint256 collateralShare = userCollateralShare[user];\n        if (requiredCollateral < collateralShare) revert ForbiddenAction();\n\n        // update totalBorrow\n        uint256 borrowAmount = totalBorrow.toElastic(userBorrowPart[user], true);\n        totalBorrow.elastic -= borrowAmount.toUint128();\n        totalBorrow.base -= userBorrowPart[user].toUint128();\n\n        // update totalCollateralShare\n        totalCollateralShare -= collateralShare;\n\n        // set user share & part to 0\n        userCollateralShare[user] = 0;\n        userBorrowPart[user] = 0;\n\n        // burn debt amount from `from`\n        IUsdo(address(asset)).burn(from, borrowAmount);\n\n        // swap collateral with asset and send it to `owner`\n        if (swapCollateral) {\n            (, uint256 returnedAmount) =\n                _swapCollateralWithAsset(collateralShare, liquidatorReceiver, liquidatorReceiverData);\n            asset.safeTransfer(receiver, returnedAmount);\n        } else {\n            uint256 collateralAmount = yieldBox.toAmount(collateralId, collateralShare, false);\n            yieldBox.withdraw(collateralId, address(this), receiver, collateralAmount, 0);\n        }\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Entry point for liquidations.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user\n    /// @param minLiquidationBonuses minimum liquidation bonus acceptable\n    /// @param liquidatorReceivers IMarketLiquidatorReceiver array\n    /// @param liquidatorReceiverDatas IMarketLiquidatorReceiver datas\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        uint256[] calldata minLiquidationBonuses,\n        IMarketLiquidatorReceiver[] calldata liquidatorReceivers,\n        bytes[] calldata liquidatorReceiverDatas\n    ) external optionNotPaused(PauseType.Liquidation) nonReentrant {\n        if (users.length == 0) revert NothingToLiquidate();\n        if (users.length != maxBorrowParts.length) revert LengthMismatch();\n        if (users.length != liquidatorReceivers.length) revert LengthMismatch();\n        if (liquidatorReceiverDatas.length != liquidatorReceivers.length) {\n            revert LengthMismatch();\n        }\n\n        _updateOracleRateForLiquidations();\n\n        _accrue();\n        penrose.reAccrueBigBangMarkets();\n\n        _closedLiquidation(\n            users, maxBorrowParts, minLiquidationBonuses, liquidatorReceivers, liquidatorReceiverDatas, exchangeRate\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _swapCollateralWithAsset(\n        uint256 _collateralShare,\n        IMarketLiquidatorReceiver _liquidatorReceiver,\n        bytes memory _liquidatorReceiverData\n    ) private returns (uint256 returnedShare, uint256 returnedAmount) {\n        uint256 collateralAmount = yieldBox.toAmount(collateralId, _collateralShare, false);\n        yieldBox.withdraw(collateralId, address(this), address(_liquidatorReceiver), collateralAmount, 0);\n\n        uint256 assetBalanceBefore = asset.balanceOf(address(this));\n        //msg.sender should be validated against `initiator` on IMarketLiquidatorReceiver\n        _liquidatorReceiver.onCollateralReceiver(\n            msg.sender, address(collateral), address(asset), collateralAmount, _liquidatorReceiverData\n        );\n        uint256 assetBalanceAfter = asset.balanceOf(address(this));\n\n        returnedAmount = assetBalanceAfter - assetBalanceBefore;\n        if (returnedAmount == 0) revert OnCollateralReceiverFailed();\n        returnedShare = yieldBox.toShare(assetId, returnedAmount, false);\n    }\n\n    function _updateBorrowAndCollateralShare(\n        address user,\n        uint256 maxBorrowPart,\n        uint256 minLiquidationBonus, // min liquidation bonus to accept (default 0)\n        uint256 _exchangeRate\n    ) private returns (uint256 borrowAmount, uint256 borrowPart, uint256 collateralShare) {\n        if (_exchangeRate == 0) revert ExchangeRateNotValid();\n\n        // get collateral amount in asset's value\n        uint256 collateralPartInAsset = (\n            yieldBox.toAmount(collateralId, userCollateralShare[user], false) * EXCHANGE_RATE_PRECISION\n        ) / _exchangeRate;\n\n        // compute closing factor (liquidatable amount)\n        uint256 borrowPartWithBonus =\n            computeClosingFactor(userBorrowPart[user], collateralPartInAsset, FEE_PRECISION_DECIMALS);\n\n        // limit liquidable amount before bonus to the current debt\n        uint256 userTotalBorrowAmount = totalBorrow.toElastic(userBorrowPart[user], true);\n        borrowPartWithBonus = borrowPartWithBonus > userTotalBorrowAmount ? userTotalBorrowAmount : borrowPartWithBonus;\n\n        // check the amount to be repaid versus liquidator supplied limit\n        borrowPartWithBonus = borrowPartWithBonus > maxBorrowPart ? maxBorrowPart : borrowPartWithBonus;\n        borrowAmount = borrowPartWithBonus;\n\n        // compute part units, preventing rounding dust when liquidation is full\n        borrowPart = borrowAmount == userTotalBorrowAmount\n            ? userBorrowPart[user]\n            : totalBorrow.toBase(borrowPartWithBonus, false);\n        if (borrowPart == 0) revert Solvent();\n\n        if (liquidationBonusAmount > 0) {\n            borrowPartWithBonus = borrowPartWithBonus + (borrowPartWithBonus * liquidationBonusAmount) / FEE_PRECISION;\n        }\n\n        if (collateralPartInAsset < borrowPartWithBonus) {\n            if (collateralPartInAsset <= userTotalBorrowAmount) {\n                revert BadDebt();\n            }\n            // If current debt is covered by collateral fully\n            // then there is some liquidation bonus,\n            // so liquidation can proceed if liquidator's minimum is met\n            if (minLiquidationBonus > 0) {\n                // `collateralPartInAsset > borrowAmount` as `borrowAmount <= userTotalBorrowAmount`\n                uint256 effectiveBonus = ((collateralPartInAsset - borrowAmount) * FEE_PRECISION) / borrowAmount;\n                if (effectiveBonus < minLiquidationBonus) {\n                    revert InsufficientLiquidationBonus();\n                }\n                collateralShare = userCollateralShare[user];\n            } else {\n                revert InsufficientLiquidationBonus();\n            }\n        } else {\n            collateralShare =\n                yieldBox.toShare(collateralId, (borrowPartWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION, false);\n            if (collateralShare > userCollateralShare[user]) {\n                revert NotEnoughCollateral();\n            }\n        }\n\n        userBorrowPart[user] -= borrowPart;\n        userCollateralShare[user] -= collateralShare;\n    }\n\n    function _extractLiquidationFees(uint256 returnedShare, uint256 borrowShare, uint256 callerReward)\n        private\n        returns (uint256 feeShare, uint256 callerShare)\n    {\n        uint256 extraShare = returnedShare > borrowShare ? returnedShare - borrowShare : 0;\n        callerShare = (extraShare * callerReward) / FEE_PRECISION; //  y%  of profit goes to caller.\n        feeShare = extraShare - callerShare; // rest of the profit goes to fee.\n\n        //protocol fees should be kept in the contract as we do a yieldBox.depositAsset when we are extracting the fees using `refreshPenroseFees`\n        if (callerShare > 0) {\n            address(asset).safeApprove(address(yieldBox), type(uint256).max);\n            yieldBox.depositAsset(assetId, address(this), msg.sender, 0, callerShare);\n        }\n        address(asset).safeApprove(address(yieldBox), 0);\n    }\n\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        IMarketLiquidatorReceiver _liquidatorReceiver,\n        bytes calldata _liquidatorReceiverData,\n        uint256 _exchangeRate,\n        uint256 minLiquidationBonus\n    ) private {\n        uint256 callerReward = _getCallerReward(user, _exchangeRate);\n\n        (uint256 borrowAmount,, uint256 collateralShare) =\n            _updateBorrowAndCollateralShare(user, maxBorrowPart, minLiquidationBonus, _exchangeRate);\n        totalCollateralShare = totalCollateralShare > collateralShare ? totalCollateralShare - collateralShare : 0;\n\n        uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n        (uint256 returnedShare,) =\n            _swapCollateralWithAsset(collateralShare, _liquidatorReceiver, _liquidatorReceiverData);\n        if (returnedShare < borrowShare) revert AmountNotValid();\n\n        (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(returnedShare, borrowShare, callerReward);\n\n        IUsdo(address(asset)).burn(address(this), borrowAmount);\n\n        address[] memory _users = new address[](1);\n        _users[0] = user;\n        emit Liquidated(msg.sender, _users, callerShare, feeShare, borrowAmount, collateralShare);\n    }\n\n    struct __ClosedLiquidationCalldata {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        IMarketLiquidatorReceiver liquidatorReceiver;\n    }\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        uint256[] calldata minLiquidationBonuses,\n        IMarketLiquidatorReceiver[] calldata liquidatorReceivers,\n        bytes[] calldata liquidatorReceiverDatas,\n        uint256 _exchangeRate\n    ) private {\n        uint256 liquidatedCount = 0;\n        uint256 arrLength = users.length;\n\n        __ClosedLiquidationCalldata memory calldata_; // Stack too deep fix\n\n        for (uint256 i; i < arrLength;) {\n            calldata_.user = users[i];\n            calldata_.maxBorrowPart = maxBorrowParts[i];\n            calldata_.minLiquidationBonus = minLiquidationBonuses[i];\n            calldata_.liquidatorReceiver = liquidatorReceivers[i];\n\n            if (!_isSolvent(calldata_.user, _exchangeRate, true)) {\n                liquidatedCount++;\n                _liquidateUser(\n                    calldata_.user,\n                    calldata_.maxBorrowPart,\n                    calldata_.liquidatorReceiver,\n                    liquidatorReceiverDatas[i],\n                    _exchangeRate,\n                    calldata_.minLiquidationBonus\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(liquidatedCount != 0, \"BB: no users found\");\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLiquidation.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IMarketLiquidatorReceiver} from \"tapioca-periph/interfaces/bar/IMarketLiquidatorReceiver.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\n\n// solhint-disable max-line-length\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLiquidation is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error NothingToLiquidate();\n    error LengthMismatch();\n    error ForbiddenAction();\n    error OnCollateralReceiverFailed();\n    error BadDebt();\n    error NotEnoughCollateral();\n    error Solvent();\n    error AmountNotValid();\n    error InsufficientLiquidationBonus();\n    error NotAuthorized();\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n\n    function liquidateBadDebt(\n        address user,\n        address from,\n        address receiver,\n        IMarketLiquidatorReceiver liquidatorReceiver,\n        bytes calldata liquidatorReceiverData,\n        bool swapCollateral\n    ) external onlyOwner {\n        _updateOracleRateForLiquidations();\n\n        //check from whitelist status\n        {\n            bool isWhitelisted = ICluster(penrose.cluster()).isWhitelisted(0, from);\n            if (!isWhitelisted) revert NotAuthorized();\n        }\n\n        // accrue before liquidation\n        _accrue();\n        penrose.reAccrueBigBangMarkets();\n\n        // compute borrow amount with bonus\n        uint256 elasticPart = totalBorrow.toElastic(userBorrowPart[user], false);\n        uint256 borrowAmountWithBonus = elasticPart + (elasticPart * liquidationMultiplier) / FEE_PRECISION;\n        uint256 requiredCollateral =\n            yieldBox.toShare(collateralId, (borrowAmountWithBonus * exchangeRate) / EXCHANGE_RATE_PRECISION, false);\n\n        uint256 collateralShare = userCollateralShare[user];\n        if (requiredCollateral < collateralShare) revert ForbiddenAction();\n\n        // update totalBorrow\n        uint256 borrowAmount = totalBorrow.toElastic(userBorrowPart[user], true);\n        totalBorrow.elastic -= borrowAmount.toUint128();\n        totalBorrow.base -= userBorrowPart[user].toUint128();\n\n        // update totalCollateralShare\n        totalCollateralShare -= collateralShare;\n\n        // set user share & part to 0\n        userCollateralShare[user] = 0;\n        userBorrowPart[user] = 0;\n\n        // burn debt amount from `from`\n        IUsdo(address(asset)).burn(from, borrowAmount);\n\n        // swap collateral with asset and send it to `owner`\n        if (swapCollateral) {\n            (, uint256 returnedAmount) =\n                _swapCollateralWithAsset(collateralShare, liquidatorReceiver, liquidatorReceiverData);\n            asset.safeTransfer(receiver, returnedAmount);\n        } else {\n            uint256 collateralAmount = yieldBox.toAmount(collateralId, collateralShare, false);\n            yieldBox.withdraw(collateralId, address(this), receiver, collateralAmount, 0);\n        }\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Entry point for liquidations.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user\n    /// @param minLiquidationBonuses minimum liquidation bonus acceptable\n    /// @param liquidatorReceivers IMarketLiquidatorReceiver array\n    /// @param liquidatorReceiverDatas IMarketLiquidatorReceiver datas\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        uint256[] calldata minLiquidationBonuses,\n        IMarketLiquidatorReceiver[] calldata liquidatorReceivers,\n        bytes[] calldata liquidatorReceiverDatas\n    ) external optionNotPaused(PauseType.Liquidation) nonReentrant {\n        if (users.length == 0) revert NothingToLiquidate();\n        if (users.length != maxBorrowParts.length) revert LengthMismatch();\n        if (users.length != liquidatorReceivers.length) revert LengthMismatch();\n        if (liquidatorReceiverDatas.length != liquidatorReceivers.length) {\n            revert LengthMismatch();\n        }\n\n        _updateOracleRateForLiquidations();\n\n        _accrue();\n        penrose.reAccrueBigBangMarkets();\n\n        _closedLiquidation(\n            users, maxBorrowParts, minLiquidationBonuses, liquidatorReceivers, liquidatorReceiverDatas, exchangeRate\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _swapCollateralWithAsset(\n        uint256 _collateralShare,\n        IMarketLiquidatorReceiver _liquidatorReceiver,\n        bytes memory _liquidatorReceiverData\n    ) private returns (uint256 returnedShare, uint256 returnedAmount) {\n        uint256 collateralAmount = yieldBox.toAmount(collateralId, _collateralShare, false);\n        yieldBox.withdraw(collateralId, address(this), address(_liquidatorReceiver), collateralAmount, 0);\n\n        uint256 assetBalanceBefore = asset.balanceOf(address(this));\n        //msg.sender should be validated against `initiator` on IMarketLiquidatorReceiver\n        _liquidatorReceiver.onCollateralReceiver(\n            msg.sender, address(collateral), address(asset), collateralAmount, _liquidatorReceiverData\n        );\n        uint256 assetBalanceAfter = asset.balanceOf(address(this));\n\n        returnedAmount = assetBalanceAfter - assetBalanceBefore;\n        if (returnedAmount == 0) revert OnCollateralReceiverFailed();\n        returnedShare = yieldBox.toShare(assetId, returnedAmount, false);\n    }\n\n    function _updateBorrowAndCollateralShare(\n        address user,\n        uint256 maxBorrowPart,\n        uint256 minLiquidationBonus, // min liquidation bonus to accept (default 0)\n        uint256 _exchangeRate\n    ) private returns (uint256 borrowAmount, uint256 borrowPart, uint256 collateralShare) {\n        if (_exchangeRate == 0) revert ExchangeRateNotValid();\n\n        // get collateral amount in asset's value\n        uint256 collateralPartInAsset = (\n            yieldBox.toAmount(collateralId, userCollateralShare[user], false) * EXCHANGE_RATE_PRECISION\n        ) / _exchangeRate;\n\n        // compute closing factor (liquidatable amount)\n        uint256 borrowPartWithBonus =\n            computeClosingFactor(userBorrowPart[user], collateralPartInAsset, FEE_PRECISION_DECIMALS);\n\n        // limit liquidable amount before bonus to the current debt\n        uint256 userTotalBorrowAmount = totalBorrow.toElastic(userBorrowPart[user], true);\n        borrowPartWithBonus = borrowPartWithBonus > userTotalBorrowAmount ? userTotalBorrowAmount : borrowPartWithBonus;\n\n        // check the amount to be repaid versus liquidator supplied limit\n        borrowPartWithBonus = borrowPartWithBonus > maxBorrowPart ? maxBorrowPart : borrowPartWithBonus;\n        borrowAmount = borrowPartWithBonus;\n\n        // compute part units, preventing rounding dust when liquidation is full\n        borrowPart = borrowAmount == userTotalBorrowAmount\n            ? userBorrowPart[user]\n            : totalBorrow.toBase(borrowPartWithBonus, false);\n        if (borrowPart == 0) revert Solvent();\n\n        if (liquidationBonusAmount > 0) {\n            borrowPartWithBonus = borrowPartWithBonus + (borrowPartWithBonus * liquidationBonusAmount) / FEE_PRECISION;\n        }\n\n        if (collateralPartInAsset < borrowPartWithBonus) {\n            if (collateralPartInAsset <= userTotalBorrowAmount) {\n                revert BadDebt();\n            }\n            // If current debt is covered by collateral fully\n            // then there is some liquidation bonus,\n            // so liquidation can proceed if liquidator's minimum is met\n            if (minLiquidationBonus > 0) {\n                // `collateralPartInAsset > borrowAmount` as `borrowAmount <= userTotalBorrowAmount`\n                uint256 effectiveBonus = ((collateralPartInAsset - borrowAmount) * FEE_PRECISION) / borrowAmount;\n                if (effectiveBonus < minLiquidationBonus) {\n                    revert InsufficientLiquidationBonus();\n                }\n                collateralShare = userCollateralShare[user];\n            } else {\n                revert InsufficientLiquidationBonus();\n            }\n        } else {\n            collateralShare =\n                yieldBox.toShare(collateralId, (borrowPartWithBonus * _exchangeRate) / EXCHANGE_RATE_PRECISION, false);\n            if (collateralShare > userCollateralShare[user]) {\n                revert NotEnoughCollateral();\n            }\n        }\n\n        userBorrowPart[user] -= borrowPart;\n        userCollateralShare[user] -= collateralShare;\n    }\n\n    function _extractLiquidationFees(uint256 returnedShare, uint256 borrowShare, uint256 callerReward)\n        private\n        returns (uint256 feeShare, uint256 callerShare)\n    {\n        uint256 extraShare = returnedShare > borrowShare ? returnedShare - borrowShare : 0;\n        callerShare = (extraShare * callerReward) / FEE_PRECISION; //  y%  of profit goes to caller.\n        feeShare = extraShare - callerShare; // rest of the profit goes to fee.\n\n        //protocol fees should be kept in the contract as we do a yieldBox.depositAsset when we are extracting the fees using `refreshPenroseFees`\n        if (callerShare > 0) {\n            address(asset).safeApprove(address(yieldBox), type(uint256).max);\n            yieldBox.depositAsset(assetId, address(this), msg.sender, 0, callerShare);\n        }\n        address(asset).safeApprove(address(yieldBox), 0);\n    }\n\n    function _liquidateUser(\n        address user,\n        uint256 maxBorrowPart,\n        IMarketLiquidatorReceiver _liquidatorReceiver,\n        bytes calldata _liquidatorReceiverData,\n        uint256 _exchangeRate,\n        uint256 minLiquidationBonus\n    ) private {\n        uint256 callerReward = _getCallerReward(user, _exchangeRate);\n\n        (uint256 borrowAmount,, uint256 collateralShare) =\n            _updateBorrowAndCollateralShare(user, maxBorrowPart, minLiquidationBonus, _exchangeRate);\n        totalCollateralShare = totalCollateralShare > collateralShare ? totalCollateralShare - collateralShare : 0;\n\n        uint256 borrowShare = yieldBox.toShare(assetId, borrowAmount, true);\n\n        (uint256 returnedShare,) =\n            _swapCollateralWithAsset(collateralShare, _liquidatorReceiver, _liquidatorReceiverData);\n        if (returnedShare < borrowShare) revert AmountNotValid();\n\n        (uint256 feeShare, uint256 callerShare) = _extractLiquidationFees(returnedShare, borrowShare, callerReward);\n\n        IUsdo(address(asset)).burn(address(this), borrowAmount);\n\n        address[] memory _users = new address[](1);\n        _users[0] = user;\n        emit Liquidated(msg.sender, _users, callerShare, feeShare, borrowAmount, collateralShare);\n    }\n\n    struct __ClosedLiquidationCalldata {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        IMarketLiquidatorReceiver liquidatorReceiver;\n    }\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        uint256[] calldata minLiquidationBonuses,\n        IMarketLiquidatorReceiver[] calldata liquidatorReceivers,\n        bytes[] calldata liquidatorReceiverDatas,\n        uint256 _exchangeRate\n    ) private {\n        uint256 liquidatedCount = 0;\n        uint256 arrLength = users.length;\n\n        __ClosedLiquidationCalldata memory calldata_; // Stack too deep fix\n\n        for (uint256 i; i < arrLength;) {\n            calldata_.user = users[i];\n            calldata_.maxBorrowPart = maxBorrowParts[i];\n            calldata_.minLiquidationBonus = minLiquidationBonuses[i];\n            calldata_.liquidatorReceiver = liquidatorReceivers[i];\n\n            if (!_isSolvent(calldata_.user, _exchangeRate, true)) {\n                liquidatedCount++;\n                _liquidateUser(\n                    calldata_.user,\n                    calldata_.maxBorrowPart,\n                    calldata_.liquidatorReceiver,\n                    liquidatorReceiverDatas[i],\n                    _exchangeRate,\n                    calldata_.minLiquidationBonus\n                );\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(liquidatedCount != 0, \"BB: no users found\");\n    }\n}"
    }
  ]
}