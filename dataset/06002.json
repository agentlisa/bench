{
  "Title": "[M-08] Return value of low level `call` not checked",
  "Content": "\n<https://github.com/code-423n4/2023-08-goodentry/blob/71c0c0eca8af957202ccdbf5ce2f2a514ffe2e24/contracts/helper/V3Proxy.sol#L156> \n\n<https://github.com/code-423n4/2023-08-goodentry/blob/71c0c0eca8af957202ccdbf5ce2f2a514ffe2e24/contracts/helper/V3Proxy.sol#L174> \n\n<https://github.com/code-423n4/2023-08-goodentry/blob/71c0c0eca8af957202ccdbf5ce2f2a514ffe2e24/contracts/helper/V3Proxy.sol#L192>\n\n### Impact\n\nIf the `msg.sender` is a contract and its `receive()` function has the potential to revert, the code `payable(msg.sender).call{value:wad}(\"\")` could potentially return a false result, which is not being verified. As a result, the calling functions may exit without successfully returning ethers to senders.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-08-goodentry/blob/71c0c0eca8af957202ccdbf5ce2f2a514ffe2e24/contracts/helper/V3Proxy.sol#L147C1-L158C6> \n\n<https://github.com/code-423n4/2023-08-goodentry/blob/71c0c0eca8af957202ccdbf5ce2f2a514ffe2e24/contracts/helper/V3Proxy.sol#L160C1-L176C6> \n\n<https://github.com/code-423n4/2023-08-goodentry/blob/71c0c0eca8af957202ccdbf5ce2f2a514ffe2e24/contracts/helper/V3Proxy.sol#L178C1-L194C6>\n\n### PoC using Foundry:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\n\ncontract CallerContract {\n\n    VaultContract private vaultAddress;\n    constructor(VaultContract _vaultAddr) payable {\n        vaultAddress = _vaultAddr;\n    }\n\n    receive() payable external {\n        revert();\n    }\n\n    function claim(uint256 amount) public {\n        vaultAddress.claimEther(amount);\n    }\n\n}\n\ncontract VaultContract {\n    CallerContract private callerContract;\n    constructor() payable {}\n\n    receive() payable external {\n        revert();\n    }\n\n    function claimEther(uint256 amount) public {\n        require(amount <= 3 ether, \"Cannot claim more than 3 ether\");\n        msg.sender.call{value:amount}(\"\");\n        //(bool sent,) = msg.sender.call{value: amount}(\"\");\n        //require(sent, \"sent failed\");\n    }\n\n    function sendEither() payable external {\n        callerContract.claim(3 ether);\n    }\n\n    function setCaller(CallerContract _caller) public {\n        callerContract = _caller;\n    }\n\n}\n\ncontract CallReturnValueNotCheckedTest is Test {\n\n    address public Bob;\n    VaultContract public vaultContract;\n    CallerContract public callerContract;\n\n    function setUp() public {\n        Bob = makeAddr(\"Bob\");\n        vaultContract = new VaultContract();\n        callerContract = new CallerContract(vaultContract);\n        vaultContract.setCaller(callerContract);\n        deal(Bob, 10 ether);\n    }\n\n    function test_callReturnNotChecked() public {\n        console2.log(\"Before calling: Bob balance is %d ether\", Bob.balance / 1e18);\n        console2.log(\"Before calling: Vault balance is %d ether\", address(vaultContract).balance / 1e18);\n        console2.log(\"Bob sends 3 ether\");\n        vm.startPrank(Bob);\n        //vm.expectRevert();\n        vaultContract.sendEither{value: 3 ether}();\n        console2.log(\"After  calling: Bob balance is %d ether\", Bob.balance / 1e18);\n        console2.log(\"After  calling: Vault balance is %d ether\", address(vaultContract).balance / 1e18);\n        vm.stopPrank();\n\n    }\n}\n\n```\n\nThe output is:\n\n```log\nRunning 1 test for test/ReturnValueTest.t.sol:CallReturnValueNotCheckedTest\n[PASS] test_callReturnNotChecked() (gas: 42207)\nLogs:\n  Before calling: Bob balance is 10 ether\n  Before calling: Vault balance is 0 ether\n  Bob sends 3 ether\n  After  calling: Bob balance is 7 ether\n  After  calling: Vault balance is 3 ether\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 762.13Âµs\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\nThe caller contract fails to receive ether, but the whole transaction is not reverted. As a result, the ether will be locked in the `Vault` contract.\n\nThis issue can be prevented by adding logic to check the return value of `call`.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\n\ncontract CallerContract {\n\n    VaultContract private vaultAddress;\n    constructor(VaultContract _vaultAddr) payable {\n        vaultAddress = _vaultAddr;\n    }\n\n    receive() payable external {\n        revert();\n    }\n\n    function claim(uint256 amount) public {\n        vaultAddress.claimEther(amount);\n    }\n\n}\n\ncontract VaultContract {\n    CallerContract private callerContract;\n    constructor() payable {}\n\n    receive() payable external {\n        revert();\n    }\n\n    function claimEther(uint256 amount) public {\n        require(amount <= 3 ether, \"Cannot claim more than 3 ether\");\n        //msg.sender.call{value:amount}(\"\");\n        (bool sent,) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"sent failed\");\n    }\n\n    function sendEither() payable external {\n        callerContract.claim(3 ether);\n    }\n\n    function setCaller(CallerContract _caller) public {\n        callerContract = _caller;\n    }\n\n}\n\ncontract CallReturnValueNotCheckedTest is Test {\n\n    address public Bob;\n    VaultContract public vaultContract;\n    CallerContract public callerContract;\n\n    function setUp() public {\n        Bob = makeAddr(\"Bob\");\n        vaultContract = new VaultContract();\n        callerContract = new CallerContract(vaultContract);\n        vaultContract.setCaller(callerContract);\n        deal(Bob, 10 ether);\n    }\n\n    function test_callReturnNotChecked() public {\n        console2.log(\"Before calling: Bob balance is %d ether\", Bob.balance / 1e18);\n        console2.log(\"Before calling: Vault balance is %d ether\", address(vaultContract).balance / 1e18);\n        console2.log(\"Bob sends 3 ether\");\n        vm.startPrank(Bob);\n        //vm.expectRevert();\n        vaultContract.sendEither{value: 3 ether}();\n        console2.log(\"After  calling: Bob balance is %d ether\", Bob.balance / 1e18);\n        console2.log(\"After  calling: Vault balance is %d ether\", address(vaultContract).balance / 1e18);\n        vm.stopPrank();\n\n    }\n\n    function test_callReturnChecked_revert() public {\n        console2.log(\"Before calling: Bob balance is %d ether\", Bob.balance / 1e18);\n        console2.log(\"Before calling: Vault balance is %d ether\", address(vaultContract).balance / 1e18);\n        console2.log(\"Bob sends 3 ether\");\n        vm.startPrank(Bob);\n        vm.expectRevert();\n        vaultContract.sendEither{value: 3 ether}();\n        console2.log(\"After  calling: Bob balance is %d ether\", Bob.balance / 1e18);\n        console2.log(\"After  calling: Vault balance is %d ether\", address(vaultContract).balance / 1e18);\n        vm.stopPrank();\n\n    }\n}\n```\n\nOutput of modified code:\n\n```log\nRunning 1 test for test/ReturnValueTest.t.sol:CallReturnValueNotCheckedTest\n[PASS] test_callReturnChecked_revert() (gas: 42788)\nLogs:\n  Before calling: Bob balance is 10 ether\n  Before calling: Vault balance is 0 ether\n  Bob sends 3 ether\n  After  calling: Bob balance is 10 ether\n  After  calling: Vault balance is 0 ether\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 6.60ms\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\nNow the ether is returned back if call is failed.\n\n</details>\n\n### Recommended Mitigation Steps\n\nIt's recommended to check the return value to be true or just use OpenZeppelin `Address` library `sendValue()` function for ether transfer. See <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/utils/Address.sol#L64> .\n\n**[Keref (Good Entry) confirmed and commented](https://github.com/code-423n4/2023-08-goodentry-findings/issues/83#issuecomment-1683240488):**\n > See [PR#3](https://github.com/GoodEntry-io/ge/pull/3).\n\n**Status:** Not fully mitigated. Full details in reports from [kutugu](https://github.com/code-423n4/2023-09-goodentry-mitigation-findings/issues/41) and [3docSec](https://github.com/code-423n4/2023-09-goodentry-mitigation-findings/issues/3), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-goodentry",
  "Code": [
    {
      "filename": "contracts/helper/V3Proxy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.19;\nimport \"../openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\"; \n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n    function refundETH() external payable;\n    function WETH9() external view returns (address);\n}\n\n\ninterface IQuoter {\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n    \n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n\ninterface IWETH9 is IERC20 {\n    function withdraw(uint) external;\n}\n\ncontract V3Proxy is ReentrancyGuard, Ownable {\n    using SafeERC20 for ERC20;\n    ISwapRouter immutable public ROUTER;\n    IQuoter     immutable public QUOTER;\n    uint24      immutable public feeTier; \n    bool acceptPayable;\n    \n    event Swap(\n        address indexed user, \n        address indexed assetIn,\n        address indexed assetOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    \n    constructor(ISwapRouter _router, IQuoter _quoter, uint24 _fee) {\n        ROUTER = _router;\n        QUOTER = _quoter;\n        feeTier = _fee;\n    \n    }\n    \n    function WETH() external view returns (address) {\n        return ROUTER.WETH9();\n    }     \n    \n    receive() external payable {\n        require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    fallback() external payable {\n       require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    function emergencyWithdraw(ERC20 token) onlyOwner external {   \n        token.safeTransfer(msg.sender, token.balanceOf( address(this) ) );  // msg.sender has been Required to be owner\n    }\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = amountIn;\n        amounts[1] = QUOTER.quoteExactInputSingle(path[0], path[1], feeTier, amountIn, 0);\n    }\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = QUOTER.quoteExactOutputSingle(path[0], path[1], feeTier, amountOut, 0);\n        amounts[1] = amountOut;\n    }\n\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeTransfer(msg.sender, ogInAsset.balanceOf(address(this)));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = msg.value;         \n        amounts[1] = ROUTER.exactInputSingle{value: msg.value}(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, msg.value, amountOutMin, 0));\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);  \n    }\n\n    \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle{value: msg.value}(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, msg.value, 0));         \n        amounts[1] = amountOut;\n        acceptPayable = true;\n        ROUTER.refundETH();\n        acceptPayable = false;\n        msg.sender.call{value: msg.value - amounts[0]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n    \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, address(this), deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeApprove(address(ROUTER), 0);\n        IWETH9 weth = IWETH9(ROUTER.WETH9());\n        acceptPayable = true;\n        weth.withdraw(amountOut);\n        acceptPayable = false;\n        payable(msg.sender).call{value: amountOut}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n       \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, address(this), deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0); \n        IWETH9 weth = IWETH9(ROUTER.WETH9());\n        acceptPayable = true;\n        weth.withdraw(amounts[1]);\n        acceptPayable = false;\n        payable(msg.sender).call{value: amounts[1]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);                 \n    }\n\n}"
    },
    {
      "filename": "contracts/helper/V3Proxy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.19;\nimport \"../openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\"; \n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n    function refundETH() external payable;\n    function WETH9() external view returns (address);\n}\n\n\ninterface IQuoter {\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n    \n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n\ninterface IWETH9 is IERC20 {\n    function withdraw(uint) external;\n}\n\ncontract V3Proxy is ReentrancyGuard, Ownable {\n    using SafeERC20 for ERC20;\n    ISwapRouter immutable public ROUTER;\n    IQuoter     immutable public QUOTER;\n    uint24      immutable public feeTier; \n    bool acceptPayable;\n    \n    event Swap(\n        address indexed user, \n        address indexed assetIn,\n        address indexed assetOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    \n    constructor(ISwapRouter _router, IQuoter _quoter, uint24 _fee) {\n        ROUTER = _router;\n        QUOTER = _quoter;\n        feeTier = _fee;\n    \n    }\n    \n    function WETH() external view returns (address) {\n        return ROUTER.WETH9();\n    }     \n    \n    receive() external payable {\n        require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    fallback() external payable {\n       require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    function emergencyWithdraw(ERC20 token) onlyOwner external {   \n        token.safeTransfer(msg.sender, token.balanceOf( address(this) ) );  // msg.sender has been Required to be owner\n    }\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = amountIn;\n        amounts[1] = QUOTER.quoteExactInputSingle(path[0], path[1], feeTier, amountIn, 0);\n    }\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = QUOTER.quoteExactOutputSingle(path[0], path[1], feeTier, amountOut, 0);\n        amounts[1] = amountOut;\n    }\n\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeTransfer(msg.sender, ogInAsset.balanceOf(address(this)));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = msg.value;         \n        amounts[1] = ROUTER.exactInputSingle{value: msg.value}(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, msg.value, amountOutMin, 0));\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);  \n    }\n\n    \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle{value: msg.value}(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, msg.value, 0));         \n        amounts[1] = amountOut;\n        acceptPayable = true;\n        ROUTER.refundETH();\n        acceptPayable = false;\n        msg.sender.call{value: msg.value - amounts[0]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n    \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, address(this), deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeApprove(address(ROUTER), 0);\n        IWETH9 weth = IWETH9(ROUTER.WETH9());\n        acceptPayable = true;\n        weth.withdraw(amountOut);\n        acceptPayable = false;\n        payable(msg.sender).call{value: amountOut}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n       \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, address(this), deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0); \n        IWETH9 weth = IWETH9(ROUTER.WETH9());\n        acceptPayable = true;\n        weth.withdraw(amounts[1]);\n        acceptPayable = false;\n        payable(msg.sender).call{value: amounts[1]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);                 \n    }\n\n}"
    },
    {
      "filename": "contracts/helper/V3Proxy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.19;\nimport \"../openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\"; \n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n    function refundETH() external payable;\n    function WETH9() external view returns (address);\n}\n\n\ninterface IQuoter {\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n    \n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n\ninterface IWETH9 is IERC20 {\n    function withdraw(uint) external;\n}\n\ncontract V3Proxy is ReentrancyGuard, Ownable {\n    using SafeERC20 for ERC20;\n    ISwapRouter immutable public ROUTER;\n    IQuoter     immutable public QUOTER;\n    uint24      immutable public feeTier; \n    bool acceptPayable;\n    \n    event Swap(\n        address indexed user, \n        address indexed assetIn,\n        address indexed assetOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    \n    constructor(ISwapRouter _router, IQuoter _quoter, uint24 _fee) {\n        ROUTER = _router;\n        QUOTER = _quoter;\n        feeTier = _fee;\n    \n    }\n    \n    function WETH() external view returns (address) {\n        return ROUTER.WETH9();\n    }     \n    \n    receive() external payable {\n        require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    fallback() external payable {\n       require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    function emergencyWithdraw(ERC20 token) onlyOwner external {   \n        token.safeTransfer(msg.sender, token.balanceOf( address(this) ) );  // msg.sender has been Required to be owner\n    }\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = amountIn;\n        amounts[1] = QUOTER.quoteExactInputSingle(path[0], path[1], feeTier, amountIn, 0);\n    }\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = QUOTER.quoteExactOutputSingle(path[0], path[1], feeTier, amountOut, 0);\n        amounts[1] = amountOut;\n    }\n\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeTransfer(msg.sender, ogInAsset.balanceOf(address(this)));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = msg.value;         \n        amounts[1] = ROUTER.exactInputSingle{value: msg.value}(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, msg.value, amountOutMin, 0));\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);  \n    }\n\n    \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle{value: msg.value}(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, msg.value, 0));         \n        amounts[1] = amountOut;\n        acceptPayable = true;\n        ROUTER.refundETH();\n        acceptPayable = false;\n        msg.sender.call{value: msg.value - amounts[0]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n    \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, address(this), deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeApprove(address(ROUTER), 0);\n        IWETH9 weth = IWETH9(ROUTER.WETH9());\n        acceptPayable = true;\n        weth.withdraw(amountOut);\n        acceptPayable = false;\n        payable(msg.sender).call{value: amountOut}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n       \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, address(this), deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0); \n        IWETH9 weth = IWETH9(ROUTER.WETH9());\n        acceptPayable = true;\n        weth.withdraw(amounts[1]);\n        acceptPayable = false;\n        payable(msg.sender).call{value: amounts[1]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);                 \n    }\n\n}"
    },
    {
      "filename": "contracts/helper/V3Proxy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.19;\nimport \"../openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\"; \n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n    function refundETH() external payable;\n    function WETH9() external view returns (address);\n}\n\n\ninterface IQuoter {\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n    \n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n\ninterface IWETH9 is IERC20 {\n    function withdraw(uint) external;\n}\n\ncontract V3Proxy is ReentrancyGuard, Ownable {\n    using SafeERC20 for ERC20;\n    ISwapRouter immutable public ROUTER;\n    IQuoter     immutable public QUOTER;\n    uint24      immutable public feeTier; \n    bool acceptPayable;\n    \n    event Swap(\n        address indexed user, \n        address indexed assetIn,\n        address indexed assetOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    \n    constructor(ISwapRouter _router, IQuoter _quoter, uint24 _fee) {\n        ROUTER = _router;\n        QUOTER = _quoter;\n        feeTier = _fee;\n    \n    }\n    \n    function WETH() external view returns (address) {\n        return ROUTER.WETH9();\n    }     \n    \n    receive() external payable {\n        require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    fallback() external payable {\n       require(acceptPayable, \"CannotReceiveETH\");\n    }\n    \n    function emergencyWithdraw(ERC20 token) onlyOwner external {   \n        token.safeTransfer(msg.sender, token.balanceOf( address(this) ) );  // msg.sender has been Required to be owner\n    }\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = amountIn;\n        amounts[1] = QUOTER.quoteExactInputSingle(path[0], path[1], feeTier, amountIn, 0);\n    }\n\n    function getAmountsIn(uint amountOut, address[] calldata path) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        amounts = new uint[](2);\n        amounts[0] = QUOTER.quoteExactOutputSingle(path[0], path[1], feeTier, amountOut, 0);\n        amounts[1] = amountOut;\n    }\n\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountIn);\n        ogInAsset.safeApprove(address(ROUTER), amountIn);\n        amounts = new uint[](2);\n        amounts[0] = amountIn;         \n        amounts[1] = ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountIn, amountOutMin, 0));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, amountInMax, 0));         \n        amounts[1] = amountOut; \n        ogInAsset.safeTransfer(msg.sender, ogInAsset.balanceOf(address(this)));\n        ogInAsset.safeApprove(address(ROUTER), 0);\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = msg.value;         \n        amounts[1] = ROUTER.exactInputSingle{value: msg.value}(ISwapRouter.ExactInputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, msg.value, amountOutMin, 0));\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]);  \n    }\n\n    \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[0] == ROUTER.WETH9(), \"Invalid path\");\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle{value: msg.value}(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, msg.sender, deadline, amountOut, msg.value, 0));         \n        amounts[1] = amountOut;\n        acceptPayable = true;\n        ROUTER.refundETH();\n        acceptPayable = false;\n        msg.sender.call{value: msg.value - amounts[0]}(\"\");\n        emit Swap(msg.sender, path[0], path[1], amounts[0], amounts[1]); \n    }\n    \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) payable external returns (uint[] memory amounts) {\n        require(path.length == 2, \"Direct swap only\");\n        require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n        ERC20 ogInAsset = ERC20(path[0]);\n        ogInAsset.safeTransferFrom(msg.sender, address(this), amountInMax);\n        ogInAsset.safeApprove(address(ROUTER), amountInMax);\n        amounts = new uint[](2);\n        amounts[0] = ROUTER.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(path[0], path[1], feeTier, address(this)"
    }
  ]
}