{
  "Title": "[M-12] `ArbitrumCoreBranchRouter.executeNoSettlement` can't handle `0x07`  function",
  "Content": "\n`ArbitrumCoreBranchRouter.executeNoSettlement` can't handle the `setCoreBranchRouter` function.\n\n### Proof of Concept\n\nArbitrumCoreBranchRouter extends CoreBranchRouter and overrides its `executeNoSettlement` function.\n`CoreBranchRouter.executeNoSettlement` [can handle the 0x07 function](https://github.com/code-423n4/2023-09-maia/blob/main/src/CoreBranchRouter.sol#L140-L146), but `ArbitrumCoreBranchRouter.executeNoSettlement` [can't](https://github.com/code-423n4/2023-09-maia/blob/main/src/ArbitrumCoreBranchRouter.sol#L168-L170).\n\nI believe this is because previously `CoreBranchRouter.executeNoSettlement` also [didn't handle 0x07 function](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/CoreBranchRouter.sol#L278-L280) and when support for it was added, ArbitrumCoreBranchRouter was not updated with new function.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nAdd support of `0x07` function.\n\n### Assessed type\n\nError\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/187#issuecomment-1765038962)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/187#issuecomment-1807198568):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/4d2825cd4e73a69ad33bccaf2ceb07443f127beb).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/CoreBranchRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\nimport {IBranchBridgeAgent as IBridgeAgent, GasParams} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchBridgeAgentFactory as IBridgeAgentFactory} from \"./interfaces/IBranchBridgeAgentFactory.sol\";\nimport {IBranchRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {ICoreBranchRouter} from \"./interfaces/ICoreBranchRouter.sol\";\nimport {IERC20hTokenBranchFactory as ITokenFactory} from \"./interfaces/IERC20hTokenBranchFactory.sol\";\n\nimport {BaseBranchRouter} from \"./BaseBranchRouter.sol\";\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Core Branch Router Contract\n/// @author MaiaDAO\ncontract CoreBranchRouter is ICoreBranchRouter, BaseBranchRouter {\n    /// @notice hToken Factory Address.\n    address public immutable hTokenFactoryAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Core Branch Router.\n     * @param _hTokenFactoryAddress Branch hToken Factory Address.\n     */\n    constructor(address _hTokenFactoryAddress) BaseBranchRouter() {\n        hTokenFactoryAddress = _hTokenFactoryAddress;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice This function is used to add a global token to a branch.\n     * @param _globalAddress Address of the token to be added.\n     * @param _dstChainId Chain Id of the chain to which the deposit is being added.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addGlobalToken(address _globalAddress, uint256 _dstChainId, GasParams[3] calldata _gParams)\n        external\n        payable\n    {\n        // Encode Call Data\n        bytes memory params = abi.encode(msg.sender, _globalAddress, _dstChainId, [_gParams[1], _gParams[2]]);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x01), params);\n\n        // Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).callOut{value: msg.value}(payable(msg.sender), payload, _gParams[0]);\n    }\n\n    /**\n     * @notice This function is used to add a local token to the system.\n     * @param _underlyingAddress Address of the underlying token to be added.\n     * @param _gParams Gas parameters for remote execution.\n     */\n    function addLocalToken(address _underlyingAddress, GasParams calldata _gParams) external payable virtual {\n        //Get Token Info\n        uint8 decimals = ERC20(_underlyingAddress).decimals();\n\n        //Create Token\n        ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(\n            ERC20(_underlyingAddress).name(), ERC20(_underlyingAddress).symbol(), decimals, true\n        );\n\n        //Encode Data\n        bytes memory params = abi.encode(_underlyingAddress, newToken, newToken.name(), newToken.symbol(), decimals);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x02), params);\n\n        //Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(msg.sender), payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYERZERO EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function executeNoSettlement(bytes calldata _params) external payable virtual override requiresAgentExecutor {\n        /// _receiveAddGlobalToken\n        if (_params[0] == 0x01) {\n            (\n                address globalAddress,\n                string memory name,\n                string memory symbol,\n                uint8 decimals,\n                address refundee,\n                GasParams memory gParams\n            ) = abi.decode(_params[1:], (address, string, string, uint8, address, GasParams));\n\n            _receiveAddGlobalToken(globalAddress, name, symbol, decimals, refundee, gParams);\n            /// _receiveAddBridgeAgent\n        } else if (_params[0] == 0x02) {\n            (\n                address newBranchRouter,\n                address branchBridgeAgentFactory,\n                address rootBridgeAgent,\n                address rootBridgeAgentFactory,\n                address refundee,\n                GasParams memory gParams\n            ) = abi.decode(_params[1:], (address, address, address, address, address, GasParams));\n\n            _receiveAddBridgeAgent(\n                newBranchRouter, branchBridgeAgentFactory, rootBridgeAgent, rootBridgeAgentFactory, refundee, gParams\n            );\n\n            /// _toggleBranchBridgeAgentFactory\n        } else if (_params[0] == 0x03) {\n            (address bridgeAgentFactoryAddress) = abi.decode(_params[1:], (address));\n\n            _toggleBranchBridgeAgentFactory(bridgeAgentFactoryAddress);\n\n            /// _removeBranchBridgeAgent\n        } else if (_params[0] == 0x04) {\n            (address branchBridgeAgent) = abi.decode(_params[1:], (address));\n\n            _removeBranchBridgeAgent(branchBridgeAgent);\n\n            /// _manageStrategyToken\n        } else if (_params[0] == 0x05) {\n            (address underlyingToken, uint256 minimumReservesRatio) = abi.decode(_params[1:], (address, uint256));\n\n            _manageStrategyToken(underlyingToken, minimumReservesRatio);\n\n            /// _managePortStrategy\n        } else if (_params[0] == 0x06) {\n            (address portStrategy, address underlyingToken, uint256 dailyManagementLimit, bool isUpdateDailyLimit) =\n                abi.decode(_params[1:], (address, address, uint256, bool));\n\n            _managePortStrategy(portStrategy, underlyingToken, dailyManagementLimit, isUpdateDailyLimit);\n\n            /// _setCoreBranchRouter\n        } else if (_params[0] == 0x07) {\n            (address coreBranchRouter, address coreBranchBridgeAgent) = abi.decode(_params[1:], (address, address));\n\n            IPort(localPortAddress).setCoreBranchRouter(coreBranchRouter, coreBranchBridgeAgent);\n\n            /// Unrecognized Function Selector\n        } else {\n            revert UnrecognizedFunctionId();\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain.\n     *         Must be called from another chain.\n     *  @param _globalAddress the address of the global virtualized token.\n     *  @param _name token name.\n     *  @param _symbol token symbol.\n     *  @param _refundee the address of the excess gas receiver.\n     *  @param _gParams Gas parameters for remote execution.\n     *  @dev FUNC ID: 1\n     *  @dev all hTokens have 18 decimals.\n     */\n    function _receiveAddGlobalToken(\n        address _globalAddress,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _refundee,\n        GasParams memory _gParams\n    ) internal {\n        //Create Token\n        ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(_name, _symbol, _decimals, false);\n\n        // Encode Data\n        bytes memory params = abi.encode(_globalAddress, newToken);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x03), params);\n\n        //Send Cross-Chain request\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(_refundee), payload, _gParams);\n    }\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain.\n     *         Must be called from another chain.\n     *    @param _newBranchRouter the address of the new branch router.\n     *    @param _branchBridgeAgentFactory the address of the branch bridge agent factory.\n     *    @param _rootBridgeAgent the address of the root bridge agent.\n     *    @param _rootBridgeAgentFactory the address of the root bridge agent factory.\n     *    @param _refundee the address of the excess gas receiver.\n     *    @param _gParams Gas parameters for remote execution.\n     *    @dev FUNC ID: 2\n     *    @dev all hTokens have 18 decimals.\n     */\n    function _receiveAddBridgeAgent(\n        address _newBranchRouter,\n        address _branchBridgeAgentFactory,\n        address _rootBridgeAgent,\n        address _rootBridgeAgentFactory,\n        address _refundee,\n        GasParams memory _gParams\n    ) internal virtual {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Check if msg.sender is a valid BridgeAgentFactory\n        if (!IPort(_localPortAddress).isBridgeAgentFactory(_branchBridgeAgentFactory)) {\n            revert UnrecognizedBridgeAgentFactory();\n        }\n\n        // Create BridgeAgent\n        address newBridgeAgent = IBridgeAgentFactory(_branchBridgeAgentFactory).createBridgeAgent(\n            _newBranchRouter, _rootBridgeAgent, _rootBridgeAgentFactory\n        );\n\n        // Check BridgeAgent Address\n        if (!IPort(_localPortAddress).isBridgeAgent(newBridgeAgent)) {\n            revert UnrecognizedBridgeAgent();\n        }\n\n        // Encode Data\n        bytes memory params = abi.encode(newBridgeAgent, _rootBridgeAgent);\n\n        // Pack FuncId\n        bytes memory payload = abi.encodePacked(bytes1(0x04), params);\n\n        //Send Cross-Chain request\n        IBridgeAgent(localBridgeAgentAddress).callOutSystem{value: msg.value}(payable(_refundee), payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 BRIDGE AGENT MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to add/deactivate a Branch Bridge Agent Factory.\n     *  @param _newBridgeAgentFactoryAddress the address of the new local bridge agent factory.\n     *  @dev FUNC ID: 3\n     */\n    function _toggleBranchBridgeAgentFactory(address _newBridgeAgentFactoryAddress) internal {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Check if BridgeAgentFactory is active\n        if (IPort(_localPortAddress).isBridgeAgentFactory(_newBridgeAgentFactoryAddress)) {\n            // If so, disable it.\n            IPort(_localPortAddress).toggleBridgeAgentFactory(_newBridgeAgentFactoryAddress);\n        } else {\n            // If not, add it.\n            IPort(_localPortAddress).addBridgeAgentFactory(_newBridgeAgentFactoryAddress);\n        }\n    }\n\n    /**\n     * @notice Function to remove an active Branch Bridge Agent from the system.\n     *  @param _branchBridgeAgent the address of the local Bridge Agent to be removed.\n     *  @dev FUNC ID: 4\n     */\n    function _removeBranchBridgeAgent(address _branchBridgeAgent) internal {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Revert if it is not an active BridgeAgent\n        if (!IPort(_localPortAddress).isBridgeAgent(_branchBridgeAgent)) revert UnrecognizedBridgeAgent();\n\n        // Remove BridgeAgent\n        IPort(_localPortAddress).toggleBridgeAgent(_branchBridgeAgent);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 PORT STRATEGIES INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to add/remove a token to be used by Port Strategies.\n     *  @param _underlyingToken the address of the underlying token.\n     *  @param _minimumReservesRatio the minimum reserves ratio the Port must have.\n     *  @dev FUNC ID: 5\n     */\n    function _manageStrategyToken(address _underlyingToken, uint256 _minimumReservesRatio) internal {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Check if the token is an active Strategy Token\n        if (IPort(_localPortAddress).isStrategyToken(_underlyingToken)) {\n            // If so, toggle it off.\n            IPort(_localPortAddress).toggleStrategyToken(_underlyingToken);\n        } else {\n            // If not, add it.\n            IPort(_localPortAddress).addStrategyToken(_underlyingToken, _minimumReservesRatio);\n        }\n    }\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain.\n     *         Must be called from another chain.\n     *  @param _portStrategy the address of the port strategy.\n     *  @param _underlyingToken the address of the underlying token.\n     *  @param _dailyManagementLimit the daily management limit.\n     *  @param _isUpdateDailyLimit if the daily limit is being updated.\n     *  @dev FUNC ID: 6\n     */\n    function _managePortStrategy(\n        address _portStrategy,\n        address _underlyingToken,\n        uint256 _dailyManagementLimit,\n        bool _isUpdateDailyLimit\n    ) internal {\n        // Save Port Address to memory\n        address _localPortAddress = localPortAddress;\n\n        // Check if Port Strategy is active\n        if (!IPort(_localPortAddress).isPortStrategy(_portStrategy, _underlyingToken)) {\n            // If Port Strategy is not active, add new Port Strategy.\n            IPort(_localPortAddress).addPortStrategy(_portStrategy, _underlyingToken, _dailyManagementLimit);\n        } else if (_isUpdateDailyLimit) {\n            // Or update daily limit.\n            IPort(_localPortAddress).updatePortStrategy(_portStrategy, _underlyingToken, _dailyManagementLimit);\n        } else {\n            // Or Toggle Port Strategy.\n            IPort(_localPortAddress).togglePortStrategy(_portStrategy, _underlyingToken);\n        }\n    }\n}"
    },
    {
      "filename": "src/ulysses-omnichain/CoreBranchRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\nimport {IBranchBridgeAgent as IBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchBridgeAgentFactory as IBridgeAgentFactory} from \"./interfaces/IBranchBridgeAgentFactory.sol\";\nimport {IBranchRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {ICoreBranchRouter} from \"./interfaces/ICoreBranchRouter.sol\";\nimport {IERC20hTokenBranchFactory as ITokenFactory} from \"./interfaces/IERC20hTokenBranchFactory.sol\";\n\nimport {BaseBranchRouter} from \"./BaseBranchRouter.sol\";\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Core Branch Router Contract\ncontract CoreBranchRouter is BaseBranchRouter {\n    /// @notice hToken Factory Address.\n    address public hTokenFactoryAddress;\n\n    /// @notice Local Port Address.\n    address public localPortAddress;\n\n    constructor(address _hTokenFactoryAddress, address _localPortAddress) BaseBranchRouter() {\n        localPortAddress = _localPortAddress;\n        hTokenFactoryAddress = _hTokenFactoryAddress;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice This function is used to add a global token to a branch.\n     * @param _globalAddress Address of the token to be added.\n     * @param _toChain Chain Id of the chain to which the deposit is being added.\n     * @param _remoteExecutionGas Gas to be used for the remote execution in destination chain.\n     * @param _rootExecutionGas Gas to be saved for the final root execution.\n     */\n    function addGlobalToken(\n        address _globalAddress,\n        uint24 _toChain,\n        uint128 _remoteExecutionGas,\n        uint128 _rootExecutionGas\n    ) external payable {\n        //Encode Call Data\n        bytes memory data = abi.encode(msg.sender, _globalAddress, _toChain, _rootExecutionGas);\n\n        //Pack FuncId\n        bytes memory packedData = abi.encodePacked(bytes1(0x01), data);\n\n        //Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(\n            msg.sender, packedData, 0, _remoteExecutionGas\n        );\n    }\n\n    /**\n     * @notice This function is used to add a local token to the system.\n     * @param _underlyingAddress Address of the underlying token to be added.\n     */\n    function addLocalToken(address _underlyingAddress) external payable virtual {\n        //Get Token Info\n        string memory name = ERC20(_underlyingAddress).name();\n        string memory symbol = ERC20(_underlyingAddress).symbol();\n\n        //Create Token\n        ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(name, symbol);\n\n        //Encode Data\n        bytes memory data = abi.encode(_underlyingAddress, newToken, name, symbol);\n\n        //Pack FuncId\n        bytes memory packedData = abi.encodePacked(bytes1(0x02), data);\n\n        //Send Cross-Chain request (System Response/Request)\n        IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                 TOKEN MANAGEMENT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain. Must be called from another chain.\n     *  @param _globalAddress the address of the global virtualized token.\n     *  @param _name token name.\n     *  @param _symbol token symbol.\n     *  @param _rootExecutionGas the amount of gas to be used in the root execution.\n     *  @dev FUNC ID: 1\n     *  @dev all hTokens have 18 decimals.\n     *\n     */\n    function _receiveAddGlobalToken(\n        address _globalAddress,\n        string memory _name,\n        string memory _symbol,\n        uint128 _rootExecutionGas\n    ) internal {\n        //Create Token\n        ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(_name, _symbol);\n\n        //Encode Data\n        bytes memory data = abi.encode(_globalAddress, newToken);\n\n        //Pack FuncId\n        bytes memory packedData = abi.encodePacked(bytes1(0x03), data);\n\n        //Send Cross-Chain request\n        IBridgeAgent(localBridgeAgentAddress).performSystemCallOut(address(this), packedData, _rootExecutionGas, 0);\n    }\n\n    /**\n     * @notice Function to deploy/add a token already active in the global environment in the Root Chain. Must be called from another chain.\n     *  @param _newBranchRouter the address of the new branch router.\n     *  @param _branchBridgeAgentFactory the address of the branch bridge agent factory.\n     *  @param _rootBridgeAgent the address of the root bridge agent.\n     *  @param _rootBridgeAgentFactory the address of the root bridge agent factory.\n     *  @param _remoteExecutionGas the amount of gas to be used in the remote execution.\n     *  @dev FUNC ID: 2\n     *  @dev all hTokens have 18 decimals.\n     *\n     */\n    function _receiveAddBridgeAgent(\n        address _newBranchRouter,\n        address _branchBridgeAgentFactory,\n        address _rootBridgeAgent,\n        address _rootBridgeAgentFactory,\n        uint128 _remoteExecutionGas\n    ) internal virtual {\n        //Check if msg.sender is a valid BridgeAgentFactory\n        if (!IPort(localPortAddress).isBridgeAgentFactory(_branchBridgeAgentFactory)) {\n            revert UnrecognizedBridgeAgentFactory();\n        }\n\n        //Create Token\n        address newBridgeAgent = IBridgeAgentFactory(_branchBridgeAgentFactory).createBridgeAgent(\n            _newBranchRouter, _rootBridgeAgent, _rootBridgeAgentFactory\n        );\n\n        //Check BridgeAgent Address\n        if (!IPort(localPortAddress).isBridgeAgent(newBridgeAgent)) {\n            revert UnrecognizedBridgeAgent();\n        }\n\n        //Encode Data\n        bytes memory data = abi.encode(newBridgeAgent, _rootBridgeAgent);\n\n        //Pack FuncId\n        bytes memory packedData = abi.encodePacked(bytes1(0x04), data);\n\n        //Send Cross-Chain request\n        IBridgeAgent(localBridgeAgentAddress).performSystemCallOut(address(this), packedData, _remoteExecutionGas, 0);\n    }\n\n    /**\n     * @notice Function to add/deactivate a Branch Bridge Agent Factory.\n     *  @param _newBridgeAgentFactoryAddress the address of the new local bridge agent factory.\n     *  @dev FUNC ID: 3\n     *\n     */\n    function _toggleBranchBridgeAgentFactory(address _newBridgeAgentFactoryAddress) internal {\n        if (!IPort(localPortAddress).isBridgeAgentFactory(_newBridgeAgentFactoryAddress)) {\n            IPort(localPortAddress).addBridgeAgentFactory(_newBridgeAgentFactoryAddress);\n        } else {\n            IPort(localPortAddress).toggleBridgeAgentFactory(_newBridgeAgentFactoryAddress);\n        }\n    }\n\n    /**\n     * @notice Function to remove an active Branch Bridge Agent from the system.\n     *  @param _branchBridgeAgent the address of the local Bridge Agent to be removed.\n     *  @dev FUNC ID: 4\n     *\n     */\n    function _removeBranchBridgeAgent(address _branchBridgeAgent) internal {\n        if (!IPort(localPortAddress).isBridgeAgent(_branchBridgeAgent)) revert UnrecognizedBridgeAgent();\n        IPort(localPortAddress).toggleBridgeAgent(_branchBridgeAgent);\n    }\n\n    /**\n     * @notice Function to add / remove a token to be used by Port Strategies.\n     *  @param _underlyingToken the address of the underlying token.\n     *  @param _minimumReservesRatio the minimum reserves ratio the Port must have.\n     *  @dev FUNC ID: 5\n     *\n     */\n    function _manageStrategyToken(address _underlyingToken, uint256 _minimumReservesRatio) internal {\n        if (!IPort(localPortAddress).isStrategyToken(_underlyingToken)) {\n            IPort(localPortAddress).addStrategyToken(_underlyingToken, _minimumReservesRatio);\n        } else {\n            IPort(localPortAddress).toggleStrategyToken(_underlyingToken);\n        }\n    }\n\n    /**\n     * @notice Function to deploy/add a token already active in the global enviornment in the Root Chain. Must be called from another chain.\n     *  @param _portStrategy the address of the port strategy.\n     *  @param _underlyingToken the address of the underlying token.\n     *  @param _dailyManagementLimit the daily management limit.\n     *  @param _isUpdateDailyLimit if the daily limit is being updated.\n     *  @dev FUNC ID: 6\n     *\n     */\n    function _managePortStrategy(\n        address _portStrategy,\n        address _underlyingToken,\n        uint256 _dailyManagementLimit,\n        bool _isUpdateDailyLimit\n    ) internal {\n        if (!IPort(localPortAddress).isPortStrategy(_portStrategy, _underlyingToken)) {\n            //Add new Port Strategy if new.\n            IPort(localPortAddress).addPortStrategy(_portStrategy, _underlyingToken, _dailyManagementLimit);\n        } else if (_isUpdateDailyLimit) {\n            //Or Update daily limit.\n            IPort(localPortAddress).updatePortStrategy(_portStrategy, _underlyingToken, _dailyManagementLimit);\n        } else {\n            //Or Toggle Port Strategy.\n            IPort(localPortAddress).togglePortStrategy(_portStrategy, _underlyingToken);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ANYCALL EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function anyExecuteNoSettlement(bytes calldata _data)\n        external\n        virtual\n        override\n        requiresAgentExecutor\n        returns (bool success, bytes memory result)\n    {\n        /// _receiveAddGlobalToken\n        if (_data[0] == 0x01) {\n            (address globalAddress, string memory name, string memory symbol, uint128 gasToBridgeOut) =\n                abi.decode(_data[1:], (address, string, string, uint128));\n\n            _receiveAddGlobalToken(globalAddress, name, symbol, gasToBridgeOut);\n            /// _receiveAddBridgeAgent\n        } else if (_data[0] == 0x02) {\n            (\n                address newBranchRouter,\n                address branchBridgeAgentFactory,\n                address rootBridgeAgent,\n                address rootBridgeAgentFactory,\n                uint128 remoteExecutionGas\n            ) = abi.decode(_data[1:], (address, address, address, address, uint128));\n\n            _receiveAddBridgeAgent(\n                newBranchRouter, branchBridgeAgentFactory, rootBridgeAgent, rootBridgeAgentFactory, remoteExecutionGas\n            );\n\n            /// _toggleBranchBridgeAgentFactory\n        } else if (_data[0] == 0x03) {\n            (address bridgeAgentFactoryAddress) = abi.decode(_data[1:], (address));\n            _toggleBranchBridgeAgentFactory(bridgeAgentFactoryAddress);\n\n            /// _removeBranchBridgeAgent\n        } else if (_data[0] == 0x04) {\n            (address branchBridgeAgent) = abi.decode(_data[1:], (address));\n            _removeBranchBridgeAgent(branchBridgeAgent);\n\n            /// _manageStrategyToken\n        } else if (_data[0] == 0x05) {\n            (address underlyingToken, uint256 minimumReservesRatio) = abi.decode(_data[1:], (address, uint256));\n            _manageStrategyToken(underlyingToken, minimumReservesRatio);\n\n            /// _managePortStrategy\n        } else if (_data[0] == 0x06) {\n            (address portStrategy, address underlyingToken, uint256 dailyManagementLimit, bool isUpdateDailyLimit) =\n                abi.decode(_data[1:], (address, address, uint256, bool));\n            _managePortStrategy(portStrategy, underlyingToken, dailyManagementLimit, isUpdateDailyLimit);\n\n            /// Unrecognized Function Selector\n        } else {\n            return (false, \"unknown selector\");\n        }\n        return (true, \"\");\n    }\n\n    fallback() external payable {}\n\n    error UnrecognizedBridgeAgent();\n    error UnrecognizedBridgeAgentFactory();\n}"
    }
  ]
}