{
  "Title": "[H-05] Multiple issues with decimal scaling will cause incorrect accounting of hTokens and underlying tokens",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L313>\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L696>\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L745>\n\n### Vulnerability details\n\nFunctions `_normalizeDecimals()` and `_denormalizeDecimals()` are used to handle non-18 decimal tokens when bridging a deposit by scaling them to a normalized 18 decimal form for `hToken` accounting, and then de-normalizing them to the token's decimals when interacting with the underlying token.\n\nHowever, there are 3 issues as follows:\n\n1. Implementations of `_normalizeDecimals()` and `_denormalizeDecimals()` are reversed.\n2. The function `_denormalizeDecimals()` is missing in `ArbitrumBranchPort.depositToPort()`.\n3. The function `_normalizeDecimals()` is missing in functions within `BranchBridgeAgent`.\n\nThese issues will cause an incorrect accounting of `hTokens` and underlying tokens in the system.\n\n### Impact\n\nAn incorrect decimal scaling will lead to a loss of funds, as the amount deposited and withdrawn for bridging will be inaccurate. This can be abused by an attacker or result in users incurring losses.\n\nFor example, an attacker can abuse the `ArbitrumBranchPort.depositToPort()` issue and steal from the system by first depositing a token that has more than 18 decimals. The attacker will receive more `hTokens` than the deposited underlying token amount. The attacker can then make a profit by withdrawing from the port with the excess `hTokens`.\n\nOn the other hand, if the underlying token is less than 18 decimals, the depositor can incur losses, as the amount of underlying tokens deposited will be more than the amount of `hTokens` received.\n\n### Issue #1\n\nThe functions `BranchBridgeAgent._normalizeDecimals()` and `BranchPort._denormalizeDecimals()` (shown below) are incorrect, as they are implemented in a reversed manner; such that `_denormalizeDecimals()` is normalizing to 18 decimals while `_normalizeDecimals()` is de-normalizing to the underlying token decimals.\n\nThe result is that for tokens with > 18 decimals, `_normalizeDecimals()` will overscale the decimals, while for tokens with < 18 decimals, `_normalizeDecimals()` will underscale the decimals.\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1340-L1342>\n\n```Solidity\n    function _normalizeDecimals(uint256 _amount, uint8 _decimals) internal pure returns (uint256) {\n        return _decimals == 18 ? _amount : _amount * (10 ** _decimals) / 1 ether;\n    }\n```\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L388-L390>\n\n```Solidity\n    function _denormalizeDecimals(uint256 _amount, uint8 _decimals) internal pure returns (uint256) {\n        return _decimals == 18 ? _amount : _amount * 1 ether / (10 ** _decimals);\n    }\n```\n\n### Issue #2\n\nThe function `ArbitrumBranchPort.depositToPort()` is missing the call  `_denormalizeDecimals()` to scale back the decimals of the underlying token amounts before transferring. This will cause the wrong amount of the underlying tokens to be transferred.\n\nAs shown below, the function `ArbitrumBranchBridgeAgent.depositToPort()` has normalized the \"amount\" to 18 decimals before passing into `ArbitrumBranchPort.depositToPort()`.\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L104>\n\n```Solidity\n    function depositToPort(address underlyingAddress, uint256 amount) external payable lock {\n\n        //@audit - amount is normalized to 18 decimals here\n        IArbPort(localPortAddress).depositToPort(\n            msg.sender, msg.sender, underlyingAddress, _normalizeDecimals(amount, ERC20(underlyingAddress).decimals())\n        );\n    }\n```\n\nThat means, the `_deposit` amount for `ArbitrumBranchPort.depositToPort()` (see below) will be incorrect, as it is not de-normalized back to the underlying token's decimal, causing the wrong value to be transferred from the depositor.\n\nIf the underlying token is more than 18 decimals, the depositor will transfer less underlying tokens than the `hToken` received, resulting in excess `hTokens`. The depositor can then call `withdrawFromPort()` to receive more underlying tokens than deposited.\n\nIf the underlying token is less than 18 decimals, that will inflate the amount to be transferred from the depositor, causing the depositor to deposit more underlying tokens than the amount of `hToken` received. The depositor will incur a loss when withdrawing from the port.\n\nInstead, the `_deposit` should be de-normalized in `ArbitrumBranchPort.depositToPort()` when passing to `_underlyingAddress.safeTransferFrom()`, so that it is scaled back to the underlying token's decimals when transferring.\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchPort.sol#L52-L54>\n\n```Solidity\n    function depositToPort(address _depositor, address _recipient, address _underlyingAddress, uint256 _deposit)\n        external\n        requiresBridgeAgent\n    {\n        address globalToken = IRootPort(rootPortAddress).getLocalTokenFromUnder(_underlyingAddress, localChainId);\n        if (globalToken == address(0)) revert UnknownUnderlyingToken();\n\n        //@audit - the amount of underlying token should be denormalized first before transferring\n        _underlyingAddress.safeTransferFrom(_depositor, address(this), _deposit);\n\n        IRootPort(rootPortAddress).mintToLocalBranch(_recipient, globalToken, _deposit);\n    }\n```\n\n### Issue #3\n\nIn `BranchBridgeAgent`, the deposit amount passed into `_depositAndCall()` and `_depositAndCallMultiple()` are missing `_normalizeDecimals()`.\n\nThe example below shows `callOutSignedAndBridge()`, but the issue is also present in `callOutAndBridge()`, `callOutSignedAndBridgeMultiple()` and `callOutAndBridgeMultiple()`.\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L269>\n\n```Solidity\n    function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x05),\n            msg.sender,\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            msg.sender,\n            packedData,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            //@audit - the deposit amount of underlying token should be noramlized first\n            _dParams.deposit,\n            msg.value.toUint128()\n        );\n    }\n```\n\nThis will affect `_createDepositSingle()` and `_createDepositMultiple()`, leading to incorrect decimals for `IPort(localPortAddress).bridgeOut()`, which will affect `hToken` burning and the deposit of underlying tokens.\n\nAt the same time, the deposits to be stored in `getDeposit[]` are also not normalized, causing a mismatch of decimals when `clearToken()` is called via `redeemDeposit()`.\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L857-L891>\n\n```Solidity\n    function _createDepositSingle(\n        address _user,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Deposit / Lock Tokens into Port\n        IPort(localPortAddress).bridgeOut(_user, _hToken, _token, _amount, _deposit);\n\n        //Deposit Gas to Port\n        _depositGas(_gasToBridgeOut);\n\n        // Cast to dynamic memory array\n        address[] memory hTokens = new address[](1);\n        hTokens[0] = _hToken;\n        address[] memory tokens = new address[](1);\n        tokens[0] = _token;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = _amount;\n        uint256[] memory deposits = new uint256[](1);\n        deposits[0] = _deposit;\n\n        // Update State\n        getDeposit[_getAndIncrementDepositNonce()] = Deposit({\n            owner: _user,\n            hTokens: hTokens,\n            tokens: tokens,\n            amounts: amounts,\n            //@audit the deposits stored is not normalized, causing a mismatch of decimals when `clearToken()` is called via `redeemDeposit()`\n            deposits: deposits,\n            status: DepositStatus.Success,\n            depositedGas: _gasToBridgeOut\n        });\n    }\n```\n\n### Recommended Mitigation Steps\n\n1.  Switch the implementation of `_normalizeDecimals()` to `_denormalizeDecimals()` and vice versa.\n\n2.  Add `_denormalizeDecimals()` to `ArbitrumBranchPort.depositToPort()` when calling `IRootPort(rootPortAddress).mintToLocalBranch()`.\n\n3.  Utilize `_normalizeDecimals()` when passing deposit amounts to  `_depositAndCall()` and `_depositAndCallMultiple()` within `BranchBridgeAgent`.\n\n### Assessed type\n\nDecimal\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/758#issuecomment-1631358603)**\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/758#issuecomment-1655669704):**\n > We recognize the audit's findings on Decimal Conversion for Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\nimport {IApp, IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchRouter as IRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\nimport {\n    Deposit,\n    DepositStatus,\n    DepositInput,\n    DepositMultipleInput,\n    DepositParams,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _wrappedNativeToken,\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\ncontract BranchBridgeAgent is IBranchBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Decode Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ENTRY_SIZE = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// ClearTokens Decode Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liqudity is virtualized(e.g. 4).\n    uint256 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint256 public immutable localChainId;\n\n    /// @notice Address for Local Wrapped Native Token.\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable localAnyCallAddress;\n\n    /// @notice Address for Local Anyexec Address where cross-chain requests from the Root Chain Router are received locally.\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    address public bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint32 => Deposit) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint32 => bool) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public remoteCallDepositedGas;\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions\n    uint256 internal constant TRANSFER_OVERHEAD = 24_000;\n\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(_localAnyCallAddress != address(0), \"AnyCall Address cannot be the zero address.\");\n        require(_localAnyCallExecutorAddress != address(0), \"AnyCall Executor Address cannot be the zero address.\");\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        localAnyCallAddress = _localAnyCallAddress;\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(bytes calldata _params, uint128 _remoteExecutionGas) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call without deposit\n        _callOut(msg.sender, _params, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with deposit\n        _callOutAndBridge(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with multiple deposits\n        _callOutAndBridgeMultiple(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(bytes calldata _params, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x04), msg.sender, depositNonce, _params, msg.value.toUint128(), _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Signed Call without deposit\n        _noDepositCall(msg.sender, packedData, msg.value.toUint128());\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x05),\n            msg.sender,\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            msg.sender,\n            packedData,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Normalize Deposits\n        uint256[] memory _deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            _deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _deposits,\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            msg.sender,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        uint128 _remoteExecutionGas,\n        uint24 _toChain\n    ) external payable lock requiresFallbackGas {\n        //Check if deposit belongs to message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData;\n\n        if (uint8(getDeposit[_depositNonce].hTokens.length) == 1) {\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x02),\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        } else if (uint8(getDeposit[_depositNonce].hTokens.length) > 1) {\n            //Nonce\n            uint32 nonce = _depositNonce;\n\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x06),\n                    msg.sender,\n                    uint8(getDeposit[_depositNonce].hTokens.length),\n                    nonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x03),\n                    uint8(getDeposit[nonce].hTokens.length),\n                    _depositNonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        }\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Deposit Gas to Port\n        _depositGas(msg.value.toUint128());\n\n        //Ensure success Status\n        getDeposit[_depositNonce].status = DepositStatus.Success;\n\n        //Update Deposited Gas\n        getDeposit[_depositNonce].depositedGas = msg.value.toUint128();\n\n        //Perform Call\n        _performCall(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _gasToBoostSettlement)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x07), depositNonce++, _settlementNonce, msg.value.toUint128(), _gasToBoostSettlement\n        );\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(bytes1(0x08), _depositNonce, msg.value.toUint128(), uint128(0));\n\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    function _sendRetrieveOrRetry(bytes memory _data) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(msg.sender, msg.value.toUint128());\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function redeemDeposit(uint32 _depositNonce) external lock {\n        //Update Deposit\n        if (getDeposit[_depositNonce].status != DepositStatus.Failed) {\n            revert DepositRedeemUnavailable();\n        }\n        _redeemDeposit(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performSystemCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x00), depositNonce, _params, gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, gasToBridgeOut);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOut(_depositor, _params, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridge(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridgeMultiple(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearToken(address _recipient, address _hToken, address _token, uint256 _amount, uint256 _deposit)\n        external\n        requiresAgentExecutor\n    {\n        _clearToken(_recipient, _hToken, _token, _amount, _deposit);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearTokens(bytes calldata _sParams, address _recipient)\n        external\n        requiresAgentExecutor\n        returns (SettlementMultipleParams memory)\n    {\n        //Parse Params\n        uint8 numOfAssets = uint8(bytes1(_sParams[0]));\n        uint32 nonce = uint32(bytes4(_sParams[PARAMS_START:PARAMS_TKN_START]));\n\n        address[] memory _hTokens = new address[](numOfAssets);\n        address[] memory _tokens = new address[](numOfAssets);\n        uint256[] memory _amounts = new uint256[](numOfAssets);\n        uint256[] memory _deposits = new uint256[](numOfAssets);\n\n        //Transfer token to recipient\n        for (uint256 i = 0; i < numOfAssets;) {\n            //Parse Params\n            _hTokens[i] = address(\n                uint160(\n                    bytes20(\n                        bytes32(\n                            _sParams[\n                                PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * i) + 12:\n                                    PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * (PARAMS_START + i))\n                            ]\n                        )\n                    )\n                )\n            );\n            _tokens[i] = address(\n                uint160(\n                    bytes20(\n                        _sParams[\n                            PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(i + numOfAssets) + 12:\n                                PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i + numOfAssets)\n                        ]\n                    )\n                )\n            );\n            _amounts[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            _deposits[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            //Clear Tokens to destination\n            if (_amounts[i] - _deposits[i] > 0) {\n                IPort(localPortAddress).bridgeIn(_recipient, _hTokens[i], _amounts[i] - _deposits[i]);\n            }\n\n            if (_deposits[i] > 0) {\n                IPort(localPortAddress).withdraw(_recipient, _tokens[i], _deposits[i]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return SettlementMultipleParams(numOfAssets, _recipient, nonce, _hTokens, _tokens, _amounts, _deposits);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                LOCAL USER DEPOSIT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router without token deposit.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 1 (Call without deposit)\n     *\n     */\n    function _callOut(address _depositor, bytes calldata _params, uint128 _gasToBridgeOut, uint128 _remoteExecutionGas)\n        internal\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x01), depositNonce, _params, _gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, _gasToBridgeOut);\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing a single asset.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 2 (Call with single deposit)\n     *\n     */\n    function _callOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x02),\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            _depositor, packedData, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing two or more assets.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 3 (Call with multiple deposit)\n     *\n     */\n    function _callOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Normalize Deposits\n        uint256[] memory deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x03),\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            deposits,\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            _depositor,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _noDepositCall(address _depositor, bytes memory _data, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(_depositor, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hToken Local Input hToken Address.\n     *   @param _token Native / Underlying Token Address.\n     *   @param _amount Amount of Local hTokens deposited for trade.\n     *   @param _deposit Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCall(\n        address _depositor,\n        bytes memory _data,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Deposit and Store Info\n        _createDepositSingle(_depositor, _hToken, _token, _amount, _deposit, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hTokens Local Input hToken Address.\n     *   @param _tokens Native / Underlying Token Address.\n     *   @param _amounts Amount of Local hTokens deposited for trade.\n     *   @param _deposits  Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCallMultiple(\n        address _depositor,\n        bytes memory _data,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Validate Input\n        if (\n            _hTokens.length != _tokens.length || _tokens.length != _amounts.length\n                || _amounts.length != _deposits.length\n        ) revert InvalidInput();\n\n        //Deposit and Store Info\n        _createDepositMultiple(_depositor, _hTokens, _tokens, _amounts, _deposits, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createGasDeposit(address _user, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas to Port\n        _depositGas(_gasToBridgeOut);\n\n        // Update State\n        getDeposit[_getAndIncrementDepositNonce()] = Deposit({\n            owner: _user,\n            hTokens: new address[](0),\n            tokens: new address[](0),\n            amounts: new uint256[](0),\n            deposits: new uint256[](0),\n            status: DepositStatus.Success,\n            depositedGas: _gasToBridgeOut\n        });\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _hToken deposited local hToken addresses.\n     *    @param _token deposited native / underlying Token addresses.\n     *    @param _amount amounts of hTokens input.\n     *    @param _deposit amount of deposited underlying / native tokens.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createDepositSingle(\n        address _user,\n        address _hToken,"
    }
  ]
}