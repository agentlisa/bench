{
  "Title": "`onERC721Received()` callback is never called when new tokens are minted in Erc721Facet.sol",
  "Content": "# `onERC721Received()` callback is never called when new tokens are minted in Erc721Facet.sol\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ERC721Facet.sol#L260\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/ERC721Facet.sol#L260</a>\n\n\n## Summary\nThe ERC721Facet contract does not properly call the corresponding callback when new tokens are minted.\nThe ERC721 standard states that the onERC721Received callback must be called when a mint or transfer operation occurs. However, the smart contracts interacting as users with `Erc721Facet.mintNFT()` will not be notified with the onERC721Received callback, as expected according to the ERC721 standard.\n\n## Vulnerability Details\n`onErc721Received()` isn't called on minting:\n```solidity\n    function mintNFT(address asset, uint8 shortRecordId)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, shortRecordId)\n    {\n        if (shortRecordId == Constants.SHORT_MAX_ID) {\n            revert Errors.CannotMintLastShortRecord();\n        }\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][msg.sender][shortRecordId];\n\n        if (short.tokenId != 0) revert Errors.AlreadyMinted();\n\n        s.nftMapping[s.tokenIdCounter] = STypes.NFT({\n            owner: msg.sender,\n            assetId: s.asset[asset].assetId,\n            shortRecordId: shortRecordId\n        });\n\n        short.tokenId = s.tokenIdCounter;\n\n        //@dev never decreases\n        s.tokenIdCounter += 1;\n    }\n```\n\n## Impact\nIt can create interoperability issues with users' contracts\n\n## Tools Used\nManual Review\n\n## Recommendations\nCall `onErc721Received()`",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/ERC721Facet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ERC721Facet is Modifiers, IERC721 {\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        if (owner == address(0)) {\n            revert Errors.ERC721InvalidOwner(address(0));\n        }\n\n        uint256 length = s.assets.length;\n        for (uint256 i; i < length;) {\n            STypes.ShortRecord[] memory shortRecords =\n                IDiamond(payable(address(this))).getShortRecords(s.assets[i], owner);\n            for (uint256 j; j < shortRecords.length;) {\n                if (shortRecords[j].tokenId != 0) {\n                    balance++;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return s.nftMapping[tokenId].owner;\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert Errors.ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, tokenId);\n\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\n            revert Errors.ERC721InvalidReceiver(to);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        // @dev ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        if (\n            msg.sender != from && !s.isApprovedForAll[from][msg.sender]\n                && msg.sender != s.getApproved[tokenId]\n        ) revert Errors.ERC721InsufficientApproval(msg.sender, tokenId);\n\n        address owner = ownerOf(tokenId);\n        if (owner != from) {\n            revert Errors.ERC721IncorrectOwner(from, tokenId, owner);\n        }\n        if (to == address(0)) {\n            revert Errors.ERC721InvalidReceiver(address(0));\n        }\n\n        STypes.NFT memory nft = s.nftMapping[tokenId];\n        address asset = s.assetMapping[nft.assetId];\n\n        //@dev If NFT does not exist, ERC721NonexistentToken() will trigger\n        LibShortRecord.transferShortRecord(asset, from, to, uint40(tokenId), nft);\n\n        delete s.getApproved[tokenId];\n\n        emit Events.Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return s.isApprovedForAll[owner][operator];\n    }\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external {\n        // @dev ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n        address owner = _ownerOf(tokenId);\n\n        if (to == owner) {\n            revert Errors.ERC721InvalidOperator(owner);\n        }\n\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\n            revert Errors.ERC721InvalidApprover(msg.sender);\n        }\n\n        s.getApproved[tokenId] = to;\n\n        emit Events.Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        if (msg.sender == operator) {\n            revert Errors.ERC721InvalidOperator(msg.sender);\n        }\n        s.isApprovedForAll[msg.sender][operator] = approved;\n        emit Events.ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        if (!_exists(tokenId)) {\n            revert Errors.ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator) {\n        _requireMinted(tokenId);\n        return s.getApproved[tokenId];\n    }\n\n    /**\n     * @notice Mints NFT for active shortRecord\n     * @dev Minters can only mint their own shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shortRecordId Id of active shortRecord\n     */\n\n    function mintNFT(address asset, uint8 shortRecordId)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, shortRecordId)\n    {\n        if (shortRecordId == Constants.SHORT_MAX_ID) {\n            revert Errors.CannotMintLastShortRecord();\n        }\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][msg.sender][shortRecordId];\n\n        if (short.tokenId != 0) revert Errors.AlreadyMinted();\n\n        s.nftMapping[s.tokenIdCounter] = STypes.NFT({\n            owner: msg.sender,\n            assetId: s.asset[asset].assetId,\n            shortRecordId: shortRecordId\n        });\n\n        short.tokenId = s.tokenIdCounter;\n\n        //@dev never decreases\n        s.tokenIdCounter += 1;\n    }\n\n    function tokenURI(uint256 id) public view virtual returns (string memory) {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data)\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert Errors.ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    // This implements ERC-165 (copied from DiamondLoupeFacet.sol)\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}"
    }
  ]
}