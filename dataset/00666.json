{
  "Title": "Potential rewards loss due to LpTokenStaker switch in RewardManager",
  "Content": "##### Description\n\nChanging the LpTokenStaker via `Controller.switchLpTokenStaker()` results in all users losing a portion of their rewards in RewardManager. It happens because after changing the LpTokenStaker, `RewardManager._accountCheckpoint()` will use a new address for which `LpTokenStaker.getUserBalanceForPool(conicPool, account)` will return zero. As a result, the accumulated integral for the staking period will be reset to zero as the `balance` variable is zero:\n\n```\nfunction _updateAccountRewardsMeta(\n    bytes32 key,\n    address account,\n    uint256 balance\n    )\n    ...\n    uint256 share = \n        balance.mulDown(\n            meta.earnedIntegral - meta.accountIntegral[account]\n            );\n```\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/RewardManager.sol#L229-L234\n\n##### Recommendation\n\nWe recommend ensuring user rewards in `RewardManager` remain unaffected during transitions.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RewardManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/pools/IConicPool.sol\";\nimport \"../interfaces/pools/ILpToken.sol\";\nimport \"../interfaces/pools/IRewardManager.sol\";\nimport \"../interfaces/IConvexHandler.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../interfaces/tokenomics/ILpTokenStaker.sol\";\nimport \"../interfaces/tokenomics/ICNCLockerV2.sol\";\nimport \"../interfaces/vendor/ICurvePoolV2.sol\";\nimport \"../interfaces/vendor/UniswapRouter02.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Types.sol\";\n\ncontract RewardManager is IRewardManager, Ownable, Initializable {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RewardMeta {\n        uint256 earnedIntegral;\n        uint256 lastHoldings;\n        mapping(address => uint256) accountIntegral;\n        mapping(address => uint256) accountShare;\n    }\n\n    IERC20 public constant CVX = IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    IERC20 public constant CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant CNC = IERC20(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n    UniswapRouter02 public constant SUSHISWAP =\n        UniswapRouter02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n    ICurvePoolV2 public constant CNC_ETH_POOL =\n        ICurvePoolV2(0x838af967537350D2C44ABB8c010E49E32673ab94);\n\n    uint256 public constant MAX_FEE_PERCENTAGE = 3e17;\n    uint256 public constant SLIPPAGE_THRESHOLD = 0.95e18; // 5% slippage as a multiplier\n\n    bytes32 internal constant _CNC_KEY = \"cnc\";\n    bytes32 internal constant _CRV_KEY = \"crv\";\n    bytes32 internal constant _CVX_KEY = \"cvx\";\n\n    address public override conicPool;\n    IERC20 public immutable underlying;\n    IController public immutable controller;\n    ICNCLockerV2 public immutable locker;\n    bool internal _claimingCNC;\n\n    EnumerableSet.AddressSet internal _extraRewards;\n    mapping(address => address) public extraRewardsCurvePool;\n    mapping(bytes32 => RewardMeta) internal _rewardsMeta;\n    mapping(uint256 => bool) internal _claimedForCliff;\n\n    bool public feesEnabled;\n    uint256 public feePercentage;\n\n    constructor(address _controller, address _underlying, address cncLocker) {\n        underlying = IERC20(_underlying);\n        controller = IController(_controller);\n        WETH.safeApprove(address(CNC_ETH_POOL), type(uint256).max);\n        locker = ICNCLockerV2(cncLocker);\n    }\n\n    function initialize(address _pool) external onlyOwner initializer {\n        conicPool = _pool;\n    }\n\n    /// @notice Updates the internal fee accounting state. Returns `true` if rewards were claimed\n    function poolCheckpoint() public override returns (bool) {\n        IConvexHandler convexHandler = IConvexHandler(controller.convexHandler());\n\n        (\n            uint256 crvHoldings,\n            uint256 cvxHoldings,\n            uint256 cncHoldings,\n            Types.CliffInfo memory cliffInfo\n        ) = _getHoldingsWithCliffInfo(convexHandler);\n\n        // if we are in the threshold near a cliff for the first time claim rewards\n        if (cliffInfo.withinThreshold && !_claimedForCliff[cliffInfo.currentCliff]) {\n            _claimPoolEarningsForCliff(cliffInfo.currentCliff);\n        }\n\n        uint256 crvEarned = crvHoldings - _rewardsMeta[_CRV_KEY].lastHoldings;\n        uint256 cvxEarned;\n        if (cvxHoldings > _rewardsMeta[_CVX_KEY].lastHoldings) {\n            cvxEarned = cvxHoldings - _rewardsMeta[_CVX_KEY].lastHoldings;\n        }\n        uint256 cncEarned = cncHoldings - _rewardsMeta[_CNC_KEY].lastHoldings;\n\n        uint256 crvFee;\n        uint256 cvxFee;\n\n        if (feesEnabled) {\n            crvFee = crvEarned.mulDown(feePercentage);\n            cvxFee = cvxEarned.mulDown(feePercentage);\n            crvEarned -= crvFee;\n            cvxEarned -= cvxFee;\n            crvHoldings -= crvFee;\n            cvxHoldings -= cvxFee;\n        }\n\n        uint256 _totalStaked = controller.lpTokenStaker().getBalanceForPool(conicPool);\n        if (_totalStaked > 0) {\n            _updateEarned(_CVX_KEY, cvxHoldings, cvxEarned, _totalStaked);\n            _updateEarned(_CRV_KEY, crvHoldings, crvEarned, _totalStaked);\n            _updateEarned(_CNC_KEY, cncHoldings, cncEarned, _totalStaked);\n        }\n\n        if (!feesEnabled) {\n            return false;\n        }\n\n        bool rewardsClaimed = false;\n\n        if (crvFee > CRV.balanceOf(conicPool) || cvxFee > CVX.balanceOf(conicPool)) {\n            _claimPoolEarningsAndSellRewardTokens();\n            rewardsClaimed = true;\n        }\n\n        CRV.safeTransferFrom(conicPool, address(this), crvFee);\n        CVX.safeTransferFrom(conicPool, address(this), cvxFee);\n\n        // Fee transfer to the CNC locker\n        CRV.safeApprove(address(locker), crvFee);\n        CVX.safeApprove(address(locker), cvxFee);\n        locker.receiveFees(crvFee, cvxFee);\n\n        return rewardsClaimed;\n    }\n\n    function _updateEarned(\n        bytes32 key,\n        uint256 holdings,\n        uint256 earned,\n        uint256 _totalSupply\n    ) internal {\n        _rewardsMeta[key].earnedIntegral += earned.divDown(_totalSupply);\n        _rewardsMeta[key].lastHoldings = holdings;\n    }\n\n    function _getEarnedRewards()\n        internal\n        view\n        returns (uint256 crvEarned, uint256 cvxEarned, uint256 cncEarned)\n    {\n        IConvexHandler convexHandler = IConvexHandler(controller.convexHandler());\n        return _getEarnedRewards(convexHandler);\n    }\n\n    function _getHoldingsWithCliffInfo(\n        IConvexHandler convexHandler\n    )\n        internal\n        view\n        returns (\n            uint256 crvHoldings,\n            uint256 cvxHoldings,\n            uint256 cncHoldings,\n            Types.CliffInfo memory cliffInfo\n        )\n    {\n        address[] memory curvePools = IConicPool(conicPool).allPools();\n\n        uint256 claimableCRV;\n        for (uint256 i; i < curvePools.length; i++) {\n            claimableCRV += controller.poolAdapterFor(curvePools[i]).getCRVEarnedOnConvex(\n                conicPool,\n                curvePools[i]\n            );\n        }\n\n        crvHoldings = CRV.balanceOf(conicPool) + claimableCRV;\n\n        uint256 claimableCVX;\n        (claimableCVX, cliffInfo) = convexHandler.computeClaimableConvexWithCliffInfo(claimableCRV);\n        cvxHoldings = CVX.balanceOf(conicPool) + claimableCVX;\n        cncHoldings = CNC.balanceOf(conicPool);\n        if (!_claimingCNC) {\n            cncHoldings += controller.lpTokenStaker().claimableCnc(conicPool);\n        }\n    }\n\n    function _getHoldings(\n        IConvexHandler convexHandler\n    ) internal view returns (uint256 crvHoldings, uint256 cvxHoldings, uint256 cncHoldings) {\n        (crvHoldings, cvxHoldings, cncHoldings, ) = _getHoldingsWithCliffInfo(convexHandler);\n    }\n\n    function _getEarnedRewards(\n        IConvexHandler convexHandler\n    ) internal view returns (uint256 crvEarned, uint256 cvxEarned, uint256 cncEarned) {\n        (\n            uint256 currentHoldingsCRV,\n            uint256 currentHoldingsCVX,\n            uint256 currentHoldingsCNC\n        ) = _getHoldings(convexHandler);\n\n        crvEarned = currentHoldingsCRV - _rewardsMeta[_CRV_KEY].lastHoldings;\n        cvxEarned = currentHoldingsCVX - _rewardsMeta[_CVX_KEY].lastHoldings;\n        cncEarned = currentHoldingsCNC - _rewardsMeta[_CNC_KEY].lastHoldings;\n    }\n\n    function accountCheckpoint(address account) external {\n        _accountCheckpoint(account);\n    }\n\n    function _accountCheckpoint(address account) internal {\n        uint256 accountBalance = controller.lpTokenStaker().getUserBalanceForPool(\n            conicPool,\n            account\n        );\n        poolCheckpoint();\n        _updateAccountRewardsMeta(_CNC_KEY, account, accountBalance);\n        _updateAccountRewardsMeta(_CRV_KEY, account, accountBalance);\n        _updateAccountRewardsMeta(_CVX_KEY, account, accountBalance);\n    }\n\n    function _updateAccountRewardsMeta(bytes32 key, address account, uint256 balance) internal {\n        RewardMeta storage meta = _rewardsMeta[key];\n        uint256 share = balance.mulDown(meta.earnedIntegral - meta.accountIntegral[account]);\n        meta.accountShare[account] += share;\n        meta.accountIntegral[account] = meta.earnedIntegral;\n    }\n\n    /// @notice Claims all CRV, CVX and CNC earned by a user. All extra reward\n    /// tokens earned will be sold for CNC.\n    /// @dev Conic pool LP tokens need to be staked in the `LpTokenStaker` in\n    /// order to receive a share of the CRV, CVX and CNC earnings.\n    /// after selling all extra reward tokens.\n    function claimEarnings() public override returns (uint256, uint256, uint256) {\n        _accountCheckpoint(msg.sender);\n        uint256 crvAmount = _rewardsMeta[_CRV_KEY].accountShare[msg.sender];\n        uint256 cvxAmount = _rewardsMeta[_CVX_KEY].accountShare[msg.sender];\n        uint256 cncAmount = _rewardsMeta[_CNC_KEY].accountShare[msg.sender];\n\n        if (\n            crvAmount > CRV.balanceOf(conicPool) ||\n            cvxAmount > CVX.balanceOf(conicPool) ||\n            cncAmount > CNC.balanceOf(conicPool)\n        ) {\n            _claimPoolEarningsAndSellRewardTokens();\n        }\n        _rewardsMeta[_CNC_KEY].accountShare[msg.sender] = 0;\n        _rewardsMeta[_CVX_KEY].accountShare[msg.sender] = 0;\n        _rewardsMeta[_CRV_KEY].accountShare[msg.sender] = 0;\n\n        CRV.safeTransferFrom(conicPool, msg.sender, crvAmount);\n        CVX.safeTransferFrom(conicPool, msg.sender, cvxAmount);\n        CNC.safeTransferFrom(conicPool, msg.sender, cncAmount);\n\n        (\n            uint256 currentHoldingsCRV,\n            uint256 currentHoldingsCVX,\n            uint256 currentHoldingsCNC\n        ) = _getHoldings(IConvexHandler(controller.convexHandler()));\n        _rewardsMeta[_CRV_KEY].lastHoldings = currentHoldingsCRV;\n        _rewardsMeta[_CVX_KEY].lastHoldings = currentHoldingsCVX;\n        _rewardsMeta[_CNC_KEY].lastHoldings = currentHoldingsCNC;\n\n        emit EarningsClaimed(msg.sender, cncAmount, crvAmount, cvxAmount);\n        return (cncAmount, crvAmount, cvxAmount);\n    }\n\n    /// @notice Claims all claimable CVX and CRV from Convex for all staked Curve LP tokens.\n    /// Then Swaps all additional rewards tokens for CNC.\n    function claimPoolEarningsAndSellRewardTokens() external override {\n        if (!poolCheckpoint()) {\n            _claimPoolEarningsAndSellRewardTokens();\n        }\n    }\n\n    function _claimPoolEarningsForCliff(uint256 cliff) internal {\n        _claimPoolEarningsAndSellRewardTokens();\n        _claimedForCliff[cliff] = true;\n    }\n\n    function _claimPoolEarningsAndSellRewardTokens() internal {\n        _claimPoolEarnings();\n\n        uint256 cncBalanceBefore_ = CNC.balanceOf(conicPool);\n\n        _sellRewardTokens();\n\n        uint256 receivedCnc_ = CNC.balanceOf(conicPool) - cncBalanceBefore_;\n        uint256 _totalStaked = controller.lpTokenStaker().getBalanceForPool(conicPool);\n        if (_totalStaked > 0)\n            _rewardsMeta[_CNC_KEY].earnedIntegral += receivedCnc_.divDown(_totalStaked);\n        emit SoldRewardTokens(receivedCnc_);\n    }\n\n    /// @notice Claims all claimable CVX and CRV from Convex for all staked Curve LP tokens\n    function _claimPoolEarnings() internal {\n        _claimingCNC = true;\n        controller.lpTokenStaker().claimCNCRewardsForPool(conicPool);\n        _claimingCNC = false;\n\n        uint256 cvxBalance = CVX.balanceOf(conicPool);\n        uint256 crvBalance = CRV.balanceOf(conicPool);\n\n        address[] memory pools = IConicPool(conicPool).allPools();\n        for (uint256 i; i < pools.length; i++) {\n            controller.poolAdapterFor(pools[i]).claimEarnings(conicPool, pools[i]);\n        }\n\n        uint256 claimedCvx = CVX.balanceOf(conicPool) - cvxBalance;\n        uint256 claimedCrv = CRV.balanceOf(conicPool) - crvBalance;\n\n        emit ClaimedRewards(claimedCrv, claimedCvx);\n    }\n\n    /// @notice Swaps all additional rewards tokens for CNC.\n    function _sellRewardTokens() internal {\n        uint256 extraRewardsLength_ = _extraRewards.length();\n        if (extraRewardsLength_ == 0) return;\n        for (uint256 i; i < extraRewardsLength_; i++) {\n            _swapRewardTokenForWeth(_extraRewards.at(i));\n        }\n        _swapWethForCNC();\n    }\n\n    function listExtraRewards() external view returns (address[] memory) {\n        return _extraRewards.values();\n    }\n\n    function addExtraReward(address reward) public override onlyOwner returns (bool) {\n        require(reward != address(0), \"invalid address\");\n        require(\n            reward != address(CVX) &&\n                reward != address(CRV) &&\n                reward != address(underlying) &&\n                reward != address(CNC),\n            \"token not allowed\"\n        );\n\n        // Checking reward token isn't a Curve Pool LP Token\n        address[] memory pools = IConicPool(conicPool).allPools();\n        for (uint256 i; i < pools.length; i++) {\n            address curveLpToken_ = controller.poolAdapterFor(pools[i]).lpToken(pools[i]);\n            require(reward != curveLpToken_, \"token not allowed\");\n        }\n\n        IERC20(reward).safeApprove(address(SUSHISWAP), 0);\n        IERC20(reward).safeApprove(address(SUSHISWAP), type(uint256).max);\n        emit ExtraRewardAdded(reward);\n        return _extraRewards.add(reward);\n    }\n\n    function addBatchExtraRewards(address[] memory _rewards) external override onlyOwner {\n        for (uint256 i; i < _rewards.length; i++) {\n            addExtraReward(_rewards[i]);\n        }\n    }\n\n    function removeExtraReward(address tokenAddress) external onlyOwner {\n        _extraRewards.remove(tokenAddress);\n        emit ExtraRewardRemoved(tokenAddress);\n    }\n\n    function setExtraRewardsCurvePool(address extraReward_, address curvePool_) external onlyOwner {\n        require(curvePool_ != extraRewardsCurvePool[extraReward_], \"must be different to current\");\n        if (curvePool_ != address(0)) {\n            IERC20(extraReward_).safeApprove(curvePool_, 0);\n            IERC20(extraReward_).safeApprove(curvePool_, type(uint256).max);\n        }\n        extraRewardsCurvePool[extraReward_] = curvePool_;\n        emit ExtraRewardsCurvePoolSet(extraReward_, curvePool_);\n    }\n\n    function setFeePercentage(uint256 _feePercentage) external override onlyOwner {\n        require(_feePercentage < MAX_FEE_PERCENTAGE, \"cannot set fee percentage to more than 30%\");\n        require(locker.totalBoosted() > 0);\n        feePercentage = _feePercentage;\n        feesEnabled = true;\n        emit FeesSet(feePercentage);\n    }\n\n    function claimableRewards(\n        address account\n    ) external view returns (uint256 cncRewards, uint256 crvRewards, uint256 cvxRewards) {\n        uint256 _totalStaked = controller.lpTokenStaker().getBalanceForPool(conicPool);\n        if (_totalStaked == 0) return (0, 0, 0);\n        (uint256 crvEarned, uint256 cvxEarned, uint256 cncEarned) = _getEarnedRewards();\n        uint256 userBalance = controller.lpTokenStaker().getUserBalanceForPool(conicPool, account);\n\n        cncRewards = _getClaimableReward(\n            account,\n            _CNC_KEY,\n            cncEarned,\n            userBalance,\n            _totalStaked,\n            false\n        );\n        crvRewards = _getClaimableReward(\n            account,\n            _CRV_KEY,\n            crvEarned,\n            userBalance,\n            _totalStaked,\n            feesEnabled\n        );\n        cvxRewards = _getClaimableReward(\n            account,\n            _CVX_KEY,\n            cvxEarned,\n            userBalance,\n            _totalStaked,\n            feesEnabled\n        );\n    }\n\n    function _getClaimableReward(\n        address account,\n        bytes32 key,\n        uint256 earned,\n        uint256 userBalance,\n        uint256 _totalSupply,\n        bool deductFee\n    ) internal view returns (uint256) {\n        RewardMeta storage meta = _rewardsMeta[key];\n        uint256 integral = meta.earnedIntegral;\n        if (deductFee) {\n            integral += earned.divDown(_totalSupply).mulDown(ScaledMath.ONE - feePercentage);\n        } else {\n            integral += earned.divDown(_totalSupply);\n        }\n        return\n            meta.accountShare[account] +\n            userBalance.mulDown(integral - meta.accountIntegral[account]);\n    }\n\n    function _swapRewardTokenForWeth(address rewardToken_) internal {\n        uint256 tokenBalance_ = IERC20(rewardToken_).balanceOf(address(this));\n        if (tokenBalance_ == 0) return;\n\n        ICurvePoolV2 curvePool_ = ICurvePoolV2(extraRewardsCurvePool[rewardToken_]);\n        if (address(curvePool_) != address(0)) {\n            (int128 i, int128 j, ) = controller.curveRegistryCache().coinIndices(\n                address(curvePool_),\n                rewardToken_,\n                address(WETH)\n            );\n            (uint256 from_, uint256 to_) = (uint256(uint128(i)), uint256(uint128(j)));\n            curvePool_.exchange(\n                from_,\n                to_,\n                tokenBalance_,\n                _minAmountOut(address(rewardToken_), address(WETH), tokenBalance_),\n                false,\n                address(this)\n            );\n            return;\n        }\n\n        address[] memory path_ = new address[](2);\n        path_[0] = rewardToken_;\n        path_[1] = address(WETH);\n        SUSHISWAP.swapExactTokensForTokens(\n            tokenBalance_,\n            _minAmountOut(address(rewardToken_), address(WETH), tokenBalance_),\n            path_,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function _swapWethForCNC() internal {\n        uint256 wethBalance_ = WETH.balanceOf(address(this));\n        if (wethBalance_ == 0) return;\n        CNC_ETH_POOL.exchange(\n            0,\n            1,\n            wethBalance_,\n            _minAmountOut(address(WETH), address(CNC), wethBalance_),\n            false,\n            conicPool\n        );\n    }\n\n    function _minAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) internal view returns (uint256) {\n        IOracle oracle_ = controller.priceOracle();\n\n        if (tokenIn_ == tokenOut_) {\n            return amountIn_;\n        }\n\n        // If we don't have a price for either token, we can't calculate the min amount out\n        // This should only ever happen for very minor tokens, so we accept the risk of not having\n        // slippage protection in that case\n        if (!oracle_.isTokenSupported(tokenIn_) || !oracle_.isTokenSupported(tokenOut_)) {\n            return 0;\n        }\n\n        return\n            amountIn_\n                .mulDown(oracle_.getUSDPrice(tokenIn_))\n                .divDown(oracle_.getUSDPrice(tokenOut_))\n                .convertScale(\n                    IERC20Metadata(tokenIn_).decimals(),\n                    IERC20Metadata(tokenOut_).decimals()\n                )\n                .mulDown(SLIPPAGE_THRESHOLD);\n    }\n}"
    }
  ]
}