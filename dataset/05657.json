{
  "Title": "[L-03] Rewards can be unintentionally overridden",
  "Content": "\n- https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol#L65\n- https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol#L74\n\nLidiquity mining rewards are set up using `setConcRewards()` or `setAmbRewards()`. In both cases, the rewards are overridden instead of accumulated. Taking `setConcRewards()` as the [example](https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol#L65-L72):\n\n```solidity\n65:     function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n66:         // require(msg.sender == governance_, \"Only callable by governance\");\n67:         require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n68:         while (weekFrom <= weekTo) {\n69:             concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n70:             weekFrom += uint32(WEEK);\n71:         }\n72:     }\n```\n\nLine 69 assigns the new value `weeklyReward` to the storage mapping. If rewards were already set for this pool, i.e. `concRewardPerWeek_[poolIdx][weekFrom] != 0`, then the new assignment will override the existing value.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/callpaths/LiquidityMiningPath.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"../mixins/StorageLayout.sol\";\nimport \"../mixins/LiquidityMining.sol\";\nimport \"../libraries/ProtocolCmd.sol\";\n\n/* @title Liquidity mining callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         components related to CANTO liquidity mining.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary CrocSwap contract.\n * @dev Since this contract is a proxy sidecar, entrypoints need to be marked\n *      payable even though it doesn't directly handle msg.value. Otherwise it will\n *      fail on any. Because of this, this contract should never be used in any other\n *      context besides a proxy sidecar to CrocSwapDex. */\ncontract LiquidityMiningPath is LiquidityMining {\n    /* @notice Consolidated method for protocol control related commands. \n     *         Used to set reward rates */\n    function protocolCmd(bytes calldata cmd) public virtual {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n\n    /* @notice Consolidated method for user commands.\n     *         Used for claiming liquidity mining rewards. */\n    function userCmd(bytes calldata input) public payable {\n        (uint8 code, bytes32 poolHash, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim) =\n            abi.decode(input, (uint8, bytes32, int24, int24, uint32[]));\n\n        if (code == UserCmd.CLAIM_CONC_REWARDS_CODE) {\n            claimConcentratedRewards(poolHash, lowerTick, upperTick, weeksToClaim);\n        } else if (code == UserCmd.CLAIM_AMB_REWARDS_CODE) {\n            claimAmbientRewards(poolHash, weeksToClaim);\n        } else {\n            revert(\"Invalid user command\");\n        }\n    }\n\n    function claimConcentratedRewards(bytes32 poolIdx, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim)\n        public\n        payable\n    {\n        claimConcentratedRewards(payable(msg.sender), poolIdx, lowerTick, upperTick, weeksToClaim);\n    }\n\n    function claimAmbientRewards(bytes32 poolIdx, uint32[] memory weeksToClaim) public payable {\n        claimAmbientRewards(payable(msg.sender), poolIdx, weeksToClaim);\n    }\n\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Croc sidecar proxy and used\n     *         in the correct slot. */\n    function acceptCrocProxyRole(address, uint16 slot) public pure returns (bool) {\n        return slot == CrocSlots.LIQUIDITY_MINING_PROXY_IDX;\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/callpaths/LiquidityMiningPath.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"../mixins/StorageLayout.sol\";\nimport \"../mixins/LiquidityMining.sol\";\nimport \"../libraries/ProtocolCmd.sol\";\n\n/* @title Liquidity mining callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         components related to CANTO liquidity mining.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary CrocSwap contract.\n * @dev Since this contract is a proxy sidecar, entrypoints need to be marked\n *      payable even though it doesn't directly handle msg.value. Otherwise it will\n *      fail on any. Because of this, this contract should never be used in any other\n *      context besides a proxy sidecar to CrocSwapDex. */\ncontract LiquidityMiningPath is LiquidityMining {\n    /* @notice Consolidated method for protocol control related commands. \n     *         Used to set reward rates */\n    function protocolCmd(bytes calldata cmd) public virtual {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n\n    /* @notice Consolidated method for user commands.\n     *         Used for claiming liquidity mining rewards. */\n    function userCmd(bytes calldata input) public payable {\n        (uint8 code, bytes32 poolHash, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim) =\n            abi.decode(input, (uint8, bytes32, int24, int24, uint32[]));\n\n        if (code == UserCmd.CLAIM_CONC_REWARDS_CODE) {\n            claimConcentratedRewards(poolHash, lowerTick, upperTick, weeksToClaim);\n        } else if (code == UserCmd.CLAIM_AMB_REWARDS_CODE) {\n            claimAmbientRewards(poolHash, weeksToClaim);\n        } else {\n            revert(\"Invalid user command\");\n        }\n    }\n\n    function claimConcentratedRewards(bytes32 poolIdx, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim)\n        public\n        payable\n    {\n        claimConcentratedRewards(payable(msg.sender), poolIdx, lowerTick, upperTick, weeksToClaim);\n    }\n\n    function claimAmbientRewards(bytes32 poolIdx, uint32[] memory weeksToClaim) public payable {\n        claimAmbientRewards(payable(msg.sender), poolIdx, weeksToClaim);\n    }\n\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Croc sidecar proxy and used\n     *         in the correct slot. */\n    function acceptCrocProxyRole(address, uint16 slot) public pure returns (bool) {\n        return slot == CrocSlots.LIQUIDITY_MINING_PROXY_IDX;\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/callpaths/LiquidityMiningPath.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"../mixins/StorageLayout.sol\";\nimport \"../mixins/LiquidityMining.sol\";\nimport \"../libraries/ProtocolCmd.sol\";\n\n/* @title Liquidity mining callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         components related to CANTO liquidity mining.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary CrocSwap contract.\n * @dev Since this contract is a proxy sidecar, entrypoints need to be marked\n *      payable even though it doesn't directly handle msg.value. Otherwise it will\n *      fail on any. Because of this, this contract should never be used in any other\n *      context besides a proxy sidecar to CrocSwapDex. */\ncontract LiquidityMiningPath is LiquidityMining {\n    /* @notice Consolidated method for protocol control related commands. \n     *         Used to set reward rates */\n    function protocolCmd(bytes calldata cmd) public virtual {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n\n    /* @notice Consolidated method for user commands.\n     *         Used for claiming liquidity mining rewards. */\n    function userCmd(bytes calldata input) public payable {\n        (uint8 code, bytes32 poolHash, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim) =\n            abi.decode(input, (uint8, bytes32, int24, int24, uint32[]));\n\n        if (code == UserCmd.CLAIM_CONC_REWARDS_CODE) {\n            claimConcentratedRewards(poolHash, lowerTick, upperTick, weeksToClaim);\n        } else if (code == UserCmd.CLAIM_AMB_REWARDS_CODE) {\n            claimAmbientRewards(poolHash, weeksToClaim);\n        } else {\n            revert(\"Invalid user command\");\n        }\n    }\n\n    function claimConcentratedRewards(bytes32 poolIdx, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim)\n        public\n        payable\n    {\n        claimConcentratedRewards(payable(msg.sender), poolIdx, lowerTick, upperTick, weeksToClaim);\n    }\n\n    function claimAmbientRewards(bytes32 poolIdx, uint32[] memory weeksToClaim) public payable {\n        claimAmbientRewards(payable(msg.sender), poolIdx, weeksToClaim);\n    }\n\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Croc sidecar proxy and used\n     *         in the correct slot. */\n    function acceptCrocProxyRole(address, uint16 slot) public pure returns (bool) {\n        return slot == CrocSlots.LIQUIDITY_MINING_PROXY_IDX;\n    }\n}"
    }
  ]
}