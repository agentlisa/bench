{
  "Title": "M-2: Blocklisted investors can still claim USDC in `TokenSale.sol`",
  "Content": "# Issue M-2: Blocklisted investors can still claim USDC in `TokenSale.sol` \n\nSource: https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/82 \n\n## Found by \nAMOW, Silvermist, ZdravkoHr., audithare, s1ce, ydlee\n## Summary\nA wrong argument is passed when checking if a user is blacklisted for claiming in [`TokenSale.claim()`](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L367). Because the check is insufficient, blocked users can claim their USDC.\n\n## Vulnerability Detail\n[`Admin.setClaimBlock()`](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/Admin.sol#L271-L273) blocks users from claiming. The function accepts the address of the user to be blocked and adds it to the `blockClaim` mapping.\n\n```solidity\n    /**\n     @dev Whitelist users\n     @param _address Address of User\n     */\n    function setClaimBlock(address _address) external onlyRole(OPERATOR) {\n        blockClaim[_address] = true;\n    }\n```\n\nThe check in `Admin.claim()` wrongly passes `address(this)` as argument when calling `Admin.blockClaim`.\n\n```solidity\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n```\nIn this context, `address(this)` will be the address of the token sale contract and the require statement can be bypassed even by a blocked user.\n## Impact\nThe whole functionality for blocking claims doesn't work properly.\n\n## Code Snippet\n```solidity\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nPass the address of the user.\n\n```diff\n        require(\n-            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n+            uint8(epoch) > 1 && !admin.blockClaim(msg.sender)),\n            \"TokenSale: Not time or not allowed\"\n        );\n```\n\n\n\n## Discussion\n\n**0502lian**\n\nBlockClaim function is used for instance(block the whole tokeSale ), not for one user.\n\n**Coareal**\n\nEscalate\n\nIssue is invalid. Implementation is correct and intended. The mentioned check is used to block a specific tokenSale instance, and not that of a user.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Issue is invalid. Implementation is correct and intended. The mentioned check is used to block a specific tokenSale instance, and not that of a user.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**s1ce**\n\nIssue should be valid. Comments in the code seem to suggest that this is on a per user basis.\n\n**ZdravkoHr**\n\nAgree with @s1ce. According to the Sherlock hierarchy of truth `protocol documentation (including code comments) > protocol answers on the contest public Discord channel.`\n\n**omar-ahsan**\n\nIssue should be invalid, the only issue here is that the comments are wrong.\n\n**Hash01011122**\n\nCan you give any reason on why this issue should be invalidated?? @Coareal @omar-ahsan \n\n**omar-ahsan**\n\n@Hash01011122 \n\n```solidity\n    /**\n     @dev Whitelist users\n     @param _address Address of User\n     */\n    function setClaimBlock(address _address) external onlyRole(OPERATOR) {\n        blockClaim[_address] = true;\n    }\n```\n\nThe comments above the function indicate whitelisting of users but this function is not intended to whitelist any address. `setClaimBlock()` as the name suggests is used to block an address by setting it to true in `blockClaim`. Similarly \n\n\n![image_123650291](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/assets/106596821/d6320e08-d87f-453c-a56a-7420127a5d7c)\n\nThe comments by sponsor team indicate that this function is used to block all incoming claims for a particular Token Sale which means all users can not claim from the token sale during the blocked duration. Currently the function does as intended according to this description.\n\nFurther more the code already contains a function to blacklist users i.e [addToBlackList()](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/Admin.sol#L145-L163). This function performs the blocking of single users by blocking the [deposit()](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L168-L171) function for blacklisted users which is the entry point to the token sale.\n \n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Lithium-Ventures/zap-contracts-labs/pull/3.\n\n**Hash01011122**\n\nGlad @omar-ahsan you did point out this mistake. My question to you is were watsons aware of this at the time of contest if not this is a valid finding. \n\n**omar-ahsan**\n\n> Glad @omar-ahsan you did point out this mistake. My question to you is were watsons aware of this at the time of contest if not this is a valid finding. \n\nSince the comments are misleading and not correct, the next source of information was the dev in the public chat. The screenshot of the message in my previous reply is from the public chat hence everyone knew this information.\n\n**Evert0x**\n\nPlanning to accept escalation and invalidate issue\n\n**ZdravkoHr**\n\n@Evert0x, so the Sherlock documentation should be updated to discord > comments?\n\n**Hash01011122**\n\n@Evert0x I think this is a valid issue, as Watson's were not aware of it before or at the time of the  contest. @omar-ahsan I understand that you had conversation with sponsors and they responded you in discord but not every watson was aware of it. I would like @Evert0x to reconsider his decision.\n\n**Evert0x**\n\n@Hash01011122 do you know if there was any other language for this function in the code or docs?\n\n**Hash01011122**\n\nAs far as I know there were no mentions about this in docs or in codebase\n\n**detectiveking123**\n\n@Evert0x @Czar102 \n\nThere are a lot, and I mean a lot, of issues with the documentation in this codebase. This has left a lot of ambiguity in terms of what the sponsors actually want vs the design decisions they've consciously made. \n\nI would recommend only rewarding issues that actually cause a loss of funds or very, very clearly break protocol functionality (i.e. it's just definitely not a design decision). This issue, as well as #87 and #56, fall into the category of \"maybe the sponsors intended this, maybe they didn't\", and I don't think any of them should be valid issues. \n\n**Nilay27**\n\n> @Evert0x @Czar102\n> \n> There are a lot, and I mean a lot, of issues with the documentation in this codebase. This has left a lot of ambiguity in terms of what the sponsors actually want vs the design decisions they've consciously made.\n> \n> I would recommend only rewarding issues that actually cause a loss of funds or very, very clearly break protocol functionality (i.e. it's just definitely not a design decision). This issue, as well as #87 and #56, fall into the category of \"maybe the sponsors intended this, maybe they didn't\", and I don't think any of them should be valid issues.\n\n\n\n@detectiveking123, I understand your concerns about potentially overreporting issues that may be interpreted as design decisions rather than genuine flaws. \n\nHowever, as a Watson, we rely heavily on the documentation provided to guide our auditing process. When the documentation is unclear and the sponsors are not available for clarification, we must address potential vulnerabilities based on our best understanding of the intended functionality.\n\nConsidering the nature of a competitive audit, dismissing ambiguities that arise from unclear documentation could inadvertently overlook genuine issues and waste a lot of Watsons' time due to a lack of due diligence before the audit.\n\n@Evert0x @Czar102 @Hash01011122, I would like to request that we only finalize these issues once after the sponsors' confirmation. While this might be a bit of a hassle, but this would be the fairest approach.\n\n\n**Hash01011122**\n\nI stand by what I mentioned earlier that this should remain a valid issue. @Evert0x @Czar102 \n\n**Evert0x**\n\nWith the hierarchy of truth at the time of the contest I believe the right judgment is to reject the escalation and keep the issue valid. \n\n**detectiveking123**\n\n@Evert0x Judgement doesn't make sense. By that logic, there are so many other issues in this contest that should be valid, just because the documentation is completely wrong. \n\n**Hash01011122**\n\n@detectiveking123 I've already justified the validity of this issue above. If you can provide a counterargument using any rule from Sherlock's documentation, please do so. If not please refrain to comment on this issue.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Coareal](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/82/#issuecomment-2025929501): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/243",
  "Code": [
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i = 0; i < users.length; i++) {\n            isWhitelisted[users[i]] = true;\n        }\n    }\n\n    function setAllocationAndTax(uint256[3] calldata _allocations) external {\n        require(block.timestamp <= params.privateStart, \"Time lapsed\");\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        maxAllocation = _allocations[0];\n        globalTaxRate = _allocations[1];\n        whitelistTxRate = _allocations[2];\n    }\n\n    function setMarketingWallet(address _wallet) external {\n        _onlyAdmin();\n        marketingWallet = _wallet;\n    }\n\n    /**\n     * @dev setup the current tokensale stage (epoch)\n     */\n    function checkingEpoch() public {\n        uint256 time = block.timestamp;\n        if (\n            epoch != Epoch.Private &&\n            time >= params.privateStart &&\n            time <= params.privateEnd\n        ) {\n            epoch = Epoch.Private;\n            return;\n        }\n        if ((epoch != Epoch.Finished && (time > params.privateEnd))) {\n            epoch = Epoch.Finished;\n            return;\n        }\n    }\n\n    // to save size\n    function _onlyAdmin() internal view {\n        require(\n            admin.hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                msg.sender == address(admin),\n            \"TokenSale: Onlyadmin\"\n        );\n    }\n\n    /**\n     * @dev invest usdc to the tokensale\n     */\n    function deposit(uint256 _amount) external {\n        console.log(\"kyc enabled\", isKYCEnabled);\n        if (isKYCEnabled) {\n            require(admin.isKYCDone(msg.sender) == true, \"KYC not done\");\n        }\n        address sender = msg.sender;\n        require(\n            !admin.blacklist(address(this), sender),\n            \"TokenSale: Blacklisted\"\n        );\n        checkingEpoch();\n\n        require(epoch == Epoch.Private, \"TokenSale: Incorrect time\");\n        require(_amount > 0, \"TokenSale: 0 deposit\");\n\n        if (userDepositIndex[sender] == 0) {\n            usersOnDeposit.push(sender);\n            userDepositIndex[sender] = usersOnDeposit.length;\n        }\n        if (epoch == Epoch.Private) {\n            _processPrivate(sender, _amount);\n        }\n    }\n\n    function destroy() external override {\n        _onlyAdmin();\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n        address payable wallet = payable(admin.wallet());\n        selfdestruct(wallet);\n    }\n\n    /**\n     * @notice withdraw accidently sent ERC20 tokens\n     * @param _tokenAddress address of token to withdraw\n     */\n    function removeOtherERC20Tokens(address _tokenAddress) external {\n        _onlyAdmin();\n        require(\n            _tokenAddress != address(usdc),\n            \"TokenSale: Can't withdraw usdc\"\n        );\n        uint256 balance = IERC20D(_tokenAddress).balanceOf(address(this));\n        IERC20D(_tokenAddress).safeTransfer(admin.wallet(), balance);\n\n        emit ERC20TokensRemoved(_tokenAddress, msg.sender, balance);\n    }\n\n    /**\n     * @dev processing usdc investment to the private round\n     * @param _sender - transaction sender\n     * @param _amount - investment amount in usdc\n     */\n    function _processPrivate(address _sender, uint256 _amount) internal {\n        require(_amount > 0, \"TokenSale: Too small\");\n\n        Staked storage s = stakes[_sender];\n        uint256 amount = _amount * PCT_BASE;\n        uint256 sum = s.amount + amount;\n\n        uint256 maxAllocationOfUser = (calculateMaxAllocation(_sender)) *\n            PCT_BASE;\n        require(sum <= maxAllocationOfUser, \"upto max allocation\");\n        uint256 taxFreeAllcOfUser = 0; // hardcode zero - all pools have ax\n\n        uint256 userTaxAmount;\n\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n\n        if (userTaxAmount > 0) {\n            s.taxAmount += userTaxAmount;\n            usdc.safeTransferFrom(_sender, marketingWallet, userTaxAmount);\n        }\n        s.amount += uint128(amount);\n        state.totalPrivateSold += uint128(amount);\n        usdc.safeTransferFrom(_sender, address(this), amount);\n\n        /**@notice Forbid unstaking*/\n        // stakingContract.setPoolsEndTime(_sender, uint256(params.privateEnd)); // TODO: uncomment\n        emit DepositPrivate(_sender, _amount, address(this));\n    }\n\n    /**\n     * @dev sends the usdc raise to admin's wallet\n     */\n\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n\n        if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n\n    function _maxTaxfreeAllocation(address _sender) internal returns (uint256) {\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTierAllc > giftedTierAllc) {\n            return userTierAllc;\n        } else {\n            return giftedTierAllc;\n        }\n    }\n\n    function _maxTierAllc(address _sender) internal returns (uint256) {\n        (uint256 userTier, uint256 userLockLvl, , ) = stakingContract\n            .getUserState(_sender);\n\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTier == 0 && giftedTierAllc == 0) {\n            return 0;\n        }\n\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 nextTierAllc;\n        if (userLockLvl > 0 && userLockLvl < 4) {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl + 1,\n                userTier\n            );\n        } else {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl,\n                userTier + 1\n            );\n        }\n\n        if (nextTierAllc > userTierAllc) {\n            if (nextTierAllc > giftedTierAllc) {\n                return nextTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        } else {\n            if (userTierAllc > giftedTierAllc) {\n                return userTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        }\n    }\n\n    // _amount should be in dollar without decimals\n    function userTaxRate(\n        uint256 _amount,\n        address _sender\n    ) public returns (uint256) {\n        uint256 userTaxFreeAllc = 0;\n\n        if (_amount > userTaxFreeAllc) {\n            if (isWhitelisted[_sender]) {\n                return whitelistTxRate;\n            } else {\n                return globalTaxRate;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    function takeUSDCRaised() external override {\n        checkingEpoch();\n        require(epoch == Epoch.Finished, \"TokenSale: Not time yet\");\n        require(!isRaiseClaimed, \"TokenSale: Already paid\");\n\n        uint256 earned;\n\n        if (state.totalPrivateSold > state.totalSupplyInValue) {\n            earned = uint256(state.totalSupplyInValue);\n        } else {\n            earned = uint256(state.totalPrivateSold);\n        }\n\n        isRaiseClaimed = true;\n\n        if (earned > 0) {\n            uint256 bal = usdc.balanceOf(address(this));\n            uint256 returnValue = earned <= bal ? earned : bal;\n            usdc.safeTransfer(admin.wallet(), returnValue);\n        }\n\n        emit RaiseClaimed(admin.wallet(), earned);\n    }\n\n    /**\n     * @dev allows the participants of the private round to claim usdc left\n     */\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n\n    function _claim(Staked memory _s) internal view returns (uint120, uint256) {\n        uint256 left;\n        if (state.totalPrivateSold > (state.totalSupplyInValue)) {\n            uint256 rate = (state.totalSupplyInValue * PCT_BASE) /\n                state.totalPrivateSold;\n            _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n            left = uint256(_s.amount) - uint256(_s.share);\n        } else {\n            _s.share = uint120(_s.amount);\n        }\n\n        return (_s.share, left);\n    }\n\n    function canClaim(address _user) external view returns (uint120, uint256) {\n        return _claim(stakes[_user]);\n    }\n\n    /**\n     * @dev sends Locked usdc to admin wallet\n     */\n\n    function takeLocked() external override {\n        _onlyAdmin();\n        require(\n            block.timestamp >= (params.privateEnd + 2592e3),\n            \"TokenSale: Not ended\"\n        );\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n    }\n\n    /**\n    @dev Total Tokens (in $) sold in IDO\n     */\n    function totalTokenSold() external view returns (uint128) {\n        return state.totalPrivateSold;\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/Admin.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/ITokenSale.sol\";\n\n/**\n * @title Admin.\n * @dev contract creates tokenSales.\n *\n */\n\ncontract Admin is AccessControl, IAdmin, Initializable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    bytes32 public constant STAKING = keccak256(\"STAKING\");\n\n    uint256 public constant POINT_BASE = 1000;\n\n    address[] public override tokenSales;\n    address public override masterTokenSale;\n    address public override stakingContract;\n    address public override wallet;\n    address public override airdrop;\n    address public override superCharge;\n\n    mapping(address => bool) public override tokenSalesM;\n    mapping(address => bool) public override blockClaim;\n    mapping(address => uint256) public indexOfTokenSales;\n    mapping(address => ITokenSale.Params) params;\n    mapping(address => mapping(address => bool)) public override blacklist;\n    mapping(address => bool) public isKYCDone;\n\n    /**\n     ** @dev Initialize Function,gives the deployer DEFAULT_ADMIN_ROLE\n     ** @param _owner: Owner address\n     */\n    function initialize(address _owner) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n        _setRoleAdmin(OPERATOR, DEFAULT_ADMIN_ROLE);\n        wallet = _owner;\n    }\n\n    /**\n     * @dev Modifier that checks address is not ZERO address.\n     */\n    modifier validation(address _address) {\n        require(_address != address(0), \"TokenSale: Zero address\");\n        _;\n    }\n\n    /**\n     * @dev Only Admin contract can call\n     */\n    modifier onlyAdmin() {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n            \"TokenSale: Not admin\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Only Staking contract can call\n     */\n\n    modifier onlyStaking() {\n        require(hasRole(STAKING, msg.sender), \"TokenSale: Only Staking\");\n        _;\n    }\n\n    /**\n     * @dev Checks IDO existence\n     */\n    modifier onlyExist(address _instance) {\n        require(tokenSalesM[_instance], \"TokenSale: Pool Not Exist\");\n        _;\n    }\n\n    /**\n     * @dev Checks an Incoming Private pool(IDO)\n     */\n    modifier onlyIncoming(address _instance) {\n        require(\n            params[_instance].privateStart > block.timestamp,\n            \"TokenSale: Pool already started\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set Admin Wallet\n     */\n    function setWallet(\n        address _address\n    ) external validation(_address) onlyAdmin {\n        wallet = _address;\n    }\n\n    /**\n     * @dev Only Admin can add an Operator\n     */\n\n    function addOperator(address _address) external virtual onlyAdmin {\n        grantRole(OPERATOR, _address);\n    }\n\n    /**\n     * @dev Only Admin can remove an Operator\n     */\n\n    function removeOperator(address _address) external virtual onlyAdmin {\n        revokeRole(OPERATOR, _address);\n    }\n\n    /**\n     ** @dev IDO parameters\n     ** @param _instance IDO address\n     */\n    function getParams(\n        address _instance\n    ) external view override returns (ITokenSale.Params memory) {\n        return params[_instance];\n    }\n\n    /**\n     ** @dev Destroying IDO\n     ** @param _instance IDO address\n     */\n    function destroyInstance(\n        address _instance\n    ) external onlyExist(_instance) onlyIncoming(_instance) {\n        _removeFromSales(_instance);\n        ITokenSale(_instance).destroy();\n    }\n\n    /**\n     * @dev add users to blacklist\n     * @param _blacklist - the list of users to add to the blacklist\n     */\n    function addToBlackList(\n        address _instance,\n        address[] memory _blacklist\n    )\n        external\n        override\n        onlyIncoming(_instance)\n        onlyExist(_instance)\n        onlyRole(OPERATOR)\n    {\n        require(_blacklist.length <= 500, \"TokenSale: Too large array\");\n        for (uint256 i = 0; i < _blacklist.length; i++) {\n            blacklist[_instance][_blacklist[i]] = true;\n        }\n    }\n\n    /**\n    @dev returns the total no of IDO's created till now\n    */\n    function getTokenSalesCount() external view returns (uint256) {\n        return tokenSales.length;\n    }\n\n    /**\n    @dev adds an IDO to an array\n    @param _addr - address of an Instance\n    */\n\n    function _addToSales(address _addr) internal {\n        tokenSalesM[_addr] = true;\n        indexOfTokenSales[_addr] = tokenSales.length;\n        tokenSales.push(_addr);\n    }\n\n    /**\n    @dev removes an IDO to an array\n    @param _addr - address of an Instance\n    */\n    function _removeFromSales(address _addr) internal {\n        tokenSalesM[_addr] = false;\n        tokenSales[indexOfTokenSales[_addr]] = tokenSales[\n            tokenSales.length - 1\n        ];\n        indexOfTokenSales[\n            tokenSales[tokenSales.length - 1]\n        ] = indexOfTokenSales[_addr];\n        tokenSales.pop();\n        delete indexOfTokenSales[_addr];\n    }\n\n    /**\n    @dev Checking parameters of IDO\n    @param _params - IDO parameters\n    */\n    function _checkingParams(ITokenSale.Params memory _params) internal view {\n        require(_params.totalSupply > 0, \"TokenSale: TotalSupply > 0\");\n        require(\n            _params.privateStart >= block.timestamp,\n            \"TokenSale: Start time > 0\"\n        );\n        require(\n            _params.privateEnd > _params.privateStart,\n            \"TokenSale: End time > start time\"\n        );\n    }\n\n    /**\n       @notice Initializes TokenSale contract.\n       @dev creates new pool.\n       @param _params describes prices, timeline, limits of new pool.\n     */\n\n    function createPool(\n        ITokenSale.Params memory _params\n    ) external override onlyRole(OPERATOR) {\n        require(false, \"Not valid\");\n    }\n\n    /**\n     * @dev returns all token sales\n     */\n\n    function getTokenSales() external view override returns (address[] memory) {\n        return tokenSales;\n    }\n\n    /**\n     @dev set address for tokensale.\n     @param _address Address of TokenSale contract\n     */\n    function setMasterContract(\n        address _address\n    ) external override validation(_address) onlyAdmin {\n        masterTokenSale = _address;\n    }\n\n    /**\n     @dev set address for airdrop \n     @param _address Address of Airdrop contract\n     */\n    function setAirdrop(\n        address _address\n    ) external override validation(_address) onlyAdmin {\n        airdrop = _address;\n        emit SetAirdrop(_address);\n    }\n\n    /**\n    @dev set address for staking contract.\n     @param _address Address of Staking contract\n     */\n    function setStakingContract(\n        address _address\n    ) external override validation(_address) onlyAdmin {\n        stakingContract = _address;\n        _setupRole(STAKING, address(_address));\n    }\n\n    /**\n     @dev Whitelist users\n     @param _address Address of User\n     */\n    function setClaimBlock(address _address) external onlyRole(OPERATOR) {\n        blockClaim[_address] = true;\n    }\n\n    /**\n     @dev Blacklist users\n     @param _address Address of User\n     */\n    function removeClaimBlock(address _address) external onlyRole(OPERATOR) {\n        blockClaim[_address] = false;\n    }\n\n    function setSuperCharge(\n        address _superCharge\n    ) external override validation(_superCharge) onlyAdmin {\n        superCharge = _superCharge;\n    }\n\n    function setUserKYC(address[] calldata users) public onlyRole(OPERATOR) {\n        for (uint256 i = 0; i < users.length; i++) {\n            isKYCDone[users[i]] = true;\n        }\n    }\n\n    function createPoolNew(\n        ITokenSale.Params memory _params,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external override onlyRole(OPERATOR) {\n        _checkingParams(_params);\n        address instance = Clones.clone(masterTokenSale);\n        params[instance] = _params;\n        ITokenSale(instance).initialize(\n            _params,\n            stakingContract,\n            address(this),\n            _maxAllocation,\n            _globalTaxRate,\n            _isKYC,\n            _whitelistTxRate\n        );\n\n        _addToSales(instance);\n        emit CreateTokenSale(instance);\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/Admin.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/ITokenSale.sol\";\n\n/**\n * @title Admin.\n * @dev contract creates tokenSales.\n *\n */\n\ncontract Admin is AccessControl, IAdmin, Initializable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    bytes32 public constant STAKING = keccak256(\"STAKING\");\n\n    uint256 public constant POINT_BASE = 1000;\n\n    address[] public override tokenSales;\n    address public override masterTokenSale;\n    address public override stakingContract;\n    address public override wallet;\n    address public override airdrop;\n    address public override superCharge;\n\n    mapping(address => bool) public override tokenSalesM;\n    mapping(address => bool) public override blockClaim;\n    mapping(address => uint256) public indexOfTokenSales;\n    mapping(address => ITokenSale.Params) params;\n    mapping(address => mapping(address => bool)) public override blacklist;\n    mapping(address => bool) public isKYCDone;\n\n    /**\n     ** @dev Initialize Function,gives the deployer DEFAULT_ADMIN_ROLE\n     ** @param _owner: Owner address\n     */\n    function initialize(address _owner) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n        _setRoleAdmin(OPERATOR, DEFAULT_ADMIN_ROLE);\n        wallet = _owner;\n    }\n\n    /**\n     * @dev Modifier that checks address is not ZERO address.\n     */\n    modifier validation(address _address) {\n        require(_address != address(0), \"TokenSale: Zero address\");\n        _;\n    }\n\n    /**\n     * @dev Only Admin contract can call\n     */\n    modifier onlyAdmin() {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n            \"TokenSale: Not admin\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Only Staking contract can call\n     */\n\n    modifier onlyStaking() {\n        require(hasRole(STAKING, msg.sender), \"TokenSale: Only Staking\");\n        _;\n    }\n\n    /**\n     * @dev Checks IDO existence\n     */\n    modifier onlyExist(address _instance) {\n        require(tokenSalesM[_instance], \"TokenSale: Pool Not Exist\");\n        _;\n    }\n\n    /**\n     * @dev Checks an Incoming Private pool(IDO)\n     */\n    modifier onlyIncoming(address _instance) {\n        require(\n            params[_instance].privateStart > block.timestamp,\n            \"TokenSale: Pool already started\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set Admin Wallet\n     */\n    function setWallet(\n        address _address\n    ) external validation(_address) onlyAdmin {\n        wallet = _address;\n    }\n\n    /**\n     * @dev Only Admin can add an Operator\n     */\n\n    function addOperator(address _address) external virtual onlyAdmin {\n        grantRole(OPERATOR, _address);\n    }\n\n    /**\n     * @dev Only Admin can remove an Operator\n     */\n\n    function removeOperator(address _address) external virtual onlyAdmin {\n        revokeRole(OPERATOR, _address);\n    }\n\n    /**\n     ** @dev IDO parameters\n     ** @param _instance IDO address\n     */\n    function getParams(\n        address _instance\n    ) external view override returns (ITokenSale.Params memory) {\n        return params[_instance];\n    }\n\n    /**\n     ** @dev Destroying IDO\n     ** @param _instance IDO address\n     */\n    function destroyInstance(\n        address _instance\n    ) external onlyExist(_instance) onlyIncoming(_instance) {\n        _removeFromSales(_instance);\n        ITokenSale(_instance).destroy();\n    }\n\n    /**\n     * @dev add users to blacklist\n     * @param _blacklist - the list of users to add to the blacklist\n     */\n    function addToBlackList(\n        address _instance,\n        address[] memory _blacklist\n    )\n        external\n        override\n        onlyIncoming(_instance)\n        onlyExist(_instance)\n        onlyRole(OPERATOR)\n    {\n        require(_blacklist.length <= 500, \"TokenSale: Too large array\");\n        for (uint256 i = 0; i < _blacklist.length; i++) {\n            blacklist[_instance][_blacklist[i]] = true;\n        }\n    }\n\n    /**\n    @dev returns the total no of IDO's created till now\n    */\n    function getTokenSalesCount() external view returns (uint256) {\n        return tokenSales.length;\n    }\n\n    /**\n    @dev adds an IDO to an array\n    @param _addr - address of an Instance\n    */\n\n    function _addToSales(address _addr) internal {\n        tokenSalesM[_addr] = true;\n        indexOfTokenSales[_addr] = tokenSales.length;\n        tokenSales.push(_addr);\n    }\n\n    /**\n    @dev removes an IDO to an array\n    @param _addr - address of an Instance\n    */\n    function _removeFromSales(address _addr) internal {\n        tokenSalesM[_addr] = false;\n        tokenSales[indexOfTokenSales[_addr]] = tokenSales[\n            tokenSales.length - 1\n        ];\n        indexOfTokenSales[\n            tokenSales[tokenSales.length - 1]\n        ] = indexOfTokenSales[_addr];\n        tokenSales.pop();\n        delete indexOfTokenSales[_addr];\n    }\n\n    /**\n    @dev Checking parameters of IDO\n    @param _params - IDO parameters\n    */\n    function _checkingParams(ITokenSale.Params memory _params) internal view {\n        require(_params.totalSupply > 0, \"TokenSale: TotalSupply > 0\");\n        require(\n            _params.privateStart >= block.timestamp,\n            \"TokenSale: Start time > 0\"\n        );\n        require(\n            _params.privateEnd > _params.privateStart,\n            \"TokenSale: End time > start time\"\n        );\n    }\n\n    /**\n       @notice Initializes TokenSale contract.\n       @dev creates new pool.\n       @param _params describes prices, timeline, limits of new pool.\n     */\n\n    function createPool(\n        ITokenSale.Params memory _params\n    ) external override onlyRole(OPERATOR) {\n        require(false, \"Not valid\");\n    }\n\n    /**\n     * @dev returns all token sales\n     */\n\n    function getTokenSales() external view override returns (address[] memory) {\n        return tokenSales;\n    }\n\n    /**\n     @dev set address for tokensale.\n     @param _address Address of TokenSale contract\n     */\n    function setMasterContract(\n        address _address\n    ) external override validation(_address) onlyAdmin {\n        masterTokenSale = _address;\n    }\n\n    /**\n     @dev set address for airdrop \n     @param _address Address of Airdrop contract\n     */\n    function setAirdrop(\n        address _address\n    ) external override validation(_address) onlyAdmin {\n        airdrop = _address;\n        emit SetAirdrop(_address);\n    }\n\n    /**\n    @dev set address for staking contract.\n     @param _address Address of Staking contract\n     */\n    function setStakingContract(\n        address _address\n    ) external override validation(_address) onlyAdmin {\n        stakingContract = _address;\n        _setupRole(STAKING, address(_address));\n    }\n\n    /**\n     @dev Whitelist users\n     @param _address Address of User\n     */\n    function setClaimBlock(address _address) external onlyRole(OPERATOR) {\n        blockClaim[_address] = true;\n    }\n\n    /**\n     @dev Blacklist users\n     @param _address Address of User\n     */\n    function removeClaimBlock(address _address) external onlyRole(OPERATOR) {\n        blockClaim[_address] = false;\n    }\n\n    function setSuperCharge(\n        address _superCharge\n    ) external override validation(_superCharge) onlyAdmin {\n        superCharge = _superCharge;\n    }\n\n    function setUserKYC(address[] calldata users) public onlyRole(OPERATOR) {\n        for (uint256 i = 0; i < users.length; i++) {\n            isKYCDone[users[i]] = true;\n        }\n    }\n\n    function createPoolNew(\n        ITokenSale.Params memory _params,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external override onlyRole(OPERATOR) {\n        _checkingParams(_params);\n        address instance = Clones.clone(masterTokenSale);\n        params[instance] = _params;\n        ITokenSale(instance).initialize(\n            _params,\n            stakingContract,\n            address(this),\n            _maxAllocation,\n            _globalTaxRate,\n            _isKYC,\n            _whitelistTxRate\n        );\n\n        _addToSales(instance);\n        emit CreateTokenSale(instance);\n    }\n}"
    }
  ]
}