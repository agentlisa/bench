{
  "Title": "H-5: Leverage calculation is wrong",
  "Content": "# Issue H-5: Leverage calculation is wrong \n\nSource: https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/150 \n\n## Found by \n0xDjango, n33k, twicek\n## Summary\nLeverage calculation is wrong which will lead to unfair liquidations or over leveraged positions depending on price movements.\n\n## Vulnerability Detail\n`_calculate_leverage` miscalculate the leverage by using `_debt_value + _margin_value` as numerator instead of `_position_value `:\n\n[Vault.vy#L465-L477](https://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/margin-dex/Vault.vy#L465-L477)\n```solidity\ndef _calculate_leverage(\n    _position_value: uint256, _debt_value: uint256, _margin_value: uint256\n) -> uint256:\n    if _position_value <= _debt_value:\n        # bad debt\n        return max_value(uint256)\n\n\n    return (\n        PRECISION\n        * (_debt_value + _margin_value)\n        / (_position_value - _debt_value)\n        / PRECISION\n    )\n```\n\nThe three inputs of the function `_position_value`, `_debt_value` and `_margin_value` are all determined by a chainlink oracle price feed.\n`_debt_value` represents the value of the position's debt share converted to debt amount in USD.\n`_margin_value` represents the current value of the position's initial margin amount in USD.\n`_position_value` represents the current value of the position's initial position amount in USD.\n\nThe problem with the above calculation is that `_debt_value + _margin_value` does not represent the value of the position. The leverage is the ratio between the current value of the position and the current margin value. `_position_value - _debt_value` is correct and is the current margin value, but `_debt_value + _margin_value` doesn't represent the current value of the position since there is no guarantee that the debt token and the position token have correlated price movements.\n\nExample: debt token: ETH, position token: BTC.\n- Alice uses 1 ETH of margin to borrow 14 ETH (2k USD/ETH) and get 1 BTC (30k USD/BTC) of position token. Leverage is 14.\n- The next day, the price of ETH in USD is still 2k USD/ETH but BTC price in USD went down from 30k to 29k USD/BTC. Leverage is now (`_position_value == 29k`) / (`_position_value == 29k` - `_debt_value == 28k`) = 29, instead of what is calculated in the contract: (`_debt_value == 28k + _margin_value == 2k`) / (`_position_value == 29k` - `_debt_value == 28k`) = 30.\n\n\n## Impact\nLeverage calculation is wrong which will lead to unfair liquidations or over leveraged positions depending on price movements.\n\n## Code Snippet\n[Vault.vy#L465-L477](https://github.com/sherlock-audit/2023-06-unstoppable/blob/main/unstoppable-dex-audit/contracts/margin-dex/Vault.vy#L465-L477)\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider modifying the code like this:\n\n```solidity\ndef _calculate_leverage(\n    _position_value: uint256, _debt_value: uint256, _margin_value: uint256\n) -> uint256:\n    if _position_value <= _debt_value:\n        # bad debt\n        return max_value(uint256)\n\n\n    return (\n        PRECISION\n-       * (_debt_value + _margin_value)\n+       * (_position_value)\n        / (_position_value - _debt_value)\n        / PRECISION\n    )\n```\n\n\n\n## Discussion\n\n**Unstoppable-DeFi**\n\nWhile our implementation uses a slightly different definition of leverage and the initial margin + debt as base, we agree that the above implementation is cleaner and more intuitive for users. \nBoth formulas would work similarly though and liquidate positions timely to protect the protocol.\n\n**141345**\n\nagree, maybe medium is more appropriate\n\n**141345**\n\nThe dup https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/100 gives an example why the current formula could lead to unexpected result. \n\n**twicek**\n\nEscalate for 10 USDC.\nMy report shows why the current used formula is wrong as it does not take into account that debt tokens and position tokens are not necessarily tokens with correlated prices.\nThe duplicate #100 shows in another way that the formula fail to calculate the leverage of a position correctly.\nThe impact is the same, but my report highlight `_debt_value + _margin_value != _position_value`, the same way that the debt against a house is not equal to the market value of this house (also described in another way in #156).\nThe definition of leverage used in the code is not correct and will lead to unfair liquidations or over leveraged positions, which is definitely high severity.\n\n**sherlock-admin2**\n\n > Escalate for 10 USDC.\n> My report shows why the current used formula is wrong as it does not take into account that debt tokens and position tokens are not necessarily tokens with correlated prices.\n> The duplicate #100 shows in another way that the formula fail to calculate the leverage of a position correctly.\n> The impact is the same, but my report highlight `_debt_value + _margin_value != _position_value`, the same way that the debt against a house is not equal to the market value of this house (also described in another way in #156).\n> The definition of leverage used in the code is not correct and will lead to unfair liquidations or over leveraged positions, which is definitely high severity.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**fatherGoose1**\n\nThe duplicate report #100 shows how adding margin makes a position less healthy, and removing margin makes a position healthier. This is simply a backwards implementation that will lead to unfair liquidations or higher leverage than should be possible. The impact is clear loss of funds.\n\n**141345**\n\nRecommendation: \nchange the original judging, to high severity.\n\n> Escalate for 10 USDC. My report shows why the current used formula is wrong as it does not take into account that debt tokens and position tokens are not necessarily tokens with correlated prices. The duplicate #100 shows in another way that the formula fail to calculate the leverage of a position correctly. The impact is the same, but my report highlight `_debt_value + _margin_value != _position_value`, the same way that the debt against a house is not equal to the market value of this house (also described in another way in #156). The definition of leverage used in the code is not correct and will lead to unfair liquidations or over leveraged positions, which is definitely high severity.\n\nUnexpected and unfair liquidation could cause loss to users. Since the issue roots from the formula, the loss could be long term, result in accumulated fund loss for users, can can be deemed as \"material loss of funds\". \n\nBased on the above, high severity might be appropriate.\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/unstoppable-dex-audit/pull/14\n\n**hrishibhat**\n\n@Unstoppable-DeFi based on the above escalation it seems to be a high issue. Is there any other reason this should not be a high-severity issue?\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nConsidering this issue a valid high\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [twicek](https://github.com/sherlock-audit/2023-06-unstoppable-judging/issues/150/#issuecomment-1643977677): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/95",
  "Code": [
    {
      "filename": "unstoppable-dex-audit/contracts/margin-dex/Vault.vy",
      "content": "# @version ^0.3.7\n\n###################################################################\n#\n# @title Unstoppable Margin DEX - Vault\n# @license GNU AGPLv3\n# @author unstoppable.ooo\n#\n# @custom:security-contact team@unstoppable.ooo\n#\n# @notice\n#    This contract is part of the Unstoppable Margin DEX.\n#\n#    It handles all assets and allows whitelisted contracts\n#    to create undercollateralized loan positions for users\n#    that are then used to gain leveraged spot exposure to\n#    an underlying asset.\n#\n###################################################################\n\ninterface ERC20:\n    def balanceOf(_account: address) -> uint256: view\n    def decimals() -> uint8: view\n    def approve(_spender: address, _amount: uint256): nonpayable\n\ninterface ChainlinkOracle:\n    def latestRoundData() -> (\n      uint80,  # roundId,\n      int256,  # answer,\n      uint256, # startedAt,\n      uint256, # updatedAt,\n      uint80   # answeredInRound\n    ): view\n\ninterface SwapRouter:\n    def swap(\n        _token_in: address,\n        _token_out: address,\n        _amount_in: uint256,\n        _min_amount_out: uint256\n        ) -> uint256: nonpayable\n\ninterface Weth:\n    def deposit(): payable\n    def withdrawTo(_account: address, _amount: uint256): nonpayable\n\n\nPRECISION: constant(uint256) = 10**18\n\nSECONDS_PER_YEAR: constant(uint256) = 365 * 24 * 60 * 60\nPERCENTAGE_BASE: constant(uint256) = 100_00 # == 100%\nPERCENTAGE_BASE_HIGH_PRECISION: constant(uint256) = 100_00_000  # == 100%\n\nARBITRUM_SEQUENCER_UPTIME_FEED: constant(address) = 0xFdB631F5EE196F0ed6FAa767959853A9F217697D\nORACLE_FRESHNESS_THRESHOLD: constant(uint256) = 24*60*60 # 24h\n\nWETH: constant(address) = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\n\nFULL_UTILIZATION: constant(uint256) = 100_00_000\nFALLBACK_INTEREST_CONFIGURATION: constant(uint256[4]) = [\n    3_00_000,\n    20_00_000,\n    100_00_000,\n    80_00_000,\n]\n\nswap_router: public(address)\n\n# whitelisted addresses allowed to interact with this vault\nis_whitelisted_dex: public(HashMap[address, bool])\n\n# address -> address -> bool\nis_whitelisted_token: public(HashMap[address, bool])\n# token_in -> # token_out\nis_enabled_market: HashMap[address, HashMap[address, bool]]\n# token_in -> # token_out\nmax_leverage: public(HashMap[address, HashMap[address, uint256]])\n# token -> Chainlink oracle\nto_usd_oracle: public(HashMap[address, address])\n# token_in -> # token_out -> slippage\nliquidate_slippage: public(HashMap[address, HashMap[address, uint256]])\n\n# the fee charged to traders when opening a position\ntrade_open_fee: public(uint256) # 10 = 0.1%\nliquidation_penalty: public(uint256)\n# share of trading fee going to LPs vs protocol\ntrading_fee_lp_share: public(uint256) \nprotocol_fee_receiver: public(address)\n\n# trader margin balances\nmargin: public(HashMap[address, HashMap[address, uint256]])\n\n# Liquidity\n# cooldown to prevent flashloan deposit/withdraws\nwithdraw_liquidity_cooldown: public(uint256)\naccount_withdraw_liquidity_cooldown: public(HashMap[address, uint256])\n\n# base LPs\nbase_lp_shares: public(HashMap[address, HashMap[address, uint256]])\nbase_lp_total_shares: public(HashMap[address, uint256])\nbase_lp_total_amount: public(HashMap[address, uint256])\n\n# Safety Module LPs\nsafety_module_lp_shares: public(HashMap[address, HashMap[address, uint256]])\nsafety_module_lp_total_shares: public(HashMap[address, uint256])\nsafety_module_lp_total_amount: public(HashMap[address, uint256])\n\nsafety_module_interest_share_percentage: public(uint256)\n\n\n# debt_token -> total_debt_shares\ntotal_debt_shares: public(HashMap[address, uint256])\n# debt_token -> Position uid -> debt_shares\ndebt_shares: public(HashMap[address, HashMap[bytes32, uint256]])\n# debt_token -> total_debt\ntotal_debt_amount: public(HashMap[address, uint256])\n# debt_token -> timestamp\nlast_debt_update: public(HashMap[address, uint256])\n\n# token -> bad_debt\nbad_debt: public(HashMap[address, uint256])\n\n# dynamic interest rates [min, mid, max, kink]\ninterest_configuration: HashMap[address, uint256[4]]\n\nstruct Position:\n    uid: bytes32\n    account: address\n    debt_token: address\n    margin_amount: uint256\n    debt_shares: uint256\n    position_token: address\n    position_amount: uint256\n\n# uid -> Position\npositions: public(HashMap[bytes32, Position])\n\nuid_nonce: uint256\n\nadmin: public(address)\nsuggested_admin: public(address)\nis_accepting_new_orders: public(bool)\n\n\n@external\ndef __init__():\n    self.admin = msg.sender\n    self.protocol_fee_receiver = msg.sender\n\n\nevent PositionOpened:\n    account: indexed(address)\n    position: Position\n\n@nonreentrant(\"lock\")\n@external\ndef open_position(\n    _account: address,\n    _position_token: address,\n    _min_position_amount_out: uint256,\n    _debt_token: address,\n    _debt_amount: uint256,\n    _margin_amount: uint256,\n) -> (bytes32, uint256):\n    \"\"\"\n    @notice\n        Creates a new undercollateralized loan for _account\n        and uses it to assume a leveraged spot position in\n        _position_token.\n    \"\"\"\n    assert self.is_accepting_new_orders, \"paused\"\n    assert self.is_whitelisted_dex[msg.sender], \"unauthorized\"\n    assert self.is_enabled_market[_debt_token][_position_token], \"market not enabled\"\n    assert self.margin[_account][_debt_token] >= _margin_amount, \"not enough margin\"\n    assert ((_debt_amount + _margin_amount) * PRECISION / _margin_amount) <= self.max_leverage[_debt_token][_position_token] * PRECISION, \"too much leverage\"\n    assert (self._available_liquidity(_debt_token) >= _debt_amount), \"insufficient liquidity\"\n\n    self.margin[_account][_debt_token] -= _margin_amount\n    debt_shares: uint256 = self._borrow(_debt_token, _debt_amount)\n\n    token_in_amount: uint256 = _debt_amount + _margin_amount\n    amount_bought: uint256 = self._swap(\n        _debt_token, _position_token, token_in_amount, _min_position_amount_out\n    )\n\n    position_uid: bytes32 = self._generate_uid()\n    position: Position = Position(\n        {\n            uid: position_uid,\n            account: _account,\n            debt_token: _debt_token,\n            margin_amount: _margin_amount,\n            debt_shares: debt_shares,\n            position_token: _position_token,\n            position_amount: amount_bought,\n        }\n    )\n\n    self.positions[position_uid] = position\n\n    # charge fee\n    fee: uint256 = token_in_amount * self.trade_open_fee / PERCENTAGE_BASE\n    assert self.margin[_account][_debt_token] >= fee, \"not enough margin for fee\"\n    self.margin[_account][_debt_token] -= fee\n    self._distribute_trading_fee(_debt_token, fee)\n\n    log PositionOpened(_account, position)\n\n    return position_uid, amount_bought\n\n\nevent PositionClosed:\n    account: indexed(address)\n    uid: bytes32\n    position: Position\n    amount_received: uint256\n\n\nevent BadDebt:\n    token: indexed(address)\n    amount: uint256\n    position_uid: bytes32\n\n\n@nonreentrant(\"lock\")\n@external\ndef close_position(_position_uid: bytes32, _min_amount_out: uint256) -> uint256:\n    assert self.is_whitelisted_dex[msg.sender], \"unauthorized\"\n    return self._close_position(_position_uid, _min_amount_out)\n\n\n@internal\ndef _close_position(_position_uid: bytes32, _min_amount_out: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Closes an existing position, repays the debt plus\n        accrued interest and credits/debits the users margin\n        with the remaining PnL.\n    \"\"\"\n    # fetch the position from the positions-dict by uid\n    position: Position = self.positions[_position_uid]\n\n    # assign to local variable to make it editable\n    min_amount_out: uint256 = _min_amount_out\n    if min_amount_out == 0:\n        # market order, add some slippage protection\n        min_amount_out = self._market_order_min_amount_out(\n            position.position_token, position.debt_token, position.position_amount\n        )\n\n    position_debt_amount: uint256 = self._debt(_position_uid)\n    amount_out_received: uint256 = self._swap(\n        position.position_token,\n        position.debt_token,\n        position.position_amount,\n        min_amount_out,\n    )\n\n    if amount_out_received >= position_debt_amount:\n        # all good, LPs are paid back, remainder goes back to trader\n        trader_pnl: uint256 = amount_out_received - position_debt_amount\n        self.margin[position.account][position.debt_token] += trader_pnl\n        self._repay(position.debt_token, position_debt_amount)\n    else:\n        # edge case: bad debt\n        self.is_accepting_new_orders = False  # put protocol in defensive mode\n        bad_debt: uint256 = position_debt_amount - amount_out_received\n        self.bad_debt[position.debt_token] += bad_debt\n        self._repay(\n            position.debt_token, amount_out_received\n        )  # repay LPs as much as possible\n        log BadDebt(position.debt_token, bad_debt, position.uid)\n\n    # cleanup position\n    self.positions[_position_uid] = empty(Position)\n\n    log PositionClosed(position.account, position.uid, position, amount_out_received)\n\n    return amount_out_received\n\n\nevent PositionReduced:\n    account: indexed(address)\n    uid: bytes32\n    position: Position\n    amount_received: uint256\n\n@nonreentrant(\"lock\")\n@external\ndef reduce_position(\n    _position_uid: bytes32, _reduce_by_amount: uint256, _min_amount_out: uint256\n) -> uint256:\n    \"\"\"\n    @notice\n        Partially closes an existing position, by selling some of the \n        underlying position_token.\n        Reduces both debt and margin in the position, leverage \n        remains as is.\n    \"\"\"\n    assert self.is_whitelisted_dex[msg.sender], \"unauthorized\"\n    assert not self._is_liquidatable(_position_uid), \"in liquidation\"\n\n    position: Position = self.positions[_position_uid]\n    assert position.position_amount >= _reduce_by_amount, \"_reduce_by_amount > position\"\n\n    min_amount_out: uint256 = _min_amount_out\n    if min_amount_out == 0:\n        # market order, add some slippage protection\n        min_amount_out = self._market_order_min_amount_out(\n            position.position_token, position.debt_token, position.position_amount\n        )\n\n    debt_amount: uint256 = self._debt(_position_uid)\n    margin_debt_ratio: uint256 = position.margin_amount * PRECISION / debt_amount\n\n    amount_out_received: uint256 = self._swap(\n        position.position_token, position.debt_token, _reduce_by_amount, min_amount_out\n    )\n\n    # reduce margin and debt, keep leverage as before\n    reduce_margin_by_amount: uint256 = (\n        amount_out_received * margin_debt_ratio / PRECISION\n    )\n    reduce_debt_by_amount: uint256 = amount_out_received - reduce_margin_by_amount\n\n    position.margin_amount -= reduce_margin_by_amount\n\n    burnt_debt_shares: uint256 = self._repay(position.debt_token, reduce_debt_by_amount)\n    position.debt_shares -= burnt_debt_shares\n    position.position_amount -= _reduce_by_amount\n\n    self.positions[_position_uid] = position\n\n    log PositionReduced(position.account, _position_uid, position, amount_out_received)\n\n    return amount_out_received\n\n\nevent PositionLiquidated:\n    account: indexed(address)\n    uid: bytes32\n    positon: Position\n\n@nonreentrant(\"lock\")\n@external\ndef liquidate(_position_uid: bytes32):\n    \"\"\"\n    @notice\n        Liquidates a position that exceeds the maximum allowed\n        leverage for that market.\n        Charges the account a liquidation penalty.\n    \"\"\"\n    assert self.is_whitelisted_dex[msg.sender], \"unauthorized\"\n    assert self._is_liquidatable(_position_uid), \"position not liquidateable\"\n\n    position: Position = self.positions[_position_uid]\n    debt_amount: uint256 = self._debt(_position_uid)\n\n    min_amount_out: uint256 = self._market_order_min_amount_out(\n        position.position_token, position.debt_token, position.position_amount\n    )\n\n    amount_out_received: uint256 = self._close_position(_position_uid, min_amount_out)\n\n    # penalize account\n    penalty: uint256 = debt_amount * self.liquidation_penalty / PERCENTAGE_BASE\n\n    if amount_out_received > debt_amount:\n        # margin left\n        remaining_margin: uint256 = amount_out_received - debt_amount\n        penalty = min(penalty, remaining_margin)\n        self.margin[position.account][position.debt_token] -= penalty\n        self._distribute_trading_fee(position.debt_token, penalty)\n\n    log PositionLiquidated(position.account, _position_uid, position)\n\n#####################################\n#\n#         SWAP INTEGRATION\n#\n#####################################\n\n@internal\ndef _swap(\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    \"\"\"\n    @notice\n        Triggers a swap in the referenced swap_router.\n        Ensures min_amount_out is respected.\n    \"\"\"\n    ERC20(_token_in).approve(self.swap_router, _amount_in)\n    token_out_balance_before: uint256 = ERC20(_token_out).balanceOf(self)\n\n    amount_out_received: uint256 = SwapRouter(self.swap_router).swap(\n        _token_in, _token_out, _amount_in, _min_amount_out\n    )\n\n    token_out_balance_after: uint256 = ERC20(_token_out).balanceOf(self)\n    assert (\n        token_out_balance_after >= token_out_balance_before + _min_amount_out\n    ), \"min_amount_out\"\n\n    return amount_out_received\n\n\n@internal\ndef _market_order_min_amount_out(\n    _token_in: address, _token_out: address, _amount_in: uint256\n) -> uint256:\n    \"\"\"\n    @notice\n        For market orders like during liquidation or for a StopLoss,\n        we want a fairly wide slippage to ensure the swap is executed\n        as quickly as possible, while at the same time protect against\n        sandwhich attacks and frontrunning.\n        Here we calculate a reasonable min_amount_out based on the \n        liquidate_slippage configured for the specific market.\n    \"\"\"\n    return (\n        self._quote_token_to_token(_token_in, _token_out, _amount_in)\n        * (PERCENTAGE_BASE - self.liquidate_slippage[_token_in][_token_out])\n        / PERCENTAGE_BASE\n    )\n\n\n#####################################\n#\n#        LEVERAGE & HEALTH\n#\n#####################################\n\n@view\n@external\ndef effective_leverage(_position_uid: bytes32) -> uint256:\n    return self._effective_leverage(_position_uid)\n\n\n@view\n@internal\ndef _effective_leverage(_position_uid: bytes32) -> uint256:\n    \"\"\"\n    @notice\n        Calculated the current leverage of a position based\n        on the position current value, the underlying margin \n        and the accrued debt.\n    \"\"\"\n    position: Position = self.positions[_position_uid]\n    debt_amount: uint256 = self._debt(_position_uid)\n\n    position_value: uint256 = self._in_usd(\n        position.position_token, position.position_amount\n    )\n    debt_value: uint256 = self._in_usd(position.debt_token, debt_amount)\n    margin_value: uint256 = self._in_usd(position.debt_token, position.margin_amount)\n\n    return self._calculate_leverage(position_value, debt_value, margin_value)\n\n\n@view\n@internal\ndef _calculate_leverage(\n    _position_value: uint256, _debt_value: uint256, _margin_value: uint256\n) -> uint256:\n    if _position_value <= _debt_value:\n        # bad debt\n        return max_value(uint256)\n\n    return (\n        PRECISION\n        * (_debt_value + _margin_value)\n        / (_position_value - _debt_value)\n        / PRECISION\n    )\n\n\n@view\n@external\ndef is_liquidatable(_position_uid: bytes32) -> bool:\n    return self._is_liquidatable(_position_uid)\n\n@view\n@internal\ndef _is_liquidatable(_position_uid: bytes32) -> bool:\n    \"\"\"\n    @notice\n        Checks if a position exceeds the maximum leverage\n        allowed for that market.\n    \"\"\"\n    position: Position = self.positions[_position_uid]\n    leverage: uint256 = self._effective_leverage(_position_uid)\n    return leverage > self.max_leverage[position.debt_token][position.position_token]\n\n\nevent MarginAdded:\n    uid: bytes32\n    amount: uint256\n   \n@external\ndef add_margin(_position_uid: bytes32, _amount: uint256):\n    \"\"\"\n    @notice\n        Allows to add additional margin to a Position and \n        reduce the leverage.\n    \"\"\"\n    assert self.is_whitelisted_dex[msg.sender], \"unauthorized\"\n\n    position: Position = self.positions[_position_uid]\n\n    assert (self.margin[position.account][position.debt_token] >= _amount), \"not enough margin\"\n\n    self.margin[position.account][position.debt_token] -= _amount\n    position.margin_amount += _amount\n\n    self.positions[_position_uid] = position\n    log MarginAdded(_position_uid, _amount)\n\n\nevent MarginRemoved:\n    uid: bytes32\n    amount: uint256\n\n\n@external\ndef remove_margin(_position_uid: bytes32, _amount: uint256):\n    \"\"\"\n    @notice\n        Allows to remove margin from a Position and \n        increase the leverage.\n    \"\"\"\n    assert self.is_whitelisted_dex[msg.sender], \"unauthorized\"\n\n    position: Position = self.positions[_position_uid]\n\n    assert position.margin_amount >= _amount, \"not enough margin\"\n\n    position.margin_amount -= _amount\n    self.margin[position.account][position.debt_token] += _amount\n\n    assert not self._is_liquidatable(_position_uid), \"exceeds max leverage\"\n    \n    self.positions[_position_uid] = position\n    log MarginRemoved(_position_uid, _amount)\n\n\n#####################################\n#\n#        ORACLE PRICE FEEDS\n#\n#####################################\n\n@view\n@external\ndef to_usd_oracle_price(_token: address) -> uint256:\n    return self._to_usd_oracle_price(_token)\n\n@view\n@internal\ndef _to_usd_oracle_price(_token: address) -> uint256:\n    \"\"\"\n    @notice\n        Retrieves the latest Chainlink oracle price for _token.\n        Ensures that the Arbitrum sequencer is up and running and\n        that the Chainlink feed is fresh.\n    \"\"\"\n    assert self._sequencer_up(), \"sequencer down\"\n\n    round_id: uint80 = 0\n    answer: int256 = 0\n    started_at: uint256 = 0\n    updated_at: uint256 = 0\n    answered_in_round: uint80 = 0\n    round_id, answer, started_at, updated_at, answered_in_round = ChainlinkOracle(\n        self.to_usd_oracle[_token]\n    ).latestRoundData()\n\n    assert (block.timestamp - updated_at) < ORACLE_FRESHNESS_THRESHOLD, \"oracle not fresh\"\n\n    usd_price: uint256 = convert(answer, uint256)  # 8 dec\n    return usd_price\n\n\n@view\n@internal\ndef _sequencer_up() -> bool:\n    # answer == 0: Sequencer is up\n    # answer == 1: Sequencer is down\n    answer: int256 = ChainlinkOracle(ARBITRUM_SEQUENCER_UPTIME_FEED).latestRoundData()[1]\n    return answer == 0\n\n\n@view\n@internal\ndef _in_usd(_token: address, _amount: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Converts _amount of _token to a USD value.\n    \"\"\"\n    return (\n        self._to_usd_oracle_price(_token)\n        * _amount\n        / 10 ** convert(ERC20(_token).decimals(), uint256)\n    )\n\n\n@view\n@external\ndef current_exchange_rate(_position_uid: bytes32) -> uint256:\n    \"\"\"\n    @notice\n        Returns the current exchange rate / price of a \n        Positions underlying tokens.\n    \"\"\"\n    position: Position = self.positions[_position_uid]\n    one_full: uint256 = 1 * 10 ** convert(\n        ERC20(position.position_token).decimals(), uint256\n    )\n    return self._quote_token_to_token(\n        position.position_token, position.debt_token, one_full\n    )\n\n\n@view\n@internal\ndef _quote_token_to_token(\n    _token0: address, _token1: address, _amount0: uint256\n) -> uint256:\n    token0_in_usd: uint256 = self._in_usd(_token0, _amount0)  # 8 decimals\n    token1_decimals: uint256 = convert(ERC20(_token1).decimals(), uint256)\n    token1_usd_price: uint256 = self._to_usd_oracle_price(_token1)\n    # token_in_per_token_out = token_in_in_usdc / token_out_in_usdc with additional precision\n    token1_value: uint256 = (\n        PRECISION    # just for precision\n        * 10**token1_decimals \n        * token0_in_usd\n        / token1_usd_price  # the real thing\n        / PRECISION  # just for precision\n    )\n    return token1_value\n\n\n#####################################\n#\n#       USER ACCOUNTS / MARGIN\n#\n#####################################\n\nevent AccountFunded:\n    account: indexed(address)\n    amount: uint256\n    token: indexed(address)\n\n@nonreentrant(\"lock\")\n@payable\n@external\ndef fund_account_eth():\n    \"\"\"\n    @notice\n        Allows a user to fund his WETH margin by depositing ETH.\n    \"\"\"\n    assert self.is_accepting_new_orders, \"funding paused\"\n    assert self.is_whitelisted_token[WETH], \"token not whitelisted\"\n    self.margin[msg.sender][WETH] += msg.value\n    raw_call(WETH, method_id(\"deposit()\"), value=msg.value)\n    log AccountFunded(msg.sender, msg.value, WETH)\n\n\n@nonreentrant(\"lock\")\n@external\ndef fund_account(_token: address, _amount: uint256):\n    \"\"\"\n    @notice\n        Allows a user to fund his _token margin.\n    \"\"\"\n    assert self.is_accepting_new_orders, \"funding paused\"\n    assert self.is_whitelisted_token[_token], \"token not whitelisted\"\n    self.margin[msg.sender][_token] += _amount\n    self._safe_transfer_from(_token, msg.sender, self, _amount)\n    log AccountFunded(msg.sender, _amount, _token)\n\n\nevent WithdrawBalance:\n    account: indexed(address)\n    token: indexed(address)\n    amount: uint256\n\n\n@nonreentrant(\"lock\")\n@external\ndef withdraw_from_account_eth(_amount: uint256):\n    \"\"\"\n    @notice\n        Allows a user to withdraw from his WETH margin and\n        automatically swaps back to ETH.\n    \"\"\"\n    assert self.margin[msg.sender][WETH] >= _amount, \"insufficient balance\"\n    self.margin[msg.sender][WETH] -= _amount\n    raw_call(\n        WETH,\n        concat(\n            method_id(\"withdrawTo(address,uint256)\"),\n            convert(msg.sender, bytes32),\n            convert(_amount, bytes32),\n        ),\n    )\n    log WithdrawBalance(msg.sender, WETH, _amount)\n\n\n@nonreentrant(\"lock\")\n@external\ndef withdraw_from_account(_token: address, _amount: uint256):\n    \"\"\"\n    @notice\n        Allows a user to withdraw from his _token margin.\n    \"\"\"\n    assert self.margin[msg.sender][_token] >= _amount, \"insufficient balance\"\n\n    self.margin[msg.sender][_token] -= _amount\n    self._safe_transfer(_token, msg.sender, _amount)\n    log WithdrawBalance(msg.sender, _token, _amount)\n\n\n@nonreentrant(\"lock\")\n@external\ndef swap_margin(\n    _account: address,\n    _token_in: address,\n    _token_out: address,\n    _amount_in: uint256,\n    _min_amount_out: uint256,\n) -> uint256:\n    \"\"\"\n    @notice\n        Allows a user to swap his margin balances between differnt tokens.\n    \"\"\"\n    assert self.is_whitelisted_dex[msg.sender] or _account == msg.sender, \"unauthorized\"\n    assert _amount_in <= self.margin[_account][_token_in], \"insufficient balance\"\n\n    self.margin[_account][_token_in] -= _amount_in\n\n    amount_out_received: uint256 = self._swap(\n        _token_in, _token_out, _amount_in, _min_amount_out\n    )\n\n    self.margin[_account][_token_out] += amount_out_received\n\n    return amount_out_received\n\n\n#####################################\n#\n#             LIQUIDITY \n#\n#####################################\n\nevent ProvideLiquidity:\n    account: indexed(address)\n    token: indexed(address)\n    amount: uint256\n\n@nonreentrant(\"lock\")\n@payable\n@external\ndef provide_liquidity_eth(_is_safety_module: bool):\n    \"\"\"\n    @notice\n        Allows LPs to provide WETH liquidity by depositing ETH.\n    \"\"\"\n    assert msg.value > 0, \"zero value\"\n\n    assert self.is_accepting_new_orders, \"LPing paused\"\n    assert self.is_whitelisted_token[WETH], \"token not whitelisted\"\n\n    self._account_for_provide_liquidity(WETH, msg.value, _is_safety_module)\n\n    raw_call(WETH, method_id(\"deposit()\"), value=msg.value)\n\n    log ProvideLiquidity(msg.sender, WETH, msg.value)\n\n\n@nonreentrant(\"lock\")\n@external\ndef provide_liquidity(_token: address, _amount: uint256, _is_safety_module: bool):\n    \"\"\"\n    @notice\n        Allows LPs to provide _token liquidity.\n    \"\"\"\n    assert self.is_accepting_new_orders, \"LPing paused\"\n\n    assert self.is_whitelisted_token[_token], \"token not whitelisted\"\n\n    self._account_for_provide_liquidity(_token, _amount, _is_safety_module)\n\n    self._safe_transfer_from(_token, msg.sender, self, _amount)\n    log ProvideLiquidity(msg.sender, _token, _amount)\n\n\n@internal\ndef _account_for_provide_liquidity(\n    _token: address, _amount: uint256, _is_safety_module: bool\n):\n    self._update_debt(_token)\n    shares: uint256 = self._amount_to_lp_shares(_token, _amount, _is_safety_module)\n    if _is_safety_module:\n        self.safety_module_lp_total_shares[_token] += shares\n        self.safety_module_lp_shares[_token][msg.sender] += shares\n        self.safety_module_lp_total_amount[_token] += _amount\n\n    else:\n        self.base_lp_total_shares[_token] += shares\n        self.base_lp_shares[_token][msg.sender] += shares\n        self.base_lp_total_amount[_token] += _amount\n\n    # record cooldown after which account can withdraw again\n    self.account_withdraw_liquidity_cooldown[msg.sender] = (\n        block.timestamp + self.withdraw_liquidity_cooldown\n    )\n\n\nevent WithdrawLiquidity:\n    account: indexed(address)\n    token: indexed(address)\n    amount: uint256\n\n@nonreentrant(\"lock\")\n@external\ndef withdraw_liquidity_eth(_amount: uint256, _is_safety_module: bool):\n    \"\"\"\n    @notice\n        Allows LPs to withdraw their WETH liquidity in ETH.\n        Only liquidity that is currently not lent out can be withdrawn.\n    \"\"\"\n    assert (self.account_withdraw_liquidity_cooldown[msg.sender] <= block.timestamp), \"cooldown\"\n    assert _amount <= self._available_liquidity(WETH), \"liquidity not available\"\n\n    self._account_for_withdraw_liquidity(WETH, _amount, _is_safety_module)\n\n    raw_call(\n        WETH,\n        concat(\n            method_id(\"withdrawTo(address,uint256)\"),\n            convert(msg.sender, bytes32),\n            convert(_amount, bytes32),\n        ),\n    )\n\n    log WithdrawLiquidity(msg.sender, WETH, _amount)\n\n\n@nonreentrant(\"lock\")\n@external\ndef withdraw_liquidity(_token: address, _amount: uint256, _is_safety_module: bool):\n    \"\"\"\n    @notice\n        Allows LPs to withdraw their _token liquidity.\n        Only liquidity that is currently not lent out can be withdrawn.\n    \"\"\"\n    assert (self.account_withdraw_liquidity_cooldown[msg.sender] <= block.timestamp), \"cooldown\"\n\n    assert _amount <= self._available_liquidity(_token), \"liquidity not available\"\n\n    self._account_for_withdraw_liquidity(_token, _amount, _is_safety_module)\n\n    self._safe_transfer(_token, msg.sender, _amount)\n    log WithdrawLiquidity(msg.sender, _token, _amount)\n\n\n@internal\ndef _account_for_withdraw_liquidity(\n    _token: address, _amount: uint256, _is_safety_module: bool\n):\n    self._update_debt(_token)\n    if _is_safety_module:\n        shares: uint256 = self._amount_to_lp_shares(_token, _amount, True)\n        assert (shares <= self.safety_module_lp_shares[_token][msg.sender]), \"cannot withdraw more than you own\"\n        self.safety_module_lp_total_amount[_token] -= _amount\n        self.safety_module_lp_total_shares[_token] -= shares\n        self.safety_module_lp_shares[_token][msg.sender] -= shares\n\n    else:\n        shares: uint256 = self._amount_to_lp_shares(_token, _amount, False)\n        assert (shares <= self.base_lp_shares[_token][msg.sender]), \"cannot withdraw more than you own\"\n        self.base_lp_total_amount[_token] -= _amount\n        self.base_lp_total_shares[_token] -= shares\n        self.base_lp_shares[_token][msg.sender] -= shares\n\n\n@internal\n@view\ndef _amount_to_lp_shares(\n    _token: address, _amount: uint256, _is_safety_module: bool\n) -> uint256:\n    if _is_safety_module:\n        # initial shares == wei\n        if self.safety_module_lp_total_shares[_token] == 0:\n            return _amount * PRECISION\n\n        wei_per_share: uint256 = self._amount_per_safety_module_lp_share(_token)\n        new_shares: uint256 = _amount * PRECISION * PRECISION / wei_per_share\n        return new_shares\n\n    else:  # base_lp\n        # initial shares == wei\n        if self.base_lp_total_shares[_token] == 0:\n            return _amount * PRECISION\n\n        wei_per_share: uint256 = self._amount_per_base_lp_share(_token)\n        new_shares: uint256 = _amount * PRECISION * PRECISION / wei_per_share\n        return new_shares\n\n\n@external\n@view\ndef lp_shares_to_amount(\n    _token: address, _shares: uint256, _is_safety_module: bool\n) -> uint256:\n    return self._lp_shares_to_amount(_token, _shares, _is_safety_module)\n\n\n@internal\n@view\ndef _lp_shares_to_amount(\n    _token: address, _shares: uint256, _is_safety_module: bool\n) -> uint256:\n    if _shares == 0:\n        return 0\n\n    if _is_safety_module:\n        return (\n            _shares\n            * self._amount_per_safety_module_lp_share(_token)\n            / PRECISION\n            / PRECISION\n        )\n\n    return _shares * self._amount_per_base_lp_share(_token) / PRECISION / PRECISION\n\n\n@internal\n@view\ndef _amount_per_base_lp_share(_token: address) -> uint256:\n    return (\n        self.base_lp_total_amount[_token]\n        * PRECISION\n        * PRECISION\n        / self.base_lp_total_shares[_token]\n    )\n\n\n@internal\n@view\ndef _amount_per_safety_module_lp_share(_token: address) -> uint256:\n    return (\n        self._safety_module_total_amount(_token)\n        * PRECISION\n        * PRECISION\n        / self.safety_module_lp_total_shares[_token]\n    )\n\n\n@internal\n@view\ndef _safety_module_total_amount(_token: address) -> uint256:\n    if self.bad_debt[_token] > self.safety_module_lp_total_amount[_token]:\n        return 0\n    return self.safety_module_lp_total_amount[_token] - self.bad_debt[_token]\n\n\n@internal\n@view\ndef _total_liquidity(_token: address) -> uint256:\n    return (\n        self.base_lp_total_amount[_token]\n        + self.safety_module_lp_total_amount[_token]\n        - self.bad_debt[_token]\n    )\n\n@external\n@view\ndef available_liquidity(_token: address) -> uint256:\n    return self._available_liquidity(_token)\n\n\n@internal\n@view\ndef _available_liquidity(_token: address) -> uint256:\n    return self._total_liquidity(_token) - self.total_debt_amount[_token]\n\n\nevent BaseLpInterestReceived:\n    token: address\n    amount: uint256\n\n\nevent SafetyModuleInterestReceived:\n    token: address\n    amount: uint256\n\n\n@internal\ndef _pay_interest_to_lps(_token: address, _amount: uint256):\n    safety_module_amount: uint256 = (\n        _amount * self.safety_module_interest_share_percentage / PERCENTAGE_BASE\n    )\n    base_amount: uint256 = _amount - safety_module_amount\n\n    self.safety_module_lp_total_amount[_token] += safety_module_amount\n    self.base_lp_total_amount[_token] += base_amount\n    log BaseLpInterestReceived(_token, base_amount)\n    log SafetyModuleInterestReceived(_token, safety_module_amount)\n\n\n#####################################\n#\n#               DEBT\n#\n#####################################\n\n\n@internal\ndef _borrow(_debt_token: address, _amount: uint256) -> uint256:\n    self._update_debt(_debt_token)\n\n    assert _amount <= self._available_liquidity(_debt_token), \"not enough liquidity\"\n\n    debt_shares: uint256 = self._amount_to_debt_shares(_debt_token, _amount)\n\n    self.total_debt_amount[_debt_token] += _amount\n    self.total_debt_shares[_debt_token] += debt_shares\n\n    return debt_shares\n\n\n@internal\ndef _repay(_debt_token: address, _amount: uint256) -> uint256:\n    self._update_debt(_debt_token)\n\n    debt_shares: uint256 = self._amount_to_debt_shares(_debt_token, _amount)\n\n    self.total_debt_amount[_debt_token] -= _amount\n    self.total_debt_shares[_debt_token] -= debt_shares\n\n    return debt_shares\n\n\n@internal\ndef _update_debt(_debt_token: address):\n    \"\"\"\n    @notice\n        Accounts for any accrued interest since the last update.\n    \"\"\"\n    if block.timestamp == self.last_debt_update[_debt_token]:\n        return  # already up to date, nothing to do\n\n    self.last_debt_update[_debt_token] = block.timestamp\n    \n    if self.total_debt_amount[_debt_token] == 0:\n        return # no debt, no interest\n\n    self.total_debt_amount[_debt_token] += self._debt_interest_since_last_update(\n        _debt_token\n    )\n\n@internal\n@view\ndef _debt_interest_since_last_update(_debt_token: address) -> uint256:\n    return (\n        (block.timestamp - self.last_debt_update[_debt_token])\n        * self._current_interest_per_second(_debt_token)\n        * self.total_debt_amount[_debt_token]\n        / PERCENTAGE_BASE\n        / PRECISION\n    )\n\n@internal\n@view\ndef _amount_to_debt_shares(_debt_token: address, _amount: uint256) -> uint256:\n    # initial shares == wei * PRECISION\n    if self.total_debt_shares[_debt_token] == 0:\n        return _amount * PRECISION\n\n    new_shares: uint256 = (\n        _amount * PRECISION * PRECISION / self._amount_per_debt_share(_debt_token)\n    )\n    return new_shares\n\n\n@external\n@view\ndef debt_shares_to_amount(_debt_token: address, _shares: uint256) -> uint256:\n    return self._debt_shares_to_amount(_debt_token, _shares)\n\n\n@internal\n@view\ndef _debt_shares_to_amount(\n    _debt_token: address,\n    _shares: uint256,\n) -> uint256:\n    if _shares"
    }
  ]
}