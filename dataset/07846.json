{
  "Title": "[M-16] `ApprovalAll` event is missing parameters",
  "Content": "\n[HolographERC721.sol#L392](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/HolographERC721.sol#L392)<br>\n\n`beforeApprovalAll()` / `afterApprovalAll()` can only pass \"to\" and \"approved\", missing \"owner\", if contract listening to this event,but does not know who approve it, so can not react to this event.<br>\nBasically, this event cannot be used.\n\n### Proof of Concept\n\n      function setApprovalForAll(address to, bool approved) external {\n    ....\n\n        if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n          require(SourceERC721().beforeApprovalAll(to, approved)); /***** only to/approved ,need owner\n        }  \n\n        _operatorApprovals[msg.sender][to] = approved;\n\n        if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n          require(SourceERC721().afterApprovalAll(to, approved)); /***** only to/approved ,need owner\n        }\n      }\n\n### Recommended Mitigation Steps\n\nAdd parameter: owner\n\n    interface HolographedERC721 {\n    ...\n\n    - function beforeApprovalAll(address _to, bool _approved) external returns (bool success);\n    + function beforeApprovalAll(address owner, address _to, bool _approved) external returns (bool success);\n\n    - function afterApprovalAll(address _to, bool _approved) external returns (bool success);\n    + function afterApprovalAll(address owner, address _to, bool _approved) external returns (bool success);\n\n<!---->\n\n      function setApprovalForAll(address to, bool approved) external {\n\n        if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n    -     require(SourceERC721().beforeApprovalAll(to, approved)); \n    +     require(SourceERC721().beforeApprovalAll(msg.sender,to, approved)); \n        }  \n\n        _operatorApprovals[msg.sender][to] = approved;\n\n        if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n    -      require(SourceERC721().afterApprovalAll(to, approved));\n    +      require(SourceERC721().afterApprovalAll(msg.sender,to, approved));\n        }\n      }\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/270#issuecomment-1306696158):**\n > Good catch. This will be updated so that `beforeApprovalAll` and `afterApprovalAll` passes in owner.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/270#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-holograph-contest",
  "Code": [
    {
      "filename": "src/enforcer/HolographERC721.sol",
      "content": "/*HOLOGRAPH_LICENSE_HEADER*/\n\n/*SOLIDITY_COMPILER_VERSION*/\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../enum/HolographERC721Event.sol\";\nimport \"../enum/InterfaceType.sol\";\n\nimport \"../interface/ERC165.sol\";\nimport \"../interface/ERC721.sol\";\nimport \"../interface/HolographERC721Interface.sol\";\nimport \"../interface/ERC721Metadata.sol\";\nimport \"../interface/ERC721TokenReceiver.sol\";\nimport \"../interface/Holographable.sol\";\nimport \"../interface/HolographedERC721.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/PA1DInterface.sol\";\nimport \"../interface/Ownable.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-721 Collection\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC721 is Admin, Owner, HolographERC721Interface, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = precomputeslot(\"eip1967.Holograph.holograph\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = precomputeslot(\"eip1967.Holograph.sourceContract\");\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Collection name.\n   */\n  string private _name;\n\n  /**\n   * @dev Collection symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Collection royalty base points.\n   */\n  uint16 private _bps;\n\n  /**\n   * @dev Array of all token ids in collection.\n   */\n  uint256[] private _allTokens;\n\n  /**\n   * @dev Map of token id to array index of _ownedTokens.\n   */\n  mapping(uint256 => uint256) private _ownedTokensIndex;\n\n  /**\n   * @dev Token id to wallet (owner) address map.\n   */\n  mapping(uint256 => address) private _tokenOwner;\n\n  /**\n   * @dev 1-to-1 map of token id that was assigned an approved operator address.\n   */\n  mapping(uint256 => address) private _tokenApprovals;\n\n  /**\n   * @dev Map of total tokens owner by a specific address.\n   */\n  mapping(address => uint256) private _ownedTokensCount;\n\n  /**\n   * @dev Map of array of token ids owned by a specific address.\n   */\n  mapping(address => uint256[]) private _ownedTokens;\n\n  /**\n   * @notice Map of full operator approval for a particular address.\n   * @dev Usually utilised for supporting marketplace proxy wallets.\n   */\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  /**\n   * @dev Mapping from token id to position in the allTokens array.\n   */\n  mapping(uint256 => uint256) private _allTokensIndex;\n\n  /**\n   * @dev Mapping of all token ids that have been burned. This is to prevent re-minting of same token ids.\n   */\n  mapping(uint256 => bool) private _burnedTokens;\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC721: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC721: source only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    InitializableInterface sourceContract;\n    assembly {\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint16 contractBps,\n      uint256 eventConfig,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(initPayload, (string, string, uint16, uint256, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _bps = contractBps;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC721: could not init source\");\n      (bool success, bytes memory returnData) = _royalties().delegatecall(\n        abi.encodeWithSignature(\"initPA1D(bytes)\", abi.encode(address(this), uint256(contractBps)))\n      );\n      bytes4 selector = abi.decode(returnData, (bytes4));\n      require(success && selector == InitializableInterface.init.selector, \"ERC721: coud not init PA1D\");\n    }\n\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Gets a base64 encoded contract JSON file.\n   * @return string The URI.\n   */\n  function contractURI() external view returns (string memory) {\n    return HolographInterfacesInterface(_interfaces()).contractURI(_name, \"\", \"\", _bps, address(this));\n  }\n\n  /**\n   * @notice Gets the name of the collection.\n   * @return string The collection name.\n   */\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @notice Shows the interfaces the contracts support\n   * @dev Must add new 4 byte interface Ids here to acknowledge support\n   * @param interfaceId ERC165 style 4 byte interfaceId.\n   * @return bool True if supported.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    HolographInterfacesInterface interfaces = HolographInterfacesInterface(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.ERC721, interfaceId) || // check global interfaces\n      interfaces.supportsInterface(InterfaceType.PA1D, interfaceId) || // check if royalties supports interface\n      erc165Contract.supportsInterface(interfaceId) // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Gets the collection's symbol.\n   * @return string The symbol.\n   */\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @notice Get's the URI of the token.\n   * @dev Defaults the the Arweave URI\n   * @return string The URI.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    require(_exists(tokenId), \"ERC721: token does not exist\");\n    ERC721Metadata sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    return sourceContract.tokenURI(tokenId);\n  }\n\n  /**\n   * @notice Get list of tokens owned by wallet.\n   * @param wallet The wallet address to get tokens for.\n   * @return uint256[] Returns an array of token ids owned by wallet.\n   */\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\n    return _ownedTokens[wallet];\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for tokens owned by wallet.\n   * @param wallet The wallet address to get tokens for.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return tokenIds uint256[] Returns a set length array of token ids owned by wallet.\n   */\n  function tokensOfOwner(\n    address wallet,\n    uint256 index,\n    uint256 length\n  ) external view returns (uint256[] memory tokenIds) {\n    uint256 supply = _ownedTokensCount[wallet];\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    tokenIds = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      tokenIds[i] = _ownedTokens[wallet][index + i];\n    }\n  }\n\n  /**\n   * @notice Adds a new address to the token's approval list.\n   * @dev Requires the sender to be in the approved addresses.\n   * @param to The address to approve.\n   * @param tokenId The affected token.\n   */\n  function approve(address to, uint256 tokenId) external payable {\n    address tokenOwner = _tokenOwner[tokenId];\n    require(to != tokenOwner, \"ERC721: cannot approve self\");\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeApprove)) {\n      require(SourceERC721().beforeApprove(tokenOwner, to, tokenId));\n    }\n    _tokenApprovals[tokenId] = to;\n    emit Approval(tokenOwner, to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterApprove)) {\n      require(SourceERC721().afterApprove(tokenOwner, to, tokenId));\n    }\n  }\n\n  /**\n   * @notice Burns the token.\n   * @dev The sender must be the owner or approved.\n   * @param tokenId The token to burn.\n   */\n  function burn(uint256 tokenId) external {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    address wallet = _tokenOwner[tokenId];\n    if (_isEventRegistered(HolographERC721Event.beforeBurn)) {\n      require(SourceERC721().beforeBurn(wallet, tokenId));\n    }\n    _burn(wallet, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterBurn)) {\n      require(SourceERC721().afterBurn(wallet, tokenId));\n    }\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    (address from, address to, uint256 tokenId, bytes memory data) = abi.decode(\n      payload,\n      (address, address, uint256, bytes)\n    );\n    require(!_exists(tokenId), \"ERC721: token already exists\");\n    delete _burnedTokens[tokenId];\n    _mint(to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.bridgeIn)) {\n      require(SourceERC721().bridgeIn(fromChain, from, to, tokenId, data), \"HOLOGRAPH: bridge in failed\");\n    }\n    return Holographable.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    (address from, address to, uint256 tokenId) = abi.decode(payload, (address, address, uint256));\n    require(to != address(0), \"ERC721: zero address\");\n    require(_isApproved(sender, tokenId), \"ERC721: sender not approved\");\n    require(from == _tokenOwner[tokenId], \"ERC721: from is not owner\");\n    if (_isEventRegistered(HolographERC721Event.bridgeOut)) {\n      data = SourceERC721().bridgeOut(toChain, from, to, tokenId);\n    }\n    _burn(from, tokenId);\n    return (Holographable.bridgeOut.selector, abi.encode(from, to, tokenId, data));\n  }\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   * @param from cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must exist and be owned by `from`.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external payable {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   * @param from cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must exist and be owned by `from`.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) public payable {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {\n      require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));\n    }\n    _transferFrom(from, to, tokenId);\n    if (_isContract(to)) {\n      require(\n        (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&\n          ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&\n          ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==\n          ERC721TokenReceiver.onERC721Received.selector),\n        \"ERC721: onERC721Received fail\"\n      );\n    }\n    if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {\n      require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));\n    }\n  }\n\n  /**\n   * @notice Adds a new approved operator.\n   * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\n   * @param to The address to approve.\n   * @param approved Turn on or off approval status.\n   */\n  function setApprovalForAll(address to, bool approved) external {\n    require(to != msg.sender, \"ERC721: cannot approve self\");\n    if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n      require(SourceERC721().beforeApprovalAll(to, approved));\n    }\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n    if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n      require(SourceERC721().afterApprovalAll(to, approved));\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to burn a token.\n   *  Note: this is put in place to make sure that custom logic could be implemented for merging, gamification, etc.\n   *  Note: token cannot be burned if it's locked by bridge.\n   */\n  function sourceBurn(uint256 tokenId) external onlySource {\n    address wallet = _tokenOwner[tokenId];\n    _burn(wallet, tokenId);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a token.\n   */\n  function sourceMint(address to, uint224 tokenId) external onlySource {\n    // uint32 is reserved for chain id to be used\n    // we need to get current chain id, and prepend it to tokenId\n    // this will prevent possible tokenId overlap if minting simultaneously on multiple chains is possible\n    uint256 token = uint256(bytes32(abi.encodePacked(_chain(), tokenId)));\n    require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n    _mint(to, token);\n  }\n\n  /**\n   * @dev Allows source to get the prepend for their tokenIds.\n   */\n  function sourceGetChainPrepend() external view onlySource returns (uint256) {\n    return uint256(bytes32(abi.encodePacked(_chain(), uint224(0))));\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatch(address to, uint224[] calldata tokenIds) external onlySource {\n  //     require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < tokenIds.length; i++) {\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(to, token);\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatch(address[] calldata wallets, uint224[] calldata tokenIds) external onlySource {\n  //     require(wallets.length == tokenIds.length, \"ERC721: array length missmatch\");\n  //     require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < tokenIds.length; i++) {\n  //       token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(wallets[i], token);\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatchIncremental(\n  //     address to,\n  //     uint224 startingTokenId,\n  //     uint256 length\n  //   ) external onlySource {\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < length; i++) {\n  //       token = uint256(bytes32(abi.encodePacked(chain, startingTokenId)));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(to, token);\n  //       startingTokenId++;\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to transfer a token.\n   *  Note: this is put in place to make sure that custom logic could be implemented for merging, gamification, etc.\n   *  Note: token cannot be transfered if it's locked by bridge.\n   */\n  function sourceTransfer(address to, uint256 tokenId) external onlySource {\n    address wallet = _tokenOwner[tokenId];\n    _transferFrom(wallet, to, tokenId);\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `msg.sender` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   */\n  function transfer(address to, uint256 tokenId) external payable {\n    transferFrom(msg.sender, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `from` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @param from  cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public payable {\n    transferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `from` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * @param from  cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   * @param data additional data to pass.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) public payable {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeTransfer)) {\n      require(SourceERC721().beforeTransfer(from, to, tokenId, data));\n    }\n    _transferFrom(from, to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterTransfer)) {\n      require(SourceERC721().afterTransfer(from, to, tokenId, data));\n    }\n  }\n\n  /**\n   * @notice Get total number of tokens owned by wallet.\n   * @dev Used to see total amount of tokens owned by a specific wallet.\n   * @param wallet Address for which to get token balance.\n   * @return uint256 Returns an integer, representing total amount of tokens held by address.\n   */\n  function balanceOf(address wallet) public view returns (uint256) {\n    require(wallet != address(0), \"ERC721: zero address\");\n    return _ownedTokensCount[wallet];\n  }\n\n  function burned(uint256 tokenId) public view returns (bool) {\n    return _burnedTokens[tokenId];\n  }\n\n  /**\n   * @notice Decimal places to have for totalSupply.\n   * @dev Since ERC721s are single, we use 0 as the decimal places to make sure a round number for totalSupply.\n   * @return uint256 Returns the number of decimal places to have for totalSupply.\n   */\n  function decimals() external pure returns (uint256) {\n    return 0;\n  }\n\n  function exists(uint256 tokenId) public view returns (bool) {\n    return _tokenOwner[tokenId] != address(0);\n  }\n\n  /**\n   * @notice Gets the approved address for the token.\n   * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\n   * @param tokenId Token id to get approved operator for.\n   * @return address Approved address for token.\n   */\n  function getApproved(uint256 tokenId) external view returns (address) {\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @notice Checks if the address is approved.\n   * @dev Includes references to OpenSea and Rarible marketplace proxies.\n   * @param wallet Address of the wallet.\n   * @param operator Address of the marketplace operator.\n   * @return bool True if approved.\n   */\n  function isApprovedForAll(address wallet, address operator) external view returns (bool) {\n    return _operatorApprovals[wallet][operator];\n  }\n\n  /**\n   * @notice Checks who the owner of a token is.\n   * @dev The token must exist.\n   * @param tokenId The token to look up.\n   * @return address Owner of the token.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address) {\n    address tokenOwner = _tokenOwner[tokenId];\n    require(tokenOwner != address(0), \"ERC721: token does not exist\");\n    return tokenOwner;\n  }\n\n  /**\n   * @notice Get token by index.\n   * @dev Used in conjunction with totalSupply function to iterate over all tokens in collection.\n   * @param index Index of token in array.\n   * @return uint256 Returns the token id of token located at that index.\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256) {\n    require(index < _allTokens.length, \"ERC721: index out of bounds\");\n    return _allTokens[index];\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for all tokens.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return tokenIds uint256[] Returns a set length array of token ids minted.\n   */\n  function tokens(uint256 index, uint256 length) external view returns (uint256[] memory tokenIds) {\n    uint256 supply = _allTokens.length;\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    tokenIds = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      tokenIds[i] = _allTokens[index + i];\n    }\n  }\n\n  /**\n   * @notice Get token from wallet by index instead of token id.\n   * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\n   * @param wallet Specific address for which to get token for.\n   * @param index Index of token in array.\n   * @return uint256 Returns the token id of token located at that index in specified wallet.\n   */\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256) {\n    require(index < balanceOf(wallet), \"ERC721: index out of bounds\");\n    return _ownedTokens[wallet][index];\n  }\n\n  /**\n   * @notice Total amount of tokens in the collection.\n   * @dev Ignores burned tokens.\n   * @return uint256 Returns the total number of active (not burned) tokens.\n   */\n  function totalSupply() external view returns (uint256) {\n    return _allTokens.length;\n  }\n\n  /**\n   * @notice Empty function that is triggered by external contract on NFT transfer.\n   * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\n   * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * @return bytes4 Returns the interfaceId of onERC721Received.\n   */\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4) {\n    require(_isContract(_operator), \"ERC721: operator not contract\");\n    if (_isEventRegistered(HolographERC721Event.beforeOnERC721Received)) {\n      require(SourceERC721().beforeOnERC721Received(_operator, _from, address(this), _tokenId, _data));\n    }\n    try HolographERC721Interface(_operator).ownerOf(_tokenId) returns (address tokenOwner) {\n      require(tokenOwner == address(this), \"ERC721: contract not token owner\");\n    } catch {\n      revert(\"ERC721: token does not exist\");\n    }\n    if (_isEventRegistered(HolographERC721Event.afterOnERC721Received)) {\n      require(SourceERC721().afterOnERC721Received(_operator, _from, address(this), _tokenId, _data));\n    }\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Add a newly minted token into managed list of tokens.\n   * @param to Address of token owner for which to add the token.\n   * @param tokenId Id of token to add.\n   */\n  function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n    _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\n    _ownedTokensCount[to]++;\n    _ownedTokens[to].push(tokenId);\n    _allTokensIndex[tokenId] = _allTokens.length;\n    _allTokens.push(tokenId);\n  }\n\n  /**\n   * @notice Burns the token.\n   * @dev All validation needs to be done before calling this function.\n   * @param wallet Address of current token owner.\n   * @param tokenId The token to burn.\n   */\n  function _burn(address wallet, uint256 tokenId) private {\n    _clearApproval(tokenId);\n    _tokenOwner[tokenId] = address(0);\n    emit Transfer(wallet, address(0), tokenId);\n    _removeTokenFromOwnerEnumeration(wallet, tokenId);\n    _burnedTokens[tokenId] = true;\n  }\n\n  /**\n   * @notice Deletes a token from the approval list.\n   * @dev Removes from count.\n   * @param tokenId T.\n   */\n  function _clearApproval(uint256 tokenId) private {\n    delete _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @notice Mints an NFT.\n   * @dev Can to mint the token to the zero address and the token cannot already exist.\n   * @param to Address to mint to.\n   * @param tokenId The new token.\n   */\n  function _mint(address to, uint256 tokenId) private {\n    require(tokenId > 0, \"ERC721: token id cannot be zero\");\n    require(to != address(0), \"ERC721: minting to burn address\");\n    require(!_exists(tokenId), \"ERC721: token already exists\");\n    require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");\n    _tokenOwner[tokenId] = to;\n    emit Transfer(address(0), to, tokenId);\n    _addTokenToOwnerEnumeration(to, tokenId);\n  }\n\n  function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n    uint256 lastTokenIndex = _allTokens.length - 1;\n    uint256 tokenIndex = _allTokensIndex[tokenId];\n    uint256 lastTokenId = _allTokens[lastTokenIndex];\n    _allTokens[tokenIndex] = lastTokenId;\n    _allTokensIndex[lastTokenId] = tokenIndex;\n    delete _allTokensIndex[tokenId];\n    delete _allTokens[lastTokenIndex];\n    _allTokens.pop();\n  }\n\n  /**\n   * @dev Remove a token from managed list of tokens.\n   * @param from Address of token owner for which to remove the token.\n   * @param tokenId Id of token to remove.\n   */\n  function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n    _removeTokenFromAllTokensEnumeration(tokenId);\n    _ownedTokensCount[from]--;\n    uint256 lastTokenIndex = _ownedTokensCount[from];\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\n    if (tokenIndex != lastTokenIndex) {\n      uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n      _ownedTokens[from][tokenIndex] = lastTokenId;\n      _ownedTokensIndex[lastTokenId] = tokenIndex;\n    }\n    if (lastTokenIndex == 0) {\n      delete _ownedTokens[from];\n    } else {\n      delete _ownedTokens[from][lastTokenIndex];\n      _ownedTokens[from].pop();\n    }\n  }\n\n  /**\n   * @dev Primary private function that handles the transfer/mint/burn functionality.\n   * @param from Address from where token is being transferred. Zero address means it is being minted.\n   * @param to Address to whom the token is being transferred. Zero address means it is being burned.\n   * @param tokenId Id of token that is being transferred/minted/burned.\n   */\n  function _transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) private {\n    require(_tokenOwner[tokenId] == from, \"ERC721: token not owned\");\n    require(to != address(0), \"ERC721: use burn instead\");\n    _clearApproval(tokenId);\n    _tokenOwner[tokenId] = to;\n    emit Transfer(from, to, tokenId);\n    _removeTokenFromOwnerEnumeration(from, tokenId);\n    _addTokenToOwnerEnumeration(to, tokenId);\n  }\n\n  function _chain() private view returns (uint32) {\n    uint32 currentChain = HolographInterface(HolographerInterface(payable(address(this))).getHolograph())\n      .getHolographChainId();\n    if (currentChain != HolographerInterface(payable(address(this))).getOriginChain()) {\n      return currentChain;\n    }\n    return uint32(0);\n  }\n\n  /**\n   * @notice Checks if the token owner exists.\n   * @dev If the address is the zero address no owner exists.\n   * @param tokenId The affected token.\n   * @return bool True if it exists.\n   */\n  function _exists(uint256 tokenId) private view returns (bool) {\n    address tokenOwner = _tokenOwner[tokenId];\n    return tokenOwner != address(0);\n  }\n\n  /**\n   * @notice Checks if the address is an approved one.\n   * @dev Uses inlined checks for different usecases of approval.\n   * @param spender Address of the spender.\n   * @param tokenId The affected token.\n   * @return bool True if approved.\n   */\n  function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\n    require(_exists(tokenId), \"ERC721: token does not exist\");\n    address tokenOwner = _tokenOwner[tokenId];\n    return (spender == tokenOwner || _tokenApprovals[tokenId] == spender || _operatorApprovals[tokenOwner][spender]);\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != precomputekeccak256(\"\"));\n  }\n\n  /**\n   * @dev Get the source smart contract as bridgeable interface.\n   */\n  function SourceERC721() private view returns (HolographedERC721 sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    Ownable ownableContract;\n    assembly {\n      ownableContract := sload(_sourceContractSlot)\n    }\n    return ownableContract.owner();\n  }\n\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Get the bridge contract address.\n   */\n  function _royalties() private view returns (address) {\n    return\n      HolographRegistryInterface(_holograph().getRegistry()).getContractTypeAddress(\n        0x0000000000000000000000000000000000000000000000000000000050413144\n      );\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    // we check if royalties support the function, send there, otherwise revert to source\n    address _target;\n    if (HolographInterfacesInterface(_interfaces()).supportsInterface(InterfaceType.PA1D, msg.sig)) {\n      _target = _royalties();\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    } else {\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        mstore(calldatasize(), caller())\n        let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  function _isEventRegistered(HolographERC721Event _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}"
    }
  ]
}