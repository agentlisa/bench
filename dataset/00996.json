{
  "Title": "M-2: Wound agent can't invoke heal in the next round",
  "Content": "# Issue M-2: Wound agent can't invoke heal in the next round \n\nSource: https://github.com/sherlock-audit/2023-10-looksrare-judging/issues/44 \n\n## Found by \ncoffiasd, lil.eth, mstpr-brainbot, pontifex\nAccording to the document:\n\n> if a user dies on round 12. The first round they can heal is round 13\nHowever incorrect current round id check led to users being unable to invoke the `heal` function in the next round.\n\n## Vulnerability Detail \nAssume players being marked as wounded in the round `12` , players cannot invoke  `heal` in the next round 13\n\n```solidity\n    function test_heal_in_next_round_v1() public {\n        _startGameAndDrawOneRound();\n\n        _drawXRounds(11);\n\n\n        (uint256[] memory woundedAgentIds, ) = infiltration.getRoundInfo({roundId: 12});\n\n        address agentOwner = _ownerOf(woundedAgentIds[0]);\n        looks.mint(agentOwner, HEAL_BASE_COST);\n\n        vm.startPrank(agentOwner);\n        _grantLooksApprovals();\n        looks.approve(TRANSFER_MANAGER, HEAL_BASE_COST);\n\n        uint256[] memory agentIds = new uint256[](1);\n        agentIds[0] = woundedAgentIds[0];\n\n        uint256[] memory costs = new uint256[](1);\n        costs[0] = HEAL_BASE_COST;\n\n        //get gameInfo\n        (,,,,,uint40 currentRoundId,,,,,) = infiltration.gameInfo();\n        assert(currentRoundId == 13);\n\n        //get agent Info\n        IInfiltration.Agent memory agentInfo = infiltration.getAgent(woundedAgentIds[0]);\n        assert(agentInfo.woundedAt == 12);\n\n        //agent can't invoke heal in the next round.\n        vm.expectRevert(IInfiltration.HealingMustWaitAtLeastOneRound.selector);\n        infiltration.heal(agentIds);\n    }\n```\n\n## Impact\nUser have to wait for 1 more round which led to the odds for an Agent to heal successfully start at 99% at Round 1 reduce to 98% at Round 2.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-looksrare/blob/main/contracts-infiltration/contracts/Infiltration.sol#L843#L847\n\n```solidity\n    // No need to check if the heal deadline has passed as the agent would be killed\n    unchecked {\n        if (currentRoundId - woundedAt < 2) {\n            revert HealingMustWaitAtLeastOneRound();\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\n    // No need to check if the heal deadline has passed as the agent would be killed\n    unchecked {\n-       if (currentRoundId - woundedAt < 2) {\n-       if (currentRoundId - woundedAt < 1) {\n            revert HealingMustWaitAtLeastOneRound();\n        }\n    }\n```\n\n\n\n## Discussion\n\n**nevillehuang**\n\n@0xhiroshi Any reason why you disagree with the severity? It does mentioned in the docs that the first round user can heal is right after the round his agent is wounded. The above PoC also shows how a user cannot heal a wounded agent at round 13 when his agent was wounded at round 12.\n\n**0xhiroshi**\n\nhttps://github.com/LooksRare/contracts-infiltration/pull/151\n\n**SergeKireev**\n\nFix LGTM\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/122",
  "Code": [
    {
      "filename": "contracts-infiltration/contracts/Infiltration.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IInfiltration} from \"./interfaces/IInfiltration.sol\";\n\nimport {OwnableTwoSteps} from \"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\";\nimport {IERC20} from \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\";\n\nimport {ProtocolFee} from \"@looksrare/contracts-libs/contracts/ProtocolFee.sol\";\nimport {PackableReentrancyGuard} from \"@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\";\nimport {LowLevelERC20Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelWETH} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\";\nimport {ITransferManager} from \"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\";\n\nimport {VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"erc721a/contracts/ERC721A.sol\";\n\nimport {UnsafeMathUint256} from \"./libraries/UnsafeMathUint256.sol\";\n\n//                                            .:^^^^^^:::::::::::::::::::::::::::::::::::::::::::::.\n//                                          :~7777!!!77?JJ??????!?YYYYYYYYJ?7~~!!!!!!!!!7???7~~~!~~^:.\n//                                        :~!!!~~77JYYYJJYJJJJJ7J5PPPPP55?!!!!!!!7!!~~~~~~!77??7?!7!!~^.\n//                                      .^~!!!7JYYYYYYJJJJJJJJJ7Y5PPPY?!!!!!!~~~~~~!7!!~~~~~~!????J??7!!^.\n//                                   .:^!!?JYYYYYYYYJJJJJJJYJJ!J55YJ?!!!!!~~~~~~~~~~~!!7!!!!!7!!!!!77?JJ?!~:.\n//                                 .:^~?YYYYYYYYYJJJJJJJJJJJJ??YYJ?!!!77!!!!!!!!!!!!!!~~!!!77!!!!!!!!!!!7?J7~:.\n//                               .^~~!~JYYYYYYYYYJJJJJJJJ???~^??7^.........:::::::^^^^!!!!!77!!!!!!!!!!~~!!7?7!^.\n//                             :^!!!!!~~JYYYYYYJJJJJJJ7!~^:::!????~....    ...:::::::::::^^~77!!!!!!!!!~~~!!!77!!^.\n//                           :~77~!7!!~!JYJJJJJJJJJ!^^^^^^^:^JJ???7!^^::::::::..::::::::::::.:~!!!!!~7?!~~~~!!!!~~!^.\n//                         :!?7!!!77!~~JJJJJJJJ?!^^^^^^^^^::J???5PPG##GPPP5555?77!::::::::.....::^!!!J5Y?!~~~~!77~~~!~:\n//                      .:7J?!~!77!~~~!JJJJJ?~^^^^^^^^^^^::~?5##&@@@@@&BGBGPPPP555YJ!^::......:::...^?55YJ?!~~!!!!~~!!!~:\n//                    .^7J?7!!!!!!~~~~JJJJ7~^^^^^^^^^^^^:^J##@@@@@@@@@@@&#GGPPP555PPP55?:...::::::.. :!?JJJJ7!~~!77!~!!~!~:.\n//                  .:!?77!!!!!!~~~~~7JJ7~^^^^^^^^^^^^::~J#@@@@@@@@@@@@@@@#BGP55PPPPPGGGJ^......:::. ^~:^7???7!!!!!!~~!!!~!~:.\n//                .:!7!~~!!!!!!!~~~~!J7~^^^^^^^^^^^^^::7PB&@@@@@@@@&&B55555YGGPPPPPPGGBBBG7......:::..:^::^!7777!!!!!~~!!!!~!~^.\n//              .:^~!?J!~!7!!!!!~~~!~~^^~^^^^^:::::::.7PGB&&&&@@@&G?~~~!!!!~~~75GBBBBBBBB#B?  ......   .... :~!7!!!!~~!!!!!7!~7?~.\n//            .:^~!?5PPJ!~!!!!!~!!^::!~!!!^:....... .^JPB&&&&&&&G?~~!!7?JJ7!~^:^!5###&#####P~       :^^:      .^!!~~!7777!!!!~7Y5J!.\n//          .:^~!JY5PPPPY!~~~~!!^.   .:^!!^.       ::YBB####&&&P~^~!~~~^^^^:::::.^P&&&&&#&&&5    .:!????7!^::.  .^!!77777777!~!J5PPY!:\n//        .:~~~?Y5555PP5Y?~~!!^.        .^:..^^^!77?!5BB######B~:^^^::::::::......^#&&&&&&&&5  .:!???????????7!!^::~7?7?77777777?Y555J~.\n//       .:^~!!7?J??????7!!!7~.       .......:^77?JJ!5BBBBBBB#B^:::::....::::::::.~&@@@@&&&&5...^^^^^^^^^^^~^^^^^^:.~7!!~~~~~!!!!!77?7~:.\n//         .:^~!~!77!!!!!~~~!!!^:..... .::~~:....:^^:?GBBBGPPP5~.....:::::::::::.:7&&&&&&&&&P:::^:^^^^^:. .:.    .^~~~~~~~~~~~~~!77!~:.\n//           .:^~!!!77!!!~~~~~~!!^.   .::!77~^:......!Y555555555!:..::::::::::..:?#&&&&&&@@&5!7???????!. :~:.. .^!!~~~~~~~~~~~!!7!~:.\n//            ..:^~!!7?!!~~~~~~~~!!~:.:^!7!^.:^: .....755PPPPPPGG57:..::::::..:7P#&&&&&&@@@P!7????JJJ!. :^::.:~!!~~~~~~~~!!!!!7!~:..\n//           .....:^~!!77!~~~~~~~!!!!!^!7!:....^^  .. :?PPGGGGGBBBBPYJ^^^^^^JYG####&&&#&@@G?7????JJJ~. :^:.:!777!!!!!!!!!!!!7!~:.....\n//         .........:^~!!77!~~~~~~!??JY?!:...  .^^  .. :?PGBBBB####&@&######&&&#######&&#P?7????JJ7~. :^:^!?77777777777!!!7!^:.........\n//        ..........:::^~!!77!!~~~~!JJ5J7!:.    .^^. ....~PBB#####&&@@@@@@@@&&########&#J77????J?7:  :^^!?77777777??7!!!7!^:::...........\n//      ..........:::::::^~~!7?7~~~~~7JY7!~~^.   .^^. .   ^7?G###&&&@@@@@@@@&&######GJY?77????J?7:  :!!!J?777777??7!!!!~^:::::::..........\n//    ..........::::::::^^^^~~?J7!~~~~~??7^757^^. .^^.       :7?PBB#&&&&&&&&&&#BBP?7^!777????J?7..~~?5?!????????7!!!!~^^^^::::::::..........\n//   ..........:::::::^^^^^^^^^!???!~~~~!?77J?:~~^^:^:  .       .::!JJJJJJJJJJ!^^^:..777??????!~^7J!JY77JJJJ??7!!!!~^^^^^^^^:::::::..........\n//  .........:::::::^^^^^^~~~~^^^!7J?!!~~~77!^:~~!~~~~:...    .  .. .::::::::::::::.^777?77??7~~7J5!!7?JJJJ?7!!!!~^^~~~~^^^^^^:::::::.........\n// .........:::::::^^^^^~~~~~~!~~^^!JJ?7!~!!!~^^^~~~~!??!^~^.... .. .:::::::::::::::77???Y5Y7~~?Y5YJJJJJJ??7~!!~~~!!~~~~~~^^^^^:::::::.........\n// ........::::::^^^^^^~~~~~!!!!!!!~~!??77!!!~~~~:^~~~!?J???7777~^~^~~~~!!~~~~~~~!7JYYP5PG57^!?Y55YYYJJJJ7!!!~~!!!!!!!~~~~~^^^^^^::::::........\n// ......:::::::^^^^^~~~~~~!!!!!7777!~~!??7777!~!~^^~!^!??J??????????555PP5555555J?55P5PP57^!?Y55P5YYYJ?!!!~~!7777!!!!!~~~~~~^^^^^:::::::......\n// .....:::::::^^^^^~~~~~!!!!!!77777??7~~!???7?777!^~!!7???77???????JY55GG555555Y??5555PY?77JY55PPP5Y?!!!~!7??777777!!!!!~~~~~^^^^^^::::::.....\n// ....::::::^^^^^^~~~~~!!!!!77777??????!^^!?YY??!!!^~!777!^!??7!!!!!7Y5PP5YYYYJ7~Y5P55?7?JJY5555PPY7!!^^!??????77777!!!!!~~~~~^^^^^^::::::....\n// ...::::::^^^^^~~~~~!!!!!!77777??77!~~~~^:~7JP5J7^~~!!!7!7??!7777?JJ5YYYYPPP5J77555PJ77?JY555PP5J?7~^^~~~~!77??77777!!!!!!~~~~~^^^^^::::::...\n// ..::::::^^^^^~~~~~!!!!!777777!!~~~~~!!!!!~^~?5PY7~~!77!!?7!!7????JJ55555555Y?7JP5YJ?7JJY55555Y?7~^~!!!!!~~~~~!!777777!!!!!~~~~~^^^^^::::::..\n// ..::::::^^^^~~~~~!!!!!77!!~~~~~~~~7?JJJ?77!^:~?Y5Y!~!7!^7J7~~!7777?YYYYYYYYJ7?55J7JJ7J55555Y?!^:^!77?JJJ?7~~~~~~~~!!77!!!!!~~~~~^^^^^:::::..\n// .::::::^^^^^~~~~!!!!!!!^^^^^^~!!7777JJY?77!!~^.^7YY?~^!!^?J7~^^!77?YYYYYYYY7~75Y7JJ?JY555Y?!^:^~!!77?YJJ7777!!~^^^^^^!!!!!!!~~~~^^^^^::::::.\n// ::::::^^^^^~~~~~!!!!7!:!!^:^~~!!!7!777?JJ?77!~.::^7JJ7^^~~~????77?Y5PP5P55Y7?5Y?J???Y55Y?!^:::~!77?JJ?777!7!!!~~^:^!!^!7!!!!~~~~~^^^^^::::::\n// :::::^^^^^~~~~~!!!!77!:J?!^^^~~~!!!!!777??777~.^^::^7YJ!^^!!77!!7JJY555555J7!!77J??JYY?!^::^^:!777??777!!!!!~~~^^^!?J^!77!!!!~~~~~^^^^^:::::\n// :::::^^^^^~~~~!!!!!777~^!???7~^~~~!!!!!777777!.^~~~^^~?J!~^~~~!7??JJ55555Y?77!!???J?~^^:^~~~^:!777777!!!!!~~~^~7???!^~777!!!!!~~~~^^^^^:::::\n// ::::^^^^^~~~~~!!!!77777~^^~!??7~^~~~~~!!!!!777!.^!!~!!^^!?7!77!~!?JJ5555YJ7~^7JJJ!~:.:!!~!!^:!777!!!!!~~~~~^~7??!~^^~77777!!!!~~~~~^^^^^::::\n// ::::^^^^^~~~~!!!!!7777??7!^^^!??7~^~~~~~~!!!!!!.^~!!7??^.^!????????YPPPPJ~^~7JJ?!^:.^??7!!~^:!!!!!!~~~~~~^~7??!^^^!7??7777!!!!!~~~~^^^^^::::\n// ::::^^^^~~~~~!!!!77777777??~^^^~7?7~^~^~~~~!~!~.:!!7!75J::::!7????7?PPP5!^~7777~::::J57!7!!^:!!~!~~~~^~^~7?7~^^^~??77777777!!!!~~~~~^^^^::::\n// :::^^^^^~~~~!!!!!~~~^:::^^~7^:^^^~7?7!^^^^~~~~~..!!!77?5J:^^::~7?J?7JPPJ:~77!^::^^:J5?77!!!..~~~~~^^^^!7?7~^^^^~7~^^:::^~~~!!!!!~~~~^^^^^:::\n// ::::^^^^~~~~!!!~^^^^~^^^^:.::::^~^:~7??!^::^^^: :~!!!77?5J:^~~::~?JJ?P5~!??~::~~^:J5?77!!!~: :^^^::^!??7~:^~^::::.:^^^^~^^^^~!!!~~~~^^^^::::\n// ::::::^^~~~~!!~^^^~~~~^^^^:.::::^~^::~7??!^::::.::!7!!!7?5J^^~!!~^~?YPP?7~^~!!~^^J5?7!!!7!::.::::^!??7~::^~^::::.:^^^^~~~~^^^~!!~~~~^^::::::\n// ^^^^~~^^^^~~!~:^^~~!~~~^^^^:.::^~~^^:::^!??!:~!~::^!!!!!7?5J^^~!77~^~??~^~77!~^^J5?7!!!!!^::~!~:!??!^:::^^~~^::.:^^^^~~~!~~^^:~!~~^^^^~~^^^^\n// ^^^~~^:^^^^^~:^^~~!!!!!!!~~~^::~^^^^^^:::!J?!^!7!^::~!!!!7?5Y!^~!!7!~^^~!7!!~^!Y5?7!!!!~::^!7!^!?J!:::^^^^^^~::^~~~!!!!!!!~~^^:~^^^^::^~~^^^\n// !!~!7^.::^^::.^~~!!!!!77?JJJJ?!~^::^^^^^^~7?~:!!77!^^~~!!!7?J5Y7~^^~!~~!~^^~7Y5J?7!!!~~^^!77!!:~?7~^^^^^^::^~!?JJJJ?77!!!!!~~^.::^^::.^7!~!!\n// 777J?:.:^^^...:^~!!!7Y??7?777???!.:^~^^^~!~~!!!!!!7?7~^^^~~!77?JJ??~~~~~~??JJ?77!~~^^^~7?7!!!!!!~~!~^^^~^:.!??7777?7??Y7!!!~^:...^^^:.:?J777\n// !!7Y?::!77~:^^:.:^~7J??!!!7^~!!77~.:~7~~~~^^?J?!^^~~!7??!~^^^~~!!7????????7!!~~^^^~!??7!~~^^!?J?^^~~~~7~:.~777~^~~7!!??J7~^:.:^^:~77!::?Y7!!\n// !!7Y?::!!~:~?7~^:::^~~7!!7!^~~~7!!~.:~!!~~~^^^~: .:^^^^~~!7!~~~^:^^^^^^^^^^:^~~~!7!~~^^^^:. :~^^^~~~!!~:.~!!7!^~!~~7!7~~^:::^~7?~:~!!::?Y7!!\n// ?77?Y7^:^:~!??J?7!^::^~!!!~~~~!!!!~^.:^7?!~~^^^^::.:^^~!!~~~~~~^^^^^^^^^^^^^^~~~~~~!!~^^:.::^^^^~~!?7^:.^~!!!!~~~~!!!~^::^!7?J??!~:^:^7Y?77?\n// ??!7YJ^.:^!7???YYJ?7~~^^~~7!!!~~~~~~^::^~7??777!~!^^^^:::^~~~!!!!!!!!!!!!!!!!!!~~~^:::^^^^!~!777??7~^::^~~~~~~!!!7~~^^~~7?JYY???7!^:.^JY7!??\n// ??77YJ~.^~!77?JJJYYYYJ7!^^^~!777!!~~~~^::^^~!77????77?7!!~~~~^::::::::::::::::^~~~~!!7?77????77!~^^::^~~~~!!777!~^^^!7JYYYYJJJ?77!~^.~JY77??\n// J??77YJ~.^!!!JJ??777??YYJJ7!~^^~!77!~~~~~~~^^^^^~~!7777??????777777777777777777??????7777!~~^^^^^~~~~~~~!77!~^^~!7JJYY??777??JJ!!!^.~JY77??J\n// YY?77JY!:^!!!YJ?7!!!~~!!??JYJJ7!~^~~!!!~!!!!7777~~~~^^^~~~~~!777777777777777777!~~~~~^^^~~~~7777!!!!~!!!~~^~!7JJYJ??!!~~!!!7?JY!!!^:!YJ77?YY\n// YYJ?77JY!:~!!?Y?7!!!~~~~~~!!7?JYJ?7~^^~~!!!!7????????777777~~~~~~~~~~~~~~~~~~~~~~777777????????7!!!!~~^^~7?JYJ?7!!~~~~~~!!!7?Y?!!~:!YJ77?JYY\n// YJYJJ?7?J?^:!!?J?!!!~~~~~~~~~~~!7JJYY?~^^~!!77!7777?????????JJJJJJJJJJJJJJJJJJJJ?????????7777!77!!~^^~?YYJJ7!~~~~~~~~~~~!!!?J?!!:^?J?7?JJYJY\ncontract Infiltration is\n    IInfiltration,\n    OwnableTwoSteps,\n    ERC721A,\n    VRFConsumerBaseV2,\n    LowLevelERC20Transfer,\n    LowLevelWETH,\n    ProtocolFee,\n    PackableReentrancyGuard\n{\n    using UnsafeMathUint256 for uint256;\n\n    /**\n     * @notice When the frontrun lock is unlocked, agents can escape or heal.\n     */\n    uint8 private constant FRONTRUN_LOCK__UNLOCKED = 1;\n\n    /**\n     * @notice When the frontrun lock is locked, agents cannot escape or heal.\n     */\n    uint8 private constant FRONTRUN_LOCK__LOCKED = 2;\n\n    /**\n     * @notice When VRF is being requested, agents cannot escape or heal. It unlocks when the randomness is fulfilled.\n     * @dev frontrunLock is initially set as locked so that agents cannot escape or heal before the game starts.\n     *      It is unlocked when the first round's randomness is fulfilled.\n     */\n    uint8 private frontrunLock = FRONTRUN_LOCK__LOCKED;\n\n    /**\n     * @notice 100% in basis points.\n     */\n    uint256 private constant ONE_HUNDRED_PERCENT_IN_BASIS_POINTS = 10_000;\n\n    /**\n     * @notice 100% in basis points squared.\n     */\n    uint256 private constant ONE_HUNDRED_PERCENT_IN_BASIS_POINTS_SQUARED = 10_000 ** 2;\n\n    /**\n     * @notice The number of secondary prize pool winners. Their entitled shares are based on their placements.\n     *         When the number of active agents is less than or equal to this number, 1 agent is instantly killed\n     *         in each round.\n     */\n    uint256 private constant NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS = 50;\n\n    uint256 private constant PROBABILITY_PRECISION = 100_000_000;\n\n    /**\n     * @notice Max agent supply.\n     */\n    uint256 public immutable MAX_SUPPLY;\n\n    /**\n     * @notice Max mint per address.\n     */\n    uint256 public immutable MAX_MINT_PER_ADDRESS;\n\n    /**\n     * @notice The price of minting 1 agent.\n     */\n    uint256 public immutable PRICE;\n\n    /**\n     * @notice The number of blocks per round.\n     */\n    uint256 public immutable BLOCKS_PER_ROUND;\n\n    /**\n     * @notice The percentage of agents to wound per round in basis points.\n     */\n    uint256 public immutable AGENTS_TO_WOUND_PER_ROUND_IN_BASIS_POINTS;\n\n    /**\n     * @notice The number of rounds for agents to be wounded before getting killed.\n     */\n    uint256 public immutable ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD;\n\n    /**\n     * @notice This value is used as the denominator in healProbability.\n     */\n    uint256 private immutable ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE;\n\n    /**\n     * @notice This value is used as the minuend in healProbability.\n     */\n    uint256 private immutable HEAL_PROBABILITY_MINUEND;\n\n    /**\n     * @notice The base cost of healing an agent. The cost increases for each successful heal.\n     */\n    uint256 public immutable HEAL_BASE_COST;\n\n    /**\n     * @notice WETH address.\n     */\n    address private immutable WETH;\n\n    /**\n     * @notice LOOKS address.\n     */\n    address private immutable LOOKS;\n\n    /**\n     * @notice Chainlink VRF key hash.\n     */\n\n    bytes32 private immutable KEY_HASH;\n\n    /**\n     * @notice Chainlink VRF coordinator.\n     */\n    VRFCoordinatorV2Interface private immutable VRF_COORDINATOR;\n\n    /**\n     * @notice Chainlink VRF subscription ID.\n     */\n    uint64 private immutable SUBSCRIPTION_ID;\n\n    /**\n     * @notice The transfer manager contract that manages LOOKS approvals.\n     */\n    ITransferManager private immutable TRANSFER_MANAGER;\n\n    /**\n     * @notice The timestamp at which the mint period starts.\n     */\n    uint40 public mintStart;\n\n    /**\n     * @notice The timestamp at which the mint period ends.\n     */\n    uint40 public mintEnd;\n\n    /**\n     * @notice The bitmap of the placements of the secondary prize pool winners.\n     * @dev Only bit 1 to 50 are used. Bit 0 is not used.\n     */\n    uint56 private prizesClaimedBitmap;\n\n    /**\n     * @notice The base URI of the collection.\n     */\n    string private baseURI;\n\n    /**\n     * @notice Amount of agents minted per address.\n     */\n    mapping(address minter => uint256 amount) public amountMintedPerAddress;\n\n    /**\n     * @notice Chainlink randomness requests.\n     */\n    mapping(uint256 requestId => RandomnessRequest) public randomnessRequests;\n\n    /**\n     * @notice The mapping agents acts as an \"array\". In the beginning of the game, the \"length\" of the \"array\"\n     *         is the total supply. As the game progresses, the \"length\" of the \"array\" decreases\n     *         as agents are killed. The function agentsAlive() returns the \"length\" of the \"array\".\n     *\n     *         When an Agent struct has 0 value for every field with its index within the total supply,\n     *         it means that the agent is active.\n     *\n     *         Index 0 is not used as agent ID starts from 1.\n     */\n    mapping(uint256 index => Agent) private agents;\n\n    /**\n     * @notice It is used to find the index of an agent in the agents mapping given its agent ID.\n     *         If the index is 0, it means the agent's index is the same as its agent ID as no swaps\n     *         have been made.\n     */\n    mapping(uint256 agentId => uint256 index) private agentIdToIndex;\n\n    /**\n     * @notice The maximum healing or wounded agents allowed per round.\n     */\n    uint256 private constant MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND = 30;\n\n    /**\n     * @notice The maximum healing or wounded agents allowed per round + 1 for storing the array length.\n     */\n    uint256 private constant MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH = 31;\n\n    /**\n     * @notice The first element of the array is the length of the array.\n     */\n    mapping(uint256 roundId => uint16[MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH] agentIds)\n        private woundedAgentIdsPerRound;\n\n    /**\n     * @notice The first element of the array is the length of the array.\n     */\n    mapping(uint256 roundId => uint16[MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH] agentIds)\n        private healingAgentIdsPerRound;\n\n    /**\n     * @notice Game information.\n     */\n    GameInfo public gameInfo;\n\n    /**\n     * @dev Agent struct status offset for bitwise operations.\n     */\n    uint256 private constant AGENT__STATUS_OFFSET = 16;\n\n    /**\n     * @dev Agent struct wounded at offset for bitwise operations.\n     */\n    uint256 private constant AGENT__WOUNDED_AT_OFFSET = 24;\n\n    /**\n     * @dev Agent struct heal count offset for bitwise operations.\n     */\n    uint256 private constant AGENT__HEAL_COUNT_OFFSET = 64;\n\n    /**\n     * @dev GameInfo struct wounded agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__WOUNDED_AGENTS_OFFSET = 16;\n\n    /**\n     * @dev GameInfo struct healing agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__HEALING_AGENTS_OFFSET = 32;\n\n    /**\n     * @dev GameInfo struct dead agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__DEAD_AGENTS_OFFSET = 48;\n\n    /**\n     * @dev GameInfo struct escaped agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__ESCAPED_AGENTS_OFFSET = 64;\n\n    /**\n     * @dev GameInfo struct current round ID offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__CURRENT_ROUND_ID_OFFSET = 80;\n\n    /**\n     * @dev GameInfo struct current round block number offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__CURRENT_ROUND_BLOCK_NUMBER_OFFSET = 120;\n\n    /**\n     * @dev RandomnessRequest struct exists offset for bitwise operations.\n     */\n    uint256 private constant RANDOMNESS_REQUESTS__EXISTS_OFFSET = 8;\n\n    /**\n     * @dev 2 bytes bitmask.\n     */\n    uint256 private constant TWO_BYTES_BITMASK = 0xffff;\n\n    /**\n     * @dev 5 bytes bitmask.\n     */\n    uint256 private constant FIVE_BYTES_BITMASK = 0xffffffffff;\n\n    /**\n     * @param constructorCalldata Constructor calldata. See IInfiltration.ConstructorCalldata for its key values.\n     */\n    constructor(\n        ConstructorCalldata memory constructorCalldata\n    )\n        OwnableTwoSteps(constructorCalldata.owner)\n        ERC721A(constructorCalldata.name, constructorCalldata.symbol)\n        VRFConsumerBaseV2(constructorCalldata.vrfCoordinator)\n    {\n        if (\n            constructorCalldata.maxSupply <= NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS ||\n            constructorCalldata.maxSupply > type(uint16).max\n        ) {\n            revert InvalidMaxSupply();\n        }\n\n        if (\n            (constructorCalldata.maxSupply * constructorCalldata.agentsToWoundPerRoundInBasisPoints) >\n            MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND * ONE_HUNDRED_PERCENT_IN_BASIS_POINTS\n        ) {\n            revert WoundedAgentIdsPerRoundExceeded();\n        }\n\n        if (constructorCalldata.roundsToBeWoundedBeforeDead < 3) {\n            revert RoundsToBeWoundedBeforeDeadTooLow();\n        }\n\n        PRICE = constructorCalldata.price;\n        MAX_SUPPLY = constructorCalldata.maxSupply;\n        MAX_MINT_PER_ADDRESS = constructorCalldata.maxMintPerAddress;\n        BLOCKS_PER_ROUND = constructorCalldata.blocksPerRound;\n        AGENTS_TO_WOUND_PER_ROUND_IN_BASIS_POINTS = constructorCalldata.agentsToWoundPerRoundInBasisPoints;\n        ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD = constructorCalldata.roundsToBeWoundedBeforeDead;\n\n        // The next 2 values are used in healProbability\n        ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE = ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD.unsafeSubtract(1);\n        HEAL_PROBABILITY_MINUEND =\n            ((ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD * 99 - 80) * PROBABILITY_PRECISION) /\n            ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE;\n\n        LOOKS = constructorCalldata.looks;\n        HEAL_BASE_COST = constructorCalldata.healBaseCost;\n\n        KEY_HASH = constructorCalldata.keyHash;\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(constructorCalldata.vrfCoordinator);\n        SUBSCRIPTION_ID = constructorCalldata.subscriptionId;\n\n        TRANSFER_MANAGER = ITransferManager(constructorCalldata.transferManager);\n        WETH = constructorCalldata.weth;\n\n        baseURI = constructorCalldata.baseURI;\n\n        _updateProtocolFeeRecipient(constructorCalldata.protocolFeeRecipient);\n        _updateProtocolFeeBp(constructorCalldata.protocolFeeBp);\n    }\n\n    /**\n     * @dev updateProtocolFeeBp is not implemented in this contract.\n     */\n    function updateProtocolFeeBp(uint16) external pure override {\n        revert Immutable();\n    }\n\n    /**\n     * @dev updateProtocolFeeRecipient is not implemented in this contract.\n     */\n    function updateProtocolFeeRecipient(address) external pure override {\n        revert Immutable();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function setMintPeriod(uint40 newMintStart, uint40 newMintEnd) external onlyOwner {\n        if (newMintStart >= newMintEnd) {\n            revert InvalidMintPeriod();\n        }\n\n        if (newMintStart != 0) {\n            if (block.timestamp > newMintStart) {\n                revert MintStartIsInThePast();\n            }\n\n            uint256 currentMintStart = mintStart;\n            if (currentMintStart != 0) {\n                if (block.timestamp >= currentMintStart) {\n                    revert MintAlreadyStarted();\n                }\n            }\n\n            mintStart = newMintStart;\n        }\n\n        if (block.timestamp > newMintEnd || newMintEnd < mintEnd) {\n            revert MintCanOnlyBeExtended();\n        }\n\n        mintEnd = newMintEnd;\n\n        emit MintPeriodUpdated(newMintStart == 0 ? mintStart : newMintStart, newMintEnd);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @notice As long as the game has not started (after mint end), the owner can still mint.\n     */\n    function premint(address to, uint256 quantity) external payable onlyOwner {\n        if (quantity * PRICE != msg.value) {\n            revert InsufficientNativeTokensSupplied();\n        }\n\n        if (totalSupply() + quantity > MAX_SUPPLY) {\n            revert ExceededTotalSupply();\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        _mintERC2309(to, quantity);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function mint(uint256 quantity) external payable nonReentrant {\n        if (block.timestamp < mintStart || block.timestamp > mintEnd) {\n            revert NotInMintPeriod();\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        uint256 amountMinted = amountMintedPerAddress[msg.sender] + quantity;\n        if (amountMinted > MAX_MINT_PER_ADDRESS) {\n            revert TooManyMinted();\n        }\n\n        if (quantity * PRICE != msg.value) {\n            revert InsufficientNativeTokensSupplied();\n        }\n\n        if (totalSupply() + quantity > MAX_SUPPLY) {\n            revert ExceededTotalSupply();\n        }\n\n        amountMintedPerAddress[msg.sender] = amountMinted;\n        _mintERC2309(msg.sender, quantity);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @dev If Chainlink randomness callback does not come back after 1 day, we can call\n     *      startNewRound to trigger a new randomness request.\n     */\n    function startGame() external onlyOwner {\n        uint256 numberOfAgents = totalSupply();\n        if (numberOfAgents < MAX_SUPPLY) {\n            if (block.timestamp < mintEnd) {\n                revert StillMinting();\n            }\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        gameInfo.currentRoundId = 1;\n        gameInfo.activeAgents = uint16(numberOfAgents);\n        uint256 balance = address(this).balance;\n        uint256 protocolFee = balance.unsafeMultiply(protocolFeeBp).unsafeDivide(ONE_HUNDRED_PERCENT_IN_BASIS_POINTS);\n        unchecked {\n            gameInfo.prizePool = balance - protocolFee;\n        }\n\n        emit RoundStarted(1);\n\n        _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFee, gasleft());\n        _requestForRandomness();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function emergencyWithdraw() external onlyOwner {\n        uint256 activeAgents;\n        uint256 woundedAgents;\n        uint256 healingAgents;\n        uint256 escapedAgents;\n        uint256 deadAgents;\n        uint256 currentRoundId;\n        uint256 currentRoundBlockNumber;\n\n        assembly {\n            let gameInfoSlot0Value := sload(gameInfo.slot)\n            activeAgents := and(gameInfoSlot0Value, TWO_BYTES_BITMASK)\n            woundedAgents := and(shr(GAME_INFO__WOUNDED_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            healingAgents := and(shr(GAME_INFO__HEALING_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            escapedAgents := and(shr(GAME_INFO__ESCAPED_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            deadAgents := and(shr(GAME_INFO__DEAD_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            currentRoundId := and(shr(GAME_INFO__CURRENT_ROUND_ID_OFFSET, gameInfoSlot0Value), FIVE_BYTES_BITMASK)\n            currentRoundBlockNumber := and(\n                shr(GAME_INFO__CURRENT_ROUND_BLOCK_NUMBER_OFFSET, gameInfoSlot0Value),\n                FIVE_BYTES_BITMASK\n            )\n        }\n\n        bool conditionOne = currentRoundId != 0 &&\n            activeAgents + woundedAgents + healingAgents + escapedAgents + deadAgents != totalSupply();\n\n        // 50 blocks per round * 216 = 10,800 blocks which is roughly 36 hours\n        // Prefer not to hard code this number as BLOCKS_PER_ROUND is not always 50\n        bool conditionTwo = currentRoundId != 0 &&\n            activeAgents > 1 &&\n            block.number > currentRoundBlockNumber + BLOCKS_PER_ROUND * 216;\n\n        // Just in case startGame reverts, we can withdraw the ETH balance and redistribute to addresses that participated in the mint.\n        bool conditionThree = currentRoundId == 0 && block.timestamp > uint256(mintEnd).unsafeAdd(36 hours);\n\n        if (conditionOne || conditionTwo || conditionThree) {\n            uint256 ethBalance = address(this).balance;\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethBalance, gasleft());\n\n            uint256 looksBalance = IERC20(LOOKS).balanceOf(address(this));\n            _executeERC20DirectTransfer(LOOKS, msg.sender, looksBalance);\n\n            emit EmergencyWithdrawal(ethBalance, looksBalance);\n        }\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @dev If Chainlink randomness callback does not come back after 1 day, we can try by calling\n     *      startNewRound again.\n     */\n    function startNewRound() external nonReentrant {\n        uint256 currentRoundId = gameInfo.currentRoundId;\n        if (currentRoundId == 0) {\n            revert GameNotYetBegun();\n        }\n\n        if (block.number < uint256(gameInfo.currentRoundBlockNumber).unsafeAdd(BLOCKS_PER_ROUND)) {\n            revert TooEarlyToStartNewRound();\n        }\n\n        uint256 activeAgents = gameInfo.activeAgents;\n        if (activeAgents == 1) {\n            revert GameOver();\n        }\n\n        if (block.timestamp < uint256(gameInfo.randomnessLastRequestedAt).unsafeAdd(1 days)) {\n            revert TooEarlyToRetryRandomnessRequest();\n        }\n\n        if (activeAgents <= NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS) {\n            uint256 woundedAgents = gameInfo.woundedAgents;\n\n            if (woundedAgents != 0) {\n                uint256 killRoundId = currentRoundId > ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD\n                    ? currentRoundId.unsafeSubtract(ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD)\n                    : 1;\n                uint256 agentsRemaining = agentsAlive();\n                uint256 totalDeadAgentsFromKilling;\n                while (woundedAgentIdsPerRound[killRoundId][0] != 0) {\n                    uint256 deadAgentsFromKilling = _killWoundedAgents({\n                        roundId: killRoundId,\n                        currentRoundAgentsAlive: agentsRemaining\n                    });\n                    unchecked {\n                        totalDeadAgentsFromKilling += deadAgentsFromKilling;\n                        agentsRemaining -= deadAgentsFromKilling;\n                        ++killRoundId;\n                    }\n                }\n\n                // This is equivalent to\n                // unchecked {\n                //     gameInfo.deadAgents += uint16(totalDeadAgentsFromKilling);\n                // }\n                // gameInfo.woundedAgents = 0;\n                assembly {\n                    let gameInfoSlot0Value := sload(gameInfo.slot)\n                    let deadAgents := and(shr(GAME_INFO__DEAD_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n\n                    gameInfoSlot0Value := and(\n                        gameInfoSlot0Value,\n                        // This is equivalent to\n                        // not(\n                        //     or(\n                        //         shl(GAME_INFO__WOUNDED_AGENTS_OFFSET, TWO_BYTES_BITMASK),\n                        //         shl(GAME_INFO__DEAD_AGENTS_OFFSET, TWO_BYTES_BITMASK)\n                        //     )\n                        // )\n                        0xffffffffffffffffffffffffffffffffffffffffffffffff0000ffff0000ffff\n                    )\n\n                    gameInfoSlot0Value := or(\n                        gameInfoSlot0Value,\n                        shl(GAME_INFO__DEAD_AGENTS_OFFSET, add(deadAgents, totalDeadAgentsFromKilling))\n                    )\n\n                    sstore(gameInfo.slot, gameInfoSlot0Value)\n                }\n            }\n        }\n\n        _requestForRandomness();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function claimGrandPrize() external nonReentrant {\n        _assertGameOver();\n        uint256 agentId = agents[1].agentId;\n        _assertAgentOwnership(agentId);\n\n        uint256 prizePool = gameInfo.prizePool;\n\n        if (prizePool == 0) {\n            revert NothingToClaim();\n        }\n\n        gameInfo.prizePool = 0;\n\n        _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, prizePool, gasleft());\n\n        emit PrizeClaimed(agentId, address(0), prizePool);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function claimSecondaryPrizes(uint256 agentId) external nonReentrant {\n        _assertGameOver();\n        _assertAgentOwnership(agentId);\n\n        uint256 placement = agentIndex(agentId);\n        _assertValidPlacement(placement);\n\n        uint56 _prizesClaimedBitmap = prizesClaimedBitmap;\n        if ((_prizesClaimedBitmap >> placement) & 1 != 0) {\n            revert NothingToClaim();\n        }\n\n        prizesClaimedBitmap = _prizesClaimedBitmap | uint56(1 << placement);\n\n        uint256 ethAmount = secondaryPrizePoolShareAmount(gameInfo.secondaryPrizePool, placement);\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n            emit PrizeClaimed(agentId, address(0), ethAmount);\n        }\n\n        uint256 secondaryLooksPrizePool = gameInfo.secondaryLooksPrizePool;\n        if (secondaryLooksPrizePool == 0) {\n            secondaryLooksPrizePool = IERC20(LOOKS).balanceOf(address(this));\n            if (secondaryLooksPrizePool == 0) {\n                return;\n            }\n            gameInfo.secondaryLooksPrizePool = secondaryLooksPrizePool;\n        }\n\n        uint256 looksAmount = secondaryPrizePoolShareAmount(secondaryLooksPrizePool, placement);\n        if (looksAmount != 0) {\n            _executeERC20DirectTransfer(LOOKS, msg.sender, looksAmount);\n            emit PrizeClaimed(agentId, LOOKS, looksAmount);\n        }\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function escape(uint256[] calldata agentIds) external nonReentrant {\n        _assertFrontrunLockIsOff();\n\n        uint256 agentIdsCount = agentIds.length;\n        _assertNotEmptyAgentIdsArrayProvided(agentIdsCount);\n\n        uint256 activeAgents = gameInfo.activeAgents;\n        uint256 activeAgentsAfterEscape = activeAgents - agentIdsCount;\n        _assertGameIsNotOverAfterEscape(activeAgentsAfterEscape);\n\n        uint256 currentRoundAgentsAlive = agentsAlive();\n\n        uint256 prizePool = gameInfo.prizePool;\n        uint256 secondaryPrizePool = gameInfo.secondaryPrizePool;\n        uint256 reward;\n        uint256[] memory rewards = new uint256[](agentIdsCount);\n\n        for (uint256 i; i < agentIdsCount; ) {\n            uint256 agentId = agentIds[i];\n            _assertAgentOwnership(agentId);\n\n            uint256 index = agentIndex(agentId);\n            _assertAgentStatus(agents[index], agentId, AgentStatus.Active);\n\n            uint256 totalEscapeValue = prizePool / currentRoundAgentsAlive;\n            uint256 rewardForPlayer = (totalEscapeValue * _escapeMultiplier(currentRoundAgentsAlive)) /\n                ONE_HUNDRED_PERCENT_IN_BASIS_POINTS;\n            rewards[i] = rewardForPlayer;\n            reward += rewardForPlayer;\n\n            uint256 rewardToSecondaryPrizePool = (totalEscapeValue.unsafeSubtract(rewardForPlayer) *\n                _escapeRewardSplitForSecondaryPrizePool(currentRoundAgentsAlive)) / ONE_HUNDRED_PERCENT_IN_BASIS_POINTS;\n\n            unchecked {\n                prizePool = prizePool - rewardForPlayer - rewardToSecondaryPrizePool;\n            }\n            secondaryPrizePool += rewardToSecondaryPrizePool;\n\n            _swap({\n                currentAgentIndex: index,\n                lastAgentIn"
    }
  ]
}