{
  "Title": "[M06] Incentive does not initialize when Ether depreciates",
  "Content": "Once `FEI` reaches parity with `USDC`, there are 2 ways for the `FEI` price to fall below the peg: either by users selling `FEI` (which the protocol handles) or by ETH depreciating against `USDC`. There is no incentive to support the peg if ETH depreciates against `USDC`, because:\n\n\n* When the price is above the peg, `timeWeightInfo.active` is [set to false](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L218-L221).\n* If the `FEI` price naturally drops without users trading (i.e., by ETH depreciation against `USDC`), nothing triggers updates to the `timeWeightInfo` variables.\n* The `getTimeWeight` function returns `0` [when `timeWeightInfo.active` is false](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L86-L88).\n* [The `calculateBuyIncentiveMultiplier` function returns `0` when weight is `0`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/token/UniswapIncentive.sol#L197), regardless of the deviation.\n\n\nNothing forces the time-weighted incentive to become active except trading. Therefore, if `FEI` depreciates because Ether has depreciated against `USDC`, nothing incentivizes buyers to support the peg. Some trading activity would need to happen (i.e., selling, or an unincentivized buy) to start the time-weighted incentive. In such a case where a trade happens after Ether depreciates, the time-weighted incentive is measured from the block where the trade was executed, and not the block when `FEI` first fell below the peg due to Ether depreciation. In practice, this could also lead to prospective buyers monitoring the mempool for trades against the incentivized address, intending to back-run those transactions to capture an incentive.\n\n\nConsider adding an incentive for buys when the initial price is below the peg even if the time-weighted period has not yet been initialized.\n\n\n**Update:** *Acknowledged. In the words of the Fei Team: We acknowledge that this is an issue but we expect natural arbitrage and trading activity to initialize it within a reasonable time frame.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculateSellPenaltyMultiplier(deviation);\n        Decimal.D256 memory buyMultiplier = deviation.mul(uint(weight)).div(uint(TIME_WEIGHT_GRANULARITY));\n        \n        if (correspondingPenalty.lessThan(buyMultiplier)) {\n            return correspondingPenalty;\n        }\n        \n        return buyMultiplier;\n    }\n\n    function calculateSellPenaltyMultiplier(\n        Decimal.D256 memory deviation\n    ) internal pure returns (Decimal.D256 memory) {\n        return deviation.mul(deviation).mul(100); // m^2 * 100\n    }\n\n    function updateTimeWeight (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation, \n        uint32 currentWeight\n    ) internal {\n        // Reset after completion\n        if (finalDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), false);\n            return;\n        } \n        // Init\n        if (initialDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), true);\n            return;\n        }\n\n        uint updatedWeight = uint(currentWeight);\n        // Partial buy\n        if (initialDeviation.greaterThan(finalDeviation)) {\n            Decimal.D256 memory remainingRatio = finalDeviation.div(initialDeviation);\n            updatedWeight = remainingRatio.mul(uint(currentWeight)).asUint256();\n        }\n        \n        uint maxWeight = finalDeviation.mul(100).mul(uint(TIME_WEIGHT_GRANULARITY)).asUint256(); // m^2*100 (sell) = t*m (buy) \n        updatedWeight = Math.min(updatedWeight, maxWeight);\n        _setTimeWeight(updatedWeight.toUint32(), getGrowthRate(), true);\n    }\n\n    function _setTimeWeight(uint32 weight, uint32 growthRate, bool active) internal {\n        uint32 currentGrowth = getGrowthRate();\n\n        uint32 blockNo = block.number.toUint32();\n\n        timeWeightInfo = TimeWeightInfo(blockNo, weight, growthRate, active);\n\n        emit TimeWeightUpdate(weight, active);   \n        if (currentGrowth != growthRate) {\n            emit GrowthRateUpdate(growthRate);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculateSellPenaltyMultiplier(deviation);\n        Decimal.D256 memory buyMultiplier = deviation.mul(uint(weight)).div(uint(TIME_WEIGHT_GRANULARITY));\n        \n        if (correspondingPenalty.lessThan(buyMultiplier)) {\n            return correspondingPenalty;\n        }\n        \n        return buyMultiplier;\n    }\n\n    function calculateSellPenaltyMultiplier(\n        Decimal.D256 memory deviation\n    ) internal pure returns (Decimal.D256 memory) {\n        return deviation.mul(deviation).mul(100); // m^2 * 100\n    }\n\n    function updateTimeWeight (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation, \n        uint32 currentWeight\n    ) internal {\n        // Reset after completion\n        if (finalDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), false);\n            return;\n        } \n        // Init\n        if (initialDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), true);\n            return;\n        }\n\n        uint updatedWeight = uint(currentWeight);\n        // Partial buy\n        if (initialDeviation.greaterThan(finalDeviation)) {\n            Decimal.D256 memory remainingRatio = finalDeviation.div(initialDeviation);\n            updatedWeight = remainingRatio.mul(uint(currentWeight)).asUint256();\n        }\n        \n        uint maxWeight = finalDeviation.mul(100).mul(uint(TIME_WEIGHT_GRANULARITY)).asUint256(); // m^2*100 (sell) = t*m (buy) \n        updatedWeight = Math.min(updatedWeight, maxWeight);\n        _setTimeWeight(updatedWeight.toUint32(), getGrowthRate(), true);\n    }\n\n    function _setTimeWeight(uint32 weight, uint32 growthRate, bool active) internal {\n        uint32 currentGrowth = getGrowthRate();\n\n        uint32 blockNo = block.number.toUint32();\n\n        timeWeightInfo = TimeWeightInfo(blockNo, weight, growthRate, active);\n\n        emit TimeWeightUpdate(weight, active);   \n        if (currentGrowth != growthRate) {\n            emit GrowthRateUpdate(growthRate);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/UniswapIncentive.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapIncentive.sol\";\nimport \"../utils/SafeMath32.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\n\n/// @title IUniswapIncentive implementation\n/// @author Fei Protocol\ncontract UniswapIncentive is IUniswapIncentive, UniRef {\n\tusing Decimal for Decimal.D256;\n    using SafeMath32 for uint32;\n    using SafeCast for uint;\n\n    struct TimeWeightInfo {\n        uint32 blockNo;\n        uint32 weight;\n        uint32 growthRate;\n        bool active;\n    }\n\n    TimeWeightInfo private timeWeightInfo;\n\n    uint32 public constant override TIME_WEIGHT_GRANULARITY = 100_000;\n\n    mapping(address => bool) private _exempt;\n\n    /// @notice UniswapIncentive constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle Oracle to reference\n    /// @param _pair Uniswap Pair to incentivize\n    /// @param _router Uniswap Router\n\tconstructor(\n        address _core, \n        address _oracle, \n        address _pair, \n        address _router,\n        uint32 _growthRate\n    ) public UniRef(_core, _pair, _router, _oracle) {\n        _setTimeWeight(0, _growthRate, false);    \n    }\n\n    function incentivize(\n    \taddress sender, \n    \taddress receiver, \n    \taddress, \n    \tuint amountIn\n    ) external override onlyFei {\n        updateOracle();\n\n    \tif (isPair(sender)) {\n    \t\tincentivizeBuy(receiver, amountIn);\n    \t}\n\n    \tif (isPair(receiver)) {\n    \t\tincentivizeSell(sender, amountIn);\n    \t}\n    }\n\n    function setExemptAddress(address account, bool isExempt) external override onlyGovernor {\n    \t_exempt[account] = isExempt;\n        emit ExemptAddressUpdate(account, isExempt);\n    }\n\n    function setTimeWeightGrowth(uint32 growthRate) external override onlyGovernor {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        timeWeightInfo = TimeWeightInfo(tw.blockNo, tw.weight, growthRate, tw.active);\n        emit GrowthRateUpdate(growthRate);\n    }\n\n    function setTimeWeight(uint32 weight, uint32 growth, bool active) external override onlyGovernor {\n        _setTimeWeight(weight, growth, active);\n        // TimeWeightInfo memory tw = timeWeightInfo;\n        // timeWeightInfo = TimeWeightInfo(blockNo, tw.weight, tw.growthRate, tw.active);\n    }\n\n    function getGrowthRate() public view override returns (uint32) {\n        return timeWeightInfo.growthRate;\n    }\n\n    function getTimeWeight() public view override returns (uint32) {\n        TimeWeightInfo memory tw = timeWeightInfo;\n        if (!tw.active) {\n            return 0;\n        }\n\n        uint32 blockDelta = block.number.toUint32().sub(tw.blockNo);\n        return tw.weight.add(blockDelta * tw.growthRate);\n    }\n\n    function isTimeWeightActive() public view override returns (bool) {\n    \treturn timeWeightInfo.active;\n    }\n\n    function isExemptAddress(address account) public view override returns (bool) {\n    \treturn _exempt[account];\n    }\n\n    function isIncentiveParity() public view override returns (bool) {\n        uint32 weight = getTimeWeight();\n        require(weight != 0, \"UniswapIncentive: Incentive zero or not active\");\n\n        (Decimal.D256 memory price,,) = getUniswapPrice();\n        Decimal.D256 memory deviation = calculateDeviation(price, peg());\n        require(!deviation.equals(Decimal.zero()), \"UniswapIncentive: Price already at or above peg\");\n\n        Decimal.D256 memory incentive = calculateBuyIncentiveMultiplier(deviation, weight);\n        Decimal.D256 memory penalty = calculateSellPenaltyMultiplier(deviation);\n        return incentive.equals(penalty);\n    }\n\n    function getBuyIncentive(uint amount) public view override returns(\n        uint incentive, \n        uint32 weight,\n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(-1 * int256(amount));\n        weight = getTimeWeight();\n\n        if (initialDeviation.equals(Decimal.zero())) {\n            return (0, weight, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (finalDeviation.equals(Decimal.zero())) {\n            incentivizedAmount = getAmountToPegFei();\n        }\n\n        Decimal.D256 memory multiplier = calculateBuyIncentiveMultiplier(initialDeviation, weight);\n        incentive = multiplier.mul(incentivizedAmount).asUint256();\n        return (incentive, weight, initialDeviation, finalDeviation);\n    }\n\n    function getSellPenalty(uint amount) public view override returns(\n        uint penalty, \n        Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation\n    ) {\n        (initialDeviation, finalDeviation) = getPriceDeviations(int256(amount));\n\n        if (finalDeviation.equals(Decimal.zero())) {\n            return (0, initialDeviation, finalDeviation);\n        }\n\n        uint incentivizedAmount = amount;\n        if (initialDeviation.equals(Decimal.zero())) {\n            uint amountToPeg = getAmountToPegFei();\n            require(amount >= amountToPeg, \"UniswapIncentive: Underflow\");\n            incentivizedAmount = amount - amountToPeg;\n        }\n\n        Decimal.D256 memory multiplier = calculateSellPenaltyMultiplier(finalDeviation); \n        penalty = multiplier.mul(incentivizedAmount).asUint256(); \n        return (penalty, initialDeviation, finalDeviation);   \n    }\n\n    function incentivizeBuy(address target, uint amountIn) internal ifMinterSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint incentive, uint32 weight,\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation) = getBuyIncentive(amountIn);\n\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n        if (incentive != 0) {\n            fei().mint(target, incentive);         \n        }\n    }\n\n    function incentivizeSell(address target, uint amount) internal ifBurnerSelf {\n    \tif (isExemptAddress(target)) {\n    \t\treturn;\n    \t}\n\n        (uint penalty, Decimal.D256 memory initialDeviation,\n        Decimal.D256 memory finalDeviation) = getSellPenalty(amount);\n\n        uint32 weight = getTimeWeight();\n        updateTimeWeight(initialDeviation, finalDeviation, weight);\n\n        if (penalty != 0) {\n            fei().burnFrom(target, penalty);\n        }\n    }\n\n    function calculateBuyIncentiveMultiplier(\n        Decimal.D256 memory deviation,\n        uint32 weight\n    ) internal pure returns (Decimal.D256 memory) {\n        Decimal.D256 memory correspondingPenalty = calculateSellPenaltyMultiplier(deviation);\n        Decimal.D256 memory buyMultiplier = deviation.mul(uint(weight)).div(uint(TIME_WEIGHT_GRANULARITY));\n        \n        if (correspondingPenalty.lessThan(buyMultiplier)) {\n            return correspondingPenalty;\n        }\n        \n        return buyMultiplier;\n    }\n\n    function calculateSellPenaltyMultiplier(\n        Decimal.D256 memory deviation\n    ) internal pure returns (Decimal.D256 memory) {\n        return deviation.mul(deviation).mul(100); // m^2 * 100\n    }\n\n    function updateTimeWeight (\n        Decimal.D256 memory initialDeviation, \n        Decimal.D256 memory finalDeviation, \n        uint32 currentWeight\n    ) internal {\n        // Reset after completion\n        if (finalDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), false);\n            return;\n        } \n        // Init\n        if (initialDeviation.equals(Decimal.zero())) {\n            _setTimeWeight(0, getGrowthRate(), true);\n            return;\n        }\n\n        uint updatedWeight = uint(currentWeight);\n        // Partial buy\n        if (initialDeviation.greaterThan(finalDeviation)) {\n            Decimal.D256 memory remainingRatio = finalDeviation.div(initialDeviation);\n            updatedWeight = remainingRatio.mul(uint(currentWeight)).asUint256();\n        }\n        \n        uint maxWeight = finalDeviation.mul(100).mul(uint(TIME_WEIGHT_GRANULARITY)).asUint256(); // m^2*100 (sell) = t*m (buy) \n        updatedWeight = Math.min(updatedWeight, maxWeight);\n        _setTimeWeight(updatedWeight.toUint32(), getGrowthRate(), true);\n    }\n\n    function _setTimeWeight(uint32 weight, uint32 growthRate, bool active) internal {\n        uint32 currentGrowth = getGrowthRate();\n\n        uint32 blockNo = block.number.toUint32();\n\n        timeWeightInfo = TimeWeightInfo(blockNo, weight, growthRate, active);\n\n        emit TimeWeightUpdate(weight, active);   \n        if (currentGrowth != growthRate) {\n            emit GrowthRateUpdate(growthRate);\n        }\n    }\n}"
    }
  ]
}