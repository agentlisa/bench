{
  "Title": "[G-30] Some operations which won't underflow may be unchecked",
  "Content": "\n**Files:** `GasBoundCaller.sol`, `SystemContext.sol`, `MsgValueSimulator.sol`\n\n[File: code/system-contracts/contracts/GasBoundCaller.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/GasBoundCaller.sol#L49)\n```solidity\n49:         uint256 pubdataAllowance = _maxTotalGas > expectedForCompute ? _maxTotalGas - expectedForCompute : 0;\n```\n\nSince `_maxTotalGas > expectedForCompute`, we know that `_maxTotalGas - expectedForCompute` won't underflow, thus it can be unchecked.\n\n[File: code/system-contracts/contracts/GasBoundCaller.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/GasBoundCaller.sol#L63)\n```solidity\n63:         uint256 pubdataSpent = pubdataPublishedAfter > pubdataPublishedBefore\n64:             ? pubdataPublishedAfter - pubdataPublishedBefore\n65:             : 0;\n```\n\nSince `pubdataPublishedAfter > pubdataPublishedBefore`, we know that `pubdataPublishedAfter - pubdataPublishedBefore` won't underflow, thus it can be unchecked.\n\n[File: code/system-contracts/contracts/SystemContext.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L119)\n```solidity\n119:         return pubdataPublished > basePubdataSpent ? pubdataPublished - basePubdataSpent : 0;\n```\nSince `pubdataPublished > basePubdataSpent`, we know that `pubdataPublished - basePubdataSpent` won't underflow, thus it can be unchecked.\n\n[File: code/system-contracts/contracts/MsgValueSimulator.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/MsgValueSimulator.sol#L53)\n```solidity\n53:         uint256 userGas = gasInContext > MSG_VALUE_SIMULATOR_STIPEND_GAS\n54:             ? gasInContext - MSG_VALUE_SIMULATOR_STIPEND_GAS\n55:             : 0;\n```\n\nSince `gasInContext > MSG_VALUE_SIMULATOR_STIPEND_GAS`, we know that `gasInContext - MSG_VALUE_SIMULATOR_STIPEND_GAS` won't underflow, thus it can be unchecked.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/GasBoundCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {REAL_SYSTEM_CONTEXT_CONTRACT} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The contract that allows to limit the final gas expenditure of the call.\n * @dev This contract MUST be deployed in the *user space*. It does not need any functionality that only\n * system contracts have and it can relay call to any contract, breaking potential trust in system contracts.\n */\ncontract GasBoundCaller {\n    /// @notice We assume that no more than `CALL_ENTRY_OVERHEAD` ergs are used for the O(1) operations at the start\n    /// of execution of the contract, such as abi decoding the parameters, jumping to the correct function, etc.\n    uint256 constant CALL_ENTRY_OVERHEAD = 800;\n    /// @notice We assume that no more than `CALL_RETURN_OVERHEAD` ergs are used for the O(1) operations at the end of the execution,\n    /// as such relaying the return.\n    uint256 constant CALL_RETURN_OVERHEAD = 200;\n\n    /// @notice The function that implements limiting of the total gas expenditure of the call.\n    /// @dev On Era, the gas for pubdata is charged at the end of the execution of the entire transaction, meaning\n    /// that if a subcall is not trusted, it can consume lots of pubdata in the process. This function ensures that\n    /// no more than  `_maxTotalGas` will be allowed to be spent by the call. To be sure, this function uses some margin\n    /// (`BOUND_CALL_OVERHEAD`) to ensure that the call will not exceed the limit, so it may actually spend a bit less than\n    /// `_maxTotalGas` in the end.\n    /// @dev The entire `gas` passed to this function could be used, regardless\n    /// of the `_maxTotalGas` parameter. In other words, `max(gas(), _maxTotalGas)` is the maximum amount of gas that can be spent by this function.\n    /// @dev The function relays the `returndata` returned by the callee. In case the `callee` reverts, it reverts with the same error.\n    /// @param _to The address of the contract to call.\n    /// @param _maxTotalGas The maximum amount of gas that can be spent by the call.\n    /// @param _data The calldata for the call.\n    function gasBoundCall(address _to, uint256 _maxTotalGas, bytes calldata _data) external payable {\n        // At the start of the execution we deduce how much gas be spent on things that will be\n        // paid for later on by the transaction.\n        // The `expectedForCompute` variable is an upper bound of how much this contract can spend on compute and\n        // MUST be higher or equal to the `gas` passed into the call.\n        uint256 expectedForCompute = gasleft() + CALL_ENTRY_OVERHEAD;\n\n        // We expect that the `_maxTotalGas` at least includes the `gas` required for the call.\n        // This require is more of a safety protection for the users that call this function with incorrect parameters.\n        //\n        // Ultimately, the entire `gas` sent to this call can be spent on compute regardless of the `_maxTotalGas` parameter.\n        require(_maxTotalGas >= gasleft(), \"Gas limit is too low\");\n\n        // This is the amount of gas that can be spent *exclusively* on pubdata in addition to the `gas` provided to this function.\n        uint256 pubdataAllowance = _maxTotalGas > expectedForCompute ? _maxTotalGas - expectedForCompute : 0;\n\n        uint256 pubdataPublishedBefore = REAL_SYSTEM_CONTEXT_CONTRACT.getCurrentPubdataSpent();\n\n        // We never permit system contract calls.\n        // If the call fails, the `EfficientCall.call` will propagate the revert.\n        // Since the revert is propagated, the pubdata published wouldn't change and so no\n        // other checks are needed.\n        bytes memory returnData = EfficientCall.call(gasleft(), _to, msg.value, _data, false);\n\n        uint256 pubdataPublishedAfter = REAL_SYSTEM_CONTEXT_CONTRACT.getCurrentPubdataSpent();\n\n        // It is possible that pubdataPublishedAfter < pubdataPublishedBefore if the call, e.g. removes\n        // some of the previously created state diffs\n        uint256 pubdataSpent = pubdataPublishedAfter > pubdataPublishedBefore\n            ? pubdataPublishedAfter - pubdataPublishedBefore\n            : 0;\n\n        uint256 pubdataPrice = REAL_SYSTEM_CONTEXT_CONTRACT.gasPerPubdataByte();\n\n        // In case there is an overflow here, the `_maxTotalGas` wouldbn't be able to cover it anyway, so\n        // we don't mind the contract panicking here in case of it.\n        uint256 pubdataCost = pubdataPrice * pubdataSpent;\n\n        if (pubdataCost != 0) {\n            // Here we double check that the additional cost is not higher than the maximum allowed.\n            // Note, that the `gasleft()` can be spent on pubdata too.\n            require(pubdataAllowance + gasleft() >= pubdataCost + CALL_RETURN_OVERHEAD, \"Not enough gas for pubdata\");\n        }\n\n        assembly {\n            // We just relay the return data from the call.\n            return(add(returnData, 0x20), mload(returnData))\n        }\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/GasBoundCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {REAL_SYSTEM_CONTEXT_CONTRACT} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The contract that allows to limit the final gas expenditure of the call.\n * @dev This contract MUST be deployed in the *user space*. It does not need any functionality that only\n * system contracts have and it can relay call to any contract, breaking potential trust in system contracts.\n */\ncontract GasBoundCaller {\n    /// @notice We assume that no more than `CALL_ENTRY_OVERHEAD` ergs are used for the O(1) operations at the start\n    /// of execution of the contract, such as abi decoding the parameters, jumping to the correct function, etc.\n    uint256 constant CALL_ENTRY_OVERHEAD = 800;\n    /// @notice We assume that no more than `CALL_RETURN_OVERHEAD` ergs are used for the O(1) operations at the end of the execution,\n    /// as such relaying the return.\n    uint256 constant CALL_RETURN_OVERHEAD = 200;\n\n    /// @notice The function that implements limiting of the total gas expenditure of the call.\n    /// @dev On Era, the gas for pubdata is charged at the end of the execution of the entire transaction, meaning\n    /// that if a subcall is not trusted, it can consume lots of pubdata in the process. This function ensures that\n    /// no more than  `_maxTotalGas` will be allowed to be spent by the call. To be sure, this function uses some margin\n    /// (`BOUND_CALL_OVERHEAD`) to ensure that the call will not exceed the limit, so it may actually spend a bit less than\n    /// `_maxTotalGas` in the end.\n    /// @dev The entire `gas` passed to this function could be used, regardless\n    /// of the `_maxTotalGas` parameter. In other words, `max(gas(), _maxTotalGas)` is the maximum amount of gas that can be spent by this function.\n    /// @dev The function relays the `returndata` returned by the callee. In case the `callee` reverts, it reverts with the same error.\n    /// @param _to The address of the contract to call.\n    /// @param _maxTotalGas The maximum amount of gas that can be spent by the call.\n    /// @param _data The calldata for the call.\n    function gasBoundCall(address _to, uint256 _maxTotalGas, bytes calldata _data) external payable {\n        // At the start of the execution we deduce how much gas be spent on things that will be\n        // paid for later on by the transaction.\n        // The `expectedForCompute` variable is an upper bound of how much this contract can spend on compute and\n        // MUST be higher or equal to the `gas` passed into the call.\n        uint256 expectedForCompute = gasleft() + CALL_ENTRY_OVERHEAD;\n\n        // We expect that the `_maxTotalGas` at least includes the `gas` required for the call.\n        // This require is more of a safety protection for the users that call this function with incorrect parameters.\n        //\n        // Ultimately, the entire `gas` sent to this call can be spent on compute regardless of the `_maxTotalGas` parameter.\n        require(_maxTotalGas >= gasleft(), \"Gas limit is too low\");\n\n        // This is the amount of gas that can be spent *exclusively* on pubdata in addition to the `gas` provided to this function.\n        uint256 pubdataAllowance = _maxTotalGas > expectedForCompute ? _maxTotalGas - expectedForCompute : 0;\n\n        uint256 pubdataPublishedBefore = REAL_SYSTEM_CONTEXT_CONTRACT.getCurrentPubdataSpent();\n\n        // We never permit system contract calls.\n        // If the call fails, the `EfficientCall.call` will propagate the revert.\n        // Since the revert is propagated, the pubdata published wouldn't change and so no\n        // other checks are needed.\n        bytes memory returnData = EfficientCall.call(gasleft(), _to, msg.value, _data, false);\n\n        uint256 pubdataPublishedAfter = REAL_SYSTEM_CONTEXT_CONTRACT.getCurrentPubdataSpent();\n\n        // It is possible that pubdataPublishedAfter < pubdataPublishedBefore if the call, e.g. removes\n        // some of the previously created state diffs\n        uint256 pubdataSpent = pubdataPublishedAfter > pubdataPublishedBefore\n            ? pubdataPublishedAfter - pubdataPublishedBefore\n            : 0;\n\n        uint256 pubdataPrice = REAL_SYSTEM_CONTEXT_CONTRACT.gasPerPubdataByte();\n\n        // In case there is an overflow here, the `_maxTotalGas` wouldbn't be able to cover it anyway, so\n        // we don't mind the contract panicking here in case of it.\n        uint256 pubdataCost = pubdataPrice * pubdataSpent;\n\n        if (pubdataCost != 0) {\n            // Here we double check that the additional cost is not higher than the maximum allowed.\n            // Note, that the `gasleft()` can be spent on pubdata too.\n            require(pubdataAllowance + gasleft() >= pubdataCost + CALL_RETURN_OVERHEAD, \"Not enough gas for pubdata\");\n        }\n\n        assembly {\n            // We just relay the return data from the call.\n            return(add(returnData, 0x20), mload(returnData))\n        }\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/SystemContext.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {ISystemContextDeprecated} from \"./interfaces/ISystemContextDeprecated.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, SystemLogKey} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Contract that stores some of the context variables, that may be either\n * block-scoped, tx-scoped or system-wide.\n */\ncontract SystemContext is ISystemContext, ISystemContextDeprecated, ISystemContract {\n    /// @notice The number of latest L2 blocks to store.\n    /// @dev EVM requires us to be able to query the hashes of previous 256 blocks.\n    /// We could either:\n    /// - Store the latest 256 hashes (and strictly rely that we do not accidentally override the hash of the block 256 blocks ago)\n    /// - Store the latest 257 blocks' hashes.\n    uint256 internal constant MINIBLOCK_HASHES_TO_STORE = 257;\n\n    /// @notice The chainId of the network. It is set at the genesis.\n    uint256 public chainId;\n\n    /// @notice The `tx.origin` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    address public origin;\n\n    /// @notice The `tx.gasPrice` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    uint256 public gasPrice;\n\n    /// @notice The current block's gasLimit.\n    uint256 public blockGasLimit = type(uint32).max;\n\n    /// @notice The `block.coinbase` in the current transaction.\n    /// @dev For the support of coinbase, we will use the bootloader formal address for now\n    address public coinbase = BOOTLOADER_FORMAL_ADDRESS;\n\n    /// @notice Formal `block.difficulty` parameter.\n    uint256 public difficulty = 2.5e15;\n\n    /// @notice The `block.basefee`.\n    /// @dev It is currently a constant.\n    uint256 public baseFee;\n\n    /// @notice The number and the timestamp of the current L1 batch stored packed.\n    BlockInfo internal currentBatchInfo;\n\n    /// @notice The hashes of batches.\n    /// @dev It stores batch hashes for all previous batches.\n    mapping(uint256 batchNumber => bytes32 batchHash) internal batchHashes;\n\n    /// @notice The number and the timestamp of the current L2 block.\n    BlockInfo internal currentL2BlockInfo;\n\n    /// @notice The rolling hash of the transactions in the current L2 block.\n    bytes32 internal currentL2BlockTxsRollingHash;\n\n    /// @notice The hashes of L2 blocks.\n    /// @dev It stores block hashes for previous L2 blocks. Note, in order to make publishing the hashes\n    /// of the miniblocks cheaper, we only store the previous MINIBLOCK_HASHES_TO_STORE ones. Since whenever we need to publish a state\n    /// diff, a pair of <key, value> is published and for cached keys only 8-byte id is used instead of 32 bytes.\n    /// By having this data in a cyclic array of MINIBLOCK_HASHES_TO_STORE blocks, we bring the costs down by 40% (i.e. 40 bytes per miniblock instead of 64 bytes).\n    /// @dev The hash of a miniblock with number N would be stored under slot N%MINIBLOCK_HASHES_TO_STORE.\n    /// @dev Hashes of the blocks older than the ones which are stored here can be calculated as _calculateLegacyL2BlockHash(blockNumber).\n    bytes32[MINIBLOCK_HASHES_TO_STORE] internal l2BlockHash;\n\n    /// @notice To make migration to L2 blocks smoother, we introduce a temporary concept of virtual L2 blocks, the data\n    /// about which will be returned by the EVM-like methods: block.number/block.timestamp/blockhash.\n    /// - Their number will start from being equal to the number of the batch and it will increase until it reaches the L2 block number.\n    /// - Their timestamp is updated each time a new virtual block is created.\n    /// - Their hash is calculated as `keccak256(uint256(number))`\n    BlockInfo internal currentVirtualL2BlockInfo;\n\n    /// @notice The information about the virtual blocks upgrade, which tracks when the migration to the L2 blocks has started and finished.\n    VirtualBlockUpgradeInfo internal virtualBlockUpgradeInfo;\n\n    /// @notice Set the chainId origin.\n    /// @param _newChainId The chainId\n    function setChainId(uint256 _newChainId) external onlyCallFromForceDeployer {\n        chainId = _newChainId;\n    }\n\n    /// @notice Number of current transaction in block.\n    uint16 public txNumberInBlock;\n\n    /// @notice The current gas per pubdata byte\n    uint256 public gasPerPubdataByte;\n\n    /// @notice The number of pubdata spent as of the start of the transaction\n    uint256 internal basePubdataSpent;\n\n    /// @notice Set the current tx origin.\n    /// @param _newOrigin The new tx origin.\n    function setTxOrigin(address _newOrigin) external onlyCallFromBootloader {\n        origin = _newOrigin;\n    }\n\n    /// @notice Set the the current gas price.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyCallFromBootloader {\n        gasPrice = _gasPrice;\n    }\n\n    /// @notice Sets the number of L2 gas that is needed to pay a single byte of pubdata.\n    /// @dev This value does not have any impact on the execution and purely serves as a way for users\n    /// to access the current gas price for the pubdata.\n    function setPubdataInfo(uint256 _gasPerPubdataByte, uint256 _basePubdataSpent) external onlyCallFromBootloader {\n        basePubdataSpent = _basePubdataSpent;\n        gasPerPubdataByte = _gasPerPubdataByte;\n    }\n\n    function getCurrentPubdataSpent() public view returns (uint256) {\n        uint256 pubdataPublished = SystemContractHelper.getZkSyncMeta().pubdataPublished;\n        return pubdataPublished > basePubdataSpent ? pubdataPublished - basePubdataSpent : 0;\n    }\n\n    function getCurrentPubdataCost() external view returns (uint256) {\n        return gasPerPubdataByte * getCurrentPubdataSpent();\n    }\n\n    /// @notice The method that emulates `blockhash` opcode in EVM.\n    /// @dev Just like the blockhash in the EVM, it returns bytes32(0),\n    /// when queried about hashes that are older than 256 blocks ago.\n    /// @dev Since zksolc compiler calls this method to emulate `blockhash`,\n    /// its signature can not be changed to `getL2BlockHashEVM`.\n    /// @return hash The blockhash of the block with the given number.\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32 hash) {\n        uint128 blockNumber = currentVirtualL2BlockInfo.number;\n\n        VirtualBlockUpgradeInfo memory currentVirtualBlockUpgradeInfo = virtualBlockUpgradeInfo;\n\n        // Due to virtual blocks upgrade, we'll have to use the following logic for retreiving the blockhash:\n        // 1. If the block number is out of the 256-block supported range, return 0.\n        // 2. If the block was created before the upgrade for the virtual blocks (i.e. there we used to use hashes of the batches),\n        // we return the hash of the batch.\n        // 3. If the block was created after the day when the virtual blocks have caught up with the L2 blocks, i.e.\n        // all the information which is returned for users should be for L2 blocks, we return the hash of the corresponding L2 block.\n        // 4. If the block queried is a virtual blocks, calculate it on the fly.\n        if (blockNumber <= _block || blockNumber - _block > 256) {\n            hash = bytes32(0);\n        } else if (_block < currentVirtualBlockUpgradeInfo.virtualBlockStartBatch) {\n            // Note, that we will get into this branch only for a brief moment of time, right after the upgrade\n            // for virtual blocks before 256 virtual blocks are produced.\n            hash = batchHashes[_block];\n        } else if (\n            _block >= currentVirtualBlockUpgradeInfo.virtualBlockFinishL2Block &&\n            currentVirtualBlockUpgradeInfo.virtualBlockFinishL2Block > 0\n        ) {\n            hash = _getLatest257L2blockHash(_block);\n        } else {\n            // Important: we do not want this number to ever collide with the L2 block hash (either new or old one) and so\n            // that's why the legacy L2 blocks' hashes are keccak256(abi.encodePacked(uint32(_block))), while these are equivalent to\n            // keccak256(abi.encodePacked(_block))\n            hash = keccak256(abi.encode(_block));\n        }\n    }\n\n    /// @notice Returns the hash of the given batch.\n    /// @param _batchNumber The number of the batch.\n    /// @return hash The hash of the batch.\n    function getBatchHash(uint256 _batchNumber) external view returns (bytes32 hash) {\n        hash = batchHashes[_batchNumber];\n    }\n\n    /// @notice Returns the current batch's number and timestamp.\n    /// @return batchNumber and batchTimestamp tuple of the current batch's number and the current batch's timestamp\n    function getBatchNumberAndTimestamp() public view returns (uint128 batchNumber, uint128 batchTimestamp) {\n        BlockInfo memory batchInfo = currentBatchInfo;\n        batchNumber = batchInfo.number;\n        batchTimestamp = batchInfo.timestamp;\n    }\n\n    /// @notice Returns the current block's number and timestamp.\n    /// @return blockNumber and blockTimestamp tuple of the current L2 block's number and the current block's timestamp\n    function getL2BlockNumberAndTimestamp() public view returns (uint128 blockNumber, uint128 blockTimestamp) {\n        BlockInfo memory blockInfo = currentL2BlockInfo;\n        blockNumber = blockInfo.number;\n        blockTimestamp = blockInfo.timestamp;\n    }\n\n    /// @notice Returns the current L2 block's number.\n    /// @dev Since zksolc compiler calls this method to emulate `block.number`,\n    /// its signature can not be changed to `getL2BlockNumber`.\n    /// @return blockNumber The current L2 block's number.\n    function getBlockNumber() public view returns (uint128) {\n        return currentVirtualL2BlockInfo.number;\n    }\n\n    /// @notice Returns the current L2 block's timestamp.\n    /// @dev Since zksolc compiler calls this method to emulate `block.timestamp`,\n    /// its signature can not be changed to `getL2BlockTimestamp`.\n    /// @return timestamp The current L2 block's timestamp.\n    function getBlockTimestamp() public view returns (uint128) {\n        return currentVirtualL2BlockInfo.timestamp;\n    }\n\n    /// @notice Assuming that block is one of the last MINIBLOCK_HASHES_TO_STORE ones, returns its hash.\n    /// @param _block The number of the block.\n    /// @return hash The hash of the block.\n    function _getLatest257L2blockHash(uint256 _block) internal view returns (bytes32) {\n        return l2BlockHash[_block % MINIBLOCK_HASHES_TO_STORE];\n    }\n\n    /// @notice Assuming that the block is one of the last MINIBLOCK_HASHES_TO_STORE ones, sets its hash.\n    /// @param _block The number of the block.\n    /// @param _hash The hash of the block.\n    function _setL2BlockHash(uint256 _block, bytes32 _hash) internal {\n        l2BlockHash[_block % MINIBLOCK_HASHES_TO_STORE] = _hash;\n    }\n\n    /// @notice Calculates the hash of an L2 block.\n    /// @param _blockNumber The number of the L2 block.\n    /// @param _blockTimestamp The timestamp of the L2 block.\n    /// @param _prevL2BlockHash The hash of the previous L2 block.\n    /// @param _blockTxsRollingHash The rolling hash of the transactions in the L2 block.\n    function _calculateL2BlockHash(\n        uint128 _blockNumber,\n        uint128 _blockTimestamp,\n        bytes32 _prevL2BlockHash,\n        bytes32 _blockTxsRollingHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_blockNumber, _blockTimestamp, _prevL2BlockHash, _blockTxsRollingHash));\n    }\n\n    /// @notice Calculates the legacy block hash of L2 block, which were used before the upgrade where\n    /// the advanced block hashes were introduced.\n    /// @param _blockNumber The number of the L2 block.\n    function _calculateLegacyL2BlockHash(uint128 _blockNumber) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(uint32(_blockNumber)));\n    }\n\n    /// @notice Performs the upgrade where we transition to the L2 blocks.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _expectedPrevL2BlockHash The expected hash of the previous L2 block.\n    /// @param _isFirstInBatch Whether this method is called for the first time in the batch.\n    function _upgradeL2Blocks(uint128 _l2BlockNumber, bytes32 _expectedPrevL2BlockHash, bool _isFirstInBatch) internal {\n        require(_isFirstInBatch, \"Upgrade transaction must be first\");\n\n        // This is how it will be commonly done in practice, but it will simplify some logic later\n        require(_l2BlockNumber > 0, \"L2 block number is never expected to be zero\");\n\n        unchecked {\n            bytes32 correctPrevBlockHash = _calculateLegacyL2BlockHash(_l2BlockNumber - 1);\n            require(correctPrevBlockHash == _expectedPrevL2BlockHash, \"The previous L2 block hash is incorrect\");\n\n            // Whenever we'll be queried about the hashes of the blocks before the upgrade,\n            // we'll use batches' hashes, so we don't need to store 256 previous hashes.\n            // However, we do need to store the last previous hash in order to be able to correctly calculate the\n            // hash of the new L2 block.\n            _setL2BlockHash(_l2BlockNumber - 1, correctPrevBlockHash);\n        }\n    }\n\n    /// @notice Creates new virtual blocks, while ensuring they don't exceed the L2 block number.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _maxVirtualBlocksToCreate The maximum number of virtual blocks to create with this L2 block.\n    /// @param _newTimestamp The timestamp of the new L2 block, which is also the timestamp of the new virtual block.\n    function _setVirtualBlock(\n        uint128 _l2BlockNumber,\n        uint128 _maxVirtualBlocksToCreate,\n        uint128 _newTimestamp\n    ) internal {\n        if (virtualBlockUpgradeInfo.virtualBlockFinishL2Block != 0) {\n            // No need to to do anything about virtual blocks anymore\n            // All the info is the same as for L2 blocks.\n            currentVirtualL2BlockInfo = currentL2BlockInfo;\n            return;\n        }\n\n        BlockInfo memory virtualBlockInfo = currentVirtualL2BlockInfo;\n\n        if (currentVirtualL2BlockInfo.number == 0 && virtualBlockInfo.timestamp == 0) {\n            uint128 currentBatchNumber = currentBatchInfo.number;\n\n            // The virtual block is set for the first time. We can count it as 1 creation of a virtual block.\n            // Note, that when setting the virtual block number we use the batch number to make a smoother upgrade from batch number to\n            // the L2 block number.\n            virtualBlockInfo.number = currentBatchNumber;\n            // Remembering the batch number on which the upgrade to the virtual blocks has been done.\n            virtualBlockUpgradeInfo.virtualBlockStartBatch = currentBatchNumber;\n\n            require(_maxVirtualBlocksToCreate > 0, \"Can't initialize the first virtual block\");\n            _maxVirtualBlocksToCreate -= 1;\n        } else if (_maxVirtualBlocksToCreate == 0) {\n            // The virtual blocks have been already initialized, but the operator didn't ask to create\n            // any new virtual blocks. So we can just return.\n            return;\n        }\n\n        virtualBlockInfo.number += _maxVirtualBlocksToCreate;\n        virtualBlockInfo.timestamp = _newTimestamp;\n\n        // The virtual block number must never exceed the L2 block number.\n        // We do not use a `require` here, since the virtual blocks are a temporary solution to let the Solidity's `block.number`\n        // catch up with the L2 block number and so the situation where virtualBlockInfo.number starts getting larger\n        // than _l2BlockNumber is expected once virtual blocks have caught up the L2 blocks.\n        if (virtualBlockInfo.number >= _l2BlockNumber) {\n            virtualBlockUpgradeInfo.virtualBlockFinishL2Block = _l2BlockNumber;\n            virtualBlockInfo.number = _l2BlockNumber;\n        }\n\n        currentVirtualL2BlockInfo = virtualBlockInfo;\n    }\n\n    /// @notice Sets the current block number and timestamp of the L2 block.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _l2BlockTimestamp The timestamp of the new L2 block.\n    /// @param _prevL2BlockHash The hash of the previous L2 block.\n    function _setNewL2BlockData(uint128 _l2BlockNumber, uint128 _l2BlockTimestamp, bytes32 _prevL2BlockHash) internal {\n        // In the unsafe version we do not check that the block data is correct\n        currentL2BlockInfo = BlockInfo({number: _l2BlockNumber, timestamp: _l2BlockTimestamp});\n\n        // It is always assumed in production that _l2BlockNumber > 0\n        _setL2BlockHash(_l2BlockNumber - 1, _prevL2BlockHash);\n\n        // Reseting the rolling hash\n        currentL2BlockTxsRollingHash = bytes32(0);\n    }\n\n    /// @notice Sets the current block number and timestamp of the L2 block.\n    /// @dev Called by the bootloader before each transaction. This is needed to ensure\n    /// that the data about the block is consistent with the sequencer.\n    /// @dev If the new block number is the same as the current one, we ensure that the block's data is\n    /// consistent with the one in the current block.\n    /// @dev If the new block number is greater than the current one by 1,\n    /// then we ensure that timestamp has increased.\n    /// @dev If the currently stored number is 0, we assume that it is the first upgrade transaction\n    /// and so we will fill up the old data.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _l2BlockTimestamp The timestamp of the new L2 block.\n    /// @param _expectedPrevL2BlockHash The expected hash of the previous L2 block.\n    /// @param _isFirstInBatch Whether this method is called for the first time in the batch.\n    /// @param _maxVirtualBlocksToCreate The maximum number of virtual block to create with this L2 block.\n    /// @dev It is a strict requirement that a new virtual block is created at the start of the batch.\n    /// @dev It is also enforced that the number of the current virtual L2 block can not exceed the number of the L2 block.\n    function setL2Block(\n        uint128 _l2BlockNumber,\n        uint128 _l2BlockTimestamp,\n        bytes32 _expectedPrevL2BlockHash,\n        bool _isFirstInBatch,\n        uint128 _maxVirtualBlocksToCreate\n    ) external onlyCallFromBootloader {\n        // We check that the timestamp of the L2 block is consistent with the timestamp of the batch.\n        if (_isFirstInBatch) {\n            uint128 currentBatchTimestamp = currentBatchInfo.timestamp;\n            require(\n                _l2BlockTimestamp >= currentBatchTimestamp,\n                \"The timestamp of the L2 block must be greater than or equal to the timestamp of the current batch\"\n            );\n            require(_maxVirtualBlocksToCreate > 0, \"There must be a virtual block created at the start of the batch\");\n        }\n\n        (uint128 currentL2BlockNumber, uint128 currentL2BlockTimestamp) = getL2BlockNumberAndTimestamp();\n\n        if (currentL2BlockNumber == 0 && currentL2BlockTimestamp == 0) {\n            // Since currentL2BlockNumber and currentL2BlockTimestamp are zero it means that it is\n            // the first ever batch with L2 blocks, so we need to initialize those.\n            _upgradeL2Blocks(_l2BlockNumber, _expectedPrevL2BlockHash, _isFirstInBatch);\n\n            _setNewL2BlockData(_l2BlockNumber, _l2BlockTimestamp, _expectedPrevL2BlockHash);\n        } else if (currentL2BlockNumber == _l2BlockNumber) {\n            require(!_isFirstInBatch, \"Can not reuse L2 block number from the previous batch\");\n            require(currentL2BlockTimestamp == _l2BlockTimestamp, \"The timestamp of the same L2 block must be same\");\n            require(\n                _expectedPrevL2BlockHash == _getLatest257L2blockHash(_l2BlockNumber - 1),\n                \"The previous hash of the same L2 block must be same\"\n            );\n            require(_maxVirtualBlocksToCreate == 0, \"Can not create virtual blocks in the middle of the miniblock\");\n        } else if (currentL2BlockNumber + 1 == _l2BlockNumber) {\n            // From the checks in _upgradeL2Blocks it is known that currentL2BlockNumber can not be 0\n            bytes32 prevL2BlockHash = _getLatest257L2blockHash(currentL2BlockNumber - 1);\n\n            bytes32 pendingL2BlockHash = _calculateL2BlockHash(\n                currentL2BlockNumber,\n                currentL2BlockTimestamp,\n                prevL2BlockHash,\n                currentL2BlockTxsRollingHash\n            );\n\n            require(_expectedPrevL2BlockHash == pendingL2BlockHash, \"The current L2 block hash is incorrect\");\n            require(\n                _l2BlockTimestamp > currentL2BlockTimestamp,\n                \"The timestamp of the new L2 block must be greater than the timestamp of the previous L2 block\"\n            );\n\n            // Since the new block is created, we'll clear out the rolling hash\n            _setNewL2BlockData(_l2BlockNumber, _l2BlockTimestamp, _expectedPrevL2BlockHash);\n        } else {\n            revert(\"Invalid new L2 block number\");\n        }\n\n        _setVirtualBlock(_l2BlockNumber, _maxVirtualBlocksToCreate, _l2BlockTimestamp);\n    }\n\n    /// @notice Appends the transaction hash to the rolling hash of the current L2 block.\n    /// @param _txHash The hash of the transaction.\n    function appendTransactionToCurrentL2Block(bytes32 _txHash) external onlyCallFromBootloader {\n        currentL2BlockTxsRollingHash = keccak256(abi.encode(currentL2BlockTxsRollingHash, _txHash));\n    }\n\n    /// @notice Publishes L2->L1 logs needed to verify the validity of this batch on L1.\n    /// @dev Should be called at the end of the current batch.\n    function publishTimestampDataToL1() external onlyCallFromBootloader {\n        (uint128 currentBatchNumber, uint128 currentBatchTimestamp) = getBatchNumberAndTimestamp();\n        (, uint128 currentL2BlockTimestamp) = getL2BlockNumberAndTimestamp();\n\n        // The structure of the \"setNewBatch\" implies that currentBatchNumber > 0, but we still double check it\n        require(currentBatchNumber > 0, \"The current batch number must be greater than 0\");\n\n        // In order to spend less pubdata, the packe"
    }
  ]
}