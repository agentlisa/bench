{
  "Title": "[M-01] `AnyswapFacet` can be exploited to approve arbitrary tokens.",
  "Content": "\n[AnyswapFacet.sol#L35-L53](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Facets/AnyswapFacet.sol#L35-L53)<br>\n\nIn `AnyswapFacet.sol` we parse arbitrary data in `_anyswapData` allowing an attacker to drain funds (ERC20 or native tokens) from the LiFi contract.\n\nFunctions effected:\n\n*   `AnyswapFacet.startBridgeTokensViaAnyswap()`\n*   `AnyswapFacet.swapAndStartBridgeTokensViaAnyswap()`\n\n### Proof of Concept\n\nThis attack works in `AnyswapFacet.startBridgeTokensViaAnyswap()` by having a malicious `_anyswapData.token` which may change the value return in `IAnyswapToken(_anyswapData.token).underlying();`.\n\nFirst we have the first call to `IAnyswapToken(_anyswapData.token).underlying();` return a malicious ERC20 contract in the attackers control. This allows for transferring these malicious ERC20 tokens to pass the required balance checks.\n\n                uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n                LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n                require(\n                    LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                    \"ERR_INVALID_AMOUNT\"\n                );\n\nThe function will then call `_startBridge()` which again does `address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();` we have the malicious `_anyswapData.token` return a different address, one which the LiFi contract has balance for (a native token or ERC20).\n\nWe will therefore execute the following which will either approve or transfer funds to `_anyswapData.router` for a different `underlyingtoken` to the one which supplied the funds to LiFi.\n\n            address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n            if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n                IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.toChainId\n                );\n                return;\n            }\n\n            if (_anyswapData.token != address(0)) {\n                // Has underlying token?\n                if (underlyingToken != address(0)) {\n                    // Give Anyswap approval to bridge tokens\n                    LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n                    IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                        _anyswapData.token,\n                        _anyswapData.recipient,\n                        _anyswapData.amount,\n                        _anyswapData.toChainId\n                    );\n                } else {\n                    // Give Anyswap approval to bridge tokens\n                    LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n                    IAnyswapRouter(_anyswapData.router).anySwapOut(\n                        _anyswapData.token,\n                        _anyswapData.recipient,\n                        _anyswapData.amount,\n                        _anyswapData.toChainId\n                    );\n                }\n            }\n        }\n\nSince `_anyswapData.router` is an address in the attackers control they either are transferred native tokens or they have an allowance of ERC20 tokens that they can spend arbitrarily.\n\nThe attack is almost identical in `swapAndStartBridgeTokensViaAnyswap()`\n\n### Recommended Mitigation Steps\n\nConsider whitelisting both Anyswap tokens and Anyswap routers (using two distinct whitelists) restricting the attackers ability to use malicious contracts for this attack.\n\nConsider also only calling `IAnyswapToken(_anyswapData.token).underlying()` once and passing this value to `_startBridge()`.\n\n**[H3xept (Li.Fi) disagreed with High severity, but resolved and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/117#issuecomment-1096468398):**\n > We fixed the issue by not allowing underlying() to be called multiple times in one transaction (lifinance/lifi-contracts@a8d6336c2ded97bdbca65b64157596b33f18f70d)\n> \n> We disagree with the severity as no funds should ever be left in the contract by design.\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/117#issuecomment-1100696054):**\n > Keeping this as Med Risk. There can be fund leftover in the contract under normal operation, for example [this tx](https://etherscan.io/tx/0xe78c36dd2c2f21cade00a4099701b9c9f82acc8da568e1048a4d7287ce2e45b0). In fact, ~\\$300 worth of token is left in the LI.Fi smart contract on ETH mainnet [0x5a9fd7c39a6c488e715437d7b1f3c823d5596ed1](https://etherscan.io/address/0x5a9fd7c39a6c488e715437d7b1f3c823d5596ed1) as of block 14597316. I don't think this is High Risk because the max amount lost is no more than allowed slippage, which can be loss to MEV too.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/AnyswapFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Anyswap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n */\ncontract AnyswapFacet is ILiFi, Swapper {\n    /* ========== Types ========== */\n\n    struct AnyswapData {\n        address token;\n        address router;\n        uint256 amount;\n        address recipient;\n        uint256 toChainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _anyswapData data specific to Anyswap\n     */\n    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n            require(\n                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _anyswapData data specific to Anyswap\n     */\n    function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Anyswap\n     * @param _anyswapData data specific to Anyswap\n     */\n    function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n            return;\n        }\n\n        if (_anyswapData.token != address(0)) {\n            // Has underlying token?\n            if (underlyingToken != address(0)) {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            } else {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOut(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            }\n        }\n    }\n}"
    }
  ]
}