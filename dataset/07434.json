{
  "Title": "[M-11] MultisigManager may not be able to add a valid Multisig",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MultisigManager.sol#L41-L43\n\n\n# Vulnerability details\n\n## Impact\nWhen more than 10 mulitsig, it is impossible to modify or delete the old ones, making it impossible to create new valid ones.\n\n## Proof of Concept\n\nMultisigManager limits the number of Multisig to 10, which cannot be deleted or replaced after they have been disable\nThis will have a problem, if the subsequent use of 10, all 10 for some reason, be disabled\nThen it is impossible to add new ones and replace the old ones, so you have to continue using the old Multisig at risk\n\n```solidity\n    function registerMultisig(address addr) external onlyGuardian {\n        int256 multisigIndex = getIndexOf(addr);\n        if (multisigIndex != -1) {\n            revert MultisigAlreadyRegistered();\n        }\n        uint256 index = getUint(keccak256(\"multisig.count\"));\n        if (index >= MULTISIG_LIMIT) {\n            revert MultisigLimitReached(); //***@audit limt 10, and no other way to delete or replace the old Multisig ***//\n        }\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\nadd replace old mulitsig method\n\n```solidity\n    function replaceMultisig(address addr,address oldAddr) external onlyGuardian {\n        int256 multisigIndex = getIndexOf(oldAddr);\n        if (multisigIndex == -1) {\n            revert MultisigNotFound();\n        }\n\n        setAddress(keccak256(abi.encodePacked(\"multisig.item\", multisigIndex, \".address\")), addr);\n        emit RegisteredMultisig(addr, msg.sender);\n    }\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/MultisigManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {Storage} from \"./Storage.sol\";\n\n/*\n\tData Storage Schema\n\tmultisig.count = Starts at 0 and counts up by 1 after an addr is added.\n\n\tmultisig.index<address> = <index> + 1 of multisigAddress\n\tmultisig.item<index>.address = C-chain address used as primary key\n\tmultisig.item<index>.enabled = bool\n*/\n\n/// @title Multisig address creation and management for the protocol\ncontract MultisigManager is Base {\n\terror MultisigAlreadyRegistered();\n\terror MultisigNotFound();\n\terror MultisigLimitReached();\n\terror NoEnabledMultisigFound();\n\n\tevent DisabledMultisig(address indexed multisig, address actor);\n\tevent EnabledMultisig(address indexed multisig, address actor);\n\tevent RegisteredMultisig(address indexed multisig, address actor);\n\n\tuint256 public constant MULTISIG_LIMIT = 10;\n\n\tconstructor(Storage storageAddress) Base(storageAddress) {\n\t\tversion = 1;\n\t}\n\n\t/// @notice Register a multisig. Defaults to disabled when first registered.\n\t/// @param addr Address of the multisig that is being registered\n\tfunction registerMultisig(address addr) external onlyGuardian {\n\t\tint256 multisigIndex = getIndexOf(addr);\n\t\tif (multisigIndex != -1) {\n\t\t\trevert MultisigAlreadyRegistered();\n\t\t}\n\t\tuint256 index = getUint(keccak256(\"multisig.count\"));\n\t\tif (index >= MULTISIG_LIMIT) {\n\t\t\trevert MultisigLimitReached();\n\t\t}\n\n\t\tsetAddress(keccak256(abi.encodePacked(\"multisig.item\", index, \".address\")), addr);\n\n\t\t// The index is stored 1 greater than the actual value. The 1 is subtracted in getIndexOf().\n\t\tsetUint(keccak256(abi.encodePacked(\"multisig.index\", addr)), index + 1);\n\t\taddUint(keccak256(\"multisig.count\"), 1);\n\t\temit RegisteredMultisig(addr, msg.sender);\n\t}\n\n\t/// @notice Enabling a registered multisig\n\t/// @param addr Address of the multisig that is being enabled\n\tfunction enableMultisig(address addr) external onlyGuardian {\n\t\tint256 multisigIndex = getIndexOf(addr);\n\t\tif (multisigIndex == -1) {\n\t\t\trevert MultisigNotFound();\n\t\t}\n\n\t\tsetBool(keccak256(abi.encodePacked(\"multisig.item\", multisigIndex, \".enabled\")), true);\n\t\temit EnabledMultisig(addr, msg.sender);\n\t}\n\n\t/// @notice Disabling a registered multisig\n\t/// @param addr Address of the multisig that is being disabled\n\t/// @dev this will prevent the multisig from completing validations. The minipool will need to be manually reassigned to a new multisig\n\tfunction disableMultisig(address addr) external guardianOrSpecificRegisteredContract(\"Ocyticus\", msg.sender) {\n\t\tint256 multisigIndex = getIndexOf(addr);\n\t\tif (multisigIndex == -1) {\n\t\t\trevert MultisigNotFound();\n\t\t}\n\n\t\tsetBool(keccak256(abi.encodePacked(\"multisig.item\", multisigIndex, \".enabled\")), false);\n\t\temit DisabledMultisig(addr, msg.sender);\n\t}\n\n\t/// @notice Gets the next registered and enabled Multisig, revert if none found\n\t/// @dev There will never be more than 10 total multisigs. If we grow beyond that we will redesign this contract.\n\tfunction requireNextActiveMultisig() external view returns (address) {\n\t\tuint256 total = getUint(keccak256(\"multisig.count\"));\n\t\taddress addr;\n\t\tbool enabled;\n\t\tfor (uint256 i = 0; i < total; i++) {\n\t\t\t(addr, enabled) = getMultisig(i);\n\t\t\tif (enabled) {\n\t\t\t\treturn addr;\n\t\t\t}\n\t\t}\n\t\trevert NoEnabledMultisigFound();\n\t}\n\n\t/// @notice The index of a multisig. Returns -1 if the multisig is not found\n\t/// @param addr Address of the multisig that is being searched for\n\t/// @return The index for the given multisig\n\tfunction getIndexOf(address addr) public view returns (int256) {\n\t\treturn int256(getUint(keccak256(abi.encodePacked(\"multisig.index\", addr)))) - 1;\n\t}\n\n\t/// @notice Get the total count of the multisigs in the protocol\n\t/// @return Count of all multisigs\n\tfunction getCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"multisig.count\"));\n\t}\n\n\t/// @notice Gets the multisig information using the multisig's index\n\t/// @param index Index of the multisig\n\t/// @return addr and enabled. The address and the enabled status of the multisig\n\tfunction getMultisig(uint256 index) public view returns (address addr, bool enabled) {\n\t\taddr = getAddress(keccak256(abi.encodePacked(\"multisig.item\", index, \".address\")));\n\t\tenabled = (addr != address(0)) && getBool(keccak256(abi.encodePacked(\"multisig.item\", index, \".enabled\")));\n\t}\n}"
    }
  ]
}