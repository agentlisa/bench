{
  "Title": "[H-05] Permanent DoS due to non-shrinking array usage in an unbounded loop",
  "Content": "\n\n*Note: this finding was reported via the winning [Automated Findings report](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a). It was declared out of scope for the audit, but is being included here for completeness.*\n\nThere are some arrays that can grow indefinitely in size, as they never shrink. When these arrays are used in unbounded loops, they may lead to a permanent denial-of-service (DoS) of these functions.\n\n### POC\n\n1. Attacker calls `participateToAuction` N times with dust amounts until `returnHighestBid` reverts (out of gas).\n2. When `claimAuction` is called by `WinnerOrAdminRequired`, the transaction will fail, as it calls `returnHighestBid`. As a result, `claimAuction` will be permanently DoS.\n\n*There are 4 instances of this issue:*\n\n[[69](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/AuctionDemo.sol#L69), [90](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/AuctionDemo.sol#L90), [110](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/AuctionDemo.sol#L110), [136](https://github.com/code-423n4/2023-10-nextgen/blob/08a56bacd286ee52433670f3bb73a0e4a4525dd4/smart-contracts/AuctionDemo.sol#L136)]\n\n```solidity\nFile: smart-contracts/AuctionDemo.sol\n\n// @audit function returnHighestBid is vulnerable as length grows in size but never shrinks\n69: \t\t            for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n\n60: \t\t        auctionInfoData[_tokenid].push(newBid);\n\n// @audit function returnHighestBidder is vulnerable as length grows in size but never shrinks\n90: \t\t        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n\n60: \t\t        auctionInfoData[_tokenid].push(newBid);\n\n// @audit function claimAuction is vulnerable as length grows in size but never shrinks\n110: \t\t        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i ++) {\n\n60: \t\t        auctionInfoData[_tokenid].push(newBid);\n\n// @audit function cancelAllBids is vulnerable as length grows in size but never shrinks\n136: \t\t        for (uint256 i=0; i<auctionInfoData[_tokenid].length; i++) {\n\n60: \t\t        auctionInfoData[_tokenid].push(newBid);\n```\n\n**[a2rocket (NextGen) confirmed](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a?permalink_comment_id=4797585#gistcomment-4797585)**\n\n**[0xsomeone (judge) commented](https://gist.github.com/code423n4/b979a00ee3ea3f7d36ee39e2a536ba8a?permalink_comment_id=4797627#gistcomment-4797627):**\n> Important and valid.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/AuctionDemo.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: Auction Demo Contract\n *  @date: 26-October-2023 \n *  @version: 1.2\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./IMinterContract.sol\";\nimport \"./IERC721.sol\";\nimport \"./Ownable.sol\";\nimport \"./INextGenAdmins.sol\";\n\ncontract auctionDemo is Ownable {\n\n    //events \n\n    event ClaimAuction(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event Refund(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event CancelBid(address indexed _add, uint256 indexed tokenid, uint256 index, bool status, uint256 indexed funds);\n\n    IMinterContract public minter;\n    INextGenAdmins public adminsContract;\n    address gencore;\n\n    // certain functions can only be called by auction winner or admin\n    modifier WinnerOrAdminRequired(uint256 _tokenId, bytes4 _selector) {\n      require(msg.sender == returnHighestBidder(_tokenId) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    constructor (address _minter, address _gencore, address _adminsContract) public {\n        minter = IMinterContract(_minter);\n        gencore = _gencore;\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // auction Bidders\n    struct auctionInfoStru {\n        address bidder;\n        uint256 bid;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => auctionInfoStru[]) public auctionInfoData;\n\n    // claim auctioned\n    mapping (uint256 => bool) public auctionClaim;\n\n    // participate to auction\n\n    function participateToAuction(uint256 _tokenid) public payable {\n        require(msg.value > returnHighestBid(_tokenid) && block.timestamp <= minter.getAuctionEndTime(_tokenid) && minter.getAuctionStatus(_tokenid) == true);\n        auctionInfoStru memory newBid = auctionInfoStru(msg.sender, msg.value, true);\n        auctionInfoData[_tokenid].push(newBid);\n    }\n\n    // get highest bid\n\n    function returnHighestBid(uint256 _tokenid) public view returns (uint256) {\n        uint256 index;\n        if (auctionInfoData[_tokenid].length > 0) {\n            uint256 highBid = 0;\n            for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n                if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                    highBid = auctionInfoData[_tokenid][i].bid;\n                    index = i;\n                }\n            }\n            if (auctionInfoData[_tokenid][index].status == true) {\n                return highBid;\n            } else {\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    // get highest bidder\n\n    function returnHighestBidder(uint256 _tokenid) public view returns (address) {\n        uint256 highBid = 0;\n        uint256 index;\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                index = i;\n            }\n        }\n        if (auctionInfoData[_tokenid][index].status == true) {\n                return auctionInfoData[_tokenid][index].bidder;\n            } else {\n                revert(\"No Active Bidder\");\n        }\n    }\n\n    // claim Token After Auction\n\n    function claimAuction(uint256 _tokenid) public WinnerOrAdminRequired(_tokenid,this.claimAuction.selector){\n        require(block.timestamp >= minter.getAuctionEndTime(_tokenid) && auctionClaim[_tokenid] == false && minter.getAuctionStatus(_tokenid) == true);\n        auctionClaim[_tokenid] = true;\n        uint256 highestBid = returnHighestBid(_tokenid);\n        address ownerOfToken = IERC721(gencore).ownerOf(_tokenid);\n        address highestBidder = returnHighestBidder(_tokenid);\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i ++) {\n            if (auctionInfoData[_tokenid][i].bidder == highestBidder && auctionInfoData[_tokenid][i].bid == highestBid && auctionInfoData[_tokenid][i].status == true) {\n                IERC721(gencore).safeTransferFrom(ownerOfToken, highestBidder, _tokenid);\n                (bool success, ) = payable(owner()).call{value: highestBid}(\"\");\n                emit ClaimAuction(owner(), _tokenid, success, highestBid);\n            } else if (auctionInfoData[_tokenid][i].status == true) {\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit Refund(auctionInfoData[_tokenid][i].bidder, _tokenid, success, highestBid);\n            } else {}\n        }\n    }\n\n    // cancel a single Bid\n\n    function cancelBid(uint256 _tokenid, uint256 index) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        require(auctionInfoData[_tokenid][index].bidder == msg.sender && auctionInfoData[_tokenid][index].status == true);\n        auctionInfoData[_tokenid][index].status = false;\n        (bool success, ) = payable(auctionInfoData[_tokenid][index].bidder).call{value: auctionInfoData[_tokenid][index].bid}(\"\");\n        emit CancelBid(msg.sender, _tokenid, index, success, auctionInfoData[_tokenid][index].bid);\n    }\n\n    // cancel All Bids\n\n    function cancelAllBids(uint256 _tokenid) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        for (uint256 i=0; i<auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bidder == msg.sender && auctionInfoData[_tokenid][i].status == true) {\n                auctionInfoData[_tokenid][i].status = false;\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit CancelBid(msg.sender, _tokenid, i, success, auctionInfoData[_tokenid][i].bid);\n            } else {}\n        }\n    }\n\n    // return Bids\n\n    function returnBids(uint256 _tokenid) public view returns(auctionInfoStru[] memory) {\n        return auctionInfoData[_tokenid];\n    }\n\n}"
    }
  ]
}