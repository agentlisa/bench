{
  "Title": "[M-04] Priority queue min accounting breaks when nodes are split in two",
  "Content": "\nThe README states `If two users place bids at the same price but with different quantities, the queue will pull from the bid with a higher quantity first`, but the data-structure used for implementing this logic, is not used properly and essentially has its data corrupted when a large bid that is the current minimum bid, is split into two parts, so that a more favorable price can be used for a fraction of the large bid. The underlying issue is that one of the tree nodes is modified, without re-shuffling that node's location in the tree.\n\n### Impact\n\nThe minimum bid as told by the priority queue will be wrong, leading to the wrong bids being allowed to withdraw their funds, and being kicked out of the fraction of bids that are used to buy the NFT.\n\n### Proof of Concept\n\nThe priority queue using a binary tree within an array to [efficiently navigate and find the current minimum based on a node and its children](https://algs4.cs.princeton.edu/24pq/). The sorting of the nodes in the tree is based, in part, on the quantity in the case where two bids have the same price:\n\n```solidity\n// File: src/lib/MinPriorityQueue.sol : MinPriorityQueue.isGreater()   #1\n\n111        function isGreater(\n112            Queue storage self,\n113            uint256 i,\n114            uint256 j\n115        ) private view returns (bool) {\n116            Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]];\n117            Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]];\n118 @>         if (bidI.price == bidJ.price) {\n119 @>             return bidI.quantity <= bidJ.quantity;\n120            }\n121            return bidI.price > bidJ.price;\n122:       }\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/lib/MinPriorityQueue.sol#L111-L122>\n\nThe algorithm of the binary tree only works when the nodes are properly sorted. The sorting is corrupted when a node is modified, without removing it from the tree and re-inserting it:\n\n```solidity\n// File: src/modules/GroupBuy.sol : GroupBuy.processBidsInQueue()   #2\n\n299                Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();\n300                // Breaks out of while loop if given price is less than than lowest bid price\n301                if (_price < lowestBid.price) {\n302                    break;\n303                }\n304    \n305                uint256 lowestBidQuantity = lowestBid.quantity;\n306                // Checks if lowest bid quantity amount is greater than given quantity amount\n307                if (lowestBidQuantity > quantity) {\n308                    // Decrements given quantity amount from lowest bid quantity\n309 @>                 lowestBid.quantity -= quantity;\n310                    // Calculates partial contribution of bid by quantity amount and price\n311                    uint256 contribution = quantity * lowestBid.price;\n312    \n313                    // Decrements partial contribution amount of lowest bid from total and user contributions\n314                    totalContributions[_poolId] -= contribution;\n315                    userContributions[_poolId][lowestBid.owner] -= contribution;\n316                    // Increments pending balance of lowest bid owner\n317                    pendingBalances[lowestBid.owner] += contribution;\n318    \n319:                   // Inserts new bid with given quantity amount into proper position of queue\n```\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/modules/GroupBuy.sol#L299-L319>\n\nLet's say that the tree looks like this:\n\n```\n            A:(p:100,q:10)\n            /             \\\n       B:(p:100,q:10)  C:(<whatever>)\n       /           \\\nD:(whatever)   E:(whatever) \n\n```\n\nIf A is modified so that q (quantity) goes from 10 to 5, B should now be at the root of the tree, since it has the larger size, and would be considered the smaller node. When another node is added, say, `F:(p:100,q:6)`, the algorithm will see that F has a larger size than A, and so A will be popped out as the min, even though B should have been. All nodes that are under B (which may be a lot of the nodes if they all entered at the same price/quantity) essentially become invisible under various scenarios, which means the users that own those bids will not be able to withdraw their funds, even if they really are the lowest bid that deserves to be pushed out of the queue. Note that the swimming up that is done for `F` will not re-shuffle `B` since, according to the algorithm, `F` will start as a child of `C`, and `B` is not in the list of parent nodes of `C`.\n\n### Recommended Mitigation Steps\n\nWhen modifying nodes of the tree, remove them first, then re-add them after modification.\n\n**[stevennevins (Tessera) confirmed and mitigated](https://github.com/code-423n4/2022-12-tessera-findings/issues/32#issuecomment-1406670452):**\n > https://github.com/fractional-company/modular-fractional/pull/212\n>\n **Status:** Mitigation confirmed by [gzeon](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/52) and [Lambda](https://github.com/code-423n4/2023-01-tessera-mitigation-findings/issues/14).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tessera-versus-contest",
  "Code": [
    {
      "filename": "src/lib/MinPriorityQueue.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nstruct Bid {\n    uint256 bidId;\n    address owner;\n    uint256 price;\n    uint256 quantity;\n}\n\n///@notice a min priority queue implementation, based off https://algs4.cs.princeton.edu/24pq/MinPQ.java.html\nlibrary MinPriorityQueue {\n    struct Queue {\n        ///@notice incrementing bid id\n        uint256 nextBidId;\n        ///@notice array backing priority queue\n        uint256[] bidIdList;\n        ///@notice total number of bids in queue\n        uint256 numBids;\n        //@notice map bid ids to bids\n        mapping(uint256 => Bid) bidIdToBidMap;\n        ///@notice map addreses to bids they own\n        mapping(address => uint256[]) ownerToBidIds;\n    }\n\n    ///@notice initialize must be called before using queue.\n    function initialize(Queue storage self) public {\n        self.bidIdList.push(0);\n        self.nextBidId = 1;\n    }\n\n    function isEmpty(Queue storage self) public view returns (bool) {\n        return self.numBids == 0;\n    }\n\n    function getNumBids(Queue storage self) public view returns (uint256) {\n        return self.numBids;\n    }\n\n    ///@notice view min bid\n    function getMin(Queue storage self) public view returns (Bid storage) {\n        require(!isEmpty(self), \"nothing to return\");\n        uint256 minId = self.bidIdList[1];\n        return self.bidIdToBidMap[minId];\n    }\n\n    ///@notice move bid up heap\n    function swim(Queue storage self, uint256 k) private {\n        while (k > 1 && isGreater(self, k / 2, k)) {\n            exchange(self, k, k / 2);\n            k = k / 2;\n        }\n    }\n\n    ///@notice move bid down heap\n    function sink(Queue storage self, uint256 k) private {\n        while (2 * k <= self.numBids) {\n            uint256 j = 2 * k;\n            if (j < self.numBids && isGreater(self, j, j + 1)) {\n                j++;\n            }\n            if (!isGreater(self, k, j)) {\n                break;\n            }\n            exchange(self, k, j);\n            k = j;\n        }\n    }\n\n    ///@notice insert bid in heap\n    function insert(\n        Queue storage self,\n        address owner,\n        uint256 price,\n        uint256 quantity\n    ) public {\n        insert(self, Bid(self.nextBidId++, owner, price, quantity));\n    }\n\n    ///@notice insert bid in heap\n    function insert(Queue storage self, Bid memory bid) private {\n        self.bidIdList.push(bid.bidId);\n        self.bidIdToBidMap[bid.bidId] = bid;\n        self.numBids += 1;\n        swim(self, self.numBids);\n        self.ownerToBidIds[bid.owner].push(bid.bidId);\n    }\n\n    ///@notice delete min bid from heap and return\n    function delMin(Queue storage self) public returns (Bid memory) {\n        require(!isEmpty(self), \"nothing to delete\");\n        Bid memory min = self.bidIdToBidMap[self.bidIdList[1]];\n        exchange(self, 1, self.numBids--);\n        self.bidIdList.pop();\n        delete self.bidIdToBidMap[min.bidId];\n        sink(self, 1);\n        uint256[] storage curUserBids = self.ownerToBidIds[min.owner];\n        for (uint256 i = 0; i < curUserBids.length; i++) {\n            if (curUserBids[i] == min.bidId) {\n                //remove from array and delete struct\n                curUserBids[i] = curUserBids[curUserBids.length - 1];\n                curUserBids.pop();\n                break;\n            }\n        }\n        return min;\n    }\n\n    ///@notice helper function to determine ordering. When two bids have the same price, give priority\n    ///to the one with the larger quantity\n    function isGreater(\n        Queue storage self,\n        uint256 i,\n        uint256 j\n    ) private view returns (bool) {\n        Bid memory bidI = self.bidIdToBidMap[self.bidIdList[i]];\n        Bid memory bidJ = self.bidIdToBidMap[self.bidIdList[j]];\n        if (bidI.price == bidJ.price) {\n            return bidI.quantity <= bidJ.quantity;\n        }\n        return bidI.price > bidJ.price;\n    }\n\n    ///@notice helper function to exchange to bids in the heap\n    function exchange(\n        Queue storage self,\n        uint256 i,\n        uint256 j\n    ) private {\n        uint256 tempId = self.bidIdList[i];\n        self.bidIdList[i] = self.bidIdList[j];\n        self.bidIdList[j] = tempId;\n    }\n}"
    },
    {
      "filename": "src/modules/GroupBuy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ERC165Checker} from \"openzeppelin-contracts/utils/introspection/ERC165Checker.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {MerkleProof} from \"openzeppelin-contracts/utils/cryptography/MerkleProof.sol\";\nimport {MinPriorityQueue, Bid} from \"../lib/MinPriorityQueue.sol\";\nimport {Minter} from \"../modules/Minter.sol\";\n\nimport {ICryptoPunk} from \"../punks/interfaces/ICryptoPunk.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IGroupBuy, PoolInfo} from \"../interfaces/IGroupBuy.sol\";\nimport {IMarketBuyer} from \"../interfaces/IMarketBuyer.sol\";\n\n/// @title GroupBuy\n/// @author Tessera\n/// @notice Module contract for pooling group funds to purchase and vault NFTs\n/// - The bidding mechanism used here is a slightly modified implementation of the\n///   Smart Batched Auction: https://github.com/FrankieIsLost/smart-batched-auction\ncontract GroupBuy is IGroupBuy, MerkleBase, Minter {\n    /// @dev Use MinPriorityQueue library for Queue types\n    using MinPriorityQueue for MinPriorityQueue.Queue;\n    /// @dev Interface ID for ERC-721 tokens\n    bytes4 constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /// @notice Current pool ID\n    uint256 public currentId;\n    /// @notice Mapping of pool ID to vault address\n    mapping(uint256 => address) public poolToVault;\n    /// @notice Mapping of pool ID to PoolInfo struct\n    mapping(uint256 => PoolInfo) public poolInfo;\n    /// @notice Mapping of pool ID to the priority queue of valid bids\n    mapping(uint256 => MinPriorityQueue.Queue) public bidPriorityQueues;\n    /// @notice Mapping of pool ID to amount of Raes currently filled for the pool\n    mapping(uint256 => uint256) public filledQuantities;\n    /// @notice Mapping of pool ID to minimum ether price of any bid\n    mapping(uint256 => uint256) public minBidPrices;\n    /// @notice Mapping of pool ID to minimum reserve prices\n    mapping(uint256 => uint256) public minReservePrices;\n    /// @notice Mapping of pool ID to total amount of ether contributed\n    mapping(uint256 => uint256) public totalContributions;\n    /// @notice Mapping of pool ID to user address to total amount of ether contributed\n    mapping(uint256 => mapping(address => uint256)) public userContributions;\n    /// @notice Mapping of user address to pending balance available for withdrawal\n    mapping(address => uint256) public pendingBalances;\n\n    /// @dev Initializes supply contract and minimum bid price\n    constructor(address _supply) Minter(_supply) {}\n\n    /// @notice Creates a new pool\n    /// @param _nftContract Address of the NFT contract\n    /// @param _tokenIds List of tokenIds permitted to be purchased\n    /// @param _initialPrice Initial price of the NFT(s)\n    /// @param _totalSupply Total amount of Raes to be minted\n    /// @param _duration Time period of pool existing before termination\n    /// @param _quantity Amount of Raes being bid on\n    /// @param _raePrice Ether price per Rae\n    function createPool(\n        address _nftContract,\n        uint256[] calldata _tokenIds,\n        uint256 _initialPrice,\n        uint48 _totalSupply,\n        uint40 _duration,\n        uint256 _quantity,\n        uint256 _raePrice\n    ) external payable {\n        // Reverts if list of tokenIds is empty\n        uint256 length = _tokenIds.length;\n        if (length == 0) revert InsufficientTokenIds();\n\n        // Generates merkle root based on list size of tokenIds\n        bytes32 merkleRoot = (length == 1) ? bytes32(_tokenIds[0]) : _generateRoot(_tokenIds);\n\n        // Sets mapping of poolId to PoolInfo\n        poolInfo[++currentId] = PoolInfo(\n            _nftContract,\n            _totalSupply,\n            uint40(block.timestamp) + _duration,\n            false,\n            merkleRoot\n        );\n\n        // Calculates minimum bid price based on initial price of NFT and desired total supply\n        minBidPrices[currentId] = _initialPrice / _totalSupply;\n\n        // Initializes first bid in queue\n        bidPriorityQueues[currentId].initialize();\n\n        // Emits event for creating new pool\n        emit Create(currentId, _nftContract, _tokenIds, msg.sender, _totalSupply, _duration);\n\n        // Contributes ether into new pool\n        contribute(currentId, _quantity, _raePrice);\n    }\n\n    /// @notice Contributes to an existing pool\n    /// @param _poolId ID of the pool\n    /// @param _quantity Amount of Raes being bid on\n    /// @param _price Ether price per Rae\n    function contribute(\n        uint256 _poolId,\n        uint256 _quantity,\n        uint256 _price\n    ) public payable {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if NFT has already been purchased OR termination period has passed\n        (, uint48 totalSupply, , , ) = _verifyUnsuccessfulState(_poolId);\n        // Reverts if ether contribution amount per Rae is less than minimum bid price per Rae\n        if (msg.value < _quantity * minBidPrices[_poolId] || _quantity == 0)\n            revert InvalidContribution();\n        // Reverts if ether payment amount is not equal to total amount being contributed\n        if (msg.value != _quantity * _price) revert InvalidPayment();\n\n        // Updates user and pool contribution amounts\n        userContributions[_poolId][msg.sender] += msg.value;\n        totalContributions[_poolId] += msg.value;\n\n        // Calculates remaining supply based on total possible supply and current filled quantity amount\n        uint256 remainingSupply = totalSupply - filledQuantities[_poolId];\n        // Calculates quantity amount being filled at any price\n        uint256 fillAtAnyPriceQuantity = remainingSupply < _quantity ? remainingSupply : _quantity;\n\n        // Checks if quantity amount being filled is greater than 0\n        if (fillAtAnyPriceQuantity > 0) {\n            // Inserts bid into end of queue\n            bidPriorityQueues[_poolId].insert(msg.sender, _price, fillAtAnyPriceQuantity);\n            // Increments total amount of filled quantities\n            filledQuantities[_poolId] += fillAtAnyPriceQuantity;\n        }\n\n        // Calculates unfilled quantity amount based on desired quantity and actual filled quantity amount\n        uint256 unfilledQuantity = _quantity - fillAtAnyPriceQuantity;\n        // Processes bids in queue to recalculate unfilled quantity amount\n        unfilledQuantity = processBidsInQueue(_poolId, unfilledQuantity, _price);\n\n        // Recalculates filled quantity amount based on updated unfilled quantity amount\n        uint256 filledQuantity = _quantity - unfilledQuantity;\n        // Updates minimum reserve price if filled quantity amount is greater than 0\n        if (filledQuantity > 0) minReservePrices[_poolId] = getMinPrice(_poolId);\n\n        // Emits event for contributing ether to pool based on desired quantity amount and price per Rae\n        emit Contribute(\n            _poolId,\n            msg.sender,\n            msg.value,\n            _quantity,\n            _price,\n            minReservePrices[_poolId]\n        );\n    }\n\n    /// @notice Purchases NFT once contribution amount has been met\n    /// @param _poolId ID of the pool\n    /// @param _market Address of the market buyer contract\n    /// @param _nftContract Address of the NFT contract\n    /// @param _tokenId ID of the token\n    /// @param _price Total ether price of the listed NFT\n    /// @param _purchaseOrder Bytes data of the purchase order parameters\n    /// @param _purchaseProof Merkle proof of the tokenId in the list of permitted tokenIds\n    function purchase(\n        uint256 _poolId,\n        address _market,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _price,\n        bytes memory _purchaseOrder,\n        bytes32[] memory _purchaseProof\n    ) external {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if NFT has already been purchased OR termination period has passed\n        (\n            address nftContract,\n            uint48 totalSupply,\n            ,\n            ,\n            bytes32 merkleRoot\n        ) = _verifyUnsuccessfulState(_poolId);\n        // Reverts if NFT contract is not equalt to NFT contract set on pool creation\n        if (_nftContract != nftContract) revert InvalidContract();\n        // Reverts if price is greater than total contribution amount of pool\n        if (_price > minReservePrices[_poolId] * filledQuantities[_poolId])\n            revert InvalidPurchase();\n\n        // Checks merkle proof based on size of array\n        if (_purchaseProof.length == 0) {\n            // Hashes tokenId to verify merkle root if proof is empty\n            if (bytes32(_tokenId) != merkleRoot) revert InvalidProof();\n        } else {\n            // Verifies merkle proof based on position of leaf node in tree\n            bytes32 leaf = keccak256(abi.encode(_tokenId));\n            if (!MerkleProof.verify(_purchaseProof, merkleRoot, leaf)) revert InvalidProof();\n        }\n\n        // Decrements actual price from total pool contributions\n        totalContributions[_poolId] -= _price;\n\n        // Encodes NFT contract and tokenId into purchase order\n        bytes memory nftData = abi.encode(_nftContract, _tokenId);\n        // Encodes arbitrary amount of data based on market buyer to execute purchase\n        _purchaseOrder = abi.encodePacked(nftData, _purchaseOrder);\n\n        // Executes purchase order transaction through market buyer contract and deploys new vault\n        address vault = IMarketBuyer(_market).execute{value: _price}(_purchaseOrder);\n\n        // Checks if NFT contract supports ERC165 and interface ID of ERC721 tokens\n        if (ERC165Checker.supportsInterface(_nftContract, _INTERFACE_ID_ERC721)) {\n            // Verifes vault is owner of ERC-721 token\n            if (IERC721(_nftContract).ownerOf(_tokenId) != vault) revert UnsuccessfulPurchase();\n        } else {\n            // Verifies vault is owner of CryptoPunk token\n            if (ICryptoPunk(_nftContract).punkIndexToAddress(_tokenId) != vault)\n                revert UnsuccessfulPurchase();\n        }\n\n        // Stores mapping value of poolId to newly deployed vault\n        poolToVault[_poolId] = vault;\n        // Sets pool state to successful\n        poolInfo[_poolId].success = true;\n\n        // Emits event for purchasing NFT at given price\n        emit Purchase(_poolId, vault, _nftContract, _tokenId, _price);\n    }\n\n    /// @notice Mints Raes based on contribution amount and refunds remaining ether\n    /// @param _poolId ID of the pool\n    /// @param _mintProof Merkle proof for executing minting of Rae tokens\n    function claim(uint256 _poolId, bytes32[] calldata _mintProof) external {\n        // Reverts if pool ID is not valid\n        _verifyPool(_poolId);\n        // Reverts if purchase has not been made AND termination period has not passed\n        (, , , bool success, ) = _verifySuccessfulState(_poolId);\n        // Reverts if contribution balance of user is insufficient\n        uint256 contribution = userContributions[_poolId][msg.sender];\n        if (contribution == 0) revert InsufficientBalance();\n\n        // Deletes user contribution from storage\n        delete userContributions[_poolId][msg.sender];\n\n        // Set up scoped values for iteration\n        uint256 totalQty;\n        uint256 reservePrice = minReservePrices[_poolId];\n        uint256[] memory bidIds = getOwnerToBidIds(_poolId, msg.sender);\n        uint256 length = bidIds.length;\n\n        // Iterates through all active bidIds of the caller\n        if (success) {\n            for (uint256 i; i < length; ++i) {\n                // Gets bid quantity from storage\n                Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[bidIds[i]];\n                uint256 quantity = bid.quantity;\n                // Resets bid quantity amount\n                bid.quantity = 0;\n                // Increments total quantity of Raes to be minted\n                totalQty += quantity;\n                // Decrements quantity price from total user contribution balance\n                contribution -= quantity * reservePrice;\n            }\n\n            // Mints total quantity of Raes to caller\n            _mintRaes(poolToVault[_poolId], msg.sender, totalQty, _mintProof);\n        }\n\n        // Transfers remaining contribution balance back to caller\n        payable(msg.sender).call{value: contribution}(\"\");\n\n        // Withdraws pending balance of caller if available\n        if (pendingBalances[msg.sender] > 0) withdrawBalance();\n\n        // Emits event for claiming tokens and receiving ether refund\n        emit Claim(_poolId, msg.sender, totalQty, contribution);\n    }\n\n    function withdrawBalance() public {\n        // Reverts if caller balance is insufficient\n        uint256 balance = pendingBalances[msg.sender];\n        if (balance == 0) revert InsufficientBalance();\n\n        // Resets pending balance amount\n        delete pendingBalances[msg.sender];\n\n        // Transfers pending ether balance to caller\n        payable(msg.sender).call{value: balance}(\"\");\n    }\n\n    /// @notice Attempts to accept bid for specifc quantity and price\n    /// @param _poolId ID of the pool\n    /// @param _quantity Amount of Raes being filled\n    /// @param _price Price of ether per Rae token\n    /// @return quantity Unfilled quantity amount\n    function processBidsInQueue(\n        uint256 _poolId,\n        uint256 _quantity,\n        uint256 _price\n    ) private returns (uint256 quantity) {\n        quantity = _quantity;\n        while (quantity > 0) {\n            // Retrieves lowest bid in queue\n            Bid storage lowestBid = bidPriorityQueues[_poolId].getMin();\n            // Breaks out of while loop if given price is less than than lowest bid price\n            if (_price < lowestBid.price) {\n                break;\n            }\n\n            uint256 lowestBidQuantity = lowestBid.quantity;\n            // Checks if lowest bid quantity amount is greater than given quantity amount\n            if (lowestBidQuantity > quantity) {\n                // Decrements given quantity amount from lowest bid quantity\n                lowestBid.quantity -= quantity;\n                // Calculates partial contribution of bid by quantity amount and price\n                uint256 contribution = quantity * lowestBid.price;\n\n                // Decrements partial contribution amount of lowest bid from total and user contributions\n                totalContributions[_poolId] -= contribution;\n                userContributions[_poolId][lowestBid.owner] -= contribution;\n                // Increments pending balance of lowest bid owner\n                pendingBalances[lowestBid.owner] += contribution;\n\n                // Inserts new bid with given quantity amount into proper position of queue\n                bidPriorityQueues[_poolId].insert(msg.sender, _price, quantity);\n                // Resets quantity amount to exit while loop\n                quantity = 0;\n            } else {\n                // Calculates total contribution of bid by quantity amount and price\n                uint256 contribution = lowestBid.quantity * lowestBid.price;\n\n                // Decrements full contribution amount of lowest bid from total and user contributions\n                totalContributions[_poolId] -= contribution;\n                userContributions[_poolId][lowestBid.owner] -= contribution;\n                // Increments pending balance of lowest bid owner\n                pendingBalances[lowestBid.owner] += contribution;\n\n                // Removes lowest bid in queue\n                bidPriorityQueues[_poolId].delMin();\n                // Inserts new bid with lowest bid quantity amount into proper position of queue\n                bidPriorityQueues[_poolId].insert(msg.sender, _price, lowestBidQuantity);\n                // Decrements lowest bid quantity from total quantity amount\n                quantity -= lowestBidQuantity;\n            }\n        }\n    }\n\n    /// @notice Gets bid values in queue of given pool\n    /// @param _poolId ID of the pool\n    /// @param _bidId ID of the bid in queue\n    function getBidInQueue(uint256 _poolId, uint256 _bidId)\n        public\n        view\n        returns (\n            uint256 bidId,\n            address owner,\n            uint256 price,\n            uint256 quantity\n        )\n    {\n        Bid storage bid = bidPriorityQueues[_poolId].bidIdToBidMap[_bidId];\n        bidId = bid.bidId;\n        owner = bid.owner;\n        price = bid.price;\n        quantity = bid.quantity;\n    }\n\n    /// @notice Gets minimum bid price of queue for given pool\n    /// @param _poolId ID of the pool\n    function getMinPrice(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].getMin().price;\n    }\n\n    /// @notice Gets next bidId in queue of given pool\n    /// @param _poolId ID of the pool\n    function getNextBidId(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].nextBidId;\n    }\n\n    /// @notice Gets total number of bids in queue for given pool\n    /// @param _poolId ID of the pool\n    function getNumBids(uint256 _poolId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].numBids;\n    }\n\n    /// @notice Gets quantity of Raes for bid of given pool\n    /// @param _poolId ID of the pool\n    /// @param _bidId ID of the bid in queue\n    function getBidQuantity(uint256 _poolId, uint256 _bidId) public view returns (uint256) {\n        return bidPriorityQueues[_poolId].bidIdToBidMap[_bidId].quantity;\n    }\n\n    /// @notice Gets list of bidIds for address of given pool\n    /// @param _poolId ID of the pool\n    /// @param _owner Address of the owner\n    function getOwnerToBidIds(uint256 _poolId, address _owner)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return bidPriorityQueues[_poolId].ownerToBidIds[_owner];\n    }\n\n    /// @notice Logs entire queue of given pool\n    /// @dev Must include console log to debug\n    /// @param _poolId ID of the pool\n    function printQueue(uint256 _poolId) public view {\n        uint256 counter;\n        uint256 index = 1;\n        MinPriorityQueue.Queue storage queue = bidPriorityQueues[_poolId];\n        uint256 numBids = queue.numBids;\n        while (counter < numBids) {\n            Bid memory bid = queue.bidIdToBidMap[index];\n            if (bid.bidId == 0) {\n                ++index;\n                continue;\n            }\n            ++index;\n            ++counter;\n        }\n    }\n\n    /// @dev Generates merkle root for list of tokenIds\n    function _generateRoot(uint256[] calldata _tokenIds)\n        internal\n        pure\n        returns (bytes32 merkleRoot)\n    {\n        // Creates empty leaf nodes array based on size of tokenIds\n        uint256 length = _tokenIds.length;\n        bytes32[] memory leaves = new bytes32[](length);\n        unchecked {\n            for (uint256 i; i < length; ++i) {\n                // Hashes each tokenId into leaf node and set at index position of array\n                leaves[i] = keccak256(abi.encode(_tokenIds[i]));\n            }\n        }\n        // Generates merkle root from given leaf nodes\n        merkleRoot = getRoot(leaves);\n    }\n\n    /// @dev Reverts if pool ID is not valid\n    function _verifyPool(uint256 _poolId) internal view {\n        if (_poolId == 0 || _poolId > currentId) revert InvalidPool();\n    }\n\n    // Reverts if NFT has already been purchased OR termination period has passed\n    function _verifyUnsuccessfulState(uint256 _poolId)\n        internal\n        view\n        returns (\n            address,\n            uint48,\n            uint40,\n            bool,\n            bytes32\n        )\n    {\n        PoolInfo memory pool = poolInfo[_poolId];\n        if (pool.success || block.timestamp > pool.terminationPeriod) revert InvalidState();\n        return (\n            pool.nftContract,\n            pool.totalSupply,\n            pool.terminationPeriod,\n            pool.success,\n            pool.merkleRoot\n        );\n    }\n\n    // Reverts if NFT has not been purchased AND termination period has not passed\n    function _verifySuccessfulState(uint256 _poolId)\n        internal\n        view\n        returns (\n            address,\n            uint48,\n            uint40,\n            bool,\n            bytes32\n        )\n    {\n        PoolInfo memory pool = poolInfo[_poolId];\n        if (!pool.success && block.timestamp < pool.terminationPeriod) revert InvalidState();\n        return (\n            pool.nftContract,\n            pool.totalSupply,\n            pool.terminationPeriod,\n            pool.success,\n            pool.merkleRoot\n        );\n    }\n}"
    }
  ]
}