{
  "Title": "M-11: Incorrect handling of Stash Tokens within the `ConvexRewardsAdapter._claimRewards()`",
  "Content": "# Issue M-11: Incorrect handling of Stash Tokens within the `ConvexRewardsAdapter._claimRewards()` \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/632 \n\n## Found by \nduc, nobody2018\nThe `ConvexRewardsAdapter._claimRewards()` function incorrectly handles Stash tokens, leading to potential vulnerabilities.\n\n## Vulnerability Detail\nThe primary task of the `ConvexRewardAdapter._claimRewards()` function revolves around claiming rewards for Convex/Aura staked LP tokens.\n\n```solidity=\nfunction _claimRewards(\n    address gauge,\n    address defaultToken,\n    address sendTo\n) internal returns (uint256[] memory amounts, address[] memory tokens) {\n    ... \n\n    // Record balances before claiming\n    for (uint256 i = 0; i < totalLength; ++i) {\n        // The totalSupply check is used to identify stash tokens, which can\n        // substitute as rewardToken but lack a \"balanceOf()\"\n        if (IERC20(rewardTokens[i]).totalSupply() > 0) {\n            balancesBefore[i] = IERC20(rewardTokens[i]).balanceOf(account);\n        }\n    }\n\n    // Claim rewards\n    bool result = rewardPool.getReward(account, /*_claimExtras*/ true);\n    if (!result) {\n        revert RewardAdapter.ClaimRewardsFailed();\n    }\n\n    // Record balances after claiming and calculate amounts claimed\n    for (uint256 i = 0; i < totalLength; ++i) {\n        uint256 balance = 0;\n        // Same check for \"stash tokens\"\n        if (IERC20(rewardTokens[i]).totalSupply() > 0) {\n            balance = IERC20(rewardTokens[i]).balanceOf(account);\n        }\n\n        amountsClaimed[i] = balance - balancesBefore[i];\n\n        if (sendTo != address(this) && amountsClaimed[i] > 0) {\n            IERC20(rewardTokens[i]).safeTransfer(sendTo, amountsClaimed[i]);\n        }\n    }\n\n    RewardAdapter.emitRewardsClaimed(rewardTokens, amountsClaimed);\n\n    return (amountsClaimed, rewardTokens);\n}\n``` \n\nAn intriguing aspect of this function's logic lies in its management of \"stash tokens\" from AURA staking. The check to identify whether `rewardToken[i]` is a stash token involves attempting to invoke `IERC20(rewardTokens[i]).totalSupply()`. If the returned total supply value is `0`, the implementation assumes the token is a stash token and bypasses it. However, this check is flawed since the total supply of stash tokens can indeed be non-zero. For instance, at this [address](https://etherscan.io/address/0x2f5c611420c8ba9e7ec5c63e219e3c08af42a926#readContract), the stash token has `totalSupply = 150467818494283559126567`, which is definitely not zero.\n\nThis misstep in checking can potentially lead to a Denial-of-Service (DOS) situation when calling the `claimRewards()` function. This stems from the erroneous attempt to call the `balanceOf` function on stash tokens, which lack the `balanceOf()` method. Consequently, such incorrect calls might incapacitate the destination vault from claiming rewards from AURA, resulting in protocol losses.\n\n## Impact\n* The `AuraRewardsAdapter.claimRewards()` function could suffer from a Denial-of-Service (DOS) scenario.\n* The destination vault's ability to claim rewards from AURA staking might be hampered, leading to protocol losses.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/destinations/adapters/rewards/ConvexRewardsAdapter.sol#L80-L86\n\n## Tool used\nManual Review\n\n## Recommendation\nTo accurately determine whether a token is a stash token, it is advised to perform a low-level `balanceOf()` call to the token and subsequently validate the call's success.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n> Escalate\n> \n> #649 is a duplicate of this issue.\n\n    You've deleted an escalation for this issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/destinations/adapters/rewards/ConvexRewardsAdapter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { IERC20 } from \"openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { RewardAdapter } from \"src/destinations/adapters/rewards/RewardAdapter.sol\";\nimport { IBaseRewardPool } from \"src/interfaces/external/convex/IBaseRewardPool.sol\";\nimport { IClaimableRewardsAdapter } from \"src/interfaces/destinations/IClaimableRewardsAdapter.sol\";\n\n//slither-disable-next-line missing-inheritance\nlibrary ConvexRewards {\n    using SafeERC20 for IERC20;\n\n    /// @notice Claim rewards for Convex staked LP tokens\n    /// @param gauge the reward contract in Convex\n    /// @param defaultToken the reward token always provided. CVX for Convex\n    /// @param sendTo the destination of the rewarded tokens\n    /// @return amounts the amount of each token that was claimed\n    /// @return tokens the tokens that were claimed\n    function claimRewards(\n        address gauge,\n        address defaultToken,\n        address sendTo\n    ) public returns (uint256[] memory amounts, address[] memory tokens) {\n        return _claimRewards(gauge, defaultToken, sendTo);\n    }\n\n    /// @notice Claim rewards for Convex staked LP tokens\n    /// @param gauge the reward contract in Convex\n    /// @param defaultToken the reward token always provided. CVX for Convex\n    /// @return amounts the amount of each token that was claimed\n    /// @return tokens the tokens that were claimed\n    function claimRewards(\n        address gauge,\n        address defaultToken\n    ) public returns (uint256[] memory amounts, address[] memory tokens) {\n        return _claimRewards(gauge, defaultToken, address(this));\n    }\n\n    /// @notice Claim rewards for Convex staked LP tokens\n    /// @dev tokens are ordered as: extras, crv/bal, default (cvx/aura)\n    /// @param gauge the reward contract in Convex\n    /// @param defaultToken the reward token always provided. CVX for Convex\n    /// @param sendTo the destination of the rewarded tokens\n    /// @return amounts the amount of each token that was claimed\n    /// @return tokens the tokens that were claimed\n    function _claimRewards(\n        address gauge,\n        address defaultToken,\n        address sendTo\n    ) internal returns (uint256[] memory amounts, address[] memory tokens) {\n        Errors.verifyNotZero(gauge, \"gauge\");\n\n        address account = address(this);\n\n        IBaseRewardPool rewardPool = IBaseRewardPool(gauge);\n        uint256 extraRewardsLength = rewardPool.extraRewardsLength();\n        uint256 totalLength = extraRewardsLength + (defaultToken != address(0) ? 2 : 1);\n\n        uint256[] memory balancesBefore = new uint256[](totalLength);\n        uint256[] memory amountsClaimed = new uint256[](totalLength);\n        address[] memory rewardTokens = new address[](totalLength);\n\n        // add pool rewards tokens and extra rewards tokens to rewardTokens array\n        IERC20 rewardToken = rewardPool.rewardToken();\n        rewardTokens[extraRewardsLength] = address(rewardToken);\n        if (extraRewardsLength > 0) {\n            for (uint256 i = 0; i < extraRewardsLength; ++i) {\n                address extraReward = rewardPool.extraRewards(i);\n                rewardTokens[i] = address(IBaseRewardPool(extraReward).rewardToken());\n            }\n        }\n        if (defaultToken != address(0)) {\n            rewardTokens[totalLength - 1] = defaultToken;\n        }\n\n        // get balances before\n        for (uint256 i = 0; i < totalLength; ++i) {\n            // Using the totalSupply check to represent stash tokens. They sometimes\n            // stand in as the rewardToken but they don't have a \"balanceOf()\"\n            if (IERC20(rewardTokens[i]).totalSupply() > 0) {\n                balancesBefore[i] = IERC20(rewardTokens[i]).balanceOf(account);\n            }\n        }\n\n        // claim rewards\n        bool result = rewardPool.getReward(account, true);\n        if (!result) {\n            revert RewardAdapter.ClaimRewardsFailed();\n        }\n\n        // get balances after and calculate amounts claimed\n        for (uint256 i = 0; i < totalLength; ++i) {\n            uint256 balance = 0;\n            // Same check for \"stash tokens\"\n            if (IERC20(rewardTokens[i]).totalSupply() > 0) {\n                balance = IERC20(rewardTokens[i]).balanceOf(account);\n            }\n\n            amountsClaimed[i] = balance - balancesBefore[i];\n\n            if (sendTo != address(this) && amountsClaimed[i] > 0) {\n                IERC20(rewardTokens[i]).safeTransfer(sendTo, amountsClaimed[i]);\n            }\n        }\n\n        RewardAdapter.emitRewardsClaimed(rewardTokens, amountsClaimed);\n\n        return (amountsClaimed, rewardTokens);\n    }\n}"
    }
  ]
}