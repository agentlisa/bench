{
  "Title": "[L09] Repeated reward events",
  "Content": "In the [`retrieveRewards` function](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Voting.sol#L462), a `RewardRetrieved` event with zero tokens is emitted when the reward is [expired](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Voting.sol#L498) or [incorrect](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Voting.sol#L520). Additionally, after a correct vote is processed and [cleared](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Voting.sol#L524), if it is processed again it will fail the [validity test](https://github.com/UMAprotocol/protocol/blob/9d403ddb5f2f07194daefe7da51e0e0a6306f2c4/core/contracts/oracle/implementation/Voting.sol#L500) and be treated as an incorrect vote. In any of these situations, the same vote can be processed multiple times, emitting a redundant `RewardRetrieved` event every time.\n\n\nFollowing the “fail early” principle, consider checking that the `revealHash` is non-zero before processing a vote. This should help prevent emitting the `RewardRetrieved` event unnecessarily.\n\n\n**Update:** *Fixed in [PR#1240](https://github.com/UMAprotocol/protocol/pull/1240).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/oracle/implementation/Voting.sol",
      "content": "pragma solidity ^0.6.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"../interfaces/VotingInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"./EncryptedStore.sol\";\nimport \"./Registry.sol\";\nimport \"./ResultComputation.sol\";\nimport \"./VoteTiming.sol\";\nimport \"./VotingToken.sol\";\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Voting system for Oracle.\n * @dev Handles receiving and resolving price requests via a commit-reveal voting scheme.\n */\ncontract Voting is Testable, Ownable, OracleInterface, VotingInterface, EncryptedStore {\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeMath for uint;\n    using VoteTiming for VoteTiming.Data;\n    using ResultComputation for ResultComputation.Data;\n\n    /****************************************\n     *        VOTING DATA STRUCTURES        *\n     ****************************************/\n\n    // Identifies a unique price request for which the Oracle will always return the same value.\n    // Tracks ongoing votes as well as the result of the vote.\n    struct PriceRequest {\n        bytes32 identifier;\n        uint time;\n        // A map containing all votes for this price in various rounds.\n        mapping(uint => VoteInstance) voteInstances;\n        // If in the past, this was the voting round where this price was resolved. If current or the upcoming round,\n        // this is the voting round where this price will be voted on, but not necessarily resolved.\n        uint lastVotingRound;\n        // The index in the `pendingPriceRequests` that references this PriceRequest. A value of UINT_MAX means that\n        // this PriceRequest is resolved and has been cleaned up from `pendingPriceRequests`.\n        uint index;\n    }\n\n    struct VoteInstance {\n        // Maps (voterAddress) to their submission.\n        mapping(address => VoteSubmission) voteSubmissions;\n        // The data structure containing the computed voting results.\n        ResultComputation.Data resultComputation;\n    }\n\n    struct VoteSubmission {\n        // A bytes32 of `0` indicates no commit or a commit that was already revealed.\n        bytes32 commit;\n        // The hash of the value that was revealed.\n        // Note: this is only used for computation of rewards.\n        bytes32 revealHash;\n    }\n\n    struct Round {\n        uint snapshotId; // Voting token snapshot ID for this round.  0 if no snapshot has been taken.\n        FixedPoint.Unsigned inflationRate; // Inflation rate set for this round.\n        FixedPoint.Unsigned gatPercentage; // Gat rate set for this round.\n        uint rewardsExpirationTime; // Time that rewards for this round can be claimed until.\n    }\n\n    // Represents the status a price request has.\n    enum RequestStatus {\n        NotRequested, // Was never requested.\n        Active, // Is being voted on in the current round.\n        Resolved, // Was resolved in a previous round.\n        Future // Is scheduled to be voted on in a future round.\n    }\n\n    // Only used as a return value in view methods -- never stored in the contract.\n    struct RequestState {\n        RequestStatus status;\n        uint lastVotingRound;\n    }\n\n    /****************************************\n     *          INTERNAL TRACKING           *\n     ****************************************/\n\n    // Maps round numbers to the rounds.\n    mapping(uint => Round) public rounds;\n\n    // Maps price request IDs to the PriceRequest struct.\n    mapping(bytes32 => PriceRequest) private priceRequests;\n\n    // Price request ids for price requests that haven't yet been marked as resolved.\n    // These requests may be for future rounds.\n    bytes32[] private pendingPriceRequests;\n\n    VoteTiming.Data public voteTiming;\n\n    IdentifierWhitelistInterface public identifierWhitelist;\n\n    // Percentage of the total token supply that must be used in a vote to\n    // create a valid price resolution. 1 == 100%.\n    FixedPoint.Unsigned public gatPercentage;\n\n    // Global setting for the rate of inflation per vote. This is the percentage of the snapshotted total supply that\n    // should be split among the correct voters. Note: this value is used to set per-round inflation at the beginning\n    // of each round. 1 = 100%\n    FixedPoint.Unsigned public inflationRate;\n\n    // Time in seconds from the end of the round in which a price request is\n    // resolved that voters can still claim their rewards.\n    uint public rewardsExpirationTimeout;\n\n    // Reference to the voting token.\n    VotingToken public votingToken;\n\n    // Reference to the Finder.\n    FinderInterface private finder;\n\n    // If non-zero, this contract has been migrated to this address. All voters and\n    // financial contracts should query the new address only.\n    address public migratedAddress;\n\n    // Max value of an unsigned integer.\n    uint private constant UINT_MAX = ~uint(0);\n\n    /***************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event VoteCommitted(address indexed voter, uint indexed roundId, bytes32 indexed identifier, uint time);\n\n    event VoteRevealed(\n        address indexed voter,\n        uint indexed roundId,\n        bytes32 indexed identifier,\n        uint time,\n        int price,\n        uint numTokens\n    );\n\n    event RewardsRetrieved(\n        address indexed voter,\n        uint indexed roundId,\n        bytes32 indexed identifier,\n        uint time,\n        uint numTokens\n    );\n\n    event PriceRequestAdded(uint indexed votingRoundId, bytes32 indexed identifier, uint time);\n\n    event PriceResolved(uint indexed resolutionRoundId, bytes32 indexed identifier, uint time, int price);\n\n    /**\n     * @notice Construct the Voting contract.\n     * @param _phaseLength length of the commit and reveal phases in seconds.\n     * @param _gatPercentage of the total token supply that must be used in a vote to create a valid price resolution.\n     * @param _inflationRate percentage inflation per round used to increase token supply of correct voters.\n     * @param _rewardsExpirationTimeout timeout, in seconds, within which rewards must be claimed.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     * @param _identifierWhitelist defines the identifiers that can have have synthetics created against.\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\n     * @param _isTest whether this contract is being constructed for the purpose of running automated tests.\n     */\n    constructor(\n        uint _phaseLength,\n        FixedPoint.Unsigned memory _gatPercentage,\n        FixedPoint.Unsigned memory _inflationRate,\n        uint _rewardsExpirationTimeout,\n        address _votingToken,\n        address _identifierWhitelist,\n        address _finder,\n        bool _isTest\n    ) public Testable(_isTest) {\n        voteTiming.init(_phaseLength);\n        require(_gatPercentage.isLessThanOrEqual(1), \"GAT percentage must be <= 100%\");\n        gatPercentage = _gatPercentage;\n        inflationRate = _inflationRate;\n        votingToken = VotingToken(_votingToken);\n        identifierWhitelist = IdentifierWhitelistInterface(_identifierWhitelist);\n        finder = FinderInterface(_finder);\n        rewardsExpirationTimeout = _rewardsExpirationTimeout;\n    }\n\n    /***************************************\n                    MODIFIERS\n    ****************************************/\n\n    modifier onlyRegisteredContract() {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress);\n        } else {\n            Registry registry = Registry(finder.getImplementationAddress(\"Registry\"));\n            require(registry.isContractRegistered(msg.sender));\n        }\n        _;\n    }\n\n    modifier onlyIfNotMigrated() {\n        require(migratedAddress == address(0));\n        _;\n    }\n\n    /****************************************\n     *  PRICE REQUEST AND ACCESS FUNCTIONS  *\n     ****************************************/\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function requestPrice(bytes32 identifier, uint time) external override onlyRegisteredContract() {\n        uint blockTime = getCurrentTime();\n        require(time <= blockTime, \"Can only request in past\");\n        require(identifierWhitelist.isIdentifierSupported(identifier), \"Unsupported identifier request\");\n\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time);\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\n        uint currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\n\n        if (requestStatus == RequestStatus.NotRequested) {\n            // Price has never been requested.\n            // Price requests always go in the next round, so add 1 to the computed current round.\n            uint nextRoundId = currentRoundId.add(1);\n\n            priceRequests[priceRequestId] = PriceRequest({\n                identifier: identifier,\n                time: time,\n                lastVotingRound: nextRoundId,\n                index: pendingPriceRequests.length\n            });\n            pendingPriceRequests.push(priceRequestId);\n            emit PriceRequestAdded(nextRoundId, identifier, time);\n        }\n    }\n\n    /**\n     * @notice Whether the price for `identifier` and `time` is available.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function hasPrice(bytes32 identifier, uint time) external override view onlyRegisteredContract() returns (bool _hasPrice) {\n        (_hasPrice, , ) = _getPriceOrError(identifier, time);\n    }\n\n    /**\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     * @return int representing the resolved price for the given identifier and timestamp.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getPrice(bytes32 identifier, uint time) external override view onlyRegisteredContract() returns (int) {\n        (bool _hasPrice, int price, string memory message) = _getPriceOrError(identifier, time);\n\n        // If the price wasn't available, revert with the provided message.\n        require(_hasPrice, message);\n        return price;\n    }\n\n    /**\n     * @notice Gets the status of a list of price requests, identified by their identifier and time.\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\n     * @param requests array of time PendingRequest which includes a identifier and timestamp for each request.\n     * @return requestStates A lis, in the same order as the input list, giving the status of each of the specified price requests.\n     */\n    function getPriceRequestStatuses(PendingRequest[] memory requests)\n        public\n        view\n        returns (RequestState[] memory requestStates)\n    {\n        requestStates = new RequestState[](requests.length);\n        uint currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        for (uint i = 0; i < requests.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(requests[i].identifier, requests[i].time);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) {\n                requestStates[i].lastVotingRound = currentRoundId;\n            } else {\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            }\n\n            requestStates[i].status = status;\n        }\n    }\n\n    /****************************************\n     *            VOTING FUNCTIONS          *\n     ****************************************/\n\n    /**\n     * @notice Commit a vote for a price request for `identifier` at `time`.\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\n     * @param time unix timestamp of the price is being voted on.\n     * @param hash keccak256 hash of the price you want to vote for and a `int salt`.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function commitVote(bytes32 identifier, uint time, bytes32 hash) public override onlyIfNotMigrated() {\n        require(hash != bytes32(0), \"Invalid provided hash\");\n        // Current time is required for all vote timing queries.\n        uint blockTime = getCurrentTime();\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Commit, \"Cannot commit in reveal phase\");\n\n        // At this point, the computed and last updated round ID should be equal.\n        uint currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time);\n        require(\n            _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active,\n            \"Cannot commit inactive request\"\n        );\n\n        priceRequest.lastVotingRound = currentRoundId;\n        VoteInstance storage voteInstance = priceRequest.voteInstances[currentRoundId];\n        voteInstance.voteSubmissions[msg.sender].commit = hash;\n\n        emit VoteCommitted(msg.sender, currentRoundId, identifier, time);\n    }\n\n    /**\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\n     * @dev The revealed `price` and `salt` must match the latest `hash` that `commitVote()` was called with.\n     * Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price is being voted on.\n     * @param price voted on during the commit phase.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function revealVote(bytes32 identifier, uint time, int price, int salt) public override onlyIfNotMigrated() {\n        uint blockTime = getCurrentTime();\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Reveal, \"Cannot reveal in commit phase\");\n        // Note: computing the current round is required to disallow people from revealing an old commit after the\n        // round is over.\n        uint roundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time);\n        VoteInstance storage voteInstance = priceRequest.voteInstances[roundId];\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[msg.sender];\n\n        // 0 hashes are disallowed in the commit phase, so they indicate a different error.\n        // Cannot reveal an uncommitted or previously revealed hash\n        require(voteSubmission.commit != bytes32(0), \"Invalid hash reveal\");\n        // Committed hash doesn't match revealed price and salt\n        require(keccak256(abi.encode(price, salt)) == voteSubmission.commit, \"Invalid commit hash & salt\");\n        delete voteSubmission.commit;\n\n        // Lock in round variables including snapshotId and inflation rate\n        _freezeRoundVariables(roundId);\n\n        // Get the frozen snapshotId\n        uint snapshotId = rounds[roundId].snapshotId;\n\n        // Get the voter's snapshotted balance. Since balances are returned pre-scaled by 10**18, we can directly\n        // initialize the Unsigned value with the returned uint.\n        FixedPoint.Unsigned memory balance = FixedPoint.Unsigned(votingToken.balanceOfAt(msg.sender, snapshotId));\n\n        // Set the voter's submission.\n        voteSubmission.revealHash = keccak256(abi.encode(price));\n\n        // Add vote to the results.\n        voteInstance.resultComputation.addVote(price, balance);\n\n        // Remove the stored message for this price request, if it exists.\n        bytes32 topicHash = keccak256(abi.encode(identifier, time, roundId));\n        removeMessage(topicHash);\n\n        emit VoteRevealed(msg.sender, roundId, identifier, time, price, balance.rawValue);\n    }\n\n    /**\n     * @notice commits a vote and stores an encrypted version which can be later decrypted\n     * to recover the voter's price & salt.\n     * @dev The encryption mechanism uses encrypt from a signature from a users price key. See `EncryptedSender.sol`\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param hash keccak256 hash of the price you want to vote for and a `int salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n    function commitAndPersistEncryptedVote(bytes32 identifier, uint time, bytes32 hash, bytes memory encryptedVote)\n        public\n    {\n        commitVote(identifier, time, hash);\n\n        uint roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        bytes32 topicHash = keccak256(abi.encode(identifier, time, roundId));\n        storeMessage(topicHash, encryptedVote);\n    }\n\n    /**\n     * @notice Submit a batch of commits in a single transaction.\n     * @dev Using `encryptedVote` is optional. If included then commitment is stored on chain.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\n     * commitments that can fit in one transaction.\n     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function batchCommit(Commitment[] calldata commits) external override {\n        for (uint i = 0; i < commits.length; i++) {\n            if (commits[i].encryptedVote.length == 0) {\n                commitVote(commits[i].identifier, commits[i].time, commits[i].hash);\n            } else {\n                commitAndPersistEncryptedVote(\n                    commits[i].identifier,\n                    commits[i].time,\n                    commits[i].hash,\n                    commits[i].encryptedVote\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Reveal multiple votes in a single transaction.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\n     * that can fit in one transaction.\n     * @dev For more information on reveals, review the comment for `revealVote`.\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function batchReveal(Reveal[] calldata reveals) external override {\n        for (uint i = 0; i < reveals.length; i++) {\n            revealVote(reveals[i].identifier, reveals[i].time, reveals[i].price, reveals[i].salt);\n        }\n    }\n\n    /**\n     * @notice Retrieves rewards owed for a set of resolved price requests.\n     * @dev Can only retrieve rewards if calling for a valid round and if the\n     * call is done within the timeout threshold (not expired).\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\n     * @param roundId the round from which voting rewards will be retrieved from.\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\n     * @return totalRewardToIssue total amount of rewards returned to the voter.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] memory toRetrieve)\n        public\n        override \n        returns (FixedPoint.Unsigned memory totalRewardToIssue)\n    {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress, \"Can only call from migrated\");\n        }\n        uint blockTime = getCurrentTime();\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime), \"Invalid roundId\");\n\n        Round storage round = rounds[roundId];\n        bool isExpired = blockTime > round.rewardsExpirationTime;\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n            votingToken.balanceOfAt(voterAddress, round.snapshotId)\n        );\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n            votingToken.totalSupplyAt(round.snapshotId)\n        );\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            // Only retrieve rewards for votes resolved in same round\n            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (isExpired) {\n                // Emit a 0 token retrieval on expired rewards.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            } else if (\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\n            ) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\n                // and was correct, so they are eligible for a reward.\n                // Compute the reward and add to the cumulative reward.\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(\n                    voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\n                );\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    reward.rawValue\n                );\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \"Voting token issuance failed\");\n        }\n    }\n\n    /****************************************\n     *        VOTING GETTER FUNCTIONS       *\n     ****************************************/\n\n    /**\n     * @notice Gets the queries that are being voted on this round.\n     * @return pendingRequests `PendingRequest` array containing identifiers\n     * and timestamps for all pending requests.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getPendingRequests() external override view returns (PendingRequest[] memory pendingRequests) {\n        uint blockTime = getCurrentTime();\n        uint currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\n        // `pendingPriceRequests` only to those requests that `isActive()`.\n        PendingRequest[] memory unresolved = new PendingRequest[](pendingPriceRequests.length);\n        uint numUnresolved = 0;\n\n        for (uint i = 0; i < pendingPriceRequests.length; i++) {\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequests[i]];\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\n                unresolved[numUnresolved] = PendingRequest({\n                    identifier: priceRequest.identifier,\n                    time: priceRequest.time\n                });\n                numUnresolved++;\n            }\n        }\n\n        pendingRequests = new PendingRequest[](numUnresolved);\n        for (uint i = 0; i < numUnresolved; i++) {\n            pendingRequests[i] = unresolved[i];\n        }\n    }\n\n    /**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getVotePhase() external override view returns (Phase) {\n        return voteTiming.computeCurrentPhase(getCurrentTime());\n    }\n\n    /**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint representing the unique round ID.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getCurrentRoundId() external override view returns (uint) {\n        return voteTiming.computeCurrentRoundId(getCurrentTime());\n    }\n\n    /****************************************\n     *        OWNER ADMIN FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice Disables this Voting contract in favor of the migrated one.\n     * @dev Can only be called by the contract owner.\n     */\n    function setMigrated(address newVotingAddress) external onlyOwner {\n        migratedAddress = newVotingAddress;\n    }\n\n    /**\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newInflationRate sets the next rounds inflation rate.\n     */\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public onlyOwner {\n        inflationRate = newInflationRate;\n    }\n\n    /**\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newGatPercentage sets the next rounds Gat percentage.\n     */\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public onlyOwner {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPercentage;\n    }\n\n    /**\n     * @notice Resets the rewards expiration timeout.\n     * @dev This change only applies to rounds that have not yet begun.\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\n     */\n    function setRewardsExpirationTimeout(uint NewRewardsExpirationTimeout) public onlyOwner {\n        rewardsExpirationTimeout = NewRewardsExpirationTimeout;\n    }\n\n    /****************************************\n     *    PRIVATE AND INTERNAL FUNCTIONS    *\n     ****************************************/\n\n    function _getPriceOrError(bytes32 identifier, uint time)\n        private\n        view\n        returns (bool _hasPrice, int price, string memory err)\n    {\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time);\n        uint currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\n        if (requestStatus == RequestStatus.Active) {\n            return (false, 0, \"Current voting round not ended\");\n        } else if (requestStatus == RequestStatus.Resolved) {\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            (, int resolvedPrice) = voteInstance.resultComputation.getResolvedPrice(\n                _computeGat(priceRequest.lastVotingRound)\n            );\n            return (true, resolvedPrice, \"\");\n        } else if (requestStatus == RequestStatus.Future) {\n            return (false, 0, \"Price is still to be voted on\");\n        } else {\n            return (false, 0, \"Price was never requested\");\n        }\n    }\n\n    function _getPriceRequest(bytes32 identifier, uint time) private view returns (PriceRequest storage) {\n        return priceRequests[_encodePriceRequest(identifier, time)];\n    }\n\n    function _encodePriceRequest(bytes32 identifier, uint time) private pure returns (bytes32) {\n        return keccak256(abi.encode(identifier, time));\n    }\n\n    function _freezeRoundVariables(uint roundId) private {\n        Round storage round = rounds[roundId];\n        // Only on the first reveal should the snapshot be captured for that round.\n        if (round.snapshotId == 0) {\n            // There is no snapshot ID set, so create one.\n            round.snapshotId = votingToken.snapshot();\n\n            // Set the round inflation rate to the current global inflation rate.\n            rounds[roundId].inflationRate = inflationRate;\n\n            // Set the round gat percentage to the current global gat rate.\n            rounds[roundId].gatPercentage = gatPercentage;\n\n            // Set the rewards expiration time based on end of time of this round and the current global timeout.\n            rounds[roundId].rewardsExpirationTime = voteTiming.computeRoundEndTime(roundId) + rewardsExpirationTimeout;\n        }\n    }\n\n    function _resolvePriceRequest(PriceRequest storage priceRequest, VoteInstance storage voteInstance) private {\n        if (priceRequest.index == UINT_MAX) {\n            return;\n        }\n        (bool isResolved, int resolvedPrice) = voteInstance.resultComputation.getResolvedPrice(\n            _computeGat(priceRequest.lastVotingRound)\n        );\n        require(isResolved, \"Can't resolve unresolved request\");\n\n        // Delete the resolved price request from pendingPriceRequests.\n        uint lastIndex = pendingPriceRequests.length - 1;\n        PriceRequest storage lastPriceRequest = priceRequests[pendingPriceRequests[lastIndex]];\n        lastPriceRequest.index = priceRequest.index;\n        pendingPriceRequests[priceRequest.index] = pendingPriceRequests[lastIndex];\n        delete pendingPriceRequests[lastIndex];\n\n        priceRequest.index = UINT_MAX;\n        emit PriceResolved(priceRequest.lastVotingRound, priceRequest.identifier, priceRequest.time, resolvedPrice);\n    }\n\n    function _computeGat(uint roundId) private view returns (FixedPoint.Unsigned memory) {\n        uint snapshotId = rounds[roundId].snapshotId;\n        if (snap"
    }
  ]
}