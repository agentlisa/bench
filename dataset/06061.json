{
  "Title": "[G-12] Constructors can be marked payable",
  "Content": "Payable functions cost less gas to execute, since the compiler does not have to add extra checks to ensure that a payment wasn't provided. A constructor can safely be marked as payable, since only the deployer would be able to pass funds, and the project itself would not pass any funds.\n\nHere are some of the instances entailed:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/ATokenFiatCollateral.sol#L42\n\n```solidity\n    constructor(CollateralConfig memory config, uint192 revenueHiding)\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/EURFiatCollateral.sol#L23-L27\n\n```solidity\n    constructor(\n        CollateralConfig memory config,\n        AggregatorV3Interface targetUnitChainlinkFeed_,\n        uint48 targetUnitOracleTimeout_\n    ) FiatCollateral(config) {\n```\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/FiatCollateral.sol#L62-L70\n\n```solidity\n    constructor(CollateralConfig memory config)\n        Asset(\n            config.priceTimeout,\n            config.chainlinkFeed,\n            config.oracleError,\n            config.erc20,\n            config.maxTradeVolume,\n            config.oracleTimeout\n        )\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/assets/aave/ATokenFiatCollateral.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../../libraries/Fixed.sol\";\nimport \"../AppreciatingFiatCollateral.sol\";\n\n// This interface is redundant with the one from contracts/plugins/aave/IStaticAToken,\n// but it's compiled with a different solidity version.\ninterface IStaticAToken is IERC20Metadata {\n    /**\n     * @notice Claim rewards\n     * @param forceUpdate Flag to retrieve latest rewards from `INCENTIVES_CONTROLLER`\n     */\n    function claimRewardsToSelf(bool forceUpdate) external;\n\n    /**\n     * @notice Returns the Aave liquidity index of the underlying aToken, denominated rate here\n     * as it can be considered as an ever-increasing exchange rate\n     * @return The liquidity index\n     **/\n    function rate() external view returns (uint256);\n\n    /// @return The reward token, ie stkAAVE\n    // solhint-disable-next-line func-name-mixedcase\n    function REWARD_TOKEN() external view returns (IERC20);\n}\n\n/**\n * @title ATokenFiatCollateral\n * @notice Collateral plugin for an aToken for a UoA-pegged asset, like aUSDC or a aUSDP\n * Expected: {tok} != {ref}, {ref} is pegged to {target} unless defaulting, {target} == {UoA}\n */\ncontract ATokenFiatCollateral is AppreciatingFiatCollateral {\n    using OracleLib for AggregatorV3Interface;\n    using FixLib for uint192;\n\n    // solhint-disable no-empty-blocks\n\n    /// @param config.chainlinkFeed Feed units: {UoA/ref}\n    /// @param revenueHiding {1} A value like 1e-6 that represents the maximum refPerTok to hide\n    constructor(CollateralConfig memory config, uint192 revenueHiding)\n        AppreciatingFiatCollateral(config, revenueHiding)\n    {}\n\n    // solhint-enable no-empty-blocks\n\n    /// @return {ref/tok} Actual quantity of whole reference units per whole collateral tokens\n    function _underlyingRefPerTok() internal view override returns (uint192) {\n        uint256 rateInRAYs = IStaticAToken(address(erc20)).rate(); // {ray ref/tok}\n        return shiftl_toFix(rateInRAYs, -27);\n    }\n\n    /// Claim rewards earned by holding a balance of the ERC20 token\n    /// DEPRECATED: claimRewards() will be removed from all assets and collateral plugins\n    function claimRewards() external virtual override(Asset, IRewardable) {\n        IRewardable(address(erc20)).claimRewards();\n    }\n}"
    },
    {
      "filename": "contracts/plugins/assets/EURFiatCollateral.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"./FiatCollateral.sol\";\n\n/**\n * @title EURFiatCollateral\n * @notice Collateral plugin for a EUR fiatcoin collateral, like EURT\n * Expected: {tok} == {ref}, {ref} is pegged to {target} or defaults, {target} != {UoA}\n */\ncontract EURFiatCollateral is FiatCollateral {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    AggregatorV3Interface public immutable targetUnitChainlinkFeed; // {UoA/target}\n    uint48 public immutable targetUnitOracleTimeout; // {s}\n\n    /// @param config.chainlinkFeed Feed units:{UoA/ref}\n    /// @param targetUnitChainlinkFeed_ Feed units: {UoA/target}\n    /// @param targetUnitOracleTimeout_ {s} oracle timeout to use for targetUnitChainlinkFeed\n    constructor(\n        CollateralConfig memory config,\n        AggregatorV3Interface targetUnitChainlinkFeed_,\n        uint48 targetUnitOracleTimeout_\n    ) FiatCollateral(config) {\n        require(address(targetUnitChainlinkFeed_) != address(0), \"missing targetUnit feed\");\n        require(targetUnitOracleTimeout_ > 0, \"targetUnitOracleTimeout zero\");\n        targetUnitChainlinkFeed = targetUnitChainlinkFeed_;\n        targetUnitOracleTimeout = targetUnitOracleTimeout_;\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// @return low {UoA/tok} The low price estimate\n    /// @return high {UoA/tok} The high price estimate\n    /// @return pegPrice {UoA/ref}\n    function tryPrice()\n        external\n        view\n        override\n        returns (\n            uint192 low,\n            uint192 high,\n            uint192 pegPrice\n        )\n    {\n        uint192 pricePerRef = chainlinkFeed.price(oracleTimeout); // {UoA/ref}\n\n        // {UoA/target}\n        uint192 pricePerTarget = targetUnitChainlinkFeed.price(targetUnitOracleTimeout);\n\n        // div-by-zero later\n        if (pricePerTarget == 0) {\n            return (0, FIX_MAX, 0);\n        }\n\n        uint192 err = pricePerRef.mul(oracleError, CEIL);\n\n        low = pricePerRef - err;\n        high = pricePerRef + err;\n        // assert(low <= high); obviously true just by inspection\n\n        // {target/ref} = {UoA/ref} / {UoA/target}\n        pegPrice = pricePerRef.div(pricePerTarget);\n    }\n}"
    },
    {
      "filename": "contracts/plugins/assets/FiatCollateral.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"../../libraries/Fixed.sol\";\nimport \"./Asset.sol\";\nimport \"./OracleLib.sol\";\n\nuint48 constant MAX_DELAY_UNTIL_DEFAULT = 1209600; // {s} 2 weeks\n\nstruct CollateralConfig {\n    uint48 priceTimeout; // {s} The number of seconds over which saved prices decay\n    AggregatorV3Interface chainlinkFeed; // Feed units: {target/ref}\n    uint192 oracleError; // {1} The % the oracle feed can be off by\n    IERC20Metadata erc20; // The ERC20 of the collateral token\n    uint192 maxTradeVolume; // {UoA} The max trade volume, in UoA\n    uint48 oracleTimeout; // {s} The number of seconds until a oracle value becomes invalid\n    bytes32 targetName; // The bytes32 representation of the target name\n    uint192 defaultThreshold; // {1} A value like 0.05 that represents a deviation tolerance\n    // set defaultThreshold to zero to create SelfReferentialCollateral\n    uint48 delayUntilDefault; // {s} The number of seconds an oracle can mulfunction\n}\n\n/**\n * @title FiatCollateral\n * Parent class for all collateral. Can be extended to support appreciating collateral\n *\n * For: {tok} == {ref}, {ref} != {target}, {target} == {UoA}\n * Can be easily extended by (optionally) re-implementing:\n *   - tryPrice()\n *   - refPerTok()\n *   - targetPerRef()\n *   - claimRewards()\n * If you have appreciating collateral, then you should use AppreciatingFiatCollateral or\n * override refresh() yourself.\n *\n * Can intentionally disable default checks by setting config.defaultThreshold to 0\n */\ncontract FiatCollateral is ICollateral, Asset {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    // Default Status:\n    // _whenDefault == NEVER: no risk of default (initial value)\n    // _whenDefault > block.timestamp: delayed default may occur as soon as block.timestamp.\n    //                In this case, the asset may recover, reachiving _whenDefault == NEVER.\n    // _whenDefault <= block.timestamp: default has already happened (permanently)\n    uint48 private constant NEVER = type(uint48).max;\n    uint48 private _whenDefault = NEVER;\n\n    uint48 public immutable delayUntilDefault; // {s} e.g 86400\n\n    // targetName: The canonical name of this collateral's target unit.\n    bytes32 public immutable targetName;\n\n    uint192 public immutable pegBottom; // {target/ref} The bottom of the peg\n\n    uint192 public immutable pegTop; // {target/ref} The top of the peg\n\n    /// @param config.chainlinkFeed Feed units: {UoA/ref}\n    constructor(CollateralConfig memory config)\n        Asset(\n            config.priceTimeout,\n            config.chainlinkFeed,\n            config.oracleError,\n            config.erc20,\n            config.maxTradeVolume,\n            config.oracleTimeout\n        )\n    {\n        require(config.targetName != bytes32(0), \"targetName missing\");\n        if (config.defaultThreshold > 0) {\n            require(config.delayUntilDefault > 0, \"delayUntilDefault zero\");\n        }\n        require(config.delayUntilDefault <= 1209600, \"delayUntilDefault too long\");\n\n        targetName = config.targetName;\n        delayUntilDefault = config.delayUntilDefault;\n\n        // Cache constants\n        uint192 peg = targetPerRef(); // {target/ref}\n\n        // {target/ref} = {target/ref} * {1}\n        uint192 delta = peg.mul(config.defaultThreshold);\n        pegBottom = peg - delta;\n        pegTop = peg + delta;\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// Should not return FIX_MAX for low\n    /// Should only return FIX_MAX for high if low is 0\n    /// @dev Override this when pricing is more complicated than just a single oracle\n    /// @return low {UoA/tok} The low price estimate\n    /// @return high {UoA/tok} The high price estimate\n    /// @return pegPrice {target/ref} The actual price observed in the peg\n    function tryPrice()\n        external\n        view\n        virtual\n        override\n        returns (\n            uint192 low,\n            uint192 high,\n            uint192 pegPrice\n        )\n    {\n        // {target/ref} = {UoA/ref} / {UoA/target} (1)\n        pegPrice = chainlinkFeed.price(oracleTimeout);\n\n        // {target/ref} = {target/ref} * {1}\n        uint192 err = pegPrice.mul(oracleError, CEIL);\n\n        low = pegPrice - err;\n        high = pegPrice + err;\n        // assert(low <= high); obviously true just by inspection\n    }\n\n    /// Should not revert\n    /// Refresh exchange rates and update default status.\n    /// @dev May need to override: limited to handling collateral with refPerTok() = 1\n    function refresh() public virtual override(Asset, IAsset) {\n        if (alreadyDefaulted()) return;\n        CollateralStatus oldStatus = status();\n\n        // Check for soft default + save lotPrice\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192 pegPrice) {\n            // {UoA/tok}, {UoA/tok}, {target/ref}\n            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced\n\n            // Save prices if priced\n            if (high < FIX_MAX) {\n                savedLowPrice = low;\n                savedHighPrice = high;\n                lastSave = uint48(block.timestamp);\n            } else {\n                // must be unpriced\n                assert(low == 0);\n            }\n\n            // If the price is below the default-threshold price, default eventually\n            // uint192(+/-) is the same as Fix.plus/minus\n            if (pegPrice < pegBottom || pegPrice > pegTop || low == 0) {\n                markStatus(CollateralStatus.IFFY);\n            } else {\n                markStatus(CollateralStatus.SOUND);\n            }\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            markStatus(CollateralStatus.IFFY);\n        }\n\n        CollateralStatus newStatus = status();\n        if (oldStatus != newStatus) {\n            emit CollateralStatusChanged(oldStatus, newStatus);\n        }\n    }\n\n    /// @return The collateral's status\n    function status() public view returns (CollateralStatus) {\n        if (_whenDefault == NEVER) {\n            return CollateralStatus.SOUND;\n        } else if (_whenDefault > block.timestamp) {\n            return CollateralStatus.IFFY;\n        } else {\n            return CollateralStatus.DISABLED;\n        }\n    }\n\n    // === Helpers for child classes ===\n\n    function markStatus(CollateralStatus status_) internal {\n        // untestable:\n        //      All calls to markStatus happen exclusively if the collateral is not defaulted\n        if (_whenDefault <= block.timestamp) return; // prevent DISABLED -> SOUND/IFFY\n\n        if (status_ == CollateralStatus.SOUND) {\n            _whenDefault = NEVER;\n        } else if (status_ == CollateralStatus.IFFY) {\n            uint256 sum = block.timestamp + uint256(delayUntilDefault);\n            // untestable:\n            //      constructor enforces max length on delayUntilDefault\n            if (sum >= NEVER) _whenDefault = NEVER;\n            else if (sum < _whenDefault) _whenDefault = uint48(sum);\n            // else: no change to _whenDefault\n            // untested:\n            //      explicit `if` to check DISABLED. else branch will never be hit\n        } else if (status_ == CollateralStatus.DISABLED) {\n            _whenDefault = uint48(block.timestamp);\n        }\n    }\n\n    function alreadyDefaulted() internal view returns (bool) {\n        return _whenDefault <= block.timestamp;\n    }\n\n    function whenDefault() external view returns (uint256) {\n        return _whenDefault;\n    }\n\n    // === End child helpers ===\n\n    /// @return {ref/tok} Quantity of whole reference units per whole collateral tokens\n    function refPerTok() public view virtual returns (uint192) {\n        return FIX_ONE;\n    }\n\n    /// @return {target/ref} Quantity of whole target units per whole reference unit in the peg\n    function targetPerRef() public view virtual returns (uint192) {\n        return FIX_ONE;\n    }\n\n    /// @return If the asset is an instance of ICollateral or not\n    function isCollateral() external pure virtual override(Asset, IAsset) returns (bool) {\n        return true;\n    }\n}"
    }
  ]
}