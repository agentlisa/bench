{
  "Title": "[L-02]",
  "Content": "<h2 id=\"l-02\" style=\"position:relative;\"><a href=\"#l-02\" aria-label=\"l 02 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02]</h2>\n<p>Itâ€™s possible to call the method <a href=\"https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L61\">createCollateralToken</a> multiple times with the same <code>_qTokenAddress</code>, if you call <code>createCollateralToken</code> with empty <code>_qTokenAddress</code> it will bypass the <a href=\"https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/CollateralToken.sol#L81\">require(idToInfo[id].qTokenAddress == address(0))</a>, and it will be possible to call again the <code>createCollateralToken</code> with different values. It will produce a mismatch with the reality and <code>collateralTokenIds</code>.</p>\n<p>It is mandatory to add a require to verify that the <code>_qTokenAddress</code> is not empty.</p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/options/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"../external/openzeppelin/ERC1155.sol\";\nimport \"../interfaces/ICollateralToken.sol\";\n\n/// @title Tokens representing a Quant user's short positions\n/// @author Rolla\n/// @notice Can be used by owners to claim their collateral\n/// @dev This is a multi-token contract that implements the ERC1155 token standard:\n/// https://eips.ethereum.org/EIPS/eip-1155\ncontract CollateralToken is ERC1155, ICollateralToken, EIP712 {\n    /// @dev stores metadata for a CollateralToken with an specific id\n    /// @param qTokenAddress address of the corresponding QToken\n    /// @param qTokenAsCollateral QToken address of an option used as collateral in a spread\n    struct CollateralTokenInfo {\n        address qTokenAddress;\n        address qTokenAsCollateral;\n    }\n\n    /// @inheritdoc ICollateralToken\n    IQuantConfig public override quantConfig;\n\n    /// @inheritdoc ICollateralToken\n    mapping(uint256 => CollateralTokenInfo) public override idToInfo;\n\n    /// @inheritdoc ICollateralToken\n    uint256[] public override collateralTokenIds;\n\n    // Signature nonce per address\n    mapping(address => uint256) public nonces;\n\n    // keccak256(\n    //     \"metaSetApprovalForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\"\n    // );\n    bytes32 private constant _META_APPROVAL_TYPEHASH =\n        0xf8f9aaf28cf20cd45b21061d07505fa1da285124284441ea655b9eb837ed89b7;\n\n    /// @notice Initializes a new ERC1155 multi-token contract for representing\n    /// users' short positions\n    /// @param _quantConfig the address of the Quant system configuration contract\n    /// @param _name name for the domain typehash in EIP712 meta transactions\n    /// @param _version version for the domain typehash in EIP712 meta transactions\n    /// @param uri_ URI for ERC1155 tokens metadata\n    constructor(\n        address _quantConfig,\n        string memory _name,\n        string memory _version,\n        string memory uri_\n    ) ERC1155(uri_) EIP712(_name, _version) {\n        require(\n            _quantConfig != address(0),\n            \"CollateralToken: invalid QuantConfig address\"\n        );\n\n        quantConfig = IQuantConfig(_quantConfig);\n    }\n\n    /// @inheritdoc ICollateralToken\n    function createCollateralToken(\n        address _qTokenAddress,\n        address _qTokenAsCollateral\n    ) external override returns (uint256 id) {\n        id = getCollateralTokenId(_qTokenAddress, _qTokenAsCollateral);\n\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_CREATOR_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral creator can create new CollateralTokens\"\n        );\n\n        require(\n            _qTokenAddress != _qTokenAsCollateral,\n            \"CollateralToken: Can only create a collateral token with different tokens\"\n        );\n\n        require(\n            idToInfo[id].qTokenAddress == address(0),\n            \"CollateralToken: this token has already been created\"\n        );\n\n        idToInfo[id] = CollateralTokenInfo({\n            qTokenAddress: _qTokenAddress,\n            qTokenAsCollateral: _qTokenAsCollateral\n        });\n\n        collateralTokenIds.push(id);\n\n        emit CollateralTokenCreated(\n            _qTokenAddress,\n            _qTokenAsCollateral,\n            id,\n            collateralTokenIds.length\n        );\n    }\n\n    /// @inheritdoc ICollateralToken\n    function mintCollateralToken(\n        address recipient,\n        uint256 collateralTokenId,\n        uint256 amount\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_MINTER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral minter can mint CollateralTokens\"\n        );\n\n        emit CollateralTokenMinted(recipient, collateralTokenId, amount);\n\n        _mint(recipient, collateralTokenId, amount, \"\");\n    }\n\n    /// @inheritdoc ICollateralToken\n    function burnCollateralToken(\n        address owner,\n        uint256 collateralTokenId,\n        uint256 amount\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_BURNER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral burner can burn CollateralTokens\"\n        );\n        _burn(owner, collateralTokenId, amount);\n\n        emit CollateralTokenBurned(owner, collateralTokenId, amount);\n    }\n\n    /// @inheritdoc ICollateralToken\n    function mintCollateralTokenBatch(\n        address recipient,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_MINTER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral minter can mint CollateralTokens\"\n        );\n\n        uint256 length = ids.length;\n        for (uint256 i = 0; i < length; ) {\n            emit CollateralTokenMinted(recipient, ids[i], amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        _mintBatch(recipient, ids, amounts, \"\");\n    }\n\n    /// @inheritdoc ICollateralToken\n    function burnCollateralTokenBatch(\n        address owner,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external override {\n        require(\n            quantConfig.hasRole(\n                quantConfig.quantRoles(\"COLLATERAL_BURNER_ROLE\"),\n                msg.sender\n            ),\n            \"CollateralToken: Only a collateral burner can burn CollateralTokens\"\n        );\n        _burnBatch(owner, ids, amounts);\n\n        uint256 length = ids.length;\n        for (uint256 i = 0; i < length; ) {\n            emit CollateralTokenBurned(owner, ids[i], amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc ICollateralToken\n    function metaSetApprovalForAll(\n        address owner,\n        address operator,\n        bool approved,\n        uint256 nonce,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        // solhint-disable-next-line not-rely-on-time\n        require(\n            block.timestamp <= deadline,\n            \"CollateralToken: expired deadline\"\n        );\n\n        require(nonce == nonces[owner], \"CollateralToken: invalid nonce\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _META_APPROVAL_TYPEHASH,\n                owner,\n                operator,\n                approved,\n                nonce,\n                deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ecrecover(hash, v, r, s);\n        require(signer == owner, \"CollateralToken: invalid signature\");\n\n        nonces[owner]++;\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /// @inheritdoc ICollateralToken\n    function getCollateralTokensLength()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return collateralTokenIds.length;\n    }\n\n    /// @inheritdoc ICollateralToken\n    function getCollateralTokenInfo(uint256 id)\n        external\n        view\n        override\n        returns (QTokensDetails memory qTokensDetails)\n    {\n        CollateralTokenInfo memory info = idToInfo[id];\n\n        require(\n            info.qTokenAddress != address(0),\n            \"CollateralToken: Invalid id\"\n        );\n\n        IQToken.QTokenInfo memory shortDetails = IQToken(info.qTokenAddress)\n            .getQTokenInfo();\n\n        qTokensDetails.underlyingAsset = shortDetails.underlyingAsset;\n        qTokensDetails.strikeAsset = shortDetails.strikeAsset;\n        qTokensDetails.oracle = shortDetails.oracle;\n        qTokensDetails.shortStrikePrice = shortDetails.strikePrice;\n        qTokensDetails.expiryTime = shortDetails.expiryTime;\n        qTokensDetails.isCall = shortDetails.isCall;\n\n        if (info.qTokenAsCollateral != address(0)) {\n            // the given id is for a CollateralToken representing a spread\n            qTokensDetails.longStrikePrice = IQToken(info.qTokenAsCollateral)\n                .strikePrice();\n        }\n    }\n\n    /// @inheritdoc ICollateralToken\n    function getCollateralTokenId(address _qToken, address _qTokenAsCollateral)\n        public\n        pure\n        override\n        returns (uint256 id)\n    {\n        id = uint256(keccak256(abi.encodePacked(_qToken, _qTokenAsCollateral)));\n    }\n}"
    }
  ]
}