{
  "Title": "Collision between constants",
  "Content": "The [`NS_POOL_MAX_STAKE`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L27) and [`NS_POOL_REWARD_TOKEN`](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/StakingPoolCoreLibV1.sol#L22) constants are defined to be the same string, which introduces the possibility of unexpected storage collisions. In the current code base they are used with non-overlapping data types, which are saved in different mappings. Nevertheless, in the interest of predictability, consider redefining the `NS_POOL_MAX_STAKE` constant to a unique string.\n\n\n**Update:** *Fixed as of commit `90f03dce0d24af3affc50d19ac81bbc12b524a4f` in [pull request #161](https://github.com/neptune-mutual-blue/protocol/pull/161).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/StakingPoolCoreLibV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\n/* solhint-disable ordering  */\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"./StoreKeyUtil.sol\";\nimport \"./ProtoUtilV1.sol\";\nimport \"./NTransferUtilV2.sol\";\n\nlibrary StakingPoolCoreLibV1 {\n  using StoreKeyUtil for IStore;\n  using NTransferUtilV2 for IERC20;\n\n  bytes32 public constant NS_POOL = \"ns:pool:staking\";\n  bytes32 public constant NS_POOL_NAME = \"ns:pool:staking:name\";\n  bytes32 public constant NS_POOL_LOCKED = \"ns:pool:staking:locked\";\n  bytes32 public constant NS_POOL_LOCKUP_PERIOD_IN_BLOCKS = \"ns:pool:staking:lockup:period\";\n  bytes32 public constant NS_POOL_STAKING_TARGET = \"ns:pool:staking:target\";\n  bytes32 public constant NS_POOL_CUMULATIVE_STAKING_AMOUNT = \"ns:pool:staking:cum:amount\";\n  bytes32 public constant NS_POOL_STAKING_TOKEN = \"ns:pool:staking:token\";\n  bytes32 public constant NS_POOL_STAKING_TOKEN_UNI_STABLECOIN_PAIR = \"ns:pool:staking:token:uni:pair\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN = \"ns:pool:reward:token\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN_UNI_STABLECOIN_PAIR = \"ns:pool:reward:token:uni:pair\";\n  bytes32 public constant NS_POOL_STAKING_TOKEN_BALANCE = \"ns:pool:staking:token:balance\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN_DEPOSITS = \"ns:pool:reward:token:deposits\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN_DISTRIBUTION = \"ns:pool:reward:token:distrib\";\n  bytes32 public constant NS_POOL_MAX_STAKE = \"ns:pool:reward:token\";\n  bytes32 public constant NS_POOL_REWARD_PER_BLOCK = \"ns:pool:reward:per:block\";\n  bytes32 public constant NS_POOL_REWARD_PLATFORM_FEE = \"ns:pool:reward:platform:fee\";\n  bytes32 public constant NS_POOL_REWARD_TOKEN_BALANCE = \"ns:pool:reward:token:balance\";\n\n  bytes32 public constant NS_POOL_DEPOSIT_HEIGHTS = \"ns:pool:deposit:heights\";\n  bytes32 public constant NS_POOL_REWARD_HEIGHTS = \"ns:pool:reward:heights\";\n  bytes32 public constant NS_POOL_TOTAL_REWARD_GIVEN = \"ns:pool:reward:total:given\";\n\n  /**\n   * @dev Reports the remaining amount of tokens that can be staked in this pool\n   */\n  function getAvailableToStakeInternal(IStore s, bytes32 key) external view returns (uint256) {\n    uint256 totalStaked = getTotalStaked(s, key);\n    uint256 target = getTarget(s, key);\n\n    if (totalStaked >= target) {\n      return 0;\n    }\n\n    return target - totalStaked;\n  }\n\n  function getTarget(IStore s, bytes32 key) public view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_STAKING_TARGET, key);\n  }\n\n  function getRewardPlatformFee(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_REWARD_PLATFORM_FEE, key);\n  }\n\n  function getTotalStaked(IStore s, bytes32 key) public view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_CUMULATIVE_STAKING_AMOUNT, key);\n  }\n\n  function getRewardPerBlock(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_REWARD_PER_BLOCK, key);\n  }\n\n  function getLockupPeriodInBlocks(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_LOCKUP_PERIOD_IN_BLOCKS, key);\n  }\n\n  function getRewardTokenBalance(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_REWARD_TOKEN_BALANCE, key);\n  }\n\n  function getMaximumStakeInternal(IStore s, bytes32 key) external view returns (uint256) {\n    return s.getUintByKeys(NS_POOL_MAX_STAKE, key);\n  }\n\n  function getStakingTokenAddressInternal(IStore s, bytes32 key) external view returns (address) {\n    return s.getAddressByKeys(NS_POOL_STAKING_TOKEN, key);\n  }\n\n  function getStakingTokenStablecoinPairAddressInternal(IStore s, bytes32 key) external view returns (address) {\n    return s.getAddressByKeys(NS_POOL_STAKING_TOKEN_UNI_STABLECOIN_PAIR, key);\n  }\n\n  function getRewardTokenAddressInternal(IStore s, bytes32 key) external view returns (address) {\n    return s.getAddressByKeys(NS_POOL_REWARD_TOKEN, key);\n  }\n\n  function getRewardTokenStablecoinPairAddressInternal(IStore s, bytes32 key) external view returns (address) {\n    return s.getAddressByKeys(NS_POOL_REWARD_TOKEN_UNI_STABLECOIN_PAIR, key);\n  }\n\n  function ensureValidStakingPool(IStore s, bytes32 key) external view {\n    require(checkIfStakingPoolExists(s, key), \"Pool invalid or closed\");\n  }\n\n  function checkIfStakingPoolExists(IStore s, bytes32 key) public view returns (bool) {\n    return s.getBoolByKeys(NS_POOL, key);\n  }\n\n  function validateAddOrEditPoolInternal(\n    IStore s,\n    bytes32 key,\n    string calldata name,\n    address[] calldata addresses,\n    uint256[] calldata values\n  ) public view returns (bool) {\n    require(key > 0, \"Invalid key\");\n\n    bool exists = checkIfStakingPoolExists(s, key);\n\n    if (exists == false) {\n      require(bytes(name).length > 0, \"Invalid name\");\n      require(addresses[0] != address(0), \"Invalid staking token\");\n      // require(addresses[1] != address(0), \"Invalid staking token pair\"); // A POD doesn't have any pair with stablecion\n      require(addresses[2] != address(0), \"Invalid reward token\");\n      require(addresses[3] != address(0), \"Invalid reward token pair\");\n      require(values[4] > 0, \"Provide lockup period in blocks\");\n      require(values[5] > 0, \"Provide reward token allocation\");\n      require(values[3] > 0, \"Provide reward per block\");\n      require(values[0] > 0, \"Please provide staking target\");\n    }\n\n    return exists;\n  }\n\n  /**\n   * @dev Adds or edits the pool by key\n   *\n   * @custom:suppress-malicious-erc Risk tolerable. The ERC-20 `addresses[1]`, `addresses[2]`, and `addresses[3]` can be trusted\n   * as these can be supplied only by an admin.\n   *\n   * @param key Enter the key of the pool you want to create or edit\n   * @param name Enter a name for this pool\n   * @param addresses[0] stakingToken The token which is staked in this pool\n   * @param addresses[1] uniStakingTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   * @param addresses[2] rewardToken The token which is rewarded in this pool\n   * @param addresses[3] uniRewardTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   * @param values[0] stakingTarget Specify the target amount in the staking token. You can not exceed the target.\n   * @param values[1] maxStake Specify the maximum amount that can be staken at a time.\n   * @param values[2] platformFee Enter the platform fee which is deducted on reward and on the reward token\n   * @param values[3] rewardPerBlock Specify the amount of reward token awarded per block\n   * @param values[4] lockupPeriodInBlocks Enter a lockup period during when the staked tokens can't be withdrawn\n   * @param values[5] rewardTokenDeposit Enter the value of reward token you are depositing in this transaction.\n   */\n  function addOrEditPoolInternal(\n    IStore s,\n    bytes32 key,\n    string calldata name,\n    address[] calldata addresses,\n    uint256[] calldata values\n  ) external {\n    // @suppress-zero-value-check The uint values are checked in the function `validateAddOrEditPoolInternal`\n    bool poolExists = validateAddOrEditPoolInternal(s, key, name, addresses, values);\n\n    if (poolExists == false) {\n      _initializeNewPool(s, key, addresses);\n    }\n\n    if (bytes(name).length > 0) {\n      s.setStringByKeys(NS_POOL, key, name);\n    }\n\n    _updatePoolValues(s, key, values);\n\n    // If `values[5] --> rewardTokenDeposit` is specified, the contract\n    // pulls the reward tokens to this contract address\n    if (values[5] > 0) {\n      IERC20(addresses[2]).ensureTransferFrom(msg.sender, address(this), values[5]);\n    }\n  }\n\n  /**\n   * @dev Updates the values of a staking pool by the given key\n   * @param s Provide an instance of the store\n   * @param key Enter the key of the pool you want to create or edit\n   * @param values[0] stakingTarget Specify the target amount in the staking token. You can not exceed the target.\n   * @param values[1] maxStake Specify the maximum amount that can be staken at a time.\n   * @param values[2] platformFee Enter the platform fee which is deducted on reward and on the reward token\n   * @param values[3] rewardPerBlock Specify the amount of reward token awarded per block\n   * @param values[4] lockupPeriodInBlocks Enter a lockup period during when the staked tokens can't be withdrawn\n   * @param values[5] rewardTokenDeposit Enter the value of reward token you are depositing in this transaction.\n   */\n  function _updatePoolValues(\n    IStore s,\n    bytes32 key,\n    uint256[] calldata values\n  ) private {\n    if (values[0] > 0) {\n      s.setUintByKeys(NS_POOL_STAKING_TARGET, key, values[0]);\n    }\n\n    if (values[1] > 0) {\n      s.setUintByKeys(NS_POOL_MAX_STAKE, key, values[1]);\n    }\n\n    if (values[2] > 0) {\n      s.setUintByKeys(NS_POOL_REWARD_PLATFORM_FEE, key, values[2]);\n    }\n\n    if (values[3] > 0) {\n      s.setUintByKeys(NS_POOL_REWARD_PER_BLOCK, key, values[3]);\n    }\n\n    if (values[4] > 0) {\n      s.setUintByKeys(NS_POOL_LOCKUP_PERIOD_IN_BLOCKS, key, values[4]);\n    }\n\n    if (values[5] > 0) {\n      s.addUintByKeys(NS_POOL_REWARD_TOKEN_DEPOSITS, key, values[5]);\n      s.addUintByKeys(NS_POOL_REWARD_TOKEN_BALANCE, key, values[5]);\n    }\n  }\n\n  /**\n   * @dev Initializes a new pool by the given key. Assumes that the pool does not exist.\n   *\n   * @custom:warning This feature should not be accessible outside of this library.\n   *\n   * @param s Provide an instance of the store\n   * @param key Enter the key of the pool you want to create or edit\n   * @param addresses[0] stakingToken The token which is staked in this pool\n   * @param addresses[1] uniStakingTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   * @param addresses[2] rewardToken The token which is rewarded in this pool\n   * @param addresses[3] uniRewardTokenDollarPair Enter a Uniswap stablecoin pair address of the staking token\n   *\n   */\n  function _initializeNewPool(\n    IStore s,\n    bytes32 key,\n    address[] calldata addresses\n  ) private {\n    s.setAddressByKeys(NS_POOL_STAKING_TOKEN, key, addresses[0]);\n    s.setAddressByKeys(NS_POOL_STAKING_TOKEN_UNI_STABLECOIN_PAIR, key, addresses[1]);\n    s.setAddressByKeys(NS_POOL_REWARD_TOKEN, key, addresses[2]);\n    s.setAddressByKeys(NS_POOL_REWARD_TOKEN_UNI_STABLECOIN_PAIR, key, addresses[3]);\n\n    s.setBoolByKeys(NS_POOL, key, true);\n  }\n}"
    }
  ]
}