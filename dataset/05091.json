{
  "Title": "[M-01] Exiting a farm on mainnet assumes a peg of `1:1`  when swapping stETH for ETH",
  "Content": "\nWhen stETH depegs from ETH, the swaps on Curve will revert due to requesting a higher `amountOut` than what the curves pool will give.\n\n### Proof of Concept\n\nWhen exiting a farm on mainnet, the requested `tokensOut` is set as `stETH` for redeeming the SY tokens on the `PENDLE_SY` contract. Once the `PowerFarm` has on its balance the `stETH` tokens, [it does a swap from stETH to ETH using the Curves protocol.](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L293-L308)\n\nThe problem is that the implementation is assuming a peg of `1 ETH ~= 1 stETH`. Even though both tokens have a tendency to keep the peg, this hasn't been always the case as it can be seen [in this dashboard](https://dune.com/LidoAnalytical/Curve-ETHstETH). There have been many episodes of market volatility that affected the price of stETH, notably the one in last June when stETH traded at `~0.93` ETH.\n\n[When computing the `_minOutAmount`](https://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol#L194-L199), the `PowerFarm` calculates the `ethValue` of the received stETH tokens by requesting the price of the `WETH` asset, and then it applies the `reverAllowedSpread` to finally determine the `_minOutAmount` of ETH tokens that will be accepted from the swap on Curves.\n\nThe WETH price is pegged `1:1` to ETH, 1 WETH will always be 1 ETH, but, using the price of WETH to determine the `minOutAmount` is problematic, because, as seen in the dashboard, historically, `1 stETH has deppeged from 1:1 from ETH`.\n\nExample: Assume a user sets a slippage of 1%. If stETH were to depeg to 0.95 per ETH, when swapping it would try to make sure that the user received at least 0.99 ETH. Whenever trying to swap it will revert because curves can't give the requested `minOutAmount` of ETH tokens, it could give at most 0.95 ETH per stETH.\n\n```\nfunction _logicClosePosition(\n    ...\n)\n    private\n{\n    ...\n\n    //@audit-info => When exiting a farm on mainnet, the `tokenOut` is set to be `stETH`\n    address tokenOut = block.chainid == 1\n        ? ST_ETH_ADDRESS\n        : ENTRY_ASSET;\n\n    ...\n\n    uint256 ethAmount = _getEthBack(\n        tokenOutAmount,\n        _getTokensInETH(\n            //@audit-info => When exiting a farm on mainnet, the price of the `tokenOut` is requested as if it were the price of `WETH`\n            //@audit-issue => Here is where the code assumes a peg of `1 stETH to be 1 ETH`\n            block.chainid == 1\n                ? WETH_ADDRESS\n                : ENTRY_ASSET,\n            tokenOutAmount\n        )\n            * reverseAllowedSpread\n            / PRECISION_FACTOR_E18\n    );\n\n    ...\n}\n\nfunction _getEthBack(\n    uint256 _swapAmount,\n    uint256 _minOutAmount\n)\n    internal\n    returns (uint256)\n{\n    if (block.chainid == ETH_CHAIN_ID) {\n        //@audit-info => Does a swap of stETH for ETH on the Curves exchange\n        return _swapStETHintoETH(\n            _swapAmount,\n            _minOutAmount\n        );\n    }\n\n    ...\n}\n\nfunction _swapStETHintoETH(\n    uint256 _swapAmount,\n    uint256 _minOutAmount\n)\n    internal\n    returns (uint256)\n{\n    return CURVE.exchange(\n        {\n            fromIndex: 1,\n            toIndex: 0,\n            exactAmountFrom: _swapAmount,\n            //@audit-info => minimum amount of ETH that the PowerFarm will accept for swapping `exactAmountFrom` of `stETH` tokens!\n            minReceiveAmount: _minOutAmount\n        }\n    );\n}\n\n```\n\n### Tools Used\n\nReferenced [H-06 finding on Asymmetry Finance Solodit audit](https://solodit.xyz/issues/h-06-wsteth-derivative-assumes-a-11-peg-of-steth-to-eth-code4rena-asymmetry-finance-asymmetry-contest-git) and Asymmetry's C4 mitigation review [here](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/13) and [here](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/40).\n\n### Recommended Mitigation Steps\n\nThe recommendation would be to implement a mitigation similar to the one implemented on the referenced issues.\nBasically, fetch the current price of `stETH` from a Chainlink Oracle and multiply the `minOutAmount` by the current price of `stETH`. In this way, the `minOutAmount` that is sent to the Curves exchange will now be within the correct limits based on the current price of stETH.\n\nAlso, make sure to multiply the `ethValueBefore` by the current price of stETH (only when exiting farms on mainnet). In this way, both amounts, `ethValueAfter` and `ethValueBefore` will be computed based on the current price of stETH, allowing the slippage to validate that no `ethValue` was lost during the process of removing liquidity from pendle, redeeming the sy tokens and swapping on curves. In the end, both, `ethValueAfter` and `ethValueBefore` will represent the `ethValue` based on the stETH price.\n\n### Assessed type\n\nContext\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/304#issuecomment-2006301592):**\n > Since we have `ethValueBefore` and after we could also set it to `0` and no harm done, thus invalid.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/304#issuecomment-2021072307):**\n > @vonMangoldt - Would need additional description for the issue described is not actually effective, as from my analysis I can't find a counter-example.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/304#issuecomment-2090371585):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n>\n>Additionally, the team decided to use `PendleRouter` ([here](https://github.com/pendle-finance/pendle-core/blob/master/contracts/core/PendleRouter.sol)) instead of `Curve` moving forward during farm exit.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmMathLogic.sol\";\n\nabstract contract PendlePowerFarmLeverageLogic is\n    PendlePowerFarmMathLogic,\n    IFlashLoanRecipient\n{\n    /**\n     * @dev Wrapper function preparing balancer flashloan and\n     * loading data to pass into receiver.\n     */\n    function _executeBalancerFlashLoan(\n        uint256 _nftId,\n        uint256 _flashAmount,\n        uint256 _initialAmount,\n        uint256 _lendingShares,\n        uint256 _borrowShares,\n        uint256 _allowedSpread,\n        bool _ethBack,\n        bool _isAave\n    )\n        internal\n    {\n        IERC20[] memory tokens = new IERC20[](1);\n        uint256[] memory amount = new uint256[](1);\n\n        address flashAsset = WETH_ADDRESS;\n\n        tokens[0] = IERC20(flashAsset);\n        amount[0] = _flashAmount;\n\n        allowEnter = true;\n\n        BALANCER_VAULT.flashLoan(\n            this,\n            tokens,\n            amount,\n            abi.encode(\n                _nftId,\n                _initialAmount,\n                _lendingShares,\n                _borrowShares,\n                _allowedSpread,\n                msg.sender,\n                _ethBack,\n                _isAave\n            )\n        );\n    }\n\n    /**\n     * @dev Receive function from balancer flashloan. Body\n     * is called from balancer at the end of their {flashLoan()}\n     * logic. Overwritten with opening flows.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory _flashloanToken,\n        uint256[] memory _flashloanAmounts,\n        uint256[] memory _feeAmounts,\n        bytes memory _userData\n    )\n        external\n    {\n        if (allowEnter == false) {\n            revert AccessDenied();\n        }\n\n        allowEnter = false;\n\n        if (_flashloanToken.length == 0) {\n            revert InvalidParam();\n        }\n\n        if (msg.sender != BALANCER_ADDRESS) {\n            revert NotBalancerVault();\n        }\n\n        uint256 totalDebtBalancer = _flashloanAmounts[0]\n            + _feeAmounts[0];\n\n        (\n            uint256 nftId,\n            uint256 initialAmount,\n            uint256 lendingShares,\n            uint256 borrowShares,\n            uint256 allowedSpread,\n            address caller,\n            bool ethBack,\n            bool isAave\n        ) = abi.decode(\n            _userData,\n            (\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                address,\n                bool,\n                bool\n            )\n        );\n\n        if (initialAmount > 0) {\n            _logicOpenPosition(\n                isAave,\n                nftId,\n                _flashloanAmounts[0] + initialAmount,\n                totalDebtBalancer,\n                allowedSpread\n            );\n\n            return;\n        }\n\n        _logicClosePosition(\n            nftId,\n            borrowShares,\n            lendingShares,\n            totalDebtBalancer,\n            allowedSpread,\n            caller,\n            ethBack,\n            isAave\n        );\n    }\n\n    /**\n     * @dev Closes position using balancer flashloans.\n     */\n    function _logicClosePosition(\n        uint256 _nftId,\n        uint256 _borrowShares,\n        uint256 _lendingShares,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread,\n        address _caller,\n        bool _ethBack,\n        bool _isAave\n    )\n        private\n    {\n        _paybackExactShares(\n            _isAave,\n            _nftId,\n            _borrowShares\n        );\n\n        uint256 withdrawnLpsAmount = _withdrawPendleLPs(\n            _nftId,\n            _lendingShares\n        );\n\n        uint256 ethValueBefore = _getTokensInETH(\n            PENDLE_CHILD,\n            withdrawnLpsAmount\n        );\n\n        (\n            uint256 netSyOut\n            ,\n        ) = PENDLE_ROUTER.removeLiquiditySingleSy(\n            {\n                _receiver: address(this),\n                _market: address(PENDLE_MARKET),\n                _netLpToRemove: withdrawnLpsAmount,\n                _minSyOut: 0\n            }\n        );\n\n        address tokenOut = block.chainid == 1\n            ? ST_ETH_ADDRESS\n            : ENTRY_ASSET;\n\n        uint256 tokenOutAmount = PENDLE_SY.redeem(\n            {\n                _receiver: address(this),\n                _amountSharesToRedeem: netSyOut,\n                _tokenOut: tokenOut,\n                _minTokenOut: 0,\n                _burnFromInternalBalance: false\n            }\n        );\n\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n\n        uint256 ethAmount = _getEthBack(\n            tokenOutAmount,\n            _getTokensInETH(\n                block.chainid == 1\n                    ? WETH_ADDRESS\n                    : ENTRY_ASSET,\n                tokenOutAmount\n            )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18\n        );\n\n        uint256 ethValueAfter = _getTokensInETH(\n            WETH_ADDRESS,\n            ethAmount\n        )\n            * _allowedSpread\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n\n        if (_ethBack == true) {\n            _closingRouteETH(\n                ethAmount,\n                _totalDebtBalancer,\n                _caller\n            );\n\n            return;\n        }\n\n        _closingRouteToken(\n            ethAmount,\n            _totalDebtBalancer,\n            _caller\n        );\n    }\n\n    function _getEthBack(\n        uint256 _swapAmount,\n        uint256 _minOutAmount\n    )\n        internal\n        returns (uint256)\n    {\n        if (block.chainid == ETH_CHAIN_ID) {\n            return _swapStETHintoETH(\n                _swapAmount,\n                _minOutAmount\n            );\n        }\n\n        if (block.chainid == ARB_CHAIN_ID) {\n            uint256 wethAmount = _getTokensUniV3(\n                _swapAmount,\n                _minOutAmount,\n                ENTRY_ASSET,\n                WETH_ADDRESS\n            );\n\n            _unwrapETH(\n                wethAmount\n            );\n\n            return wethAmount;\n        }\n\n        revert WrongChainId();\n    }\n\n    function _getTokensUniV3(\n        uint256 _amountIn,\n        uint256 _minOutAmount,\n        address _tokenIn,\n        address _tokenOut\n    )\n        internal\n        returns (uint256)\n    {\n        return UNISWAP_V3_ROUTER.exactInputSingle(\n            IUniswapV3.ExactInputSingleParams(\n                {\n                    tokenIn: _tokenIn,\n                    tokenOut: _tokenOut,\n                    fee: UNISWAP_V3_FEE,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: _amountIn,\n                    amountOutMinimum: _minOutAmount,\n                    sqrtPriceLimitX96: 0\n                }\n            )\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for curve swap\n     * of stETH into ETH.\n     */\n    function _swapStETHintoETH(\n        uint256 _swapAmount,\n        uint256 _minOutAmount\n    )\n        internal\n        returns (uint256)\n    {\n        return CURVE.exchange(\n            {\n                fromIndex: 1,\n                toIndex: 0,\n                exactAmountFrom: _swapAmount,\n                minReceiveAmount: _minOutAmount\n            }\n        );\n    }\n\n    function _withdrawPendleLPs(\n        uint256 _nftId,\n        uint256 _lendingShares\n    )\n        private\n        returns (uint256 withdrawnLpsAmount)\n    {\n        return IPendleChild(PENDLE_CHILD).withdrawExactShares(\n            WISE_LENDING.withdrawExactShares(\n                _nftId,\n                PENDLE_CHILD,\n                _lendingShares\n            )\n        );\n    }\n\n    function _paybackExactShares(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _borrowShares\n    )\n        internal\n    {\n        if (_isAave == true) {\n            AAVE_HUB.paybackExactShares(\n                _nftId,\n                WETH_ADDRESS,\n                _borrowShares\n            );\n\n            return;\n        }\n\n        WISE_LENDING.paybackExactShares(\n            _nftId,\n            WETH_ADDRESS,\n            _borrowShares\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for a closing route\n     * which returns {ENTRY_ASSET} to the owner in the end.\n     */\n    function _closingRouteToken(\n        uint256 _tokenAmount,\n        uint256 _totalDebtBalancer,\n        address _caller\n    )\n        private\n    {\n        _wrapETH(\n            _tokenAmount\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            msg.sender,\n            _totalDebtBalancer\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            _caller,\n            _tokenAmount\n                - _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for a closing route\n     * which returns ETH to the owner in the end.\n     */\n    function _closingRouteETH(\n        uint256 _ethAmount,\n        uint256 _totalDebtBalancer,\n        address _caller\n    )\n        internal\n    {\n        _wrapETH(\n            _totalDebtBalancer\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            msg.sender,\n            _totalDebtBalancer\n        );\n\n        _sendValue(\n            _caller,\n            _ethAmount\n                - _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal function executing the\n     * collateral deposit by converting ETH\n     * into {ENTRY_ASSET}, adding it as collateral and\n     * borrowing the flashloan token to pay\n     * back {_totalDebtBalancer}.\n     */\n    function _logicOpenPosition(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _depositAmount,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread\n    )\n        internal\n    {\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n\n        if (block.chainid == ARB_CHAIN_ID) {\n\n            _depositAmount = _getTokensUniV3(\n                _depositAmount,\n                _getEthInTokens(\n                        ENTRY_ASSET,\n                        _depositAmount\n                    )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18,\n                WETH_ADDRESS,\n                ENTRY_ASSET\n            );\n        }\n\n        uint256 syReceived = PENDLE_SY.deposit(\n            {\n                _receiver: address(this),\n                _tokenIn: ENTRY_ASSET,\n                _amountTokenToDeposit: _depositAmount,\n                _minSharesOut: PENDLE_SY.previewDeposit(\n                    ENTRY_ASSET,\n                    _depositAmount\n                )\n            }\n        );\n\n        (   ,\n            uint256 netPtFromSwap,\n            ,\n            ,\n            ,\n        ) = PENDLE_ROUTER_STATIC.addLiquiditySingleSyStatic(\n            address(PENDLE_MARKET),\n            syReceived\n        );\n\n        (\n            uint256 netLpOut\n            ,\n        ) = PENDLE_ROUTER.addLiquiditySingleSy(\n            {\n                _receiver: address(this),\n                _market: address(PENDLE_MARKET),\n                _netSyIn: syReceived,\n                _minLpOut: 0,\n                _guessPtReceivedFromSy: ApproxParams(\n                    {\n                        guessMin: netPtFromSwap - 100,\n                        guessMax: netPtFromSwap + 100,\n                        guessOffchain: 0,\n                        maxIteration: 50,\n                        eps: 1e15\n                    }\n                )\n            }\n        );\n\n        uint256 ethValueBefore = _getTokensInETH(\n            ENTRY_ASSET,\n            _depositAmount\n        );\n\n        (\n            uint256 receivedShares\n            ,\n        ) = IPendleChild(PENDLE_CHILD).depositExactAmount(\n            netLpOut\n        );\n\n        uint256 ethValueAfter = _getTokensInETH(\n            PENDLE_CHILD,\n            receivedShares\n        )\n            * _allowedSpread\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n\n        WISE_LENDING.depositExactAmount(\n            _nftId,\n            PENDLE_CHILD,\n            receivedShares\n        );\n\n        _borrowExactAmount(\n            _isAave,\n            _nftId,\n            _totalDebtBalancer\n        );\n\n        if (_checkDebtRatio(_nftId) == false) {\n            revert DebtRatioTooHigh();\n        }\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            BALANCER_ADDRESS,\n            _totalDebtBalancer\n        );\n    }\n\n    function _borrowExactAmount(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _totalDebtBalancer\n    )\n        internal\n    {\n        if (_isAave == true) {\n            AAVE_HUB.borrowExactAmount(\n                _nftId,\n                WETH_ADDRESS,\n                _totalDebtBalancer\n            );\n\n            return;\n        }\n\n        WISE_LENDING.borrowExactAmount(\n            _nftId,\n            WETH_ADDRESS,\n            _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal function summarizing liquidation\n     * checks and interface call for core liquidation\n     * from wise lending.\n     */\n    function _coreLiquidation(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        uint256 _shareAmountToPay\n    )\n        internal\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        if (_checkDebtRatio(_nftId) == true) {\n            revert DebtRatioTooLow();\n        }\n\n        address paybackToken = isAave[_nftId] == true\n            ? AAVE_WETH_ADDRESS\n            : WETH_ADDRESS;\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            paybackToken,\n            _shareAmountToPay\n        );\n\n        uint256 cutoffShares = isAave[_nftId] == true\n            ? _getPositionBorrowSharesAave(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18\n            : _getPositionBorrowShares(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay > cutoffShares) {\n            revert TooMuchShares();\n        }\n\n        receivingAmount = WISE_LENDING.coreLiquidationIsolationPools(\n            _nftId,\n            _nftIdLiquidator,\n            msg.sender,\n            paybackToken,\n            PENDLE_CHILD,\n            paybackAmount,\n            _shareAmountToPay\n        );\n    }\n}"
    },
    {
      "filename": "contracts/PowerFarms/PendlePowerFarm/PendlePowerFarmLeverageLogic.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./PendlePowerFarmMathLogic.sol\";\n\nabstract contract PendlePowerFarmLeverageLogic is\n    PendlePowerFarmMathLogic,\n    IFlashLoanRecipient\n{\n    /**\n     * @dev Wrapper function preparing balancer flashloan and\n     * loading data to pass into receiver.\n     */\n    function _executeBalancerFlashLoan(\n        uint256 _nftId,\n        uint256 _flashAmount,\n        uint256 _initialAmount,\n        uint256 _lendingShares,\n        uint256 _borrowShares,\n        uint256 _allowedSpread,\n        bool _ethBack,\n        bool _isAave\n    )\n        internal\n    {\n        IERC20[] memory tokens = new IERC20[](1);\n        uint256[] memory amount = new uint256[](1);\n\n        address flashAsset = WETH_ADDRESS;\n\n        tokens[0] = IERC20(flashAsset);\n        amount[0] = _flashAmount;\n\n        allowEnter = true;\n\n        BALANCER_VAULT.flashLoan(\n            this,\n            tokens,\n            amount,\n            abi.encode(\n                _nftId,\n                _initialAmount,\n                _lendingShares,\n                _borrowShares,\n                _allowedSpread,\n                msg.sender,\n                _ethBack,\n                _isAave\n            )\n        );\n    }\n\n    /**\n     * @dev Receive function from balancer flashloan. Body\n     * is called from balancer at the end of their {flashLoan()}\n     * logic. Overwritten with opening flows.\n     */\n    function receiveFlashLoan(\n        IERC20[] memory _flashloanToken,\n        uint256[] memory _flashloanAmounts,\n        uint256[] memory _feeAmounts,\n        bytes memory _userData\n    )\n        external\n    {\n        if (allowEnter == false) {\n            revert AccessDenied();\n        }\n\n        allowEnter = false;\n\n        if (_flashloanToken.length == 0) {\n            revert InvalidParam();\n        }\n\n        if (msg.sender != BALANCER_ADDRESS) {\n            revert NotBalancerVault();\n        }\n\n        uint256 totalDebtBalancer = _flashloanAmounts[0]\n            + _feeAmounts[0];\n\n        (\n            uint256 nftId,\n            uint256 initialAmount,\n            uint256 lendingShares,\n            uint256 borrowShares,\n            uint256 allowedSpread,\n            address caller,\n            bool ethBack,\n            bool isAave\n        ) = abi.decode(\n            _userData,\n            (\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                uint256,\n                address,\n                bool,\n                bool\n            )\n        );\n\n        if (initialAmount > 0) {\n            _logicOpenPosition(\n                isAave,\n                nftId,\n                _flashloanAmounts[0] + initialAmount,\n                totalDebtBalancer,\n                allowedSpread\n            );\n\n            return;\n        }\n\n        _logicClosePosition(\n            nftId,\n            borrowShares,\n            lendingShares,\n            totalDebtBalancer,\n            allowedSpread,\n            caller,\n            ethBack,\n            isAave\n        );\n    }\n\n    /**\n     * @dev Closes position using balancer flashloans.\n     */\n    function _logicClosePosition(\n        uint256 _nftId,\n        uint256 _borrowShares,\n        uint256 _lendingShares,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread,\n        address _caller,\n        bool _ethBack,\n        bool _isAave\n    )\n        private\n    {\n        _paybackExactShares(\n            _isAave,\n            _nftId,\n            _borrowShares\n        );\n\n        uint256 withdrawnLpsAmount = _withdrawPendleLPs(\n            _nftId,\n            _lendingShares\n        );\n\n        uint256 ethValueBefore = _getTokensInETH(\n            PENDLE_CHILD,\n            withdrawnLpsAmount\n        );\n\n        (\n            uint256 netSyOut\n            ,\n        ) = PENDLE_ROUTER.removeLiquiditySingleSy(\n            {\n                _receiver: address(this),\n                _market: address(PENDLE_MARKET),\n                _netLpToRemove: withdrawnLpsAmount,\n                _minSyOut: 0\n            }\n        );\n\n        address tokenOut = block.chainid == 1\n            ? ST_ETH_ADDRESS\n            : ENTRY_ASSET;\n\n        uint256 tokenOutAmount = PENDLE_SY.redeem(\n            {\n                _receiver: address(this),\n                _amountSharesToRedeem: netSyOut,\n                _tokenOut: tokenOut,\n                _minTokenOut: 0,\n                _burnFromInternalBalance: false\n            }\n        );\n\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n\n        uint256 ethAmount = _getEthBack(\n            tokenOutAmount,\n            _getTokensInETH(\n                block.chainid == 1\n                    ? WETH_ADDRESS\n                    : ENTRY_ASSET,\n                tokenOutAmount\n            )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18\n        );\n\n        uint256 ethValueAfter = _getTokensInETH(\n            WETH_ADDRESS,\n            ethAmount\n        )\n            * _allowedSpread\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n\n        if (_ethBack == true) {\n            _closingRouteETH(\n                ethAmount,\n                _totalDebtBalancer,\n                _caller\n            );\n\n            return;\n        }\n\n        _closingRouteToken(\n            ethAmount,\n            _totalDebtBalancer,\n            _caller\n        );\n    }\n\n    function _getEthBack(\n        uint256 _swapAmount,\n        uint256 _minOutAmount\n    )\n        internal\n        returns (uint256)\n    {\n        if (block.chainid == ETH_CHAIN_ID) {\n            return _swapStETHintoETH(\n                _swapAmount,\n                _minOutAmount\n            );\n        }\n\n        if (block.chainid == ARB_CHAIN_ID) {\n            uint256 wethAmount = _getTokensUniV3(\n                _swapAmount,\n                _minOutAmount,\n                ENTRY_ASSET,\n                WETH_ADDRESS\n            );\n\n            _unwrapETH(\n                wethAmount\n            );\n\n            return wethAmount;\n        }\n\n        revert WrongChainId();\n    }\n\n    function _getTokensUniV3(\n        uint256 _amountIn,\n        uint256 _minOutAmount,\n        address _tokenIn,\n        address _tokenOut\n    )\n        internal\n        returns (uint256)\n    {\n        return UNISWAP_V3_ROUTER.exactInputSingle(\n            IUniswapV3.ExactInputSingleParams(\n                {\n                    tokenIn: _tokenIn,\n                    tokenOut: _tokenOut,\n                    fee: UNISWAP_V3_FEE,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: _amountIn,\n                    amountOutMinimum: _minOutAmount,\n                    sqrtPriceLimitX96: 0\n                }\n            )\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for curve swap\n     * of stETH into ETH.\n     */\n    function _swapStETHintoETH(\n        uint256 _swapAmount,\n        uint256 _minOutAmount\n    )\n        internal\n        returns (uint256)\n    {\n        return CURVE.exchange(\n            {\n                fromIndex: 1,\n                toIndex: 0,\n                exactAmountFrom: _swapAmount,\n                minReceiveAmount: _minOutAmount\n            }\n        );\n    }\n\n    function _withdrawPendleLPs(\n        uint256 _nftId,\n        uint256 _lendingShares\n    )\n        private\n        returns (uint256 withdrawnLpsAmount)\n    {\n        return IPendleChild(PENDLE_CHILD).withdrawExactShares(\n            WISE_LENDING.withdrawExactShares(\n                _nftId,\n                PENDLE_CHILD,\n                _lendingShares\n            )\n        );\n    }\n\n    function _paybackExactShares(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _borrowShares\n    )\n        internal\n    {\n        if (_isAave == true) {\n            AAVE_HUB.paybackExactShares(\n                _nftId,\n                WETH_ADDRESS,\n                _borrowShares\n            );\n\n            return;\n        }\n\n        WISE_LENDING.paybackExactShares(\n            _nftId,\n            WETH_ADDRESS,\n            _borrowShares\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for a closing route\n     * which returns {ENTRY_ASSET} to the owner in the end.\n     */\n    function _closingRouteToken(\n        uint256 _tokenAmount,\n        uint256 _totalDebtBalancer,\n        address _caller\n    )\n        private\n    {\n        _wrapETH(\n            _tokenAmount\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            msg.sender,\n            _totalDebtBalancer\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            _caller,\n            _tokenAmount\n                - _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal wrapper function for a closing route\n     * which returns ETH to the owner in the end.\n     */\n    function _closingRouteETH(\n        uint256 _ethAmount,\n        uint256 _totalDebtBalancer,\n        address _caller\n    )\n        internal\n    {\n        _wrapETH(\n            _totalDebtBalancer\n        );\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            msg.sender,\n            _totalDebtBalancer\n        );\n\n        _sendValue(\n            _caller,\n            _ethAmount\n                - _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal function executing the\n     * collateral deposit by converting ETH\n     * into {ENTRY_ASSET}, adding it as collateral and\n     * borrowing the flashloan token to pay\n     * back {_totalDebtBalancer}.\n     */\n    function _logicOpenPosition(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _depositAmount,\n        uint256 _totalDebtBalancer,\n        uint256 _allowedSpread\n    )\n        internal\n    {\n        uint256 reverseAllowedSpread = 2\n            * PRECISION_FACTOR_E18\n            - _allowedSpread;\n\n        if (block.chainid == ARB_CHAIN_ID) {\n\n            _depositAmount = _getTokensUniV3(\n                _depositAmount,\n                _getEthInTokens(\n                        ENTRY_ASSET,\n                        _depositAmount\n                    )\n                * reverseAllowedSpread\n                / PRECISION_FACTOR_E18,\n                WETH_ADDRESS,\n                ENTRY_ASSET\n            );\n        }\n\n        uint256 syReceived = PENDLE_SY.deposit(\n            {\n                _receiver: address(this),\n                _tokenIn: ENTRY_ASSET,\n                _amountTokenToDeposit: _depositAmount,\n                _minSharesOut: PENDLE_SY.previewDeposit(\n                    ENTRY_ASSET,\n                    _depositAmount\n                )\n            }\n        );\n\n        (   ,\n            uint256 netPtFromSwap,\n            ,\n            ,\n            ,\n        ) = PENDLE_ROUTER_STATIC.addLiquiditySingleSyStatic(\n            address(PENDLE_MARKET),\n            syReceived\n        );\n\n        (\n            uint256 netLpOut\n            ,\n        ) = PENDLE_ROUTER.addLiquiditySingleSy(\n            {\n                _receiver: address(this),\n                _market: address(PENDLE_MARKET),\n                _netSyIn: syReceived,\n                _minLpOut: 0,\n                _guessPtReceivedFromSy: ApproxParams(\n                    {\n                        guessMin: netPtFromSwap - 100,\n                        guessMax: netPtFromSwap + 100,\n                        guessOffchain: 0,\n                        maxIteration: 50,\n                        eps: 1e15\n                    }\n                )\n            }\n        );\n\n        uint256 ethValueBefore = _getTokensInETH(\n            ENTRY_ASSET,\n            _depositAmount\n        );\n\n        (\n            uint256 receivedShares\n            ,\n        ) = IPendleChild(PENDLE_CHILD).depositExactAmount(\n            netLpOut\n        );\n\n        uint256 ethValueAfter = _getTokensInETH(\n            PENDLE_CHILD,\n            receivedShares\n        )\n            * _allowedSpread\n            / PRECISION_FACTOR_E18;\n\n        if (ethValueAfter < ethValueBefore) {\n            revert TooMuchValueLost();\n        }\n\n        WISE_LENDING.depositExactAmount(\n            _nftId,\n            PENDLE_CHILD,\n            receivedShares\n        );\n\n        _borrowExactAmount(\n            _isAave,\n            _nftId,\n            _totalDebtBalancer\n        );\n\n        if (_checkDebtRatio(_nftId) == false) {\n            revert DebtRatioTooHigh();\n        }\n\n        _safeTransfer(\n            WETH_ADDRESS,\n            BALANCER_ADDRESS,\n            _totalDebtBalancer\n        );\n    }\n\n    function _borrowExactAmount(\n        bool _isAave,\n        uint256 _nftId,\n        uint256 _totalDebtBalancer\n    )\n        internal\n    {\n        if (_isAave == true) {\n            AAVE_HUB.borrowExactAmount(\n                _nftId,\n                WETH_ADDRESS,\n                _totalDebtBalancer\n            );\n\n            return;\n        }\n\n        WISE_LENDING.borrowExactAmount(\n            _nftId,\n            WETH_ADDRESS,\n            _totalDebtBalancer\n        );\n    }\n\n    /**\n     * @dev Internal function summarizing liquidation\n     * checks and interface call for core liquidation\n     * from wise lending.\n     */\n    function _coreLiquidation(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        uint256 _shareAmountToPay\n    )\n        internal\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        if (_checkDebtRatio(_nftId) == true) {\n            revert DebtRatioTooLow();\n        }\n\n        address paybackToken = isAave[_nftId] == true\n            ? AAVE_WETH_ADDRESS\n            : WETH_ADDRESS;\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            paybackToken,\n            _shareAmountToPay\n        );\n\n        uint256 cutoffShares = isAave[_nftId] == true\n            ? _getPositionBorrowSharesAave(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18\n            : _getPositionBorrowShares(_nftId)\n                * FIVTY_PERCENT\n                / PRECISION_FACTOR_E18;\n\n        if (_shareAmountToPay > cutoffShares) {\n            revert TooMuchShares();\n        }\n\n        receivingAmount = WISE_LENDING.coreLiquidationIsolationPools(\n            _nftId,\n            _nftIdLiquidator,\n            msg.sender,\n            paybackToken,\n            PENDLE_CHILD,\n            paybackAmount,\n            _shareAmountToPay\n        );\n    }\n}"
    }
  ]
}