{
  "Title": "[G-21] Length of `_encoded` is calculated twice in `validateL1ToL2Transaction` in `TransactionValidator.sol`.",
  "Content": "\nCalculating length is gas-costly operation. It's better to calculate it once and store it in local variable.\n\n[File: ethereum/contracts/zksync/libraries/TransactionValidator.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/TransactionValidator.sol#L23-L43)\n\n```\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(\n            _transaction.gasLimit,\n            _transaction.gasPerPubdataByteLimit,\n            _encoded.length\n        );\n\n(...)\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= _transaction.gasLimit,\n            \"up\"\n        );\n```\n\n`_encoded.length` is being calculated twice - in line 26 and line 38.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/zksync/libraries/TransactionValidator.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../interfaces/IMailbox.sol\";\nimport \"../Config.sol\";\n\n/// @title zkSync Library for validating L1 -> L2 transactions\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\nlibrary TransactionValidator {\n    /// @dev Used to validate key properties of an L1->L2 transaction\n    /// @param _transaction The transaction to validate\n    /// @param _encoded The abi encoded bytes of the transaction\n    /// @param _priorityTxMaxGasLimit The max gas limit, generally provided from Storage.sol\n    function validateL1ToL2Transaction(\n        IMailbox.L2CanonicalTransaction memory _transaction,\n        bytes memory _encoded,\n        uint256 _priorityTxMaxGasLimit\n    ) internal pure {\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(\n            _transaction.gasLimit,\n            _transaction.gasPerPubdataByteLimit,\n            _encoded.length\n        );\n\n        // Ensuring that the transaction is provable\n        require(l2GasForTxBody <= _priorityTxMaxGasLimit, \"ui\");\n        // Ensuring that the transaction cannot output more pubdata than is processable\n        require(l2GasForTxBody / _transaction.gasPerPubdataByteLimit <= PRIORITY_TX_MAX_PUBDATA, \"uk\");\n\n        // Ensuring that the transaction covers the minimal costs for its processing:\n        // hashing its content, publishing the factory dependencies, etc.\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= _transaction.gasLimit,\n            \"up\"\n        );\n    }\n\n    /// @dev Used to validate upgrade transactions\n    /// @param _transaction The transaction to validate\n    function validateUpgradeTransaction(IMailbox.L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, \"ua\");\n        require(_transaction.to <= type(uint160).max, \"ub\");\n        require(_transaction.paymaster == 0, \"uc\");\n        require(_transaction.value == 0, \"ud\");\n        require(_transaction.reserved[0] == 0, \"ue\");\n        require(_transaction.reserved[1] <= type(uint160).max, \"uf\");\n        require(_transaction.reserved[2] == 0, \"ug\");\n        require(_transaction.reserved[3] == 0, \"uo\");\n        require(_transaction.signature.length == 0, \"uh\");\n        require(_transaction.paymasterInput.length == 0, \"ul\");\n        require(_transaction.reservedDynamic.length == 0, \"um\");\n    }\n\n    /// @dev Calculates the approximate minimum gas limit required for executing a priority transaction.\n    /// @param _encodingLength The length of the priority transaction encoding in bytes.\n    /// @param _numberOfFactoryDependencies The number of new factory dependencies that will be added.\n    /// @param _l2GasPricePerPubdata The L2 gas price for publishing the priority transaction on L2.\n    /// @return The minimum gas limit required to execute the priority transaction.\n    /// Note: The calculation includes the main cost of the priority transaction, however, in reality, the operator can spend a little more gas on overheads.\n    function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        uint256 costForComputation;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxiliary prices which cannot be easily accounted for\n            costForComputation = L1_TX_INTRINSIC_L2_GAS;\n\n            // Taking into account the hashing costs that depend on the length of the transaction\n            // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n            // the transaction's encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n            // and the size of each new encoding word).\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n\n            // Taking into the account the additional costs of providing new factory dependenies\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n\n            // There is a minimal amount of computational L2 gas that the transaction should cover\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n        }\n\n        uint256 costForPubdata = 0;\n        {\n            // Adding the intrinsic cost for the transaction, i.e. auxilary prices which cannot be easily accounted for\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n\n            // Taking into the account the additional costs of providing new factory dependenies\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n        }\n\n        return costForComputation + costForPubdata;\n    }\n\n    /// @notice Based on the full L2 gas limit (that includes the batch overhead) and other\n    /// properties of the transaction, returns the l2GasLimit for the body of the transaction (the actual execution).\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual l2GasLimit that will be used for the transaction).\n    /// @param _gasPricePerPubdata The L2 gas price for each byte of pubdata.\n    /// @param _encodingLength The length of the ABI-encoding of the transaction.\n    function getTransactionBodyGasLimit(\n        uint256 _totalGasLimit,\n        uint256 _gasPricePerPubdata,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 txBodyGasLimit) {\n        uint256 overhead = getOverheadForTransaction(_totalGasLimit, _gasPricePerPubdata, _encodingLength);\n\n        require(_totalGasLimit >= overhead, \"my\"); // provided gas limit doesn't cover transaction overhead\n        unchecked {\n            // We enforce the fact that `_totalGasLimit >= overhead` explicitly above.\n            txBodyGasLimit = _totalGasLimit - overhead;\n        }\n    }\n\n    /// @notice Based on the total L2 gas limit and several other parameters of the transaction\n    /// returns the part of the L2 gas that will be spent on the batch's overhead.\n    /// @dev The details of how this function works can be checked in the documentation\n    /// of the fee model of zkSync. The appropriate comments are also present\n    /// in the Rust implementation description of function `get_maximal_allowed_overhead`.\n    /// @param _totalGasLimit The L2 gas limit that includes both the overhead for processing the batch\n    /// and the L2 gas needed to process the transaction itself (i.e. the actual gasLimit that will be used for the transaction).\n    /// @param _gasPricePerPubdata The maximum amount of L2 gas that the operator may charge the user for a single byte of pubdata.\n    /// @param _encodingLength The length of the binary encoding of the transaction in bytes\n    function getOverheadForTransaction(\n        uint256 _totalGasLimit,\n        uint256 _gasPricePerPubdata,\n        uint256 _encodingLength\n    ) internal pure returns (uint256 batchOverheadForTransaction) {\n        uint256 batchOverheadGas = BATCH_OVERHEAD_L2_GAS + BATCH_OVERHEAD_PUBDATA * _gasPricePerPubdata;\n\n        // The overhead from taking up the transaction's slot\n        uint256 txSlotOverhead = Math.ceilDiv(batchOverheadGas, MAX_TRANSACTIONS_IN_BATCH);\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, txSlotOverhead);\n\n        // The overhead for occupying the bootloader memory can be derived from encoded_len\n        uint256 overheadForLength = Math.ceilDiv(_encodingLength * batchOverheadGas, BOOTLOADER_TX_ENCODING_SPACE);\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n\n        // The overhead for possible published public data\n        // TODO: possibly charge a separate fee for possible pubdata spending\n        // uint256 overheadForPublicData;\n        // {\n        //     uint256 numerator = (batchOverheadGas * _totalGasLimit + _gasPricePerPubdata * MAX_PUBDATA_PER_BATCH);\n        //     uint256 denominator = (_gasPricePerPubdata * MAX_PUBDATA_PER_BATCH + batchOverheadGas);\n\n        //     overheadForPublicData = (numerator - 1) / denominator;\n        // }\n        // batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForPublicData);\n\n        // The overhead for ergs that could be used to use single-instance circuits\n        uint256 overheadForGas;\n        {\n            uint256 numerator = batchOverheadGas * _totalGasLimit + L2_TX_MAX_GAS_LIMIT;\n            uint256 denominator = L2_TX_MAX_GAS_LIMIT + batchOverheadGas;\n\n            overheadForGas = (numerator - 1) / denominator;\n        }\n        batchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForGas);\n    }\n}"
    }
  ]
}