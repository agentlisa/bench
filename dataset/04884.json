{
  "Title": "[04] `slash()` is vulnerable to `lockAndBurn()` racing, accounting of consecutive slashes might be inconsistent",
  "Content": "\nIn normal circumstances, consecutive slash amounts will be rolled over. For example, Alice is slashed in round 1. If Alice is slashed again in round 2, the slash amount from round 1 will be rolled over in round 2. See [this doc](https://github.com/code-423n4/2024-03-gitcoin/blob/main/id-staking-v2/README.md#appendix-b-slashing-in-consecutive-rounds).\n\nHowever, the above behavior cannot be guaranteed due to a possible permissionless `lockAndBurn()` racing. \nWhen `slash()` on round 2 is settled before `lockAndBurn()`. The doc-described behavior is preserved:\n\n```solidity\n  function slash(\n    address[] calldata selfStakers,\n    address[] calldata communityStakers,\n    address[] calldata communityStakees,\n    uint88 percent\n  ) external onlyRole(SLASHER_ROLE) whenNotPaused {\n...\n      if (sStake.slashedInRound != 0 && sStake.slashedInRound != currentSlashRound) {\n          //@audit this if body will run when `slash()` settles before `lockAndBurn()`\n|>        if (sStake.slashedInRound == currentSlashRound - 1) {\n          // If this is a slash from the previous round (not yet burned), move\n          // it to the current round\n          totalSlashed[currentSlashRound - 1] -= sStake.slashedAmount;\n          totalSlashed[currentSlashRound] += sStake.slashedAmount;\n```\n\nhttps://github.com/code-423n4/2024-03-gitcoin/blob/6529b351cd72a858541f60c52f0e5ad0fb6f1b16/id-staking-v2/contracts/IdentityStaking.sol#L448\n\nBut if `lockAndBurn()` settles first, the staked amount of `sStake.slashedInRound` from round 1 will be burned, and the slash amount from round 2 will be counted in round 3 even though the `slash()` is submitted in round 2.\n\n```solidity\n  function slash(\n    address[] calldata selfStakers,\n    address[] calldata communityStakers,\n    address[] calldata communityStakees,\n    uint88 percent\n  ) external onlyRole(SLASHER_ROLE) whenNotPaused {\n...\n      if (sStake.slashedInRound != 0 && sStake.slashedInRound != currentSlashRound) {\n        if (sStake.slashedInRound == currentSlashRound - 1) {\n...\n        } else {\n          //@audit else body will run if lockAndburn settles before slash()\n          // Otherwise, this is a stale slash and can be overwritten\n|>          sStake.slashedAmount = 0;\n        }\n...\n```\n\nhttps://github.com/code-423n4/2024-03-gitcoin/blob/6529b351cd72a858541f60c52f0e5ad0fb6f1b16/id-staking-v2/contracts/IdentityStaking.sol#L455\n\nAs seen above, `slash()` submitted close to the end of a round(90 days `burnRoundMinimumDuration`), might be counted either at the next round or current round due to potential `lockAndBurn` racing.  When `slash()` settles at the next round, the user's previous round slash amount will not be rolled over, and the slash amount will be directly burned instead of being preserved for the next round.\n\n### Recommendation\n\nConsider having `lockAndBurn()` access controlled by the protocol to ensure `slash()` and `lockAndBurn()` settle in the correct order.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-gitcoin",
  "Code": [
    {
      "filename": "id-staking-v2/README.md",
      "content": "# Identity Staking V2\n\nThis repo contains the Identity Staking V2 contract. These were the goals when\nwriting this contract:\n\n- Allow users to stake on themselves and others for a given duration\n- Make staking and re-staking as gas-efficient as possible\n- Be able to determine the total GTC staked by a user (self + community)\n- Allow slashing of users who commit slash-able offenses\n- Allow slashing to be appealed, with a minimum appeal period of 90 days\n- Allow successfully appealed GTC to be released\n- GTC staked in this contract should only possibly be able to be...\n    1. Held by the contract (staked or frozen)\n    2. Burned\n    3. Returned to the original owner\n- Slashing, burning, and releasing must be gas-efficient enough to be practical\n- Events should be emitted to allow simple indexing of all activity\n\n## Table of Contents\n\n1. [Working with the repo](#working-with-the-repo)\n2. [IdentityStaking.sol](#identitystakingsol)\n    1. [Methods](#methods)\n    2. [Events](#events)\n    3. [State](#state)\n    4. [Appendix A: Slashing Rounds](#appendix-a-slashing-rounds)\n    5. [Appendix B: Slashing in Consecutive Rounds](#appendix-b-slashing-in-consecutive-rounds)\n    6. [Appendix C: Diagrams](#appendix-c-diagrams)\n    7. [Appendix D: Security](#appendix-d-security)\n3. [IIdentityStaking.sol](#iidentitystakingsol)\n\n## Working with the repo\n\n```shell\nREPORT_GAS=true npx hardhat test\nnpx hardhat run scripts/deploy.ts --network <network>\n```\n\n## IdentityStaking.sol\n\n### Methods\n\n#### selfStake\n\n```solidity\nfunction selfStake(uint88 amount, uint64 duration) external whenNotPaused;\n```\n\nAdd `amount` GTC to your stake on yourself. Minimum `duration` is 12 weeks,\nmaximum `duration` is 104 weeks (2 years).\n\nIf you have an existing self-stake, then the `duration` must end later than the\nexisting self-stake's `unlockTime`.\n\nThe `unlockTime` of **all** of your self-stake will be extended to the end of\nthe new `duration`.\n\n#### extendSelfStake\n\n```solidity\nfunction extendSelfStake(uint64 duration) external whenNotPaused;\n```\n\nSet existing self-stake's unlock time to the end of `duration`. Minimum\n`duration` is 12 weeks, maximum `duration` is 104 weeks (2 years).\n\nThe `duration` must end later than the existing self-stake's `unlockTime`.\n\n#### withdrawSelfStake\n\n```solidity\nfunction withdrawSelfStake(uint88 amount) external whenNotPaused;\n```\n\nWithdraw `amount` GTC from your unlocked self-stake.\n\n#### communityStake\n\n```solidity\nfunction communityStake(address stakee, uint88 amount, uint64 duration) external whenNotPaused;\n```\n\nAdd `amount` GTC to your stake on `stakee`. Minimum `duration` is 12 weeks,\nmaximum `duration` is 104 weeks (2 years).\n\nIf you have an existing community-stake on `stakee`, then the `duration` must end\nlater than the existing community-stake's `unlockTime`.\n\nThe `unlockTime` of **all** of your community-stake on `stakee` will be\nextended to the end of the new `duration`.\n\n#### extendCommunityStake\n\n```solidity\nfunction extendCommunityStake(address stakee, uint64 duration) external whenNotPaused;\n```\n\nSet existing community-stake's unlock time to the end of `duration`. Minimum\n`duration` is 12 weeks, maximum `duration` is 104 weeks (2 years).\n\nThe `duration` must end later than the existing community-stake's `unlockTime`.\n\n#### withdrawCommunityStake\n\n```solidity\nfunction withdrawCommunityStake(address stakee, uint88 amount) external whenNotPaused;\n```\n\nWithdraw `amount` GTC from your unlocked community-stake on `stakee`.\n\n#### slash\n\n```solidity\nfunction slash(address[] selfStakers, address[] communityStakers, address[] communityStakees, uint64 percent) external onlyRole(SLASHER_ROLE) whenNotPaused;\n```\n\nSlash the provided addresses by `percent`. Addresses in `selfStakers` correspond\nto self-stakes to be slashed. The address in `communityStakers` and\n`communityStakees` correspond to community stakes to be slashed, such that\n`communityStakers[i]` has a community-stake on `communityStakees[i]`.\n\nThis function can only be called by an address with the `SLASHER_ROLE`.\n\n`percent` must be between 1 and 100.\n\n*Note: All staked GTC is liable to be slashed, even if it is past\nits unlockTime*\n\n#### lockAndBurn\n\n```solidity\nfunction lockAndBurn() external whenNotPaused;\n```\n\nThis function is to be called every three months (`burnRoundMinimumDuration`).\n\nWhen called this will lock the current round, burn the previous round, and\nstart a new round.\n\nAnyone can call this function. The `roundMinimumDuration` facilitates the\nlogic to keep everything in sync.\n\nSee [Appendix A: Slashing Rounds](./#appendix-a-slashing-rounds) for more details.\n\n#### release\n\n```solidity\nfunction release(address staker, address stakee, uint88 amountToRelease, uint16 slashRound) external onlyRole(RELEASER_ROLE) whenNotPaused;\n```\n\nRelease `amountToRelease` GTC from the community stake on `stakee` by `staker`.\nIf `staker` is the same as `stakee`, then this is a self-stake. If `slashRound`\nis two or more rounds previous to the current round, then the stake is\nalready burned and this function will fail.\n\nThis function can only be called by an address with the `RELEASER_ROLE`.\n\n#### pause\n\n```solidity\nfunction pause() external onlyRole(PAUSER_ROLE) whenNotPaused;\n```\n\nPause the contract. This function can only be called by an address with the\n`PAUSER_ROLE`.\n\n#### unpause\n\n```solidity\nfunction unpause() external onlyRole(PAUSER_ROLE) whenPaused;\n```\n\nUnpause the contract. This function can only be called by an address with the\n`PAUSER_ROLE`.\n\n### Events\n\n#### SelfStake\n\n```solidity\nevent SelfStake(address indexed staker, uint88 amount, uint64 unlockTime);\n```\n\nEmitted when a self-stake is added/increased/extended. `amount` is the additional\namount added for this particular transaction (could be `0` for an extension).\n`unlockTime` applies to the full self-stake amount for this `staker`.\n\n#### CommunityStake\n\n```solidity\nevent CommunityStake(address indexed staker, address indexed stakee, uint88 amount, uint64 unlockTime);\n```\n\nEmitted when a community-stake is added/increased/extended. `amount` is the\nadditional amount added for this particular transaction (could be `0` for an\nextension). `unlockTime` applies to the full community-stake amount for this\n`staker` on this `stakee`.\n\n#### SelfStakeWithdrawn\n\n```solidity\nevent SelfStakeWithdrawn(address indexed staker, uint88 amount);\n```\n\nEmitted when a self-stake is withdrawn. `amount` is the amount withdrawn in this\ntransaction.\n\n#### CommunityStakeWithdrawn\n\n```solidity\nevent CommunityStakeWithdrawn(address indexed staker, address indexed stakee, uint88 amount);\n```\n\nEmitted when a community-stake is withdrawn. `amount` is the amount withdrawn in\nthis transaction.\n\n#### Slash\n\n```solidity\nevent Slash(address indexed staker, uint88 amount, uint16 round);\n```\n\nEmitted when a slash occurs. `amount` is the total amount slashed in this\ntransaction. `round` is the round in which the slash occurred.\n\n#### LockAndBurn\n\n```solidity\nevent LockAndBurn(uint16 indexed round, uint88 amount);\n```\n\nEmitted when a lockAndBurn occurs. `round` is the round that was burned, and\n`amount` is the total amount burned in this transaction.\n\n### State\n\n#### SLASHER_ROLE\n\n```solidity\nbytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n```\n\nRole held by addresses which are permitted to submit a slash.\n\n#### RELEASER_ROLE\n\n```solidity\nbytes32 public constant RELEASER_ROLE = keccak256(\"RELEASER_ROLE\");\n```\n\nRole held by addresses which are permitted to release an un-burned slash.\n\n#### PAUSER_ROLE\n\n```solidity\nbytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n```\n\nRole held by addresses which are permitted to pause the contract.\n\n#### struct Stake\n\n```solidity\nstruct Stake {\n  uint64 unlockTime;\n  uint88 amount;\n  uint88 slashedAmount;\n  uint16 slashedInRound;\n}\n```\n\n- `unlockTime` is the unix time in seconds after which this stake can be\n  withdrawn.\n- `amount` is the amount of GTC staked.\n      - Note: `uint88` can hold ~300 million with 18 decimals, which is 3x the\n      current GTC supply.\n      - Note: this *does not* include any GTC that has been slashed\n      - Note: this *does* include slashed GTC that has been released\n- `slashedAmount` is the amount of GTC slashed (could be burned already)\n- `slashedInRound` is the round in which this stake was last slashed\n\n#### selfStakes\n\n```solidity\nmapping(address => Stake) public selfStakes;\n```\n\nSelf-stakes by a user. The `address` is the staker. The `Stake` struct is\ndescribed above.\n\n#### communityStakes\n\n```solidity\nmapping(address => mapping(address => Stake)) public communityStakes;\n```\n\nCommunity-stakes by a user on a stakee. The first `address` is the staker, the\nsecond `address` is the stakee. The `Stake` struct is described above.\n\n#### userTotalStaked\n\n```solidity\nmapping(address => uint88) public userTotalStaked;\n```\n\nTotal amount of GTC staked by a user. This includes self-stakes and community\nstakes on all stakees. This does not include any GTC that has been slashed.\n\n#### currentSlashRound\n\n```solidity\nuint16 public currentSlashRound = 1;\n```\n\nThe current slash round. This is incremented on each call to `lockAndBurn`.\nSee [Appendix A: Slashing Rounds](./#appendix-a-slashing-rounds).\n\n#### burnRoundMinimumDuration\n\n```solidity\nuint64 public burnRoundMinimumDuration = 90 days;\n```\n\nThe minimum duration between slash rounds. See\n[Appendix A: Slashing Rounds](./#appendix-a-slashing-rounds).\n\nThis value cannot be modified.\n\n#### lastBurnTimestamp\n\n```solidity\nuint256 public lastBurnTimestamp;\n```\n\nThe timestamp of the last call to `lockAndBurn`. See\n[Appendix A: Slashing Rounds](./#appendix-a-slashing-rounds).\n\nInitially set to the contract's deployment time.\n\n#### burnAddress\n\n```solidity\naddress public burnAddress\n```\n\nThe address to which burned stake is sent. Only configurable on initialization.\n\nThe GTC contract does not allow for transfers to the zero address, so the\naddress of the GTC contract itself will be used as the `burnAddress` instead.\nTokens transferred to the GTC contract cannot ever be retrieved by anyone.\n\n#### totalSlashed\n\n```solidity\nmapping(uint256 => uint88) public totalSlashed;\n```\n\nThe current slash total for each slash round, to track the amounts to be\nburned.\n\n#### gtc\n\n```solidity\nGTC public gtc;\n```\n\nThe GTC token contract.\n\n### Appendix A: Slashing Rounds\n\nRounds exist for the sole purpose of facilitating the timing around slashing,\nwaiting a given duration to allow time for appeals (90 days), and then burning\nthe remaining slashed amount.\n\nThis is much more gas-efficient than tracking individual slashes and their\nappeal periods.\n\n*Note for comprehending the next section: This is talking about **slash** age,\nnot **stake** age. Slash age is the time since the slash occurred.*\n\nOn each call to `lockAndBurn`...\n\n- the current round contains all the slashes younger than the last `lockAndBurn`\n  (effectively 0-90 days old), these are to be locked\n- the previous round contains all the non-released slashes older than this (at\n  least older than the `burnRoundMinimumDuration`, effectively 90-180 days old),\n  and so it is burned\n- the current round becomes the previous round, and a new round is initiated\n\nThe contract is initiated with `currentSlashRound = 1`. On the very first call\nto `lockAndBurn`, nothing will be burned.\n\n`lockAndBurn` may not necessarily be called right away after the\n`burnRoundMinimumDuration`, but this is okay. This just means that\nsome slashes will technically have a bit longer to appeal. All we\ncare about is enforcing a **minimum** appeal period.\n\nThere is a caveat to this if a user is slashed in consecutive rounds. See\n[Appendix B](./#appendix-b-slashing-in-consecutive-rounds) for more details.\n\n### Appendix B: Slashing in Consecutive Rounds\n\nIf a user is slashed, and they had also been slashed in the previous round, then\nthat user's slashAmount from the previous round will be rolled into the current\nround. Otherwise, the slashAmount from the previous would not be able to be\nreleased.\n\nIn a non-abuse situation where a user has consecutive slashes that are not\nappealed, this simply means that the stake will remain frozen longer\n(potentially indefinitely), before being burned. This should be a non-issue\nin practice.\n\nIn an abuse situation (a user keeps committing slash-able offenses in order to\ndelay their frozen stake from being burned):\n\n- The attacker must keep dumping in stake to be slashed, so they're just\n  digging a bigger hole and ultimately burning more GTC.\n- If the user is not slashed for a round, then this cycle is broken. So the\n  slashers can refuse to slash a user for a round to break the cycle.\n- Some sort of appeal limit (included in the T&C) can be implemented to prevent\n  abuse in the form of wasting the appeal council's time.\n\n### Appendix C: Diagrams\n\nNormal slashing and burning, demonstrating the minimum appeal period:\n\n```mermaid\nsequenceDiagram\n  actor Slasher\n  actor User\n  participant Staking Contract\n  actor Community\n  rect rgb(200,100,255)\n  note left of User:Slash Round 1<br />January - March\n  User->>Staking Contract: Self Stake 10 GTC\n  note right of Staking Contract: lastBurnTimestamp = Jan. 1<br />currentSlashRound = 1<br />totalSlashed[0] = 0<br />totalSlashed[1] = 0<br />User Stake =<br />amount: 10<br />slashedAmount: 0<br />slashedInRound: 0\n  Slasher->>Staking Contract: Slash User 50%\n  note right of Staking Contract: lastBurnTimestamp = Jan. 1<br />currentSlashRound = 1<br />totalSlashed[0] = 0<br />totalSlashed[1] = 5<br />User Stake =<br />amount: 5<br />slashedAmount: 5<br />slashedInRound: 1\n  end\n  Community->>Staking Contract: Lock and Burn<br />(burns totalSlashed[0] = 0 GTC)\n  note left of Community: This call always burns the<br/>previous round, in this case<br />round 0 with 0 GTC. \n  rect rgb(100,50,200)\n  note left of User: Slash Round 2<br />April - June\n  note right of Staking Contract: lastBurnTimestamp = Apr. 1<br />currentSlashRound = 2<br />totalSlashed[1] = 5<br />totalSlashed[2] = 0<br />User Stake =<br />amount: 5<br />slashedAmount: 5<br />slashedInRound: 1\n  end\n  Community->>Staking Contract: Lock and Burn<br />(burns totalSlashed[1] = 5 GTC)\n  note left of Community: This burns the 5 GTC slashed<br />in round 1. Round 2 had to<br />complete before this could<br />occur, therefore the<br />minimum appeal period<br />is the round length =<br />3 months\n```\n\nSlashing in Consecutive Rounds:\n\n```mermaid\nsequenceDiagram\n  actor Slasher\n  actor User\n  participant Staking Contract\n  actor Community\n  rect rgb(200,100,255)\n  note left of User:Slash Round 1<br />January - March\n  User->>Staking Contract: Self Stake 10 GTC\n  note right of Staking Contract: lastBurnTimestamp = Jan. 1<br />currentSlashRound = 1<br />totalSlashed[0] = 0<br />totalSlashed[1] = 0<br />User Stake =<br />amount: 10<br />slashedAmount: 0<br />slashedInRound: 0\n  Slasher->>Staking Contract: Slash User 50%\n  note right of Staking Contract: lastBurnTimestamp = Jan. 1<br />currentSlashRound = 1<br />totalSlashed[0] = 0<br />totalSlashed[1] = 5<br />User Stake =<br />amount: 5<br />slashedAmount: 5<br />slashedInRound: 1\n  end\n  Community->>Staking Contract: Lock and Burn<br />(burns totalSlashed[0] = 0 GTC)\n  rect rgb(100,50,200)\n  note left of User: Slash Round 2<br />April - June\n  note right of Staking Contract: lastBurnTimestamp = Apr. 1<br />currentSlashRound = 2<br />totalSlashed[1] = 5<br />totalSlashed[2] = 0<br />User Stake =<br />amount: 5<br />slashedAmount: 5<br />slashedInRound: 1\n  Slasher->>Staking Contract: Slash User 80%\n  note right of Staking Contract: lastBurnTimestamp = Apr. 1<br />currentSlashRound = 2<br />totalSlashed[1] = 0<br />totalSlashed[2] = 9<br />User Stake =<br />amount: 1<br />slashedAmount: 9<br />slashedInRound: 2\n  end\n  Community->>Staking Contract: Lock and Burn<br />(burns totalSlashed[1] = 0 GTC)\n  note left of Community: The 5 GTC slashed in round 1<br />was moved to round 2<br />because this particular user<br />was slashed two rounds in<br />a row, so 0 GTC is burned \nrect rgb(50,50,200)\n  note left of User: Slash Round 3<br />July  - September\n  note right of Staking Contract: lastBurnTimestamp = Jul. 1<br />currentSlashRound = 3<br />totalSlashed[2] = 9<br />totalSlashed[3] = 0<br />User Stake =<br />amount: 1<br />slashedAmount: 9<br />slashedInRound: 2\n  end\n  Community->>Staking Contract: Lock and Burn<br />(burns totalSlashed[2] = 9 GTC)\n  note left of Community: Burns all 9 slashed GTC,<br />now all slashed at<br />least 3 months ago\n```\n\nSeveral Users:\n\n```mermaid\nsequenceDiagram\n  actor Slasher\n  actor User C\n  actor User B\n  actor User A\n  participant Staking Contract\n  actor Community\n  rect rgb(200,100,255)\n    note right of Slasher:Slash Round 1<br />January - March\n    User A->>Staking Contract: Self Stake 10 GTC\n    User B->>Staking Contract: Self Stake 10 GTC\n    note right of Staking Contract: lastBurnTimestamp = Jan. 1<br />currentSlashRound = 1<br />totalSlashed[0] = 0<br />totalSlashed[1] = 0\n    Slasher->>Staking Contract: Slash Users A and B 50% - 10 GTC Total\n    note right of Staking Contract: lastBurnTimestamp = Jan. 1<br />currentSlashRound = 1<br />totalSlashed[0] = 0<br />totalSlashed[1] = 10\n  end\n  Community->>Staking Contract: Lock and Burn<br />(burns totalSlashed[0] = 0 GTC)\n  rect rgb(100,50,200)\n    note right of Slasher: Slash Round 2<br />April - June\n    User C->>Staking Contract: Self Stake 10 GTC\n    note right of Staking Contract: lastBurnTimestamp = Apr. 1<br />currentSlashRound = 2<br />totalSlashed[1] = 10<br />totalSlashed[2] = 0\n    Slasher->>Staking Contract: Slash Users A and C 80% - 12 GTC Total\n    note right of Staking Contract: User A is slashed again, so<br />their 5 GTC slashed in round 1<br />is moved to this round, along<br />with the 4 additional GTC just<br />slashed from User A and the<br />8 GTC just slashed from<br />User C = 17 GTC\n    note right of Staking Contract: lastBurnTimestamp = Apr. 1<br />currentSlashRound = 2<br />totalSlashed[1] = 5<br />totalSlashed[2] = 17\n  end\n  Community->>Staking Contract: Lock and Burn<br />(burns totalSlashed[1] = 5 GTC)\n  rect rgb(50,50,200)\n    note right of Slasher: Slash Round 3<br />July  - September\n    note right of Staking Contract: lastBurnTimestamp = Jul. 1<br />currentSlashRound = 3<br />totalSlashed[2] = 17<br />totalSlashed[3] = 0<br />\n    User B->>Staking Contract: Self Stake 10 GTC\n    Slasher->>Staking Contract: Slash User B 50% - 5 GTC Total\n    note right of Staking Contract: lastBurnTimestamp = Jul. 1<br />currentSlashRound = 3<br />totalSlashed[2] = 17<br />totalSlashed[3] = 5<br />\n  end\n  Community->>Staking Contract: Lock and Burn<br />(burns totalSlashed[2] = 17 GTC)\n```\n\n### Appendix D: Security\n\n#### Reentrancy\n\nThis contract is not susceptible to reentrancy attacks. All state changes are\nmade before any external calls are made. Additionally, external calls are made\nonly to the GTC contract set at initialization, which is a trusted contract.\n\n#### Token Ownership\n\nThe tokens in this contract can only be in three states:\n\n1. Held by the contract (staked or frozen)\n2. Burned\n3. Returned to the original owner\n\nThe contract *cannot* send tokens to any address other than the original owner,\nor the burn address.\n\n#### Token Amounts\n\nToken amounts are stored as `uint88` which can hold\n309,485,009,821,345,068,724,781,055 or just over 300 million with 18 decimals.\nThis is 3x the current GTC supply.\n\nIf this contract is used with tokens other than GTC, or if enough GTC were\nminted to exceed this amount, then the contract would need to be updated.\nCurrently uint88s are used so that all stake info fits in a single 256 byte\nslot, which provides huge gas savings.\n\nIf the current contract needs to be upgraded after the GTC supply exceeds this\nmax supply, the following could be done:\n\n*Note: These scenarios are not fully thought out and may need some tweaks to be\ncompletely viable. These are just high level proof-of-concepts.*\n\nOption 1: Do nothing. In the extremely unlikely event that one of the uint88s\nwere to exceed the max uint88, then the contract would revert. In the perfect\nstorm, a user could not be slashed in a particular round. But this is\nexceedingly unlikely and not a huge deal anyways. Users could still withdraw\ntheir existing stake.\n\nOption 2: Add an explicit stake amount cap, user total stake cap, and a round\ncap at MAX_UINT88. This should effectively change nothing, it's the same as\noption 1 but with a clearer intention.\n\nOption 3: If we want to really consider what would be necessary to handle much\nlarger amounts (i.e. in a hyperinflation scenario), then the following could be\ndone:\n\n1. If necessary the contract can be paused while this upgrade is pending.\n2. The contract could be upgraded to start considering all uint88 `amount`\n   parameters to have e.g. 16 decimals. There could be a\n   `mapping (address => bool) amountUses16Decimals` to track which amounts are\n   using 16 decimals. (Note: This is high level, in reality we need to track\n   self, community, slash round amounts, etc.)\n3. 18 decimal amounts would be divided by 100 to get the new amount, when those\n   amounts are interacted with. Any change leftover could be refunded to The user.\n4. After all 18 decimal stake is withdrawn/burned, the logic to handle\n   both 16 and 18 decimal amounts at the same time could be removed. If\n   some old stakes are holding on, there could be a one-time refund to the user\n   of any leftover change (would need to be a new function, with guarantees\n   to only be called once, etc.).\n\n#### OpenZeppelin Contracts\n\nWhere it makes sense, we've used OpenZeppelin's contracts to handle generic\nfunctionality (access control, pausing, and upgrading). These contracts are\nwell-vetted and audited.\n\n#### `block.timestamp` usage\n\n`block.timestamp` is sometimes a source of security issues because nodes can\ntweak it a bit. However, in this contract, `block.timestamp` is only used to\ndetermine when stake is staked and when it can be withdrawn. This happens over\nlong periods of a minimum of 12 weeks.\n\nThe danger with `block.timestamp` is when it's used to derive randomness, or\nwhen changing the value by a few seconds or less could have a significant\nimpact. This is not the case in this contract.\n\nAn alternative would be to rely on the average block time and calculate block\nnumbers, but then this would need to be configurable in case the average block\ntime changes in the future. So this would be a source of manipulation and\npotential error. Further, it's simply unnecessary as explained above.\n\n## IIdentityStaking.sol\n\nThis contract defines a minimal interface for the data that is likely to be\nuseful onchain, for easy integration with other contracts.\n\nThere are accessors for [selfStakes](#selfstakes),\n[communityStakes](#communitystakes), and [userTotalStaked](#usertotalstaked)."
    },
    {
      "filename": "id-staking-v2/contracts/IdentityStaking.sol",
      "content": "// SPDX-License-Identifier: GPL\npragma solidity ^0.8.23;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IIdentityStaking} from \"./IIdentityStaking.sol\";\n\n/// @title IdentityStaking\n/// @author Passport\n/// @notice This contract is used to stake GTC on self/community identity\ncontract IdentityStaking is\n  IIdentityStaking,\n  Initializable,\n  UUPSUpgradeable,\n  AccessControlUpgradeable,\n  PausableUpgradeable\n{\n  /***** SECTION 0: Errors, State, Events *****/\n\n  /// @dev Address parameter cannot be zero\n  error AddressCannotBeZero();\n\n  /// @dev Stake amount must be greater than zero\n  error AmountMustBeGreaterThanZero();\n\n  /// @dev A community stake cannot be placed on the staker's own address\n  error CannotStakeOnSelf();\n\n  /// @dev An ERC20 transfer failed\n  error FailedTransfer();\n\n  /// @dev The lock time must be between 12 and 104 weeks, and after any existing lock\n  error InvalidLockTime();\n\n  /// @dev The stake is still locked and cannot be withdrawn\n  error StakeIsLocked();\n\n  /// @dev The requested withdrawal amount is greater than the stake\n  error AmountTooHigh();\n\n  /// @dev The slash percent must be between 1 and 100\n  error InvalidSlashPercent();\n\n  /// @dev The staker and stakee arrays must be the same length\n  error StakerStakeeMismatch();\n\n  /// @dev The requested funds are greater than the slashed amount for this user\n  error FundsNotAvailableToRelease();\n\n  /// @dev The requested funds are not available to release for this user from the given round\n  error FundsNotAvailableToReleaseFromRound();\n\n  /// @dev The round has already been burned and its slashed stake cannot be released\n  error RoundAlreadyBurned();\n\n  /// @dev The minimum burn round duration has not been met, controlled by the `burnRoundMinimumDuration`\n  error MinimumBurnRoundDurationNotMet();\n\n  /// @notice Role held by addresses which are permitted to submit a slash.\n  bytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n\n  /// @notice Role held by addresses which are permitted to release an un-burned slash.\n  bytes32 public constant RELEASER_ROLE = keccak256(\"RELEASER_ROLE\");\n\n  /// @notice Role held by addresses which are permitted to pause the contract.\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  /// @notice Struct representing a stake\n  /// @param unlockTime The unix time in seconds after which the stake can be withdrawn\n  /// @param amount The amount of GTC staked, with 18 decimals\n  /// @param slashedAmount The amount of GTC slashed (could already be burned)\n  /// @param slashedInRound The round in which the stake was last slashed\n  /// @dev uint88s can hold up to 300 million w/ 18 decimals, or 3x the current max supply\n  ///      `amount` does not include any slashed or burned GTC\n  struct Stake {\n    uint64 unlockTime;\n    uint88 amount;\n    uint88 slashedAmount;\n    uint16 slashedInRound;\n  }\n\n  /// @inheritdoc IIdentityStaking\n  mapping(address => uint88) public userTotalStaked;\n\n  /// @inheritdoc IIdentityStaking\n  mapping(address => Stake) public selfStakes;\n\n  /// @inheritdoc IIdentityStaking\n  mapping(address => mapping(address => Stake)) public communityStakes;\n\n  /// @notice The current round of slashing, incremented on each call to `lockAndBurn`\n  /// @dev uint16 can hold up to 65,535 rounds, or 16,383 years with 90 day rounds\n  ///      Set to `1` in the initializer\n  uint16 public currentSlashRound;\n\n  /// @notice The minimum duration between burn rounds\n  /// @dev This sets the minimum appeal period for a slash\n  ///      Set to `90 days` in the initializer\n  uint64 public burnRoundMinimumDuration;\n\n  /// @notice The timestamp of the last burn\n  uint256 public lastBurnTimestamp;\n\n  /// @notice The address to which all burned tokens are sent\n  /// @dev Set in the initializer\n  ///      This could be set to the zero address. But in the case of GTC,\n  ///      it is set to the GTC token contract address because GTC cannot\n  ///      be transferred to the zero address\n  address public burnAddress;\n\n  /// @notice The total amount of GTC slashed in each round\n  mapping(uint16 => uint88) public totalSlashed;\n\n  /// @notice The GTC token contract\n  IERC20 public token;\n\n  /// @notice Emitted when a self-stake is added/increased/extended\n  /// @param staker The staker's address\n  /// @param amount The additional amount added for this particular transaction\n  /// @param unlockTime Unlock time for the full self-stake amount for this staker\n  /// @dev `amount` could be `0` for an extension\n  event SelfStake(address indexed staker, uint88 amount, uint64 unlockTime);\n\n  /// @notice Emitted when a community stake is added/increased/extended\n  /// @param staker The staker's address\n  /// @param stakee The stakee's address\n  /// @param amount The additional amount added for this particular transaction\n  /// @param unlockTime Unlock time for the full community stake amount for this staker on this stakee\n  /// @dev `amount` could be `0` for an extension\n  event CommunityStake(\n    address indexed staker,\n    address indexed stakee,\n    uint88 amount,\n    uint64 unlockTime\n  );\n\n  /// @notice Emitted when a self-stake is withdrawn\n  /// @param staker The staker's address\n  /// @param amount The amount withdrawn in this transaction\n  event SelfStakeWithdrawn(address indexed staker, uint88 amount);\n\n  /// @notice Emitted when a community stake is withdrawn\n  /// @param staker The staker's address\n  /// @param stakee The stakee's address\n  /// @param amount The amount withdrawn in this transaction\n  event CommunityStakeWithdrawn(address indexed staker, address indexed stakee, uint88 amount);\n\n  /// @notice Emitted when a slash is submitted\n  /// @param staker Address of the staker who is slashed\n  /// @param amount The amount slashed in this transaction\n  /// @param round The round in which the slash occurred\n  event Slash(address indexed staker, uint88 amount, uint16 round);\n\n  /// @notice Emitted when a round is burned\n  /// @param round The round that was burned\n  /// @param amount The amount of GTC burned in this transaction\n  event Burn(uint16 indexed round, uint88 amount);\n\n  /***** SECTION 1: Admin Functions *****/\n\n  /// @notice Initialize the contract\n  /// @param tokenAddress The address of the GTC token contract\n  /// @param _burnAddress The address to which all burned tokens are sent\n  /// @param initialAdmin The initial address to assign the DEFAULT_ADMIN_ROLE\n  /// @param initialSlashers The initial addresses to assign the SLASHER_ROLE\n  /// @param initialReleasers The initial addresses to assign the RELEASER_ROLE\n  function initialize(\n    address tokenAddress,\n    address _burnAddress,\n    address initialAdmin,\n    address[] calldata initialSlashers,\n    address[] calldata initialReleasers\n  ) public initializer {\n    if (tokenAddress == address(0)) {\n      revert AddressCannotBeZero();\n    }\n\n    __AccessControl_init();\n    __Pausable_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\n    _grantRole(PAUSER_ROLE, initialAdmin);\n\n    for (uint256 i = 0; i < initialSlashers.length; i++) {\n      _grantRole(SLASHER_ROLE, initialSlashers[i]);\n    }\n\n    for (uint256 i = 0; i < initialReleasers.length; i++) {\n      _grantRole(RELEASER_ROLE, initialReleasers[i]);\n    }\n\n    token = IERC20(tokenAddress);\n    burnAddress = _burnAddress;\n\n    currentSlashRound = 1;\n    burnRoundMinimumDuration = 90 days;\n    lastBurnTimestamp = block.timestamp;\n  }\n\n  /// @notice Pause the contract\n  function pause() external onlyRole(PAUSER_ROLE) whenNotPaused {\n    _pause();\n  }\n\n  /// @notice Unpause the contract\n  function unpause() external onlyRole(PAUSER_ROLE) whenPaused {\n    _unpause();\n  }\n\n  /// @inheritdoc UUPSUpgradeable\n  /// @dev Only the admin can upgrade the contract\n  /// @dev UUPSUpgradeable allows the contract to be permanently frozen in the future\n  function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n  /***** SECTION 2: Staking Functions *****/\n\n  /// @notice Add self stake\n  /// @param amount The amount of GTC to Stake\n  /// @param duration The duration in seconds of the stake lock period\n  /// @dev The duration must be between 12 weeks and 104 weeks, and after any existing lock\n  ///      The amount must be greater than zero\n  ///      The unlock time is calculated as `block.timestamp + duration`\n  ///      If there is any existing self-stake, the unlock time is extended for the entire stake amount\n  function selfStake(uint88 amount, uint64 duration) external whenNotPaused {\n    if (amount == 0) {\n      revert AmountMustBeGreaterThanZero();\n    }\n\n    uint64 unlockTime = duration + uint64(block.timestamp);\n\n    if (\n      // Must be between 12 weeks and 104 weeks\n      unlockTime < block.timestamp + 12 weeks ||\n      unlockTime > block.timestamp + 104 weeks ||\n      // Must be later than any existing lock\n      unlockTime < selfStakes[msg.sender].unlockTime\n    ) {\n      revert InvalidLockTime();\n    }\n\n    selfStakes[msg.sender].amount += amount;\n    selfStakes[msg.sender].unlockTime = unlockTime;\n    userTotalStaked[msg.sender] += amount;\n\n    emit SelfStake(msg.sender, amount, unlockTime);\n\n    if (!token.transferFrom(msg.sender, address(this), amount)) {\n      revert FailedTransfer();\n    }\n  }\n\n  /// @notice Extend lock period for self stake\n  /// @param duration The duration in seconds"
    }
  ]
}