{
  "Title": "Set credit limit by pausing the guardian",
  "Content": "##### Description\nPausing the guardian can set a new credit limit for users with the credit limit.\nhttps://github.com/ibdotxyz/compound-protocol/blob/8cd45803b48552e344e22be280c9e1c03ec8644a/contracts/Comptroller.sol#L1313\n##### Recommendation\nWe recommend updating the checks in the \"_setCreditLimit\" function.\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Comptroller.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle/PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./LiquidityMiningInterface.sol\";\nimport \"./Unitroller.sol\";\nimport \"./Governance/Comp.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound (modified by Cream)\n */\ncontract Comptroller is ComptrollerV1Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an admin delists a market\n    event MarketDelisted(CToken cToken, bool force);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when liquidity mining module is changed\n    event NewLiquidityMining(address oldLiquidityMining, address newLiquidityMining);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPaused(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when supply cap for a cToken is changed\n    event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when protocol's credit limit has changed\n    event CreditLimitChanged(address protocol, address market, uint256 creditLimit);\n\n    /// @notice Emitted when cToken version is changed\n    event NewCTokenVersion(CToken cToken, Version oldVersion, Version newVersion);\n\n    /// @notice Emitted when credit limit manager is changed\n    event NewCreditLimitManager(address oldCreditLimitManager, address newCreditLimitManager);\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) public returns (uint256[] memory) {\n        uint256 len = cTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        require(marketToJoin.isListed, \"market not listed\");\n\n        if (marketToJoin.version == Version.COLLATERALCAP) {\n            // register collateral for the borrower if the token is CollateralCap version.\n            CCollateralCapErc20Interface(address(cToken)).registerCollateral(borrower);\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external returns (uint256) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        require(amountOwed == 0, \"nonzero borrow balance\");\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        require(redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld) == 0, \"failed to exit market\");\n\n        Market storage marketToExit = markets[cTokenAddress];\n\n        if (marketToExit.version == Version.COLLATERALCAP) {\n            CCollateralCapErc20Interface(cTokenAddress).unregisterCollateral(msg.sender);\n        }\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account’s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        if (assetIndex != storedList.length - 1) {\n            storedList[assetIndex] = storedList[storedList.length - 1];\n        }\n        storedList.length--;\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Return a specific market is listed or not\n     * @param cTokenAddress The address of the asset to be checked\n     * @return Whether or not the market is listed\n     */\n    function isMarketListed(address cTokenAddress) public view returns (bool) {\n        return markets[cTokenAddress].isListed;\n    }\n\n    /**\n     * @notice Return a specific market is listed or delisted\n     * @param cTokenAddress The address of the asset to be checked\n     * @return Whether or not the market is listed or delisted\n     */\n    function isMarketListedOrDelisted(address cTokenAddress) public view returns (bool) {\n        return markets[cTokenAddress].isListed || isMarketDelisted[cTokenAddress];\n    }\n\n    /**\n     * @notice Return the credit limit of a specific protocol\n     * @dev This function shouldn't be called. It exists only for backward compatibility.\n     * @param protocol The address of the protocol\n     * @return The credit\n     */\n    function creditLimits(address protocol) public view returns (uint256) {\n        protocol; // Shh\n        return 0;\n    }\n\n    /**\n     * @notice Return the credit limit of a specific protocol for a specific market\n     * @param protocol The address of the protocol\n     * @param market The market\n     * @return The credit\n     */\n    function creditLimits(address protocol, address market) public view returns (uint256) {\n        return _creditLimits[protocol][market];\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n        require(!isCreditAccount(minter, cToken), \"credit account cannot mint\");\n\n        require(isMarketListed(cToken), \"market not listed\");\n\n        uint256 supplyCap = supplyCaps[cToken];\n        // Supply cap of 0 corresponds to unlimited supplying\n        if (supplyCap != 0) {\n            uint256 totalCash = CToken(cToken).getCash();\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            uint256 totalReserves = CToken(cToken).totalReserves();\n            // totalSupplies = totalCash + totalBorrows - totalReserves\n            (MathError mathErr, uint256 totalSupplies) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            require(mathErr == MathError.NO_ERROR, \"totalSupplies failed\");\n\n            uint256 nextTotalSupplies = add_(totalSupplies, mintAmount);\n            require(nextTotalSupplies < supplyCap, \"market supply cap reached\");\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n    function mintVerify(\n        address cToken,\n        address minter,\n        uint256 actualMintAmount,\n        uint256 mintTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        minter;\n        actualMintAmount;\n        mintTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            closeFactorMantissa = closeFactorMantissa;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256) {\n        return redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    }\n\n    function redeemAllowedInternal(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        require(isMarketListedOrDelisted(cToken), \"market not listed\");\n        require(!isCreditAccount(redeemer, cToken), \"credit account cannot redeem\");\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            CToken(cToken),\n            redeemTokens,\n            0\n        );\n        require(err == Error.NO_ERROR, \"failed to get account liquidity\");\n        require(shortfall == 0, \"insufficient liquidity\");\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        require(isMarketListed(cToken), \"market not listed\");\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            require(addToMarketInternal(CToken(cToken), borrower) == Error.NO_ERROR, \"failed to add market\");\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        require(oracle.getUnderlyingPrice(CToken(cToken)) != 0, \"price error\");\n\n        uint256 borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            uint256 nextTotalBorrows = add_(totalBorrows, borrowAmount);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        uint256 creditLimit = _creditLimits[borrower][cToken];\n        // If the borrower is a credit account, check the credit limit instead of account liquidity.\n        if (creditLimit > 0) {\n            (uint256 oErr, , uint256 borrowBalance, ) = CToken(cToken).getAccountSnapshot(borrower);\n            require(oErr == 0, \"snapshot error\");\n            require(creditLimit >= add_(borrowBalance, borrowAmount), \"insufficient credit limit\");\n        } else {\n            (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n                borrower,\n                CToken(cToken),\n                0,\n                borrowAmount\n            );\n            require(err == Error.NO_ERROR, \"failed to get account liquidity\");\n            require(shortfall == 0, \"insufficient liquidity\");\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    function borrowVerify(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external {\n        // Shh - currently unused\n        cToken;\n        borrower;\n        borrowAmount;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            closeFactorMantissa = closeFactorMantissa;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        repayAmount;\n\n        require(isMarketListedOrDelisted(cToken), \"market not listed\");\n\n        if (isCreditAccount(borrower, cToken)) {\n            require(borrower == payer, \"cannot repay on behalf of credit account\");\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 actualRepayAmount,\n        uint256 borrowerIndex\n    ) external {\n        // Shh - currently unused\n        cToken;\n        payer;\n        borrower;\n        actualRepayAmount;\n        borrowerIndex;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            closeFactorMantissa = closeFactorMantissa;\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        require(!isCreditAccount(borrower, cTokenBorrowed), \"cannot liquidate credit account\");\n\n        // Shh - currently unused\n        liquidator;\n\n        require(\n            isMarketListedOrDelisted(cTokenBorrowed) && isMarketListedOrDelisted(cTokenCollateral),\n            \"market not listed\"\n        );\n\n        /* The borrower must have shortfall in order to be liquidatable */\n        (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n        require(err == Error.NO_ERROR, \"failed to get account liquidity\");\n        require(shortfall > 0, \"insufficient shortfall\");\n\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n        uint256 maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n        if (repayAmount > maxClose) {\n            return uint256(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowVerify(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 actualRepayAmount,\n        uint256 seizeTokens\n    ) external {\n        // Shh - currently unused\n        cTokenBorrowed;\n        cTokenCollateral;\n        liquidator;\n        borrower;\n        actualRepayAmount;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            closeFactorMantissa = closeFactorMantissa;\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n        require(!isCreditAccount(borrower, cTokenBorrowed), \"cannot sieze from credit account\");\n\n        // Shh - currently unused\n        liquidator;\n        seizeTokens;\n\n        require(\n            isMarketListedOrDelisted(cTokenBorrowed) && isMarketListedOrDelisted(cTokenCollateral),\n            \"market not listed\"\n        );\n        require(\n            CToken(cTokenCollateral).comptroller() == CToken(cTokenBorrowed).comptroller(),\n            \"comptroller mismatched\"\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeVerify(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external {\n        // Shh - currently unused\n        cTokenCollateral;\n        cTokenBorrowed;\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            closeFactorMantissa = closeFactorMantissa;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n        require(!isCreditAccount(dst, cToken), \"cannot transfer to a credit account\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        return redeemAllowedInternal(cToken, src, transferTokens);\n    }\n\n    /**\n     * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n    function transferVerify(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        src;\n        dst;\n        transferTokens;\n\n        // Shh - we don't ever want this hook to be marked pure\n        if (false) {\n            closeFactorMantissa = closeFactorMantissa;\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param receiver The account which receives the tokens\n     * @param amount The amount of the tokens\n     * @param params The other parameters\n     */\n\n    function flashloanAllowed(\n        address cToken,\n        address receiver,\n        uint256 amount,\n        bytes calldata params\n    ) external view returns (bool) {\n        return !flashloanGuardianPaused[cToken];\n    }\n\n    /**\n     * @notice Update CToken's version.\n     * @param cToken Version of the asset being updated\n     * @param newVersion The new version\n     */\n    function updateCTokenVersion(address cToken, Version newVersion) external {\n        require(msg.sender == cToken, \"cToken only\");\n\n        // This function will be called when a new CToken implementation becomes active.\n        // If a new CToken is newly created, this market is not listed yet. The version of\n        // this market will be taken care of when calling `_supportMarket`.\n        if (isMarketListed(cToken)) {\n            Version oldVersion = markets[cToken].version;\n            markets[cToken].version = newVersion;\n\n            emit NewCTokenVersion(CToken(cToken), oldVersion, newVersion);\n        }\n    }\n\n    /**\n     * @notice Check if the account is a credit account\n     * @param account The account needs to be checked\n     * @param cToken The market\n     * @return The account is a credit account or not\n     */\n    function isCreditAccount(address account, address cToken) public view returns (bool) {\n        return _creditLimits[account][cToken] > 0;\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrowPlusEffects;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(0),\n            0,\n            0\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account)\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(cTokenModify),\n            redeemTokens,\n            borrowAmount\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset ="
    }
  ]
}