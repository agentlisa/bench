{
  "Title": "[H-07] `Reth.sol`: Withdrawals are unreliable and depend on excess `RocketDepositPool` balance which can brick the whole protocol",
  "Content": "\nThe Asymmetry protocol promises that a user can call [`SafETH.unstake`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L108-L129) at all times. What I mean by that is that a user should be able at all times to burn his `SafETH` tokens and receive `ETH` in return. This requires that the derivatives held by the protocol can at all times be withdrawn (i.e. converted to `ETH`).\n\nAlso the [`rebalanceToWeights`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L138-L155) functionality requires that the derivatives can be withdrawn at all times. If a derivative cannot be withdrawn then the `rebalanceToWeights` function cannot be executed which means that the protocol cannot be adjusted to use different derivatives.\n\nFor the `WstEth` and `SfrxEth` derivatives this is achieved by swapping the derivative in a Curve pool for `ETH`. The liquidity in the respective Curve pool ensures that withdrawals can be processed at all times.\n\nThe `Reth` derivative works differently.\n\nWithdrawals are made by calling the `RocketTokenRETH.burn` function:\n\n[Link](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L107-L114)\n\n```solidity\nfunction withdraw(uint256 amount) external onlyOwner {\n    // @audit this is how rETH is converted to ETH\n    RocketTokenRETHInterface(rethAddress()).burn(amount);\n    // solhint-disable-next-line\n    (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n        \"\"\n    );\n    require(sent, \"Failed to send Ether\");\n}\n```\n\nThe issue with this is that the `RocketTokenRETH.burn` function only allows for *excess balance* to be withdrawn. I.e. ETH that has been deposited by stakers but that is not yet staked on the Ethereum beacon chain. So Rocketpool allows users to burn `rETH` and withdraw `ETH` as long as the excess balance is sufficient.\n\nThe issue is obvious now: If there is no excess balance because enough users burn `rETH` or the Minipool capacity increases, the Asymmetry protocol is bascially unable to operate.\n\nWithdrawals are then impossible which bricks `SafEth.unstake` and `SafEth.rebalanceToWeights`.\n\n### Proof of Concept\n\nI show in this section how the current withdrawal flow for the `Reth` derivative is dependend on there being *excess balance* in the RocketDepositPool.\n\nThe current withdrawal flow calls `RocketTokenRETH.burn` which executes this code:\n\n[Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L106-L123)\n\n```solidity\nfunction burn(uint256 _rethAmount) override external {\n    // Check rETH amount\n    require(_rethAmount > 0, \"Invalid token burn amount\");\n    require(balanceOf(msg.sender) >= _rethAmount, \"Insufficient rETH balance\");\n    // Get ETH amount\n    uint256 ethAmount = getEthValue(_rethAmount);\n    // Get & check ETH balance\n    uint256 ethBalance = getTotalCollateral();\n    require(ethBalance >= ethAmount, \"Insufficient ETH balance for exchange\");\n    // Update balance & supply\n    _burn(msg.sender, _rethAmount);\n    // Withdraw ETH from deposit pool if required\n    withdrawDepositCollateral(ethAmount);\n    // Transfer ETH to sender\n    msg.sender.transfer(ethAmount);\n    // Emit tokens burned event\n    emit TokensBurned(msg.sender, _rethAmount, ethAmount, block.timestamp);\n}\n```\n\nThis executes `withdrawDepositCollateral(ethAmount)`:\n\n[Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L126-L133)\n\n```solidity\nfunction withdrawDepositCollateral(uint256 _ethRequired) private {\n    // Check rETH contract balance\n    uint256 ethBalance = address(this).balance;\n    if (ethBalance >= _ethRequired) { return; }\n    // Withdraw\n    RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n    rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance));\n}\n```\n\nThis then calls `rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance))` to get the `ETH` from the *excess balance*:\n\n[Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/deposit/RocketDepositPool.sol#L194-L206)\n\n```solidity\nfunction withdrawExcessBalance(uint256 _amount) override external onlyThisLatestContract onlyLatestContract(\"rocketTokenRETH\", msg.sender) {\n    // Load contracts\n    RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(getContractAddress(\"rocketTokenRETH\"));\n    RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n    // Check amount\n    require(_amount <= getExcessBalance(), \"Insufficient excess balance for withdrawal\");\n    // Withdraw ETH from vault\n    rocketVault.withdrawEther(_amount);\n    // Transfer to rETH contract\n    rocketTokenRETH.depositExcess{value: _amount}();\n    // Emit excess withdrawn event\n    emit ExcessWithdrawn(msg.sender, _amount, block.timestamp);\n}\n```\n\nAnd this function reverts if the *excess balance* is insufficient which you can see in the `require(_amount <= getExcessBalance(), \"Insufficient excess balance for withdrawal\");` check.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe solution for this issue is to have an alternative withdrawal mechanism in case the *excess balance* in the RocketDepositPool is insufficient to handle the withdrawal.\n\nThe alternative withdrawal mechanism is to sell the `rETH` tokens via the Uniswap pool.\n\nYou can use the [`RocketDepositPool.getExcessBalance`](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/deposit/RocketDepositPool.sol#L59-L67) to check if there is sufficient excess `ETH` to withdraw from Rocketpool or if the withdrawal must be made via Uniswap.\n\nThe pseudocode of the new withdraw flow looks like this:\n\n    function withdraw(uint256 amount) external onlyOwner {\n        if (rocketDepositPool excess balance is sufficient) {\n            RocketTokenRETHInterface(rethAddress()).burn(amount);\n            // solhint-disable-next-line\n            (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n                \"\"\n            );\n            require(sent, \"Failed to send Ether\");\n        } else {\n            // swap rETH for ETH via Uniswap pool\n        }\n    }\n\nI also wrote the code for the changes that I suggest:\n\n```diff\ndiff --git a/contracts/SafEth/derivatives/Reth.sol b/contracts/SafEth/derivatives/Reth.sol\nindex b6e0694..b699d5c 100644\n--- a/contracts/SafEth/derivatives/Reth.sol\n+++ b/contracts/SafEth/derivatives/Reth.sol\n@@ -105,11 +105,24 @@ contract Reth is IDerivative, Initializable, OwnableUpgradeable {\n         @notice - Convert derivative into ETH\n      */\n     function withdraw(uint256 amount) external onlyOwner {\n-        RocketTokenRETHInterface(rethAddress()).burn(amount);\n-        // solhint-disable-next-line\n-        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n-            \"\"\n-        );\n+        if (canWithdrawFromRocketPool(amount)) {\n+            RocketTokenRETHInterface(rethAddress()).burn(amount);\n+            // solhint-disable-next-line\n+        } else {\n+\n+            uint256 minOut = ((((poolPrice() * amount) / 10 ** 18) *\n+                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n+\n+            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n+            swapExactInputSingleHop(\n+                rethAddress(),\n+                W_ETH_ADDRESS,\n+                500,\n+                amount,\n+                minOut\n+            );\n+        }\n+        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\"\");\n         require(sent, \"Failed to send Ether\");\n     }\n \n@@ -149,6 +162,21 @@ contract Reth is IDerivative, Initializable, OwnableUpgradeable {\n             _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n     }\n \n+    function canWithdrawFromRocketPool(uint256 _amount) private view returns (bool) {\n+        address rocketDepositPoolAddress = RocketStorageInterface(\n+            ROCKET_STORAGE_ADDRESS\n+        ).getAddress(\n+                keccak256(\n+                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n+                )\n+            );\n+        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n+                rocketDepositPoolAddress\n+            );\n+        uint256 _ethAmount = RocketTokenRETHInterface(rethAddress()).getEthValue(_amount);\n+        return rocketDepositPool.getExcessBalance() >= _ethAmount;\n+    }\n+\n```\n\n\n**[toshiSat (Asymmetry) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/210#issuecomment-1500642915):**\n > The deposit pool is mostly always full, but the warden does have a point and we should allow for multiple options.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Check if withdraw from deposit contract possible.<br>\n\n**Status:** Sub-optimally mitigated. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/56), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/41), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/11).\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/derivatives/Reth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"../../interfaces/frax/IsFrxEth.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/rocketpool/RocketStorageInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketTokenRETHInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDepositPoolInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../interfaces/uniswap/ISwapRouter.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Factory.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\n/// @title Derivative contract for rETH\n/// @author Asymmetry Finance\ncontract Reth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant ROCKET_STORAGE_ADDRESS =\n        0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46;\n    address public constant W_ETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant UNISWAP_ROUTER =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address public constant UNI_V3_FACTORY =\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"RocketPool\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Get rETH address\n        @dev - per RocketPool Docs query addresses each time it is used\n     */\n    function rethAddress() private view returns (address) {\n        return\n            RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n    }\n\n    /**\n        @notice - Swap tokens through Uniswap\n        @param _tokenIn - token to swap from\n        @param _tokenOut - token to swap to\n        @param _poolFee - pool fee for particular swap\n        @param _amountIn - amount of token to swap from\n        @param _minOut - minimum amount of token to receive (slippage)\n     */\n    function swapExactInputSingleHop(\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _poolFee,\n        uint256 _amountIn,\n        uint256 _minOut\n    ) private returns (uint256 amountOut) {\n        IERC20(_tokenIn).approve(UNISWAP_ROUTER, _amountIn);\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n            .ExactInputSingleParams({\n                tokenIn: _tokenIn,\n                tokenOut: _tokenOut,\n                fee: _poolFee,\n                recipient: address(this),\n                amountIn: _amountIn,\n                amountOutMinimum: _minOut,\n                sqrtPriceLimitX96: 0\n            });\n        amountOut = ISwapRouter(UNISWAP_ROUTER).exactInputSingle(params);\n    }\n\n    /**\n        @notice - Convert derivative into ETH\n     */\n    function withdraw(uint256 amount) external onlyOwner {\n        RocketTokenRETHInterface(rethAddress()).burn(amount);\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n    }\n\n    /**\n        @notice - Check whether or not rETH deposit pool has room users amount\n        @param _amount - amount that will be deposited\n     */\n    function poolCanDeposit(uint256 _amount) private view returns (bool) {\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        address rocketProtocolSettingsAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\n                        \"contract.address\",\n                        \"rocketDAOProtocolSettingsDeposit\"\n                    )\n                )\n            );\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(\n                rocketProtocolSettingsAddress\n            );\n\n        return\n            rocketDepositPool.getBalance() + _amount <=\n            rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n            _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n    }\n\n    /**\n        @notice - Deposit into derivative\n        @dev - will either get rETH on exchange or deposit into contract depending on availability\n     */\n    function deposit() external payable onlyOwner returns (uint256) {\n        // Per RocketPool Docs query addresses each time it is used\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        if (!poolCanDeposit(msg.value)) {\n            uint rethPerEth = (10 ** 36) / poolPrice();\n\n            uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n\n            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n            uint256 amountSwapped = swapExactInputSingleHop(\n                W_ETH_ADDRESS,\n                rethAddress(),\n                500,\n                msg.value,\n                minOut\n            );\n\n            return amountSwapped;\n        } else {\n            address rocketTokenRETHAddress = RocketStorageInterface(\n                ROCKET_STORAGE_ADDRESS\n            ).getAddress(\n                    keccak256(\n                        abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                    )\n                );\n            RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(\n                rocketTokenRETHAddress\n            );\n            uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n            rocketDepositPool.deposit{value: msg.value}();\n            uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n            require(rethBalance2 > rethBalance1, \"No rETH was minted\");\n            uint256 rethMinted = rethBalance2 - rethBalance1;\n            return (rethMinted);\n        }\n    }\n\n    /**\n        @notice - Get price of derivative in terms of ETH\n        @dev - we need to pass amount so that it gets price from the same source that it buys or mints the rEth\n        @param _amount - amount to check for ETH price\n     */\n    function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n\n    /**\n        @notice - Total derivative balance\n     */\n    function balance() public view returns (uint256) {\n        return IERC20(rethAddress()).balanceOf(address(this));\n    }\n\n    /**\n        @notice - Price of derivative in liquidity pool\n     */\n    function poolPrice() private view returns (uint256) {\n        address rocketTokenRETHAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n        IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n        IUniswapV3Pool pool = IUniswapV3Pool(\n            factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n        );\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/contract/token/RocketTokenRETH.sol",
      "content": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport \"../../interface/network/RocketNetworkBalancesInterface.sol\";\nimport \"../../interface/token/RocketTokenRETHInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\n\n// rETH is a tokenised stake in the Rocket Pool network\n// rETH is backed by ETH (subject to liquidity) at a variable exchange rate\n\ncontract RocketTokenRETH is RocketBase, ERC20, RocketTokenRETHInterface {\n\n    // Libs\n    using SafeMath for uint;\n\n    // Events\n    event EtherDeposited(address indexed from, uint256 amount, uint256 time);\n    event TokensMinted(address indexed to, uint256 amount, uint256 ethAmount, uint256 time);\n    event TokensBurned(address indexed from, uint256 amount, uint256 ethAmount, uint256 time);\n\n    // Construct with our token details\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) ERC20(\"Rocket Pool ETH\", \"rETH\") {\n        // Version\n        version = 1;\n    }\n\n    // Receive an ETH deposit from a minipool or generous individual\n    receive() external payable {\n        // Emit ether deposited event\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\n    }\n\n    // Calculate the amount of ETH backing an amount of rETH\n    function getEthValue(uint256 _rethAmount) override public view returns (uint256) {\n        // Get network balances\n        RocketNetworkBalancesInterface rocketNetworkBalances = RocketNetworkBalancesInterface(getContractAddress(\"rocketNetworkBalances\"));\n        uint256 totalEthBalance = rocketNetworkBalances.getTotalETHBalance();\n        uint256 rethSupply = rocketNetworkBalances.getTotalRETHSupply();\n        // Use 1:1 ratio if no rETH is minted\n        if (rethSupply == 0) { return _rethAmount; }\n        // Calculate and return\n        return _rethAmount.mul(totalEthBalance).div(rethSupply);\n    }\n\n    // Calculate the amount of rETH backed by an amount of ETH\n    function getRethValue(uint256 _ethAmount) override public view returns (uint256) {\n        // Get network balances\n        RocketNetworkBalancesInterface rocketNetworkBalances = RocketNetworkBalancesInterface(getContractAddress(\"rocketNetworkBalances\"));\n        uint256 totalEthBalance = rocketNetworkBalances.getTotalETHBalance();\n        uint256 rethSupply = rocketNetworkBalances.getTotalRETHSupply();\n        // Use 1:1 ratio if no rETH is minted\n        if (rethSupply == 0) { return _ethAmount; }\n        // Check network ETH balance\n        require(totalEthBalance > 0, \"Cannot calculate rETH token amount while total network balance is zero\");\n        // Calculate and return\n        return _ethAmount.mul(rethSupply).div(totalEthBalance);\n    }\n\n    // Get the current ETH : rETH exchange rate\n    // Returns the amount of ETH backing 1 rETH\n    function getExchangeRate() override external view returns (uint256) {\n        return getEthValue(1 ether);\n    }\n\n    // Get the total amount of collateral available\n    // Includes rETH contract balance & excess deposit pool balance\n    function getTotalCollateral() override public view returns (uint25"
    }
  ]
}