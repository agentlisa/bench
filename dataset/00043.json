{
  "Title": "H-1: DOS in the claimWithdraw function due to an incorrect check of the lastFinalizedRequestId in the EEtherAdapter.sol",
  "Content": "# Issue H-1: DOS in the claimWithdraw function due to an incorrect check of the lastFinalizedRequestId in the EEtherAdapter.sol \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/55 \n\n## Found by \nDrynooo, KupiaSec, blutorque, merlin, whitehair0330\n## Summary\nThe `claimWithdrawal` function has an incorrect check of `lastFinalizedRequestId`, which lead to a DOS vulnerability in the `EEtherAdapter.claimWithdraw` function.\n```solidity\nif (_requestId < ETHERFI_WITHDRAW_NFT.lastFinalizedRequestId()) revert RequestInQueue();\n```\n\n## Vulnerability Detail\nLet's discuss how `WithdrawRequestNFT` handles withdrawal request IDs. When `requestWithdraw` is called, the `nextRequestId` is increased by one.\n```solidity\nuint256 requestId = nextRequestId++;\n```\nFor a user to successfully call the `claimWithdraw` function, the admin of `WithdrawRequestNFT` must call `finalizeRequests` with our `requestId`:\n```solidity\nfunction finalizeRequests(uint256 requestId) external onlyAdmin {\n        lastFinalizedRequestId = uint32(requestId);\n    }\n```\nSo, if a `requestId` is created and the admin finalizes our request id, then the user will be able to claim the withdrawal amount.\n\nHowever, the issue lies in the fact that `EEtherAdapter.claimWithdrawal` checks whether `_requestId >= ETHERFI_WITHDRAW_NFT.lastFinalizedRequestId()`, otherwise the call will fail.\n```solidity\nif (_requestId < ETHERFI_WITHDRAW_NFT.lastFinalizedRequestId()) revert RequestInQueue();\n```\n\nHowever, when we examine the `WithdrawRequestNFT.claimWithdrawal` function, we see a completely different check:\n```solidity\nrequire(tokenId < nextRequestId, \"Request does not exist\");\n--> require(tokenId <= lastFinalizedRequestId, \"Request is not finalized\");\nrequire(ownerOf(tokenId) != address(0), \"Already Claimed\");\n```\n\nFrom this, we can conclude that a user will only be able to call the `claimWithdrawal` function when `requestId = lastFinalizedRequestId`; otherwise, the call will fail.\n\nNow, if we examine [WithdrawRequestNFT](https://etherscan.io/address/0x7d5706f6ef3F89B3951E23e557CDFBC3239D4E2c#readProxyContract) on Etherscan, we can obtain the following information as of the report writing time:\n```code\nnextRequestId = 19059 \nlastFinalizedRequestId = 18833 \nThere are many finalized withdrawals that have not been claimed: 18832, 18831, 18741 etc\n```\nMost importantly, the admin calls `lastFinalizedRequestId` for each request ID, and the user can claim the withdrawal request ID later, meaning the main condition is that `tokenId <= lastFinalizedRequestId`.\n\nThis will result in a situation where if the admin calls lastFinalizedRequestId with our request ID and then with the next one, we will never be able to claim the withdrawal by this request ID.\n\n## Impact\nUsers will not lose their shares or receive the expected ETH, but this will impact `EEtherAdapter` as a whole because the `totalQueueEth` will be increased by the requested withdrawal amount, and it will not be possible to decrease it due to the DOS of the `claimWithdraw` function.\nAs `EEtherAdapter` is not an upgradable smart contract, I consider this issue to be of high severity.\n\n## Code Snippet\n[src/adapters/etherfi/EETHAdapter.sol#L63](https://github.com/sherlock-audit/2024-05-napier-update/blob/main/napier-v1/src/adapters/etherfi/EETHAdapter.sol#L63)\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider removing this check altogether, or you can implement it exactly as `EtherFi` does:\n```diff\n-if (_requestId < ETHERFI_WITHDRAW_NFT.lastFinalizedRequestId()) revert RequestInQueue();\n+if (_requestId > ETHERFI_WITHDRAW_NFT.lastFinalizedRequestId()) revert RequestInQueue();\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/napierfi/napier-v1/pull/222\n\n\n**sherlock-admin2**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "napier-v1/src/adapters/etherfi/EETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts@4.9.3/token/ERC721/IERC721Receiver.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\n\nimport {IWithdrawRequestNFT} from \"./interfaces/IWithdrawRequestNFT.sol\";\nimport {ILiquidityPool} from \"./interfaces/ILiquidityPool.sol\";\nimport {IWETH9} from \"../../interfaces/IWETH9.sol\";\nimport {IeETH} from \"./interfaces/IeETH.sol\";\n\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapter} from \"../BaseLSTAdapter.sol\";\n\n/// @title EEtherAdapter - eeETH\n/// @dev Important security note:\n/// 1. The staking rewards are distributed to the eETH holders by the rebasing mechanism\n/// where its balance is updated automatically on all the addresses.\n/// The rebase mechanism is implemented via shares where the share represents the eETH holder's\n/// share in the total amount of ether controlled by the ether.fi protocol.\n///\n/// 2. This contract doesn't independently keep track of the eETH balance, so it is possible\n/// for an attacker to directly transfer eETH to this contract, increase the share price.\ncontract EEtherAdapter is BaseLSTAdapter, IERC721Receiver {\n    using SafeCast for uint256;\n\n    error InvariantViolation();\n    error RequestInQueue();\n    error WithdrawalBelowMinimum();\n\n    /// @notice eETH\n    IeETH constant EETH = IeETH(Constants.EETH);\n\n    /// @dev EtherFi WithdrawRequestNFT\n    IWithdrawRequestNFT constant ETHERFI_WITHDRAW_NFT = IWithdrawRequestNFT(Constants.ETHERFI_WITHDRAW_REQUEST);\n\n    /// @dev EtherFi LiquidityPool\n    ILiquidityPool constant LIQUIDITY_POOL = ILiquidityPool(Constants.ETHERFI_LP);\n\n    receive() external payable {}\n\n    constructor(\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) BaseLSTAdapter(_rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock) ERC20(\"Napier EETH Adapter\", \"eeETH\") {\n        EETH.approve(address(LIQUIDITY_POOL), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from etherfi\n    /// @dev Reverts if there is no pending withdrawal\n    /// @dev Reverts if the withdrawal request is in queue by etherfi\n    /// @dev note eeETH scale may be decreased as etherfi has the withdrawal fee.\n    function claimWithdrawal(uint256 _requestId) external override nonReentrant {\n        uint256 queued = queueWithdrawal[_requestId];\n        if (queued == 0) revert NoPendingWithdrawal();\n\n        /// ASSERT ///\n        // EtherFi is completing withdraws internally and its number is set to lastFinalizedRequestId.\n        // If _requstId is finalized on etherfi, it's reverted.\n        if (_requestId < ETHERFI_WITHDRAW_NFT.lastFinalizedRequestId()) revert RequestInQueue();\n\n        /// INTERACT ///\n        // Claimed amount can be less than requested amount due to slashing.\n        uint256 balanceBefore = address(this).balance;\n        ETHERFI_WITHDRAW_NFT.claimWithdraw(_requestId);\n        uint256 claimed = address(this).balance - balanceBefore;\n        /// WRITE ///\n        delete queueWithdrawal[_requestId];\n        totalQueueEth -= queued.toUint128();\n        bufferEth += claimed.toUint128();\n\n        IWETH9(Constants.WETH).deposit{value: claimed}();\n        emit ClaimWithdrawal(_requestId, claimed);\n    }\n\n    /// @notice Stake ether to etherfi liquidity pool\n    /// @dev EtherFi doesn't have stake limit.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _eETHAmt = LIQUIDITY_POOL.deposit{value: stakeAmount}();\n\n        if (_eETHAmt == 0) revert InvariantViolation();\n        return stakeAmount;\n    }\n\n    /// @inheritdoc BaseLSTAdapter\n    function requestWithdrawalAll() external override nonReentrant onlyRebalancer {\n        /// INTERACT ///\n        (uint256 queuedEth, uint256 _requestId) = _requestWithdrawal(EETH.balanceOf(address(this)));\n        if (queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n        /// WRITE ///\n        totalQueueEth += queuedEth.toUint128();\n        queueWithdrawal[_requestId] = queuedEth;\n    }\n\n    /// @notice Request withdrawal for custom amount\n    function requestWithdrawal(uint256 withdrawAmount) external nonReentrant onlyRebalancer {\n        if (withdrawAmount > EETH.balanceOf(address(this))) revert InvalidWithdrawalAmount();\n        /// INTERACT ///\n        (uint256 queuedEth, uint256 _requestId) = _requestWithdrawal(withdrawAmount);\n        if (queueWithdrawal[_requestId] != 0) revert WithdrawalPending();\n        /// WRITE ///\n        totalQueueEth += queuedEth.toUint128();\n        queueWithdrawal[_requestId] = queuedEth;\n    }\n\n    /// @inheritdoc BaseLSTAdapter\n    function _requestWithdrawal(uint256 withdrawAmount) internal override returns (uint256, uint256) {\n        // The max amount for a request is 500 ether to chunk the large withdrawals into smaller ones.\n        if (withdrawAmount < 100) revert WithdrawalBelowMinimum();\n        if (withdrawAmount > 500 ether) withdrawAmount = 500 ether;\n\n        /// INTERACT ///\n        // The amount of ether that will be withdrawn is limited to\n        // the number of eETH tokens transferred to this contract at the moment of request.\n        // So, we will not receive the rewards for the period of time while these tokens stay in the queue.\n        uint256 _requestId = LIQUIDITY_POOL.requestWithdraw(address(this), withdrawAmount); // Dev: Ensure id is not 0\n        if (_requestId == 0) revert InvariantViolation();\n\n        emit RequestWithdrawal(_requestId, withdrawAmount);\n        return (withdrawAmount, _requestId);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        uint256 eEthBalance = EETH.balanceOf(address(this));\n        return totalQueueEth + bufferEth + eEthBalance;\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return 0x150b7a02; // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n    }\n}"
    }
  ]
}