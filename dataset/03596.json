{
  "Title": "[L08] Mismatched lower bounds for vault fees",
  "Content": "When a round is profitable, vaults assess two fees â€“ a performance fee and a management fee.\n\n\nThe [`setPerformanceFee`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L181) function allows `performanceFee` to be set to zero. However, the [`verifyConstructorParams`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L462) function, which is [called in `baseInitialize` for the vault](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol#L126), requires a [non-zero value](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/libraries/VaultLifecycle.sol#L472) for `performanceFee`. This discrepancy, coupled with a lack of inline documentation on the matter, can lead to confusion.\n\n\nConsider having a consistent permissible range for `performanceFee`. Further, to clarify intent and improve the overall readability of the codebase, consider documenting the reasoning behind the upper and lower bounds for all configurable values.\n\n\n**Update**: *Fixed in [commit `103568180c726dcc3dc5f3bf0f683c871d74132b` of PR#95](https://github.com/ribbon-finance/ribbon-v2/pull/95/commits/103568180c726dcc3dc5f3bf0f683c871d74132b).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/base/RibbonVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {OptionsVaultStorage} from \"../../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {IOtoken} from \"../../interfaces/GammaInterface.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {IGnosisAuction} from \"../../interfaces/IGnosisAuction.sol\";\nimport {\n    IStrikeSelection,\n    IOptionsPremiumPricer\n} from \"../../interfaces/IRibbon.sol\";\n\ncontract RibbonVault is OptionsVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    address public immutable WETH;\n    address public immutable USDC;\n\n    uint256 public constant delay = 1 hours;\n\n    uint256 public constant period = 7 days;\n\n    uint128 internal constant PLACEHOLDER_UINT = 1;\n\n    // Number of weeks per year = 52.142857 weeks * 10**6 = 52142857\n    // Dividing by weeks per year requires doing num.mul(10**6).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(address account, uint256 shares, uint256 round);\n\n    event Redeem(address indexed account, uint256 share, uint16 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap, address manager);\n\n    event Withdraw(address account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyConstructorParams(\n            _owner,\n            _feeRecipient,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(tokenName, tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee = _managementFee.mul(10**6).div(WEEKS_PER_YEAR);\n        vaultParams = _vaultParams;\n        vaultState.lastLockedAmount = uint104(\n            IERC20(vaultParams.asset).balanceOf(address(this))\n        );\n\n        vaultState.round = 1;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(newManagementFee < 100 * 10**6, \"Invalid management fee\");\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        // We are dividing annualized management fee by num weeks in a year\n        managementFee = newManagementFee.mul(10**6).div(WEEKS_PER_YEAR);\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(newPerformanceFee < 100 * 10**6, \"Invalid performance fee\");\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint104 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        uint256 oldCap = vaultParams.cap;\n        vaultParams.cap = newCap;\n        emit CapSet(oldCap, newCap, msg.sender);\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the asset is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(vaultParams.asset == WETH, \"!WETH\");\n        require(msg.value > 0, \"!value\");\n\n        _depositFor(msg.value, msg.sender);\n\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _depositFor(amount, msg.sender);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0));\n\n        _depositFor(amount, creditor);\n\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance().add(amount);\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = uint104(amount);\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            processed: false,\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: unredeemedShares\n        });\n\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).add(amount)\n        );\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param shares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint128 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool topup = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, shares, currentRound);\n\n        uint256 withdrawalShares = uint256(withdrawal.shares);\n\n        if (topup) {\n            uint256 increasedShares = withdrawalShares.add(shares);\n            ShareMath.assertUint128(increasedShares);\n            withdrawals[msg.sender].shares = uint128(increasedShares);\n        } else if (withdrawalShares == 0) {\n            withdrawals[msg.sender].shares = shares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        } else {\n            // If we have an old withdrawal, we revert\n            // The user has to process the withdrawal\n            revert(\"Existing withdraw\");\n        }\n\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).add(shares)\n        );\n\n        _transfer(msg.sender, address(this), shares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToUnderlying(\n                withdrawalShares,\n                roundPricePerShare[uint16(withdrawalRound)],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n        transferAsset(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem\n     */\n    function redeem(uint256 shares) external nonReentrant {\n        require(shares > 0, \"!shares\");\n        _redeem(shares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param shares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 shares, bool isMax) internal {\n        ShareMath.assertUint104(shares);\n\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint16 currentRound = vaultState.round;\n        require(depositReceipt.round < currentRound, \"Round not closed\");\n\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        shares = isMax ? unredeemedShares : shares;\n        require(shares > 0, \"!shares\");\n        require(shares <= unredeemedShares, \"Exceeds available\");\n\n        // This zeroes out any pending amount from depositReceipt\n        depositReceipts[msg.sender].amount = 0;\n        depositReceipts[msg.sender].processed = true;\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            uint256(unredeemedShares).sub(shares)\n        );\n\n        emit Redeem(msg.sender, shares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, shares);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /*\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds < 52, \"numRounds >= 52\");\n\n        uint16 _round = vaultState.round;\n        for (uint16 i = 0; i < numRounds; i++) {\n            uint16 index = _round + i;\n            require(index >= _round, \"Overflow\");\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = PLACEHOLDER_UINT;\n        }\n    }\n\n    /*\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @return newOption is the new option address\n     * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\n     */\n    function _rollToNextOption() internal returns (address, uint256) {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        address newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        (uint256 lockedBalance, uint256 newPricePerShare, uint256 mintShares) =\n            VaultLifecycle.rollover(\n                totalSupply(),\n                vaultParams.asset,\n                vaultParams.decimals,\n                vaultParams.initialSharePrice,\n                uint256(vaultState.totalPending),\n                vaultState.queuedWithdrawShares\n            );\n\n        optionState.currentOption = newOption;\n        optionState.nextOption = address(0);\n\n        // Finalize the pricePerShare at the end of the round\n        uint16 currentRound = vaultState.round;\n        roundPricePerShare[currentRound] = newPricePerShare;\n\n        // Take management / performance fee from previous round and deduct\n        lockedBalance = lockedBalance.sub(_collectVaultFees(lockedBalance));\n\n        vaultState.totalPending = 0;\n        vaultState.round = currentRound + 1;\n\n        _mint(address(this), mintShares);\n\n        return (newOption, lockedBalance);\n    }\n\n    /*\n     * @notice Helper function that transfers management fees and performance fees from previous round.\n     * @param currentLockedBalance is the balance we are about to lock for next round\n     * @return vaultFee is the fee deducted\n     */\n    function _collectVaultFees(uint256 currentLockedBalance)\n        internal\n        returns (uint256 vaultFee)\n    {\n        uint256 prevLockedAmount = vaultState.lastLockedAmount;\n        uint256 lockedBalanceSansPending =\n            currentLockedBalance.sub(vaultState.totalPending);\n\n        // Take performance fee and management fee ONLY if difference between\n        // last week and this week's vault deposits, taking into account pending\n        // deposits and withdrawals, is positive. If it is negative, last week's\n        // option expired ITM past breakeven, and the vault took a loss so we\n        // do not collect performance fee for last week\n        if (lockedBalanceSansPending > prevLockedAmount) {\n            uint256 performanceFeeInAsset =\n                performanceFee > 0\n                    ? lockedBalanceSansPending\n                        .sub(prevLockedAmount)\n                        .mul(performanceFee)\n                        .div(100 * 10**6)\n                    : 0;\n            uint256 managementFeeInAsset =\n                managementFee > 0\n                    ? currentLockedBalance.mul(managementFee).div(100 * 10**6)\n                    : 0;\n\n            vaultFee = performanceFeeInAsset.add(managementFeeInAsset);\n        }\n\n        if (vaultFee > 0) {\n            transferAsset(payable(feeRecipient), vaultFee);\n            emit CollectVaultFees(performanceFee, vaultFee, vaultState.round);\n        }\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function transferAsset(address payable recipient, uint256 amount) internal {\n        address asset = vaultParams.asset;\n        if (asset == WETH) {\n            IWETH(WETH).withdraw(amount);\n            (bool success, ) = recipient.call{value: amount}(\"\");\n            require(success, \"!success\");\n            return;\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the underlying balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint8 decimals = vaultParams.decimals;\n        uint256 numShares = shares(account);\n        uint256 pps =\n            totalBalance().sub(vaultState.totalPending).mul(10**decimals).div(\n                totalSupply()\n            );\n        return ShareMath.sharesToUnderlying(numShares, pps, decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount.add(heldByVault);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the vault (unredeemedShares)\n     */\n    function shareBalances(address account)\n        public\n        view\n        returns (uint256 heldByAccount, uint256 heldByVault)\n    {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.round < PLACEHOLDER_UINT) {\n            return (balanceOf(account), 0);\n        }\n\n        uint128 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        return (balanceOf(account), unredeemedShares);\n    }\n\n    /**\n     * @notice The price of a unit of share denominated in the `collateral`\n     */\n    function pricePerShare() external view returns (uint256) {\n        uint256 balance = totalBalance().sub(vaultState.totalPending);\n        return\n            (10**uint256(vaultParams.decimals)).mul(balance).div(totalSupply());\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        return\n            uint256(vaultState.lockedAmount).add(\n                IERC20(vaultParams.asset).balanceOf(address(this))\n            );\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    function cap() external view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    function nextOptionReadyAt() external view returns (uint256) {\n        return optionState.nextOptionReadyAt;\n    }\n\n    function currentOption() external view returns (address) {\n        return optionState.currentOption;\n    }\n\n    function nextOption() external view returns (address) {\n        return optionState.nextOption;\n    }\n\n    function totalPending() external view returns (uint256) {\n        return vaultState.totalPending;\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n}"
    }
  ]
}