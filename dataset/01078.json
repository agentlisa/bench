{
  "Title": "H-2: Reserves can be stolen by settling artificially created bad debt from them",
  "Content": "# Issue H-2: Reserves can be stolen by settling artificially created bad debt from them \n\nSource: https://github.com/sherlock-audit/2023-09-ajna-judging/issues/71 \n\n## Found by \nhyh\n\nIt is possible to inflate LUP and pull almost all the collateral from the loan, then settle this artificial bad debt off reserves, stealing all of them by repeating the attack.\n\n## Vulnerability Detail\n\nLUP is determined just in time of the execution, but `removeQuoteToken()` will check for `LUP > HTP = Loans.getMax(loans).thresholdPrice`, so the attack need to circumvent this. \n\nAttacker acts via 2 accounts under control, one for lending part, one for borrowing, having no previous positions in the given ERC20 pool.\nLet's say that pool state is as follows: `100` units of quote token utilized, and another `100` not utilized, for simplicity let's say all `100` are available, no auctions and no bad debt.\n\n1. Get 100 loan at TP = new HTP just below LUP (let's name this loan the manipulated_loan, ML), let's say LUP is such that `150` quote token units worth of collateral was provided (at market price)\n2. Add quote funds with `amount = {total utilized deposits} = 200` to a bucket significantly above the market (let's name it ultra_high_bucket, UHB)\n3. Remove collateral from the ML up to allowed by elevated LUP = UHB price, say it's 10x market one. I.e. almost all, say remove `140`, leaving `10` quote token units worth of collateral (at market price)\n4. Lender kick ML (removing funds from UHB will push LUP low and lender kick will be possible) to revive HTP reading\n5. Remove all from UHB except quote funds frozen by the auction, i.e. remove `100`, leave `100`\n\n1-5 go atomically in one tx.\n\nNo outside actors will be able to immediately benefit from the resulting situation as:\na. UHB remove quote token is blocked due to the frozen debt\nb. take is unprofitable while auction price is above market\nc. bucket take is unprofitable while auction price is above UHB price\n\nAt this point attacker accounting in net quote tokens worth is:\n1. `+100`, `-150`\n2. `-200`\n3. `+140`\n4.  \n5. `+100`\n\nAttacker has net `10` units of own capital still invested in the pool.\n\n6. Attacker wait for auction price reaching UHB price, calls `takeBucket` with `depositTake == true`.\nThe call can go with normal gas price as outside actors will not benefit from the such call and there will be no competition.\n`10` quote tokens worth of collateral will be placed to UHB and `98.482` units of quote token removed to cover the debt, `1.518` is the kicker's reward\n7. Attacker calls `settlePoolDebt()` which settles the remaining `1.518` of debt from pool reserves as ML has this amount of debt and no collateral\n8. Attacker removes all the funds from UHB with both initial and awarded LP shares, receiving `10` quote tokens worth of collateral and `1.518` quote token units of profit\n\n6-8 go atomically in one tx.\n\nAt this point attacker accounting in quote tokens is:\n\n6. (+kicker reward of ML stamped NP vs auction clearing UHB price in LP form)\n7. \n8. `+11.518`\n\nAttacker has net 0 units of own capital still invested in the pool, and receives `1.518` quote token units of profit.\n\nProfit part is a function of the pool's state, for the number above, assuming `auctionPrice == thresholdPrice = UHB price` and `poolRate_ = 0.05`: `1.518 = bondFactor * 100 = (npTpRatio - 1) / 10 * 100 = (1.04 + math.sqrt(0.05) / 2 - 1) / 10 * 100`, `bpf = bondFactor = takePenaltyFactor`.\n\n## Impact\n\nIt can be repeated to drain the whole reserves from the pool over time, i.e. reserves of any pool can be stolen this way.\n\n## Code Snippet\n\nLUP is the only guardian for removing the collateral:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/BorrowerActions.sol#L287-L307\n\n```solidity\n        if (vars.pull) {\n            // only intended recipient can pull collateral\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // calculate LUP only if it wasn't calculated in repay action\n            if (!vars.repay) result_.newLup = Deposits.getLup(deposits_, result_.poolDebt);\n\n>>          uint256 encumberedCollateral = Maths.wdiv(vars.borrowerDebt, result_.newLup);\n            if (\n                borrower.t0Debt != 0 && encumberedCollateral == 0 || // case when small amount of debt at a high LUP results in encumbered collateral calculated as 0\n                borrower.collateral < encumberedCollateral ||\n                borrower.collateral - encumberedCollateral < collateralAmountToPull_\n            ) revert InsufficientCollateral();\n\n            // stamp borrower Np to Tp ratio when pull collateral action\n            vars.stampNpTpRatio = true;\n\n            borrower.collateral -= collateralAmountToPull_;\n\n            result_.poolCollateral -= collateralAmountToPull_;\n        }\n```\n\nThe root cause is that bad debt is artificially created, with lender, borrower and kicker being controlled by the attacker, bad debt is then settled from the reserves:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/SettlerActions.sol#L143-L146\n\n```solidity\n            // settle debt from reserves (assets - liabilities) if reserves positive, round reserves down however\n            if (assets > liabilities) {\n                borrower.t0Debt -= Maths.min(borrower.t0Debt, Maths.floorWdiv(assets - liabilities, poolState_.inflator));\n            }\n```\n\nKicking will revive the HTP as `_kick()` removing target borrower from loans:\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/KickerActions.sol#L340-L341\n\n```solidity\n        // remove kicked loan from heap\n        Loans.remove(loans_, borrowerAddress_, loans_.indices[borrowerAddress_]);\n```\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/base/Pool.sol#L225-L249\n\n```solidity\n    function removeQuoteToken(\n        ...\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        ...\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLP_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            ...\n            RemoveQuoteParams({\n                maxAmount:      Maths.min(maxAmount_, _availableQuoteToken()),\n                index:          index_,\n>>              thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n```\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/external/LenderActions.sol#L434-L436\n\n```solidity\n        lup_ = Deposits.getLup(deposits_, poolState_.debt);\n\n>>      uint256 htp = Maths.wmul(params_.thresholdPrice, poolState_.inflator);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider introducing a buffer representing the expected kicker reward in addition to LUP, so this part of the loan will remain in the pool.\n\n\n\n## Discussion\n\n**kadenzipfel**\n\nEscalate\nShould be medium.\n\nAccording to the judging docs: \n- [How to identify a high issue](https://docs.sherlock.xyz/audits/judging/judging#iv.-how-to-identify-a-high-issue) \"3.  Significant loss of funds/large profit for the attacker at a minimal cost.\"\n- [How to identify a medium issue](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue) \"3. A material loss of funds, no/minimal profit for the attacker at a considerable cost\"\n\nThe profit margin from the provided example is ~0.4% (1.518 / (150 quote tokens worth of collateral at ML + 200 quote tokens at UHB) * 100%). This is consistent with the medium issue criteria (\"minimal profit\").\n\nThe minimum cost of the attack is greater than the total utilized deposits of the pool (**Note**: it's noted that the UHB is funded with the total utilized deposits of the pool, but the actual amount used in the example is 200, 2x the total utilized deposits and actually equal to the total utilized **and** unutilized deposits of the pool). Also note that it's not possible to use a flashloan in this circumstance since the attack requires multiple transactions across two EOAs. This is also consistent with the medium issue criteria (\"considerable cost\").\n\n**sherlock-admin2**\n\n > Escalate\n> Should be medium.\n> \n> According to the judging docs: \n> - [How to identify a high issue](https://docs.sherlock.xyz/audits/judging/judging#iv.-how-to-identify-a-high-issue) \"3.  Significant loss of funds/large profit for the attacker at a minimal cost.\"\n> - [How to identify a medium issue](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue) \"3. A material loss of funds, no/minimal profit for the attacker at a considerable cost\"\n> \n> The profit margin from the provided example is ~0.4% (1.518 / (150 quote tokens worth of collateral at ML + 200 quote tokens at UHB) * 100%). This is consistent with the medium issue criteria (\"minimal profit\").\n> \n> The minimum cost of the attack is greater than the total utilized deposits of the pool (**Note**: it's noted that the UHB is funded with the total utilized deposits of the pool, but the actual amount used in the example is 200, 2x the total utilized deposits and actually equal to the total utilized **and** unutilized deposits of the pool). Also note that it's not possible to use a flashloan in this circumstance since the attack requires multiple transactions across two EOAs. This is also consistent with the medium issue criteria (\"considerable cost\").\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neeksec**\n\nAgree with Escalation to downgrade severity to `Medium`.\n\n**dmitriia**\n\nThe use of flash loans is possible as borrower and lender can have the **same** address of the attacking smart contract, there is no restrictions in this regard. `0.4%` is the immediate, atomic profit margin. The funds that are required to stay in the contract for auction are `10`, not `200`. If flash loans are free, for example obtained from [Ajna itself](https://etherscan.io/address/0x65374cd7db203e0c9ea8b7da28a25dc770becb9e#readContract#F18), where it is [zero](https://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/base/FlashloanablePool.sol#L69), the total profit for the attacker in abstract quote token units is `1.518 - {2 days funding for 10} - total gas`.\n\nThis can be quite significant, say if `1 unit` here is `USDC 10k`, the profit is `15.18k - USDC_rate*2.0/365 * 100k - gas`. If we assume that USDC borrow rate is `10%` and total gas is `1 ETH = USD 2k`, it becomes `USDC 15.18 - 0.1*2.0/365*100 - 2 = 13.12k`. There is basically no market risk involved here, so it's arbitrage profit significant enough to compensate attacker for the efforts. This is for one pool and the attacking contract can be immediately reused for all the others.\n\nAs reserves of any pool can be drained this way fully, the reserves from all pools on all chains can be stolen. Since reserves burning is core monetization mechanics for protocl token this basically means that Ajna token will be worthless once this vector becomes public. Also, lack of reserves over time will move the growing share of pools to be insolvent as reserves also serve for bad debt coverage. Insolvency will render the pools unusable. The actual severity here is critical, but given the lack of this grade it is marked as high.\n\n**kadenzipfel**\n\n> 0.4% is the immediate, atomic profit margin.\n\nNo. As you explained in your example, steps 1-5 are atomic and by the end of step 5 the attacker is at a loss of 10 units of collateral. Profit doesn't occur until the attacker completes steps 6-8, and only if auction price gets low enough for attacker to execute these steps.\n\n> There is basically no market risk involved here\n\nThis is false. The attacker is at a 10 unit loss (10% of the entire total utilized deposits) for, by your estimation, 2 days. They only ever profit if the auction price reaches the UHB. The Ajna team thus has 2 days to assess a highly suspicious auction and prevent further losses, in which they can simply `take` the quote tokens before the attacker, griefing the attacker into a significant loss and disincentivizing the attack entirely. \n\nIn summary, regardless of flashloans, as noted in escalation: \n- The cost of the attack is still high (10% of the entire utilized deposits)\n- The attacker profit is low (best case ~13% by your example: 100k risk, 13.12k profit) or **possibly negative** if intervention.\n- The loss of funds incurred by the pool is also quite low at a maximum of ~0.76% (1.518 quote tokens lost / total pool size of 200 quote tokens * 100%)\n\n**kadenzipfel**\n\nThis issue should also be invalid until a valid proof of concept is provided considering this attack is highly complex and far from obvious. \nSee: [In case of non-obvious issues with complex vulnerabilities/attack paths, Watson must submit a valid POC for the issue to be considered valid and rewarded. ](https://docs.sherlock.xyz/audits/judging/judging#vi.-requirements)\n\n**dmitriia**\n\nMarket risk is risk that stems from movements of the market, it is absent in this scenario. Ajna team has little means to prevent the attack as the protocol is permissionless, while `take()` requires paying for collateral at prices substantially above the market, i.e. it is a material external investment that will be needed for all the pools. Also, if anyone takes before the attacker it will benefit them substantially (they are also a borrower, which will have their collateral priced even higher than they manipulated it themselves), resulting in even higher profitability, which will not disincentivize the attack.\n\n- `10` units is not a cost of attack, it is a short-term investment, which funding costs are taken into account,\n\n- `13%` for `2 days` is `(1.13) ^ (365 / 2) = 4 862 010 984 % APY` which is significantly above market rates and is attractive for the wide range of attackers,\n\n- This is loss per step. The reserves will be drained in full as nothing prevents attack to be immediately repeated. Also, it can be carried out simultaneously for many pools.\n\nAgain, this is critical severity vulnerability, having no low probability prerequisites and inflicting direct loss for the Ajna holders and pool's depositors (when reserves are lacking bad debt is written off from user's deposits starting with HPB).\n\n\n\n**dmitriia**\n\n> This issue should also be invalid until a valid proof of concept is provided considering this attack is highly complex and far from obvious\n\nProtocol team has already run PoC for this, @ith-harvey, please confirm.\n\n\n\n**Czar102**\n\nFrom my understanding, this bug makes it possible for the attacker to immediately create bad debt. Even if the earnings/losses are a small fraction of the whole TVL of the pool, it is extremely severe for a lending protocol. Planning to keep it a high severity issue unless I'm misinterpreting or missing something.\n\n**Czar102**\n\nResult:\nHigh\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [kadenzipfel](https://github.com/sherlock-audit/2023-09-ajna-judging/issues/71/#issuecomment-1800681290): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/114",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/external/BorrowerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    LoansState,\n    PoolState\n}                   from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    DrawDebtResult,\n    RepayDebtResult\n}                   from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _borrowFeeRate,\n    _priceAt,\n    _isCollateralized\n}                           from '../helpers/PoolHelper.sol';\nimport { \n    _revertIfPriceDroppedBelowLimit,\n    _revertOnMinDebt\n}                           from '../helpers/RevertsHelper.sol';\n\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\nimport { SettlerActions } from './SettlerActions.sol';\n\n/**\n    @title  BorrowerActions library\n    @notice External library containing logic for for pool actors:\n            - `Borrowers`: pledge collateral and draw debt; repay debt and pull collateral\n */\nlibrary BorrowerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `drawDebt` function local vars.\n    struct DrawDebtLocalVars {\n        bool    borrow;                // true if borrow action\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        uint256 compensatedCollateral; // [WAD] amount of borrower collateral that is compensated with LP (NFTs only)\n        uint256 t0BorrowAmount;        // [WAD] t0 amount to borrow\n        uint256 t0DebtChange;          // [WAD] additional t0 debt resulted from draw debt action\n        bool    pledge;                // true if pledge action\n        bool    stampNpTpRatio;        // true if loan's Np to Tp ratio should be restamped (when drawing debt or pledge settles auction)\n    }\n\n    /// @dev Struct used for `repayDebt` function local vars.\n    struct RepayDebtLocalVars {\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        uint256 compensatedCollateral; // [WAD] amount of borrower collateral that is compensated with LP (NFTs only)\n        bool    pull;                  // true if pull action\n        bool    repay;                 // true if repay action\n        bool    stampNpTpRatio;        // true if loan's Np to Tp ratio should be restamped (when repay settles auction or pull collateral)\n        uint256 t0RepaidDebt;          // [WAD] t0 debt repaid\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event LoanStamped(address indexed borrowerAddress);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionActive();\n    error BorrowerNotSender();\n    error BorrowerUnderCollateralized();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error InvalidAmount();\n    error LimitIndexExceeded();\n    error NoDebt();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolBorrowerActions` and `IERC721PoolBorrowerActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Loans.update` (`_upsert`):\n     *  @dev      insert or update loan in loans array\n     *  @dev      remove loan from loans array\n     *  @dev      update borrower in `address => borrower` mapping\n     *  @dev    === Reverts on ===\n     *  @dev    not enough quote tokens available `InsufficientLiquidity()`\n     *  @dev    borrower not sender `BorrowerNotSender()`\n     *  @dev    borrower debt less than pool min debt `AmountLTMinDebt()`\n     *  @dev    limit price reached `LimitIndexExceeded()`\n     *  @dev    borrower cannot draw more debt `BorrowerUnderCollateralized()`\n     *  @dev    borrower cannot be in auction `AuctionActive()`\n     */\n    function drawDebt(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        uint256 maxAvailable_,\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external returns (\n        DrawDebtResult memory result_\n    ) {\n        // revert if not enough pool balance to borrow\n        if (amountToBorrow_ > maxAvailable_) revert InsufficientLiquidity();\n\n        // revert if borrower is in auction\n        if(_inAuction(auctions_, borrowerAddress_)) revert AuctionActive();\n\n        DrawDebtLocalVars memory vars;\n        vars.pledge = collateralToPledge_ != 0;\n        vars.borrow = amountToBorrow_ != 0;\n\n        // revert if no amount to pledge or borrow\n        if (!vars.pledge && !vars.borrow) revert InvalidAmount();\n\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n        result_.t0PoolDebt          = poolState_.t0Debt;\n        result_.poolDebt            = poolState_.debt;\n        result_.poolCollateral      = poolState_.collateral;\n        result_.remainingCollateral = borrower.collateral;\n\n        if (vars.pledge) {\n            // add new amount of collateral to pledge to borrower balance\n            borrower.collateral  += collateralToPledge_;\n\n            result_.remainingCollateral += collateralToPledge_;\n            result_.newLup              = Deposits.getLup(deposits_, result_.poolDebt);\n\n            // add new amount of collateral to pledge to pool balance\n            result_.poolCollateral += collateralToPledge_;\n        }\n\n        if (vars.borrow) {\n            // only intended recipient can borrow quote\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            vars.t0BorrowAmount = Maths.ceilWdiv(amountToBorrow_, poolState_.inflator);\n\n            // t0 debt change is t0 amount to borrow plus the origination fee\n            vars.t0DebtChange = Maths.wmul(vars.t0BorrowAmount, _borrowFeeRate(poolState_.rate) + Maths.WAD);\n\n            borrower.t0Debt += vars.t0DebtChange;\n\n            vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n            // check that drawing debt doesn't leave borrower debt under pool min debt amount\n            _revertOnMinDebt(\n                loans_,\n                result_.poolDebt,\n                vars.borrowerDebt,\n                poolState_.quoteTokenScale\n            );\n\n            // add debt change to pool's debt\n            result_.t0PoolDebt += vars.t0DebtChange;\n            result_.poolDebt   = Maths.wmul(result_.t0PoolDebt, poolState_.inflator);\n            result_.newLup     = Deposits.getLup(deposits_, result_.poolDebt);\n\n            // revert if borrow drives LUP price under the specified price limit\n            _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n\n            // use new lup to check borrow action won't push borrower into a state of under-collateralization\n            // this check also covers the scenario when loan is already auctioned\n            if (!_isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)) {\n                revert BorrowerUnderCollateralized();\n            }\n\n            // stamp borrower Np to Tp ratio when draw debt\n            vars.stampNpTpRatio = true;\n        }\n\n        // update loan state\n        Loans.update(\n            loans_,\n            borrower,\n            borrowerAddress_,\n            poolState_.rate,\n            false,                          // loan not in auction\n            vars.stampNpTpRatio\n        );\n\n        result_.debtPostAction       = borrower.t0Debt;\n        result_.collateralPostAction = borrower.collateral;\n    }\n\n    /**\n     *  @notice See `IERC20PoolBorrowerActions` and `IERC721PoolBorrowerActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Loans.update` (`_upsert`):\n     *  @dev      insert or update loan in loans array\n     *  @dev      remove loan from loans array\n     *  @dev      update borrower in `address => borrower` mapping\n     *  @dev    === Reverts on ===\n     *  @dev    no debt to repay `NoDebt()`\n     *  @dev    borrower debt less than pool min debt `AmountLTMinDebt()`\n     *  @dev    borrower not sender `BorrowerNotSender()`\n     *  @dev    not enough collateral to pull `InsufficientCollateral()`\n     *  @dev    limit price reached `LimitIndexExceeded()`\n     *  @dev    borrower cannot be in auction `AuctionActive()`\n     */\n    function repayDebt(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_,\n        uint256 limitIndex_\n    ) external returns (\n        RepayDebtResult memory result_\n    ) {\n        RepayDebtLocalVars memory vars;\n        vars.repay = maxQuoteTokenAmountToRepay_ != 0;\n        vars.pull  = collateralAmountToPull_     != 0;\n\n        // revert if no amount to pull or repay\n        if (!vars.repay && !vars.pull) revert InvalidAmount();\n\n        if(_inAuction(auctions_, borrowerAddress_)) revert AuctionActive();\n\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n        result_.t0PoolDebt          = poolState_.t0Debt;\n        result_.poolDebt            = poolState_.debt;\n        result_.poolCollateral      = poolState_.collateral;\n        result_.remainingCollateral = borrower.collateral;\n\n        if (vars.repay) {\n            if (borrower.t0Debt == 0) revert NoDebt();\n\n            if (maxQuoteTokenAmountToRepay_ == type(uint256).max) {\n                vars.t0RepaidDebt = borrower.t0Debt;\n            } else {\n                vars.t0RepaidDebt = Maths.min(\n                    borrower.t0Debt,\n                    Maths.floorWdiv(maxQuoteTokenAmountToRepay_, poolState_.inflator)\n                );\n            }\n\n            result_.quoteTokenToRepay = Maths.ceilWmul(vars.t0RepaidDebt, poolState_.inflator);\n            // revert if (due to roundings) calculated token amount to repay is 0\n            if (result_.quoteTokenToRepay == 0) revert InvalidAmount();\n\n            result_.t0PoolDebt -= vars.t0RepaidDebt;\n            result_.poolDebt   = Maths.wmul(result_.t0PoolDebt, poolState_.inflator);\n\n            vars.borrowerDebt = Maths.wmul(borrower.t0Debt - vars.t0RepaidDebt, poolState_.inflator);\n\n            // check that paying the loan doesn't leave borrower debt under min debt amount\n            _revertOnMinDebt(\n                loans_,\n                result_.poolDebt,\n                vars.borrowerDebt,\n                poolState_.quoteTokenScale\n            );\n\n            result_.newLup = Deposits.getLup(deposits_, result_.poolDebt);\n            borrower.t0Debt -= vars.t0RepaidDebt;\n        }\n\n        if (vars.pull) {\n            // only intended recipient can pull collateral\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // calculate LUP only if it wasn't calculated in repay action\n            if (!vars.repay) result_.newLup = Deposits.getLup(deposits_, result_.poolDebt);\n\n            uint256 encumberedCollateral = Maths.wdiv(vars.borrowerDebt, result_.newLup);\n            if (\n                borrower.t0Debt != 0 && encumberedCollateral == 0 || // case when small amount of debt at a high LUP results in encumbered collateral calculated as 0\n                borrower.collateral < encumberedCollateral ||\n                borrower.collateral - encumberedCollateral < collateralAmountToPull_\n            ) revert InsufficientCollateral();\n\n            // stamp borrower Np to Tp ratio when pull collateral action\n            vars.stampNpTpRatio = true;\n\n            borrower.collateral -= collateralAmountToPull_;\n\n            result_.poolCollateral -= collateralAmountToPull_;\n        }\n\n        // check limit price and revert if price dropped below\n        _revertIfPriceDroppedBelowLimit(result_.newLup, limitIndex_);\n\n        // update loan state\n        Loans.update(\n            loans_,\n            borrower,\n            borrowerAddress_,\n            poolState_.rate,\n            false,                         // loan not in auction\n            vars.stampNpTpRatio\n        );\n\n        result_.debtPostAction       = borrower.t0Debt;\n        result_.collateralPostAction = borrower.collateral;\n    }\n\n    /**\n     *  @notice See `IPoolBorrowerActions` for descriptions\n     *  @dev    === Write state ===\n     *  @dev    - `Loans.update` (`_upsert`):\n     *  @dev      insert or update loan in loans array\n     *  @dev      remove loan from loans array\n     *  @dev      update borrower in `address => borrower` mapping\n     *  @dev    === Reverts on ===\n     *  @dev    auction active `AuctionActive()`\n     *  @dev    loan not fully collateralized `BorrowerUnderCollateralized()`\n     *  @dev    === Emit events ===\n     *  @dev    - `LoanStamped`\n     */\n    function stampLoan(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_\n    ) external returns (\n        uint256 newLup_\n    ) {\n        // revert if loan is in auction\n        if (_inAuction(auctions_, msg.sender)) revert AuctionActive();\n\n        Borrower memory borrower = loans_.borrowers[msg.sender];\n\n        newLup_ = Deposits.getLup(deposits_, poolState_.debt);\n\n        // revert if loan is not fully collateralized at current LUP\n        if (\n            !_isCollateralized(\n                Maths.wmul(borrower.t0Debt, poolState_.inflator), // current borrower debt\n                borrower.collateral,\n                newLup_,\n                poolState_.poolType\n            )\n        ) revert BorrowerUnderCollateralized();\n\n        // update loan state to stamp Np to Tp ratio\n        Loans.update(\n            loans_,\n            borrower,\n            msg.sender,\n            poolState_.rate,\n            false,          // loan not in auction\n            true            // stamp Np to Tp ratio of the loan\n        );\n\n        emit LoanStamped(msg.sender);\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     *  @notice Returns `true` if borrower is in auction.\n     *  @dev    Used to accuratley increment and decrement `t0DebtInAuction` accumulator.\n     *  @param  auctions_ Struct for pool auctions state.\n     *  @param  borrower_ Borrower address to check auction status for.\n     *  @return `True` if borrower is in auction.\n     */\n    function _inAuction(\n        AuctionsState storage auctions_,\n        address borrower_\n    ) internal view returns (bool) {\n        return auctions_.liquidations[borrower_].kickTime != 0;\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/libraries/external/SettlerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                       from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    SettleParams,\n    SettleResult\n}                       from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _auctionPrice,\n    _indexOf,\n    _priceAt,\n    MAX_FENWICK_INDEX,\n    MIN_PRICE,\n    DEPOSIT_BUFFER   \n}  from '../helpers/PoolHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auction settler library\n    @notice External library containing actions involving auctions within pool:\n            - `settle` auctions\n */\nlibrary SettlerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `_settlePoolDebtWithDeposit` function local vars.\n    struct SettleLocalVars {\n        uint256 collateralUsed;     // [WAD] collateral used to settle debt\n        uint256 debt;               // [WAD] debt to settle\n        uint256 hpbCollateral;      // [WAD] amount of collateral in HPB bucket\n        uint256 hpbUnscaledDeposit; // [WAD] unscaled amount of of quote tokens in HPB bucket before settle\n        uint256 hpbLP;              // [WAD] amount of LP in HPB bucket\n        uint256 index;              // index of settling bucket\n        uint256 maxSettleableDebt;  // [WAD] max amount that can be settled with existing collateral\n        uint256 price;              // [WAD] price of settling bucket\n        uint256 scaledDeposit;      // [WAD] scaled amount of quote tokens in bucket\n        uint256 scale;              // [WAD] scale of settling bucket\n        uint256 unscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AuctionSettle(address indexed borrower, uint256 collateral);\n    event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lp, uint256 index);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event Settle(address indexed borrower, uint256 settledDebt);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionNotClearable();\n    error NoAuction();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolSettlerActions` for descriptions.\n     *  @notice Settles the debt of the given loan / borrower by performing following steps:\n     *          1. settle debt with `HPB`s deposit, up to specified buckets depth.\n     *          2. settle debt with pool reserves (if there's still debt and no collateral left after step 1).\n     *          3. forgive bad debt from next `HPB`, up to remaining buckets depth (and if there's still debt after step 2).\n     *  @dev    === Write state ===\n     *  @dev    update borrower state\n     *  @dev    === Reverts on ===\n     *  @dev    loan is not in auction `NoAuction()`\n     *  @dev    `72` hours didn't pass and auction still has collateral `AuctionNotClearable()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Settle`\n     *  @return result_ The `SettleResult` struct result of settle action.\n     */\n    function settlePoolDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        ReserveAuctionState storage reserveAuction_,\n        PoolState calldata poolState_,\n        SettleParams memory params_\n    ) external returns (SettleResult memory result_) {\n        uint256 kickTime = auctions_.liquidations[params_.borrower].kickTime;\n        if (kickTime == 0) revert NoAuction();\n\n        Borrower memory borrower = loans_.borrowers[params_.borrower];\n        if ((block.timestamp - kickTime <= 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n        result_.t0DebtSettled       = borrower.t0Debt;\n        result_.collateralSettled   = borrower.collateral;\n\n        // 1. settle debt with HPB deposit\n        (\n            borrower.t0Debt,\n            borrower.collateral,\n            params_.bucketDepth\n        ) = _settlePoolDebtWithDeposit(\n            buckets_,\n            deposits_,\n            params_,\n            borrower,\n            poolState_.inflator\n        );\n\n        if (borrower.t0Debt != 0 && borrower.collateral == 0) {\n            // 2. settle debt with pool reserves\n            uint256 assets = Maths.floorWmul(poolState_.t0Debt - result_.t0DebtSettled + borrower.t0Debt, poolState_.inflator) + params_.poolBalance;\n\n            uint256 liabilities =\n                // require 1.0 + 1e-9 deposit buffer (extra margin) for deposits\n                Maths.wmul(DEPOSIT_BUFFER, Deposits.treeSum(deposits_)) +\n                auctions_.totalBondEscrowed +\n                reserveAuction_.unclaimed;\n\n            // settle debt from reserves (assets - liabilities) if reserves positive, round reserves down however\n            if (assets > liabilities) {\n                borrower.t0Debt -= Maths.min(borrower.t0Debt, Maths.floorWdiv(assets - liabilities, poolState_.inflator));\n            }\n\n            // 3. forgive bad debt from next HPB\n            if (borrower.t0Debt != 0) {\n                borrower.t0Debt = _forgiveBadDebt(\n                    buckets_,\n                    deposits_,\n                    params_,\n                    borrower,\n                    poolState_.inflator\n                );\n            }\n        }\n\n        // complete result struct with debt settled\n        result_.t0DebtSettled -= borrower.t0Debt;\n\n        emit Settle(\n            params_.borrower,\n            result_.t0DebtSettled\n        );\n\n        // if entire debt was settled then settle auction\n        if (borrower.t0Debt == 0) {\n            (borrower.collateral, ) = _settleAuction(\n                auctions_,\n                buckets_,\n                deposits_,\n                params_.borrower,\n                borrower.collateral,\n                poolState_.poolType\n            );\n        }\n\n        // complete result struct with debt and collateral post action and collateral settled\n        result_.debtPostAction      = borrower.t0Debt;\n        result_.collateralRemaining = borrower.collateral;\n        result_.collateralSettled   -= result_.collateralRemaining;\n\n        // update borrower state\n        loans_.borrowers[params_.borrower] = borrower;\n    }\n\n    /***************************/\n    /***  Internal Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Performs auction settle based on pool type, emits settle event and removes auction from auctions queue.\n     *  @dev    === Emit events ===\n     *  @dev    - `AuctionNFTSettle` or `AuctionSettle`\n     *  @param  auctions_              Struct for pool auctions state.\n     *  @param  buckets_               Struct for pool buckets state.\n     *  @param  deposits_              Struct for pool deposits state.\n     *  @param  borrowerAddress_       Address of the borrower that exits auction.\n     *  @param  borrowerCollateral_    Borrower collateral amount before auction exit (in `NFT` could be fragmented as result of partial takes).\n     *  @param  poolType_              Type of the pool (can be `ERC20` or `ERC721`).\n     *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for `ERC20` pool, rounded collateral for `ERC721` pool).\n     *  @return compensatedCollateral_ Amount of collateral compensated (`ERC721` settle only), to be deducted from pool pledged collateral accumulator. Always `0` for `ERC20` pools.\n     */\n    function _settleAuction(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        address borrowerAddress_,\n        uint256 borrowerCollateral_,\n        uint256 poolType_\n    ) internal returns (uint256 remainingCollateral_, uint256 compensatedCollateral_) {\n\n        if (poolType_ == uint8(PoolType.ERC721)) {\n            uint256 lp;\n            uint256 bucketIndex;\n\n            // floor collateral of borrower\n            remainingCollateral_ = (borrowerCollateral_ / Maths.WAD) * Maths.WAD;\n\n            // if there's fraction of NFTs remaining then reward difference to borrower as LP in auction price bucket\n            if (remainingCollateral_ != borrowerCollateral_) {\n\n                // calculate the amount of collateral that should be compensated with LP\n                compensatedCollateral_ = borrowerCollateral_ - remainingCollateral_;\n\n                uint256 auctionPrice = _auctionPrice(\n                    auctions_.liquidations[borrowerAddress_].referencePrice,\n                    auctions_.liquidations[borrowerAddress_].kickTime\n                );\n\n                // determine the bucket index to compensate fractional collateral\n                bucketIndex = auctionPrice > MIN_PRICE ? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;\n\n                // deposit collateral in bucket and reward LP to compensate fractional collateral\n                lp = Buckets.addCollateral(\n                    buckets_[bucketIndex],\n                    borrowerAddress_,\n                    Deposits.valueAt(deposits_, bucketIndex),\n                    compensatedCollateral_,\n                    _priceAt(bucketIndex)\n                );\n            }\n\n            emit AuctionNFTSettle(\n                borrowerAddress_,\n                remainingCollateral_,\n                lp,\n                bucketIndex\n            );\n\n        } else {\n            remainingCollateral_ = borrowerCollateral_;\n\n            emit AuctionSettle(\n                borrowerAddress_,\n                remainingCollateral_\n            );\n        }\n\n        _removeAuction(auctions_, borrowerAddress_);\n    }\n\n    /**\n     *  @notice Removes auction and repairs the queue order.\n     *  @notice Updates kicker's claimable balance with bond size awarded and subtracts bond size awarded from `liquidationBondEscrowed`.\n     *  @dev    === Write state ===\n     *  @dev    decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *  @dev    decrement auctions count accumulator\n     *  @dev    update auction queue state\n     *  @param  auctions_ Struct for pool auctions state.\n     *  @param  borrower_ Auctioned borrower address.\n     */\n    function _removeAuction(\n        AuctionsState storage auctions_,\n        address borrower_\n    ) internal {\n        Liquidation memory liquidation = auctions_.liquidations[borrower_];\n        // update kicker balances\n        Kicker storage kicker = auctions_.kickers[liquidation.kicker];\n\n        kicker.locked    -= liquidation.bondSize;\n        kicker.claimable += liquidation.bondSize;\n\n        // decrement number of active auctions\n        -- auctions_.noOfAuctions;\n\n        // update auctions queue\n        if (auctions_.head == borrower_ && auctions_.tail == borrower_) {\n            // liquidation is the head and tail\n            auctions_.head = address(0);\n            auctions_.tail = address(0);\n        }\n        else if(auctions_.head == borrower_) {\n            // liquidation is the head\n            auctions_.liquidations[liquidation.next].prev = address(0);\n            auctions_.head = liquidation.next;\n        }\n        else if(auctions_.tail == borrower_) {\n            // liquidation is the tail\n            auctions_.liquidations[liquidation.prev].next = address(0);\n            auctions_.tail = liquidation.prev;\n        }\n        else {\n            // liquidation is in the middle\n            auctions_.liquidations[liquidation.prev].next = liquidation.next;\n            auctions_.liquidations[liquidation.next].prev = liquidation.prev;\n        }\n        // delete liquidation\n        delete auctions_.liquidations[borrower_];\n    }\n\n    /**\n     *  @notice Called to settle debt using `HPB` deposits, up to the number of specified buckets depth.\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledRemove()` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @param  buckets_             Struct for pool buckets state.\n     *  @param  deposits_            Struct for pool deposits state.\n     *  @param  params_              Struct containing params for settle action.\n     *  @param  borrower_            Struct containing borrower details.\n     *  @param  inflator_            Current pool inflator.\n     *  @return remainingt0Debt_     Remaining borrower `t0` debt after settle with `HPB`.\n     *  @return remainingCollateral_ Remaining borrower collateral after settle with `HPB`.\n     *  @return bucketDepth_         Number of buckets to use for forgiving debt in case there's more remaining.\n     */\n    function _settlePoolDebtWithDeposit(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        SettleParams memory params_,\n        Borrower memory borrower_,\n        uint256 inflator_\n    ) internal returns (uint256 remainingt0Debt_, uint256 remainingCollateral_, uint256 bucketDepth_) {\n        remainingt0Debt_     = borrower_.t0Debt;\n        remainingCollateral_ = borrower_.collateral;\n        bucketDepth_         = params_.bucketDepth;\n\n        while (bucketDepth_ != 0 && remainingt0Debt_ != 0 && remainingCollateral_ != 0) {\n            SettleLocalVars memory vars;\n\n            (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            vars.hpbUnscaledDeposit    = Deposits.unscaledValueAt(deposits_, vars.index);\n            vars.unscaledDeposit       = vars.hpbUnscaledDeposit;\n            vars.price                 = _priceAt(vars.index);\n\n            if (vars.unscaledDeposit != 0) {\n                vars.debt              = Maths.wmul(remainingt0Debt_, inflator_);           // current debt to be settled\n                vars.maxSettleableDebt = Maths.floorWmul(remainingCollateral_, vars.price); // max debt that can be settled with existing collateral\n                vars.scaledDeposit     = Maths.wmul(vars.scale, vars.unscaledDeposit);\n\n                // 1) bucket deposit covers remaining loan debt to settle, loan's collateral can cover remaining loan debt to settle\n                if (vars.scaledDeposit >= vars.debt && vars.maxSettleableDebt >= vars.debt) {\n                    // remove only what's needed to settle the debt\n                    vars.unscaledDeposit = Maths.wdiv(vars.debt, vars.scale);\n                    vars.collateralUsed  = Maths.ceilWdiv(vars.debt, vars.price);\n\n                    // settle the entire debt\n                    remainingt0Debt_ = 0;\n                }\n                // 2) bucket deposit can not cover all of loan's remaining debt, bucket deposit is the constraint\n                else if (vars.maxSettleableDebt >= vars.scaledDeposit) {\n                    vars.collateralUsed = Maths.ceilWdiv(vars.scaledDeposit, vars.price);\n\n                    // subtract from debt the corresponding t0 amount of deposit\n                    remainingt0Debt_ -= Maths.floorWdiv(vars.scaledDeposit, inflator_);\n                }\n                // 3) loan's collateral can not cover remaining loan debt to settle, loan collateral is the constraint\n                else {\n                    vars.unscaledDeposit = Maths.wdiv(vars.maxSettleableDebt, vars.scale);\n                    vars.collateralUsed  = remainingCollateral_;\n\n                    remainingt0Debt_ -= Maths.floorWdiv(vars.maxSettleableDebt, inflator_);\n                }\n\n                // remove settled collateral from loan\n                remainingCollateral_ -= vars.collateralUsed;\n\n                // use HPB bucket to swap loan collateral for loan debt\n                Bucket storage hpb = buckets_[vars.index];\n                vars.hpbLP         = hpb.lps;\n                vars.hpbCollateral = hpb.collateral + vars.collateralUsed;\n\n                // set amount to remove as min of calculated amount and available deposit (to prevent rounding issues)\n                vars.unscaledDeposit    = Maths.min(vars.hpbUnscaledDeposit, vars.unscaledDeposit);\n                vars.hpbUnscaledDeposit -= vars.unscaledDeposit;\n\n                // remove amount to settle debt from bucket (could be entire deposit or only the settled debt)\n                Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);\n\n                // check if bucket healthy - set bankruptcy if collateral is 0 and entire deposit was used to settle and there's stil"
    }
  ]
}