{
  "Title": "Unhandled chainlink revert in case its multisigs block access to price feeds",
  "Content": "# Unhandled chainlink revert in case its multisigs block access to price feeds\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L20-L62\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L20-L62</a>\n\n\n## Summary\n\nIn some extreme cases, oracles can be taken offline or token prices can fall to zero. Therefore a call to `latestRoundData` could potentially revert and none of the circuit breakers would fallback to query any prices automatically.\n\n## Vulnerability Details\n\nAccording to Ditto’s documentation in https://dittoeth.com/technical/oracles, there are two circuit breaking events if Chainlink data becomes unusable: Invalid Fetch Data and Price Deviation. \n\nThe issue arises from the possibility that Chainlink multisignature entities might intentionally block access to the price feed. In such a scenario, the invocation of the `latestRoundData` function could potentially trigger a revert, rendering the circuit-breaking events ineffective in mitigating the consequences, as they would be incapable of querying any price data or specific information.\n\nIn certain exceptional circumstances, Chainlink has already taken the initiative to temporarily suspend specific oracles. As an illustrative instance, during the UST collapse incident, Chainlink opted to halt the UST/ETH price oracle to prevent the dissemination of erroneous data to various protocols.\n\nAdditionally, these dangerous oracle's scenarios are very well documented by OpenZeppelin in https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles. For our context:\n\n*\"While currently there’s no whitelisting mechanism to allow or disallow contracts from reading prices, powerful  multisigs can tighten these access controls. In other words, the multisigs can immediately block access to price feeds at will. Therefore, to prevent denial of service scenarios, it is recommended to query ChainLink price feeds using a defensive approach with Solidity’s try/catch structure. In this way, if the call to the price feed fails, the caller contract is still in control and can handle any errors safely and explicitly\".*\n\nAlthough a fallback mechanism, specifically the TWAP, is in place to uphold system functionality in the event of Chainlink failure, it is imperative to note that Ditto's documentation **explicitly underscores its substantial reliance on oracles**. Consequently, it is imperative to address this issue comprehensively within the codebase, given that it pertains to one of the fundamental functionalities of the environment. \n\n## Proof of Concept\n\nAs mentioned above, In order to mitigate the potential risks associated with a denial-of-service scenario, it is advisable to employ a `try-catch` mechanism when querying Chainlink prices in the function `getOraclePrice` under LibOracle.sol. Through this approach, in the event of a failure in the invocation of the price feed, the caller contract retains command and can adeptly manage any errors in a secure and explicit manner.\n\nhttps://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L25-L32\n\n```\n (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n```\n\nHere I enumerate some of the core functions that will be affected in case of an unhandled oracle revert:\n\nFunction createMarket under OwnerFacet.sol: \n\nhttps://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/OwnerFacet.sol#L47-L68\n\nFunction updateOracleAndStartingShort under LibOrders.sol:\n\nhttps://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOrders.sol#L812-L816 \n\nFunction getShortIdAtOracle under ViewFaucet.sol:\n\nhttps://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ViewFacet.sol#L173-L187 \n\n\n## Impact\n\nIf a configured Oracle feed has malfunctioned or ceased operating, it will produce a revert when checking for `latestRoundData` that would need to be manually handled by the system.\n\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nEncase the invocation of the function `latestRoundData()` within a `try-catch` construct instead of invoking it directly. In circumstances where the function call results in a revert, the catch block may serve the purpose of invoking an alternative oracle or managing the error in a manner that is deemed appropriate for the system. \n\n\n\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/OwnerFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OwnerFacet is Modifiers {\n    using U256 for uint256;\n\n    /**\n     * @notice Initialize data for newly deployed market\n     * @dev Single use only\n     *\n     * @param asset The market that will be impacted\n     * @param a The market settings\n     */\n\n    /*\n     * @param oracle The oracle for the asset\n     * @param initialMargin Initial margin value of the new market\n     * @param primaryLiquidationCR Liquidation ratio (Maintenance margin) value of the new market\n     * @param secondaryLiquidationCR CRatio threshold for secondary liquidations\n     * @param forcedBidPriceBuffer Liquidation limit value of the new market\n     * @param minimumCR Lowest threshold for shortRecord to not lose collateral during liquidation\n     * @param resetLiquidationTime Time limit for when flagged shorts get reset\n     * @param secondLiquidationTime Time limit for when flagged shorts can be liquidated by others, not just flagger\n     * @param firstLiquidationTime Time limit for when flagged shorts get be liquidated by flagger\n     * @param tappFeePct Primary liquidation fee sent to TAPP out of shorter collateral\n     * @param callerFeePct Primary liquidation fee sent to margin caller out of shorter collateral\n     * @param minBidEth Minimum bid dust amount\n     * @param minAskEth Minimum ask dust amount\n     * @param minShortErc Minimum short record debt amount\n    */\n\n    function createMarket(address asset, STypes.Asset memory a) external onlyDAO {\n        STypes.Asset storage Asset = s.asset[asset];\n        // can check non-zero ORDER_ID to prevent creating same asset\n        if (Asset.orderId != 0) revert Errors.MarketAlreadyCreated();\n\n        Asset.vault = a.vault;\n        _setAssetOracle(asset, a.oracle);\n\n        Asset.assetId = uint8(s.assets.length);\n        s.assetMapping[s.assets.length] = asset;\n        s.assets.push(asset);\n\n        STypes.Order memory guardOrder;\n        guardOrder.prevId = Constants.HEAD;\n        guardOrder.id = Constants.HEAD;\n        guardOrder.nextId = Constants.TAIL;\n        //@dev parts of OB depend on having sell's HEAD's price and creationTime = 0\n        s.asks[asset][Constants.HEAD] = s.shorts[asset][Constants.HEAD] = guardOrder;\n\n        //@dev Using Bid's HEAD's order contain oracle data\n        guardOrder.creationTime = LibOrders.getOffsetTime();\n        guardOrder.ercAmount = uint80(LibOracle.getOraclePrice(asset));\n        s.bids[asset][Constants.HEAD] = guardOrder;\n\n        //@dev hardcoded value\n        Asset.orderId = Constants.STARTING_ID; // 100\n        Asset.startingShortId = Constants.HEAD;\n\n        //@dev comment with initial values\n        _setInitialMargin(asset, a.initialMargin); // 500 -> 5 ether\n        _setPrimaryLiquidationCR(asset, a.primaryLiquidationCR); // 400 -> 4 ether\n        _setSecondaryLiquidationCR(asset, a.secondaryLiquidationCR); // 150 -> 1.5 ether\n        _setForcedBidPriceBuffer(asset, a.forcedBidPriceBuffer); // 110 -> 1.1 ether\n        _setMinimumCR(asset, a.minimumCR); // 110 -> 1.1 ether\n        _setResetLiquidationTime(asset, a.resetLiquidationTime); // 1600 -> 16 hours\n        _setSecondLiquidationTime(asset, a.secondLiquidationTime); // 1200 -> 12 hours\n        _setFirstLiquidationTime(asset, a.firstLiquidationTime); // 1000 -> 10 hours\n        _setTappFeePct(asset, a.tappFeePct); //25 -> .025 ether\n        _setCallerFeePct(asset, a.callerFeePct); //5 -> .005 ether\n        _setMinBidEth(asset, a.minBidEth); //1 -> 0.001 ether\n        _setMinAskEth(asset, a.minAskEth); //1 -> 0.001 ether\n        _setMinShortErc(asset, a.minShortErc); //2000 -> 2000 ether\n\n        // Create TAPP short\n        LibShortRecord.createShortRecord(\n            asset, address(this), SR.FullyFilled, 0, 0, 0, 0, 0\n        );\n        emit Events.CreateMarket(asset, Asset);\n    }\n\n    //@dev does not need read only re-entrancy\n    function owner() external view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n\n    function admin() external view returns (address) {\n        return s.admin;\n    }\n\n    //@dev does not need read only re-entrancy\n    function ownerCandidate() external view returns (address) {\n        return s.ownerCandidate;\n    }\n\n    function transferOwnership(address newOwner) external onlyDAO {\n        s.ownerCandidate = newOwner;\n        emit Events.NewOwnerCandidate(newOwner);\n    }\n\n    //@dev event emitted in setContractOwner\n    function claimOwnership() external {\n        if (s.ownerCandidate != msg.sender) revert Errors.NotOwnerCandidate();\n        LibDiamond.setContractOwner(msg.sender);\n        delete s.ownerCandidate;\n    }\n\n    //No need for claim step because DAO can also set admin\n    function transferAdminship(address newAdmin) external onlyAdminOrDAO {\n        s.admin = newAdmin;\n        emit Events.NewAdmin(newAdmin);\n    }\n\n    //When deactivating an asset make sure to zero out the oracle.\n    function setAssetOracle(address asset, address oracle) external onlyDAO {\n        _setAssetOracle(asset, oracle);\n        emit Events.UpdateAssetOracle(asset, oracle);\n    }\n\n    function createVault(\n        address zeth,\n        uint256 vault,\n        MTypes.CreateVaultParams calldata params\n    ) external onlyDAO {\n        if (s.zethVault[zeth] != 0) revert Errors.VaultAlreadyCreated();\n        s.zethVault[zeth] = vault;\n        _setTithe(vault, params.zethTithePercent);\n        _setDittoMatchedRate(vault, params.dittoMatchedRate);\n        _setDittoShorterRate(vault, params.dittoShorterRate);\n        emit Events.CreateVault(zeth, vault);\n    }\n\n    // Update eligibility requirements for yield accrual\n    function setTithe(uint256 vault, uint16 zethTithePercent) external onlyAdminOrDAO {\n        _setTithe(vault, zethTithePercent);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoMatchedRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoMatchedRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoShorterRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoShorterRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    // For Short Record collateral ratios\n    // initialMargin > primaryLiquidationCR > secondaryLiquidationCR > minimumCR\n    // After initial market creation. Set CRs from smallest to largest to prevent triggering the require checks\n\n    function setInitialMargin(address asset, uint16 value) external onlyAdminOrDAO {\n        require(value > s.asset[asset].primaryLiquidationCR, \"below primary liquidation\");\n        _setInitialMargin(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setPrimaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        require(\n            value > s.asset[asset].secondaryLiquidationCR, \"below secondary liquidation\"\n        );\n        _setPrimaryLiquidationCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondaryLiquidationCR(asset, value);\n        require(\n            LibAsset.secondaryLiquidationCR(asset) > LibAsset.minimumCR(asset),\n            \"below minimum CR\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setForcedBidPriceBuffer(address asset, uint8 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setForcedBidPriceBuffer(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinimumCR(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinimumCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function setResetLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setResetLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].secondLiquidationTime, \"below secondLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].firstLiquidationTime, \"below firstLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setFirstLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setFirstLiquidationTime(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setTappFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setTappFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setCallerFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setCallerFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinBidEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinBidEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinAskEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinAskEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinShortErc(address asset, uint16 value) external onlyAdminOrDAO {\n        _setMinShortErc(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function createBridge(\n        address bridge,\n        uint256 vault,\n        uint16 withdrawalFee,\n        uint8 unstakeFee\n    ) external onlyDAO {\n        s.vaultBridges[vault].push(bridge);\n        s.bridge[bridge].vault = uint8(vault);\n        _setWithdrawalFee(bridge, withdrawalFee);\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.CreateBridge(bridge, s.bridge[bridge]);\n    }\n\n    function deleteBridge(address bridge) external onlyDAO {\n        uint256 vault = s.bridge[bridge].vault;\n        if (vault == 0) revert Errors.InvalidBridge();\n\n        address[] storage VaultBridges = s.vaultBridges[vault];\n        uint256 length = VaultBridges.length;\n        for (uint256 i; i < length; i++) {\n            if (VaultBridges[i] == bridge) {\n                if (i != length - 1) {\n                    VaultBridges[i] = VaultBridges[length - 1];\n                }\n                VaultBridges.pop();\n                break;\n            }\n        }\n        delete s.bridge[bridge];\n        emit Events.DeleteBridge(bridge);\n    }\n\n    function setWithdrawalFee(address bridge, uint16 withdrawalFee)\n        external\n        onlyAdminOrDAO\n    {\n        _setWithdrawalFee(bridge, withdrawalFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function setUnstakeFee(address bridge, uint8 unstakeFee) external onlyAdminOrDAO {\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function _setAssetOracle(address asset, address oracle) private {\n        if (asset == address(0) || oracle == address(0)) revert Errors.ParameterIsZero();\n        s.asset[asset].oracle = oracle;\n    }\n\n    function _setTithe(uint256 vault, uint16 zethTithePercent) private {\n        if (zethTithePercent > 33_33) revert Errors.InvalidTithe();\n        s.vault[vault].zethTithePercent = zethTithePercent;\n    }\n\n    function _setDittoMatchedRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoMatchedRate = rewardRate;\n    }\n\n    function _setDittoShorterRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoShorterRate = rewardRate;\n    }\n\n    function _setInitialMargin(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        s.asset[asset].initialMargin = value;\n        require(LibAsset.initialMargin(asset) < Constants.CRATIO_MAX, \"above max CR\");\n    }\n\n    function _setPrimaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].initialMargin, \"above initial margin\");\n        s.asset[asset].primaryLiquidationCR = value;\n    }\n\n    function _setSecondaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].primaryLiquidationCR, \"above primary liquidation\");\n        s.asset[asset].secondaryLiquidationCR = value;\n    }\n\n    function _setForcedBidPriceBuffer(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].forcedBidPriceBuffer = value;\n    }\n\n    function _setMinimumCR(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].minimumCR = value;\n        require(\n            LibAsset.minimumCR(asset) < LibAsset.secondaryLiquidationCR(asset),\n            \"above secondary liquidation\"\n        );\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function _setResetLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(value <= 4800, \"above 48.00\");\n        s.asset[asset].resetLiquidationTime = value;\n    }\n\n    function _setSecondLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].resetLiquidationTime, \"above resetLiquidationTime\"\n        );\n        s.asset[asset].secondLiquidationTime = value;\n    }\n\n    function _setFirstLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].secondLiquidationTime, \"above secondLiquidationTime\"\n        );\n        s.asset[asset].firstLiquidationTime = value;\n    }\n\n    function _setTappFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].tappFeePct = value;\n    }\n\n    function _setCallerFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].callerFeePct = value;\n    }\n\n    function _setMinBidEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minBidEth = value;\n    }\n\n    function _setMinAskEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minAskEth = value;\n    }\n\n    function _setMinShortErc(address asset, uint16 value) private {\n        //no upperboard check because uint8 max - 65,535\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minShortErc = value;\n    }\n\n    function _setWithdrawalFee(address bridge, uint16 withdrawalFee) private {\n        require(withdrawalFee <= 1500, \"above 15.00%\");\n        s.bridge[bridge].withdrawalFee = withdrawalFee;\n    }\n\n    function _setUnstakeFee(address bridge, uint8 unstakeFee) private {\n        require(unstakeFee <= 250, \"above 2.50%\");\n        s.bridge[bridge].unstakeFee = unstakeFee;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOrders.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, Math104, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes, O, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOrders {\n    using LibOracle for address;\n    using U256 for uint256;\n    using Math104 for uint104;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    // @dev in seconds\n    function getOffsetTime() internal view returns (uint32 timeInSeconds) {\n        // shouldn't overflow in 136 years\n        return uint32(block.timestamp - Constants.STARTING_TIME); // @dev(safe-cast)\n    }\n\n    // @dev in hours\n    function getOffsetTimeHours() internal view returns (uint24 timeInHours) {\n        return uint24(getOffsetTime() / 1 hours);\n    }\n\n    function convertCR(uint16 cr) internal pure returns (uint256) {\n        return (uint256(cr) * 1 ether) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // For matched token reward\n    function increaseSharesOnMatch(\n        address asset,\n        STypes.Order memory order,\n        MTypes.Match memory matchTotal,\n        uint88 eth\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        // @dev use the diff to get more time (2159), to prevent overflow at year 2106\n        uint32 timeTillMatch = getOffsetTime() - order.creationTime;\n        if (timeTillMatch > Constants.MIN_DURATION) {\n            // shares in eth-days\n            uint88 shares = eth * (timeTillMatch / 1 days);\n            matchTotal.dittoMatchedShares += shares;\n\n            uint256 vault = s.asset[asset].vault;\n            s.vaultUser[vault][order.addr].dittoMatchedShares += shares;\n        }\n    }\n\n    function currentOrders(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset\n    ) internal view returns (STypes.Order[] memory) {\n        uint16 currentId = orders[asset][Constants.HEAD].nextId;\n        uint256 size;\n\n        while (currentId != Constants.TAIL) {\n            size++;\n            currentId = orders[asset][currentId].nextId;\n        }\n\n        STypes.Order[] memory list = new STypes.Order[](size);\n        currentId = orders[asset][Constants.HEAD].nextId; // reset currentId\n\n        for (uint256 i = 0; i < size; i++) {\n            list[i] = orders[asset][currentId];\n            currentId = orders[asset][currentId].nextId;\n        }\n        return list;\n    }\n\n    function isShort(STypes.Order memory order) internal pure returns (bool) {\n        return order.orderType == O.Li"
    }
  ]
}