{
  "Title": "[M-10] Lack of way to handle not fully repaid bad debt after liquidation after the lending pool share or WLP are fully seized",
  "Content": "\nWhen user has bad debt, user's borrow credit > collateral credit. Liqudiator can step in and liquidate and seize user's share or seize user WLP and repay the debt.\n\nWhile the liquidate function aims to let liqudiator take the min share available for bad debt repayment.\n\n```solidity\n// take min of what's available (for bad debt repayment)\nshares = shares.min(IPosManager(POS_MANAGER).getCollAmt(_posId, _poolOut)); // take min of what's available\n_require(shares >= _minShares, Errors.SLIPPAGE_CONTROL);\n```\n\nAfter the user's pool share is transferred out, or after user's WLP is seized, the rest of unpaid debt becomes bad debt permanently. For example, user's borrow 1000 USDT and has debt 1000 USDT. His share is only worth 500 USD as collateral price drops. Because the code lets liquidator take min of what's available for both lending pool share and take min of what's available (for bad debt repayment) for WLP amount. The liqudiator can repay 800 USD and seize share of 500 USD. However, there are 200 USD remaining debt. When other liquidators (even this liquidator belongs to protocol) writes to repay and erase the rest 200 USD bad debt, he cannot because [removeCollateralTo validates share > 0, if share is 0, revert](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/core/PosManager.sol#L235).\n\n```solidity\n_require(_shares > 0, Errors.ZERO_VALUE);\n```\n\nIf the underlying collateral is WLP, the second liquidation aims to write off bad debt does not work as well because if all WLP is transfered out, calling [\\_harvest and unwrap again is likely to revert](https://github.com/code-423n4/2023-12-initcapital/blob/a53e401529451b208095b3af11862984d0b32177/contracts/core/PosManager.sol#L265).\n\n```solidity\n_harvest(_posId, _wLp, _tokenId);\nIBaseWrapLp(_wLp).unwrap(_tokenId, _amt, _receiver);\n```\n\nThe bad permanently inflates the totalAssets() in lending pool and inflates the total debt to not let other users borrow from protocol because of the borrow cap checks.\n\nAlso, the lender suffers the loss because if the bad debt is not repaid, the lender that deposit cash into the lending pool is lost.\n\n### Recommended Mitigation Steps\n\nAdd a way to handle not fully repaid bad debt after liquidation after the lending pool share or WLP is fully seized.\n\nAdd a function to donate to the lending pool to let user supply asset or add a function to socialize the bad debt as loss explicilty.\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/9#issuecomment-1869836241)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-initcapital",
  "Code": [
    {
      "filename": "contracts/core/PosManager.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC721EnumerableUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\nimport {ERC721HolderUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\ncontract PosManager is IPosManager, UnderACM, ERC721EnumerableUpgradeable, ERC721HolderUpgradeable {\n    using SafeCast for uint;\n    using SafeCast for int;\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    // constants\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n\n    // storages\n    mapping(address => uint) public nextNonces; // @inheritdoc IPosManager\n    mapping(uint => PosInfo) private __posInfos;\n    mapping(uint => PosCollInfo) private __posCollInfos;\n    mapping(uint => PosBorrInfo) private __posBorrInfos;\n    mapping(address => uint) private __collBalances;\n    address public core;\n    uint8 public maxCollCount; // limit number of collateral to avoid out of gas\n    mapping(uint => mapping(address => uint)) public pendingRewards; // @inheritdoc IPosManager\n    mapping(address => mapping(uint => bool)) public isCollateralized; // @inheritdoc IPosManager\n    mapping(address => EnumerableSet.UintSet) private __viewerPosIds;\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyCore() {\n        _require(msg.sender == core, Errors.NOT_INIT_CORE);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(_isApprovedOrOwner(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    // constructor\n    constructor(address _acm) UnderACM(_acm) {\n        _disableInitializers();\n    }\n\n    // initializer\n    /// @dev initialize the contract, set the ERC721's name and symbol, and set the init core address\n    /// @param _name ERC721's name\n    /// @param _symbol ERC721's symbol\n    /// @param _core core address\n    function initialize(string calldata _name, string calldata _symbol, address _core, uint8 _maxCollCount)\n        external\n        initializer\n    {\n        __ERC721_init(_name, _symbol);\n        core = _core;\n        maxCollCount = _maxCollCount;\n        emit SetMaxCollCount(_maxCollCount);\n    }\n\n    // functions\n    /// @inheritdoc IPosManager\n    function getPosBorrInfo(uint _posId) external view returns (address[] memory pools, uint[] memory debtShares) {\n        PosBorrInfo storage posBorrInfo = __posBorrInfos[_posId];\n        pools = posBorrInfo.pools.values();\n        debtShares = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            debtShares[i] = posBorrInfo.debtShares[pools[i]];\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosBorrExtraInfo(uint _posId, address _pool)\n        external\n        view\n        returns (uint totalInterest, uint lastDebtAmt)\n    {\n        PosBorrExtraInfo memory borrExtraInfo = __posBorrInfos[_posId].borrExtraInfos[_pool];\n        totalInterest = borrExtraInfo.totalInterest;\n        lastDebtAmt = borrExtraInfo.lastDebtAmt;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosCollInfo(uint _posId)\n        external\n        view\n        returns (\n            address[] memory pools,\n            uint[] memory amts,\n            address[] memory wLps,\n            uint[][] memory ids,\n            uint[][] memory wLpAmts\n        )\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        pools = posCollInfo.collTokens.values();\n        amts = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            amts[i] = posCollInfo.collAmts[pools[i]];\n        }\n        wLps = posCollInfo.wLps.values();\n        ids = new uint[][](wLps.length);\n        wLpAmts = new uint[][](wLps.length);\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            ids[i] = posCollInfo.ids[wLps[i]].values();\n            wLpAmts[i] = new uint[](ids[i].length);\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                wLpAmts[i][j] = IBaseWrapLp(wLps[i]).balanceOfLp(ids[i][j]);\n            }\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getCollAmt(uint _posId, address _pool) external view returns (uint amt) {\n        amt = __posCollInfos[_posId].collAmts[_pool];\n    }\n\n    /// @inheritdoc IPosManager\n    function getCollWLpAmt(uint _posId, address _wLp, uint _tokenId) external view returns (uint amt) {\n        if (__posCollInfos[_posId].ids[_wLp].contains(_tokenId)) {\n            amt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId);\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosInfo(uint _posId) external view returns (address viewer, uint16 mode) {\n        PosInfo memory info = __posInfos[_posId];\n        viewer = info.viewer;\n        mode = info.mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosMode(uint _posId) external view returns (uint16 mode) {\n        mode = __posInfos[_posId].mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosDebtShares(uint _posId, address _pool) external view returns (uint debtShares) {\n        debtShares = __posBorrInfos[_posId].debtShares[_pool];\n    }\n\n    /// @inheritdoc IPosManager\n    function getViewerPosIdsAt(address _viewer, uint _index) external view returns (uint posId) {\n        posId = __viewerPosIds[_viewer].at(_index);\n    }\n\n    /// @inheritdoc IPosManager\n    function getViewerPosIdsLength(address _viewer) external view returns (uint length) {\n        length = __viewerPosIds[_viewer].length();\n    }\n\n    /// @inheritdoc IPosManager\n    function updatePosDebtShares(uint _posId, address _pool, int _deltaShares) external onlyCore {\n        uint currDebtShares = __posBorrInfos[_posId].debtShares[_pool];\n        uint debtAmtCurrent = ILendingPool(_pool).debtShareToAmtCurrent(currDebtShares);\n        PosBorrExtraInfo storage extraInfo = __posBorrInfos[_posId].borrExtraInfos[_pool];\n        // update interest accrued since last update\n        // NOTE: debtAmtCurrent is always >= lastDebtAmt\n        extraInfo.totalInterest += (debtAmtCurrent - extraInfo.lastDebtAmt).toUint128();\n        uint newDebtShares = (currDebtShares.toInt256() + _deltaShares).toUint256();\n        // handle first borrower\n        uint newDebtAmt = ILendingPool(_pool).totalDebtShares() > 0\n            ? ILendingPool(_pool).debtShareToAmtStored(newDebtShares)\n            : newDebtShares;\n        __posBorrInfos[_posId].debtShares[_pool] = newDebtShares;\n        // snapshot the current debt amount for next interest calculation\n        extraInfo.lastDebtAmt = newDebtAmt.toUint128();\n        if (newDebtShares > 0) __posBorrInfos[_posId].pools.add(_pool);\n        else __posBorrInfos[_posId].pools.remove(_pool);\n    }\n\n    /// @inheritdoc IPosManager\n    function updatePosMode(uint _posId, uint16 _mode) external onlyCore {\n        __posInfos[_posId].mode = _mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function addCollateral(uint _posId, address _pool) external onlyCore returns (uint amtIn) {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        uint newBalance = IERC20(_pool).balanceOf(address(this));\n        amtIn = newBalance - __collBalances[_pool];\n        _require(amtIn != 0, Errors.ZERO_VALUE);\n        uint posBalance = posCollInfo.collAmts[_pool];\n        if (posBalance == 0) {\n            posCollInfo.collTokens.add(_pool);\n            uint8 collCount = posCollInfo.collCount + 1;\n            // NOTE: to avoid out of gas\n            _require(collCount <= maxCollCount, Errors.MAX_COLLATERAL_COUNT_REACHED);\n            posCollInfo.collCount = collCount;\n        }\n        posCollInfo.collAmts[_pool] = posBalance + amtIn;\n        __collBalances[_pool] = newBalance;\n    }\n\n    /// @inheritdoc IPosManager\n    function addCollateralWLp(uint _posId, address _wLp, uint _tokenId) external onlyCore returns (uint amtIn) {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        _require(IBaseWrapLp(_wLp).ownerOf(_tokenId) == address(this), Errors.NOT_OWNER);\n        _require(!isCollateralized[_wLp][_tokenId], Errors.ALREADY_COLLATERALIZED);\n        _require(IBaseWrapLp(_wLp).balanceOfLp(_tokenId) != 0, Errors.ZERO_VALUE);\n        posCollInfo.wLps.add(_wLp);\n        // NOTE: will return true if add new id\n        if (posCollInfo.ids[_wLp].add(_tokenId)) {\n            uint8 collCount = posCollInfo.collCount + 1;\n            _require(collCount <= maxCollCount, Errors.MAX_COLLATERAL_COUNT_REACHED);\n            posCollInfo.collCount = collCount;\n        }\n        isCollateralized[_wLp][_tokenId] = true;\n        amtIn = IBaseWrapLp(_wLp).balanceOfLp(_tokenId);\n    }\n\n    /// @inheritdoc IPosManager\n    function removeCollateralTo(uint _posId, address _pool, uint _shares, address _receiver)\n        external\n        onlyCore\n        returns (uint)\n    {\n        _require(_shares > 0, Errors.ZERO_VALUE);\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        uint newPosCollAmt = posCollInfo.collAmts[_pool] - _shares;\n        if (newPosCollAmt == 0) {\n            posCollInfo.collTokens.remove(_pool);\n            posCollInfo.collCount -= 1;\n        }\n        posCollInfo.collAmts[_pool] = newPosCollAmt;\n        IERC20(_pool).safeTransfer(_receiver, _shares);\n        __collBalances[_pool] = IERC20(_pool).balanceOf(address(this));\n        return _shares;\n    }\n\n    /// @inheritdoc IPosManager\n    function removeCollateralWLpTo(uint _posId, address _wLp, uint _tokenId, uint _amt, address _receiver)\n        external\n        onlyCore\n        returns (uint)\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        // NOTE: balanceOfLp should be 1:1 with amt\n        uint newWLpAmt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId) - _amt;\n        if (newWLpAmt == 0) {\n            _require(posCollInfo.ids[_wLp].remove(_tokenId), Errors.NOT_CONTAIN);\n            posCollInfo.collCount -= 1;\n            if (posCollInfo.ids[_wLp].length() == 0) {\n                posCollInfo.wLps.remove(_wLp);\n            }\n            isCollateralized[_wLp][_tokenId] = false;\n        }\n        _harvest(_posId, _wLp, _tokenId);\n        IBaseWrapLp(_wLp).unwrap(_tokenId, _amt, _receiver);\n        return _amt;\n    }\n\n    /// @inheritdoc IPosManager\n    function createPos(address _owner, uint16 _mode, address _viewer) external onlyCore returns (uint posId) {\n        uint nonce = nextNonces[_owner]++;\n        posId = uint(keccak256(abi.encodePacked(_owner, nonce)));\n        _updateViewerPosIds(posId, _viewer);\n        __posInfos[posId].viewer = _viewer;\n        __posInfos[posId].mode = _mode;\n        _safeMint(_owner, posId);\n    }\n\n    /// @inheritdoc IPosManager\n    function harvestTo(uint _posId, address _wlp, uint _tokenId, address _to)\n        public\n        onlyAuthorized(_posId)\n        returns (address[] memory tokens, uint[] memory amts)\n    {\n        // check that pos hold wlp\n        _require(__posCollInfos[_posId].ids[_wlp].contains(_tokenId), Errors.NOT_CONTAIN);\n        (tokens, amts) = IBaseWrapLp(_wlp).harvest(_tokenId, _to);\n    }\n\n    /// @inheritdoc IPosManager\n    function claimPendingRewards(uint _posId, address[] calldata _tokens, address _to)\n        external\n        onlyAuthorized(_posId)\n        returns (uint[] memory amts)\n    {\n        amts = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; i = i.uinc()) {\n            amts[i] = pendingRewards[_posId][_tokens[i]];\n            if (amts[i] != 0) {\n                pendingRewards[_posId][_tokens[i]] = 0;\n                IERC20(_tokens[i]).safeTransfer(_to, amts[i]);\n            }\n        }\n    }\n\n    /// @dev harvest reward tokens and update the pending rewards for the position\n    function _harvest(uint _posId, address _wlp, uint _tokenId) internal {\n        (address[] memory tokens, uint[] memory amts) = IBaseWrapLp(_wlp).harvest(_tokenId, address(this));\n        for (uint i; i < tokens.length; i = i.uinc()) {\n            pendingRewards[_posId][tokens[i]] += amts[i];\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function isAuthorized(address _account, uint _posId) external view returns (bool) {\n        return _isApprovedOrOwner(_account, _posId);\n    }\n\n    /// @inheritdoc IPosManager\n    function setMaxCollCount(uint8 _maxCollCount) external onlyGuardian {\n        maxCollCount = _maxCollCount;\n        emit SetMaxCollCount(_maxCollCount);\n    }\n\n    /// @inheritdoc IPosManager\n    function setPosViewer(uint _posId, address _viewer) external onlyAuthorized(_posId) {\n        _require(__posInfos[_posId].viewer != _viewer, Errors.ALREADY_SET);\n        _updateViewerPosIds(_posId, _viewer);\n        __posInfos[_posId].viewer = _viewer;\n    }\n\n    /// @dev update position viewer to ids mapping\n    function _updateViewerPosIds(uint _posId, address _viewer) internal {\n        address oldViewer = __posInfos[_posId].viewer;\n        // remove pos id from old viewer\n        if (oldViewer != address(0)) __viewerPosIds[oldViewer].remove(_posId);\n        // add pos id to new viewer\n        __viewerPosIds[_viewer].add(_posId);\n    }\n}"
    },
    {
      "filename": "contracts/core/PosManager.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IBaseWrapLp} from '../interfaces/wrapper/IBaseWrapLp.sol';\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {SafeCast} from '@openzeppelin-contracts/utils/math/SafeCast.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC721EnumerableUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\nimport {ERC721HolderUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\nimport {EnumerableSet} from '@openzeppelin-contracts/utils/structs/EnumerableSet.sol';\nimport {UnderACM} from '../common/UnderACM.sol';\n\ncontract PosManager is IPosManager, UnderACM, ERC721EnumerableUpgradeable, ERC721HolderUpgradeable {\n    using SafeCast for uint;\n    using SafeCast for int;\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    // constants\n    bytes32 private constant GUARDIAN = keccak256('guardian');\n\n    // storages\n    mapping(address => uint) public nextNonces; // @inheritdoc IPosManager\n    mapping(uint => PosInfo) private __posInfos;\n    mapping(uint => PosCollInfo) private __posCollInfos;\n    mapping(uint => PosBorrInfo) private __posBorrInfos;\n    mapping(address => uint) private __collBalances;\n    address public core;\n    uint8 public maxCollCount; // limit number of collateral to avoid out of gas\n    mapping(uint => mapping(address => uint)) public pendingRewards; // @inheritdoc IPosManager\n    mapping(address => mapping(uint => bool)) public isCollateralized; // @inheritdoc IPosManager\n    mapping(address => EnumerableSet.UintSet) private __viewerPosIds;\n\n    // modifiers\n    modifier onlyGuardian() {\n        ACM.checkRole(GUARDIAN, msg.sender);\n        _;\n    }\n\n    modifier onlyCore() {\n        _require(msg.sender == core, Errors.NOT_INIT_CORE);\n        _;\n    }\n\n    modifier onlyAuthorized(uint _posId) {\n        _require(_isApprovedOrOwner(msg.sender, _posId), Errors.NOT_AUTHORIZED);\n        _;\n    }\n\n    // constructor\n    constructor(address _acm) UnderACM(_acm) {\n        _disableInitializers();\n    }\n\n    // initializer\n    /// @dev initialize the contract, set the ERC721's name and symbol, and set the init core address\n    /// @param _name ERC721's name\n    /// @param _symbol ERC721's symbol\n    /// @param _core core address\n    function initialize(string calldata _name, string calldata _symbol, address _core, uint8 _maxCollCount)\n        external\n        initializer\n    {\n        __ERC721_init(_name, _symbol);\n        core = _core;\n        maxCollCount = _maxCollCount;\n        emit SetMaxCollCount(_maxCollCount);\n    }\n\n    // functions\n    /// @inheritdoc IPosManager\n    function getPosBorrInfo(uint _posId) external view returns (address[] memory pools, uint[] memory debtShares) {\n        PosBorrInfo storage posBorrInfo = __posBorrInfos[_posId];\n        pools = posBorrInfo.pools.values();\n        debtShares = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            debtShares[i] = posBorrInfo.debtShares[pools[i]];\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosBorrExtraInfo(uint _posId, address _pool)\n        external\n        view\n        returns (uint totalInterest, uint lastDebtAmt)\n    {\n        PosBorrExtraInfo memory borrExtraInfo = __posBorrInfos[_posId].borrExtraInfos[_pool];\n        totalInterest = borrExtraInfo.totalInterest;\n        lastDebtAmt = borrExtraInfo.lastDebtAmt;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosCollInfo(uint _posId)\n        external\n        view\n        returns (\n            address[] memory pools,\n            uint[] memory amts,\n            address[] memory wLps,\n            uint[][] memory ids,\n            uint[][] memory wLpAmts\n        )\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        pools = posCollInfo.collTokens.values();\n        amts = new uint[](pools.length);\n        for (uint i; i < pools.length; i = i.uinc()) {\n            amts[i] = posCollInfo.collAmts[pools[i]];\n        }\n        wLps = posCollInfo.wLps.values();\n        ids = new uint[][](wLps.length);\n        wLpAmts = new uint[][](wLps.length);\n        for (uint i; i < wLps.length; i = i.uinc()) {\n            ids[i] = posCollInfo.ids[wLps[i]].values();\n            wLpAmts[i] = new uint[](ids[i].length);\n            for (uint j; j < ids[i].length; j = j.uinc()) {\n                wLpAmts[i][j] = IBaseWrapLp(wLps[i]).balanceOfLp(ids[i][j]);\n            }\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getCollAmt(uint _posId, address _pool) external view returns (uint amt) {\n        amt = __posCollInfos[_posId].collAmts[_pool];\n    }\n\n    /// @inheritdoc IPosManager\n    function getCollWLpAmt(uint _posId, address _wLp, uint _tokenId) external view returns (uint amt) {\n        if (__posCollInfos[_posId].ids[_wLp].contains(_tokenId)) {\n            amt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId);\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosInfo(uint _posId) external view returns (address viewer, uint16 mode) {\n        PosInfo memory info = __posInfos[_posId];\n        viewer = info.viewer;\n        mode = info.mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosMode(uint _posId) external view returns (uint16 mode) {\n        mode = __posInfos[_posId].mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function getPosDebtShares(uint _posId, address _pool) external view returns (uint debtShares) {\n        debtShares = __posBorrInfos[_posId].debtShares[_pool];\n    }\n\n    /// @inheritdoc IPosManager\n    function getViewerPosIdsAt(address _viewer, uint _index) external view returns (uint posId) {\n        posId = __viewerPosIds[_viewer].at(_index);\n    }\n\n    /// @inheritdoc IPosManager\n    function getViewerPosIdsLength(address _viewer) external view returns (uint length) {\n        length = __viewerPosIds[_viewer].length();\n    }\n\n    /// @inheritdoc IPosManager\n    function updatePosDebtShares(uint _posId, address _pool, int _deltaShares) external onlyCore {\n        uint currDebtShares = __posBorrInfos[_posId].debtShares[_pool];\n        uint debtAmtCurrent = ILendingPool(_pool).debtShareToAmtCurrent(currDebtShares);\n        PosBorrExtraInfo storage extraInfo = __posBorrInfos[_posId].borrExtraInfos[_pool];\n        // update interest accrued since last update\n        // NOTE: debtAmtCurrent is always >= lastDebtAmt\n        extraInfo.totalInterest += (debtAmtCurrent - extraInfo.lastDebtAmt).toUint128();\n        uint newDebtShares = (currDebtShares.toInt256() + _deltaShares).toUint256();\n        // handle first borrower\n        uint newDebtAmt = ILendingPool(_pool).totalDebtShares() > 0\n            ? ILendingPool(_pool).debtShareToAmtStored(newDebtShares)\n            : newDebtShares;\n        __posBorrInfos[_posId].debtShares[_pool] = newDebtShares;\n        // snapshot the current debt amount for next interest calculation\n        extraInfo.lastDebtAmt = newDebtAmt.toUint128();\n        if (newDebtShares > 0) __posBorrInfos[_posId].pools.add(_pool);\n        else __posBorrInfos[_posId].pools.remove(_pool);\n    }\n\n    /// @inheritdoc IPosManager\n    function updatePosMode(uint _posId, uint16 _mode) external onlyCore {\n        __posInfos[_posId].mode = _mode;\n    }\n\n    /// @inheritdoc IPosManager\n    function addCollateral(uint _posId, address _pool) external onlyCore returns (uint amtIn) {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        uint newBalance = IERC20(_pool).balanceOf(address(this));\n        amtIn = newBalance - __collBalances[_pool];\n        _require(amtIn != 0, Errors.ZERO_VALUE);\n        uint posBalance = posCollInfo.collAmts[_pool];\n        if (posBalance == 0) {\n            posCollInfo.collTokens.add(_pool);\n            uint8 collCount = posCollInfo.collCount + 1;\n            // NOTE: to avoid out of gas\n            _require(collCount <= maxCollCount, Errors.MAX_COLLATERAL_COUNT_REACHED);\n            posCollInfo.collCount = collCount;\n        }\n        posCollInfo.collAmts[_pool] = posBalance + amtIn;\n        __collBalances[_pool] = newBalance;\n    }\n\n    /// @inheritdoc IPosManager\n    function addCollateralWLp(uint _posId, address _wLp, uint _tokenId) external onlyCore returns (uint amtIn) {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        _require(IBaseWrapLp(_wLp).ownerOf(_tokenId) == address(this), Errors.NOT_OWNER);\n        _require(!isCollateralized[_wLp][_tokenId], Errors.ALREADY_COLLATERALIZED);\n        _require(IBaseWrapLp(_wLp).balanceOfLp(_tokenId) != 0, Errors.ZERO_VALUE);\n        posCollInfo.wLps.add(_wLp);\n        // NOTE: will return true if add new id\n        if (posCollInfo.ids[_wLp].add(_tokenId)) {\n            uint8 collCount = posCollInfo.collCount + 1;\n            _require(collCount <= maxCollCount, Errors.MAX_COLLATERAL_COUNT_REACHED);\n            posCollInfo.collCount = collCount;\n        }\n        isCollateralized[_wLp][_tokenId] = true;\n        amtIn = IBaseWrapLp(_wLp).balanceOfLp(_tokenId);\n    }\n\n    /// @inheritdoc IPosManager\n    function removeCollateralTo(uint _posId, address _pool, uint _shares, address _receiver)\n        external\n        onlyCore\n        returns (uint)\n    {\n        _require(_shares > 0, Errors.ZERO_VALUE);\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        uint newPosCollAmt = posCollInfo.collAmts[_pool] - _shares;\n        if (newPosCollAmt == 0) {\n            posCollInfo.collTokens.remove(_pool);\n            posCollInfo.collCount -= 1;\n        }\n        posCollInfo.collAmts[_pool] = newPosCollAmt;\n        IERC20(_pool).safeTransfer(_receiver, _shares);\n        __collBalances[_pool] = IERC20(_pool).balanceOf(address(this));\n        return _shares;\n    }\n\n    /// @inheritdoc IPosManager\n    function removeCollateralWLpTo(uint _posId, address _wLp, uint _tokenId, uint _amt, address _receiver)\n        external\n        onlyCore\n        returns (uint)\n    {\n        PosCollInfo storage posCollInfo = __posCollInfos[_posId];\n        // NOTE: balanceOfLp should be 1:1 with amt\n        uint newWLpAmt = IBaseWrapLp(_wLp).balanceOfLp(_tokenId) - _amt;\n        if (newWLpAmt == 0) {\n            _require(posCollInfo.ids[_wLp].remove(_tokenId), Errors.NOT_CONTAIN);\n            posCollInfo.collCount -= 1;\n            if (posCollInfo.ids[_wLp].length() == 0) {\n                posCollInfo.wLps.remove(_wLp);\n            }\n            isCollateralized[_wLp][_tokenId] = false;\n        }\n        _harvest(_posId, _wLp, _tokenId);\n        IBaseWrapLp(_wLp).unwrap(_tokenId, _amt, _receiver);\n        return _amt;\n    }\n\n    /// @inheritdoc IPosManager\n    function createPos(address _owner, uint16 _mode, address _viewer) external onlyCore returns (uint posId) {\n        uint nonce = nextNonces[_owner]++;\n        posId = uint(keccak256(abi.encodePacked(_owner, nonce)));\n        _updateViewerPosIds(posId, _viewer);\n        __posInfos[posId].viewer = _viewer;\n        __posInfos[posId].mode = _mode;\n        _safeMint(_owner, posId);\n    }\n\n    /// @inheritdoc IPosManager\n    function harvestTo(uint _posId, address _wlp, uint _tokenId, address _to)\n        public\n        onlyAuthorized(_posId)\n        returns (address[] memory tokens, uint[] memory amts)\n    {\n        // check that pos hold wlp\n        _require(__posCollInfos[_posId].ids[_wlp].contains(_tokenId), Errors.NOT_CONTAIN);\n        (tokens, amts) = IBaseWrapLp(_wlp).harvest(_tokenId, _to);\n    }\n\n    /// @inheritdoc IPosManager\n    function claimPendingRewards(uint _posId, address[] calldata _tokens, address _to)\n        external\n        onlyAuthorized(_posId)\n        returns (uint[] memory amts)\n    {\n        amts = new uint[](_tokens.length);\n        for (uint i; i < _tokens.length; i = i.uinc()) {\n            amts[i] = pendingRewards[_posId][_tokens[i]];\n            if (amts[i] != 0) {\n                pendingRewards[_posId][_tokens[i]] = 0;\n                IERC20(_tokens[i]).safeTransfer(_to, amts[i]);\n            }\n        }\n    }\n\n    /// @dev harvest reward tokens and update the pending rewards for the position\n    function _harvest(uint _posId, address _wlp, uint _tokenId) internal {\n        (address[] memory tokens, uint[] memory amts) = IBaseWrapLp(_wlp).harvest(_tokenId, address(this));\n        for (uint i; i < tokens.length; i = i.uinc()) {\n            pendingRewards[_posId][tokens[i]] += amts[i];\n        }\n    }\n\n    /// @inheritdoc IPosManager\n    function isAuthorized(address _account, uint _posId) external view returns (bool) {\n        return _isApprovedOrOwner(_account, _posId);\n    }\n\n    /// @inheritdoc IPosManager\n    function setMaxCollCount(uint8 _maxCollCount) external onlyGuardian {\n        maxCollCount = _maxCollCount;\n        emit SetMaxCollCount(_maxCollCount);\n    }\n\n    /// @inheritdoc IPosManager\n    function setPosViewer(uint _posId, address _viewer) external onlyAuthorized(_posId) {\n        _require(__posInfos[_posId].viewer != _viewer, Errors.ALREADY_SET);\n        _updateViewerPosIds(_posId, _viewer);\n        __posInfos[_posId].viewer = _viewer;\n    }\n\n    /// @dev update position viewer to ids mapping\n    function _updateViewerPosIds(uint _posId, address _viewer) internal {\n        address oldViewer = __posInfos[_posId].viewer;\n        // remove pos id from old viewer\n        if (oldViewer != address(0)) __viewerPosIds[oldViewer].remove(_posId);\n        // add pos id to new viewer\n        __viewerPosIds[_viewer].add(_posId);\n    }\n}"
    }
  ]
}