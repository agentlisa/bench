{
  "Title": "[M-03] Stader OPERATOR is a single point of failure",
  "Content": "\n<https://github.com/code-423n4/2023-06-stader/blob/main/contracts/PermissionlessNodeRegistry.sol#L183> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/PermissionedNodeRegistry.sol#L254>\n\nThe OPERATOR role holds a lot of power within the system, which can compromise both the system integrity and it's permission-less nature.\n\n### Proof of Concept\n\nThe OPERATOR key is responsible for confirming the marking of each validator submitted key as either valid or invalid, without any assurance to validators.\n\n1.  Arbitrary negation of participation makes permissionless pool permissioned.\n\nThe documentation states:\n\n> Any validator in permissionless pool can run a node with 4 ETH + 0.4 ETH worth of SD token.\n\nWhich is not strictly true, since any participant in the system must be vetted by the OPERATOR, which can arbitrarily mark as invalid or frontrun the key without the need to provide justification or having an appeal system. Alternatively, the OPERATOR can simply ignore the added key and never mark it as `ready to deposit`.\n\nTherefore, the pool can't be considered permissionless, since participants must rely on the benevolence of the OPERATOR to participate.\n\n2.  Authorization of invalid keys\n\nThere is no way for the smart contract system to check or confirm that a given public key is really legit. This could generate income to ETHx holders, so the system relies solely on the OPERATOR to make that distinction, rendering the system vulnerable in case of a comprised wallet.\n\n### Recommended Mitigation Steps\n\nThere is no simple fix for the issue, but at minimum, the protocol shouldn't be advertised as permissionless.\n\n### Assessed type\n\nRug-Pull\n\n**[Picodes (judge) decreased severity to Medium](https://github.com/code-423n4/2022-06-stader-findings/issues/344#issuecomment-1591845515)**\n\n**[manoj9april (Stader) confirmed and commented](https://github.com/code-423n4/2022-06-stader-findings/issues/344#issuecomment-1598329047):**\n > Thank you for pointing it out.\n> We will move this logic to oracle.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-06-stader-findings/issues/344#issuecomment-1616567202):**\n > Keeping Medium severity considering this could be an instance of \"function of the protocol or its availability could be impacted\".\n\n**[sanjay-staderlabs (Stader) commented](https://github.com/code-423n4/2023-06-stader-findings/issues/344#issuecomment-1633520716):**\n>This is fixed.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/PermissionlessNodeRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport './library/ValidatorStatus.sol';\nimport './interfaces/IStaderConfig.sol';\nimport './interfaces/IVaultFactory.sol';\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/INodeRegistry.sol';\nimport './interfaces/IPermissionlessPool.sol';\nimport './interfaces/INodeELRewardVault.sol';\nimport './interfaces/IStaderInsuranceFund.sol';\nimport './interfaces/IValidatorWithdrawalVault.sol';\nimport './interfaces/SDCollateral/ISDCollateral.sol';\nimport './interfaces/IPermissionlessNodeRegistry.sol';\nimport './interfaces/IOperatorRewardsCollector.sol';\n\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\n\ncontract PermissionlessNodeRegistry is\n    INodeRegistry,\n    IPermissionlessNodeRegistry,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    uint8 public constant override POOL_ID = 1;\n    uint16 public override inputKeyCountLimit;\n    uint64 public override maxNonTerminalKeyPerOperator;\n\n    IStaderConfig public staderConfig;\n\n    uint256 public override verifiedKeyBatchSize;\n    uint256 public override nextOperatorId;\n    uint256 public override nextValidatorId;\n    uint256 public override validatorQueueSize;\n    uint256 public override nextQueuedValidatorIndex;\n    uint256 public override totalActiveValidatorCount;\n    uint256 public constant override FRONT_RUN_PENALTY = 3 ether;\n    uint256 public constant COLLATERAL_ETH = 4 ether;\n\n    // mapping of validator Id and Validator struct\n    mapping(uint256 => Validator) public override validatorRegistry;\n    // mapping of validator public key and validator Id\n    mapping(bytes => uint256) public override validatorIdByPubkey;\n    // Queued Validator queue\n    mapping(uint256 => uint256) public override queuedValidators;\n    // mapping of operator Id and Operator struct\n    mapping(uint256 => Operator) public override operatorStructById;\n    // mapping of operator address and operator Id\n    mapping(address => uint256) public override operatorIDByAddress;\n    //mapping of operator wise validator Ids arrays\n    mapping(uint256 => uint256[]) public override validatorIdsByOperatorId;\n    mapping(uint256 => uint256) public socializingPoolStateChangeBlock;\n    //mapping of operator address with nodeELReward vault address\n    mapping(uint256 => address) public override nodeELRewardVaultByOperatorId;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) public initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        __AccessControl_init_unchained();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        staderConfig = IStaderConfig(_staderConfig);\n        nextOperatorId = 1;\n        nextValidatorId = 1;\n        inputKeyCountLimit = 30;\n        maxNonTerminalKeyPerOperator = 50;\n        verifiedKeyBatchSize = 50;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n\n    /**\n     * @notice onboard a node operator\n     * @dev any one call, permissionless\n     * @param _optInForSocializingPool opted in or not to socialize mev and priority fee\n     * @param _operatorName name of operator\n     * @param _operatorRewardAddress eth1 address of operator to get rewards and withdrawals\n     * @return feeRecipientAddress fee recipient address for all validator clients of a operator\n     */\n    function onboardNodeOperator(\n        bool _optInForSocializingPool,\n        string calldata _operatorName,\n        address payable _operatorRewardAddress\n    ) external override whenNotPaused returns (address feeRecipientAddress) {\n        address poolUtils = staderConfig.getPoolUtils();\n        if (IPoolUtils(poolUtils).poolAddressById(POOL_ID) != staderConfig.getPermissionlessPool()) {\n            revert DuplicatePoolIDOrPoolNotAdded();\n        }\n        IPoolUtils(poolUtils).onlyValidName(_operatorName);\n        UtilLib.checkNonZeroAddress(_operatorRewardAddress);\n\n        //checks if operator already onboarded in any pool of stader protocol\n        if (IPoolUtils(poolUtils).isExistingOperator(msg.sender)) {\n            revert OperatorAlreadyOnBoardedInProtocol();\n        }\n        //deploy NodeELRewardVault for NO\n        address nodeELRewardVault = IVaultFactory(staderConfig.getVaultFactory()).deployNodeELRewardVault(\n            POOL_ID,\n            nextOperatorId\n        );\n        nodeELRewardVaultByOperatorId[nextOperatorId] = nodeELRewardVault;\n        feeRecipientAddress = _optInForSocializingPool\n            ? staderConfig.getPermissionlessSocializingPool()\n            : nodeELRewardVault;\n        onboardOperator(_optInForSocializingPool, _operatorName, _operatorRewardAddress);\n        return feeRecipientAddress;\n    }\n\n    /**\n     * @notice add validator keys\n     * @dev only accepts if bond of 4 ETH per key is provided along with sufficient SD lockup\n     * @param _pubkey pubkey of validators\n     * @param _preDepositSignature signature of a validators for 1ETH deposit\n     * @param _depositSignature signature of a validator for 31ETH deposit\n     */\n    function addValidatorKeys(\n        bytes[] calldata _pubkey,\n        bytes[] calldata _preDepositSignature,\n        bytes[] calldata _depositSignature\n    ) external payable override nonReentrant whenNotPaused {\n        uint256 operatorId = onlyActiveOperator(msg.sender);\n        (uint256 keyCount, uint256 operatorTotalKeys) = checkInputKeysCountAndCollateral(\n            _pubkey.length,\n            _preDepositSignature.length,\n            _depositSignature.length,\n            operatorId\n        );\n\n        address vaultFactory = staderConfig.getVaultFactory();\n        address poolUtils = staderConfig.getPoolUtils();\n        for (uint256 i; i < keyCount; ) {\n            IPoolUtils(poolUtils).onlyValidKeys(_pubkey[i], _preDepositSignature[i], _depositSignature[i]);\n            address withdrawVault = IVaultFactory(vaultFactory).deployWithdrawVault(\n                POOL_ID,\n                operatorId,\n                operatorTotalKeys + i, //operator totalKeys\n                nextValidatorId\n            );\n            validatorRegistry[nextValidatorId] = Validator(\n                ValidatorStatus.INITIALIZED,\n                _pubkey[i],\n                _preDepositSignature[i],\n                _depositSignature[i],\n                withdrawVault,\n                operatorId,\n                0,\n                0\n            );\n\n            validatorIdByPubkey[_pubkey[i]] = nextValidatorId;\n            validatorIdsByOperatorId[operatorId].push(nextValidatorId);\n            emit AddedValidatorKey(msg.sender, _pubkey[i], nextValidatorId);\n            nextValidatorId++;\n            unchecked {\n                ++i;\n            }\n        }\n\n        //slither-disable-next-line arbitrary-send-eth\n        IPermissionlessPool(staderConfig.getPermissionlessPool()).preDepositOnBeaconChain{\n            value: staderConfig.getPreDepositSize() * keyCount\n        }(_pubkey, _preDepositSignature, operatorId, operatorTotalKeys);\n    }\n\n    /**\n     * @notice move validator state from INITIALIZE to PRE_DEPOSIT\n     * after verifying pre-sign message, front running and deposit signature.\n     * report front run and invalid signature pubkeys\n     * @dev only `OPERATOR` role can call\n     * @param _readyToDepositPubkey array of pubkeys ready to be moved to PRE_DEPOSIT state\n     * @param _frontRunPubkey array for pubkeys which got front deposit\n     * @param _invalidSignaturePubkey array of pubkey which has invalid signature for deposit\n     */\n    function markValidatorReadyToDeposit(\n        bytes[] calldata _readyToDepositPubkey,\n        bytes[] calldata _frontRunPubkey,\n        bytes[] calldata _invalidSignaturePubkey\n    ) external override nonReentrant whenNotPaused {\n        UtilLib.onlyOperatorRole(msg.sender, staderConfig);\n        uint256 readyToDepositValidatorsLength = _readyToDepositPubkey.length;\n        uint256 frontRunValidatorsLength = _frontRunPubkey.length;\n        uint256 invalidSignatureValidatorsLength = _invalidSignaturePubkey.length;\n        if (\n            readyToDepositValidatorsLength + frontRunValidatorsLength + invalidSignatureValidatorsLength >\n            verifiedKeyBatchSize\n        ) {\n            revert TooManyVerifiedKeysReported();\n        }\n\n        for (uint256 i; i < readyToDepositValidatorsLength; ) {\n            uint256 validatorId = validatorIdByPubkey[_readyToDepositPubkey[i]];\n            onlyInitializedValidator(validatorId);\n            markKeyReadyToDeposit(validatorId);\n            emit ValidatorMarkedReadyToDeposit(_readyToDepositPubkey[i], validatorId);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (frontRunValidatorsLength > 0) {\n            IStaderInsuranceFund(staderConfig.getStaderInsuranceFund()).depositFund{\n                value: frontRunValidatorsLength * FRONT_RUN_PENALTY\n            }();\n        }\n\n        for (uint256 i; i < frontRunValidatorsLength; ) {\n            uint256 validatorId = validatorIdByPubkey[_frontRunPubkey[i]];\n            onlyInitializedValidator(validatorId);\n            handleFrontRun(validatorId);\n            emit ValidatorMarkedAsFrontRunned(_frontRunPubkey[i], validatorId);\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < invalidSignatureValidatorsLength; ) {\n            uint256 validatorId = validatorIdByPubkey[_invalidSignaturePubkey[i]];\n            onlyInitializedValidator(validatorId);\n            handleInvalidSignature(validatorId);\n            emit ValidatorStatusMarkedAsInvalidSignature(_invalidSignaturePubkey[i], validatorId);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice handling of fully withdrawn validators\n     * @dev list of pubkeys reported by oracle\n     * @param  _pubkeys array of withdrawn validators pubkey\n     */\n    function withdrawnValidators(bytes[] calldata _pubkeys) external override {\n        UtilLib.onlyStaderContract(msg.sender, staderConfig, staderConfig.STADER_ORACLE());\n        uint256 withdrawnValidatorCount = _pubkeys.length;\n        if (withdrawnValidatorCount > staderConfig.getWithdrawnKeyBatchSize()) {\n            revert TooManyWithdrawnKeysReported();\n        }\n        for (uint256 i; i < withdrawnValidatorCount; ) {\n            uint256 validatorId = validatorIdByPubkey[_pubkeys[i]];\n            if (!isActiveValidator(validatorId)) {\n                revert UNEXPECTED_STATUS();\n            }\n            validatorRegistry[validatorId].status = ValidatorStatus.WITHDRAWN;\n            validatorRegistry[validatorId].withdrawnBlock = block.number;\n            IValidatorWithdrawalVault(validatorRegistry[validatorId].withdrawVaultAddress).settleFunds();\n            emit ValidatorWithdrawn(_pubkeys[i], validatorId);\n            unchecked {\n                ++i;\n            }\n        }\n        decreaseTotalActiveValidatorCount(withdrawnValidatorCount);\n    }\n\n    /**\n     * @notice update the next queued validator index by a count\n     * @dev accept call from permissionless pool\n     * @param _nextQueuedValidatorIndex updated next index of queued validator\n     */\n    function updateNextQueuedValidatorIndex(uint256 _nextQueuedValidatorIndex) external {\n        UtilLib.onlyStaderContract(msg.sender, staderConfig, staderConfig.PERMISSIONLESS_POOL());\n        nextQueuedValidatorIndex = _nextQueuedValidatorIndex;\n        emit UpdatedNextQueuedValidatorIndex(nextQueuedValidatorIndex);\n    }\n\n    /**\n     * @notice sets the deposit block for a validator\n     * @dev only permissionless pool can call\n     * @param _validatorId Id of the validator\n     */\n    function updateDepositStatusAndBlock(uint256 _validatorId) external override {\n        UtilLib.onlyStaderContract(msg.sender, staderConfig, staderConfig.PERMISSIONLESS_POOL());\n        validatorRegistry[_validatorId].depositBlock = block.number;\n        markValidatorDeposited(_validatorId);\n        emit UpdatedValidatorDepositBlock(_validatorId, block.number);\n    }\n\n    // allow NOs to opt in/out of socialize pool after coolDownPeriod\n    function changeSocializingPoolState(bool _optInForSocializingPool)\n        external\n        override\n        returns (address feeRecipientAddress)\n    {\n        uint256 operatorId = onlyActiveOperator(msg.sender);\n        if (operatorStructById[operatorId].optedForSocializingPool == _optInForSocializingPool) {\n            revert NoChangeInState();\n        }\n\n        if (\n            block.number <\n            socializingPoolStateChangeBlock[operatorId] + staderConfig.getSocializingPoolOptInCoolingPeriod()\n        ) {\n            revert CooldownNotComplete();\n        }\n        feeRecipientAddress = nodeELRewardVaultByOperatorId[operatorId];\n        if (_optInForSocializingPool) {\n            if (address(feeRecipientAddress).balance > 0) {\n                INodeELRewardVault(feeRecipientAddress).withdraw();\n            }\n            feeRecipientAddress = staderConfig.getPermissionlessSocializingPool();\n        }\n        operatorStructById[operatorId].optedForSocializingPool = _optInForSocializingPool;\n        socializingPoolStateChangeBlock[operatorId] = block.number;\n        emit UpdatedSocializingPoolState(operatorId, _optInForSocializingPool, block.number);\n    }\n\n    // @inheritdoc INodeRegistry\n    function getSocializingPoolStateChangeBlock(uint256 _operatorId) external view returns (uint256) {\n        return socializingPoolStateChangeBlock[_operatorId];\n    }\n\n    /**\n     * @notice update maximum key to be added in a batch\n     * @dev only `OPERATOR` role can call\n     * @param _inputKeyCountLimit updated maximum key limit in the input\n     */\n    function updateInputKeyCountLimit(uint16 _inputKeyCountLimit) external override {\n        UtilLib.onlyOperatorRole(msg.sender, staderConfig);\n        inputKeyCountLimit = _inputKeyCountLimit;\n        emit UpdatedInputKeyCountLimit(inputKeyCountLimit);\n    }\n\n    /**\n     * @notice update the maximum non terminal key limit per operator\n     * @dev only `MANAGER` role can call\n     * @param _maxNonTerminalKeyPerOperator updated maximum non terminal key per operator limit\n     */\n    function updateMaxNonTerminalKeyPerOperator(uint64 _maxNonTerminalKeyPerOperator) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        maxNonTerminalKeyPerOperator = _maxNonTerminalKeyPerOperator;\n        emit UpdatedMaxNonTerminalKeyPerOperator(maxNonTerminalKeyPerOperator);\n    }\n\n    /**\n     * @notice update the max number of verified validator keys reported by oracle\n     * @dev only `OPERATOR` can call\n     * @param _verifiedKeysBatchSize updated maximum verified key limit in the oracle input\n     */\n    function updateVerifiedKeysBatchSize(uint256 _verifiedKeysBatchSize) external {\n        UtilLib.onlyOperatorRole(msg.sender, staderConfig);\n        verifiedKeyBatchSize = _verifiedKeysBatchSize;\n        emit UpdatedVerifiedKeyBatchSize(_verifiedKeysBatchSize);\n    }\n\n    //update the address of staderConfig\n    function updateStaderConfig(address _staderConfig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    /**\n     * @notice update the name and reward address of an operator\n     * @dev only node operator can update\n     * @param _operatorName new name of the operator\n     * @param _rewardAddress new reward address\n     */\n    function updateOperatorDetails(string calldata _operatorName, address payable _rewardAddress) external override {\n        IPoolUtils(staderConfig.getPoolUtils()).onlyValidName(_operatorName);\n        UtilLib.checkNonZeroAddress(_rewardAddress);\n        onlyActiveOperator(msg.sender);\n        uint256 operatorId = operatorIDByAddress[msg.sender];\n        operatorStructById[operatorId].operatorName = _operatorName;\n        operatorStructById[operatorId].operatorRewardAddress = _rewardAddress;\n        emit UpdatedOperatorDetails(msg.sender, _operatorName, _rewardAddress);\n    }\n\n    /**\n     * @notice increase the total active validator count\n     * @dev only permissionless pool calls it when it does the deposit of 31ETH for validator\n     * @param _count count to increase total active validator value\n     */\n    function increaseTotalActiveValidatorCount(uint256 _count) external override {\n        UtilLib.onlyStaderContract(msg.sender, staderConfig, staderConfig.PERMISSIONLESS_POOL());\n        totalActiveValidatorCount += _count;\n        emit IncreasedTotalActiveValidatorCount(totalActiveValidatorCount);\n    }\n\n    /**\n     * @notice transfer the `_amount` to permissionless pool\n     * @dev only permissionless pool can call\n     * @param _amount amount of eth to send to permissionless pool\n     */\n    function transferCollateralToPool(uint256 _amount) external override nonReentrant {\n        UtilLib.onlyStaderContract(msg.sender, staderConfig, staderConfig.PERMISSIONLESS_POOL());\n        IPermissionlessPool(staderConfig.getPermissionlessPool()).receiveRemainingCollateralETH{value: _amount}();\n        emit TransferredCollateralToPool(_amount);\n    }\n\n    /**\n     * @param _nodeOperator @notice operator total non terminal keys within a specified validator list\n     * @param _startIndex start index in validator queue to start with\n     * @param _endIndex  up to end index of validator queue to to count\n     */\n    function getOperatorTotalNonTerminalKeys(\n        address _nodeOperator,\n        uint256 _startIndex,\n        uint256 _endIndex\n    ) public view override returns (uint64) {\n        if (_startIndex > _endIndex) {\n            revert InvalidStartAndEndIndex();\n        }\n        uint256 operatorId = operatorIDByAddress[_nodeOperator];\n        uint256 validatorCount = getOperatorTotalKeys(operatorId);\n        _endIndex = _endIndex > validatorCount ? validatorCount : _endIndex;\n        uint64 totalNonWithdrawnKeyCount;\n        for (uint256 i = _startIndex; i < _endIndex; ) {\n            uint256 validatorId = validatorIdsByOperatorId[operatorId][i];\n            if (isNonTerminalValidator(validatorId)) {\n                totalNonWithdrawnKeyCount++;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return totalNonWithdrawnKeyCount;\n    }\n\n    /**\n     * @notice get the total added keys for an operator\n     * @dev length of the validatorIds array for an operator\n     * @param _operatorId Id of node operator\n     */\n    function getOperatorTotalKeys(uint256 _operatorId) public view override returns (uint256 _totalKeys) {\n        _totalKeys = validatorIdsByOperatorId[_operatorId].length;\n    }\n\n    /**\n     * @notice return total queued keys for permissionless pool\n     * @return _validatorCount total queued validator count\n     */\n    function getTotalQueuedValidatorCount() public view override returns (uint256) {\n        return validatorQueueSize - nextQueuedValidatorIndex;\n    }\n\n    /**\n     * @notice return total active keys for permissionless pool\n     * @return _validatorCount total active validator count\n     */\n    function getTotalActiveValidatorCount() external view override returns (uint256) {\n        return totalActiveValidatorCount;\n    }\n\n    function getCollateralETH() external pure override returns (uint256) {\n        return COLLATERAL_ETH;\n    }\n\n    /**\n     * @notice returns the operator reward address\n     * @param _operatorId operator Id\n     */\n    function getOperatorRewardAddress(uint256 _operatorId) external view override returns (address payable) {\n        return operatorStructById[_operatorId].operatorRewardAddress;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     * Contract must not be paused\n     */\n    function pause() external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        _pause();\n    }\n\n    /**\n     * @dev Returns to normal state.\n     * Contract must be paused\n     */\n    function unpause() external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        _unpause();\n    }\n\n    /**\n     * @notice Returns an array of active validators\n     *\n     * @param _pageNumber The page number of the results to fetch (starting from 1).\n     * @param _pageSize The maximum number of items per page.\n     *\n     * @return An array of `Validator` objects representing the active validators.\n     */\n    function getAllActiveValidators(uint256 _pageNumber, uint256 _pageSize)\n        external\n        view\n        override\n        returns (Validator[] memory)\n    {\n        if (_pageNumber == 0) {\n            revert PageNumberIsZero();\n        }\n        uint256 startIndex = (_pageNumber - 1) * _pageSize + 1;\n        uint256 endIndex = startIndex + _pageSize;\n        endIndex = endIndex > nextValidatorId ? nextValidatorId : endIndex;\n        Validator[] memory validators = new Validator[](_pageSize);\n        uint256 validatorCount = 0;\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            if (isActiveValidator(i)) {\n                validators[validatorCount] = validatorRegistry[i];\n                validatorCount++;\n            }\n        }\n        // If the result array isn't full, resize it to remove the unused elements\n        assembly {\n            mstore(validators, validatorCount)\n        }\n\n        return validators;\n    }\n\n    /**\n     * @notice Returns an array of all validators for an Operator\n     *\n     * @param _pageNumber The page number of the results to fetch (starting from 1).\n     * @param _pageSize The maximum number of items per page.\n     *\n     * @return An array of `Validator` objects representing all validators for an operator\n     */\n    function getValidatorsByOperator(\n        address _operator,\n        uint256 _pageNumber,\n        uint256 _pageSize\n    ) external view override returns (Validator[] memory) {\n        if (_pageNumber == 0) {\n            revert PageNumberIsZero();\n        }\n        uint256 startIndex = (_pageNumber - 1) * _pageSize;\n        uint256 endIndex = startIndex + _pageSize;\n        uint256 operatorId = operatorIDByAddress[_operator];\n        if (operatorId == 0) {\n            revert OperatorNotOnBoarded();\n        }\n        uint256 validatorCount = getOperatorTotalKeys(operatorId);\n        endIndex = endIndex > validatorCount ? validatorCount : endIndex;\n        Validator[] memory validators = new Validator[](endIndex > startIndex ? endIndex - startIndex : 0);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            uint256 validatorId = validatorIdsByOperatorId[operatorId][i];\n            validators[i - startIndex] = validatorRegistry[validatorId];\n        }\n\n        return validators;\n    }\n\n    /**\n     * @notice Returns an array of nodeELRewardVault address for operators opting out of socializing pool\n     *\n     * @param _pageNumber The page number of the results to fetch (starting from 1).\n     * @param _pageSize The maximum number of items per page.\n     *\n     * @return An array of `address` objects representing the nodeELRewardVault contract address.\n     */\n    function getNodeELVaultAddressForOptOutOperators(uint256 _pageNumber, uint256 _pageSize)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        if (_pageNumber == 0) {\n            revert PageNumberIsZero();\n        }\n        uint256 startIndex = (_pageNumber - 1) * _pageSize + 1;\n        uint256 endIndex = startIndex + _pageSize;\n        endIndex = endIndex > nextOperatorId ? nextOperatorId : endIndex;\n        address[] memory nodeELRewardVault = new address[](_pageSize);\n        uint256 optOutOperatorCount = 0;\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            if (!operatorStructById[i].optedForSocializingPool) {\n                nodeELRewardVault[optOutOperatorCount] = nodeELRewardVaultByOperatorId[i];\n                optOutOperatorCount++;\n            }\n        }\n\n        // If the result array isn't full, resize it to remove the unused elements\n        assembly {\n            mstore(nodeELRewardVault, optOutOperatorCount)\n        }\n\n        return nodeELRewardVault;\n    }\n\n    // check for duplicate keys in permissionless node registry\n    function isExistingPubkey(bytes calldata _pubkey) external view override returns (bool) {\n        return validatorIdByPubkey[_pubkey] != 0;\n    }\n\n    // check for duplicate operator in permissionless node registry\n    function isExistingOperator(address _operAddr) external view override returns (bool) {\n        return operatorIDByAddress[_operAddr] != 0;\n    }\n\n    function onboardOperator(\n        bool _optInForSocializingPool,\n        string calldata _operatorName,\n        address payable _operatorRewardAddress\n    ) internal {\n        operatorStructById[nextOperatorId] = Operator(\n            true,\n            _optInForSocializingPool,\n            _operatorName,\n            _operatorRewardAddress,\n            msg.sender\n        );\n        operatorIDByAddress[msg.sender] = nextOperatorId;\n        socializingPoolStateChangeBlock[nextOperatorId] = block.number;\n        nextOperatorId++;\n\n        emit OnboardedOperator(msg.sender, _operatorRewardAddress, nextOperatorId - 1, _optInForSocializingPool);\n    }\n\n    // mark validator  `PRE_DEPOSIT` after successful key verification and front run check\n    function markKeyReadyToDeposit(uint256 _validatorId) internal {\n        validatorRegistry[_validatorId].status = ValidatorStatus.PRE_DEPOSIT;\n        queuedValidators[validatorQueueSize] = _validatorId;\n        validatorQueueSize++;\n    }\n\n    // handle front run validator by changing their status, deactivating operator and imposing penalty\n    function handleFrontRun(uint256 _validatorId) internal {\n        validatorRegistry[_validatorId].status = ValidatorStatus.FRONT_RUN;\n        uint256 operatorId = validatorRegistry[_validatorId].operatorId;\n        operatorStructById[operatorId].active = false;\n    }\n\n    // handle validator with invalid signature for 1ETH deposit\n    //send back remaining ETH to operator address\n    function handleInvalidSignature(uint256 _validatorId) internal {\n        validatorRegistry[_validatorId].status = ValidatorStatus.INVALID_SIGNATURE;\n        uint256 operatorId = validatorRegistry[_validatorId].operatorId;\n        address operatorAddress = operatorStructById[operatorId].operatorAddress;\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{\n            value: (COLLATERAL_ETH - staderConfig.getPreDepositSize())\n        }(operatorAddress);\n    }\n\n    // validate the input of `addValidatorKeys` function\n    function checkInputKeysCountAndCollateral(\n        uint256 _pubkeyLength,\n        uint256 _preDepositSignatureLength,\n        uint256 _depositSignatureLength,\n        uint256 _operatorId\n    ) internal view returns (uint256 keyCount, uint256 totalKeys) {\n        if (_pubkeyLength != _preDepositSignatureLength || _pubkeyLength != _depositSignatureLength) {\n            revert MisMatchingInputKeysSize();\n        }\n        keyCount = _pubkeyLength;\n        if (keyCount == 0 || keyCount > inputKeyCountLimit) {\n            revert InvalidKeyCount();\n        }\n\n        totalKeys = getOperatorTotalKeys(_operatorId);\n        uint256 totalNonTerminalKeys = getOperatorTotalNonTerminalKeys(msg.sender, 0, totalKeys);\n        if ((totalNonTerminalKeys + keyCount) > maxNonTerminalKeyPerOperator) {\n            revert maxKeyLimitReached();\n        }\n\n        // check for collateral ETH for adding keys\n        if (msg.value != keyCount * COLLATERAL_ETH) {\n            revert InvalidBondEthValue();\n        }\n        //checks if operator has enough SD collateral for adding `keyCount` keys\n        if (\n            !ISDCollateral(staderConfig.getSDCollateral()).hasEnoughSDCollateral(\n                msg.sender,\n                POOL_ID,\n                totalNonTerminalKeys + keyCount\n            )\n        ) {\n            revert NotEnoughSDCollateral();\n        }\n    }\n\n    // operator in active state\n    function onlyActiveOperator(address _operAddr) internal view returns (uint256 _operatorId) {\n        _operatorId = operatorIDByAddress[_operAddr];\n        if (_operatorId == 0) {\n            revert OperatorNotOnBoarded();\n        }\n        if (!operatorStructById[_operatorId].active) {\n            revert OperatorIsDeactivate();\n        }\n    }\n\n    // checks if validator status enum is not withdrawn ,front run and invalid signature\n    function isNonTerminalValidator(uint256 _validatorId) internal view returns (bool) {\n        Validator memory validator = validatorRegistry[_validatorId];\n        return\n            !(validator.status == ValidatorStatus.WITHDRAWN ||\n                validator.status == ValidatorStatus.FRONT_RUN ||\n                validator.status == ValidatorStatus.INVALID_SIGNATURE);\n    }\n\n    // checks if validator is active,\n    //active validator are those having user deposit staked on beacon chain\n    function isActiveValidator(uint256 _validatorId) internal view returns (bool) {\n        Validator memory validator = validatorRegistry[_validatorId];\n        return validator.status == ValidatorStatus.DEPOSITED;\n    }\n\n    // decreases the pool total active validator count\n    function decreaseTotalActiveValidatorCount(uint256 _count) internal {\n        totalActiveValidatorCount -= _count;\n        emit DecreasedTotalActiveValidatorCount(totalActiveValidatorCount);\n    }\n\n    function onlyInitializedValidator(uint256 _validatorId) internal view {\n        if (_validatorId == 0 || validatorRegistry[_validatorId].status != ValidatorStatus.INITIALIZED) {\n            revert UNEXPECTED_STATUS();\n        }\n    }\n\n    function markValidatorDeposited(uint256 _validatorId) internal {\n        validatorRegistry[_validatorId].status = ValidatorStatus.DEPOSITED;\n    }\n}"
    }
  ]
}