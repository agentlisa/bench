{
  "Title": "Plugin timestamps data can be overwritten by a call to the `prepayTimepointsStorageSlot` function",
  "Content": "##### Description\nThere is an issue at the line https://github.com/cryptoalgebra/Algebra/blob/6f57b3e218630106a4d41aedefd38f9e83b41e2b/src/plugins/contracts/AlgebraBasePluginV1.sol#L67.\nPlugin timestamps data can be overwritten by a call to the `prepayTimepointsStorageSlots` function in cases when the\nplugin was configured from AlgebraPool by a call to `setPluginConfig` (and `setPlugin`) and the `initialize` function inside plugin wasn't called. An attacker can wait for some swaps and data in the timepoints array to overwrite the existing timestamps. But due to uninitialized ticks in the first timepoint, users won't be able to perform many swaps from AlgebraPool because the plugin will operate with null initial data.\nThis issue has been assigned a MEDIUM severity level because an attacker is able to overwrite data only for a few timepoints.\n\n##### Recommendation\nWe recommend restricting the `prepayTimepointsStorageSlots` function to be called only by the plugin factory manager.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/plugins/contracts/AlgebraBasePluginV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport '@cryptoalgebra/core/contracts/base/common/Timestamp.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Plugins.sol';\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraFactory.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/plugin/IAlgebraPlugin.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/pool/IAlgebraPoolState.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\n\nimport './interfaces/IAlgebraBasePluginV1.sol';\nimport './interfaces/IBasePluginV1Factory.sol';\nimport './interfaces/IAlgebraVirtualPool.sol';\n\nimport './libraries/VolatilityOracle.sol';\nimport './libraries/AdaptiveFee.sol';\n\n/// @title Algebra default plugin\n/// @notice This contract stores timepoints and calculates adaptive fee and statistical averages\ncontract AlgebraBasePluginV1 is IAlgebraBasePluginV1, Timestamp, IAlgebraPlugin {\n  uint256 internal constant UINT16_MODULO = 65536;\n\n  using VolatilityOracle for VolatilityOracle.Timepoint[UINT16_MODULO];\n\n  /// @dev The role can be granted in AlgebraFactory\n  bytes32 public constant FEE_CONFIG_MANAGER = keccak256('FEE_CONFIG_MANAGER');\n\n  /// @inheritdoc IAlgebraPlugin\n  uint8 public constant override defaultPluginConfig =\n    uint8(Plugins.AFTER_INIT_FLAG | Plugins.BEFORE_SWAP_FLAG | Plugins.AFTER_POSITION_MODIFY_FLAG | Plugins.DYNAMIC_FEE);\n\n  /// @inheritdoc IFarmingPlugin\n  address public immutable override pool;\n  address private immutable factory;\n  address private immutable pluginFactory;\n\n  /// @inheritdoc IVolatilityOracle\n  VolatilityOracle.Timepoint[UINT16_MODULO] public override timepoints;\n\n  /// @inheritdoc IVolatilityOracle\n  uint16 public override timepointIndex;\n\n  /// @inheritdoc IVolatilityOracle\n  uint32 public override lastTimepointTimestamp;\n\n  /// @inheritdoc IFarmingPlugin\n  address public override incentive;\n\n  /// @inheritdoc IDynamicFeeManager\n  AlgebraFeeConfiguration public feeConfig;\n\n  modifier onlyPool() {\n    require(msg.sender == pool, 'only pool can call this');\n    _;\n  }\n\n  constructor(address _pool, address _factory, address _pluginFactory) {\n    (factory, pool, pluginFactory) = (_factory, _pool, _pluginFactory);\n  }\n\n  function _getPoolState() internal view returns (uint160 price, int24 tick, uint16 fee, uint8 pluginConfig) {\n    (price, tick, fee, pluginConfig, , ) = IAlgebraPoolState(pool).globalState();\n  }\n\n  /// @inheritdoc IAlgebraBasePluginV1\n  function initialize() external override {\n    require(!timepoints[0].initialized, 'Already initialized');\n    require(IAlgebraPool(pool).plugin() == address(this), 'Plugin not attached');\n    (uint160 price, int24 tick, , ) = _getPoolState();\n    require(price != 0, 'Pool is not initialized');\n\n    uint32 time = _blockTimestamp();\n    lastTimepointTimestamp = time;\n    timepoints.initialize(time, tick);\n\n    IAlgebraPool(pool).setPluginConfig(defaultPluginConfig);\n  }\n\n  // ###### Volatility and TWAP oracle ######\n\n  /// @inheritdoc IVolatilityOracle\n  function getSingleTimepoint(uint32 secondsAgo) external view override returns (int56 tickCumulative, uint112 volatilityCumulative) {\n    (, int24 tick, , ) = _getPoolState();\n    uint16 lastTimepointIndex = timepointIndex;\n    uint16 oldestIndex = timepoints.getOldestIndex(lastTimepointIndex);\n    VolatilityOracle.Timepoint memory result = timepoints.getSingleTimepoint(_blockTimestamp(), secondsAgo, tick, lastTimepointIndex, oldestIndex);\n    (tickCumulative, volatilityCumulative) = (result.tickCumulative, result.volatilityCumulative);\n  }\n\n  /// @inheritdoc IVolatilityOracle\n  function getTimepoints(\n    uint32[] memory secondsAgos\n  ) external view override returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives) {\n    (, int24 tick, , ) = _getPoolState();\n    return timepoints.getTimepoints(_blockTimestamp(), secondsAgos, tick, timepointIndex);\n  }\n\n  /// @inheritdoc IVolatilityOracle\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external override {\n    require(!timepoints[startIndex].initialized); // if not initialized, then all subsequent ones too\n    require(amount > 0 && type(uint16).max - startIndex >= amount);\n\n    unchecked {\n      for (uint256 i = startIndex; i < startIndex + amount; ++i) {\n        timepoints[i].blockTimestamp = 1; // will be overwritten\n      }\n    }\n  }\n\n  // ###### Fee manager ######\n\n  /// @inheritdoc IDynamicFeeManager\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata _config) external override {\n    require(msg.sender == pluginFactory || IAlgebraFactory(factory).hasRoleOrOwner(FEE_CONFIG_MANAGER, msg.sender));\n    AdaptiveFee.validateFeeConfiguration(_config);\n\n    feeConfig = _config;\n    emit FeeConfiguration(_config);\n  }\n\n  /// @inheritdoc IAlgebraDynamicFeePlugin\n  function getCurrentFee() external view override returns (uint16 fee) {\n    AlgebraFeeConfiguration memory _feeConfig = feeConfig;\n    if (_feeConfig.alpha1 | _feeConfig.alpha2 == 0) {\n      return _feeConfig.baseFee;\n    } else {\n      uint16 lastIndex = timepointIndex;\n      uint16 oldestIndex = timepoints.getOldestIndex(lastIndex);\n      (, int24 tick, , ) = _getPoolState();\n\n      uint88 volatilityAverage = timepoints.getAverageVolatility(_blockTimestamp(), tick, lastIndex, oldestIndex);\n\n      return AdaptiveFee.getFee(volatilityAverage, feeConfig);\n    }\n  }\n\n  function _getFeeAtLastTimepoint(uint16 lastTimepointIndex, uint16 oldestTimepointIndex, int24 currentTick) internal view returns (uint16 fee) {\n    AlgebraFeeConfiguration memory _feeConfig = feeConfig;\n    if (_feeConfig.alpha1 | _feeConfig.alpha2 == 0) {\n      return _feeConfig.baseFee;\n    } else {\n      uint88 volatilityAverage = timepoints.getAverageVolatility(_blockTimestamp(), currentTick, lastTimepointIndex, oldestTimepointIndex);\n      return AdaptiveFee.getFee(volatilityAverage, _feeConfig);\n    }\n  }\n\n  // ###### Farming plugin ######\n\n  /// @inheritdoc IFarmingPlugin\n  function setIncentive(address newIncentive) external override {\n    require(msg.sender == IBasePluginV1Factory(pluginFactory).farmingAddress());\n\n    bool turnOn = newIncentive != address(0);\n    address currentIncentive = incentive;\n\n    require(currentIncentive != newIncentive, 'already active');\n    if (currentIncentive != address(0)) require(!turnOn, 'has active incentive');\n\n    incentive = newIncentive;\n    emit Incentive(newIncentive);\n\n    (, , , uint8 pluginConfig) = _getPoolState();\n    bool isHookActive = pluginConfig & uint8(Plugins.AFTER_SWAP_FLAG) != 0;\n    if (turnOn != isHookActive) {\n      pluginConfig = pluginConfig ^ uint8(Plugins.AFTER_SWAP_FLAG);\n      IAlgebraPool(pool).setPluginConfig(pluginConfig);\n    }\n  }\n\n  /// @inheritdoc IFarmingPlugin\n  function isIncentiveActive(address targetIncentive) external view override returns (bool) {\n    if (incentive != targetIncentive) return false;\n    if (IAlgebraPool(pool).plugin() != address(this)) return false;\n    (, , , uint8 pluginConfig) = _getPoolState();\n    if (pluginConfig & uint8(Plugins.AFTER_SWAP_FLAG) == 0) return false;\n\n    return true;\n  }\n\n  // ###### HOOKS ######\n\n  function beforeInitialize(address, uint160) external override onlyPool returns (bytes4) {\n    uint8 newPluginConfig = defaultPluginConfig;\n    if (incentive != address(0)) newPluginConfig |= uint8(Plugins.AFTER_SWAP_FLAG);\n\n    IAlgebraPool(msg.sender).setPluginConfig(newPluginConfig);\n    return IAlgebraPlugin.beforeInitialize.selector;\n  }\n\n  function afterInitialize(address, uint160, int24 tick) external override onlyPool returns (bytes4) {\n    lastTimepointTimestamp = _blockTimestamp();\n    timepoints.initialize(_blockTimestamp(), tick);\n\n    IAlgebraPool(pool).setFee(feeConfig.baseFee);\n    return IAlgebraPlugin.afterInitialize.selector;\n  }\n\n  function beforeModifyPosition(address, address, int24, int24, int128, bytes calldata) external view override onlyPool returns (bytes4) {\n    revert('Not implemented');\n  }\n\n  function afterModifyPosition(address, address, int24, int24, int128, uint256, uint256, bytes calldata) external override onlyPool returns (bytes4) {\n    _writeTimepointAndUpdateFee();\n    return IAlgebraPlugin.afterModifyPosition.selector;\n  }\n\n  function beforeSwap(address, address, bool, int256, uint160, bool, bytes calldata) external override onlyPool returns (bytes4) {\n    _writeTimepointAndUpdateFee();\n    return IAlgebraPlugin.beforeSwap.selector;\n  }\n\n  function afterSwap(address, address, bool zeroToOne, int256, uint160, int256, int256, bytes calldata) external override onlyPool returns (bytes4) {\n    (, int24 tick, , ) = _getPoolState();\n    IAlgebraVirtualPool(incentive).crossTo(tick, zeroToOne);\n    return IAlgebraPlugin.afterSwap.selector;\n  }\n\n  function beforeFlash(address, address, uint256, uint256, bytes calldata) external view override onlyPool returns (bytes4) {\n    revert('Not implemented');\n  }\n\n  function afterFlash(address, address, uint256, uint256, uint256, uint256, bytes calldata) external view override onlyPool returns (bytes4) {\n    revert('Not implemented');\n  }\n\n  function _writeTimepointAndUpdateFee() internal {\n    (uint16 _lastIndex, uint32 _lastTimepointTimestamp) = (timepointIndex, lastTimepointTimestamp);\n    uint32 currentTimestamp = _blockTimestamp();\n\n    if (_lastTimepointTimestamp == currentTimestamp) return;\n\n    (, int24 tick, uint16 fee, ) = _getPoolState();\n    (uint16 newLastIndex, uint16 oldestIndex) = timepoints.write(_lastIndex, currentTimestamp, tick);\n\n    timepointIndex = newLastIndex;\n    lastTimepointTimestamp = currentTimestamp;\n\n    uint16 newFee = _getFeeAtLastTimepoint(newLastIndex, oldestIndex, tick);\n    if (newFee != fee) {\n      IAlgebraPool(pool).setFee(newFee);\n    }\n  }\n}"
    }
  ]
}