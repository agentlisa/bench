{
  "Title": "[G-01] `slurp` SLOAD Gas Optimization",
  "Content": "\n**Severity**: *Gas Optimization*<br>\n**Likelihood**: *High*<br>\n**Status**: {Not Submitted}<br>\n**Scope**: [`slurp()`](https://github.com/code-423n4/2022-02-tribe-turbo/blob/main/src/TurboSafe.sol#L255-L290)\n\nThere are two *sloads* of `getTotalFeiBoostedForVault[vault]` that can be gas golfed using an *mload* to reduce gas by `100 - 3`.\n\n![slurp Gas Golf](https://i.imgur.com/J7MFU3c.png)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-tribe-turbo-contest",
  "Code": [
    {
      "filename": "src/TurboSafe.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {CERC20} from \"./interfaces/CERC20.sol\";\nimport {Comptroller} from \"./interfaces/Comptroller.sol\";\n\nimport {TurboMaster} from \"./TurboMaster.sol\";\n\n/// @title Turbo Safe\n/// @author Transmissions11\n/// @notice Fuse liquidity accelerator.\ncontract TurboSafe is Auth, ERC4626, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The Master contract that created the Safe.\n    /// @dev Fees are paid directly to the Master, where they can be swept.\n    TurboMaster public immutable master;\n\n    /// @notice The Fei token on the network.\n    ERC20 public immutable fei;\n\n    /// @notice The Turbo Fuse Pool contract that collateral is held in and Fei is borrowed from.\n    Comptroller public immutable pool;\n\n    /// @notice The Fei cToken in the Turbo Fuse Pool that Fei is borrowed from.\n    CERC20 public immutable feiTurboCToken;\n\n    /// @notice The cToken that accepts the asset in the Turbo Fuse Pool.\n    CERC20 public immutable assetTurboCToken;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new Safe that accepts a specific asset.\n    /// @param _owner The owner of the Safe.\n    /// @param _authority The Authority of the Safe.\n    /// @param _asset The ERC20 compliant token the Safe should accept.\n    constructor(\n        address _owner,\n        Authority _authority,\n        ERC20 _asset\n    )\n        Auth(_owner, _authority)\n        ERC4626(\n            _asset,\n            // ex: Dai Stablecoin Turbo Safe\n            string(abi.encodePacked(_asset.name(), \" Turbo Safe\")),\n            // ex: tsDAI\n            string(abi.encodePacked(\"ts\", _asset.symbol()))\n        )\n    {\n        master = TurboMaster(msg.sender);\n\n        fei = master.fei();\n\n        // An asset of Fei makes no sense.\n        require(asset != fei, \"INVALID_ASSET\");\n\n        pool = master.pool();\n\n        feiTurboCToken = pool.cTokensByUnderlying(fei);\n\n        assetTurboCToken = pool.cTokensByUnderlying(asset);\n\n        // If the provided asset is not supported by the Turbo Fuse Pool, revert.\n        require(address(assetTurboCToken) != address(0), \"UNSUPPORTED_ASSET\");\n\n        // Construct an array of market(s) to enable as collateral.\n        CERC20[] memory marketsToEnter = new CERC20[](1);\n        marketsToEnter[0] = assetTurboCToken;\n\n        // Enter the market(s) and ensure to properly revert if there is an error.\n        require(pool.enterMarkets(marketsToEnter)[0] == 0, \"ENTER_MARKETS_FAILED\");\n\n        // Preemptively approve the asset to the Turbo Fuse Pool's corresponding cToken.\n        asset.safeApprove(address(assetTurboCToken), type(uint256).max);\n\n        // Preemptively approve Fei to the Turbo Fuse Pool's Fei cToken.\n        fei.safeApprove(address(feiTurboCToken), type(uint256).max);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SAFE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The current total amount of Fei the Safe is using to boost Vaults.\n    uint256 public totalFeiBoosted;\n\n    /// @notice Maps Vaults to the total amount of Fei they've being boosted with.\n    /// @dev Used to determine the fees to be paid back to the Master.\n    mapping(ERC4626 => uint256) public getTotalFeiBoostedForVault;\n\n    /*///////////////////////////////////////////////////////////////\n                               MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks the caller is authorized using either the Master's Authority or the Safe's local Authority.\n    modifier requiresLocalOrMasterAuth() {\n        // Check if the caller is the owner first:\n        if (msg.sender != owner) {\n            Authority masterAuth = master.authority(); // Saves a warm SLOAD, about 100 gas.\n\n            // If the Master's Authority does not exist or does not accept upfront:\n            if (address(masterAuth) == address(0) || !masterAuth.canCall(msg.sender, address(this), msg.sig)) {\n                Authority auth = authority; // Memoizing saves us a warm SLOAD, around 100 gas.\n\n                // The only authorization option left is via the local Authority, otherwise revert.\n                require(\n                    address(auth) != address(0) && auth.canCall(msg.sender, address(this), msg.sig),\n                    \"UNAUTHORIZED\"\n                );\n            }\n        }\n\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC4626 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Called after any type of deposit occurs.\n    /// @param assetAmount The amount of assets being deposited.\n    /// @dev Using requiresAuth here prevents unauthorized users from depositing.\n    function afterDeposit(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {\n        // Collateralize the assets in the Turbo Fuse Pool.\n        require(assetTurboCToken.mint(assetAmount) == 0, \"MINT_FAILED\");\n    }\n\n    /// @notice Called before any type of withdrawal occurs.\n    /// @param assetAmount The amount of assets being withdrawn.\n    /// @dev Using requiresAuth here prevents unauthorized users from withdrawing.\n    function beforeWithdraw(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {\n        // Withdraw the assets from the Turbo Fuse Pool.\n        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, \"REDEEM_FAILED\");\n    }\n\n    /// @notice Returns the total amount of assets held in the Safe.\n    /// @return The total amount of assets held in the Safe.\n    function totalAssets() public view override returns (uint256) {\n        return assetTurboCToken.balanceOf(address(this)).mulWadDown(assetTurboCToken.exchangeRateStored());\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           BOOST/LESS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Vault is boosted by the Safe.\n    /// @param user The user who boosted the Vault.\n    /// @param vault The Vault that was boosted.\n    /// @param feiAmount The amount of Fei that was boosted to the Vault.\n    event VaultBoosted(address indexed user, ERC4626 indexed vault, uint256 feiAmount);\n\n    /// @notice Borrow Fei from the Turbo Fuse Pool and deposit it into an authorized Vault.\n    /// @param vault The Vault to deposit the borrowed Fei into.\n    /// @param feiAmount The amount of Fei to borrow and supply into the Vault.\n    /// @dev Automatically accrues any fees earned by the Safe in the Vault to the Master.\n    function boost(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresAuth {\n        // Ensure the Vault accepts Fei asset.\n        require(vault.asset() == fei, \"NOT_FEI\");\n\n        // Call the Master where it will do extra validation\n        // and update it's total count of funds used for boosting.\n        master.onSafeBoost(asset, vault, feiAmount);\n\n        // Increase the boost total proportionately.\n        totalFeiBoosted += feiAmount;\n\n        unchecked {\n            // Update the total Fei deposited into the Vault proportionately.\n            // Cannot overflow because the total cannot be less than a single Vault.\n            getTotalFeiBoostedForVault[vault] += feiAmount;\n        }\n\n        emit VaultBoosted(msg.sender, vault, feiAmount);\n\n        // Borrow the Fei amount from the Fei cToken in the Turbo Fuse Pool.\n        require(feiTurboCToken.borrow(feiAmount) == 0, \"BORROW_FAILED\");\n\n        // Approve the borrowed Fei to the specified Vault.\n        fei.safeApprove(address(vault), feiAmount);\n\n        // Deposit the Fei into the specified Vault.\n        vault.deposit(feiAmount, address(this));\n    }\n\n    /// @notice Emitted when a Vault is withdrawn from by the Safe.\n    /// @param user The user who lessed the Vault.\n    /// @param vault The Vault that was withdrawn from.\n    /// @param feiAmount The amount of Fei that was withdrawn from the Vault.\n    event VaultLessened(address indexed user, ERC4626 indexed vault, uint256 feiAmount);\n\n    /// @notice Withdraw Fei from a deposited Vault and use it to repay debt in the Turbo Fuse Pool.\n    /// @param vault The Vault to withdraw the Fei from.\n    /// @param feiAmount The amount of Fei to withdraw from the Vault and repay in the Turbo Fuse Pool.\n    /// @dev Automatically accrues any fees earned by the Safe in the Vault to the Master.\n    function less(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresLocalOrMasterAuth {\n        // Update the total Fei deposited into the Vault proportionately.\n        getTotalFeiBoostedForVault[vault] -= feiAmount;\n\n        unchecked {\n            // Decrease the boost total proportionately.\n            // Cannot underflow because the total cannot be less than a single Vault.\n            totalFeiBoosted -= feiAmount;\n        }\n\n        emit VaultLessened(msg.sender, vault, feiAmount);\n\n        // Withdraw the specified amount of Fei from the Vault.\n        vault.withdraw(feiAmount, address(this), address(this));\n\n        // Get out current amount of Fei debt in the Turbo Fuse Pool.\n        uint256 feiDebt = feiTurboCToken.borrowBalanceCurrent(address(this));\n\n        // If our debt balance decreased, repay the minimum.\n        // The surplus Fei will accrue as fees and can be sweeped.\n        if (feiAmount > feiDebt) feiAmount = feiDebt;\n\n        // Repay Fei debt in the Turbo Fuse Pool, unless we would repay nothing.\n        if (feiAmount != 0) require(feiTurboCToken.repayBorrow(feiAmount) == 0, \"REPAY_FAILED\");\n\n        // Call the Master to allow it to update its accounting.\n        master.onSafeLess(asset, vault, feiAmount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              SLURP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Vault is slurped from by the Safe.\n    /// @param user The user who slurped the Vault.\n    /// @param vault The Vault that was slurped.\n    /// @param protocolFeeAmount The amount of Fei accrued as fees to the Master.\n    /// @param safeInterestAmount The amount of Fei accrued as interest to the Safe.\n    event VaultSlurped(\n        address indexed user,\n        ERC4626 indexed vault,\n        uint256 protocolFeeAmount,\n        uint256 safeInterestAmount\n    );\n\n    /// @notice Accrue any interest earned by the Safe in the Vault.\n    /// @param vault The Vault to accrue interest from, if any.\n    /// @dev Sends a portion of the interest to the Master, as determined by the Clerk.\n    function slurp(ERC4626 vault) external nonReentrant requiresLocalOrMasterAuth {\n        // Ensure the Safe has Fei currently boosting the Vault.\n        require(getTotalFeiBoostedForVault[vault] != 0, \"NO_FEI_BOOSTED\");\n\n        // Compute the amount of Fei interest the Safe generated by boosting the Vault.\n        uint256 interestEarned = vault.assetsOf(address(this)) - getTotalFeiBoostedForVault[vault];\n\n        // Compute what percentage of the interest earned will go back to the Safe.\n        uint256 protocolFeePercent = master.clerk().getFeePercentageForSafe(this, asset);\n\n        // Compute the amount of Fei the protocol will retain as fees.\n        uint256 protocolFeeAmount = interestEarned.mulWadDown(protocolFeePercent);\n\n        // Compute the amount of Fei the Safe will retain as interest.\n        uint256 safeInterestAmount = interestEarned - protocolFeeAmount;\n\n        // Increase the boost total proportionately.\n        totalFeiBoosted += safeInterestAmount;\n\n        unchecked {\n            // Update the total Fei held in the Vault proportionately.\n            // Cannot overflow because the total cannot be less than a single Vault.\n            getTotalFeiBoostedForVault[vault] += safeInterestAmount;\n        }\n\n        emit VaultSlurped(msg.sender, vault, protocolFeeAmount, safeInterestAmount);\n\n        // If we have unaccrued fees, withdraw them from the Vault and transfer them to the Master.\n        if (protocolFeeAmount != 0) vault.withdraw(protocolFeeAmount, address(master), address(this));\n\n        // Call the Master to allow it to update its accounting.\n        master.onSafeSlurp(asset, vault, safeInterestAmount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              SWEEP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted a token is sweeped from the Safe.\n    /// @param user The user who sweeped the token from the Safe.\n    /// @param to The recipient of the sweeped tokens.\n    /// @param amount The amount of the token that was sweeped.\n    event TokenSweeped(address indexed user, address indexed to, ERC20 indexed token, uint256 amount);\n\n    /// @notice Claim tokens sitting idly in the Safe.\n    /// @param to The recipient of the sweeped tokens.\n    /// @param token The token to sweep and send.\n    /// @param amount The amount of the token to sweep.\n    function sweep(\n        address to,\n        ERC20 token,\n        uint256 amount\n    ) external nonReentrant requiresAuth {\n        // Ensure the caller is not trying to steal Vault shares or collateral cTokens.\n        require(getTotalFeiBoostedForVault[ERC4626(address(token))] == 0 && token != assetTurboCToken, \"INVALID_TOKEN\");\n\n        emit TokenSweeped(msg.sender, to, token, amount);\n\n        // Transfer the sweeped tokens to the recipient.\n        token.safeTransfer(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               GIB LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Safe is gibbed.\n    /// @param user The user who gibbed the Safe.\n    /// @param to The recipient of the impounded collateral.\n    /// @param assetAmount The amount of underling tokens impounded.\n    event SafeGibbed(address indexed user, address indexed to, uint256 assetAmount);\n\n    /// @notice Impound a specific amount of a Safe's collateral.\n    /// @param to The address to send the impounded collateral to.\n    /// @param assetAmount The amount of the asset to impound.\n    /// @dev Can only be called by the Gibber, not by the Safe owner.\n    /// @dev Debt must be repaid in advance, or the redemption will fail.\n    function gib(address to, uint256 assetAmount) external nonReentrant requiresLocalOrMasterAuth {\n        emit SafeGibbed(msg.sender, to, assetAmount);\n\n        // Withdraw the specified amount of assets from the Turbo Fuse Pool.\n        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, \"REDEEM_FAILED\");\n\n        // Transfer the assets to the authorized caller.\n        asset.safeTransfer(to, assetAmount);\n    }\n}"
    }
  ]
}