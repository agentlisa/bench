{
  "Title": "M-5: D3Oracle will return the wrong price if the Chainlink aggregator returns price outside min/max range",
  "Content": "# Issue M-5: D3Oracle will return the wrong price if the Chainlink aggregator returns price outside min/max range \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/129 \n\n## Found by \n0xdice91, BugHunter101, MohammedRizwan, PRAISE, Proxy, dirk\\_y, kutugu\n## Summary\n\nChainlink oracles have a min and max price that they return. If the price goes below the minimum price the oracle will not return the correct price but only the min price. Same goes for the other extremity.\n\n## Vulnerability Detail\n\nBoth [`getPrice()`](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol#L48-L56) and [`getOriginalPrice()`](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol#L58-L67) only check `price > 0` not are they within the correct range\n\n```solidity\n(uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\nrequire(price > 0, \"Chainlink: Incorrect Price\");\nrequire(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\nrequire(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n```\n\n## Impact\n\nThe wrong price may be returned in the event of a market crash.\nThe functions with the issue are used in [`D3VaultFunding.sol`](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol), [`D3VaultLiquidation.sol`](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol) and [`D3UserQuota.sol`](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/periphery/D3UserQuota.sol)\n\n## Code Snippet\n\n- D3Oracle.sol functions:\n  - [`getPrice()`](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol#L48-L56)\n  - [`getOriginalPrice()`](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol#L58-L67)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n[Check the latest answer against reasonable limits](https://docs.chain.link/data-feeds#check-the-latest-answer-against-reasonable-limits) and/or revert in case you get a bad price\n\n```solidity\n require(price >= minAnswer && price <= maxAnswer, \"invalid price\");\n```\n\n\n\n\n## Discussion\n\n**Attens1423**\n\nHow can we get minPrice and maxPrice from oracle contract? Could you give us a more detailed procession?\n\n**0xffff11**\n\nhttps://docs.chain.link/data-feeds#check-the-latest-answer-against-reasonable-limits @Attens1423 \n\n\n**Attens1423**\n\nWe understand this doc. If you could offer a code example, including how to get minPrice and maxPrice from code, we would appreciate it\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ID3Oracle} from \"../../intf/ID3Oracle.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nstruct PriceSource {\n    address oracle;\n    bool isWhitelisted;\n    uint256 priceTolerance;\n    uint8 priceDecimal;\n    uint8 tokenDecimal;\n    uint256 heartBeat;\n}\n\ncontract D3Oracle is ID3Oracle, InitializableOwnable {\n    // originToken => priceSource\n    mapping(address => PriceSource) public priceSources;\n\n    /// @notice Onwer is set in constructor\n    constructor() {\n        initOwner(msg.sender);\n    }\n\n    /// @notice Set the price source for a token\n    /// @param token The token address\n    /// @param source The price source for the token\n    function setPriceSource(address token, PriceSource calldata source) external onlyOwner {\n        priceSources[token] = source;\n        require(source.priceTolerance <= DecimalMath.ONE && source.priceTolerance >= 1e10, \"INVALID_PRICE_TOLERANCE\");\n    }\n\n    /// @notice Enable or disable oracle for a token\n    /// @dev Owner could stop oracle feed price in emergency\n    /// @param token The token address\n    /// @param isAvailable Whether the oracle is available for the token\n    function setTokenOracleFeasible(address token, bool isAvailable) external onlyOwner {\n        priceSources[token].isWhitelisted = isAvailable;\n    }\n\n    /// @notice Get the price for a token\n    /// @dev The price definition is: how much virtual USD the token values if token amount is 1e18.\n    /// @dev Example 1: if the token decimals is 18, and worth 2 USD, then price is 2e18.\n    /// @dev Example 2: if the token decimals is 8, and worth 2 USD, then price is 2e28.\n    /// @param token The token address\n    function getPrice(address token) public view override returns (uint256) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        return uint256(price) * 10 ** (36 - priceSources[token].priceDecimal - priceSources[token].tokenDecimal);\n    }\n\n    function getOriginalPrice(address token) public view override returns (uint256, uint8) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        uint8 priceDecimal = priceSources[token].priceDecimal;\n        return (uint256(price), priceDecimal);\n    }\n\n    /// @notice Return if oracle is feasible for a token\n    /// @param token The token address\n    function isFeasible(address token) external view override returns (bool) {\n        return priceSources[token].isWhitelisted;\n    }\n\n    /// @notice Given certain amount of fromToken, get the max return amount of toToken\n    /// @param fromToken The from token address\n    /// @param toToken The to token address\n    /// @param fromAmount The from token amount\n    function getMaxReceive(address fromToken, address toToken, uint256 fromAmount) external view returns (uint256) {\n        uint256 fromTlr = priceSources[fromToken].priceTolerance;\n        uint256 toTlr = priceSources[toToken].priceTolerance;\n\n        return DecimalMath.div((fromAmount * getPrice(fromToken)) / getPrice(toToken), DecimalMath.mul(fromTlr, toTlr));\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ID3Oracle} from \"../../intf/ID3Oracle.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nstruct PriceSource {\n    address oracle;\n    bool isWhitelisted;\n    uint256 priceTolerance;\n    uint8 priceDecimal;\n    uint8 tokenDecimal;\n    uint256 heartBeat;\n}\n\ncontract D3Oracle is ID3Oracle, InitializableOwnable {\n    // originToken => priceSource\n    mapping(address => PriceSource) public priceSources;\n\n    /// @notice Onwer is set in constructor\n    constructor() {\n        initOwner(msg.sender);\n    }\n\n    /// @notice Set the price source for a token\n    /// @param token The token address\n    /// @param source The price source for the token\n    function setPriceSource(address token, PriceSource calldata source) external onlyOwner {\n        priceSources[token] = source;\n        require(source.priceTolerance <= DecimalMath.ONE && source.priceTolerance >= 1e10, \"INVALID_PRICE_TOLERANCE\");\n    }\n\n    /// @notice Enable or disable oracle for a token\n    /// @dev Owner could stop oracle feed price in emergency\n    /// @param token The token address\n    /// @param isAvailable Whether the oracle is available for the token\n    function setTokenOracleFeasible(address token, bool isAvailable) external onlyOwner {\n        priceSources[token].isWhitelisted = isAvailable;\n    }\n\n    /// @notice Get the price for a token\n    /// @dev The price definition is: how much virtual USD the token values if token amount is 1e18.\n    /// @dev Example 1: if the token decimals is 18, and worth 2 USD, then price is 2e18.\n    /// @dev Example 2: if the token decimals is 8, and worth 2 USD, then price is 2e28.\n    /// @param token The token address\n    function getPrice(address token) public view override returns (uint256) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        return uint256(price) * 10 ** (36 - priceSources[token].priceDecimal - priceSources[token].tokenDecimal);\n    }\n\n    function getOriginalPrice(address token) public view override returns (uint256, uint8) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        uint8 priceDecimal = priceSources[token].priceDecimal;\n        return (uint256(price), priceDecimal);\n    }\n\n    /// @notice Return if oracle is feasible for a token\n    /// @param token The token address\n    function isFeasible(address token) external view override returns (bool) {\n        return priceSources[token].isWhitelisted;\n    }\n\n    /// @notice Given certain amount of fromToken, get the max return amount of toToken\n    /// @param fromToken The from token address\n    /// @param toToken The to token address\n    /// @param fromAmount The from token amount\n    function getMaxReceive(address fromToken, address toToken, uint256 fromAmount) external view returns (uint256) {\n        uint256 fromTlr = priceSources[fromToken].priceTolerance;\n        uint256 toTlr = priceSources[toToken].priceTolerance;\n\n        return DecimalMath.div((fromAmount * getPrice(fromToken)) / getPrice(toToken), DecimalMath.mul(fromTlr, toTlr));\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/periphery/D3Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ID3Oracle} from \"../../intf/ID3Oracle.sol\";\nimport \"../lib/DecimalMath.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nstruct PriceSource {\n    address oracle;\n    bool isWhitelisted;\n    uint256 priceTolerance;\n    uint8 priceDecimal;\n    uint8 tokenDecimal;\n    uint256 heartBeat;\n}\n\ncontract D3Oracle is ID3Oracle, InitializableOwnable {\n    // originToken => priceSource\n    mapping(address => PriceSource) public priceSources;\n\n    /// @notice Onwer is set in constructor\n    constructor() {\n        initOwner(msg.sender);\n    }\n\n    /// @notice Set the price source for a token\n    /// @param token The token address\n    /// @param source The price source for the token\n    function setPriceSource(address token, PriceSource calldata source) external onlyOwner {\n        priceSources[token] = source;\n        require(source.priceTolerance <= DecimalMath.ONE && source.priceTolerance >= 1e10, \"INVALID_PRICE_TOLERANCE\");\n    }\n\n    /// @notice Enable or disable oracle for a token\n    /// @dev Owner could stop oracle feed price in emergency\n    /// @param token The token address\n    /// @param isAvailable Whether the oracle is available for the token\n    function setTokenOracleFeasible(address token, bool isAvailable) external onlyOwner {\n        priceSources[token].isWhitelisted = isAvailable;\n    }\n\n    /// @notice Get the price for a token\n    /// @dev The price definition is: how much virtual USD the token values if token amount is 1e18.\n    /// @dev Example 1: if the token decimals is 18, and worth 2 USD, then price is 2e18.\n    /// @dev Example 2: if the token decimals is 8, and worth 2 USD, then price is 2e28.\n    /// @param token The token address\n    function getPrice(address token) public view override returns (uint256) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        return uint256(price) * 10 ** (36 - priceSources[token].priceDecimal - priceSources[token].tokenDecimal);\n    }\n\n    function getOriginalPrice(address token) public view override returns (uint256, uint8) {\n        require(priceSources[token].isWhitelisted, \"INVALID_TOKEN\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(priceSources[token].oracle);\n        (uint80 roundID, int256 price,, uint256 updatedAt, uint80 answeredInRound) = priceFeed.latestRoundData();\n        require(price > 0, \"Chainlink: Incorrect Price\");\n        require(block.timestamp - updatedAt < priceSources[token].heartBeat, \"Chainlink: Stale Price\");\n        require(answeredInRound >= roundID, \"Chainlink: Stale Price\");\n        uint8 priceDecimal = priceSources[token].priceDecimal;\n        return (uint256(price), priceDecimal);\n    }\n\n    /// @notice Return if oracle is feasible for a token\n    /// @param token The token address\n    function isFeasible(address token) external view override returns (bool) {\n        return priceSources[token].isWhitelisted;\n    }\n\n    /// @notice Given certain amount of fromToken, get the max return amount of toToken\n    /// @param fromToken The from token address\n    /// @param toToken The to token address\n    /// @param fromAmount The from token amount\n    function getMaxReceive(address fromToken, address toToken, uint256 fromAmount) external view returns (uint256) {\n        uint256 fromTlr = priceSources[fromToken].priceTolerance;\n        uint256 toTlr = priceSources[toToken].priceTolerance;\n\n        return DecimalMath.div((fromAmount * getPrice(fromToken)) / getPrice(toToken), DecimalMath.mul(fromTlr, toTlr));\n    }\n}"
    }
  ]
}