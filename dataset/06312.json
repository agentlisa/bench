{
  "Title": "[M-06] Universal Data Key Permissions May Be Abused During Ownership Transfers",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lukso/blob/9dbc96410b3052fc0fd9d423249d1fa42958cae8/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol#L132-L137>\n\n<https://github.com/code-423n4/2023-06-lukso/blob/9dbc96410b3052fc0fd9d423249d1fa42958cae8/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol#L282-L288>\n\n<https://github.com/code-423n4/2023-06-lukso/blob/9dbc96410b3052fc0fd9d423249d1fa42958cae8/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol#L462>\n\n### Impact\n\nIn `LSP6KeyManager`, when fetching permissions. we are looking for universal permissions (independent from the owner). If a UP owner transfers ownership to a new owner that uses a key manager, the previously set permissions (like access for a lot controller) remain intact. This can potentially enable the old owner to retain significant control over the UP, which could be abused to destabilize the contract or cause financial harm to the new owner and other participants.\n\n### Proof of Concept\n\nThe problem arises from the inability of the smart contract to identify and manage data keys that were set by previous owners. A malicious actor could set certain permissions while they are the owner of the UP, then transfer the ownership to a new owner. The old permissions would remain in effect, allowing the old owner to maintain undue control and possibly 'rug pull' or cause other harmful actions at a later date.\n\n### Tools Used\n\nThe issue was identified through manual review of the contract mechanisms and their potential abuse, without the use of specific security tools.\n\n### Recommended Mitigation Steps\n\nTo prevent potential abuse through residual permissions, the data keys for permissions should be made owner-specific. The following mitigation steps can be implemented:\n\n*   Hash the permission with the owner's address: When setting permissions, they can be hashed with the owner's address. This way, the permissions are specifically associated with a particular owner and do not affect subsequent owners.\n\n*   Add a nonce upon ownership transfer: To further ensure the uniqueness and irrelevance of old permissions, a random nonce can be added each time the ownership is transferred. This nonce can be used in conjunction with the address of the LSP6 when retrieving permissions, making any permissions set by old owners irrelevant.\n\n### Assessed type\n\nRug-Pull\n\n**[CJ42 (LUKSO) confirmed and commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/98#issuecomment-1640231566):**\n > We are aware of the issue, but we want upgradability. Therefore, we are trying to think of solutions that we already have in mind (e.g: using unique salts while hashing the `AddressPermissions:Permissions:<controller> + salt` prefix).\n\n**[Trust (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/98#issuecomment-1662042575):**\n > I believe rug pull vectors should be capped at M severity. This is a really important find though.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/98#issuecomment-1665645987):**\n > Going to share additional rationale for severity assessment:\n >\n> Owner permissions vs Universal permissions are completely different concepts in LUKSO account abstraction. A user that receives \"owner\" permissions on an account should not be assuming permissions are reset, as it is not stated at any point.\n> The issue at hand, is  at the smart contract-level, it is impossible to know if some user has permissions set (this can still be checked on blockchain indexers/etherscan). This points to a somewhat problematic design, which is why I've decided to award it with Medium severity.\n> \n> The conditionals and the unfounded trust required from the receiver for any damage to occur make the finding not eligible for High severity.\n\n**[MiloTruck (warden) commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/98#issuecomment-1665762096):**\n > Hi @Trust, I don't mean to question your judgement here, but I don't really understand why this issue is considered a medium severity bug.\n> \n> > A user that receives \"owner\" permissions on an account should not be assuming permissions are reset, as it is not stated at any point.\n> \n> Wouldn't this mean that any impact resulting from a previous owner maliciously configuring permissions is a user mistake (as it is the responsibility of the current owner to ensure permissions are correct), making the issue QA?\n> \n> Additionally, in my opinion, the likelihood of such a scenario occurring is extremely low since LSP0 accounts, unlike NFTs, aren't meant to be traded and should not be transferred between untrusted parties in the first place.\n> \n> > The issue at hand, is that at the smart contract-level, it is impossible to know if some user has permissions set (this can still be checked on blockchain indexers/etherscan). This points to a somewhat problematic design, which is why I've decided to award it with Medium severity.\n> \n> Shouldn't design issues fall under QA according to C4's severity rules? While it is true that this cannot be checked on-chain, there are ways to side-step this issue by monitoring what permissions are added off-chain.\n> \n> Would also like to highlight that there are many other ways for a previous owner to maliciously configure the LSP0 account without permissions that cannot be checked at a smart contract level:\n> * Previous owner can add an extension to transfer tokens out from the account.\n> * Previous owner can approve other addresses controlled by themselves to transfer LSP7/LSP8 tokens on behalf of the LSP0 account by calling `authorizeOperator()` through `execute()`.\n>  \n> This suggests that the sponsor was aware of the risks related to the transferring ownership of a LSP0 account and deemed them as acceptable for the current design.\n> \n> Would like to hear your opinion to understand from a judge's POV, thanks!\n\n**[skimaharvey (LUKSO) commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/98#issuecomment-1665794364):**\n >>Going to share additional rationale for severity assessment: etc...\n >\n>@Trust - Agreed with everything said here. As stated, the main issue is that they are not retrievable from the smart contract directly which is not ideal. \n>\n> We intend to fix it by:\n> - enforcing that the permissions are retrievable at the SC level.\n> - and/or when there is a change in owner old permissions should easily be discarded (through, for example, adding a salt set at the Key Manager level).\n> \n> We are still thinking about it and are open to any good ideas you might have.\n> But yes 'High' severity seems exaggerated, as it is your duty as a new owner to not blindly trust and make sure that old permissions do not remain through an indexer, for example.\n> \n> And yes @MiloTruck - it is true for controllers or extensions. Anything that could have permissions on the UP. \n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/98#issuecomment-1665934681):**\n > @MiloTruck - good points raised. In an ideal world, this would be part of the architecture section of a top analysis report. However, we're still not there yet.\n >\n> I've factored in these considerations:\n> 1. The submission was eye-opening for the team.\n> 2. Functionality is lacking (can't view permissions trustlessly).\n> 3. From chats with the team, the usage of account transfers is not as unlikely as initially seems.\n> \n> Therefore, I decided to round up a weak medium/strong analysis, as sponsor has confirmed the finding.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP6KeyManager/LSP6KeyManagerCore.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\n// interfaces\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {\n    IERC725X\n} from \"../../submodules/ERC725/implementations/contracts/interfaces/IERC725X.sol\";\nimport {\n    IERC725Y\n} from \"../../submodules/ERC725/implementations/contracts/interfaces/IERC725Y.sol\";\nimport {ILSP6KeyManager} from \"./ILSP6KeyManager.sol\";\nimport {\n    ILSP20CallVerifier as ILSP20\n} from \"../LSP20CallVerification/ILSP20CallVerifier.sol\";\n\n// modules\nimport {ILSP14Ownable2Step} from \"../LSP14Ownable2Step/ILSP14Ownable2Step.sol\";\nimport {\n    ERC725Y\n} from \"../../submodules/ERC725/implementations/contracts/ERC725Y.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {LSP6SetDataModule} from \"./LSP6Modules/LSP6SetDataModule.sol\";\nimport {LSP6ExecuteModule} from \"./LSP6Modules/LSP6ExecuteModule.sol\";\nimport {LSP6OwnershipModule} from \"./LSP6Modules/LSP6OwnershipModule.sol\";\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LSP6Utils} from \"./LSP6Utils.sol\";\n\n// errors\nimport {\n    BatchExecuteParamsLengthMismatch,\n    BatchExecuteRelayCallParamsLengthMismatch,\n    LSP6BatchExcessiveValueSent,\n    LSP6BatchInsufficientValueSent,\n    InvalidPayload,\n    InvalidRelayNonce,\n    NoPermissionsSet,\n    InvalidERC725Function,\n    CannotSendValueToSetData,\n    RelayCallBeforeStartTime,\n    RelayCallExpired\n} from \"./LSP6Errors.sol\";\n\nimport {\n    _INTERFACEID_ERC1271,\n    _ERC1271_MAGICVALUE,\n    _ERC1271_FAILVALUE\n} from \"../LSP0ERC725Account/LSP0Constants.sol\";\nimport {\n    LSP6_VERSION,\n    _INTERFACEID_LSP6,\n    _PERMISSION_SIGN,\n    _PERMISSION_REENTRANCY\n} from \"./LSP6Constants.sol\";\nimport \"../LSP20CallVerification/LSP20Constants.sol\";\n\n/**\n * @title Core implementation of the LSP6 Key Manager standard.\n * @author Fabian Vogelsteller <frozeman>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi)\n * @dev This contract acts as a controller for an ERC725 Account.\n *      Permissions for controllers are stored in the ERC725Y storage of the ERC725 Account and can be updated using `setData(...)`.\n */\nabstract contract LSP6KeyManagerCore is\n    ERC165,\n    ILSP6KeyManager,\n    ILSP20,\n    LSP6SetDataModule,\n    LSP6ExecuteModule,\n    LSP6OwnershipModule\n{\n    using LSP6Utils for *;\n    using ECDSA for *;\n    using BytesLib for bytes;\n\n    address internal _target;\n\n    // Variables, methods and modifier used for ReentrancyGuard are taken from the link below and modified accordingly.\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\n    bool private _reentrancyStatus;\n\n    mapping(address => mapping(uint256 => uint256)) internal _nonceStore;\n\n    function target() public view returns (address) {\n        return _target;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == _INTERFACEID_LSP6 ||\n            interfaceId == _INTERFACEID_ERC1271 ||\n            interfaceId == _INTERFACEID_LSP20_CALL_VERIFIER ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function getNonce(\n        address from,\n        uint128 channelId\n    ) public view returns (uint256) {\n        uint256 nonceInChannel = _nonceStore[from][channelId];\n        return (uint256(channelId) << 128) | nonceInChannel;\n    }\n\n    /**\n     * @inheritdoc IERC1271\n     */\n    function isValidSignature(\n        bytes32 dataHash,\n        bytes memory signature\n    ) public view returns (bytes4 magicValue) {\n        // if isValidSignature fail, the error is catched in returnedError\n        (address recoveredAddress, ECDSA.RecoverError returnedError) = ECDSA\n            .tryRecover(dataHash, signature);\n\n        // if recovering throws an error, return the fail value\n        if (returnedError != ECDSA.RecoverError.NoError)\n            return _ERC1271_FAILVALUE;\n\n        // if the address recovered has SIGN permission return the ERC1271 magic value, otherwise the fail value\n        return (\n            ERC725Y(_target).getPermissionsFor(recoveredAddress).hasPermission(\n                _PERMISSION_SIGN\n            )\n                ? _ERC1271_MAGICVALUE\n                : _ERC1271_FAILVALUE\n        );\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function execute(\n        bytes calldata payload\n    ) public payable virtual returns (bytes memory) {\n        return _execute(msg.value, payload);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeBatch(\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) public payable virtual returns (bytes[] memory) {\n        if (values.length != payloads.length) {\n            revert BatchExecuteParamsLengthMismatch();\n        }\n\n        bytes[] memory results = new bytes[](payloads.length);\n        uint256 totalValues;\n\n        for (uint256 ii = 0; ii < payloads.length; ) {\n            if ((totalValues += values[ii]) > msg.value) {\n                revert LSP6BatchInsufficientValueSent(totalValues, msg.value);\n            }\n\n            results[ii] = _execute(values[ii], payloads[ii]);\n\n            unchecked {\n                ++ii;\n            }\n        }\n\n        if (totalValues < msg.value) {\n            revert LSP6BatchExcessiveValueSent(totalValues, msg.value);\n        }\n\n        return results;\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeRelayCall(\n        bytes memory signature,\n        uint256 nonce,\n        uint256 validityTimestamps,\n        bytes calldata payload\n    ) public payable virtual returns (bytes memory) {\n        return\n            _executeRelayCall(\n                signature,\n                nonce,\n                validityTimestamps,\n                msg.value,\n                payload\n            );\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeRelayCallBatch(\n        bytes[] memory signatures,\n        uint256[] calldata nonces,\n        uint256[] calldata validityTimestamps,\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) public payable virtual returns (bytes[] memory) {\n        if (\n            signatures.length != nonces.length ||\n            nonces.length != validityTimestamps.length ||\n            validityTimestamps.length != values.length ||\n            values.length != payloads.length\n        ) {\n            revert BatchExecuteRelayCallParamsLengthMismatch();\n        }\n\n        bytes[] memory results = new bytes[](payloads.length);\n        uint256 totalValues;\n\n        for (uint256 ii = 0; ii < payloads.length; ) {\n            if ((totalValues += values[ii]) > msg.value) {\n                revert LSP6BatchInsufficientValueSent(totalValues, msg.value);\n            }\n\n            results[ii] = _executeRelayCall(\n                signatures[ii],\n                nonces[ii],\n                validityTimestamps[ii],\n                values[ii],\n                payloads[ii]\n            );\n\n            unchecked {\n                ++ii;\n            }\n        }\n\n        if (totalValues < msg.value) {\n            revert LSP6BatchExcessiveValueSent(totalValues, msg.value);\n        }\n\n        return results;\n    }\n\n    /**\n     * @inheritdoc ILSP20\n     */\n    function lsp20VerifyCall(\n        address caller,\n        uint256 msgValue,\n        bytes calldata data\n    ) external returns (bytes4) {\n        bool isSetData = false;\n        if (\n            bytes4(data) == IERC725Y.setData.selector ||\n            bytes4(data) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        // If target is invoking the verification, emit the event and change the reentrancy guard\n        if (msg.sender == _target) {\n            bool isReentrantCall = _nonReentrantBefore(isSetData, caller);\n\n            _verifyPermissions(caller, msgValue, data);\n            emit VerifiedCall(caller, msgValue, bytes4(data));\n\n            // if it's a setData call, do not invoke the `lsp20VerifyCallResult(..)` function\n            return\n                isSetData || isReentrantCall\n                    ? _LSP20_VERIFY_CALL_MAGIC_VALUE_WITHOUT_POST_VERIFICATION\n                    : _LSP20_VERIFY_CALL_MAGIC_VALUE_WITH_POST_VERIFICATION;\n        }\n        // If a different address is invoking the verification, do not change the state\n        // and do read-only verification\n        else {\n            bool isReentrantCall = _reentrancyStatus;\n\n            if (isReentrantCall) {\n                _requirePermissions(\n                    caller,\n                    ERC725Y(_target).getPermissionsFor(caller),\n                    _PERMISSION_REENTRANCY\n                );\n            }\n\n            _verifyPermissions(caller, msgValue, data);\n\n            // if it's a setData call, do not invoke the `lsp20VerifyCallResult(..)` function\n            return\n                isSetData || isReentrantCall\n                    ? _LSP20_VERIFY_CALL_MAGIC_VALUE_WITHOUT_POST_VERIFICATION\n                    : _LSP20_VERIFY_CALL_MAGIC_VALUE_WITH_POST_VERIFICATION;\n        }\n    }\n\n    /**\n     * @inheritdoc ILSP20\n     */\n    function lsp20VerifyCallResult(\n        bytes32 /*callHash*/,\n        bytes memory /*result*/\n    ) external returns (bytes4) {\n        // If it's the target calling, set back the reentrancy guard\n        // to false, if not return the magic value\n        if (msg.sender == _target) {\n            _nonReentrantAfter();\n        }\n        return _LSP20_VERIFY_CALL_RESULT_MAGIC_VALUE;\n    }\n\n    function _execute(\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        if (payload.length < 4) {\n            revert InvalidPayload(payload);\n        }\n\n        bool isSetData = false;\n        if (\n            bytes4(payload) == IERC725Y.setData.selector ||\n            bytes4(payload) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        bool isReentrantCall = _nonReentrantBefore(isSetData, msg.sender);\n\n        _verifyPermissions(msg.sender, msgValue, payload);\n        emit VerifiedCall(msg.sender, msgValue, bytes4(payload));\n\n        bytes memory result = _executePayload(msgValue, payload);\n\n        if (!isReentrantCall && !isSetData) {\n            _nonReentrantAfter();\n        }\n\n        return result;\n    }\n\n    function _executeRelayCall(\n        bytes memory signature,\n        uint256 nonce,\n        uint256 validityTimestamps,\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        if (payload.length < 4) {\n            revert InvalidPayload(payload);\n        }\n\n        bytes memory encodedMessage = abi.encodePacked(\n            LSP6_VERSION,\n            block.chainid,\n            nonce,\n            validityTimestamps,\n            msgValue,\n            payload\n        );\n\n        address signer = address(this)\n            .toDataWithIntendedValidatorHash(encodedMessage)\n            .recover(signature);\n\n        bool isSetData = false;\n        if (\n            bytes4(payload) == IERC725Y.setData.selector ||\n            bytes4(payload) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        bool isReentrantCall = _nonReentrantBefore(isSetData, signer);\n\n        if (!_isValidNonce(signer, nonce)) {\n            revert InvalidRelayNonce(signer, nonce, signature);\n        }\n\n        // increase nonce after successful verification\n        _nonceStore[signer][nonce >> 128]++;\n\n        if (validityTimestamps != 0) {\n            uint128 startingTimestamp = uint128(validityTimestamps >> 128);\n            uint128 endingTimestamp = uint128(validityTimestamps);\n\n            // solhint-disable not-rely-on-time\n            if (block.timestamp < startingTimestamp) {\n                revert RelayCallBeforeStartTime();\n            }\n            if (block.timestamp > endingTimestamp) {\n                revert RelayCallExpired();\n            }\n        }\n\n        _verifyPermissions(signer, msgValue, payload);\n        emit VerifiedCall(signer, msgValue, bytes4(payload));\n\n        bytes memory result = _executePayload(msgValue, payload);\n\n        if (!isReentrantCall && !isSetData) {\n            _nonReentrantAfter();\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice execute the `payload` passed to `execute(...)` or `executeRelayCall(...)`\n     * @param payload the abi-encoded function call to execute on the target.\n     * @return bytes the result from calling the target with `payload`\n     */\n    function _executePayload(\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        (bool success, bytes memory returnData) = _target.call{\n            value: msgValue,\n            gas: gasleft()\n        }(payload);\n        bytes memory result = Address.verifyCallResult(\n            success,\n            returnData,\n            \"LSP6: failed executing payload\"\n        );\n\n        return result.length != 0 ? abi.decode(result, (bytes)) : result;\n    }\n\n    /**\n     * @notice verify the nonce `_idx` for `_from` (obtained via `getNonce(...)`)\n     * @dev \"idx\" is a 256bits (unsigned) integer, where:\n     *          - the 128 leftmost bits = channelId\n     *      and - the 128 rightmost bits = nonce within the channel\n     * @param from caller address\n     * @param idx (channel id + nonce within the channel)\n     */\n    function _isValidNonce(\n        address from,\n        uint256 idx\n    ) internal view virtual returns (bool) {\n        uint256 mask = ~uint128(0);\n        // Alternatively:\n        // uint256 mask = (1<<128)-1;\n        // uint256 mask = 0xffffffffffffffffffffffffffffffff;\n        return (idx & mask) == (_nonceStore[from][idx >> 128]);\n    }\n\n    /**\n     * @dev verify if the `from` address is allowed to execute the `payload` on the `target`.\n     * @param from either the caller of `execute(...)` or the signer of `executeRelayCall(...)`.\n     * @param payload the payload to execute on the `target`.\n     */\n    function _verifyPermissions(\n        address from,\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal view virtual {\n        bytes32 permissions = ERC725Y(_target).getPermissionsFor(from);\n        if (permissions == bytes32(0)) revert NoPermissionsSet(from);\n\n        bytes4 erc725Function = bytes4(payload);\n\n        // ERC725Y.setData(bytes32,bytes)\n        if (erc725Function == IERC725Y.setData.selector) {\n            if (msgValue != 0) revert CannotSendValueToSetData();\n            (bytes32 inputKey, bytes memory inputValue) = abi.decode(\n                payload[4:],\n                (bytes32, bytes)\n            );\n\n            LSP6SetDataModule._verifyCanSetData(\n                _target,\n                from,\n                permissions,\n                inputKey,\n                inputValue\n            );\n\n            // ERC725Y.setDataBatch(bytes32[],bytes[])\n        } else if (erc725Function == IERC725Y.setDataBatch.selector) {\n            if (msgValue != 0) revert CannotSendValueToSetData();\n            (bytes32[] memory inputKeys, bytes[] memory inputValues) = abi\n                .decode(payload[4:], (bytes32[], bytes[]));\n\n            LSP6SetDataModule._verifyCanSetData(\n                _target,\n                from,\n                permissions,\n                inputKeys,\n                inputValues\n            );\n\n            // ERC725X.execute(uint256,address,uint256,bytes)\n        } else if (erc725Function == IERC725X.execute.selector) {\n            LSP6ExecuteModule._verifyCanExecute(\n                _target,\n                from,\n                permissions,\n                payload\n            );\n        } else if (\n            erc725Function == ILSP14Ownable2Step.transferOwnership.selector ||\n            erc725Function == ILSP14Ownable2Step.acceptOwnership.selector\n        ) {\n            LSP6OwnershipModule._verifyOwnershipPermissions(from, permissions);\n        } else {\n            revert InvalidERC725Function(erc725Function);\n        }\n    }\n\n    /**\n     * @dev Initialise _reentrancyStatus to _NOT_ENTERED.\n     */\n    function _setupLSP6ReentrancyGuard() internal virtual {\n        _reentrancyStatus = false;\n    }\n\n    /**\n     * @dev Update the status from `_NON_ENTERED` to `_ENTERED` and checks if\n     * the status is `_ENTERED` in order to revert the call unless the caller has the REENTRANCY permission\n     * Used in the beginning of the `nonReentrant` modifier, before the method execution starts.\n     */\n    function _nonReentrantBefore(\n        bool isSetData,\n        address from\n    ) internal virtual returns (bool isReentrantCall) {\n        isReentrantCall = _reentrancyStatus;\n        if (isReentrantCall) {\n            // CHECK the caller has REENTRANCY permission\n            _requirePermissions(\n                from,\n                ERC725Y(_target).getPermissionsFor(from),\n                _PERMISSION_REENTRANCY\n            );\n        } else {\n            if (!isSetData) {\n                _reentrancyStatus = true;\n            }\n        }\n    }\n\n    /**\n     * @dev Resets the status to `_NOT_ENTERED`\n     * Used in the end of the `nonReentrant` modifier after the method execution is terminated\n     */\n    function _nonReentrantAfter() internal virtual {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = false;\n    }\n\n    /**\n     * @dev revert if `controller`'s `addressPermissions` doesn't contain `permissionsRequired`\n     * @param controller the caller address\n     * @param addressPermissions the caller's permissions BitArray\n     * @param permissionRequired the required permission\n     */\n    function _requirePermissions(\n        address controller,\n        bytes32 addressPermissions,\n        bytes32 permissionRequired\n    ) internal pure override(LSP6ExecuteModule, LSP6SetDataModule) {\n        LSP6ExecuteModule._requirePermissions(\n            controller,\n            addressPermissions,\n            permissionRequired\n        );\n    }\n}"
    },
    {
      "filename": "contracts/LSP6KeyManager/LSP6KeyManagerCore.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\n// interfaces\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {\n    IERC725X\n} from \"../../submodules/ERC725/implementations/contracts/interfaces/IERC725X.sol\";\nimport {\n    IERC725Y\n} from \"../../submodules/ERC725/implementations/contracts/interfaces/IERC725Y.sol\";\nimport {ILSP6KeyManager} from \"./ILSP6KeyManager.sol\";\nimport {\n    ILSP20CallVerifier as ILSP20\n} from \"../LSP20CallVerification/ILSP20CallVerifier.sol\";\n\n// modules\nimport {ILSP14Ownable2Step} from \"../LSP14Ownable2Step/ILSP14Ownable2Step.sol\";\nimport {\n    ERC725Y\n} from \"../../submodules/ERC725/implementations/contracts/ERC725Y.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {LSP6SetDataModule} from \"./LSP6Modules/LSP6SetDataModule.sol\";\nimport {LSP6ExecuteModule} from \"./LSP6Modules/LSP6ExecuteModule.sol\";\nimport {LSP6OwnershipModule} from \"./LSP6Modules/LSP6OwnershipModule.sol\";\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LSP6Utils} from \"./LSP6Utils.sol\";\n\n// errors\nimport {\n    BatchExecuteParamsLengthMismatch,\n    BatchExecuteRelayCallParamsLengthMismatch,\n    LSP6BatchExcessiveValueSent,\n    LSP6BatchInsufficientValueSent,\n    InvalidPayload,\n    InvalidRelayNonce,\n    NoPermissionsSet,\n    InvalidERC725Function,\n    CannotSendValueToSetData,\n    RelayCallBeforeStartTime,\n    RelayCallExpired\n} from \"./LSP6Errors.sol\";\n\nimport {\n    _INTERFACEID_ERC1271,\n    _ERC1271_MAGICVALUE,\n    _ERC1271_FAILVALUE\n} from \"../LSP0ERC725Account/LSP0Constants.sol\";\nimport {\n    LSP6_VERSION,\n    _INTERFACEID_LSP6,\n    _PERMISSION_SIGN,\n    _PERMISSION_REENTRANCY\n} from \"./LSP6Constants.sol\";\nimport \"../LSP20CallVerification/LSP20Constants.sol\";\n\n/**\n * @title Core implementation of the LSP6 Key Manager standard.\n * @author Fabian Vogelsteller <frozeman>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi)\n * @dev This contract acts as a controller for an ERC725 Account.\n *      Permissions for controllers are stored in the ERC725Y storage of the ERC725 Account and can be updated using `setData(...)`.\n */\nabstract contract LSP6KeyManagerCore is\n    ERC165,\n    ILSP6KeyManager,\n    ILSP20,\n    LSP6SetDataModule,\n    LSP6ExecuteModule,\n    LSP6OwnershipModule\n{\n    using LSP6Utils for *;\n    using ECDSA for *;\n    using BytesLib for bytes;\n\n    address internal _target;\n\n    // Variables, methods and modifier used for ReentrancyGuard are taken from the link below and modified accordingly.\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\n    bool private _reentrancyStatus;\n\n    mapping(address => mapping(uint256 => uint256)) internal _nonceStore;\n\n    function target() public view returns (address) {\n        return _target;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == _INTERFACEID_LSP6 ||\n            interfaceId == _INTERFACEID_ERC1271 ||\n            interfaceId == _INTERFACEID_LSP20_CALL_VERIFIER ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function getNonce(\n        address from,\n        uint128 channelId\n    ) public view returns (uint256) {\n        uint256 nonceInChannel = _nonceStore[from][channelId];\n        return (uint256(channelId) << 128) | nonceInChannel;\n    }\n\n    /**\n     * @inheritdoc IERC1271\n     */\n    function isValidSignature(\n        bytes32 dataHash,\n        bytes memory signature\n    ) public view returns (bytes4 magicValue) {\n        // if isValidSignature fail, the error is catched in returnedError\n        (address recoveredAddress, ECDSA.RecoverError returnedError) = ECDSA\n            .tryRecover(dataHash, signature);\n\n        // if recovering throws an error, return the fail value\n        if (returnedError != ECDSA.RecoverError.NoError)\n            return _ERC1271_FAILVALUE;\n\n        // if the address recovered has SIGN permission return the ERC1271 magic value, otherwise the fail value\n        return (\n            ERC725Y(_target).getPermissionsFor(recoveredAddress).hasPermission(\n                _PERMISSION_SIGN\n            )\n                ? _ERC1271_MAGICVALUE\n                : _ERC1271_FAILVALUE\n        );\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function execute(\n        bytes calldata payload\n    ) public payable virtual returns (bytes memory) {\n        return _execute(msg.value, payload);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeBatch(\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) public payable virtual returns (bytes[] memory) {\n        if (values.length != payloads.length) {\n            revert BatchExecuteParamsLengthMismatch();\n        }\n\n        bytes[] memory results = new bytes[](payloads.length);\n        uint256 totalValues;\n\n        for (uint256 ii = 0; ii < payloads.length; ) {\n            if ((totalValues += values[ii]) > msg.value) {\n                revert LSP6BatchInsufficientValueSent(totalValues, msg.value);\n            }\n\n            results[ii] = _execute(values[ii], payloads[ii]);\n\n            unchecked {\n                ++ii;\n            }\n        }\n\n        if (totalValues < msg.value) {\n            revert LSP6BatchExcessiveValueSent(totalValues, msg.value);\n        }\n\n        return results;\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeRelayCall(\n        bytes memory signature,\n        uint256 nonce,\n        uint256 validityTimestamps,\n        bytes calldata payload\n    ) public payable virtual returns (bytes memory) {\n        return\n            _executeRelayCall(\n                signature,\n                nonce,\n                validityTimestamps,\n                msg.value,\n                payload\n            );\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeRelayCallBatch(\n        bytes[] memory signatures,\n        uint256[] calldata nonces,\n        uint256[] calldata validityTimestamps,\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) public payable virtual returns (bytes[] memory) {\n        if (\n            signatures.length != nonces.length ||\n            nonces.length != validityTimestamps.length ||\n            validityTimestamps.length != values.length ||\n            values.length != payloads.length\n        ) {\n            revert BatchExecuteRelayCallParamsLengthMismatch();\n        }\n\n        bytes[] memory results = new bytes[](payloads.length);\n        uint256 totalValues;\n\n        for (uint256 ii = 0; ii < payloads.length; ) {\n            if ((totalValues += values[ii]) > msg.value) {\n                revert LSP6BatchInsufficientValueSent(totalValues, msg.value);\n            }\n\n            results[ii] = _executeRelayCall(\n                signatures[ii],\n                nonces[ii],\n                validityTimestamps[ii],\n                values[ii],\n                payloads[ii]\n            );\n\n            unchecked {\n                ++ii;\n            }\n        }\n\n        if (totalValues < msg.value) {\n            revert LSP6BatchExcessiveValueSent(totalValues, msg.value);\n        }\n\n        return results;\n    }\n\n    /**\n     * @inheritdoc ILSP20\n     */\n    function lsp20VerifyCall(\n        address caller,\n        uint256 msgValue,\n        bytes calldata data\n    ) external returns (bytes4) {\n        bool isSetData = false;\n        if (\n            bytes4(data) == IERC725Y.setData.selector ||\n            bytes4(data) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        // If target is invoking the verification, emit the event and change the reentrancy guard\n        if (msg.sender == _target) {\n            bool isReentrantCall = _nonReentrantBefore(isSetData, caller);\n\n            _verifyPermissions(caller, msgValue, data);\n            emit VerifiedCall(caller, msgValue, bytes4(data));\n\n            // if it's a setData call, do not invoke the `lsp20VerifyCallResult(..)` function\n            return\n                isSetData || isReentrantCall\n                    ? _LSP20_VERIFY_CALL_MAGIC_VALUE_WITHOUT_POST_VERIFICATION\n                    : _LSP20_VERIFY_CALL_MAGIC_VALUE_WITH_POST_VERIFICATION;\n        }\n        // If a different address is invoking the verification, do not change the state\n        // and do read-only verification\n        else {\n            bool isReentrantCall = _reentrancyStatus;\n\n            if (isReentrantCall) {\n                _requirePermissions(\n                    caller,\n                    ERC725Y(_target).getPermissionsFor(caller),\n                    _PERMISSION_REENTRANCY\n                );\n            }\n\n            _verifyPermissions(caller, msgValue, data);\n\n            // if it's a setData call, do not invoke the `lsp20VerifyCallResult(..)` function\n            return\n                isSetData || isReentrantCall\n                    ? _LSP20_VERIFY_CALL_MAGIC_VALUE_WITHOUT_POST_VERIFICATION\n                    : _LSP20_VERIFY_CALL_MAGIC_VALUE_WITH_POST_VERIFICATION;\n        }\n    }\n\n    /**\n     * @inheritdoc ILSP20\n     */\n    function lsp20VerifyCallResult(\n        bytes32 /*callHash*/,\n        bytes memory /*result*/\n    ) external returns (bytes4) {\n        // If it's the target calling, set back the reentrancy guard\n        // to false, if not return the magic value\n        if (msg.sender == _target) {\n            _nonReentrantAfter();\n        }\n        return _LSP20_VERIFY_CALL_RESULT_MAGIC_VALUE;\n    }\n\n    function _execute(\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        if (payload.length < 4) {\n            revert InvalidPayload(payload);\n        }\n\n        bool isSetData = false;\n        if (\n            bytes4(payload) == IERC725Y.setData.selector ||\n            bytes4(payload) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        bool isReentrantCall = _nonReentrantBefore(isSetData, msg.sender);\n\n        _verifyPermissions(msg.sender, msgValue, payload);\n        emit VerifiedCall(msg.sender, msgValue, bytes4(payload));\n\n        bytes memory result = _executePayload(msgValue, payload);\n\n        if (!isReentrantCall && !isSetData) {\n            _nonReentrantAfter();\n        }\n\n        return result;\n    }\n\n    function _executeRelayCall(\n        bytes memory signature,\n        uint256 nonce,\n        uint256 validityTimestamps,\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        if (payload.length < 4) {\n            revert InvalidPayload(payload);\n        }\n\n        bytes memory encodedMessage = abi.encodePacked(\n            LSP6_VERSION,\n            block.chainid,\n            nonce,\n            validityTimestamps,\n            msgValue,\n            payload\n        );\n\n        address signer = address(this)\n            .toDataWithIntendedValidatorHash(encodedMessage)\n            .recover(signature);\n\n        bool isSetData = false;\n        if (\n            bytes4(payload) == IERC725Y.setData.selector ||\n            bytes4(payload) == IERC725Y.setDataBatch.selector\n        ) {\n            isSetData = true;\n        }\n\n        bool isReentrantCall = _nonReentrantBefore(isSetData, signer);\n\n        if (!_isValidNonce(signer, nonce)) {\n            revert InvalidRelayNonce(signer, nonce, signature);\n        }\n\n        // increase nonce after successful verification\n        _nonceStore[signer][nonce >> 128]++;\n\n        if (validityTimestamps != 0) {\n            uint128 startingTimestamp = uint128(validityTimestamps >> 128);\n            uint128 endingTimestamp = uint128(validityTimestamps);\n\n            // solhint-disable not-rely-on-time\n            if (block.timestamp < startingTimestamp) {\n                revert RelayCallBeforeStartTime();\n            }\n            if (block.timestamp > endingTimestamp) {\n                revert RelayCallExpired();\n            }\n        }\n\n        _verifyPermissions(signer, msgValue, payload);\n        emit VerifiedCall(signer, msgValue, bytes4(payload));\n\n        bytes memory result = _executePayload(msgValue, payload);\n\n        if (!isReentrantCall && !isSetData) {\n            _nonReentrantAfter();\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice execute the `payload` passed to `execute(...)` or `executeRelayCall(...)`\n     * @param payload the abi-encoded function call to execute on the target.\n     * @return bytes the result from calling the target with `payload`\n     */\n    function _executePayload(\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        (bool success, bytes memory returnData) = _target.call{\n            value: msgValue,\n            gas: gasleft()\n        }(payload);\n        bytes memory result = Address.verifyCallResult(\n            success,\n            returnData,\n            \"LSP6: failed executing payload\"\n        );\n\n        return result.length != 0 ? abi.decode(result, (bytes)) : result;\n    }\n\n    /**\n     * @notice verify the nonce `_idx` for `_from` (obtained via `getNonce(...)`)\n     * @dev \"idx\" is a 256bits (unsigned) integer, where:\n     *          - the 128 leftmost bits = channelId\n     *      and - the 128 rightmost bits = nonce within the channel\n     * @param from caller address\n     * @param idx (channel id + nonce within the channel)\n     */\n    function _isValidNonce(\n        address from,\n        uint256 idx\n    ) internal view virtual returns (bool) {\n        uint256 mask = ~uint128(0);\n        // Alternatively:\n        // uint256 mask = (1<<128)-1;\n        // uint256 mask = 0xffffffffffffffffffffffffffffffff;\n        return (idx & mask) == (_nonceStore[from][idx >> 128]);"
    }
  ]
}