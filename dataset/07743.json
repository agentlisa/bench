{
  "Title": "[G-06]  Functions guaranteed to revert when called by normal users can be marked `payable`",
  "Content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost.\n\n*There are 13 instances of this issue:*\n```solidity\nFile: contracts/LooksRareAggregator.sol\n\n120:      function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n\n132:      function addFunction(address proxy, bytes4 selector) external onlyOwner {\n\n143:      function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n\n153       function setFee(\n154           address proxy,\n155           uint256 bp,\n156           address recipient\n157:      ) external onlyOwner {\n\n173       function approve(\n174           address marketplace,\n175           address currency,\n176           uint256 amount\n177:      ) external onlyOwner {\n\n197       function rescueERC721(\n198           address collection,\n199           address to,\n200           uint256 tokenId\n201:      ) external onlyOwner {\n\n213       function rescueERC1155(\n214           address collection,\n215           address to,\n216           uint256[] calldata tokenIds,\n217           uint256[] calldata amounts\n218:      ) external onlyOwner {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/LooksRareAggregator.sol#L120\n\n```solidity\nFile: contracts/OwnableTwoSteps.sol\n\n51:       function cancelOwnershipTransfer() external onlyOwner {\n\n68:       function confirmOwnershipRenouncement() external onlyOwner {\n\n98:       function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\n\n110:      function initiateOwnershipRenouncement() external onlyOwner {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/OwnableTwoSteps.sol#L51\n\n```solidity\nFile: contracts/TokenRescuer.sol\n\n22:       function rescueETH(address to) external onlyOwner {\n\n34:       function rescueERC20(address currency, address to) external onlyOwner {\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/TokenRescuer.sol#L22\n\n\n___\n\n## Excluded Gas Optimization Findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness.\n\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;07] | `<array>.length` should not be looked up in every loop of a `for`-loop | 2 | 6 |\n| [G&#x2011;08] | Using `bool`s for storage incurs overhead | 1 | 17100 |\n\nTotal: 3 instances over 2 issues with **17106 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/LooksRareAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"./lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC721Transfer} from \"./lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"./lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {BasicOrder, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {BasicOrder, FeeData, TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {LooksRareProxy} from \"./proxies/LooksRareProxy.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {TokenRescuer} from \"./TokenRescuer.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from different marketplaces\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenRescuer,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to this contract\n     *         directly. Transactions that involve ERC20 orders should be submitted to the contract\n     *         ERC20EnabledLooksRareAggregator and it will call this contract's execution function.\n     *         The purpose is to prevent a malicious proxy from stealing users' ERC20 tokens if\n     *         this contract's ownership is compromised. By not providing any allowances to this\n     *         aggregator, even if a malicious proxy is added, it cannot call\n     *         token.transferFrom(victim, attacker, amount) inside the proxy within the context of the\n     *         aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => bool)) private _proxyFunctionSelectors;\n    mapping(address => FeeData) private _proxyFeeData;\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) revert ZeroAddress();\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) revert InvalidOrderLength();\n\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        if (tokenTransfersLength == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            if (!_proxyFunctionSelectors[singleTradeData.proxy][singleTradeData.selector]) revert InvalidFunction();\n\n            (bytes memory proxyCalldata, bool maxFeeBpViolated) = _encodeCalldataAndValidateFeeBp(\n                singleTradeData,\n                recipient,\n                isAtomic\n            );\n            if (maxFeeBpViolated) {\n                if (isAtomic) {\n                    revert FeeTooHigh();\n                } else {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n            (bool success, bytes memory returnData) = singleTradeData.proxy.delegatecall(proxyCalldata);\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length > 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfersLength > 0) _returnERC20TokensIfAny(tokenTransfers, originator);\n        _returnETHIfAny(originator);\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) revert AlreadySet();\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n        emit ERC20EnabledLooksRareAggregatorSet();\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = true;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @param proxy Proxy to apply the fee to\n     * @param bp Fee basis point\n     * @param recipient Fee recipient\n     */\n    function setFee(\n        address proxy,\n        uint256 bp,\n        address recipient\n    ) external onlyOwner {\n        if (bp > 10000) revert FeeTooHigh();\n        _proxyFeeData[proxy].bp = bp;\n        _proxyFeeData[proxy].recipient = recipient;\n\n        emit FeeUpdated(proxy, bp, recipient);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param marketplace The marketplace address to approve\n     * @param currency The ERC20 token address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address marketplace,\n        address currency,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool) {\n        return _proxyFunctionSelectors[proxy][selector];\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    receive() external payable {}\n\n    function _encodeCalldataAndValidateFeeBp(\n        TradeData calldata singleTradeData,\n        address recipient,\n        bool isAtomic\n    ) private view returns (bytes memory proxyCalldata, bool maxFeeBpViolated) {\n        FeeData memory feeData = _proxyFeeData[singleTradeData.proxy];\n        maxFeeBpViolated = singleTradeData.maxFeeBp < feeData.bp;\n        proxyCalldata = abi.encodeWithSelector(\n            singleTradeData.selector,\n            singleTradeData.orders,\n            singleTradeData.ordersExtraData,\n            singleTradeData.extraData,\n            recipient,\n            isAtomic,\n            feeData.bp,\n            feeData.recipient\n        );\n    }\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));\n            if (balance > 0) _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/OwnableTwoSteps.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport {IOwnableTwoSteps} from \"./interfaces/IOwnableTwoSteps.sol\";\n\n/**\n * @title OwnableTwoSteps\n * @notice This contract offers transfer of ownership in two steps with potential owner having to confirm the transaction.\n *         Renouncement of the ownership is also a two-step process with a timelock since the next potential owner is address(0).\n */\nabstract contract OwnableTwoSteps is IOwnableTwoSteps {\n    // Address of the current owner\n    address public owner;\n\n    // Address of the potential owner\n    address public potentialOwner;\n\n    // Delay for the timelock (in seconds)\n    uint256 public delay;\n\n    // Earliest ownership renouncement timestamp\n    uint256 public earliestOwnershipRenouncementTime;\n\n    // Ownership status\n    Status public ownershipStatus;\n\n    /**\n     * @notice Modifier to wrap functions for contracts that inherit this contract\n     */\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     *         Initial owner is the deployment address.\n     *         Delay (for the timelock) must be set by the contract that inherits from this.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Cancel transfer of ownership\n     * @dev This function can be used for both cancelling a transfer to a new owner and\n     *      cancelling the renouncement of the ownership.\n     */\n    function cancelOwnershipTransfer() external onlyOwner {\n        if (ownershipStatus == Status.NoOngoingTransfer) revert NoOngoingTransferInProgress();\n\n        if (ownershipStatus == Status.TransferInProgress) {\n            delete potentialOwner;\n        } else if (ownershipStatus == Status.RenouncementInProgress) {\n            delete earliestOwnershipRenouncementTime;\n        }\n\n        delete ownershipStatus;\n\n        emit CancelOwnershipTransfer();\n    }\n\n    /**\n     * @notice Confirm ownership renouncement\n     */\n    function confirmOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.RenouncementInProgress) revert RenouncementNotInProgress();\n        if (block.timestamp < earliestOwnershipRenouncementTime) revert RenouncementTooEarly();\n\n        delete earliestOwnershipRenouncementTime;\n        delete owner;\n        delete ownershipStatus;\n\n        emit NewOwner(address(0));\n    }\n\n    /**\n     * @notice Confirm ownership transfer\n     * @dev This function can only be called by the current potential owner.\n     */\n    function confirmOwnershipTransfer() external {\n        if (ownershipStatus != Status.TransferInProgress) revert TransferNotInProgress();\n        if (msg.sender != potentialOwner) revert WrongPotentialOwner();\n\n        owner = msg.sender;\n        delete ownershipStatus;\n        delete potentialOwner;\n\n        emit NewOwner(owner);\n    }\n\n    /**\n     * @notice Initiate transfer of ownership to a new owner\n     * @param newPotentialOwner New potential owner address\n     */\n    function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) revert TransferAlreadyInProgress();\n\n        ownershipStatus = Status.TransferInProgress;\n        potentialOwner = newPotentialOwner;\n\n        emit InitiateOwnershipTransfer(owner, newPotentialOwner);\n    }\n\n    /**\n     * @notice Initiate ownership renouncement\n     */\n    function initiateOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) revert TransferAlreadyInProgress();\n\n        ownershipStatus = Status.RenouncementInProgress;\n        earliestOwnershipRenouncementTime = block.timestamp + delay;\n\n        emit InitiateOwnershipRenouncement(earliestOwnershipRenouncementTime);\n    }\n\n    /**\n     * @notice Set up the timelock delay for renouncing ownership\n     * @param _delay Timelock delay for the owner to confirm renouncing the ownership\n     * @dev This function is expected to be included in the constructor of the contract that inherits this contract.\n     *      If it is not set, there is no timelock to renounce the ownership.\n     */\n    function _setupDelayForRenouncingOwnership(uint256 _delay) internal {\n        delay = _delay;\n    }\n}"
    },
    {
      "filename": "contracts/TokenRescuer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {OwnableTwoSteps} from \"./OwnableTwoSteps.sol\";\nimport {LowLevelERC20Transfer} from \"./lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelETH} from \"./lowLevelCallers/LowLevelETH.sol\";\n\n/**\n * @title TokenRescuer\n * @notice This contract contains functions to move tokens\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract TokenRescuer is OwnableTwoSteps, LowLevelETH, LowLevelERC20Transfer {\n    error InsufficientAmount();\n\n    /**\n     * @notice Rescue the contract's trapped ETH\n     * @dev Must be called by the current owner\n     * @param to Send the contract's ETH balance to this address\n     */\n    function rescueETH(address to) external onlyOwner {\n        uint256 withdrawAmount = address(this).balance - 1;\n        if (withdrawAmount == 0) revert InsufficientAmount();\n        _transferETH(to, withdrawAmount);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC20 tokens\n     * @dev Must be called by the current owner\n     * @param currency The address of the ERC20 token to rescue from the contract\n     * @param to Send the contract's specified ERC20 token balance to this address\n     */\n    function rescueERC20(address currency, address to) external onlyOwner {\n        uint256 withdrawAmount = IERC20(currency).balanceOf(address(this)) - 1;\n        if (withdrawAmount == 0) revert InsufficientAmount();\n        _executeERC20DirectTransfer(currency, to, withdrawAmount);\n    }\n}"
    }
  ]
}