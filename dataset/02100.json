{
  "Title": "M-15: Malicious order keepers can trigger the cancellation of any order, with old blocks",
  "Content": "# Issue M-15: Malicious order keepers can trigger the cancellation of any order, with old blocks \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/163 \n\n## Found by \nIllIllI\n\n## Summary\n\nMalicious order keepers can trigger the cancellation of any order by providing oracle prices from blocks unrelated to the order\n\n\n## Vulnerability Detail\n\nEach order [has](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L29-L36) [its](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/IncreaseOrderUtils.sol#L60-L66) [own](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol#L109-L113) [requirements](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L189-L193) [about](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/SwapOrderUtils.sol#L24-L29) what block ranges it expects. The error handler for each order only allows orders to be retried if the keeper provided empty/invalid prices. The error handlers make no such allowances for invalid blocks.\n\nThe order keepers are supposed to be a decentralized network, so it's likely that at some point there will be a bad actor, or one who uses the rules to their advantage, at the expense of other users.\n\n\n## Impact\n\nOrders will be canceled rather than retried by keepers that would have executed the order properly. This may lead to position liquidations.\n\n\n## Code Snippet\n\nThese are three revert errors that are not caught by the [various](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/OrderHandler.sol#L227) [error](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/WithdrawalHandler.sol#L187) [handlers](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/DepositHandler.sol#L190):\n```solidity\n    function revertOracleBlockNumbersAreNotEqual(uint256[] memory oracleBlockNumbers, uint256 expectedBlockNumber) internal pure {\n        revert OracleBlockNumbersAreNotEqual(oracleBlockNumbers, expectedBlockNumber);\n    }\n\n\n    function revertOracleBlockNumbersAreSmallerThanRequired(uint256[] memory oracleBlockNumbers, uint256 expectedBlockNumber) internal pure {\n        revert OracleBlockNumbersAreSmallerThanRequired(oracleBlockNumbers, expectedBlockNumber);\n    }\n\n\n    function revertOracleBlockNumberNotWithinRange(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        uint256 blockNumber\n    ) internal pure {\n        revert OracleBlockNumberNotWithinRange(minOracleBlockNumbers, maxOracleBlockNumbers, blockNumber);\n    }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/oracle/OracleUtils.sol#L276-L290\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nAdd checks for these errors, and make the functions result in a revert rather than a cancellation\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/4a5981a1f006468cd78dd974110d0a8be23b5fc9#diff-d1cd88df390b68e193ecd449d918fbfccb8c24f39cbb3f4c32a659e932122d8fR291\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validateEnabledMarket(params.contracts.dataStore, params.market);\n        MarketUtils.validatePositionMarket(params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        if (order.swapPath().length == 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n        } else {\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(order.market())),\n                    result.outputToken,\n                    result.outputAmount,\n                    params.swapPathMarkets,\n                    order.minOutputAmount(),\n                    order.receiver(),\n                    order.shouldUnwrapNativeToken()\n                )\n            ) returns (address /* tokenOut */, uint256 /* swapOutputAmount */) {\n            } catch Error(string memory reason) {\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    \"\"\n                );\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    reasonBytes\n                );\n            }\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    function _handleSwapError(\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/OrderHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title OrderHandler\n// @dev Contract to handle creation, execution and cancellation of orders\ncontract OrderHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error OrderNotUpdatable(Order.OrderType orderType);\n    error InvalidKeeperForFrozenOrder(address keeper);\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev creates an order in the order store\n    // @param account the order's account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        address account,\n        BaseOrderUtils.CreateOrderParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createOrderFeatureDisabledKey(address(this), uint256(params.orderType)));\n\n        return OrderUtils.createOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            referralStorage,\n            account,\n            params\n        );\n    }\n\n    /**\n     * @dev Updates the given order with the specified size delta, acceptable price, and trigger price.\n     * The `updateOrder()` feature must be enabled for the given order type. The caller must be the owner\n     * of the order, and the order must not be a market order. The size delta, trigger price, and\n     * acceptable price are updated on the order, and the order is unfrozen. Any additional WNT that is\n     * transferred to the contract is added to the order's execution fee. The updated order is then saved\n     * in the order store, and an `OrderUpdated` event is emitted.\n     *\n     * @param key The unique ID of the order to be updated\n     * @param sizeDeltaUsd The new size delta for the order\n     * @param acceptablePrice The new acceptable price for the order\n     * @param triggerPrice The new trigger price for the order\n     */\n    function updateOrder(\n        bytes32 key,\n        uint256 sizeDeltaUsd,\n        uint256 acceptablePrice,\n        uint256 triggerPrice,\n        uint256 minOutputAmount,\n        Order.Props memory order\n    ) external payable globalNonReentrant onlyController {\n        FeatureUtils.validateFeature(dataStore, Keys.updateOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            revert OrderNotUpdatable(order.orderType());\n        }\n\n        order.setSizeDeltaUsd(sizeDeltaUsd);\n        order.setTriggerPrice(triggerPrice);\n        order.setAcceptablePrice(acceptablePrice);\n        order.setMinOutputAmount(minOutputAmount);\n        order.setIsFrozen(false);\n\n        // allow topping up of executionFee as partially filled or frozen orders\n        // will have their executionFee reduced\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 receivedWnt = orderVault.recordTransferIn(wnt);\n        order.setExecutionFee(order.executionFee() + receivedWnt);\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderUpdated(eventEmitter, key, sizeDeltaUsd, triggerPrice, acceptablePrice);\n    }\n\n    /**\n     * @dev Cancels the given order. The `cancelOrder()` feature must be enabled for the given order\n     * type. The caller must be the owner of the order, and the order must not be a market order. The\n     * order is cancelled by calling the `cancelOrder()` function in the `OrderUtils` contract. This\n     * function also records the starting gas amount and the reason for cancellation, which is passed to\n     * the `cancelOrder()` function.\n     *\n     * @param key The unique ID of the order to be cancelled\n     */\n    function cancelOrder(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Order.Props memory order = OrderStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            ExchangeUtils.validateRequestCancellation(\n                _dataStore,\n                order.updatedAtBlock(),\n                \"Order\"\n            );\n        }\n\n        OrderUtils.cancelOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            key,\n            order.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev simulate execution of an order to check for any errors\n    // @param key the order key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteOrder(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n        uint256 startingGas = gasleft();\n\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleOrderError(key, startingGas, reasonBytes);\n        }\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the order\n    // @param startingGas the starting gas\n    function _executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(key, oracleParams, keeper, startingGas);\n        // limit swaps require frozen order keeper for execution since on creation it can fail due to output amount\n        // which would automatically cause the order to be frozen\n        // limit increase and limit / trigger decrease orders may fail due to output amount as well and become frozen\n        // but only if their acceptablePrice is reached\n        if (params.order.isFrozen() || params.order.orderType() == Order.OrderType.LimitSwap) {\n            _validateFrozenOrderKeeper(keeper);\n        }\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeOrderFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n    }\n\n    // @dev handle a caught order error\n    // @param key the order's key\n    // @param startingGas the starting gas\n    // @param reason the error reason\n    // @param reasonKey the hash or the error reason\n    function _handleOrderError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (\n            OracleUtils.isEmptyPriceError(errorSelector) ||\n            errorSelector == InvalidKeeperForFrozenOrder.selector\n        ) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        bool isMarketOrder = BaseOrderUtils.isMarketOrder(order.orderType());\n\n        if (isMarketOrder) {\n            OrderUtils.cancelOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        } else {\n            if (\n                errorSelector == FeatureUtils.DisabledFeature.selector ||\n                errorSelector == PositionUtils.EmptyPosition.selector ||\n                errorSelector == BaseOrderUtils.InvalidOrderPrices.selector\n            ) {\n                ErrorUtils.revertWithCustomError(reasonBytes);\n            }\n\n            // freeze unfulfillable orders to prevent the order system from being gamed\n            // an example of gaming would be if a user creates a limit order\n            // with size greater than the available amount in the pool\n            // the user waits for their limit price to be hit, and if price\n            // moves in their favour after, they can deposit into the pool\n            // to allow the order to be executed then close the order for a profit\n            //\n            // frozen order keepers will have additional validations before executing\n            // frozen orders to prevent gaming\n            //\n            // alternatively, the user can call updateOrder to unfreeze the order\n            OrderUtils.freezeOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev validate that the keeper is a frozen order keeper\n    // @param keeper address of the keeper\n    function _validateFrozenOrderKeeper(address keeper) internal view {\n        if (!roleStore.hasRole(keeper, Role.FROZEN_ORDER_KEEPER)) {\n            revert InvalidKeeperForFrozenOrder(keeper);\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/oracle/OracleUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/Bits.sol\";\nimport \"../price/Price.sol\";\n\n// @title OracleUtils\n// @dev Library for oracle functions\nlibrary OracleUtils {\n    using Array for uint256[];\n\n    // @dev SetPricesParams struct for values required in Oracle.setPrices\n    // @param signerInfo compacted indexes of signers, the index is used to retrieve\n    // the signer address from the OracleStore\n    // @param tokens list of tokens to set prices for\n    // @param compactedOracleBlockNumbers compacted oracle block numbers\n    // @param compactedOracleTimestamps compacted oracle timestamps\n    // @param compactedDecimals compacted decimals for prices\n    // @param compactedMinPrices compacted min prices\n    // @param compactedMinPricesIndexes compacted min price indexes\n    // @param compactedMaxPrices compacted max prices\n    // @param compactedMaxPricesIndexes compacted max price indexes\n    // @param signatures signatures of the oracle signers\n    // @param priceFeedTokens tokens to set prices for based on an external price feed value\n    struct SetPricesParams {\n        uint256 signerInfo;\n        address[] tokens;\n        uint256[] compactedMinOracleBlockNumbers;\n        uint256[] compactedMaxOracleBlockNumbers;\n        uint256[] compactedOracleTimestamps;\n        uint256[] compactedDecimals;\n        uint256[] compactedMinPrices;\n        uint256[] compactedMinPricesIndexes;\n        uint256[] compactedMaxPrices;\n        uint256[] compactedMaxPricesIndexes;\n        bytes[] signatures;\n        address[] priceFeedTokens;\n    }\n\n    struct SimulatePricesParams {\n        address[] primaryTokens;\n        Price.Props[] primaryPrices;\n        address[] secondaryTokens;\n        Price.Props[] secondaryPrices;\n    }\n\n    struct ReportInfo {\n        uint256 minOracleBlockNumber;\n        uint256 maxOracleBlockNumber;\n        uint256 oracleTimestamp;\n        bytes32 blockHash;\n        address token;\n        bytes32 tokenOracleType;\n        uint256 precision;\n        uint256 minPrice;\n        uint256 maxPrice;\n    }\n\n    // compacted prices have a length of 32 bits\n    uint256 public constant COMPACTED_PRICE_BIT_LENGTH = 32;\n    uint256 public constant COMPACTED_PRICE_BITMASK = Bits.BITMASK_32;\n\n    // compacted precisions have a length of 8 bits\n    uint256 public constant COMPACTED_PRECISION_BIT_LENGTH = 8;\n    uint256 public constant COMPACTED_PRECISION_BITMASK = Bits.BITMASK_8;\n\n    // compacted block numbers have a length of 64 bits\n    uint256 public constant COMPACTED_BLOCK_NUMBER_BIT_LENGTH = 64;\n    uint256 public constant COMPACTED_BLOCK_NUMBER_BITMASK = Bits.BITMASK_64;\n\n    // compacted timestamps have a length of 64 bits\n    uint256 public constant COMPACTED_TIMESTAMP_BIT_LENGTH = 64;\n    uint256 public constant COMPACTED_TIMESTAMP_BITMASK = Bits.BITMASK_64;\n\n    // compacted price indexes have a length of 8 bits\n    uint256 public constant COMPACTED_PRICE_INDEX_BIT_LENGTH = 8;\n    uint256 public constant COMPACTED_PRICE_INDEX_BITMASK = Bits.BITMASK_8;\n\n    error EmptyPrimaryPrice(address token);\n    error EmptySecondaryPrice(address token);\n    error EmptyLatestPrice(address token);\n    error EmptyCustomPrice(address token);\n\n    error EmptyCompactedPrice(uint256 index);\n    error EmptyCompactedBlockNumber(uint256 index);\n    error EmptyCompactedTimestamp(uint256 index);\n\n    error OracleBlockNumbersAreNotEqual(uint256[] oracleBlockNumbers, uint256 expectedBlockNumber);\n    error OracleBlockNumbersAreSmallerThanRequired(uint256[] oracleBlockNumbers, uint256 expectedBlockNumber);\n    error OracleBlockNumberNotWithinRange(\n        uint256[] minOracleBlockNumbers,\n        uint256[] maxOracleBlockNumbers,\n        uint256 blockNumber\n    );\n\n    error InvalidSignature(address recoveredSigner, address expectedSigner);\n\n    function validateBlockNumberWithinRange(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        uint256 blockNumber\n    ) internal pure {\n        if (!isBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                blockNumber\n        )) {\n            revertOracleBlockNumberNotWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                blockNumber\n            );\n        }\n    }\n\n    function isBlockNumberWithinRange(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        uint256 blockNumber\n    ) internal pure returns (bool) {\n        if (!minOracleBlockNumbers.areLessThanOrEqualTo(blockNumber)) {\n            return false;\n        }\n\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(blockNumber)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // @dev get the uncompacted price at the specified index\n    // @param compactedPrices the compacted prices\n    // @param index the index to get the uncompacted price at\n    // @return the uncompacted price at the specified index\n    function getUncompactedPrice(uint256[] memory compactedPrices, uint256 index) internal pure returns (uint256) {\n        uint256 price = Array.getUncompactedValue(\n            compactedPrices,\n            index,\n            COMPACTED_PRICE_BIT_LENGTH,\n            COMPACTED_PRICE_BITMASK,\n            \"getUncompactedPrice\"\n        );\n\n        if (price == 0) { revert EmptyCompactedPrice(index); }\n\n        return price;\n    }\n\n    // @dev get the uncompacted decimal at the specified index\n    // @param compactedDecimals the compacted decimals\n    // @param index the index to get the uncompacted decimal at\n    // @return the uncompacted decimal at the specified index\n    function getUncompactedDecimal(uint256[] memory compactedDecimals, uint256 index) internal pure returns (uint256) {\n        uint256 decimal = Array.getUncompactedValue(\n            compactedDecimals,\n            index,\n            COMPACTED_PRECISION_BIT_LENGTH,\n            COMPACTED_PRECISION_BITMASK,\n            \"getUncompactedDecimal\"\n        );\n\n        return decimal;\n    }\n\n\n    // @dev get the uncompacted price index at the specified index\n    // @param compactedPriceIndexes the compacted indexes\n    // @param index the index to get the uncompacted price index at\n    // @return the uncompacted price index at the specified index\n    function getUncompactedPriceIndex(uint256[] memory compactedPriceIndexes, uint256 index) internal pure returns (uint256) {\n        uint256 priceIndex = Array.getUncompactedValue(\n            compactedPriceIndexes,\n            index,\n            COMPACTED_PRICE_INDEX_BIT_LENGTH,\n            COMPACTED_PRICE_INDEX_BITMASK,\n            \"getUncompactedPriceIndex\"\n        );\n\n        return priceIndex;\n\n    }\n\n    // @dev get the uncompacted oracle block numbers\n    // @param compactedOracleBlockNumbers the compacted oracle block numbers\n    // @param length the length of the uncompacted oracle block numbers\n    // @return the uncompacted oracle block numbers\n    function getUncompactedOracleBlockNumbers(uint256[] memory compactedOracleBlockNumbers, uint256 length) internal pure returns (uint256[] memory) {\n        uint256[] memory blockNumbers = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            blockNumbers[i] = getUncompactedOracleBlockNumber(compactedOracleBlockNumbers, i);\n        }\n\n        return blockNumbers;\n    }\n\n    // @dev get the uncompacted oracle block number\n    // @param compactedOracleBlockNumbers the compacted oracle block numbers\n    // @param index the index to get the uncompacted oracle block number at\n    // @return the uncompacted oracle block number\n    function getUncompactedOracleBlockNumber(uint256[] memory compactedOracleBlockNumbers, uint256 index) internal pure returns (uint256) {\n        uint256 blockNumber = Array.getUncompactedValue(\n            compactedOracleBlockNumbers,\n            index,\n            COMPACTED_BLOCK_NUMBER_BIT_LENGTH,\n            COMPACTED_BLOCK_NUMBER_BITMASK,\n            \"getUncompactedOracleBlockNumber\"\n        );\n\n        if (blockNumber == 0) { revert EmptyCompactedBlockNumber(index); }\n\n        return blockNumber;\n    }\n\n    // @dev get the uncompacted oracle timestamp\n    // @param compactedOracleTimestamps the compacted oracle timestamps\n    // @param index the index to get the uncompacted oracle timestamp at\n    // @return the uncompacted oracle timestamp\n    function getUncompactedOracleTimestamp(uint256[] memory compactedOracleTimestamps, uint256 index) internal pure returns (uint256) {\n        uint256 blockNumber = Array.getUncompactedValue(\n            compactedOracleTimestamps,\n            index,\n            COMPACTED_TIMESTAMP_BIT_LENGTH,\n            COMPACTED_TIMESTAMP_BITMASK,\n            \"getUncompactedOracleTimestamp\"\n        );\n\n        if (blockNumber == 0) { revert EmptyCompactedTimestamp(index); }\n\n        return blockNumber;\n    }\n\n    // @dev validate the signer of a price\n    // @param minOracleBlockNumber the min block number used for the signed message hash\n    // @param maxOracleBlockNumber the max block number used for the signed message hash\n    // @param oracleTimestamp the timestamp used for the signed message hash\n    // @param blockHash the block hash used for the signed message hash\n    // @param token the token used for the signed message hash\n    // @param precision the precision used for the signed message hash\n    // @param minPrice the min price used for the signed message hash\n    // @param maxPrice the max price used for the signed message hash\n    // @param signature the signer's signature\n    // @param expectedSigner the address of the expected signer\n    function validateSigner(\n        bytes32 SALT,\n        ReportInfo memory info,\n        bytes memory signature,\n        address expectedSigner\n    ) internal pure {\n        bytes32 digest = ECDSA.toEthSignedMessageHash(\n            keccak256(abi.encode(\n                SALT,\n                info.minOracleBlockNumber,\n                info.maxOracleBlockNumber,\n                info.oracleTimestamp,\n                info.blockHash,\n                info.token,\n                info.tokenOracleType,\n                info.precision,\n                info.minPrice,\n                info.maxPrice\n            ))\n        );\n\n        address recoveredSigner = ECDSA.recover(digest, signature);\n        if (recoveredSigner != expectedSigner) {\n            revert InvalidSignature(recoveredSigner, expectedSigner);\n        }\n    }\n\n    function revertOracleBlockNumbersAreNotEqual(uint256[] memory oracleBlockNumbers, uint256 expectedBlockNumber) internal pure {\n        revert OracleBlockNumbersAreNotEqual(oracleBlockNumbers, expectedBlockNumber);\n    }\n\n    function revertOracleBlockNumbersAreSmallerThanRequired(uint256[] memory oracleBlockNumbers, uint256 expectedBlockNumber) internal pure {\n        revert OracleBlockNumbersAreSmallerThanRequired(oracleBlockNumbers, expectedBlockNumber);\n    }\n\n    function revertOracleBlockNumberNotWithinRange(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        uint256 blockNumber\n    ) internal pure {\n        revert OracleBlockNumberNotWithinRange(minOracleBlockNumbers, maxOracleBlockNumbers, blockNumber);\n    }\n\n    function isEmptyPriceError(bytes4 errorSelector) internal pure returns (bool) {\n        if (errorSelector == EmptyPrimaryPrice.selector) {\n            return true;\n        }\n\n        if (errorSelector == EmptySecondaryPrice.selector) {\n            return true;\n        }\n\n        if (errorSelector == EmptyLatestPrice.selector) {\n            return true;\n        }\n\n        if (errorSelector == EmptyCustomPrice.selector) {\n            return true;\n        }\n\n        return false;\n    }\n}"
    }
  ]
}