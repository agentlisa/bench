{
  "Title": "M-5: If referral or liquidator is the same address as the account, then liquidation/referral fees will be lost due to local storage being overwritten after the `claimable` amount is credited to liquidator or referral",
  "Content": "# Issue M-5: If referral or liquidator is the same address as the account, then liquidation/referral fees will be lost due to local storage being overwritten after the `claimable` amount is credited to liquidator or referral \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/16 \n\n## Found by \nbin2chen, panprog\n## Summary\n\nAny user (address) can be liquidator and/or referral, including account's own address (the user can self-liquidate or self-refer). During the market settlement, liquidator and referral fees are credited to liquidator/referral's `local.claimable` storage. The issue is that the account's local storage is held in the memory during the settlement process, and is saved into storage after settlement/update. This means that `local.claimable` storage changes for the account are not reflected in the in-memory cached copy and discarded when the cached copy is saved after settlement.\n\nThis leads to liquidator and referral fees being lost when these are the account's own address.\n\n## Vulnerability Detail\n\nDuring market account settlement process, in the `_processOrderLocal`, liquidator and referral fees are credited to corresponding accounts via:\n```solidity\n...\n    _credit(liquidators[account][newOrderId], accumulationResult.liquidationFee);\n    _credit(referrers[account][newOrderId], accumulationResult.subtractiveFee);\n...\nfunction _credit(address account, UFixed6 amount) private {\n    if (amount.isZero()) return;\n\n    Local memory newLocal = _locals[account].read();\n    newLocal.credit(amount);\n    _locals[account].store(newLocal);\n}\n```\n\nHowever, for the account the cached copy of `_locals[account]` is stored after the settlement in `_storeContext`:\n```solidity\nfunction _storeContext(Context memory context, address account) private {\n    // state\n    _global.store(context.global);\n    _locals[account].store(context.local);\n...\n```\n\nThe order of these actions is:\n```solidity\nfunction settle(address account) external nonReentrant whenNotPaused {\n    Context memory context = _loadContext(account);\n\n    _settle(context, account);\n\n    _storeContext(context, account);\n}\n```\n\n1. Load `_locals[account]` into memory (`context.local`)\n2. Settle: during settlement `_locals[account].claimable` is increased for liquidator and referral. Note: this is not reflected in `context.local`\n3. Store cached context: `_locals[account]` is overwritten with the `context.local`, losing `claimable` increased during settlement.\n\n## Impact\n\nIf user self-liquidates or self-refers, the liquidation and referral fees are lost by the user (and are stuck in the contract, because they're still subtracted from the user's collateral).\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, add this to test/unit/market/Market.test.ts:\n```ts\nit('self-liquidation fees lost', async () => {\nconst POSITION = parse6decimal('100.000')\nconst COLLATERAL = parse6decimal('120')\n\nfunction setupOracle(price: string, timestamp : number, nextTimestamp : number) {\n    const oracleVersion = {\n    price: parse6decimal(price),\n    timestamp: timestamp,\n    valid: true,\n    }\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion)\n    oracle.status.returns([oracleVersion, nextTimestamp])\n    oracle.request.returns()\n}\n\ndsu.transferFrom.whenCalledWith(user.address, market.address, COLLATERAL.mul(1e12)).returns(true)\ndsu.transferFrom.whenCalledWith(userB.address, market.address, COLLATERAL.mul(1e12)).returns(true)\n\nvar time = TIMESTAMP;\n\nsetupOracle('1', time, time + 100);\nawait market.connect(user)\n    ['update(address,uint256,uint256,uint256,int256,bool)'](user.address, POSITION, 0, 0, COLLATERAL, false);\n\ntime += 100;\nsetupOracle('1', time, time + 100);\nawait market.connect(userB)\n    ['update(address,uint256,uint256,uint256,int256,bool)'](userB.address, 0, POSITION, 0, COLLATERAL, false);\n\ntime += 100;\nsetupOracle('1', time, time + 100);\n\ntime += 100;\nsetupOracle('0.7', time, time + 100);\n\n// self-liquidate\nsetupOracle('0.7', time, time + 100);\nawait market.connect(userB)\n    ['update(address,uint256,uint256,uint256,int256,bool)'](userB.address, 0, 0, 0, 0, true);\n\n// settle liquidation\ntime += 100;\nsetupOracle('0.7', time, time + 100);\nawait market.settle(userB.address);\nvar info = await market.locals(userB.address);\nconsole.log(\"Claimable userB: \" + info.claimable);\n```\n\nConsole log:\n```solidity\nClaimable userB: 0\n```\n\n## Code Snippet\n\n`Market._credit` modifies `local.claimable` storage for the account:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L678-L684\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nModify `Market._credit` function to increase `context.local.claimable` if account to be credited matches account which is being updated.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  this seems valid valid medium; medium(2)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/302\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\nimport \"./libs/InvariantLib.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    Fixed6 private constant MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL = Fixed6.wrap(type(int256).min);\n    UFixed6 private constant MAGIC_VALUE_UNCHANGED_POSITION = UFixed6.wrap(type(uint256).max);\n    UFixed6 private constant MAGIC_VALUE_FULLY_CLOSED_POSITION = UFixed6.wrap(type(uint256).max - 1);\n\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev DEPRECATED SLOT -- previously the reward token\n    bytes32 private __unused0__;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev DEPRECATED SLOT -- previously the payoff provider\n    bytes32 private __unused1__;\n\n    /// @dev Beneficiary of the market, receives donations\n    address private beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address private coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev DEPRECATED SLOT -- previously the global pending positions\n    bytes32 private __unused2__;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev DEPRECATED SLOT -- previously the local pending positions\n    bytes32 private __unused3__;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @dev The global pending order for each id\n    mapping(uint256 => OrderStorageGlobal) private _pendingOrder;\n\n    /// @dev The local pending order for each id for each account\n    mapping(address => mapping(uint256 => OrderStorageLocal)) private _pendingOrders;\n\n    /// @dev The global aggregate pending order\n    OrderStorageGlobal private _pending;\n\n    /// @dev The local aggregate pending order for each account\n    mapping(address => OrderStorageLocal) private _pendings;\n\n    /// @dev The local checkpoint for each id for each account\n    mapping(address => mapping(uint256 => CheckpointStorage)) private _checkpoints;\n\n    /// @dev The liquidator for each id for each account\n    mapping(address => mapping(uint256 => address)) public liquidators;\n\n    /// @dev The referrer for each id for each account\n    mapping(address => mapping(uint256 => address)) public referrers;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __ReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n    }\n\n    /// @notice Settles the account's position and collateral\n    /// @param account The account to operate on\n    function settle(address account) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n\n        _storeContext(context, account);\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external {\n        update(account, newMaker, newLong, newShort, collateral, protect, address(0));\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    /// @param referrer The referrer of the order\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect,\n        address referrer\n    ) public nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect, referrer);\n\n        _storeContext(context, account);\n    }\n\n    /// @notice Updates the oracle of the market\n    /// @dev For the v2.1.1 -> v2.2 migration process, not to be used otherwise\n    /// @param newOracle The new oracle address\n    function updateOracle(IOracleProvider newOracle) external onlyOwner {\n        oracle = newOracle;\n        emit OracleUpdated(newOracle);\n    }\n\n    /// @notice Updates the beneficiary, coordinator, and parameter set of the market\n    /// @param newBeneficiary The new beneficiary address\n    /// @param newCoordinator The new coordinator address\n    /// @param newParameter The new parameter set\n    function updateParameter(\n        address newBeneficiary,\n        address newCoordinator,\n        MarketParameter memory newParameter\n    ) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter());\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n\n        // credit impact update fee to the protocol account\n        Global memory newGlobal = _global.read();\n        Position memory latestPosition = _position.read();\n        RiskParameter memory latestRiskParameter = _riskParameter.read();\n        OracleVersion memory latestVersion = oracle.at(latestPosition.timestamp);\n\n        Fixed6 updateFee = latestRiskParameter.makerFee\n            .update(newRiskParameter.makerFee, latestPosition.maker, latestVersion.price.abs())\n            .add(latestRiskParameter.takerFee\n                .update(newRiskParameter.takerFee, latestPosition.skew(), latestVersion.price.abs()));\n\n        newGlobal.exposure = newGlobal.exposure.sub(updateFee);\n        _global.store(newGlobal);\n\n        // update\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, donation, and claimable\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n        Local memory newLocal = _locals[msg.sender].read();\n\n        if (_claimFee(factory().owner(), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donation)) newGlobal.donation = UFixed6Lib.ZERO;\n        if (_claimFee(msg.sender, newLocal.claimable)) newLocal.claimable = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n        _locals[msg.sender].store(newLocal);\n    }\n\n    /// @notice Settles any exposure that has accrued to the market\n    /// @dev Resets exposure to zero, caller pays or receives to net out the exposure\n    function claimExposure() external onlyOwner {\n        Global memory newGlobal = _global.read();\n\n        if (newGlobal.exposure.sign() == 1) token.push(msg.sender, UFixed18Lib.from(newGlobal.exposure.abs()));\n        if (newGlobal.exposure.sign() == -1) token.pull(msg.sender, UFixed18Lib.from(newGlobal.exposure.abs()));\n\n        emit ExposureClaimed(msg.sender, newGlobal.exposure);\n\n        newGlobal.exposure = Fixed6Lib.ZERO;\n        _global.store(newGlobal);\n    }\n\n    /// @notice Helper function to handle a singular fee claim.\n    /// @param receiver The address to receive the fee\n    /// @param fee The amount of the fee to claim\n    function _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n        if (msg.sender != receiver || fee.isZero()) return false;\n\n        token.push(receiver, UFixed18Lib.from(fee));\n        emit FeeClaimed(receiver, fee);\n        return true;\n    }\n\n    /// @notice Returns the payoff provider\n    /// @dev For backwards compatibility\n    function payoff() external pure returns (address) {\n        return address(0);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending order for the given id\n    /// @param id The id to query\n    function pendingOrder(uint256 id) external view returns (Order memory) {\n        return _pendingOrder[id].read();\n    }\n\n    /// @notice Returns the local pending order for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingOrders(address account, uint256 id) external view returns (Order memory) {\n        return _pendingOrders[account][id].read();\n    }\n\n    /// @notice Returns the aggregate global pending order\n    function pending() external view returns (Order memory) {\n        return _pending.read();\n    }\n\n    /// @notice Returns the aggregate local pending order for the given account\n    /// @param account The account to query\n    function pendings(address account) external view returns (Order memory) {\n        return _pendings[account].read();\n    }\n\n    /// @notice Returns the local checkpoint for the given account and version\n    /// @param account The account to query\n    /// @param version The version to query\n    function checkpoints(address account, uint256 version) external view returns (Checkpoint memory) {\n        return _checkpoints[account][version].read();\n    }\n\n    /// @notice Loads the transaction context\n    /// @param account The account to load for\n    /// @return context The transaction context\n    function _loadContext(address account) private view returns (Context memory context) {\n        // parameters\n        context.marketParameter = _parameter.read();\n        context.riskParameter = _riskParameter.read();\n        context.protocolParameter = IMarketFactory(address(factory())).parameter();\n\n        // oracle\n        (context.latestOracleVersion, context.currentTimestamp) = oracle.status();\n\n        // state\n        context.global = _global.read();\n        context.local = _locals[account].read();\n\n        // latest positions\n        context.latestPosition.global = _position.read();\n        context.latestPosition.local = _positions[account].read();\n\n        // aggregate pending orders\n        context.pending.global = _pending.read();\n        context.pending.local = _pendings[account].read();\n    }\n\n    /// @notice Stores the context for the transaction\n    /// @param context The context to store\n    /// @param account The account to store for\n    function _storeContext(Context memory context, address account) private {\n        // state\n        _global.store(context.global);\n        _locals[account].store(context.local);\n\n        // latest positions\n        _position.store(context.latestPosition.global);\n        _positions[account].store(context.latestPosition.local);\n\n        // aggregate pending orders\n        _pending.store(context.pending.global);\n        _pendings[account].store(context.pending.local);\n    }\n\n    /// @notice Loads the context for the update process\n    /// @param context The context to load to\n    /// @param account The account to load for\n    /// @param referrer The referrer to load for\n    /// @return updateContext The update context\n    function _loadUpdateContext(\n        Context memory context,\n        address account,\n        address referrer\n    ) private view returns (UpdateContext memory updateContext) {\n        // load current position\n        updateContext.currentPosition.global = context.latestPosition.global.clone();\n        updateContext.currentPosition.global.update(context.pending.global);\n        updateContext.currentPosition.local = context.latestPosition.local.clone();\n        updateContext.currentPosition.local.update(context.pending.local);\n\n        // load current order\n        updateContext.order.global = _pendingOrder[context.global.currentId].read();\n        updateContext.order.local = _pendingOrders[account][context.local.currentId].read();\n\n        // load external actors\n        updateContext.operator = IMarketFactory(address(factory())).operators(account, msg.sender);\n        updateContext.liquidator = liquidators[account][context.local.currentId];\n        updateContext.referrer = referrers[account][context.local.currentId];\n        updateContext.referralFee = IMarketFactory(address(factory())).referralFee(referrer);\n    }\n\n    /// @notice Stores the context for the update process\n    /// @param context The transaction context\n    /// @param updateContext The update context to store\n    /// @param account The account to store for\n    function _storeUpdateContext(Context memory context, UpdateContext memory updateContext, address account) private {\n        // current orders\n        _pendingOrder[context.global.currentId].store(updateContext.order.global);\n        _pendingOrders[account][context.local.currentId].store(updateContext.order.local);\n\n        // external actors\n        liquidators[account][context.local.currentId] = updateContext.liquidator;\n        referrers[account][context.local.currentId] = updateContext.referrer;\n    }\n\n    /// @notice Updates the current position\n    /// @param context The context to use\n    /// @param account The account to update\n    /// @param newMaker The new maker position size\n    /// @param newLong The new long position size\n    /// @param newShort The new short position size\n    /// @param collateral The change in collateral\n    /// @param protect Whether to protect the position for liquidation\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect,\n        address referrer\n    ) private notSettleOnly(context) {\n        // load\n        UpdateContext memory updateContext = _loadUpdateContext(context, account, referrer);\n\n        // magic values\n        collateral = _processCollateralMagicValue(context, collateral);\n        newMaker = _processPositionMagicValue(context, updateContext.currentPosition.local.maker, newMaker);\n        newLong = _processPositionMagicValue(context, updateContext.currentPosition.local.long, newLong);\n        newShort = _processPositionMagicValue(context, updateContext.currentPosition.local.short, newShort);\n\n        // referral fee\n        UFixed6 referralFee = _processReferralFee(context, updateContext, referrer);\n\n        // advance to next id if applicable\n        if (context.currentTimestamp > updateContext.order.local.timestamp) {\n            updateContext.order.local.next(context.currentTimestamp);\n            context.local.currentId++;\n        }\n        if (context.currentTimestamp > updateContext.order.global.timestamp) {\n            updateContext.order.global.next(context.currentTimestamp);\n            context.global.currentId++;\n        }\n\n        // update current position\n        Order memory newOrder = OrderLib.from(\n            context.currentTimestamp,\n            updateContext.currentPosition.local,\n            collateral,\n            newMaker,\n            newLong,\n            newShort,\n            protect,\n            referralFee\n        );\n        updateContext.currentPosition.global.update(newOrder);\n        updateContext.currentPosition.local.update(newOrder);\n\n        // apply new order\n        updateContext.order.local.add(newOrder);\n        updateContext.order.global.add(newOrder);\n        context.pending.global.add(newOrder);\n        context.pending.local.add(newOrder);\n\n        // update collateral\n        context.local.update(collateral);\n\n        // protect account\n        if (newOrder.protected()) updateContext.liquidator = msg.sender;\n\n        // apply referrer\n        _processReferrer(updateContext, newOrder, referrer);\n\n        // request version\n        if (!newOrder.isEmpty()) oracle.request(IMarket(this), account);\n\n        // after\n        InvariantLib.validate(context, updateContext, msg.sender, account, newOrder, collateral);\n\n        // store\n        _storeUpdateContext(context, updateContext, account);\n\n        // fund\n        if (collateral.sign() == 1) token.pull(msg.sender, UFixed18Lib.from(collateral.abs()));\n        if (collateral.sign() == -1) token.push(msg.sender, UFixed18Lib.from(collateral.abs()));\n\n        // events\n        emit Updated(msg.sender, account, context.currentTimestamp, newMaker, newLong, newShort, collateral, protect, referrer);\n        emit OrderCreated(account, newOrder);\n    }\n\n    /// @notice Processes the referral fee for the given order\n    /// @param context The context to use\n    /// @param updateContext The update context to use\n    /// @param referrer The referrer of the order\n    /// @return The referral fee to apply\n    function _processReferralFee(\n        Context memory context,\n        UpdateContext memory updateContext,\n        address referrer\n    ) private pure returns (UFixed6) {\n        if (referrer == address(0)) return UFixed6Lib.ZERO;\n        if (!updateContext.referralFee.isZero()) return updateContext.referralFee;\n        return context.protocolParameter.referralFee;\n    }\n\n    /// @notice Processes the referrer for the given order\n    /// @param updateContext The update context to use\n    /// @param newOrder The order to process\n    /// @param referrer The referrer of the order\n    function _processReferrer(\n        UpdateContext memory updateContext,\n        Order memory newOrder,\n        address referrer\n    ) private pure {\n        if (newOrder.makerReferral.isZero() && newOrder.takerReferral.isZero()) return;\n        if (updateContext.referrer == address(0)) updateContext.referrer = referrer;\n        if (updateContext.referrer == referrer) return;\n\n        revert MarketInvalidReferrerError();\n    }\n\n    /// @notice Loads the settlement context\n    /// @param context The transaction context\n    /// @param account The account to load for\n    /// @return settlementContext The settlement context\n    function _loadSettlementContext(\n        Context memory context,\n        address account\n    ) private view returns (SettlementContext memory settlementContext) {\n        // processing accumulators\n        settlementContext.latestVersion = _versions[context.latestPosition.global.timestamp].read();\n        settlementContext.latestCheckpoint = _checkpoints[account][context.latestPosition.local.timestamp].read();\n        settlementContext.orderOracleVersion = oracle.at(context.latestPosition.global.timestamp);\n\n        // v2.2 migration (if latest checkpoint is empty, initialize with latest local collateral)\n        if (\n            settlementContext.latestCheckpoint.tradeFee.isZero() &&\n            settlementContext.latestCheckpoint.settlementFee.isZero() &&\n            settlementContext.latestCheckpoint.transfer.isZero() &&\n            settlementContext.latestCheckpoint.collateral.isZero() &&\n            context.pending.local.collateral.isZero()\n        ) settlementContext.latestCheckpoint.collateral = context.local.collateral;\n    }\n\n    /// @notice Settles the account position up to the latest version\n    /// @param context The context to use\n    /// @param account The account to settle\n    function _settle(Context memory context, address account) private {\n        SettlementContext memory settlementContext = _loadSettlementContext(context, account);\n\n        Order memory nextOrder;\n\n        // settle\n        while (\n            context.global.currentId != context.global.latestId &&\n            (nextOrder = _pendingOrder[context.global.latestId + 1].read()).ready(context.latestOracleVersion)\n        ) _processOrderGlobal(context, settlementContext, context.global.latestId + 1, nextOrder);\n\n        while (\n            context.local.currentId != context.local.latestId &&\n            (nextOrder = _pendingOrders[account][context.local.latestId + 1].read()).ready(context.latestOracleVersion)\n        ) _processOrderLocal(context, settlementContext, account, context.local.latestId + 1, nextOrder);\n\n        // sync\n        if (context.latestOracleVersion.timestamp > context.latestPosition.global.timestamp) {\n            nextOrder = _pendingOrder[context.global.latestId].read();\n            nextOrder.next(context.latestOracleVersion.timestamp);\n            _processOrderGlobal(context, settlementContext, context.global.latestId, nextOrder);\n        }\n\n        if (context.latestOracleVersion.timestamp > context.latestPosition.local.timestamp) {\n            nextOrder = _pendingOrders[account][context.local.latestId].read();\n            nextOrder.next(context.latestOracleVersion.timestamp);\n            _processOrderLocal(context, settlementContext, account, context.local.latestId, nextOrder);\n        }\n    }\n\n    /// @notice Modifies the collateral input per magic values\n    /// @param context The context to use\n    /// @param collateral The collateral to process\n    /// @return The resulting collateral value\n    function _processCollateralMagicValue(Context memory context, Fixed6 collateral) private pure returns (Fixed6) {\n        return collateral.eq(MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL) ?\n            context.local.collateral.mul(Fixed6Lib.NEG_ONE) :\n            collateral;\n    }\n\n    /// @notice Modifies the position input per magic values\n    /// @param context The context to use\n    /// @param currentPosition The current position prior to update\n    /// @param newPosition The position to process\n    /// @return The resulting position value\n    function _processPositionMagicValue(\n        Context memory context,\n        UFixed6 currentPosition,\n        UFixed6 newPosition\n    ) private pure returns (UFixed6) {\n        if (newPosition.eq(MAGIC_VALUE_UNCHANGED_POSITION))\n            return currentPosition;\n        if (newPosition.eq(MAGIC_VALUE_FULLY_CLOSED_POSITION)) {\n            if (currentPosition.isZero()) return currentPosition;\n            return currentPosition.sub(context.latestPosition.local.magnitude().sub(context.pending.local.neg()));\n        }\n        return newPosition;\n    }\n\n    /// @notice Processes the given global pending position into the latest position\n    /// @param context The context to use\n    /// @param newOrderId The id of the pending position to process\n    /// @param newOrder The pending position to process\n    function _processOrderGlobal(\n        Context memory context,\n        SettlementContext memory settlementContext,\n        uint256 newOrderId,\n        Order memory newOrder\n    ) private {\n        OracleVersion memory oracleVersion = oracle.at(newOrder.timestamp);\n\n        context.pending.global.sub(newOrder);\n        if (!oracleVersion.valid) newOrder.invalidate();\n\n        VersionAccumulationResult memory accumulationResult;\n        (settlementContext.latestVersion, context.global, accumulationResult) = VersionLib.accumulate(\n            settlementContext.latestVersion,\n            context.global,\n            context.latestPosition.global,\n            newOrder,\n            settlementContext.orderOracleVersion,\n            oracleVersion,\n            context.marketParameter,\n            context.riskParameter\n        );\n\n        context.global.update(newOrderId, accumulationResult, context.marketParameter, context.protocolParameter);\n        context.latestPosition.global.update(newOrder);\n\n        settlementContext.orderOracleVersion = oracleVersion;\n        _versions[newOrder.timestamp].store(settlementContext.latestVersion);\n\n        emit PositionProcessed(newOrderId, newOrder, accumulationResult);\n    }\n\n    /// @notice Processes the given local pending position into the latest position\n    /// @param context The context to use\n    /// @param account The account to process for\n    /// @param newOrderId The id of the pending position to process\n    /// @param newOrder The pending order to process\n    function _processOrderLocal(\n        Context memory context,\n        SettlementContext memory settlementContext,\n        address account,\n        uint256 newOrderId,\n        Order memory newOrder\n    ) private {\n        Version memory versionFrom = _versions[context.latestPosition.local.timestamp].read();\n        Version memory versionTo = _versions[newOrder.timestamp].read();\n\n        context.pending.local.sub(newOrder);\n        if (!versionTo.valid) newOrder.invalidate();\n\n        CheckpointAccumulationResult memory accumulationResult;\n        (settlementContext.latestCheckpoint, accumulationResult) = CheckpointLib.accumulate(\n            settlementContext.latestCheckpoint,\n            newOrder,\n            context.latestPosition.local,\n            versionFrom,\n            versionTo\n        );\n\n        context.local.update(newOrderId, accumulationResult);\n        context.latestPosition.local.update(newOrder);\n\n        _checkpoints[account][newOrder.timestamp].store(settlementContext.latestCheckpoint);\n\n        _credit(liquidators[account][newOrderId], accumulationResult.liquidationFee);\n        _credit(referrers[account][newOrderId], accumulationResult.subtractiveFee);\n\n        emit AccountPositionProcessed(account, newOrderId, newOrder, accumulationResult);\n    }\n\n    /// @notice Credits an account's claimable that is out-of-context\n    /// @dev The amount must have already come from a corresponing debit in the settlement flow\n    /// @param account The account to credit\n    /// @param amount The amount to credit\n    function _credit(address account, UFixed6 amount) private {\n        if (amount.isZero()) return;\n\n        Local memory newLocal = _locals[account].read();\n        newLocal.credit(amount);\n        _locals[account].store(newLocal);\n    }\n\n    /// @notice Only the coordinator or the owner can call\n    modifier onlyCoordinator {\n        if (msg.sender != coordinator && msg.sender != factory().owner()) revert MarketNotCoordinatorError();\n        _;\n    }\n\n    /// @notice Only when the market is not in settle-only mode\n    modifier notSettleOnly(Context memory context) {\n        if (context.marketParameter.settle) revert MarketSettleOnlyError();\n        _;\n    }\n}"
    }
  ]
}