{
  "Title": "[H-02] A new era might be triggered despite a significant value being held in the previous era",
  "Content": "\n<https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L441-L444> <br><https://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/StRSR.sol#L457-L460>\n\nWhen RSR seizure occurs the staking and drafting rate is adjusted accordingly, if any of those rates is above some threshold then a new era begins (draft or staking era accordingly), wiping out all of the holdings of the current era.\nThe assumption is that if the rate is above the threshold then there's not much staking or drafts left after the seizure (and therefore it makes sense to begin a new era).\nHowever, there might be a case where a previous seizure has increased the staking/draft rate close to the threshold, and then even a small seizure would make it cross this threshold. In that case the total value of staking or drafts can be very high, and they will all be wiped out by starting a new era.\n\n### Impact\n\nStakers will lose their holdings or pending drafts.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   Max stake rate is 1e9\n*   A seizure occurs and the new rate is now 91e7\n*   Not much staking is left after the seizure, but as time passes users keep staking bring back the total stakes to a significant value\n*   A 10% seizure occurs, this causes the staking rate to cross the threshold (getting to 1.01e9) and start a new era\n\nThis means the stakings were wiped out despite holding a significant amount of value, causing a loss for the holders.\n\n### Recommended Mitigation Steps\n\nThis one is a bit difficult to mitigate.\nOne way I can think of is to add a 'migration' feature, where in such cases a new era would be created but users would be able to transfer the funds that they held in the previous era into the new era. But this would require some significant code changes and checking that this doesn't break anything or introduces new bugs.\n\n\n**[tbrent (Reserve) commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/2#issuecomment-1588260840):**\n > @0xA5DF thoughts on a governance function that requires the ratio be out of bounds, that does `beginEra()` and/or `beginDraftEra()`? \n> \n> The idea is that stakers can mostly withdraw, and since governance thresholds are all percentage, vote to immolate themselves and re-start the staking pool. I think it should treat `beginEra()` and `beginDraftEra()` separately, but I'm not confident in that yet. \n\n**[tbrent (Reserve) acknowledged and commented](https://github.com/code-423n4/2023-06-reserve-findings/issues/2#issuecomment-1620824773):**\n > We're still not sure how to mitigate this one. Agree it should be considered HIGH and a new issue.\n\n**[Reserve mitigated](https://github.com/code-423n4/2023-08-reserve-mitigation#individual-prs):**\n> Adds governance function to manually push the era forward.<br>\n> PR: https://github.com/reserve-protocol/protocol/pull/888\n\n**Status:** Mitigation confirmed. Full details in reports from [0xA5DF](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/31), [ronnyx2017](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/8), and [rvierdiiev](https://github.com/code-423n4/2023-08-reserve-mitigation-findings/issues/11) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/p1/StRSR.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IStRSR.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"../libraries/Permit.sol\";\nimport \"./mixins/Component.sol\";\n\n/*\n * @title StRSRP1\n * @notice StRSR is an ERC20 token contract that allows people to stake their RSR as\n *   over-collateralization behind an RToken. As compensation stakers receive a share of revenues\n *   in the form of RSR. Balances are generally non-rebasing. As rewards are paid out StRSR becomes\n *   redeemable for increasing quantities of RSR.\n *\n * The one time that StRSR will rebase is if the entirety of over-collateralization RSR is seized.\n *   If this happens, users balances are zereod out and StRSR is re-issued at a 1:1 exchange rate\n *   with RSR.\n *\n * There's an important asymmetry in StRSR: when RSR is added it must be split only\n *   across non-withdrawing stakes, while when RSR is seized it is seized uniformly from both\n *   stakes that are in the process of being withdrawn and those that are not.\n */\n// solhint-disable max-states-count\nabstract contract StRSRP1 is Initializable, ComponentP1, IStRSR, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint48 public constant PERIOD = ONE_BLOCK; // {s} 12 seconds; 1 block on PoS Ethereum\n    uint48 public constant MIN_UNSTAKING_DELAY = PERIOD * 2; // {s}\n    uint48 public constant MAX_UNSTAKING_DELAY = 31536000; // {s} 1 year\n    uint192 public constant MAX_REWARD_RATIO = FIX_ONE; // {1} 100%\n\n    // === ERC20 ===\n    string public name; // immutable\n    string public symbol; // immutable\n    // solhint-disable const-name-snakecase\n    uint8 public constant decimals = 18;\n\n    // Component addresses, immutable after init()\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IBasketHandler private basketHandler;\n    IERC20 private rsr;\n\n    /// === Financial State: Stakes (balances) ===\n    // Era. If stake balances are wiped out due to RSR seizure, increment the era to zero balances.\n    // Only ever directly written by beginEra()\n    uint256 internal era;\n\n    // Typically: \"balances\". These are the tokenized staking positions!\n    // era => ({account} => {qStRSR})\n    mapping(uint256 => mapping(address => uint256)) private stakes; // Stakes per account {qStRSR}\n    uint256 private totalStakes; // Total of all stakes {qStRSR}\n    uint256 private stakeRSR; // Amount of RSR backing all stakes {qRSR}\n    uint192 private stakeRate; // The exchange rate between stakes and RSR. D18{qStRSR/qRSR}\n\n    uint192 private constant MAX_STAKE_RATE = 1e9 * FIX_ONE; // 1e9 D18{qStRSR/qRSR}\n\n    // era => (owner => (spender => {qStRSR}))\n    mapping(uint256 => mapping(address => mapping(address => uint256))) private _allowances;\n\n    // === Financial State: Drafts ===\n    // Era. If drafts get wiped out due to RSR seizure, increment the era to zero draft values.\n    // Only ever directly written by beginDraftEra()\n    uint256 internal draftEra;\n    // Drafts: share of the withdrawing tokens. Not transferrable and not revenue-earning.\n    struct CumulativeDraft {\n        // Avoid re-using uint192 in order to avoid confusion with our type system; 176 is enough\n        uint176 drafts; // Total amount of drafts that will become available // {qDrafts}\n        uint64 availableAt; // When the last of the drafts will become available\n    }\n    // draftEra => ({account} => {drafts})\n    mapping(uint256 => mapping(address => CumulativeDraft[])) public draftQueues; // {drafts}\n    mapping(uint256 => mapping(address => uint256)) public firstRemainingDraft; // draft index\n    uint256 private totalDrafts; // Total of all drafts {qDrafts}\n    uint256 private draftRSR; // Amount of RSR backing all drafts {qRSR}\n    uint192 public draftRate; // The exchange rate between drafts and RSR. D18{qDrafts/qRSR}\n\n    uint192 private constant MAX_DRAFT_RATE = 1e9 * FIX_ONE; // 1e9 D18{qDrafts/qRSR}\n\n    // ==== Analysis Definitions for Financial State ====\n    // Let `bal` be the map stakes[era]; so, bal[acct] == balanceOf(acct)\n\n    // Entirely different concepts for the Drafts:\n    // `draft[acct]` is a \"draft record\". If, say, r = draft[acct], then:\n    //   Let `r.queue` be the map draftQueues[era][acct]\n    //   Let `r.left` be the value firstRemainingDraft[era][acct] // ( minus 1? )\n    //   Let `r.right` be the value draftsQueues[era][acct].length\n    //   We further define r.queue[-1].drafts to be 0.\n    //\n    // So, for any keyval pair (acct, r) in draft:\n    // r.left <= r.right\n    // for all i and j with r.left <= i < j < r.right:\n    //   r.queue[i].drafts < r.queue[j].drafts, and\n    //   r.queue[i].availableAt <= r.queue[j].availableAt\n    //\n    // Define draftSum, the total amount of drafts eventually due to the account holder of record r:\n    // Let draftSum(r:draftRecord) =\n    //   r.queue[r.right-1].drafts - r.queue[r.left-1].drafts\n\n    // ==== Invariants ====\n    // [total-stakes]: totalStakes == sum(bal[acct] for acct in bal)\n    // [max-stake-rate]: 0 < stakeRate <= MAX_STAKE_RATE\n    // [stake-rate]: if totalStakes == 0, then stakeRSR == 0 and stakeRate == FIX_ONE\n    //               else, stakeRSR * stakeRate >= totalStakes * 1e18\n    //               (ie, stakeRSR covers totalStakes at stakeRate)\n    //\n    // [total-drafts]: totalDrafts == sum(draftSum(draft[acct]) for acct in draft)\n    // [max-draft-rate]: 0 < draftRate <= MAX_DRAFT_RATE\n    // [draft-rate]: if totalDrafts == 0, then draftRSR == 0 and draftRate == FIX_ONE\n    //               else, draftRSR * draftRate >= totalDrafts * 1e18\n    //               (ie, draftRSR covers totalDrafts at draftRate)\n    //\n    // === ERC20Permit ===\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n    // === Delegation ===\n    mapping(address => CountersUpgradeable.Counter) private _delegationNonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    // ==== Gov Params ====\n    // Promise: Each gov param is set _only_ by the appropriate \"set\" function.\n    uint48 public unstakingDelay; // {s} The minimum length of time spent in the draft queue\n    uint192 public rewardRatio; // {1} The fraction of the revenue balance to handout per period\n\n    // === Rewards Cache ===\n    // Promise: The two *payout* vars are modified only by init() and _payoutRewards()\n    //   init() pretends that the \"first\" payout happens at initialization time\n    //   _payoutRewards() updates them as described.\n    // When init() or _payoutRewards() was last called:\n    //     payoutLastPaid was the timestamp when the last paid-up block ended\n    //     rsrRewardsAtLastPayout was the value of rsrRewards() at that time\n\n    // {seconds} The last time when rewards were paid out\n    uint48 public payoutLastPaid;\n\n    // {qRSR} How much reward RSR was held the last time rewards were paid out\n    uint256 private rsrRewardsAtLastPayout;\n\n    // === 3.0.0 ===\n    // The fraction of draftRSR + stakeRSR that may exit without a refresh\n    uint192 private constant MAX_WITHDRAWAL_LEAK = 3e17; // {1} 30%\n\n    uint192 private leaked; // {1} stake fraction that has withdrawn without a refresh\n    uint48 private lastWithdrawRefresh; // {s} timestamp of last refresh() during withdraw()\n    uint192 public withdrawalLeak; // {1} gov param -- % RSR that can be withdrawn without refresh\n\n    // ======================\n\n    // init() can only be called once (initializer)\n    // ==== Financial State:\n    // effects:\n    //   draft' = {}, bal' = {}, all totals zero, all rates FIX_ONE.\n    //   payoutLastPaid' = now\n    //   rsrRewardsAtLastPayout' = current RSR balance ( == rsrRewards() given the above )\n    function init(\n        IMain main_,\n        string calldata name_,\n        string calldata symbol_,\n        uint48 unstakingDelay_,\n        uint192 rewardRatio_,\n        uint192 withdrawalLeak_\n    ) external initializer {\n        require(bytes(name_).length > 0, \"name empty\");\n        require(bytes(symbol_).length > 0, \"symbol empty\");\n        __Component_init(main_);\n        __EIP712_init(name_, VERSION);\n        name = name_;\n        symbol = symbol_;\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        basketHandler = main_.basketHandler();\n        rsr = IERC20(address(main_.rsr()));\n\n        payoutLastPaid = uint48(block.timestamp);\n        rsrRewardsAtLastPayout = main_.rsr().balanceOf(address(this));\n        setUnstakingDelay(unstakingDelay_);\n        setRewardRatio(rewardRatio_);\n        setWithdrawalLeak(withdrawalLeak_);\n\n        beginEra();\n        beginDraftEra();\n    }\n\n    /// Assign reward payouts to the staker pool\n    /// @custom:refresher\n    function payoutRewards() external {\n        requireNotFrozen();\n        _payoutRewards();\n    }\n\n    /// Stakes an RSR `amount` on the corresponding RToken to earn yield and over-collateralize\n    /// the system\n    /// @param rsrAmount {qRSR}\n    /// @dev Staking continues while paused/frozen, without reward handouts\n    /// @custom:interaction CEI\n    // checks:\n    //   0 < rsrAmount\n    //\n    // effects:\n    //   stakeRSR' = stakeRSR + rsrAmount\n    //   totalStakes' = stakeRSR' * stakeRate / 1e18   (as required by invariant)\n    //   bal'[caller] = bal[caller] + (totalStakes' - totalStakes)\n    //   stakeRate' = stakeRate     (this could go without saying, but it's important!)\n    //\n    // actions:\n    //   rsr.transferFrom(account, this, rsrAmount)\n    function stake(uint256 rsrAmount) public {\n        require(rsrAmount > 0, \"Cannot stake zero\");\n\n        if (!main.frozen()) _payoutRewards();\n\n        // Mint new stakes\n        mintStakes(_msgSender(), rsrAmount);\n\n        // == Interactions ==\n        IERC20Upgradeable(address(rsr)).safeTransferFrom(_msgSender(), address(this), rsrAmount);\n    }\n\n    /// Begins a delayed unstaking for `amount` StRSR\n    /// @param stakeAmount {qStRSR}\n    /// @custom:interaction\n    // checks:\n    //   not paused (trading) or frozen\n    //   0 < stakeAmount <= bal[caller]\n    //\n    // effects:\n    //   totalStakes' = totalStakes - stakeAmount\n    //   bal'[caller] = bal[caller] - stakeAmount\n    //   stakeRSR' = ceil(totalStakes' * 1e18 / stakeRate)\n    //   stakeRate' = stakeRate (no change)\n    //\n    //   draftRSR' + stakeRSR' = draftRSR + stakeRSR\n    //   draftRate' = draftRate (no change)\n    //   totalDrafts' = floor(draftRSR' + draftRate' / 1e18)\n    //\n    //   A draft for (totalDrafts' - totalDrafts) drafts\n    //   is freshly appended to the caller's draft record.\n    function unstake(uint256 stakeAmount) external {\n        requireNotTradingPausedOrFrozen();\n\n        address account = _msgSender();\n        require(stakeAmount > 0, \"Cannot withdraw zero\");\n        require(stakes[era][account] >= stakeAmount, \"Not enough balance\");\n\n        _payoutRewards();\n\n        // ==== Compute changes to stakes and RSR accounting\n        // rsrAmount: how many RSR to move from the stake pool to the draft pool\n        // pick rsrAmount as big as we can such that (newTotalStakes <= newStakeRSR * stakeRate)\n        _burn(account, stakeAmount);\n\n        // newStakeRSR: {qRSR} = D18 * {qStRSR} / D18{qStRSR/qRSR}\n        uint256 newStakeRSR = (FIX_ONE_256 * totalStakes + (stakeRate - 1)) / stakeRate;\n        uint256 rsrAmount = stakeRSR - newStakeRSR;\n        stakeRSR = newStakeRSR;\n\n        // Create draft\n        (uint256 index, uint64 availableAt) = pushDraft(account, rsrAmount);\n        emit UnstakingStarted(index, era, account, rsrAmount, stakeAmount, availableAt);\n    }\n\n    /// Complete an account's unstaking; callable by anyone\n    /// @custom:interaction CEIC - Warning: violates CEI; has checks at the end\n    // Let:\n    //   r = draft[account]\n    //   draftAmount = r.queue[endId - 1].drafts - r.queue[r.left-1].drafts\n    //\n    // checks:\n    //   RToken is fully collateralized and the basket is sound.\n    //   The system is not paused (trading) or frozen.\n    //   endId <= r.right\n    //   r.queue[endId - 1].availableAt <= now\n    //\n    // effects:\n    //   r'.left = max(endId, r.left)\n    //   draftSum'(account) = draftSum(account) + draftAmount)\n    //   r'.right = r.right\n    //   totalDrafts' = totalDrafts - draftAmount\n    //   draftRSR' = ceil(totalDrafts' * 1e18 / draftRate)\n    //\n    // actions:\n    //   rsr.transfer(account, rsrOut)\n    function withdraw(address account, uint256 endId) external {\n        requireNotTradingPausedOrFrozen();\n\n        uint256 firstId = firstRemainingDraft[draftEra][account];\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        if (endId == 0 || firstId >= endId) return;\n\n        // == Checks + Effects ==\n        require(endId <= queue.length, \"index out-of-bounds\");\n        require(queue[endId - 1].availableAt <= block.timestamp, \"withdrawal unavailable\");\n\n        // untestable:\n        //      firstId will never be zero, due to previous checks against endId\n        uint192 oldDrafts = firstId > 0 ? queue[firstId - 1].drafts : 0;\n        uint192 draftAmount = queue[endId - 1].drafts - oldDrafts;\n\n        // advance queue past withdrawal\n        firstRemainingDraft[draftEra][account] = endId;\n\n        // ==== Compute RSR amount\n        uint256 newTotalDrafts = totalDrafts - draftAmount;\n        // newDraftRSR: {qRSR} = {qDrafts} * D18 / D18{qDrafts/qRSR}\n        uint256 newDraftRSR = (newTotalDrafts * FIX_ONE_256 + (draftRate - 1)) / draftRate;\n        uint256 rsrAmount = draftRSR - newDraftRSR;\n\n        if (rsrAmount == 0) return;\n\n        // ==== Transfer RSR from the draft pool\n        totalDrafts = newTotalDrafts;\n        draftRSR = newDraftRSR;\n\n        // == Interactions ==\n        leakyRefresh(rsrAmount);\n        IERC20Upgradeable(address(rsr)).safeTransfer(account, rsrAmount);\n        emit UnstakingCompleted(firstId, endId, draftEra, account, rsrAmount);\n\n        // == Checks ==\n        require(basketHandler.fullyCollateralized(), \"RToken uncollateralized\");\n        require(basketHandler.isReady(), \"basket not ready\");\n    }\n\n    /// Cancel an ongoing unstaking; resume staking\n    /// @custom:interaction CEI\n    function cancelUnstake(uint256 endId) external {\n        requireNotFrozen();\n        address account = _msgSender();\n\n        // We specifically allow unstaking when under collateralized\n        // require(basketHandler.fullyCollateralized(), \"RToken uncollateralized\");\n        // require(basketHandler.isReady(), \"basket not ready\");\n\n        uint256 firstId = firstRemainingDraft[draftEra][account];\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        if (endId == 0 || firstId >= endId) return;\n\n        require(endId <= queue.length, \"index out-of-bounds\");\n\n        // Cancelling unstake does not require checking if the unstaking was available\n        // require(queue[endId - 1].availableAt <= block.timestamp, \"withdrawal unavailable\");\n\n        uint192 oldDrafts = firstId > 0 ? queue[firstId - 1].drafts : 0;\n        uint192 draftAmount = queue[endId - 1].drafts - oldDrafts;\n\n        // advance queue past withdrawal\n        firstRemainingDraft[draftEra][account] = endId;\n\n        // ==== Compute RSR amount\n        uint256 newTotalDrafts = totalDrafts - draftAmount;\n        // newDraftRSR: {qRSR} = {qDrafts} * D18 / D18{qDrafts/qRSR}\n        uint256 newDraftRSR = (newTotalDrafts * FIX_ONE_256 + (draftRate - 1)) / draftRate;\n        uint256 rsrAmount = draftRSR - newDraftRSR;\n\n        if (rsrAmount == 0) return;\n\n        // ==== Transfer RSR from the draft pool\n        totalDrafts = newTotalDrafts;\n        draftRSR = newDraftRSR;\n\n        emit UnstakingCancelled(firstId, endId, draftEra, account, rsrAmount);\n\n        // Mint new stakes\n        mintStakes(account, rsrAmount);\n    }\n\n    /// @param rsrAmount {qRSR}\n    /// Must seize at least `rsrAmount`, or revert\n    /// @custom:protected\n    // let:\n    //   keepRatio = 1 - (rsrAmount / rsr.balanceOf(this))\n    //\n    // checks:\n    //   0 < rsrAmount <= rsr.balanceOf(this)\n    //   not paused (trading) or frozen\n    //   caller is backingManager\n    //\n    // effects, in two phases. Phase 1: (from x to x')\n    //   stakeRSR' = floor(stakeRSR * keepRatio)\n    //   totalStakes' = totalStakes\n    //   stakeRate' = ceil(totalStakes' * 1e18 / stakeRSR')\n    //\n    //   draftRSR' = floor(draftRSR * keepRatio)\n    //   totalDrafts' = totalDrafts\n    //   draftRate' = ceil(totalDrafts' * 1e18 / draftRSR')\n    //\n    //   let fromRewards = floor(rsrRewards() * (1 - keepRatio))\n    //\n    // effects phase 2: (from x' to x'')\n    //   draftRSR'' = (draftRSR' <= MAX_DRAFT_RATE) ? draftRSR' : 0\n    //   if draftRSR'' = 0, then totalDrafts'' = 0 and draftRate'' = FIX_ONE\n    //   stakeRSR'' = (stakeRSR' <= MAX_STAKE_RATE) ? stakeRSR' : 0\n    //   if stakeRSR'' = 0, then totalStakes'' = 0 and stakeRate'' = FIX_ONE\n    //\n    // actions:\n    //   as (this), rsr.transfer(backingManager, seized)\n    //   where seized = draftRSR - draftRSR'' + stakeRSR - stakeRSR'' + fromRewards\n    //\n    // other properties:\n    //   seized >= rsrAmount, which should be a logical consequence of the above effects\n    function seizeRSR(uint256 rsrAmount) external {\n        requireNotTradingPausedOrFrozen();\n\n        require(_msgSender() == address(backingManager), \"not backing manager\");\n        require(rsrAmount > 0, \"Amount cannot be zero\");\n\n        uint256 rsrBalance = rsr.balanceOf(address(this));\n        require(rsrAmount <= rsrBalance, \"Cannot seize more RSR than we hold\");\n\n        _payoutRewards();\n\n        uint256 seizedRSR;\n        uint192 initRate = exchangeRate();\n        uint256 rewards = rsrRewards();\n\n        // Remove RSR from stakeRSR\n        uint256 stakeRSRToTake = (stakeRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        stakeRSR -= stakeRSRToTake;\n        seizedRSR = stakeRSRToTake;\n\n        // update stakeRate, possibly beginning a new stake era\n        if (stakeRSR > 0) {\n            // Downcast is safe: totalStakes is 1e38 at most so expression maximum value is 1e56\n            stakeRate = uint192((FIX_ONE_256 * totalStakes + (stakeRSR - 1)) / stakeRSR);\n        }\n        if (stakeRSR == 0 || stakeRate > MAX_STAKE_RATE) {\n            seizedRSR += stakeRSR;\n            beginEra();\n        }\n\n        // Remove RSR from draftRSR\n        uint256 draftRSRToTake = (draftRSR * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        draftRSR -= draftRSRToTake;\n        seizedRSR += draftRSRToTake;\n\n        // update draftRate, possibly beginning a new draft era\n        if (draftRSR > 0) {\n            // Downcast is safe: totalDrafts is 1e38 at most so expression maximum value is 1e56\n            draftRate = uint192((FIX_ONE_256 * totalDrafts + (draftRSR - 1)) / draftRSR);\n        }\n\n        if (draftRSR == 0 || draftRate > MAX_DRAFT_RATE) {\n            seizedRSR += draftRSR;\n            beginDraftEra();\n        }\n\n        // Remove RSR from yet-unpaid rewards (implicitly)\n        seizedRSR += (rewards * rsrAmount + (rsrBalance - 1)) / rsrBalance;\n        rsrRewardsAtLastPayout = rsrRewards() - seizedRSR;\n\n        // Transfer RSR to caller\n        emit ExchangeRateSet(initRate, exchangeRate());\n        IERC20Upgradeable(address(rsr)).safeTransfer(_msgSender(), seizedRSR);\n    }\n\n    /// @return D18{qRSR/qStRSR} The exchange rate between RSR and StRSR\n    function exchangeRate() public view returns (uint192) {\n        // D18{qRSR/qStRSR} = D18 * D18 / D18{qStRSR/qRSR}\n        return (FIX_SCALE_SQ + (stakeRate / 2)) / stakeRate; // ROUND method\n    }\n\n    /// Return the maximum value of endId such that withdraw(endId) can immediately work\n    // let r = draft[account]\n    // returns:\n    //   if r.left == r.right: r.right (i.e, withdraw 0 drafts)\n    //   else: the least id such that r.left <= id <= r.right and r.queue[id].availableAt > now\n    function endIdForWithdraw(address account) external view returns (uint256) {\n        uint256 time = block.timestamp;\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n\n        // Bounds our search for the current cumulative draft\n        (uint256 left, uint256 right) = (firstRemainingDraft[draftEra][account], queue.length);\n\n        // If there are no drafts to be found, return 0 drafts\n        if (left >= right) return right;\n        if (queue[left].availableAt > time) return left;\n\n        // Otherwise, there *are* drafts with left <= index < right and availableAt <= time.\n        // Binary search:\n        uint256 test;\n        while (left < right - 1) {\n            // Loop invariants, because without great care a binary search is usually wrong:\n            // - queue[left].availableAt <= time\n            // - either right == queue.length or queue[right].availableAt > time\n            test = (left + right) / 2; // left < test < right because left < right - 1\n            if (queue[test].availableAt <= time) left = test;\n            else right = test;\n        }\n        return right;\n    }\n\n    /// Used by FacadeP1\n    /// @return The length of the draft queue for an account in an era\n    function draftQueueLen(uint256 era_, address account) external view returns (uint256) {\n        return draftQueues[era_][account].length;\n    }\n\n    /// @return {qDrafts} The amount of RSR currently being withdrawn\n    function getDraftRSR() external view returns (uint256) {\n        return draftRSR;\n    }\n\n    /// @return {qRSR} The amount of RSR currently being staked and earning rewards\n    function getStakeRSR() external view returns (uint256) {\n        return stakeRSR;\n    }\n\n    /// @return {qDrafts} The amount of StRSR currently being withdrawn\n    function getTotalDrafts() external view returns (uint256) {\n        return totalDrafts;\n    }\n\n    // ==== Internal Functions ====\n\n    /// Assign reward payouts to the staker pool\n    /// @dev do this by effecting stakeRSR and payoutLastPaid as appropriate, given the current\n    /// value of rsrRewards()\n    /// @dev perhaps astonishingly, this _isn't_ a refresher\n\n    // let\n    //   N = numPeriods; the number of whole rewardPeriods since the last payout\n    //   payout = rsrRewards() * (1 - (1 - rewardRatio)^N)  (see [strsr-payout-formula])\n    //\n    // effects:\n    //   stakeRSR' = stakeRSR + payout\n    //   rsrRewards'() = rsrRewards() - payout   (implicit in the code, but true)\n    //   stakeRate' = ceil(totalStakes' * 1e18 / stakeRSR')  (because [stake-rate])\n    //     unless totalStakes == 0 or stakeRSR == 0, in which case stakeRate' = FIX_ONE\n    //   totalStakes' = totalStakes\n    //\n    // [strsr-payout-formula]:\n    //   The process we're modelling is:\n    //     N = number of whole rewardPeriods since last _payoutRewards() call\n    //     rewards_0 = rsrRewards()\n    //     payout_{i+1} = rewards_i * payoutRatio\n    //     rewards_{i+1} = rewards_i - payout_{i+1}\n    //     payout = sum{payout_i for i in [1...N]}\n    //   thus:\n    //     rewards_N = rewards_0 - payout\n    //     rewards_{i+1} = rewards_i - rewards_i * payoutRatio = rewards_i * (1-payoutRatio)\n    //     rewards_N = rewards_0 * (1-payoutRatio) ^ N\n    //     payout = rewards_N - rewards_0 = rewards_0 * (1 - (1-payoutRatio)^N)\n    function _payoutRewards() internal {\n        if (block.timestamp < payoutLastPaid + PERIOD) return;\n        uint48 numPeriods = (uint48(block.timestamp) - payoutLastPaid) / PERIOD;\n\n        uint192 initRate = exchangeRate();\n        uint256 payout;\n\n        // Do an actual payout if and only if enough RSR is staked!\n        if (totalStakes >= FIX_ONE) {\n            // Paying out the ratio r, N times, equals paying out the ratio (1 - (1-r)^N) 1 time.\n            // Apply payout to RSR backing\n            // payoutRatio: D18 = FIX_ONE: D18 - FixLib.powu(): D18\n            // Both uses of uint192(-) are fine, as it's equivalent to FixLib.sub().\n            uint192 payoutRatio = FIX_ONE - FixLib.powu(FIX_ONE - rewardRatio, numPeriods);\n\n            // payout: {qRSR} = D18{1} * {qRSR} / D18\n            payout = (payoutRatio * rsrRewardsAtLastPayout) / FIX_ONE;\n            stakeRSR += payout;\n        }\n\n        payoutLastPaid += numPeriods * PERIOD;\n        rsrRewardsAtLastPayout = rsrRewards();\n\n        // stakeRate else case: D18{qStRSR/qRSR} = {qStRSR} * D18 / {qRSR}\n        // downcast is safe: it's at most 1e38 * 1e18 = 1e56\n        // untestable:\n        //      the second half of the OR comparison is untestable because of the invariant:\n        //      if totalStakes == 0, then stakeRSR == 0\n        stakeRate = (stakeRSR == 0 || totalStakes == 0)\n            ? FIX_ONE\n            : uint192((totalStakes * FIX_ONE_256 + (stakeRSR - 1)) / stakeRSR);\n\n        emit RewardsPaid(payout);\n        emit ExchangeRateSet(initRate, exchangeRate());\n    }\n\n    /// @param rsrAmount {qRSR}\n    /// @return index The index of the draft\n    /// @return availableAt {s} The timestamp the cumulative draft vests\n    // effects:\n    //   draftRSR' = draftRSR + rsrAmount\n    //   draftRate' = draftRate    (ie, unchanged)\n    //   totalDrafts' = floor(draftRSR' * draftRate' / 1e18)\n    //   r'.left = r.left\n    //   r'.right = r.right + 1\n    //   r'.queue is r.queue with a new entry appeneded for (totalDrafts' - totalDraft) drafts\n    //   where r = draft[account] and r' = draft'[account]\n    function pushDraft(address account, uint256 rsrAmount)\n        internal\n        returns (uint256 index, uint64 availableAt)\n    {\n        // draftAmount: how many drafts to create and assign to the user\n        // pick draftAmount as big as we can such that (newTotalDrafts <= newDraftRSR * draftRate)\n        draftRSR += rsrAmount;\n        // newTotalDrafts: {qDrafts} = D18{qDrafts/qRSR} * {qRSR} / D18\n        uint256 newTotalDrafts = (draftRate * draftRSR) / FIX_ONE;\n        uint256 draftAmount = newTotalDrafts - totalDrafts;\n        totalDrafts = newTotalDrafts;\n\n        // Push drafts into account's draft queue\n        CumulativeDraft[] storage queue = draftQueues[draftEra][account];\n        index = queue.length;\n\n        uint192 oldDrafts = index > 0 ? queue[index - 1].drafts : 0;\n        uint64 lastAvailableAt = index > 0 ? queue[index - 1].availableAt : 0;\n        availableAt = uint64(block.timestamp) + unstakingDelay;\n        if (lastAvailableAt > availableAt) {\n            availableAt = lastAvailableAt;\n        }\n\n        queue.push(CumulativeDraft(uint176(oldDrafts + draftAmount), availableAt));\n    }\n\n    /// Zero all stakes and withdrawals\n    /// Overriden in StRSRVotes to handle rebases\n    // effects:\n    //   stakeRSR' = totalStakes' = 0\n    //   stakeRate' = FIX_ONE\n    function beginEra() internal virtual {\n        stakeRSR = 0;\n        totalStakes = 0;\n        stakeRate = FIX_ONE;\n        era++;\n\n        emit AllBalancesReset(era);\n    }\n\n    // effects:\n    //  draftRSR' = totalDrafts' = 0\n    //  draftRate' = FIX_ONE\n    function beginDraftEra() internal virtual {\n        draftRSR = 0;\n        totalDrafts = 0;\n        draftRate = FIX_ONE;\n        draftEra++;\n\n        emit AllUnstakingReset(draftEra);\n    }\n\n    /// @return {qRSR} The balance of RSR that this contract owns dedicated to future RSR rewards.\n    function rsrRewards() internal view returns (uint256) {\n        return rsr.balanceOf(address(this)) - stakeRSR - draftRSR;\n    }\n\n    /// Refresh if too much RSR has exited since the last refresh occurred\n    /// @param rsrWithdrawal {qRSR} How much RSR is being withdrawn\n    /// Effects-Refresh\n    function leakyRefresh(uint256 rsrWithdrawal) private {\n        uint48 lastRefresh = assetRegistry.lastRefresh(); // {s}\n\n        // Assumption: rsrWithdrawal has already been taken out of draftRSR\n        uint256 totalRSR = stakeRSR + draftRSR + rsrWithdrawal; // {qRSR}\n        uint192 withdrawal = _safeWrap((rsrWithdrawal * FIX_ONE + totalRSR - 1) / totalRSR); // {1}\n\n        // == Effects ==\n        leaked = lastWithdrawRefresh != lastRefresh ? withdrawal : leaked + withdrawal;\n        lastWithdrawRefresh = lastRefresh;\n\n        if (leaked > withdrawalLeak) {\n            leaked = 0;\n            lastWithdrawRefresh = uint48(block.timestamp);\n\n            /// == Refresh ==\n            assetRegistry.refresh();\n        }\n    }\n\n    /// Mint stakes corresponding to rsrAmount to an account\n    /// @param rsrAmount {qRSR} The RSR amount being staked\n    function mintStakes(address account, uint256 rsrAmount) private {\n        // This is not an overflow risk according to our expected ranges:\n        //   rsrAmount <= 1e29, totalStaked <= 1e38, 1e29 * 1e38 < 2^256.\n        // stakeAmount: how many stRSR the user shall receive.\n        // pick stakeAmount as big as we can such that (newTotalStakes <= newStakeRSR * stakeRate)\n        uint256 newStakeRSR = stakeRSR + rsrAmount;\n        // newTotalStakes: {qStRSR} = D18{qStRSR/qRSR} * {qRSR} / D18\n        uint256 newTotalStakes = (stakeRate * newStakeRSR) / FIX_ONE;\n        uint256 stakeAmount = newTotalStakes - totalStakes;\n\n        // Transfer RSR from account to this contract\n        stakeRSR += rsrAmount;\n        _mint(account, stakeAmount);\n        emit Staked(era, account, rsrAmount, stakeAmount);\n    }\n\n    // contract-size-saver\n    // solhint-disable-next-line no-empty-blocks\n    function requireNotTradingPausedOrFrozen() private notTradingPausedOrFrozen {}\n\n    // contract-size-saver\n    // solhint-disable-next-line no-empty-blocks\n    function requireNotFrozen() private notFrozen {}\n\n    // contract-size-saver\n    // solhint-disable-next-line no-empty-blocks\n    function requireGovernanceOnly() private governance {}\n\n    // ==== ERC20 ====\n    // This section extracted from ERC20; adjusted to work with stakes/eras\n    // name(), symbol(), and decimals() are all auto-generated\n\n    function totalSupply() public view returns (uint256) {\n        return totalStakes;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return stakes[era][account];\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[era][owner][spender];\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        _spendAllowance(from, _msgSender(), amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[era][owner][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[era][owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    // checks: from != 0, to != 0,\n    // effects: bal[from] -= amount; bal[to] += amount;\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        requir"
    }
  ]
}