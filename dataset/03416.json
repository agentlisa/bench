{
  "Title": "`_timestampLU` can be equal to 0",
  "Content": "##### Description\n`_timestampLU` can be equal to 0, for example in constructor:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/pool/PoolService.sol#L209\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/pool/PoolService.sol#L334\n##### Recommendation\nWe recommend checking it and use another calculation for this scenario.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/pool/PoolService.sol",
      "content": "// SPDX-License-Identifier: BSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {ACLTrait} from \"../core/ACLTrait.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\n\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\nimport {IPoolService} from \"../interfaces/IPoolService.sol\";\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\n\nimport {AddressProvider} from \"../core/AddressProvider.sol\";\nimport {DieselToken} from \"../tokens/DieselToken.sol\";\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title Pool Service\n/// @notice Encapsulates business logic for:\n///  - Adding/removing pool liquidity\n///  - Managing diesel tokens & diesel rates\n///  - Lend funds to credit manager\n///\n/// More: https://dev.gearbox.fi/developers/pools/pool-service\ncontract PoolService is IPoolService, ACLTrait, ReentrancyGuard {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n    using PercentageMath for uint256;\n\n    // Expected liquidity at last update (LU)\n    uint256 public _expectedLiquidityLU;\n\n    // Expected liquidity limit\n    uint256 public override expectedLiquidityLimit;\n\n    // Total borrowed amount: https://dev.gearbox.fi/developers/pools/economy/total-borrowed\n    uint256 public override totalBorrowed;\n\n    // Address repository\n    AddressProvider public addressProvider;\n\n    // Interest rate model\n    IInterestRateModel public interestRateModel;\n\n    // Underlying token address\n    address public override underlyingToken;\n\n    // Diesel(LP) token address\n    address public override dieselToken;\n\n    // Credit managers mapping with permission to borrow / repay\n    mapping(address => bool) public override creditManagersCanBorrow;\n    mapping(address => bool) public creditManagersCanRepay;\n\n    // Credif managers\n    address[] public override creditManagers;\n\n    // Treasury address for tokens\n    address public treasuryAddress;\n\n    // Cumulative index in RAY\n    uint256 public override _cumulativeIndex_RAY;\n\n    // Current borrow rate in RAY: https://dev.gearbox.fi/developers/pools/economy#borrow-apy\n    uint256 public override borrowAPY_RAY;\n\n    // Timestamp of last update\n    uint256 public override _timestampLU;\n\n    // Withdraw fee in PERCENTAGE FORMAT\n    uint256 public override withdrawFee;\n\n    // = PERCENTAGE_AMOUNT - withdrawFee\n    uint256 public withdrawMultiplier;\n\n    //\n    // CONSTRUCTOR\n    //\n\n    /// @dev Constructor\n    /// @param _addressProvider Address Repository for upgradable contract model\n    /// @param _underlyingToken Address of underlying token\n    /// @param _dieselAddress Address of diesel (LP) token\n    /// @param _interestRateModelAddress Address of interest rate model\n    constructor(\n        address _addressProvider,\n        address _underlyingToken,\n        address _dieselAddress,\n        address _interestRateModelAddress\n    ) ACLTrait(_addressProvider) {\n        addressProvider = AddressProvider(_addressProvider);\n        interestRateModel = IInterestRateModel(_interestRateModelAddress);\n        underlyingToken = _underlyingToken;\n        dieselToken = _dieselAddress;\n        treasuryAddress = addressProvider.getTreasuryContract();\n\n        _cumulativeIndex_RAY = WadRayMath.RAY; // T:[PS-5]\n        _updateBorrowRate(); // to set up correct borrow rate at start\n\n        setWithdrawFee(0);\n    }\n\n    //\n    // LIQUIDITY MANAGEMENT\n    //\n\n    /**\n     * @dev Adds liquidity to pool\n     * - Transfers underlying asset to pool\n     * - Mints diesel (LP) token with current diesel rate\n     * - Updates expected liquidity\n     * - Updates borrow rate\n     *\n     * More: https://dev.gearbox.fi/developers/pools/pool-service#addliquidity\n     *\n     * @param amount Amount of tokens to be transfer\n     * @param onBehalfOf The address that will receive the diesel tokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of diesel\n     * tokens is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function addLiquidity(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 referralCode\n    )\n        external\n        override\n        whenNotPaused // T:[PS-4]\n        nonReentrant\n    {\n        require(\n            expectedLiquidity() + amount <= expectedLiquidityLimit,\n            Errors.POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT\n        ); // T:[PS-31]\n\n        IERC20(underlyingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        ); // T:[PS-2, 7]\n\n        DieselToken(dieselToken).mint(onBehalfOf, toDiesel(amount)); // T:[PS-2, 7]\n\n        _expectedLiquidityLU = _expectedLiquidityLU.add(amount); // T:[PS-2, 7]\n        _updateBorrowRate(); // T:[PS-2, 7]\n\n        emit AddLiquidity(msg.sender, onBehalfOf, amount, referralCode); // T:[PS-2, 7]\n    }\n\n    /**\n     * @dev Removes liquidity from pool\n     * - Transfers to LP underlying account = amount * diesel rate\n     * - Burns diesel tokens\n     * - Decreases underlying amount from total_liquidity\n     * - Updates borrow rate\n     *\n     * More: https://dev.gearbox.fi/developers/pools/pool-service#removeliquidity\n     *\n     * @param amount Amount of tokens to be transfer\n     * @param to Address to transfer liquidity\n     */\n    function removeLiquidity(uint256 amount, address to)\n        external\n        override\n        whenNotPaused // T:[PS-4]\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 underlyingTokensAmount = fromDiesel(amount); // T:[PS-3, 8]\n\n        uint256 amountSent = underlyingTokensAmount.percentMul(\n            withdrawMultiplier\n        );\n\n        IERC20(underlyingToken).safeTransfer(to, amountSent); // T:[PS-3, 34]\n        IERC20(underlyingToken).safeTransfer(\n            treasuryAddress,\n            underlyingTokensAmount.percentMul(withdrawFee)\n        ); // T:[PS-3, 34]\n        DieselToken(dieselToken).burn(msg.sender, amount); // T:[PS-3, 8]\n\n        _expectedLiquidityLU = _expectedLiquidityLU.sub(underlyingTokensAmount); // T:[PS-3, 8]\n        _updateBorrowRate(); // T:[PS-3,8 ]\n\n        emit RemoveLiquidity(msg.sender, to, amount); // T:[PS-3, 8]\n\n        return amountSent;\n    }\n\n    /// @dev Returns expected liquidity - the amount of money should be in the pool\n    /// if all users close their Credit accounts and return debt\n    ///\n    /// More: https://dev.gearbox.fi/developers/pools/economy#expected-liquidity\n    function expectedLiquidity() public view override returns (uint256) {\n        // timeDifference = blockTime - previous timeStamp\n        uint256 timeDifference = block.timestamp.sub(uint256(_timestampLU));\n\n        //                                    currentBorrowRate * timeDifference\n        //  interestAccrued = totalBorrow *  ------------------------------------\n        //                                             SECONDS_PER_YEAR\n        //\n        uint256 interestAccrued = totalBorrowed.rayMul(\n            borrowAPY_RAY.mul(timeDifference).div(Constants.SECONDS_PER_YEAR)\n        ); // T:[GM-1]\n\n        return _expectedLiquidityLU.add(interestAccrued); // T:[PS-29]\n    }\n\n    /// @dev Returns available liquidity in the pool (pool balance)\n    /// More: https://dev.gearbox.fi/developers/\n    function availableLiquidity() public view override returns (uint256) {\n        return IERC20(underlyingToken).balanceOf(address(this));\n    }\n\n    //\n    // CREDIT ACCOUNT LENDING\n    //\n\n    /// @dev Lends funds to credit manager and updates the pool parameters\n    /// More: https://dev.gearbox.fi/developers/pools/pool-service#lendcreditAccount\n    ///\n    /// @param borrowedAmount Borrowed amount for credit account\n    /// @param creditAccount Credit account address\n    function lendCreditAccount(uint256 borrowedAmount, address creditAccount)\n        external\n        override\n        whenNotPaused // T:[PS-4]\n    {\n        require(\n            creditManagersCanBorrow[msg.sender],\n            Errors.POOL_CREDIT_MANAGERS_ONLY\n        ); // T:[PS-12, 13]\n\n        // Transfer funds to credit account\n        IERC20(underlyingToken).safeTransfer(creditAccount, borrowedAmount); // T:[PS-14]\n\n        // Update borrow Rate\n        _updateBorrowRate(); // T:[PS-17]\n\n        // Increase total borrowed amount\n        totalBorrowed = totalBorrowed.add(borrowedAmount); // T:[PS-16]\n\n        emit Borrow(msg.sender, creditAccount, borrowedAmount); // T:[PS-15]\n    }\n\n    /// @dev It's called after credit account funds transfer back to pool and updates corretly parameters.\n    /// More: https://dev.gearbox.fi/developers/pools/pool-service#repaycreditAccount\n    ///\n    /// @param borrowedAmount Borrowed amount (without interest accrued)\n    /// @param profit Represents PnL value if PnL > 0\n    /// @param loss Represents PnL value if PnL <0\n    function repayCreditAccount(\n        uint256 borrowedAmount,\n        uint256 profit,\n        uint256 loss\n    )\n        external\n        override\n        whenNotPaused // T:[PS-4]\n    {\n        require(\n            creditManagersCanRepay[msg.sender],\n            Errors.POOL_CREDIT_MANAGERS_ONLY\n        ); // T:[PS-12]\n\n        // For fee surplus we mint tokens for treasury\n        if (profit > 0) {\n            // T:[PS-22] provess that diesel rate will be the same within the margin of error\n            DieselToken(dieselToken).mint(treasuryAddress, toDiesel(profit)); // T:[PS-21, 22]\n            _expectedLiquidityLU = _expectedLiquidityLU.add(profit); // T:[PS-21, 22]\n        }\n        // If returned money < borrowed amount + interest accrued\n        // it tries to compensate loss by burning diesel (LP) tokens\n        // from treasury fund\n        else {\n            uint256 amountToBurn = toDiesel(loss); // T:[PS-19,20]\n\n            uint256 treasuryBalance = DieselToken(dieselToken).balanceOf(\n                treasuryAddress\n            ); // T:[PS-19,20]\n\n            if (treasuryBalance < amountToBurn) {\n                amountToBurn = treasuryBalance;\n                emit UncoveredLoss(\n                    msg.sender,\n                    loss.sub(fromDiesel(treasuryBalance))\n                ); // T:[PS-23]\n            }\n\n            // If treasury has enough funds, it just burns needed amount\n            // to keep diesel rate on the same level\n            DieselToken(dieselToken).burn(treasuryAddress, amountToBurn); // T:[PS-19. 20]\n\n            _expectedLiquidityLU = _expectedLiquidityLU.sub(loss); //T:[PS-19,20]\n        }\n\n        // Update available liquidity\n        _updateBorrowRate(); // T:[PS-19, 20, 21]\n\n        // Reduce total borrowed. Should be after _updateBorrowRate() for correct calculations\n        totalBorrowed = totalBorrowed.sub(borrowedAmount); // T:[PS-19, 20]\n\n        emit Repay(msg.sender, borrowedAmount, profit, loss); // T:[PS-18]\n    }\n\n    //\n    // INTEREST RATE MANAGEMENT\n    //\n\n    /**\n     * @dev Calculates interest accrued from the last update using the linear model\n     *\n     *                                    /     currentBorrowRate * timeDifference \\\n     *  newCumIndex  = currentCumIndex * | 1 + ------------------------------------ |\n     *                                    \\              SECONDS_PER_YEAR          /\n     *\n     * @return current cumulative index in RAY\n     */\n    function calcLinearCumulative_RAY() public view override returns (uint256) {\n        //solium-disable-next-line\n        uint256 timeDifference = block.timestamp.sub(uint256(_timestampLU)); // T:[PS-28]\n\n        return\n            calcLinearIndex_RAY(\n                _cumulativeIndex_RAY,\n                borrowAPY_RAY,\n                timeDifference\n            ); // T:[PS-28]\n    }\n\n    /// @dev Calculate linear index\n    /// @param cumulativeIndex_RAY Current cumulative index in RAY\n    /// @param currentBorrowRate_RAY Current borrow rate in RAY\n    /// @param timeDifference Duration in seconds\n    /// @return newCumulativeIndex Cumulative index accrued duration in Rays\n    function calcLinearIndex_RAY(\n        uint256 cumulativeIndex_RAY,\n        uint256 currentBorrowRate_RAY,\n        uint256 timeDifference\n    ) public pure returns (uint256) {\n        //                                    /     currentBorrowRate * timeDifference \\\n        //  newCumIndex  = currentCumIndex * | 1 + ------------------------------------ |\n        //                                    \\              SECONDS_PER_YEAR          /\n        //\n        uint256 linearAccumulated_RAY = WadRayMath.RAY.add(\n            currentBorrowRate_RAY.mul(timeDifference).div(\n                Constants.SECONDS_PER_YEAR\n            )\n        ); // T:[GM-2]\n\n        return cumulativeIndex_RAY.rayMul(linearAccumulated_RAY); // T:[GM-2]\n    }\n\n    /// @dev Updates Cumulative index when liquidity parameters are changed\n    ///  - compute how much interest were accrued from last update\n    ///  - compute new cumulative index based on updated liquidity parameters\n    ///  - stores new cumulative index and timestamp when it was updated\n    function _updateBorrowRate() internal {\n        // Update total _expectedLiquidityLU\n\n        _expectedLiquidityLU = expectedLiquidity(); // T:[PS-27]\n\n        // Update cumulativeIndex\n        _cumulativeIndex_RAY = calcLinearCumulative_RAY(); // T:[PS-27]\n\n        // update borrow APY\n        borrowAPY_RAY = interestRateModel.calcBorrowRate(\n            _expectedLiquidityLU,\n            availableLiquidity()\n        ); // T:[PS-27]\n        _timestampLU = block.timestamp; // T:[PS-27]\n    }\n\n    //\n    // DIESEL TOKEN MGMT\n    //\n\n    /// @dev Returns current diesel rate in RAY format\n    /// More info: https://dev.gearbox.fi/developers/pools/economy#diesel-rate\n    function getDieselRate_RAY() public view override returns (uint256) {\n        uint256 dieselSupply = IERC20(dieselToken).totalSupply();\n        if (dieselSupply == 0) return WadRayMath.RAY; // T:[PS-1]\n        return expectedLiquidity().rayDiv(dieselSupply); // T:[PS-6]\n    }\n\n    /// @dev Converts amount into diesel tokens\n    /// @param amount Amount in underlying tokens to be converted to diesel tokens\n    function toDiesel(uint256 amount) public view override returns (uint256) {\n        return amount.rayDiv(getDieselRate_RAY()); // T:[PS-24]\n    }\n\n    /// @dev Converts amount from diesel tokens to undelying token\n    /// @param amount Amount in diesel tokens to be converted to diesel tokens\n    function fromDiesel(uint256 amount) public view override returns (uint256) {\n        return amount.rayMul(getDieselRate_RAY()); // T:[PS-24]\n    }\n\n    //\n    // CONFIGURATION\n    //\n\n    /// @dev Connects new Credif manager to pool\n    /// @param _creditManager Address of credif manager\n    function connectCreditManager(address _creditManager)\n        external\n        configuratorOnly // T:[PS-9]\n    {\n        require(\n            address(this) == ICreditManager(_creditManager).poolService(),\n            Errors.POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER\n        ); // T:[PS-10]\n\n        require(\n            !creditManagersCanRepay[_creditManager],\n            Errors.POOL_CANT_ADD_CREDIT_MANAGER_TWICE\n        ); // T:[PS-35]\n\n        creditManagersCanBorrow[_creditManager] = true; // T:[PS-11]\n        creditManagersCanRepay[_creditManager] = true; // T:[PS-11]\n        creditManagers.push(_creditManager); // T:[PS-11]\n        emit NewCreditManagerConnected(_creditManager); // T:[PS-11]\n    }\n\n    /// @dev Forbid to borrow for particulat credif manager\n    /// @param _creditManager Address of credif manager\n    function forbidCreditManagerToBorrow(address _creditManager)\n        external\n        configuratorOnly // T:[PS-9]\n    {\n        creditManagersCanBorrow[_creditManager] = false; // T:[PS-13]\n        emit BorrowForbidden(_creditManager); // T:[PS-13]\n    }\n\n    /// @dev Set the new interest rate model for pool\n    /// @param _interestRateModel Address of new interest rate model contract\n    function newInterestRateModel(address _interestRateModel)\n        external\n        configuratorOnly // T:[PS-9]\n    {\n        interestRateModel = IInterestRateModel(_interestRateModel); // T:[PS-25]\n        _updateBorrowRate(); // T:[PS-26]\n        emit NewInterestRateModel(_interestRateModel); // T:[PS-25]\n    }\n\n    /// @dev Sets expected liquidity limit\n    /// @param newLimit New expected liquidity limit\n    function setExpectedLiquidityLimit(uint256 newLimit)\n        external\n        configuratorOnly // T:[PS-9]\n    {\n        expectedLiquidityLimit = newLimit; // T:[PS-30]\n        emit NewExpectedLiquidityLimit(newLimit); // T:[PS-30]\n    }\n\n    /// @dev Sets withdraw fee\n    function setWithdrawFee(uint256 fee)\n        public\n        configuratorOnly // T:[PS-9]\n    {\n        require(\n            fee < Constants.MAX_WITHDRAW_FEE,\n            Errors.POOL_INCORRECT_WITHDRAW_FEE\n        ); // T:[PS-32]\n        withdrawFee = fee; // T:[PS-33]\n        withdrawMultiplier = PercentageMath.PERCENTAGE_FACTOR.sub(fee); // T:[PS-33]\n    }\n\n    /// @dev Returns quantity of connected credit accounts managers\n    function creditManagersCount() external view override returns (uint256) {\n        return creditManagers.length; // T:[PS-11]\n    }\n}"
    },
    {
      "filename": "contracts/pool/PoolService.sol",
      "content": "// SPDX-License-Identifier: BSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {ACLTrait} from \"../core/ACLTrait.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\n\nimport {IInterestRateModel} from \"../interfaces/IInterestRateModel.sol\";\nimport {IPoolService} from \"../interfaces/IPoolService.sol\";\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\n\nimport {AddressProvider} from \"../core/AddressProvider.sol\";\nimport {DieselToken} from \"../tokens/DieselToken.sol\";\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title Pool Service\n/// @notice Encapsulates business logic for:\n///  - Adding/removing pool liquidity\n///  - Managing diesel tokens & diesel rates\n///  - Lend funds to credit manager\n///\n/// More: https://dev.gearbox.fi/developers/pools/pool-service\ncontract PoolService is IPoolService, ACLTrait, ReentrancyGuard {\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using SafeERC20 for IERC20;\n    using PercentageMath for uint256;\n\n    // Expected liquidity at last update (LU)\n    uint256 public _expectedLiquidityLU;\n\n    // Expected liquidity limit\n    uint256 public override expectedLiquidityLimit;\n\n    // Total borrowed amount: https://dev.gearbox.fi/developers/pools/economy/total-borrowed\n    uint256 public override totalBorrowed;\n\n    // Address repository\n    AddressProvider public addressProvider;\n\n    // Interest rate model\n    IInterestRateModel public interestRateModel;\n\n    // Underlying token address\n    address public override underlyingToken;\n\n    // Diesel(LP) token address\n    address public override dieselToken;\n\n    // Credit managers mapping with permission to borrow / repay\n    mapping(address => bool) public override creditManagersCanBorrow;\n    mapping(address => bool) public creditManagersCanRepay;\n\n    // Credif managers\n    address[] public override creditManagers;\n\n    // Treasury address for tokens\n    address public treasuryAddress;\n\n    // Cumulative index in RAY\n    uint256 public override _cumulativeIndex_RAY;\n\n    // Current borrow rate in RAY: https://dev.gearbox.fi/developers/pools/economy#borrow-apy\n    uint256 public override borrowAPY_RAY;\n\n    // Timestamp of last update\n    uint256 public override _timestampLU;\n\n    // Withdraw fee in PERCENTAGE FORMAT\n    uint256 public override withdrawFee;\n\n    // = PERCENTAGE_AMOUNT - withdrawFee\n    uint256 public withdrawMultiplier;\n\n    //\n    // CONSTRUCTOR\n    //\n\n    /// @dev Constructor\n    /// @param _addressProvider Address Repository for upgradable contract model\n    /// @param _underlyingToken Address of underlying token\n    /// @param _dieselAddress Address of diesel (LP) token\n    /// @param _interestRateModelAddress Address of interest rate model\n    constructor(\n        address _addressProvider,\n        address _underlyingToken,\n        address _dieselAddress,\n        address _interestRateModelAddress\n    ) ACLTrait(_addressProvider) {\n        addressProvider = AddressProvider(_addressProvider);\n        interestRateModel = IInterestRateModel(_interestRateModelAddress);\n        underlyingToken = _underlyingToken;\n        dieselToken = _dieselAddress;\n        treasuryAddress = addressProvider.getTreasuryContract();\n\n        _cumulativeIndex_RAY = WadRayMath.RAY; // T:[PS-5]\n        _updateBorrowRate(); // to set up correct borrow rate at start\n\n        setWithdrawFee(0);\n    }\n\n    //\n    // LIQUIDITY MANAGEMENT\n    //\n\n    /**\n     * @dev Adds liquidity to pool\n     * - Transfers underlying asset to pool\n     * - Mints diesel (LP) token with current diesel rate\n     * - Updates expected liquidity\n     * - Updates borrow rate\n     *\n     * More: https://dev.gearbox.fi/developers/pools/pool-service#addliquidity\n     *\n     * @param amount Amount of tokens to be transfer\n     * @param onBehalfOf The address that will receive the diesel tokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of diesel\n     * tokens is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function addLiquidity(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 referralCode\n    )\n        external\n        override\n        whenNotPaused // T:[PS-4]\n        nonReentrant\n    {\n        require(\n            expectedLiquidity() + amount <= expectedLiquidityLimit,\n            Errors.POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT\n        ); // T:[PS-31]\n\n        IERC20(underlyingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        ); // T:[PS-2, 7]\n\n        DieselToken(dieselToken).mint(onBehalfOf, toDiesel(amount)); // T:[PS-2, 7]\n\n        _expectedLiquidityLU = _expectedLiquidityLU.add(amount); // T:[PS-2, 7]\n        _updateBorrowRate(); // T:[PS-2, 7]\n\n        emit AddLiquidity(msg.sender, onBehalfOf, amount, referralCode); // T:[PS-2, 7]\n    }\n\n    /**\n     * @dev Removes liquidity from pool\n     * - Transfers to LP underlying account = amount * diesel rate\n     * - Burns diesel tokens\n     * - Decreases underlying amount from total_liquidity\n     * - Updates borrow rate\n     *\n     * More: https://dev.gearbox.fi/developers/pools/pool-service#removeliquidity\n     *\n     * @param amount Amount of tokens to be transfer\n     * @param to Address to transfer liquidity\n     */\n    function removeLiquidity(uint256 amount, address to)\n        external\n        override\n        whenNotPaused // T:[PS-4]\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 underlyingTokensAmount = fromDiesel(amount); // T:[PS-3, 8]\n\n        uint256 amountSent = underlyingTokensAmount.percentMul(\n            withdrawMultiplier\n        );\n\n        IERC20(underlyingToken).safeTransfer(to, amountSent); // T:[PS-3, 34]\n        IERC20(underlyingToken).safeTransfer(\n            treasuryAddress,\n            underlyingTokensAmount.percentMul(withdrawFee)\n        ); // T:[PS-3, 34]\n        DieselToken(dieselToken).burn(msg.sender, amount); // T:[PS-3, 8]\n\n        _expectedLiquidityLU = _expectedLiquidityLU.sub(underlyingTokensAmount); // T:[PS-3, 8]\n        _updateBorrowRate(); // T:[PS-3,8 ]\n\n        emit RemoveLiquidity(msg.sender, to, amount); // T:[PS-3, 8]\n\n        return amountSent;\n    }\n\n    /// @dev Returns expected liquidity - the amount of money should be in the pool\n    /// if all users close their Credit accounts and return debt\n    ///\n    /// More: https://dev.gearbox.fi/developers/pools/economy#expected-liquidity\n    function expectedLiquidity() public view override returns (uint256) {\n        // timeDifference = blockTime - previous timeStamp\n        uint256 timeDifference = block.timestamp.sub(uint256(_timestampLU));\n\n        //                                    currentBorrowRate * timeDifference\n        //  interestAccrued = totalBorrow *  ------------------------------------\n        //                                             SECONDS_PER_YEAR\n        //\n        uint256 interestAccrued = totalBorrowed.rayMul(\n            borrowAPY_RAY.mul(timeDifference).div(Constants.SECONDS_PER_YEAR)\n        ); // T:[GM-1]\n\n        return _expectedLiquidityLU.add(interestAccrued); // T:[PS-29]\n    }\n\n    /// @dev Returns available liquidity in the pool (pool balance)\n    /// More: https://dev.gearbox.fi/developers/\n    function availableLiquidity() public view override returns (uint256) {\n        return IERC20(underlyingToken).balanceOf(address(this));\n    }\n\n    //\n    // CREDIT ACCOUNT LENDING\n    //\n\n    /// @dev Lends funds to credit manager and updates the pool parameters\n    /// More: https://dev.gearbox.fi/developers/pools/pool-service#lendcreditAccount\n    ///\n    /// @param borrowedAmount Borrowed amount for credit account\n    /// @param creditAccount Credit account address\n    function lendCreditAccount(uint256 borrowedAmount, address creditAccount)\n        external\n        override\n        whenNotPaused // T:[PS-4]\n    {\n        require(\n            creditManagersCanBorrow[msg.sender],\n            Errors.POOL_CREDIT_MANAGERS_ONLY\n        ); // T:[PS-12, 13]\n\n        // Transfer funds to credit account\n        IERC20(underlyingToken).safeTransfer(creditAccount, borrowedAmount); // T:[PS-14]\n\n        // Update borrow Rate\n        _updateBorrowRate(); // T:[PS-17]\n\n        // Increase total borrowed amount\n        totalBorrowed = totalBorrowed.add(borrowedAmount); // T:[PS-16]\n\n        emit Borrow(msg.sender, creditAccount, borrowedAmount); // T:[PS-15]\n    }\n\n    /// @dev It's called after credit account funds transfer back to pool and updates corretly parameters.\n    /// More: https://dev.gearbox.fi/developers/pools/pool-service#repaycreditAccount\n    ///\n    /// @param borrowedAmount Borrowed amount (without interest accrued)\n    /// @param profit Represents PnL value if PnL > 0\n    /// @param loss Represents PnL value if PnL <0\n    function repayCreditAccount(\n        uint256 borrowedAmount,\n        uint256 profit,\n        uint256 loss\n    )\n        external\n        override\n        whenNotPaused // T:[PS-4]\n    {\n        require(\n            creditManagersCanRepay[msg.sender],\n            Errors.POOL_CREDIT_MANAGERS_ONLY\n        ); // T:[PS-12]\n\n        // For fee surplus we mint tokens for treasury\n        if (profit > 0) {\n            // T:[PS-22] provess that diesel rate will be the same within the margin of error\n            DieselToken(dieselToken).mint(treasuryAddress, toDiesel(profit)); // T:[PS-21, 22]\n            _expectedLiquidityLU = _expectedLiquidityLU.add(profit); // T:[PS-21, 22]\n        }\n        // If returned money < borrowed amount + interest accrued\n        // it tries to compensate loss by burning diesel (LP) tokens\n        // from treasury fund\n        else {\n            uint256 amountToBurn = toDiesel(loss); // T:[PS-19,20]\n\n            uint256 treasuryBalance = DieselToken(dieselToken).balanceOf(\n                treasuryAddress\n            ); // T:[PS-19,20]\n\n            if (treasuryBalance < amountToBurn) {\n                amountToBurn = treasuryBalance;\n                emit UncoveredLoss(\n                    msg.sender,\n                    loss.sub(fromDiesel(treasuryBalance))\n                ); // T:[PS-23]\n            }\n\n            // If treasury has enough funds, it just burns needed amount\n            // to keep diesel rate on the same level\n            DieselToken(dieselToken).burn(treasuryAddress, amountToBurn); // T:[PS-19. 20]\n\n            _expectedLiquidityLU = _expectedLiquidityLU.sub(loss); //T:[PS-19,20]\n        }\n\n        // Update available liquidity\n        _updateBorrowRate(); // T:[PS-19, 20, 21]\n\n        // Reduce total borrowed. Should be after _updateBorrowRate() for correct calculations\n        totalBorrowed = totalBorrowed.sub(borrowedAmount); // T:[PS-19, 20]\n\n        emit Repay(msg.sender, borrowedAmount, profit, loss); // T:[PS-18]\n    }\n\n    //\n    // INTEREST RATE MANAGEMENT\n    //\n\n    /**\n     * @dev Calculates interest accrued from the last update using the linear model\n     *\n     *                                    /     currentBorrowRate * timeDifference \\\n     *  newCumIndex  = currentCumIndex * | 1 + ------------------------------------ |\n     *                                    \\              SECONDS_PER_YEAR          /\n     *\n     * @return current cumulative index in RAY\n     */\n    function calcLinearCumulative_RAY() public view override returns (uint256) {\n        //solium-disable-next-line\n        uint256 timeDifference = block.timestamp.sub(uint256(_timestampLU)); // T:[PS-28]\n\n        return\n            calcLinearIndex_RAY(\n                _cumulativeIndex_RAY,\n                borrowAPY_RAY,\n                timeDifference\n            ); // T:[PS-28]\n    }\n\n    /// @dev Calculate linear index\n    /// @param cumulativeIndex_RAY Current cumulative index in RAY\n    /// @param currentBorrowRate_RAY Current borrow rate in RAY\n    /// @param timeDifference Duration in seconds\n    /// @return newCumulativeIndex Cumulative index accrued duration in Rays\n    function calcLinearIndex_RAY(\n        uint256 cumulativeIndex_RAY,\n        uint256 currentBorrowRate_RAY,\n        uint256 timeDifference\n    ) public pure returns (uint256) {\n        //                                    /     currentBorrowRate * timeDifference \\\n        //  newCumIndex  = currentCumIndex * | 1 + ------------------------------------ |\n        //                                    \\              SECONDS_PER_YEAR          /\n        //\n        uint256 linearAccumulated_RAY = WadRayMath.RAY.add(\n            currentBorrowRate_RAY.mul(timeDifference).div(\n                Constants.SECONDS_PER_YEAR\n            )\n        ); // T:[GM-2]\n\n        return cumulativeIndex_RAY.rayMul(linearAccumulated_RAY); // T:[GM-2]\n    }\n\n    /// @dev Updates Cumulative index when liquidity parameters are changed\n    ///  - compute how much interest were accrued from last update\n    ///  - compute new cumulative index based on updated liquidity parameters\n    ///  - stores new cumulative index and timestamp when it was updated\n    function _updateBorrowRate() internal {\n        // Update total _expectedLiquidityLU\n\n        _expectedLiquidityLU = expectedLiquidity(); // T:[PS-27]\n\n        // Update cumulativeIndex\n        _cumulativeIndex_RAY = calcLinearCumulative_RAY(); // T:[PS-27]\n\n        // update borrow APY\n        borrowAPY_RAY = interestRateModel.calcBorrowRate(\n            _expectedLiquidityLU,\n            availableLiquidity()\n        ); // T:[PS-27]\n        _timestampLU = block.timestamp; // T:[PS-27]\n    }\n\n    //\n    // DIESEL TOKEN MGMT\n    //\n\n    /// @dev Returns current diesel rate in RAY format\n    //"
    }
  ]
}