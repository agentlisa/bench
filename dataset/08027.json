{
  "Title": "[H-05] ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol safeguards can be bypassed by cancelling in-progress proposal allowing the majority to steal NFT",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/proposals/ProposalExecutionEngine.sol#L183-L202\n\n\n# Vulnerability details\n\nNote: PartyDAO acknowledges that \"canceling an InProgress proposal (mid-step) can leave the governance party in a vulnerable or undesirable state because there is no cleanup logic run during a cancel\" in the \"Known Issues / Topics\" section of the contest readme. I still believe that this vulnerability needs to be mitigated as it can directly lead to loss of user funds.\n\n## Impact\n\nMajority vote can abuse cancel functionality to steal an NFT owned by the party\n\n## Proof of Concept\n\nArbitraryCallsProposal.sol implements the following safeguards for arbitrary proposals that are not unanimous:\n\n1. Prevents the ownership of any NFT changing during the call. It does this by checking the the ownership of all NFTs before and after the call.\n\n2. Prevents calls that would change the approval status of any NFT. This is done by disallowing the \"approve\" and \"setApprovalForAll\" function selectors.\n\nAdditionally ListOnOpenseaProposal.sol implements the following safeguards:\n\n1. NFTs are first listed for auction on Zora so that if they are listed for a very low price then the auction will keep them from being purchased at such a low price\n\n2. At the end of the auction the approval is revoked when _cleanUpListing is called\n\nThese safeguards are ultimately ineffective though. The majority could use the following steps to steal the NFT:\n\n1. Create ListOnOpenseaProposal with high sell price and short cancel delay\n\n2. Vote to approve proposal with majority vote\n\n3. Execute first step of proposal, listing NFT on Zora auction for high price\n\n4. Wait for Zora auction to end since the auction price is so high that no one will buy it\n\n5. Execute next step, listing the NFT on Opensea. During this step the contract grants approval of the NFT to the Opensea contract\n\n6. Wait for cancelDelay to expire\n\n7. Call PartyGovernance.sol#cancel. This will immediately terminate the Opensea bypassing _cleanUpListing and keeping the approval to the Opensea contract\n\n8. Create ArbitraryCallsProposal.sol that lists the NFT on Opensea for virtually nothing. Since only approval selectors have been blacklisted and the NFT does not change ownership, the proposal does not need to be unanimous to execute.\n\n9. Approve proposal and execute\n\n10. Buy NFT\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nWhen a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/proposals/ProposalExecutionEngine.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"./ListOnOpenseaProposal.sol\";\nimport \"./ListOnZoraProposal.sol\";\nimport \"./FractionalizeProposal.sol\";\nimport \"./ArbitraryCallsProposal.sol\";\nimport \"./LibProposal.sol\";\nimport \"./ProposalStorage.sol\";\n\n/// @notice Upgradable implementation of proposal execution logic for parties that use it.\n/// @dev This contract will be delegatecall'ed into by `Party` proxy instances.\ncontract ProposalExecutionEngine is\n    IProposalExecutionEngine,\n    Implementation,\n    ProposalStorage,\n    ListOnOpenseaProposal,\n    ListOnZoraProposal,\n    FractionalizeProposal,\n    ArbitraryCallsProposal\n{\n    using LibRawResult for bytes;\n\n    error UnsupportedProposalTypeError(uint32 proposalType);\n\n    // The types of proposals supported.\n    // The first 4 bytes of a proposal's `proposalData` determine the proposal\n    // type.\n    // WARNING: This should be append-only.\n    enum ProposalType {\n        Invalid,\n        ListOnOpensea,\n        ListOnZora,\n        Fractionalize,\n        ArbitraryCalls,\n        UpgradeProposalEngineImpl,\n        // Append new proposal types here.\n        NumProposalTypes\n    }\n\n    // Explicit storage bucket for \"private\" state owned by the `ProposalExecutionEngine`.\n    // See `_getStorage()` for how this is addressed.\n    //\n    // Read this for more context on the pattern motivating this:\n    // https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets\n    struct Storage {\n        // The hash of the next `progressData` for the current `InProgress`\n        // proposal. This is updated to the hash of the next `progressData` every\n        // time a proposal is executed. This enforces that the next call to\n        // `executeProposal()` receives the correct `progressData`.\n        // If there is no current `InProgress` proposal, this will be 0x0.\n        bytes32 nextProgressDataHash;\n        // The proposal ID of the current, in progress proposal being executed.\n        // `InProgress` proposals need to have `executeProposal()` called on them\n        // multiple times until they complete. Only one proposal may be\n        // in progress at a time, meaning no other proposals can be executed\n        // if this value is nonzero.\n        uint256 currentInProgressProposalId;\n    }\n\n    event ProposalEngineImplementationUpgraded(address oldImpl, address newImpl);\n\n    error ZeroProposalIdError();\n    error MalformedProposalDataError();\n    error ProposalExecutionBlockedError(uint256 proposalId, uint256 currentInProgressProposalId);\n    error ProposalProgressDataInvalidError(bytes32 actualProgressDataHash, bytes32 expectedProgressDataHash);\n    error ProposalNotInProgressError(uint256 proposalId);\n    error UnexpectedProposalEngineImplementationError(IProposalExecutionEngine actualImpl, IProposalExecutionEngine expectedImpl);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n    // Storage slot for `Storage`.\n    // Use a constant, non-overlapping slot offset for the storage bucket.\n    uint256 private constant _STORAGE_SLOT = uint256(keccak256('ProposalExecutionEngine.Storage'));\n\n    // Set immutables.\n    constructor(\n        IGlobals globals,\n        IOpenseaExchange seaport,\n        IOpenseaConduitController seaportConduitController,\n        IZoraAuctionHouse zoraAuctionHouse,\n        IFractionalV1VaultFactory fractionalVaultFactory\n    )\n        ListOnOpenseaProposal(globals, seaport, seaportConduitController)\n        ListOnZoraProposal(globals, zoraAuctionHouse)\n        FractionalizeProposal(fractionalVaultFactory)\n    {\n        _GLOBALS = globals;\n    }\n\n    // Used by `Party` to setup the execution engine.\n    // Currently does nothing, but may be changed in future versions.\n    function initialize(address oldImpl, bytes calldata initializeData)\n        external\n        override\n        onlyDelegateCall\n    { /* NOOP */ }\n\n    /// @notice Get the current `InProgress` proposal ID.\n    /// @dev With this version, only one proposal may be in progress at a time.\n    function getCurrentInProgressProposalId()\n        external\n        view\n        returns (uint256 id)\n    {\n        return _getStorage().currentInProgressProposalId;\n    }\n\n    /// @inheritdoc IProposalExecutionEngine\n    function executeProposal(ExecuteProposalParams memory params)\n        external\n        onlyDelegateCall\n        returns (bytes memory nextProgressData)\n    {\n        // Must have a valid proposal ID.\n        if (params.proposalId == 0) {\n            revert ZeroProposalIdError();\n        }\n        Storage storage stor = _getStorage();\n        uint256 currentInProgressProposalId = stor.currentInProgressProposalId;\n        if (currentInProgressProposalId == 0) {\n            // No proposal is currently in progress.\n            // Mark this proposal as the one in progress.\n            stor.currentInProgressProposalId = params.proposalId;\n        } else if (currentInProgressProposalId != params.proposalId) {\n            // Only one proposal can be in progress at a time.\n            revert ProposalExecutionBlockedError(\n                params.proposalId,\n                currentInProgressProposalId\n            );\n        }\n        {\n            bytes32 nextProgressDataHash = stor.nextProgressDataHash;\n            if (nextProgressDataHash == 0) { // Expecting no progress data.\n                // This is the state if there is no current `InProgress` proposal.\n                assert(currentInProgressProposalId == 0);\n                if (params.progressData.length != 0) {\n                    revert ProposalProgressDataInvalidError(\n                        keccak256(params.progressData),\n                        nextProgressDataHash\n                    );\n                }\n            } else { // Expecting progress data.\n                bytes32 progressDataHash = keccak256(params.progressData);\n                // Progress data must match the one stored.\n                if (nextProgressDataHash != progressDataHash) {\n                    revert ProposalProgressDataInvalidError(\n                        progressDataHash,\n                        nextProgressDataHash\n                    );\n                }\n            }\n            // Temporarily set the expected next progress data hash to an\n            // unachievable constant to act as a reentrancy guard.\n            stor.nextProgressDataHash = bytes32(type(uint256).max);\n        }\n\n        // Note that we do not enforce that the proposal has not been executed\n        // (and completed) before in this contract. That is enforced by PartyGovernance.\n\n        // Execute the proposal.\n        ProposalType pt;\n        (pt, params.proposalData) = _extractProposalType(params.proposalData);\n        nextProgressData = _execute(pt, params);\n\n        // If progress data is empty, the proposal is complete.\n        if (nextProgressData.length == 0) {\n            stor.currentInProgressProposalId = 0;\n            stor.nextProgressDataHash = 0;\n        } else {\n            // Remember the next progress data.\n            stor.nextProgressDataHash = keccak256(nextProgressData);\n        }\n    }\n\n    /// @inheritdoc IProposalExecutionEngine\n    function cancelProposal(uint256 proposalId)\n        external\n        onlyDelegateCall\n    {\n        // Must be a valid proposal ID.\n        if (proposalId == 0) {\n            revert ZeroProposalIdError();\n        }\n        Storage storage stor = _getStorage();\n        {\n            // Must be the current InProgress proposal.\n            uint256 currentInProgressProposalId = stor.currentInProgressProposalId;\n            if (currentInProgressProposalId != proposalId) {\n                revert ProposalNotInProgressError(proposalId);\n            }\n        }\n        // Clear the current InProgress proposal ID and next progress data.\n        stor.currentInProgressProposalId = 0;\n        stor.nextProgressDataHash = 0;\n    }\n\n    // Switch statement used to execute the right proposal.\n    function _execute(ProposalType pt, ExecuteProposalParams memory params)\n        internal\n        virtual\n        returns (bytes memory nextProgressData)\n    {\n        if (pt == ProposalType.ListOnOpensea) {\n            nextProgressData = _executeListOnOpensea(params);\n        } else if (pt == ProposalType.ListOnZora) {\n            nextProgressData = _executeListOnZora(params);\n        } else if (pt == ProposalType.Fractionalize) {\n            nextProgressData = _executeFractionalize(params);\n        } else if (pt == ProposalType.ArbitraryCalls) {\n            nextProgressData = _executeArbitraryCalls(params);\n        } else if (pt == ProposalType.UpgradeProposalEngineImpl) {\n            _executeUpgradeProposalsImplementation(params.proposalData);\n        } else {\n            revert UnsupportedProposalTypeError(uint32(pt));\n        }\n    }\n\n    // Destructively pops off the first 4 bytes of `proposalData` to determine\n    // the type. This modifies `proposalData` and returns the updated\n    // pointer to it.\n    function _extractProposalType(bytes memory proposalData)\n        private\n        pure\n        returns (ProposalType proposalType, bytes memory offsetProposalData)\n    {\n        // First 4 bytes is proposal type. While the proposal type could be\n        // stored in just 1 byte, this makes it easier to encode with\n        // `abi.encodeWithSelector`.\n        if (proposalData.length < 4) {\n            revert MalformedProposalDataError();\n        }\n        assembly {\n            // By reading 4 bytes into the length prefix, the leading 4 bytes\n            // of the data will be in the lower bits of the read word.\n            proposalType := and(mload(add(proposalData, 4)), 0xffffffff)\n            mstore(add(proposalData, 4), sub(mload(proposalData), 4))\n            offsetProposalData := add(proposalData, 4)\n        }\n        require(proposalType != ProposalType.Invalid);\n        require(uint8(proposalType) < uint8(ProposalType.NumProposalTypes));\n    }\n\n    // Upgrade implementation to the latest version.\n    function _executeUpgradeProposalsImplementation(bytes memory proposalData)\n        private\n    {\n        (address expectedImpl, bytes memory initData) =\n            abi.decode(proposalData, (address, bytes));\n        // Always upgrade to latest implementation stored in `_GLOBALS`.\n        IProposalExecutionEngine newImpl = IProposalExecutionEngine(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)\n        );\n        if (expectedImpl != address(newImpl)) {\n            revert UnexpectedProposalEngineImplementationError(\n                newImpl,\n                IProposalExecutionEngine(expectedImpl)\n            );\n        }\n        _initProposalImpl(newImpl, initData);\n        emit ProposalEngineImplementationUpgraded(address(IMPL), expectedImpl);\n    }\n\n    // Retrieve the explicit storage bucket for the ProposalExecutionEngine logic.\n    function _getStorage() internal pure returns (Storage storage stor) {\n        uint256 slot = _STORAGE_SLOT;\n        assembly { stor.slot := slot }\n    }\n}"
    }
  ]
}