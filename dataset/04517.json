{
  "Title": "Contract owners can change business logic unnoticeably",
  "Content": "In several contracts, the owner can arbitrarily change the business logic by setting new contract addresses, without properly warning users of those changes. Examples are:\n\n\n* [`RenderToken#setEscrowContractAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L58) :the address that will hold tokens in escrow and keep a ledger of funds available for jobs.\n* [`Escrow#changeRenderTokenAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L55) : the address of the token contract.\n* [`Escrow#changeDisbursalAddress`](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/Escrow.sol#L45) : the address authorized to distribute tokens for completed jobs.\n\n\nConsider emitting events to notify users about any modifications of such importance in the contractsâ€™ business logic.\n\n\n***Update:** events [are](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/RenderToken.sol#L91) [now](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L84) [emitted](https://github.com/jeualvarez/Token-Audit/blob/master/contracts/Escrow.sol#L66) to provide users with a mechanism to track these changes.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RenderToken.sol",
      "content": "pragma solidity ^0.4.14;\n\n// Escrow constract\nimport \"./Escrow.sol\";\nimport \"./MigratableERC20.sol\";\n\n/**\n * @title RenderToken\n * @dev ERC20 mintable token\n * The token will be minted by the crowdsale contract only\n */\ncontract RenderToken is Migratable, MigratableERC20, MintableToken {\n\n  string public constant name = \"Render Token\";\n  string public constant symbol = \"RNDR\";\n  uint8 public constant decimals = 18;\n\n  // The address of the contract that manages job balances. Address is used for forwarding tokens\n  // that come in to fund jobs\n  address public escrowContractAddress;\n\n  /**\n   * @dev Constructor\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   */\n  function initialize(address _owner, address _legacyToken) public isInitializer(\"RenderToken\", \"0\") {\n    MintableToken.initialize(_owner);\n    MigratableERC20.initialize(_legacyToken);\n  }\n\n  /**\n   * @dev Take tokens prior to beginning a job\n   *\n   * This function is called by the artist, and it will transfer tokens\n   * to a separate escrow contract to be held until the job is completed\n   * @param _jobID is the ID of the job used within the ORC backend\n   * @param _amount is the number of RNDR tokens being held in escrow\n   */\n  function holdInEscrow(string _jobID, uint256 _amount) public {\n    require(transfer(escrowContractAddress, _amount));\n    Escrow(escrowContractAddress).fundJob(_jobID, _amount);\n  }\n\n  function _mint(address _to, uint256 _amount) internal {\n    require(_to != address(0));\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Transfer(address(0), _to, _amount);\n  }\n\n  /**\n   * @dev Set the address of the escrow contract\n   *\n   * This will dictate the contract that will hold tokens in escrow and keep\n   * a ledger of funds available for jobs\n   * @param _escrowAddress see escrowContractAddress\n  */\n  function setEscrowContractAddress(address _escrowAddress) public onlyOwner {\n    escrowContractAddress = _escrowAddress;\n  }\n\n}"
    },
    {
      "filename": "contracts/Escrow.sol",
      "content": "pragma solidity ^0.4.18;\n\nimport \"../node_modules/openzeppelin-zos/contracts/token/ERC20/MintableToken.sol\";\n\n/**\n * @title Escrow\n * @dev Escrow contract that works with RNDR token\n * This contract holds tokens while render jobs are being completed\n * and information on token allottment per job\n */\ncontract Escrow is Migratable, Ownable {\n  using SafeMath for uint256;\n\n  // This is a mapping of job IDs to the number of tokens allotted to the job\n  mapping(string => uint256) jobBalances;\n  // This is the address of the render token contract\n  address public renderTokenAddress;\n  // This is the address with authority to call the disburseJob function\n  address public disbursalAddress;\n\n  // Emit the jobId along with the new balance of the job\n  // Used on job creation, additional funding added to jobs, and job disbursal\n  // Internal systems for assigning jobs will watch this event to determine balances available\n  event JobBalanceUpdate (string _jobId, uint256 _balance);\n\n  /**\n   * @dev Constructor\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   * @param _renderTokenAddress see renderTokenAddress\n   */\n  function initialize (address _owner, address _renderTokenAddress) public isInitializer(\"Escrow\", \"0\") {\n    Ownable.initialize(_owner);\n    disbursalAddress = _owner;\n    renderTokenAddress = _renderTokenAddress;\n  }\n\n  /**\n   * @dev Change the address authorized to distribute tokens for completed jobs\n   *\n   * Because there are no on-chain details to indicate who performed a render, an outside\n   * system must call the disburseJob function with the information needed to properly\n   * distribute tokens. This function updates the address with the authority to perform distributions\n   * @param _newDisbursalAddress see disbursalAddress\n   */\n  function changeDisbursalAddress(address _newDisbursalAddress) public onlyOwner {\n    disbursalAddress = _newDisbursalAddress;\n  }\n\n  /**\n   * @dev Change the address allowances will be sent to after job completion\n   *\n   * Ideally, this will not be used, but is included as a failsafe\n   * @param _newRenderTokenAddress see renderTokenAddress\n   */\n  function changeRenderTokenAddress(address _newRenderTokenAddress) public onlyOwner {\n    renderTokenAddress = _newRenderTokenAddress;\n  }\n\n  /**\n   * @dev Send allowances to node(s) that performed a job\n   *\n   * This can only be called by the disbursalAddress, an accound owned\n   * by OTOY, and it provides the number of tokens to send to each node\n   * @param _jobId the ID of the job used in the jobBalances mapping\n   * @param _recipients the address(es) of the nodes that performed rendering\n   * @param _amounts the amount(s) to send to each address. These must be in the same\n   * order as the recipient addresses\n   */\n  function disburseJob(string _jobId, address[] _recipients, uint256[] _amounts) public canDisburse {\n    require(jobBalances[_jobId] > 0);\n\n    for(uint i = 0; i < _recipients.length; i++) {\n      jobBalances[_jobId] = jobBalances[_jobId].sub(_amounts[i]);\n      StandardToken(renderTokenAddress).increaseApproval(_recipients[i], _amounts[i]);\n    }\n\n    emit JobBalanceUpdate(_jobId, jobBalances[_jobId]);\n  }\n\n  /**\n   * @dev Add RNDR tokens to a job\n   *\n   * This can only be called by a function on the RNDR token contract\n   * @param _jobId the ID of the job used in the jobBalances mapping\n   * @param _tokens the number of tokens sent by the artist to fund the job\n   */\n  function fundJob(string _jobId, uint256 _tokens) public {\n    // Jobs can only be created through the RNDR contract\n    require(msg.sender == renderTokenAddress);\n\n    jobBalances[_jobId] = jobBalances[_jobId].add(_tokens);\n\n    emit JobBalanceUpdate(_jobId, jobBalances[_jobId]);\n  }\n\n  /**\n   * @dev See the tokens available for a job\n   *\n   * @param _jobId the ID used to lookup the job balance\n   */\n  function jobBalance(string _jobId) public view returns(uint256) {\n    return jobBalances[_jobId];\n  }\n\n  /**\n   * @dev Modifier to check if the message sender can call the disburseJob function\n   */\n  modifier canDisburse() {\n    require(msg.sender == disbursalAddress);\n    _;\n  }\n\n}"
    },
    {
      "filename": "contracts/Escrow.sol",
      "content": "pragma solidity ^0.4.18;\n\nimport \"../node_modules/openzeppelin-zos/contracts/token/ERC20/MintableToken.sol\";\n\n/**\n * @title Escrow\n * @dev Escrow contract that works with RNDR token\n * This contract holds tokens while render jobs are being completed\n * and information on token allottment per job\n */\ncontract Escrow is Migratable, Ownable {\n  using SafeMath for uint256;\n\n  // This is a mapping of job IDs to the number of tokens allotted to the job\n  mapping(string => uint256) jobBalances;\n  // This is the address of the render token contract\n  address public renderTokenAddress;\n  // This is the address with authority to call the disburseJob function\n  address public disbursalAddress;\n\n  // Emit the jobId along with the new balance of the job\n  // Used on job creation, additional funding added to jobs, and job disbursal\n  // Internal systems for assigning jobs will watch this event to determine balances available\n  event JobBalanceUpdate (string _jobId, uint256 _balance);\n\n  /**\n   * @dev Constructor\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   * @param _renderTokenAddress see renderTokenAddress\n   */\n  function initialize (address _owner, address _renderTokenAddress) public isInitializer(\"Escrow\", \"0\") {\n    Ownable.initialize(_owner);\n    disbursalAddress = _owner;\n    renderTokenAddress = _renderTokenAddress;\n  }\n\n  /**\n   * @dev Change the address authorized to distribute tokens for completed jobs\n   *\n   * Because there are no on-chain details to indicate who performed a render, an outside\n   * system must call the disburseJob function with the information needed to properly\n   * distribute tokens. This function updates the address with the authority to perform distributions\n   * @param _newDisbursalAddress see disbursalAddress\n   */\n  function changeDisbursalAddress(address _newDisbursalAddress) public onlyOwner {\n    disbursalAddress = _newDisbursalAddress;\n  }\n\n  /**\n   * @dev Change the address allowances will be sent to after job completion\n   *\n   * Ideally, this will not be used, but is included as a failsafe\n   * @param _newRenderTokenAddress see renderTokenAddress\n   */\n  function changeRenderTokenAddress(address _newRenderTokenAddress) public onlyOwner {\n    renderTokenAddress = _newRenderTokenAddress;\n  }\n\n  /**\n   * @dev Send allowances to node(s) that performed a job\n   *\n   * This can only be called by the disbursalAddress, an accound owned\n   * by OTOY, and it provides the number of tokens to send to each node\n   * @param _jobId the ID of the job used in the jobBalances mapping\n   * @param _recipients the address(es) of the nodes that performed rendering\n   * @param _amounts the amount(s) to send to each address. These must be in the same\n   * order as the recipient addresses\n   */\n  function disburseJob(string _jobId, address[] _recipients, uint256[] _amounts) public canDisburse {\n    require(jobBalances[_jobId] > 0);\n\n    for(uint i = 0; i < _recipients.length; i++) {\n      jobBalances[_jobId] = jobBalances[_jobId].sub(_amounts[i]);\n      StandardToken(renderTokenAddress).increaseApproval(_recipients[i], _amounts[i]);\n    }\n\n    emit JobBalanceUpdate(_jobId, jobBalances[_jobId]);\n  }\n\n  /**\n   * @dev Add RNDR tokens to a job\n   *\n   * This can only be called by a function on the RNDR token contract\n   * @param _jobId the ID of the job used in the jobBalances mapping\n   * @param _tokens the number of tokens sent by the artist to fund the job\n   */\n  function fundJob(string _jobId, uint256 _tokens) public {\n    // Jobs can only be created through the RNDR contract\n    require(msg.sender == renderTokenAddress);\n\n    jobBalances[_jobId] = jobBalances[_jobId].add(_tokens);\n\n    emit JobBalanceUpdate(_jobId, jobBalances[_jobId]);\n  }\n\n  /**\n   * @dev See the tokens available for a job\n   *\n   * @param _jobId the ID used to lookup the job balance\n   */\n  function jobBalance(string _jobId) public view returns(uint256) {\n    return jobBalances[_jobId];\n  }\n\n  /**\n   * @dev Modifier to check if the message sender can call the disburseJob function\n   */\n  modifier canDisburse() {\n    require(msg.sender == disbursalAddress);\n    _;\n  }\n\n}"
    },
    {
      "filename": "contracts/RenderToken.sol",
      "content": "pragma solidity ^0.4.24;\n\n// Escrow constract\nimport { Escrow } from \"./Escrow.sol\";\nimport { Migratable } from \"../node_modules/zos-lib/contracts/migrations/Migratable.sol\";\nimport { MigratableERC20 } from \"./MigratableERC20.sol\";\nimport { Ownable } from \"../node_modules/openzeppelin-zos/contracts/ownership/Ownable.sol\";\nimport { StandardToken } from \"../node_modules/openzeppelin-zos/contracts/token/ERC20/StandardToken.sol\";\n\n/**\n * @title RenderToken\n * @dev ERC20 mintable token\n * The token will be minted by the crowdsale contract only\n */\ncontract RenderToken is Migratable, MigratableERC20, Ownable, StandardToken {\n\n  string public constant name = \"Render Token\";\n  string public constant symbol = \"RNDR\";\n  uint8 public constant decimals = 18;\n\n  // The address of the contract that manages job balances. Address is used for forwarding tokens\n  // that come in to fund jobs\n  address public escrowContractAddress;\n\n  // Emit new contract address when escrowContractAddress has been changed\n  event EscrowContractAddressUpdate(address escrowContractAddress);\n  // Emit information related to tokens being escrowed\n  event TokensEscrowed(address indexed sender, string jobId, uint256 amount);\n  // Emit information related to legacy tokens being migrated\n  event TokenMigration(address indexed receiver, uint256 amount);\n\n  /**\n   * @dev Initailization\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   */\n  function initialize(address _owner, address _legacyToken) public isInitializer(\"RenderToken\", \"0\") {\n    require(_owner != address(0), \"_owner must not be null\");\n    require(_legacyToken != address(0), \"_legacyToken must not be null\");\n    Ownable.initialize(_owner);\n    MigratableERC20.initialize(_legacyToken);\n  }\n\n  /**\n   * @dev Take tokens prior to beginning a job\n   *\n   * This function is called by the artist, and it will transfer tokens\n   * to a separate escrow contract to be held until the job is completed\n   * @param _jobID is the ID of the job used within the ORC backend\n   * @param _amount is the number of RNDR tokens being held in escrow\n   */\n  function holdInEscrow(string _jobID, uint256 _amount) public {\n    require(transfer(escrowContractAddress, _amount), \"token transfer to escrow address failed\");\n    Escrow(escrowContractAddress).fundJob(_jobID, _amount);\n\n    emit TokensEscrowed(msg.sender, _jobID, _amount);\n  }\n\n  /**\n   * @dev Mints new tokens equal to the amount of legacy tokens burned\n   *\n   * This function is called internally, but triggered by a user choosing to\n   * migrate their balance.\n   * @param _to is the address tokens will be sent to\n   * @param _amount is the number of RNDR tokens being sent to the address\n   */\n  function _mintMigratedTokens(address _to, uint256 _amount) internal {\n    require(_to != address(0), \"_to address must not be null\");\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n\n    emit TokenMigration(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n  }\n\n  /**\n   * @dev Set the address of the escrow contract\n   *\n   * This will dictate the contract that will hold tokens in escrow and keep\n   * a ledger of funds available for jobs.\n   * RNDR is still in its infancy, and changes may need to be made to this\n   * contract and / or the escrow contract. Including methods to update the\n   * addresses allows the contracts to update independently.\n   * If the escrow contract is ever migrated to another address for\n   * either added security or functionality, this will need to be called.\n   * @param _escrowAddress see escrowContractAddress\n   */\n  function setEscrowContractAddress(address _escrowAddress) public onlyOwner {\n    require(_escrowAddress != address(0), \"_escrowAddress must not be null\");\n    escrowContractAddress = _escrowAddress;\n\n    emit EscrowContractAddressUpdate(escrowContractAddress);\n  }\n\n}"
    }
  ]
}