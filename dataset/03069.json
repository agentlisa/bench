{
  "Title": "Events lack previous values",
  "Content": "There are a couple instances of events which are emitted when the state of the contract is changed. Among these events, some only record the new value and omit recording the previous value.\n\n\nHere are instances of this issue:\n\n\n* [`event EIP712`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/IBuyNowBase.sol#L67)\n* [`event PaymentWindow`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/IBuyNowBase.sol#L74)\n* [`event OnlyUserCanWithdraw`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/buyNow/base/IBuyNowBase.sol#L91)\n* [`event DefaultFeesCollector`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/FeesCollectors.sol#L25)\n* [`event UniverseFeesCollector`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/FeesCollectors.sol#L32)\n* [`event DefaultOperator`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/Operators.sol#L28)\n* [`event UniverseOperator`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/roles/Operators.sol#L35)\n* [`event DefaultAuctionConfig`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/IAuctionBase.sol#L88-L92)\n* [`event UniverseAuctionConfig`](https://github.com/freeverseio/crypto-payments/blob/956a98e53ef540f7b2b40f3b923d0b0e3e5d32ef/contracts/auction/base/IAuctionBase.sol#L105-L110)\n\n\nWhen using events to record state changes, it is recommended to record the previous value as well to document the entirety of the change. Consider including the previous state to any event that changes the state of the contract.\n\n\n***Update**: Fixed with commit `6e02cc3` of [PR#14](https://github.com/freeverseio/crypto-payments/pull/14).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/buyNow/base/IBuyNowBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\nimport \"./ISignableStructsBuyNow.sol\";\n\n/**\n * @title Interface to base Escrow Contract for Payments in BuyNow mode.\n * @author Freeverse.io, www.freeverse.io\n * @dev The contract that implements this interface only operates the BuyNow path of a payment;\n * it derives from previously audited code, except for minimal method name changes and\n * several methods changed from 'private' to 'internal'\n * The contract that implements this interface can be inherited to:\n * - conduct buyNows in either native crypto or ERC20 tokens\n * - add more elaborated payment processes (such as Auctions)\n *\n * The contract that implements this interface operates as an escrow\n * for paying for assets in BuyNow mode: the first buyer that\n * executes the buyNow method gets the asset.\n *\n * ROLES: Buyers/bidders explicitly sign the agreement to let the specified Operator address\n * act as an Oracle, responsible for signing the success or failure of the asset transfer,\n * which is conducted outside this contract upon reception of funds.\n *\n * If no confirmation is received from the Operator during the PaymentWindow,\n * all funds received from the buyer are made available to him/her for refund.\n * Throughout the contract, this moment is labeled as 'expirationTime'.\n *\n * To start a payment, signatures of both the buyer and the Operator are required, and they\n * are checked in the contracts that inherit from this one.\n *\n * The contract that implements this interface maintains the balances of all users,\n * which can be withdrawn via explicit calls to the various 'withdraw' methods.\n * If a buyer has a non-zero local balance at the moment of starting a new payment,\n * the contract reuses it, and only requires the provision of the remainder funds required (if any).\n *\n * Each BuyNow has the following State Machine:\n * - NOT_STARTED -> ASSET_TRANSFERRING, triggered by buyNow\n * - ASSET_TRANSFERRING -> PAID, triggered by relaying assetTransferSuccess signed by Operator\n * - ASSET_TRANSFERRING -> REFUNDED, triggered by relaying assetTransferFailed signed by Operator\n * - ASSET_TRANSFERRING -> REFUNDED, triggered by a refund request after expirationTime\n *\n * NOTE: To ensure that the payment process proceeds as expected when the payment starts,\n * upon acceptance of a payment, the following data: {operator, feesCollector, expirationTime}\n * is stored in the payment struct, and used throughout the payment, regardless of\n * any possible modifications to the contract's storage.\n *\n * NOTE: The contract allows a feature, 'Seller Registration', that can be used in the scenario that\n * applications want users to prove that they have enough crypto know-how (obtain native crypto,\n * pay for gas using a web3 wallet, etc.) to interact by themselves with this smart contract before selling,\n * so that they are less likely to require technical help in case they need to withdraw funds.\n * - If _isSellerRegistrationRequired = true, this feature is enabled, and payments can only be initiated\n *    if the payment seller has previously executed the registerAsSeller method.\n * - If _isSellerRegistrationRequired = false, this feature is disabled, and payments can be initiated\n *    regardless of any previous call to the registerAsSeller method.\n *\n * NOTE: Following audits suggestions, the EIP712 contract, which uses OpenZeppelin's implementation,\n * is not inherited; it is separately deployed, so that it can be upgraded should the standard evolve in the future.\n *\n */\n\ninterface IBuyNowBase is ISignableStructsBuyNow {\n    /**\n     * @dev Event emitted on change of EIP712 verifier contract address\n     * @param eip712address The address of the new EIP712 verifier contract\n     */\n\n    event EIP712(address eip712address);\n\n    /**\n     * @dev Event emitted on change of payment window\n     * @param window The new amount of time after the arrival of a payment for which,\n     *  in absence of confirmation of asset transfer success, a buyer is allowed to refund\n     */\n    event PaymentWindow(uint256 window);\n\n    /**\n     * @dev Event emitted when a user executes the registerAsSeller method\n     * @param seller The address of the newly registeredAsSeller user.\n     */\n    event NewSeller(address indexed seller);\n\n    /**\n     * @dev Event emitted when a user sets a value of onlyUserCanWithdraw\n     *  - if true: only the user can execute withdrawals of his/her local balance\n     *  - if false: any address can help and execute the withdrawals on behalf of the user\n     *   (the funds still go straight to the user, but the helper address covers gas costs\n     *    and the hassle of executing the transaction)\n     * @param user The address of the user.\n     * @param onlyUserCanWithdraw true if only the user can execute withdrawals of his/her local balance\n     */\n    event OnlyUserCanWithdraw(address indexed user, bool onlyUserCanWithdraw);\n\n    /**\n     * @dev Event emitted when a buyer is refunded for a given payment process\n     * @param paymentId The id of the already initiated payment\n     * @param buyer The address of the refunded buyer\n     */\n    event BuyerRefunded(bytes32 indexed paymentId, address indexed buyer);\n\n    /**\n     * @dev Event emitted when funds for a given payment arrive to this contract\n     * @param paymentId The unique id identifying the payment\n     * @param buyer The address of the buyer providing the funds\n     * @param seller The address of the seller of the asset\n     */\n    event BuyNow(\n        bytes32 indexed paymentId,\n        address indexed buyer,\n        address indexed seller\n    );\n\n    /**\n     * @dev Event emitted when a payment process arrives at the PAID\n     *  final state, where the seller receives the funds.\n     * @param paymentId The id of the already initiated payment\n     */\n    event Paid(bytes32 indexed paymentId);\n\n    /**\n     * @dev Event emitted when user withdraws funds from this contract\n     * @param user The address of the user that withdraws\n     * @param amount The amount withdrawn, in lowest units of the currency\n     */\n    event Withdraw(address indexed user, uint256 amount);\n\n    /**\n     * @dev The enum characterizing the possible states of an payment process\n     */\n    enum State {\n        NotStarted,\n        AssetTransferring,\n        Refunded,\n        Paid,\n        Auctioning\n    }\n\n    /**\n     * @notice Main struct stored with every payment.\n     *  All variables of the struct remain immutable throughout a payment process\n     *  except for `state`.\n     */\n    struct Payment {\n        // the current state of the payment process\n        State state;\n\n        // the buyer, providing the required funds, who shall receive\n        // the asset on a successful payment.\n        address buyer;\n\n        // the seller of the asset, who shall receive the funds\n        // (subtracting fees) on a successful payment.        \n        address seller;\n\n        // The address of the operator of this payment\n        address operator;\n\n        // The address of the feesCollector of this payment\n        address feesCollector;\n\n        // The timestamp after which, in absence of confirmation of \n        // asset transfer success, a buyer is allowed to refund\n        uint256 expirationTime;\n\n        // the percentage fee expressed in Basis Points (bps), typical in finance\n        // Examples:  2.5% = 250 bps, 10% = 1000 bps, 100% = 10000 bps\n        uint256 feeBPS;\n\n        // the price of the asset, an integer expressed in the\n        // lowest unit of the currency.\n        uint256 amount;\n    }\n\n    /**\n     * @notice Registers msg.sender as seller so that, if the contract has set\n     *  _isSellerRegistrationRequired = true, then payments will be accepted with\n     *  msg.sender as seller.\n    */\n    function registerAsSeller() external;\n\n    /**\n     * @notice Sets the value of onlyUserCanWithdraw for the user with msg.sender address:\n     *  - if true: only the user can execute withdrawals of his/her local balance\n     *  - if false: any address can help and execute the withdrawals on behalf of the user\n     *   (the funds still go straight to the user, but the helper address covers gas costs\n     *    and the hassle of executing the transaction)\n     * @param onlyUserCan true if only the user can execute withdrawals of his/her local balance\n     */\n    function setOnlyUserCanWithdraw(bool onlyUserCan) external;\n\n    /**\n     * @notice Relays the operator signature declaring that the asset transfer was successful or failed,\n     *  and updates local balances of seller or buyer, respectively.\n     * @dev Can be executed by anyone, but the operator signature must be included as input param.\n     *  Seller or Buyer's local balances are updated, allowing explicit withdrawal.\n     *  Moves payment to PAID or REFUNDED state on transfer success/failure, respectively.\n     * @param transferResult The asset transfer result struct signed by the operator.\n     * @param operatorSignature The operator signature of transferResult\n     */\n    function finalize(\n        AssetTransferResult calldata transferResult,\n        bytes calldata operatorSignature\n    ) external;\n\n    /**\n     * @notice Relays the operator signature declaring that the asset transfer was successful or failed,\n     *  updates balances of seller or buyer, respectively, and proceeds to withdraw all funds \n     *  in this contract available to the rightful recipient of the paymentId: \n     *  the seller if transferResult.wasSuccessful == true, the buyer otherwise.\n     * @dev If recipient has set onlyUserCanWithdraw == true, then msg.sender must the the recipient;\n     *  otherwise, anyone can execute this method, with funds arriving to the recipient too, but with a\n     *  helping 3rd party covering gas costs and TX sending hassle.\n     *  The operator signature must be included as input param.\n     *  Moves payment to PAID or REFUNDED state on transfer success/failure, respectively.\n     * @param transferResult The asset transfer result struct signed by the operator.\n     * @param operatorSignature The operator signature of transferResult\n     */\n    function finalizeAndWithdraw(\n        AssetTransferResult calldata transferResult,\n        bytes calldata operatorSignature\n    ) external;\n\n    /**\n     * @notice Moves buyer's provided funds to buyer's balance.\n     * @dev Anybody can call this function.\n     *  Requires acceptsRefunds == true to proceed.\n     *  After updating buyer's balance, he/she can later withdraw.\n     *  Moves payment to REFUNDED state.\n     * @param paymentId The unique ID that identifies the payment.\n     */\n    function refund(bytes32 paymentId) external;\n\n    /**\n     * @notice Executes refund and withdraw to the buyer in one transaction.\n     * @dev If the buyer has set onlyUserCanWithdraw == true, then msg.sender must the the recipient;\n     *  otherwise, anyone can execute this method, with funds arriving to the buyer too, but with a\n     *  helping 3rd party covering gas costs and TX sending hassle.\n     *  Requires acceptsRefunds == true to proceed.\n     *  All of msg.sender's balance in the contract is withdrawn,\n     *  not only the part that was locked in this particular paymentId\n     *  Moves payment to REFUNDED state.\n     * @param paymentId The unique ID that identifies the payment.\n     */\n    function refundAndWithdraw(bytes32 paymentId) external;\n\n    /**\n     * @notice Transfers funds avaliable in this\n     *  contract's balanceOf[msg.sender] to msg.sender\n     */\n    function withdraw() external;\n\n    /**\n     * @notice Transfers funds avaliable in this\n     *  contract's balanceOf[recipient] to recipient.\n     *  The funds still go to straight the recipient, as if he/she\n     *  has executed the withdrawal() method, but the msg.sender\n     *  covers gas costs and the hassle of executing the transaction.\n     *  Users can always opt out from this feature, using the setOnlyUserCanWithdraw method.\n     */\n    function withdrawTo(address recipient) external;\n\n    /**\n     * @notice Transfers only the specified amount\n     *  from this contract's balanceOf[msg.sender] to msg.sender.\n     *  Reverts if balanceOf[msg.sender] < amount.\n     * @param amount The required amount to withdraw\n     */\n    function withdrawAmount(uint256 amount) external;\n\n    // VIEW FUNCTIONS\n\n    /**\n     * @notice Returns whether sellers need to be registered to be able to accept payments\n     * @return Returns true if sellers need to be registered to be able to accept payments\n     */\n    function isSellerRegistrationRequired() external view returns (bool);\n\n    /**\n     * @notice Returns true if the address provided is a registered seller\n     * @param addr the address that is queried\n     * @return Returns whether the address is registered as seller\n     */\n    function isRegisteredSeller(address addr) external view returns (bool);\n\n    /**\n     * @notice Returns the local balance of the provided address that is stored in this\n     *  contract, and hence, available for withdrawal.\n     * @param addr the address that is queried\n     * @return the local balance\n     */\n    function balanceOf(address addr) external view returns (uint256);\n\n    /**\n     * @notice Returns all data stored in a payment\n     * @param paymentId The unique ID that identifies the payment.\n     * @return the struct stored for the payment\n     */\n    function paymentInfo(bytes32 paymentId)\n        external\n        view\n        returns (Payment memory);\n\n    /**\n     * @notice Returns the state of a payment.\n     * @dev If payment is in ASSET_TRANSFERRING, it may be worth\n     *  checking acceptsRefunds to check if it has gone beyond expirationTime.\n     * @param paymentId The unique ID that identifies the payment.\n     * @return the state of the payment.\n     */\n    function paymentState(bytes32 paymentId) external view returns (State);\n\n    /**\n     * @notice Returns true if the payment accepts a refund to the buyer\n     * @dev The payment must be in ASSET_TRANSFERRING and beyond expirationTime.\n     * @param paymentId The unique ID that identifies the payment.\n     * @return true if the payment accepts a refund to the buyer.\n     */\n    function acceptsRefunds(bytes32 paymentId) external view returns (bool);\n\n    /**\n     * @notice Returns the address of the of the contract containing\n     *  the implementation of the EIP712 verifying functions\n     * @return the address of the EIP712 verifier contract\n     */\n    function EIP712Address() external view returns (address);\n\n    /**\n     * @notice Returns the amount of seconds that a payment\n     *  can remain in ASSET_TRANSFERRING state without positive\n     *  or negative confirmation by the operator\n     * @return the payment window in secs\n     */\n    function paymentWindow() external view returns (uint256);\n\n    /**\n     * @notice Returns a descriptor about the currency that this contract accepts\n     * @return the string describing the currency\n     */\n    function acceptedCurrency() external view returns (string memory);\n\n    /**\n     * @notice Splits the funds required to provide 'amount' into two sources:\n     *  - externalFunds: the funds required to be transferred from the external buyer balance\n     *  - localFunds: the funds required from the buyer's already available balance in this contract.\n     * @param buyer The address for which the amount is to be split\n     * @param amount The amount to be split\n     * @return externalFunds The funds required to be transferred from the external buyer balance\n     * @return localFunds The amount of local funds that will be used.\n     */\n    function splitFundingSources(address buyer, uint256 amount)\n        external\n        view\n        returns (uint256 externalFunds, uint256 localFunds);\n\n    /**\n     * @notice Returns true if the 'amount' required for a payment is available to this contract.\n     * @dev In more detail: returns true if the sum of the buyer's local balance in this contract,\n     *  plus the external available balance, is larger or equal than 'amount'\n     * @param buyer The address for which funds are queried\n     * @param amount The amount that is queried\n     * @return Returns true if enough funds are available\n     */\n    function enoughFundsAvailable(address buyer, uint256 amount)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the maximum amount of funds available to a buyer\n     * @dev In more detail: returns the sum of the buyer's local balance in this contract,\n     *  plus the available external balance.\n     * @param buyer The address for which funds are queried\n     * @return the max funds available\n     */\n    function maxFundsAvailable(address buyer) external view returns (uint256);\n\n    /**\n     * @notice Reverts unless the requirements for a BuyNowInput are fulfilled.\n     * @param buyNowInp The BuyNowInput struct\n     */\n    function assertBuyNowInputsOK(BuyNowInput calldata buyNowInp) external view;\n\n    /**\n     * @notice Returns the value of onlyUserCanWithdraw for a given user\n     * @param user The address of the user\n     */\n    function onlyUserCanWithdraw(address user) external view returns (bool);\n\n    // PURE FUNCTIONS\n\n    /**\n     * @notice Safe computation of fee amount for a provided amount, feeBPS pair\n     * @dev Must return a value that is guaranteed to be less or equal to the provided amount\n     * @param amount The amount\n     * @param feeBPS The percentage fee expressed in Basis Points (bps).\n     *  feeBPS examples:  2.5% = 250 bps, 10% = 1000 bps, 100% = 10000 bps\n     * @return The fee amount\n     */\n    function computeFeeAmount(uint256 amount, uint256 feeBPS)\n        external\n        pure\n        returns (uint256);\n}"
    },
    {
      "filename": "contracts/buyNow/base/IBuyNowBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\nimport \"./ISignableStructsBuyNow.sol\";\n\n/**\n * @title Interface to base Escrow Contract for Payments in BuyNow mode.\n * @author Freeverse.io, www.freeverse.io\n * @dev The contract that implements this interface only operates the BuyNow path of a payment;\n * it derives from previously audited code, except for minimal method name changes and\n * several methods changed from 'private' to 'internal'\n * The contract that implements this interface can be inherited to:\n * - conduct buyNows in either native crypto or ERC20 tokens\n * - add more elaborated payment processes (such as Auctions)\n *\n * The contract that implements this interface operates as an escrow\n * for paying for assets in BuyNow mode: the first buyer that\n * executes the buyNow method gets the asset.\n *\n * ROLES: Buyers/bidders explicitly sign the agreement to let the specified Operator address\n * act as an Oracle, responsible for signing the success or failure of the asset transfer,\n * which is conducted outside this contract upon reception of funds.\n *\n * If no confirmation is received from the Operator during the PaymentWindow,\n * all funds received from the buyer are made available to him/her for refund.\n * Throughout the contract, this moment is labeled as 'expirationTime'.\n *\n * To start a payment, signatures of both the buyer and the Operator are required, and they\n * are checked in the contracts that inherit from this one.\n *\n * The contract that implements this interface maintains the balances of all users,\n * which can be withdrawn via explicit calls to the various 'withdraw' methods.\n * If a buyer has a non-zero local balance at the moment of starting a new payment,\n * the contract reuses it, and only requires the provision of the remainder funds required (if any).\n *\n * Each BuyNow has the following State Machine:\n * - NOT_STARTED -> ASSET_TRANSFERRING, triggered by buyNow\n * - ASSET_TRANSFERRING -> PAID, triggered by relaying assetTransferSuccess signed by Operator\n * - ASSET_TRANSFERRING -> REFUNDED, triggered by relaying assetTransferFailed signed by Operator\n * - ASSET_TRANSFERRING -> REFUNDED, triggered by a refund request after expirationTime\n *\n * NOTE: To ensure that the payment process proceeds as expected when the payment starts,\n * upon acceptance of a payment, the following data: {operator, feesCollector, expirationTime}\n * is stored in the payment struct, and used throughout the payment, regardless of\n * any possible modifications to the contract's storage.\n *\n * NOTE: The contract allows a feature, 'Seller Registration', that can be used in the scenario that\n * applications want users to prove that they have enough crypto know-how (obtain native crypto,\n * pay for gas using a web3 wallet, etc.) to interact by themselves with this smart contract before selling,\n * so that they are less likely to require technical help in case they need to withdraw funds.\n * - If _isSellerRegistrationRequired = true, this feature is enabled, and payments can only be initiated\n *    if the payment seller has previously executed the registerAsSeller method.\n * - If _isSellerRegistrationRequired = false, this feature is disabled, and payments can be initiated\n *    regardless of any previous call to the registerAsSeller method.\n *\n * NOTE: Following audits suggestions, the EIP712 contract, which uses OpenZeppelin's implementation,\n * is not inherited; it is separately deployed, so that it can be upgraded should the standard evolve in the future.\n *\n */\n\ninterface IBuyNowBase is ISignableStructsBuyNow {\n    /**\n     * @dev Event emitted on change of EIP712 verifier contract address\n     * @param eip712address The address of the new EIP712 verifier contract\n     */\n\n    event EIP712(address eip712address);\n\n    /**\n     * @dev Event emitted on change of payment window\n     * @param window The new amount of time after the arrival of a payment for which,\n     *  in absence of confirmation of asset transfer success, a buyer is allowed to refund\n     */\n    event PaymentWindow(uint256 window);\n\n    /**\n     * @dev Event emitted when a user executes the registerAsSeller method\n     * @param seller The address of the newly registeredAsSeller user.\n     */\n    event NewSeller(address indexed seller);\n\n    /**\n     * @dev Event emitted when a user sets a value of onlyUserCanWithdraw\n     *  - if true: only the user can execute withdrawals of his/her local balance\n     *  - if false: any address can help and execute the withdrawals on behalf of the user\n     *   (the funds still go straight to the user, but the helper address covers gas costs\n     *    and the hassle of executing the transaction)\n     * @param user The address of the user.\n     * @param onlyUserCanWithdraw true if only the user can execute withdrawals of his/her local balance\n     */\n    event OnlyUserCanWithdraw(address indexed user, bool onlyUserCanWithdraw);\n\n    /**\n     * @dev Event emitted when a buyer is refunded for a given payment process\n     * @param paymentId The id of the already initiated payment\n     * @param buyer The address of the refunded buyer\n     */\n    event BuyerRefunded(bytes32 indexed paymentId, address indexed buyer);\n\n    /**\n     * @dev Event emitted when funds for a given payment arrive to this contract\n     * @param paymentId The unique id identifying the payment\n     * @param buyer The address of the buyer providing the funds\n     * @param seller The address of the seller of the asset\n     */\n    event BuyNow(\n        bytes32 indexed paymentId,\n        address indexed buyer,\n        address indexed seller\n    );\n\n    /**\n     * @dev Event emitted when a payment process arrives at the PAID\n     *  final state, where the seller receives the funds.\n     * @param paymentId The id of the already initiated payment\n     */\n    event Paid(bytes32 indexed paymentId);\n\n    /**\n     * @dev Event emitted when user withdraws funds from this contract\n     * @param user The address of the user that withdraws\n     * @param amount The amount withdrawn, in lowest units of the currency\n     */\n    event Withdraw(address indexed user, uint256 amount);\n\n    /**\n     * @dev The enum characterizing the possible states of an payment process\n     */\n    enum State {\n        NotStarted,\n        AssetTransferring,\n        Refunded,\n        Paid,\n        Auctioning\n    }\n\n    /**\n     * @notice Main struct stored with every payment.\n     *  All variables of the struct remain immutable throughout a payment process\n     *  except for `state`.\n     */\n    struct Payment {\n        // the current state of the payment process\n        State state;\n\n        // the buyer, providing the required funds, who shall receive\n        // the asset on a successful payment.\n        address buyer;\n\n        // the seller of the asset, who shall receive the funds\n        // (subtracting fees) on a successful payment.        \n        address seller;\n\n        // The address of the operator of this payment\n        address operator;\n\n        // The address of the feesCollector of this payment\n        address feesCollector;\n\n        // The timestamp after which, in absence of confirmation of \n        // asset transfer success, a buyer is allowed to refund\n        uint256 expirationTime;\n\n        // the percentage fee expressed in Basis Points (bps), typical in finance\n        // Examples:  2.5% = 250 bps, 10% = 1000 bps, 100% = 10000 bps\n        uint256 feeBPS;\n\n        // the price of the asset, an integer expressed in the\n        // lowest unit of the currency.\n        uint256 amount;\n    }\n\n    /**\n     * @notice Registers msg.sender as seller so that, if the contract has set\n     *  _isSellerRegistrationRequired = true, then payments will be accepted with\n     *  msg.sender as seller.\n    */\n    function registerAsSeller() external;\n\n    /**\n     * @notice Sets the value of onlyUserCanWithdraw for the user with msg.sender address:\n     *  - if true: only the user can execute withdrawals of his/her local balance\n     *  - if false: any address can help and execute the withdrawals on behalf of the user\n     *   (the funds still go straight to the user, but the helper address covers gas costs\n     *    and the hassle of executing the transaction)\n     * @param onlyUserCan true if only the user can execute withdrawals of his/her local balance\n     */\n    function setOnlyUserCanWithdraw(bool onlyUserCan) external;\n\n    /**\n     * @notice Relays the operator signature declaring that the asset transfer was successful or failed,\n     *  and updates local balances of seller or buyer, respectively.\n     * @dev Can be executed by anyone, but the operator signature must be included as input param.\n     *  Seller or Buyer's local balances are updated, allowing explicit withdrawal.\n     *  Moves payment to PAID or REFUNDED state on transfer success/failure, respectively.\n     * @param transferResult The asset transfer result struct signed by the operator.\n     * @param operatorSignature The operator signature of transferResult\n     */\n    function finalize(\n        AssetTransferResult calldata transferResult,\n        bytes calldata operatorSignature\n    ) external;\n\n    /**\n     * @notice Relays the operator signature declaring that the asset transfer was successful or failed,\n     *  updates balances of seller or buyer, respectively, and proceeds to withdraw all funds \n     *  in this contract available to the rightful recipient of the paymentId: \n     *  the seller if transferResult.wasSuccessful == true, the buyer otherwise.\n     * @dev If recipient has set onlyUserCanWithdraw == true, then msg.sender must the the recipient;\n     *  otherwise, anyone can execute this method, with funds arriving to the recipient too, but with a\n     *  helping 3rd party covering gas costs and TX sending hassle.\n     *  The operator signature must be included as input param.\n     *  Moves payment to PAID or REFUNDED state on transfer success/failure, respectively.\n     * @param transferResult The asset transfer result struct signed by the operator.\n     * @param operatorSignature The operator signature of transferResult\n     */\n    function finalizeAndWithdraw(\n        AssetTransferResult calldata transferResult,\n        bytes calldata operatorSignature\n    ) external;\n\n    /**\n     * @notice Moves buyer's provided funds to buyer's balance.\n     * @dev Anybody can call this function.\n     *  Requires acceptsRefunds == true to proceed.\n     *  After updating buyer's balance, he/she can later withdraw.\n     *  Moves payment to REFUNDED state.\n     * @param paymentId The unique ID that identifies the payment.\n     */\n    function refund(bytes32 paymentId) external;\n\n    /**\n     * @notice Executes refund and withdraw to the buyer in one transaction.\n     * @dev If the buyer has set onlyUserCanWithdraw == true, then msg.sender must the the recipient;\n     *  otherwise, anyone can execute this method, with funds arriving to the buyer too, but with a\n     *  helping 3rd party covering gas costs and TX sending hassle.\n     *  Requires acceptsRefunds == true to proceed.\n     *  All of msg.sender's balance in the contract is withdrawn,\n     *  not only the part that was locked in this particular paymentId\n     *  Moves payment to REFUNDED state.\n     * @param paymentId The unique ID that identifies the payment.\n     */\n    function refundAndWithdraw(bytes32 paymentId) external;\n\n    /**\n     * @notice Transfers funds avaliable in this\n     *  contract's balanceOf[msg.sender] to msg.sender\n     */\n    function withdraw() external;\n\n    /**\n     * @notice Transfers funds avaliable in this\n     *  contract's balanceOf[recipient] to recipient.\n     *  The funds still go to straight the recipient, as if he/she\n     *  has executed the withdrawal() method, but the msg.sender\n     *  covers gas costs and the hassle of executing the transaction.\n     *  Users can always opt out from this feature, using the setOnlyUserCanWithdraw method.\n     */\n    function withdrawTo(address recipient) external;\n\n    /**\n     * @notice Transfers only the specified amount\n     *  from this contract's balanceOf[msg.sender] to msg.sender.\n     *  Reverts if balanceOf[msg.sender] < amount.\n     * @param amount The required amount to withdraw\n     */\n    function withdrawAmount(uint256 amount) external;\n\n    // VIEW FUNCTIONS\n\n    /**\n     * @notice Returns whether sellers need to be registered to be able to accept payments\n     * @return Returns true if sellers need to be registered to be able to accept payments\n     */\n    function isSellerRegistrationRequired() external view returns (bool);\n\n    /**\n     * @notice Returns true if the address provided is a registered seller\n     * @param addr the address that is queried\n     * @return Returns whether the address is registered as seller\n     */\n    function isRegisteredSeller(address addr) external view returns (bool);\n\n    /**\n     * @notice Returns the local balance of the provided address that is stored in this\n     *  contract, and hence, available for withdrawal.\n     * @param addr the address that is queried\n     * @return the local balance\n     */\n    function balanceOf(address addr) external view returns (uint256);\n\n    /**\n     * @notice Returns all data stored in a payment\n     * @param paymentId The unique ID that identifies the payment.\n     * @return the struct stored for the payment\n     */\n    function paymentInfo(bytes32 paymentId)\n        external\n        view\n        returns (Payment memory);\n\n    /**\n     * @notice Returns the state of a payment.\n     * @dev If payment is in ASSET_TRANSFERRING, it may be worth\n     *  checking acceptsRefunds to check if it has gone beyond expirationTime.\n     * @param paymentId The unique ID that identifies the payment.\n     * @return the state of the payment.\n     */\n    function paymentState(bytes32 paymentId) external view returns (State);\n\n    /**\n     * @notice Returns true if the payment accepts a refund to the buyer\n     * @dev The payment must be in ASSET_TRANSFERRING and beyond expirationTime.\n     * @param paymentId The unique ID that identifies the payment.\n     * @return true if the payment accepts a refund to the buyer.\n     */\n    function acceptsRefunds(bytes32 paymentId) external view returns (bool);\n\n    /**\n     * @notice Returns the address of the of the contract containing\n     *  the implementation of the EIP712 verifying functions\n     * @return the address of the EIP712 verifier contract\n     */\n    function EIP712Address() external view returns (address);\n\n    /**\n     * @notice Returns the amount of seconds that a payment\n     *  can remain in ASSET_TRANSFERRING state without positive\n     *  or negative confirmation by the operator\n     * @return the payment window in secs\n     */\n    function paymentWindow() external view returns (uint256);\n\n    /**\n     * @notice Returns a descriptor about the currency that this"
    }
  ]
}