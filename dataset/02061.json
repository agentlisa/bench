{
  "Title": "M-1: Denial-of-Service in the liquidation flow results in the collateral NTF will be stuck in the contract.",
  "Content": "# Issue M-1: Denial-of-Service in the liquidation flow results in the collateral NTF will be stuck in the contract. \n\nSource: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/76 \n\n## Found by \nInspex, jekapi\n\n\n## Summary\nIf the `loanTovalue` value of the offer is extremely high, the liquidation flow will be reverted, causing the collateral NTF to persist in the contract forever.\n\n\n## Vulnerability Detail\nThe platform allows users to sign offers and provide funds to those who need to borrow assets.\n\nIn the first scenario, the lender provided an offer that the `loanTovalue` as high as the result of the `shareMatched` is `0`. For example, if the borrowed amount was `1e40` and the offer had a `loanTovalue` equal to `1e68`, the share would be `0`.\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/BorrowLogic/BorrowHandlers.sol#L47\n\nAs a result, an arithmetic error (`Division or modulo by 0`) will occur in the `price()` function at line 50 during the liquidation process.\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L34-L55\n\nIn the second scenario, if the lender's share exceeds `0`, but the offer's `loanToValue` is extremely high, the `price()` function at line 54 may encounter an arithmetic error(`Arithmetic over/underflow`) during the `estimatedValue` calculation.\n\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L54\n\n## Poof of Concept\n**kairos-contracts/test/BorrowBorrow.t.sol**\n```solidity\nfunction testBorrowOverflow() public {\n    uint256 borrowAmount = 1e40;\n    BorrowArg[] memory borrowArgs = new BorrowArg[](1);\n    (, ,uint256 loanId , ) = kairos.getParameters();\n    loanId += 1;\n\n    Offer memory offer = Offer({\n            assetToLend: money,\n            loanToValue: 1e61,\n            duration: 1,\n            expirationDate: block.timestamp + 2 hours,\n            tranche: 0,\n            collateral: getNft()\n        });\n    uint256 currentTokenId;\n\n    getFlooz(signer, money, getOfferArg(offer).amount);\n\n    {\n        OfferArg[] memory offerArgs = new OfferArg[](1);\n        currentTokenId = getJpeg(BORROWER, nft);\n        offer.collateral.id = currentTokenId;\n        offerArgs[0] = OfferArg({\n            signature: getSignature(offer),\n            amount: borrowAmount,\n            offer: offer\n        });\n        borrowArgs[0] = BorrowArg({nft: NFToken({id: currentTokenId, implem: nft}), args: offerArgs});\n    }\n\n    vm.prank(BORROWER);\n    kairos.borrow(borrowArgs);\n\n    assertEq(nft.balanceOf(BORROWER), 0);\n    assertEq(money.balanceOf(BORROWER), borrowAmount);\n    assertEq(nft.balanceOf(address(kairos)), 1);\n\n    vm.warp(block.timestamp + 1);\n    Loan memory loan = kairos.getLoan(loanId);\n    console.log(\"price of loanId\", kairos.price(loanId));\n}\n```\n\n\n\n## Impact\nThe loan position will not be liquidated, which will result in the collateral NTF being permanently frozen in the contract.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/BorrowLogic/BorrowHandlers.sol#L47\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L50\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L54\n## Tool used\n\nManual Review\n\n## Recommendation\nWe recommend adding the mechanism during the borrowing process to restrict the maximum `loanToValue` limit and ensure that the lender's share is always greater than zero. This will prevent arithmetic errors.\n\n\n\n## Discussion\n\n**npasquie**\n\nsimilar to #34 \n\n**npasquie**\n\nfixed here https://github.com/kairos-loan/kairos-contracts/pull/52\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/56",
  "Code": [
    {
      "filename": "kairos-contracts/src/BorrowLogic/BorrowHandlers.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IBorrowHandlers} from \"../interface/IBorrowHandlers.sol\";\n\nimport {BorrowCheckers} from \"./BorrowCheckers.sol\";\nimport {CollateralState, NFToken, OfferArg, Ray} from \"../DataStructure/Objects.sol\";\nimport {Loan, Payment, Protocol, Provision, Auction} from \"../DataStructure/Storage.sol\";\nimport {ONE, protocolStorage, supplyPositionStorage} from \"../DataStructure/Global.sol\";\nimport {RayMath} from \"../utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"../utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"../SupplyPositionLogic/SafeMint.sol\";\n/* solhint-disable-next-line max-line-length */\nimport {InconsistentAssetRequests, InconsistentTranches, RequestedAmountTooHigh, UnsafeAmountLent, UnsafeOfferLoanToValuesGap} from \"../DataStructure/Errors.sol\";\n\n/// @notice handles usage of entities to borrow with\nabstract contract BorrowHandlers is IBorrowHandlers, BorrowCheckers, SafeMint {\n    using RayMath for uint256;\n    using RayMath for Ray;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice handles usage of a loan offer to borrow from\n    /// @param arg arguments for the usage of this offer\n    /// @param collatState tracked state of the matching of the collateral\n    /// @return collateralState updated `collatState` after usage of the offer\n    function useOffer(\n        OfferArg memory arg,\n        CollateralState memory collatState\n    ) internal returns (CollateralState memory) {\n        address signer = checkOfferArg(arg);\n        Ray shareMatched;\n\n        if (arg.offer.assetToLend != collatState.assetLent) {\n            // all offers used for a collateral must refer to the same erc20\n            revert InconsistentAssetRequests(collatState.assetLent, arg.offer.assetToLend);\n        }\n        if (arg.offer.tranche != collatState.tranche) {\n            // all offers used for a collateral must refer to the same interest rate tranche\n            revert InconsistentTranches(collatState.tranche, arg.offer.tranche);\n        }\n\n        checkCollateral(arg.offer, collatState.nft);\n\n        // we keep track of the share of the maximum value (`loanToValue`) proposed by an offer used by the borrower.\n        shareMatched = arg.amount.div(arg.offer.loanToValue);\n        collatState.matched = collatState.matched.add(shareMatched);\n\n        /* we consider that lenders are acquiring shares of the NFT used as collateral by lending the amount\n        corresponding to shareMatched. We check this process is not ditributing more shares than the full NFT value. */\n        if (collatState.matched.gt(ONE)) {\n            revert RequestedAmountTooHigh(\n                arg.amount,\n                arg.offer.loanToValue.mul(ONE.sub(collatState.matched.sub(shareMatched))),\n                arg.offer\n            );\n        }\n\n        // the shortest duration offered among all offers used will be used to determine the loan end date.\n        if (arg.offer.duration < collatState.minOfferDuration) {\n            collatState.minOfferDuration = arg.offer.duration;\n        }\n        if (arg.offer.loanToValue < collatState.minOfferLoanToValue) {\n            collatState.minOfferLoanToValue = arg.offer.loanToValue;\n        }\n        if (arg.offer.loanToValue > collatState.maxOfferLoanToValue) {\n            collatState.maxOfferLoanToValue = arg.offer.loanToValue;\n        }\n\n        /* This check serves to prevent a manipulation of the auction start price. The auction price is determined by\n        a multiple of the mean of the offer loanToValues used in the loan. Being lender and borrower at the same time,\n        one could influence this price by providing an infinitesimal loanToValue price, get a loan instantly liquidable\n        at a price inferior a the loanToValue of another offer used in the loan. buying its own NFT in auction would\n        result in a net gain arising from the difference between the sale price of the NFT and the loanToValue provided\n        by the other offer (effectively stealing the funds of the lender). This is prevented by limiting the max gap\n        between two offer loanToValue to a factor 2, and making the priceFactor of the auction equal or superior to 2.5.\n        In the worst case, the attacker can influence the start price of the auction to be\n        (attacked_offer_ltv / 2) * 2.5 which is superior to the attacked offer loan to value. */\n        if (collatState.maxOfferLoanToValue > collatState.minOfferLoanToValue * 2) {\n            revert UnsafeOfferLoanToValuesGap(\n                collatState.minOfferLoanToValue,\n                collatState.maxOfferLoanToValue\n            );\n        }\n\n        // transferring the borrowed funds from the lender to the borrower\n        collatState.assetLent.checkedTransferFrom(signer, collatState.from, arg.amount);\n\n        // issuing supply position NFT to the signer of the loan offer with metadatas\n        safeMint(signer, Provision({amount: arg.amount, share: shareMatched, loanId: collatState.loanId}));\n        return (collatState);\n    }\n\n    /// @notice handles usage of one collateral to back a loan request\n    /// @param args arguments for usage of one or multiple loan offers\n    /// @param from borrower for this loan\n    /// @param nft collateral to use\n    /// @return loan the loan created backed by provided collateral\n    function useCollateral(\n        OfferArg[] memory args,\n        address from,\n        NFToken memory nft\n    ) internal returns (Loan memory loan) {\n        CollateralState memory collatState = initializedCollateralState(args[0], from, nft);\n\n        // total supply is later incremented as part of the minting of the first supply position\n        uint256 firstSupplyPositionId = supplyPositionStorage().totalSupply + 1;\n        uint256 nbOfOffers = args.length;\n        uint256 lent; // keep track of the total amount lent/borrowed\n\n        for (uint256 i = 0; i < nbOfOffers; i++) {\n            collatState = useOffer(args[i], collatState);\n            lent += args[i].amount;\n        }\n\n        // cf RepayFacet for the rationale of this check. We prevent repaying being impossible due to an overflow in the\n        // interests to repay calculation.\n        if (lent > 1e40) {\n            revert UnsafeAmountLent(lent);\n        }\n        loan = initializedLoan(collatState, from, nft, nbOfOffers, lent, firstSupplyPositionId);\n        protocolStorage().loan[collatState.loanId] = loan;\n\n        emit Borrow(collatState.loanId, abi.encode(loan));\n    }\n\n    /// @notice initializes the collateral state memory struct used to keep track of the collateralization and other\n    ///     health checks variables during the issuance of a loan\n    /// @param firstOfferArg the first struct of arguments for an offer among potentially multiple used loan offers\n    /// @param from I.e borrower\n    /// @param nft - used as collateral\n    /// @return collatState the initialized collateral state struct\n    function initializedCollateralState(\n        OfferArg memory firstOfferArg,\n        address from,\n        NFToken memory nft\n    ) internal returns (CollateralState memory) {\n        return\n            CollateralState({\n                matched: Ray.wrap(0),\n                assetLent: firstOfferArg.offer.assetToLend,\n                tranche: firstOfferArg.offer.tranche,\n                minOfferDuration: firstOfferArg.offer.duration,\n                minOfferLoanToValue: firstOfferArg.offer.loanToValue,\n                maxOfferLoanToValue: firstOfferArg.offer.loanToValue,\n                from: from,\n                nft: nft,\n                loanId: ++protocolStorage().nbOfLoans // returns incremented value (also increments in storage)\n            });\n    }\n\n    /// @notice initializes the loan struct representing borrowed funds from one NFT collateral, will be stored\n    /// @param collatState contains info on share of the collateral value used by the borrower\n    /// @param nft - used as collateral\n    /// @param nbOfOffers number of loan offers used (I.e number of supply positions minted)\n    /// @param lent amount lent/borrowed\n    /// @param firstSupplyPositionId identifier of the first supply position (I.e NFT token id)\n    /// @return loan tne initialized loan to store\n    function initializedLoan(\n        CollateralState memory collatState,\n        address from,\n        NFToken memory nft,\n        uint256 nbOfOffers,\n        uint256 lent,\n        uint256 firstSupplyPositionId\n    ) internal view returns (Loan memory) {\n        Protocol storage proto = protocolStorage();\n\n        /* the shortest offered duration determines the max date of repayment to make sure all loan offer terms are\n        respected */\n        uint256 endDate = block.timestamp + collatState.minOfferDuration;\n        Payment memory notPaid; // not paid as it corresponds to the meaning of the uninitialized struct\n\n        /* the minimum interests amount to repay is used as anti ddos mechanism to prevent borrowers to produce lots of\n        dust supply positions that the lenders will have to pay gas to claim. This is why it is determined on a\n        per-offer basis, as each position can be used to claim funds separetely and induce a gas cost. With a design\n        approach similar to the auction parameters setting, this minimal cost is set at borrow time to avoid bad\n        surprises arising from governance setting new parameters during the loan life. cf docs for more details. */\n        notPaid.minInterestsToRepay = nbOfOffers * proto.minOfferCost[collatState.assetLent];\n\n        return\n            Loan({\n                assetLent: collatState.assetLent,\n                lent: lent,\n                shareLent: collatState.matched,\n                startDate: block.timestamp,\n                endDate: endDate,\n                /* auction parameters are copied from protocol parameters to the loan storage as a way to prevent\n                a governance-initiated change of terms to modify the terms a borrower chose to accept or change the\n                price of an NFT being sold abruptly during the course of an auction. */\n                auction: Auction({duration: proto.auction.duration, priceFactor: proto.auction.priceFactor}),\n                /* the interest rate is stored as a value instead of the tranche id as a precaution in case of a change\n                in the interest rate mechanisms due to contract upgrade */\n                interestPerSecond: proto.tranche[collatState.tranche],\n                borrower: from,\n                collateral: nft,\n                supplyPositionIndex: firstSupplyPositionId,\n                payment: notPaid,\n                /* from the first supply position id and the number of offers used all supply position ids can be\n                deduced + the number of offers/positions is directly accessible for other purposes */\n                nbOfPositions: nbOfOffers\n            });\n    }\n}"
    },
    {
      "filename": "kairos-contracts/src/AuctionFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IAuctionFacet} from \"./interface/IAuctionFacet.sol\";\n\nimport {BuyArg, NFToken, Ray} from \"./DataStructure/Objects.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\nimport {protocolStorage, supplyPositionStorage, ONE, ZERO} from \"./DataStructure/Global.sol\";\n// solhint-disable-next-line max-line-length\nimport {LoanAlreadyRepaid, CollateralIsNotLiquidableYet} from \"./DataStructure/Errors.sol\";\n\n/// @notice handles sale of collaterals being liquidated, following a dutch auction starting at repayment date\ncontract AuctionFacet is IAuctionFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice buy one or multiple NFTs in liquidation\n    /// @param args arguments on what and how to buy\n    function buy(BuyArg[] memory args) external {\n        for (uint256 i = 0; i < args.length; i++) {\n            useLoan(args[i]);\n        }\n    }\n\n    /// @notice gets the price to buy the underlying collateral of the loan\n    /// @param loanId identifier of the loan\n    /// @return price computed price\n    function price(uint256 loanId) public view returns (uint256) {\n        Loan storage loan = protocolStorage().loan[loanId];\n        uint256 loanEndDate = loan.endDate;\n        uint256 timeSinceLiquidable = block.timestamp - loanEndDate;\n\n        checkLoanStatus(loanId);\n\n        /* the decreasing factor controls the evolution of the price from its initial value to 0 (and staying at 0)\n        over the course of the auction duration */\n        Ray decreasingFactor = timeSinceLiquidable >= loan.auction.duration\n            ? ZERO\n            : ONE.sub(timeSinceLiquidable.div(loan.auction.duration));\n\n        /* the estimated value arises from the mean of the loan offer loanToValues used in the loan regarding their\n        share in the collateral usage. This must stay consitent even if less than the full value of the NFT has been\n        used as collateral */\n        uint256 estimatedValue = loan.lent.mul(ONE.div(loan.shareLent));\n\n        /* by mutliplying the estimated price by some factor and slowly decreasing this price over time we aim to\n        make sure a liquidator will buy the NFT at fair market price. */\n        return estimatedValue.mul(loan.auction.priceFactor).mul(decreasingFactor);\n    }\n\n    /// @notice handles buying one NFT\n    /// @param arg arguments on what and how to buy\n    function useLoan(BuyArg memory arg) internal {\n        Loan storage loan = protocolStorage().loan[arg.loanId];\n\n        checkLoanStatus(arg.loanId);\n        uint256 toPay = price(arg.loanId);\n\n        /* store as liquidated and paid before transfers to avoid malicious reentrency, following\n        checks-effects-interaction pattern */\n        loan.payment.liquidated = true;\n        loan.payment.paid = toPay;\n        loan.assetLent.checkedTransferFrom(msg.sender, address(this), toPay);\n        loan.collateral.implem.safeTransferFrom(address(this), arg.to, loan.collateral.id);\n\n        emit Buy(arg.loanId, abi.encode(arg));\n    }\n\n    /// @notice checks that loan is liquidable, revert if not\n    /// @param loanId identifier of the loan\n    function checkLoanStatus(uint256 loanId) internal view {\n        Loan storage loan = protocolStorage().loan[loanId];\n\n        if (block.timestamp < loan.endDate) {\n            revert CollateralIsNotLiquidableYet(loan.endDate, loanId);\n        }\n        if (loan.payment.paid != 0 || loan.payment.liquidated) {\n            revert LoanAlreadyRepaid(loanId);\n        }\n    }\n}"
    },
    {
      "filename": "kairos-contracts/src/AuctionFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IAuctionFacet} from \"./interface/IAuctionFacet.sol\";\n\nimport {BuyArg, NFToken, Ray} from \"./DataStructure/Objects.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\nimport {protocolStorage, supplyPositionStorage, ONE, ZERO} from \"./DataStructure/Global.sol\";\n// solhint-disable-next-line max-line-length\nimport {LoanAlreadyRepaid, CollateralIsNotLiquidableYet} from \"./DataStructure/Errors.sol\";\n\n/// @notice handles sale of collaterals being liquidated, following a dutch auction starting at repayment date\ncontract AuctionFacet is IAuctionFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice buy one or multiple NFTs in liquidation\n    /// @param args arguments on what and how to buy\n    function buy(BuyArg[] memory args) external {\n        for (uint256 i = 0; i < args.length; i++) {\n            useLoan(args[i]);\n        }\n    }\n\n    /// @notice gets the price to buy the underlying collateral of the loan\n    /// @param loanId identifier of the loan\n    /// @return price computed price\n    function price(uint256 loanId) public view returns (uint256) {\n        Loan storage loan = protocolStorage().loan[loanId];\n        uint256 loanEndDate = loan.endDate;\n        uint256 timeSinceLiquidable = block.timestamp - loanEndDate;\n\n        checkLoanStatus(loanId);\n\n        /* the decreasing factor controls the evolution of the price from its initial value to 0 (and staying at 0)\n        over the course of the auction duration */\n        Ray decreasingFactor = timeSinceLiquidable >= loan.auction.duration\n            ? ZERO\n            : ONE.sub(timeSinceLiquidable.div(loan.auction.duration));\n\n        /* the estimated value arises from the mean of the loan offer loanToValues used in the loan regarding their\n        share in the collateral usage. This must stay consitent even if less than the full value of the NFT has been\n        used as collateral */\n        uint256 estimatedValue = loan.lent.mul(ONE.div(loan.shareLent));\n\n        /* by mutliplying the estimated price by some factor and slowly decreasing this price over time we aim to\n        make sure a liquidator will buy the NFT at fair market price. */\n        return estimatedValue.mul(loan.auction.priceFactor).mul(decreasingFactor);\n    }\n\n    /// @notice handles buying one NFT\n    /// @param arg arguments on what and how to buy\n    function useLoan(BuyArg memory arg) internal {\n        Loan storage loan = protocolStorage().loan[arg.loanId];\n\n        checkLoanStatus(arg.loanId);\n        uint256 toPay = price(arg.loanId);\n\n        /* store as liquidated and paid before transfers to avoid malicious reentrency, following\n        checks-effects-interaction pattern */\n        loan.payment.liquidated = true;\n        loan.payment.paid = toPay;\n        loan.assetLent.checkedTransferFrom(msg.sender, address(this), toPay);\n        loan.collateral.implem.safeTransferFrom(address(this), arg.to, loan.collateral.id);\n\n        emit Buy(arg.loanId, abi.encode(arg));\n    }\n\n    /// @notice checks that loan is liquidable, revert if not\n    /// @param loanId identifier of the loan\n    function checkLoanStatus(uint256 loanId) internal view {\n        Loan storage loan = protocolStorage().loan[loanId];\n\n        if (block.timestamp < loan.endDate) {\n            revert CollateralIsNotLiquidableYet(loan.endDate, loanId);\n        }\n        if (loan.payment.paid != 0 || loan.payment.liquidated) {\n            revert LoanAlreadyRepaid(loanId);\n        }\n    }\n}"
    },
    {
      "filename": "kairos-contracts/src/BorrowLogic/BorrowHandlers.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IBorrowHandlers} from \"../interface/IBorrowHandlers.sol\";\n\nimport {BorrowCheckers} from \"./BorrowCheckers.sol\";\nimport {CollateralState, NFToken, OfferArg, Ray} from \"../DataStructure/Objects.sol\";\nimport {Loan, Payment, Protocol, Provision, Auction} from \"../DataStructure/Storage.sol\";\nimport {ONE, protocolStorage, supplyPositionStorage} from \"../DataStructure/Global.sol\";\nimport {RayMath} from \"../utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"../utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"../SupplyPositionLogic/SafeMint.sol\";\n/* solhint-disable-next-line max-line-length */\nimport {InconsistentAssetRequests, InconsistentTranches, RequestedAmountTooHigh, UnsafeAmountLent, UnsafeOfferLoanToValuesGap} from \"../DataStructure/Errors.sol\";\n\n/// @notice handles usage of entities to borrow with\nabstract contract BorrowHandlers is IBorrowHandlers, BorrowCheckers, SafeMint {\n    using RayMath for uint256;\n    using RayMath for Ray;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice handles usage of a loan offer to borrow from\n    /// @param arg arguments for the usage of this offer\n    /// @param collatState tracked state of the matching of the collateral\n    /// @return collateralState updated `collatState` after usage of the offer\n    function useOffer(\n        OfferArg memory arg,\n        CollateralState memory collatState\n    ) internal returns (CollateralState memory) {\n        address signer = checkOfferArg(arg);\n        Ray shareMatched;\n\n        if (arg.offer.assetToLend != collatState.assetLent) {\n            // all offers used for a collateral must refer to the same erc20\n            revert InconsistentAssetRequests(collatState.assetLent, arg.offer.assetToLend);\n        }\n        if (arg.offer.tranche != collatState.tranche) {\n            // all offers used for a collateral must refer to the same interest rate tranche\n            revert InconsistentTranches(collatState.tranche, arg.offer.tranche);\n        }\n\n        checkCollateral(arg.offer, collatState.nft);\n\n        // we keep track of the share of the maximum value (`loanToValue`) proposed by an offer used by the borrower.\n        shareMatched = arg.amount.div(arg.offer.loanToValue);\n        collatState.matched = collatState.matched.add(shareMatched);\n\n        /* we consider that lenders are acquiring shares of the NFT used as collateral by lending the amount\n        corresponding to shareMatched. We check this process is not ditributing more shares than the full NFT value. */\n        if (collatState.matched.gt(ONE)) {\n            revert RequestedAmountTooHigh(\n                arg.amount,\n                arg.offer.loanToValue.mul(ONE.sub(collatState.matched.sub(shareMatched))),\n                arg.offer\n            );\n        }\n\n        // the shortest duration offered among all offers used will be used to determine the loan end date.\n        if (arg.offer.duration < collatState.minOfferDuration) {\n            collatState.minOfferDuration = arg.offer.duration;\n        }\n        if (arg.offer.loanToValue < collatState.minOfferLoanToValue) {\n            collatState.minOfferLoanToValue = arg.offer.loanToValue;\n        }\n        if (arg.offer.loanToValue > collatState.maxOfferLoanToValue) {\n            collatState.maxOfferLoanToValue = arg.offer.loanToValue;\n        }\n\n        /* This check serves to prevent a manipulation of the auction start price. The auction price is determined by\n        a multiple of the mean of the offer loanToValues used in the loan. Being lender and borrower at the same time,\n        one could influence this price by providing an infinitesimal loanToValue price, get a loan instantly liquidable\n        at a price inferior a the loanToValue of another offer used in the loan. buying its own NFT in auction would\n        result in a net gain arising from the difference between the sale price of the NFT and the loanToValue provided\n        by the other offer (effectively stealing the funds of the lender). This is prevented by limiting the max gap\n        between two offer loanToValue to a factor 2, and making the priceFactor of the auction equal or superior to 2.5.\n        In the worst case, the attacker can influence the start price of the auction to be\n        (attacked_offer_ltv / 2) * 2.5 which is superior to the attacked offer loan to value. */\n        if (collatState.maxOfferLoanToValue > collatState.minOfferLoanToValue * 2) {\n            revert UnsafeOfferLoanToValuesGap(\n                collatState.minOfferLoanToValue,\n                collatState.maxOfferLoanToValue\n            );\n        }\n\n        // transferring the borrowed funds from the lender to the borrower\n        collatState.assetLent.checkedTransferFrom(signer, collatState.from, arg.amount);\n\n        // issuing supply position NFT to the signer of the loan offer with metadatas\n        safeMint(signer, Provision({amount: arg.amount, share: shareMatched, loanId: collatState.loanId}));\n        return (collatState);\n    }\n\n    /// @notice handles usage of one collateral to back a loan request\n    /// @param args arguments for usage of one or multiple loan offers\n    /// @param from borrower for this loan\n    /// @param nft collateral to use\n    /// @return loan the loan created backed by provided collateral\n    function useCollateral(\n        OfferArg[] memory args,\n        address from,\n        NFToken memory nft\n    ) internal returns (Loan memory loan) {\n        CollateralState memory collatState = initializedCollateralState(args[0], from, nft);\n\n        // total supply is later incremented as part of the minting of the first supply position\n        uint256 firstSupplyPositionId = supplyPositionStorage().totalSupply + 1;\n        uint256 nbOfOffers = args.length;\n        uint256 lent; // keep track of the total amount lent/borrowed\n\n        for (uint256 i = 0; i < nbOfOffers; i++) {\n            collatState = useOffer(args[i], collatState);\n            lent += args[i].amount;\n        }\n\n        // cf RepayFacet for the rationale of this check. We prevent repaying being impossible due to an overflow in the\n        // interests to repay calculation.\n        if (lent > 1e40) {\n            revert UnsafeAmountLent(lent);\n        }\n        loan = initializedLoan(collatState, from, nft, nbOfOffers, lent, firstSupplyPositionId);\n        protocolStorage().loan[collatState.loanId] = loan;\n\n        emit Borrow(collatState.loanId, abi.encode(loan));\n    }\n\n    /// @notice initializes the collateral state memory struct used to keep track of the collateralization and other\n    ///     health checks variables during the issuance of a loan\n    /// @param firstOfferArg the first struct of arguments for an offer among potentially multiple used loan offers\n    /// @param from I.e borrower\n    /// @param nft - used as collateral\n    /// @return collatState the initialized collateral state struct\n    function initializedCollateralState(\n        OfferArg memory firstOfferArg,\n        address from,\n        NFToken memory nft\n    ) internal returns (CollateralState memory) {\n        return\n            CollateralState({\n                matched: Ray.wrap(0),\n                assetLent: firstOfferArg.offer.assetToLend,\n                tranche: firstOfferArg.offer.tranche,\n                minOfferDuration: firstOfferArg.offer.duration,\n                minOfferLoanToValue: firstOfferArg.offer.loanToValue,\n                maxOfferLoanToValue: firstOfferArg.offer.loanToValue,\n                from: from,\n                nft: nft,\n                loanId: ++protocolStorage().nbOfLoans // returns incremented value (also increments in storage)\n            });\n    }\n\n    /// @notice initializes the loan struct representing borrowed funds from one NFT collateral, will be stored\n    /// @param collatState contains info on share of the collateral value used by the borrower\n    /// @param nft - used as collateral\n    /// @param nbOfOffers number of loan offers used (I.e number of supply positions minted)\n    /// @param lent amount lent/borrowed\n    /// @param firstSupplyPositionId identifier of the first supply position (I.e NFT token id)\n    /// @return loan tne initialized loan to store\n    function initializedLoan(\n        CollateralState memory collatState,\n        address from,\n        NFToken memory nft,\n        uint256 nbOfOffers,\n        uint256 lent,\n        uint256 firstSupplyPositionId\n    ) internal view returns (Loan memory) {\n        Protocol storage proto = protocolStorage();\n\n        /* the shortest offered duration determines the max date of repayment to make sure all loan offer terms are\n        respected */\n        uint256 endDate = block.timestamp + collatState.minOfferDuration;\n        Payment memory notPaid; // not paid as it corresponds to the meaning of the uninitialized struct\n\n        /* the minimum interests amount to repay is used as anti ddos mechanism to prevent borrowers to produce lots of\n        dust supply positions that the lenders will have to pay gas to claim. This is why it is determined on a\n        per-offer basis, as each position can be used to claim funds separetely and induce a gas cost. With a design\n        approach similar to the auction parameters setting, this minimal cost is set at borrow time to avoid bad\n        surprises arising from governance setting new parameters during the loan life. cf docs for more details. */\n        notPaid.minInterestsToRepay = nbOfOffers * proto.minOfferCost[collatState.assetLent];\n\n        return\n            Loan({\n                assetLent: collatState.assetLent,\n                lent: lent,\n                shareLent: collatState.matched,\n                startDate: block.timestamp,\n                endDate: endDate,\n                /* auction parameters are copied from protocol parameters to the loan storage as a way to prevent\n                a governance-initiated change of terms to modify the terms a borrower chose to accept or change the\n                price of an NFT being sold abruptly during the course of an auction. */\n                auction: Auction({duration: proto.auction.duration, priceFactor: proto.auction.priceFactor}),\n                /* the interest rate is stored as a value instead of the tranche id as a precaution in case of a change\n                in the interest rate mechanisms due to contract upgrade */\n                interestPerSecond: proto.tranche[collatState.tranche],\n                borrower: from,\n                collateral: nft,\n                supplyPositionIndex: firstSupplyPositionId,\n                payment: notPaid,\n                /* from the first supply position id and the number of offers used all supply position ids can be\n                deduced + the number of offers/positions is directly accessible for other purposes */\n                nbOfPositions: nbOfOffers\n            });\n    }\n}"
    },
    {
      "filename": "kairos-contracts/src/AuctionFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IAuctionFacet} from \"./interface/IAuctionFacet.sol\";\n\nimport {BuyArg, NFToken, Ray} from \"./DataStructure/Objects.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\nimport {protocolStorage, supplyPositionStorage, ONE, ZERO} from \"./DataStructure/Global.sol\";\n// solhint-disable-next-line max-line-length\nimport {LoanAlreadyRepaid, CollateralIsNotLiquidableYet} from \"./DataStructure/Errors.sol\";\n\n/// @notice handles sale of collaterals being liquidated, following a dutch auction starting at repayment date\ncontract AuctionFacet is IAuctionFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice buy one or multiple NFTs in liquidation\n    /// @param args arguments on what and how to buy\n    function buy(BuyArg[] memory args) external {\n        for (uint256 i = 0; i < args.length; i++) {\n            useLoan(args[i]);\n        }\n    }\n\n    /// @notice gets the price to buy the underlying collateral of the loan\n    /// @param loanId identifier of the loan\n    /// @return price computed price\n    function price(uint256 loanId) public view returns (uint256) {\n        Loan storage loan = protocolStorage().loan[loanId];\n        uint256 loanEndDate = loan.endDate;\n        uint256 timeSinceLiquidable = block.timestamp - loanEndDate;\n\n        checkLoanStatus(loanId);\n\n        /* the decreasing factor controls the evolution of the price from its initial value to 0 (and staying at 0)\n        over the course of the auction duration */\n        Ray decreasingFactor = timeSinceLiquidable >= loan.auction.duration\n            ? ZERO\n            : ONE.sub(timeSinceLiquidable.div(loan.auction.duration));\n\n        /* the estimated value arises from the mean of the loan offer loanToValues used in the loan regarding their\n        share in the collateral usage. This must stay consitent even if less than the full value of the NFT has been\n        used as collateral */\n        uint256 estimatedValue = loan.lent.mul(ONE.div(loan.shareLent));\n\n        /* by mutliplying the estimated price by some factor and slowly decreasing this price over time we aim to\n        make sure a liquidator will buy the NFT at fair market price. */\n        return estimatedValue.mul(loan.auction.priceFactor).mul(decreasingFactor);\n    }\n\n    /// @notice handles buying one NFT\n    /// @param arg arguments on what and how to buy\n    function useLo"
    }
  ]
}