{
  "Title": "[G-07] Cache function calls",
  "Content": "External calls are expensive as they are performed via the `CALL`/`STATICCALL` opcodes. Calls to internal functions can also be expensive when the internal functions themselves read from storage and/or perform external calls. If a function call, such as the ones explained above, is performed more than once, it should be cached to avoid incurring the costs multiple times.\n\nTotal Instances: `5`\n\nEstimated Gas Saved: `600`\n\n<details>\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L227-L239\n\n### Cache the return value from `totalStaked()` to save 1 External Call (~100 gas)\n```solidity\nFile: contracts/lybra/miner/ProtocolRewardsPool.sol\n227:    function notifyRewardAmount(uint amount, uint tokenType) external {\n228:        require(msg.sender == address(configurator));\n229:        if (totalStaked() == 0) return;\n230:        require(amount > 0, \"amount = 0\");\n231:        if(tokenType == 0) {\n232:            uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n233:            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n234:        } else if(tokenType == 1) {\n235:            ERC20 token = ERC20(configurator.stableToken());\n236:            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n237:        } else {\n238:            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n239:        }\n```\n```diff\ndiff --git a/lybra/miner/ProtocolRewardsPool.sol b/lybra/miner/ProtocolRewardsPool.sol\nindex 8fc83d6..5cdfbc1 100644\n--- a/lybra/miner/ProtocolRewardsPool.sol\n+++ b/lybra/miner/ProtocolRewardsPool.sol\n@@ -226,16 +226,18 @@ contract ProtocolRewardsPool is Ownable {\n      */\n     function notifyRewardAmount(uint amount, uint tokenType) external {\n         require(msg.sender == address(configurator));\n-        if (totalStaked() == 0) return;\n+        uint256 _cachedTotalStaked = totalStaked();\n+        if (_cachedTotalStaked == 0) return;\n         require(amount > 0, \"amount = 0\");\n         if(tokenType == 0) {\n             uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n-            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n+            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / _cachedTotalStaked;\n         } else if(tokenType == 1) {\n             ERC20 token = ERC20(configurator.stableToken());\n-            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n+            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / _cachedTotalStaked;\n         } else {\n-            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n+            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / _cachedTotalStaked;\n         }\n     }\n }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L204-L205\n\n### Cache `configurator.vaultKeeperRatio(address(this))` to save 1 External Call (~100 gas)\n```solidity\nFile: contracts/lybra/pools/base/LybraEUSDVaultBase.sol\n204:        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) { // @audit: 1st external call\n205:            reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio; // @audit: 2nd external call\n```\n```diff\ndiff --git a/lybra/pools/base/LybraEUSDVaultBase.sol b/lybra/pools/base/LybraEUSDVaultBase.sol\nindex 7a8c439..cde9e96 100644\n--- a/lybra/pools/base/LybraEUSDVaultBase.sol\n+++ b/lybra/pools/base/LybraEUSDVaultBase.sol\n@@ -201,8 +201,9 @@ abstract contract LybraEUSDVaultBase {\n         totalDepositedAsset -= assetAmount;\n         depositedAsset[onBehalfOf] -= assetAmount;\n         uint256 reward2keeper;\n-        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) {\n-            reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio;\n+        uint256 _vaultKeeperRatio = configurator.vaultKeeperRatio(address(this));\n+        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + _vaultKeeperRatio * 1e18) {\n+            reward2keeper = ((assetAmount * _vaultKeeperRatio) * 1e18) / onBehalfOfCollateralRatio;\n             collateralAsset.transfer(msg.sender, reward2keeper);\n         }\n         collateralAsset.transfer(provider, assetAmount - reward2keeper);\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L163-L169\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L132-L134\n\n### Cache the return value from `totalStaked()` to save 1 External Call (~100 gas)\n```solidity\nFile: contracts/lybra/miner/EUSDMiningIncentives.sol\n132:    function totalStaked() internal view returns (uint256) {\n133:        return EUSD.totalSupply(); // @audit: external call\n134:    }\n\n163:    function rewardPerToken() public view returns (uint256) {\n164:        if (totalStaked() == 0) { // @audit: 1st external call\n165:            return rewardPerTokenStored;\n166:        }\n167:\n168:        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked(); // @audit: 2nd external call\n169:    }\n```\n```diff\ndiff --git a/lybra/miner/EUSDMiningIncentives.sol b/lybra/miner/EUSDMiningIncentives.sol\nindex e6c57c8..2dcb330 100644\n--- a/lybra/miner/EUSDMiningIncentives.sol\n+++ b/lybra/miner/EUSDMiningIncentives.sol\n@@ -161,11 +161,12 @@ contract EUSDMiningIncentives is Ownable {\n     }\n\n     function rewardPerToken() public view returns (uint256) {\n-        if (totalStaked() == 0) {\n+        uint256 _cachedTotalStaked = totalStaked();\n+        if (_cachedTotalStaked == 0) {\n             return rewardPerTokenStored;\n         }\n\n-        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n+        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / _cachedTotalStaked;\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/ProtocolRewardsPool.sol#L115-L116\n\n### Cache `getPreUnlockableAmount(msg.sender)` to save 2 SLOADs\n```solidity\nFile: contracts/lybra/miner/ProtocolRewardsPool.sol\n115:        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender); // @audit: 1st function call (reads `time2fullRedemption[user]` at least 2 times)\n116:        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender); // @audit: 2nd function call (`time2FullRedemption[user]` read a total of at least 4 times)\n```\n```diff\ndiff --git a/lybra/miner/ProtocolRewardsPool.sol b/lybra/miner/ProtocolRewardsPool.sol\nindex 8fc83d6..3416ba4 100644\n--- a/lybra/miner/ProtocolRewardsPool.sol\n+++ b/lybra/miner/ProtocolRewardsPool.sol\n@@ -112,8 +112,9 @@ contract ProtocolRewardsPool is Ownable {\n      */\n     function unlockPrematurely() external {\n         require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n-        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n-        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n+        uint256 _preUnlockableAmount = getPreUnlockableAmount(msg.sender);\n+        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - _preUnlockableAmount;\n+        uint256 amount = _preUnlockableAmount + getClaimAbleLBR(msg.sender);\n         if (amount > 0) {\n             LBR.mint(msg.sender, amount);\n         }\n```\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/LybraStETHVault.sol#L66-L94\n\n### Cache getDutchAuctionDiscountPrice() to save 1 SLOAD\n```solidity\nFile: contracts/lybra/pools/LybraStETHVault.sol\n66:        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000; // @audit: 1st function call (reads `lidoRebaseTime`)\n...\n94:        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp); // @audit: 2nd function call (reads `lidoRebaseTime` again)\n```\n```diff\ndiff --git a/lybra/pools/LybraStETHVault.sol b/lybra/pools/LybraStETHVault.sol\nindex 3f20843..8b8984b 100644\n--- a/lybra/pools/LybraStETHVault.sol\n+++ b/lybra/pools/LybraStETHVault.sol\n@@ -63,7 +63,8 @@ contract LybraStETHDepositVault is LybraEUSDVaultBase {\n         uint256 excessAmount = collateralAsset.balanceOf(address(this)) - totalDepositedAsset;\n         require(excessAmount > 0 && stETHAmount > 0, \"Only LSD excess income can be exchanged\");\n         uint256 realAmount = stETHAmount > excessAmount ? excessAmount : stETHAmount;\n-        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * getDutchAuctionDiscountPrice()) / 10000;\n+        uint256 _dutchAuctionDiscountPrice = getDutchAuctionDiscountPrice();\n+        uint256 payAmount = (((realAmount * getAssetPrice()) / 1e18) * _dutchAuctionDiscountPrice) / 10000;\n\n         uint256 income = feeStored + _newFee();\n         if (payAmount > income) {\n@@ -91,7 +92,7 @@ contract LybraStETHDepositVault is LybraEUSDVaultBase {\n\n         lastReportTime = block.timestamp;\n         collateralAsset.transfer(msg.sender, realAmount);\n-        emit LSDValueCaptured(realAmount, payAmount, getDutchAuctionDiscountPrice(), block.timestamp);\n+        emit LSDValueCaptured(realAmount, payAmount, _dutchAuctionDiscountPrice, block.timestamp);\n     }\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address esLBR balance changes, call the refreshReward method to update rewards to be claimed.\n */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IesLBR.sol\";\n\ninterface IesLBRBoost {\n    function getUnlockTime(\n        address user\n    ) external view returns (uint256 unlockTime);\n}\n\ncontract ProtocolRewardsPool is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBR public esLBR;\n    IesLBR public LBR;\n    IesLBRBoost public esLBRBoost;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n    mapping(address => uint) public time2fullRedemption;\n    mapping(address => uint) public unstakeRatio;\n    mapping(address => uint) public lastWithdrawTime;\n    uint256 immutable exitCycle = 90 days;\n    uint256 public grabableAmount;\n    uint256 public grabFeeRatio = 3000;\n    event Restake(address indexed user, uint256 amount, uint256 time);\n    event StakeLBR(address indexed user, uint256 amount, uint256 time);\n    event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n    event WithdrawLBR(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 eUSDAmount, address token, uint256 tokenAmount, uint256 time);\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    function setTokenAddress(address _eslbr, address _lbr, address _boost) external onlyOwner {\n        esLBR = IesLBR(_eslbr);\n        LBR = IesLBR(_lbr);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setGrabCost(uint256 _ratio) external onlyOwner {\n        require(_ratio <= 8000, \"BCE\");\n        grabFeeRatio = _ratio;\n    }\n\n    // Total staked\n    function totalStaked() internal view returns (uint256) {\n        return esLBR.totalSupply();\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return esLBR.balanceOf(staker);\n    }\n\n    function stake(uint256 amount) external {\n        LBR.burn(msg.sender, amount);\n        esLBR.mint(msg.sender, amount);\n        emit StakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Unlocks esLBR and converts it to LBR.\n     * @param amount The amount to convert.\n     * Requirements:\n     * The current time must be greater than the unlock time retrieved from the boost contract for the user.\n     * Effects:\n     * Resets the user's vesting data, entering a new vesting period, when converting to LBR.\n     */\n    function unstake(uint256 amount) external {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended. You can't convert your esLBR now.\");\n        esLBR.burn(msg.sender, amount);\n        withdraw(msg.sender);\n        uint256 total = amount;\n        if (time2fullRedemption[msg.sender] > block.timestamp) {\n            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n        }\n        unstakeRatio[msg.sender] = total / exitCycle;\n        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n        emit UnstakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    function withdraw(address user) public {\n        uint256 amount = getClaimAbleLBR(user);\n        if (amount > 0) {\n            LBR.mint(user, amount);\n        }\n        lastWithdrawTime[user] = block.timestamp;\n        emit WithdrawLBR(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeems and converts the ESLBR being claimed in advance,\n     * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n     */\n    function unlockPrematurely() external {\n        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n        if (amount > 0) {\n            LBR.mint(msg.sender, amount);\n        }\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        grabableAmount += burnAmount;\n    }\n\n    /**\n     * @dev Purchase the accumulated amount of pre-claimed lost ESLBR in the contract using LBR.\n     * @param amount The amount of ESLBR to be purchased.\n     * Requirements:\n     * The amount must be greater than 0.\n     */\n    function grabEsLBR(uint256 amount) external {\n        require(amount > 0, \"QMG\");\n        grabableAmount -= amount;\n        LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);\n        esLBR.mint(msg.sender, amount);\n    }\n\n    /**\n     * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n     */\n    function reStake() external {\n        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n        esLBR.mint(msg.sender, amount);\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        emit Restake(msg.sender, amount, block.timestamp);\n    }\n\n    function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n        uint256 a = getReservedLBRForVesting(user);\n        if (a == 0) return 0;\n        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n    }\n\n    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n        }\n    }\n\n    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > block.timestamp) {\n            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n        }\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    function getClaimAbleUSD(address user) external view returns (uint256 amount) {\n        amount = IEUSD(configurator.getEUSDAddress()).getMintedEUSDByShares(earned(user));\n    }\n\n    /**\n     * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.\n     */\n    modifier updateReward(address account) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        _;\n    }\n\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    /**\n     * @notice When claiming protocol rewards earnings, if there is a sufficient amount of eUSD in the ProtocolRewards Pool,\n     * the eUSD will be prioritized for distribution. Distributes earnings in the order of peUSD and other stablecoins if the eUSD balance is insufficient..\n     */\n    function getReward() external updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IEUSD EUSD = IEUSD(configurator.getEUSDAddress());\n            uint256 balance = EUSD.sharesOf(address(this));\n            uint256 eUSDShare = balance >= reward ? reward : reward - balance;\n            EUSD.transferShares(msg.sender, eUSDShare);\n            if(reward > eUSDShare) {\n                ERC20 peUSD = ERC20(configurator.peUSD());\n                uint256 peUSDBalance = peUSD.balanceOf(address(this));\n                if(peUSDBalance >= reward - eUSDShare) {\n                    peUSD.transfer(msg.sender, reward - eUSDShare);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(peUSD), reward - eUSDShare, block.timestamp);\n                } else {\n                    if(peUSDBalance > 0) {\n                        peUSD.transfer(msg.sender, peUSDBalance);\n                    }\n                    ERC20 token = ERC20(configurator.stableToken());\n                    uint256 tokenAmount = (reward - eUSDShare - peUSDBalance) * token.decimals() / 1e18;\n                    token.transfer(msg.sender, tokenAmount);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(token), reward - eUSDShare, block.timestamp);\n                }\n            } else {\n                emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(0), 0, block.timestamp);\n            }\n           \n        }\n    }\n\n    /**\n     * @dev Receives stablecoin tokens sent by the configurator contract and records the protocol rewards accumulation per esLBR held.\n     * @param amount The amount of rewards to be distributed.\n     * @param tokenType The type of token (0 for eUSD, 1 for other stablecoins, 2 for peUSD).\n     * @dev This function is called by the configurator contract to distribute rewards.\n     * @dev When receiving stablecoin tokens other than eUSD, the decimals of the token are converted to 18 for consistent calculations.\n     */\n    function notifyRewardAmount(uint amount, uint tokenType) external {\n        require(msg.sender == address(configurator));\n        if (totalStaked() == 0) return;\n        require(amount > 0, \"amount = 0\");\n        if(tokenType == 0) {\n            uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n        } else if(tokenType == 1) {\n            ERC20 token = ERC20(configurator.stableToken());\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n        } else {\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/lybra/pools/base/LybraEUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/IEUSD.sol\";\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface LbrStakingPool {\n    function notifyRewardAmount(uint256 amount) external;\n}\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraEUSDVaultBase {\n    IEUSD public immutable EUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public immutable badCollateralRatio = 150 * 1e18;\n    IPriceFeed immutable etherOracle;\n\n    uint256 public totalDepositedAsset;\n    uint256 public lastReportTime;\n    uint256 public poolTotalEUSDCirculation;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    uint8 immutable vaultType = 0;\n    uint256 public feeStored;\n    mapping(address => uint256) depositedTime;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n\n    event WithdrawAsset(address sponsor, address asset, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 liquidateEtherAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n    event LSDValueCaptured(uint256 stETHAdded, uint256 payoutEUSD, uint256 discountRate, uint256 timestamp);\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 eusdAmount, uint256 collateralAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _collateralAsset, address _etherOracle, address _configurator) {\n        collateralAsset = IERC20(_collateralAsset);\n        configurator = Iconfigurator(_configurator);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    /**\n     * @notice Allowing direct deposits of ETH, the pool may convert it into the corresponding collateral during the implementation.\n     * While depositing, it is possible to simultaneously mint eUSD for oneself.\n     * Emits a `DepositEther` event.\n     *\n     * Requirements:\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     * - msg.value Must be higher than 0.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit collateral and allow minting eUSD for oneself.\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 stETH.\");\n\n        bool success = collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(success, \"TF\");\n\n        totalDepositedAsset += assetAmount;\n        depositedAsset[msg.sender] += assetAmount;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check userâ€™s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZERO_WITHDRAW\");\n        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\");\n        totalDepositedAsset -= amount;\n        depositedAsset[msg.sender] -= amount;\n\n        uint256 withdrawal = checkWithdrawal(msg.sender, amount);\n\n        collateralAsset.transfer(onBehalfOf, withdrawal);\n        if (borrowed[msg.sender] > 0) {\n            _checkHealth(msg.sender, getAssetPrice());\n        }\n        emit WithdrawAsset(msg.sender, address(collateralAsset), onBehalfOf, withdrawal, block.timestamp);\n    }\n\n    function checkWithdrawal(address user, uint256 amount) internal view returns (uint256 withdrawal) {\n        withdrawal = block.timestamp - 3 days >= depositedTime[user] ? amount : (amount * 999) / 1000;\n    }\n\n    /**\n     * @notice The mint amount number of EUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n        require(amount > 0, \"ZERO_MINT\");\n        _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of EUSD and payback the amount of minted EUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"BURN_TO_THE_ZERO_ADDRESS\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using EUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - collateralAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize EUSD\n     * @dev After liquidation, borrower's debt is reduced by collateralAmount * etherPrice, collateral is reduced by the collateralAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < badCollateralRatio, \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(EUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, eusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        totalDepositedAsset -= reducedAsset;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is below badCollateralRatio, borrowers with collateralRatio below 125% could be fully liquidated.\n     * Emits a `LiquidationRecord` event.\n     *\n     * Requirements:\n     * - Current overallCollateralRatio should be below badCollateralRatio\n     * - `onBehalfOf`collateralRatio should be below 125%\n     * @dev After Liquidation, borrower's debt is reduced by collateralAmount * etherPrice, deposit is reduced by collateralAmount * borrower's collateralRatio. Keeper gets a liquidation reward of `keeperRatio / borrower's collateralRatio\n     */\n    function superLiquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        require((totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\");\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < 125 * 1e18, \"borrowers collateralRatio should below 125%\");\n        require(assetAmount <= depositedAsset[onBehalfOf], \"total of collateral can be liquidated at most\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n        if (onBehalfOfCollateralRatio >= 1e20) {\n            eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRatio;\n        }\n        require(EUSD.allowance(provider, address(this)) >= eusdAmount, \"provider should authorize to provide liquidation EUSD\");\n\n        _repay(provider, onBehalfOf, eusdAmount);\n\n        totalDepositedAsset -= assetAmount;\n        depositedAsset[onBehalfOf] -= assetAmount;\n        uint256 reward2keeper;\n        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) {\n            reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio;\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        collateralAsset.transfer(provider, assetAmount - reward2keeper);\n\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, assetAmount, reward2keeper, true, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDistribution` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 payAmount) external virtual;\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`eusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 eusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, eusdAmount);\n        uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        totalDepositedAsset -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Mints eUSD tokens for a user.\n     * @param _provider The provider's address.\n     * @param _onBehalfOf The user's address.\n     * @param _mintAmount The amount of eUSD tokens to be minted.\n     * @param _assetPrice The current collateral asset price.\n     * @dev Mints eUSD tokens for the specified user, updates the total supply and borrowed balance,\n     * refreshes the mint reward for the provider, checks the health of the provider,\n     * and emits a Mint event.\n     * Requirements:\n     * The total supply plus mint amount must not exceed the maximum supply allowed for the vault.\n     * The provider must have sufficient borrowing capacity to mint the specified amount.\n     */\n    function _mintEUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        try configurator.refreshMintReward(_provider) {} catch {}\n        borrowed[_provider] += _mintAmount;\n\n        EUSD.mint(_onBehalfOf, _mintAmount);\n        _saveReport();\n        poolTotalEUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(msg.sender, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount EUSD to payback minted EUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalEUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        uint256 amount = borrowed[_onBehalfOf] >= _amount ? _amount : borrowed[_onBehalfOf];\n\n        EUSD.burn(_provider, amount);\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n\n        borrowed[_onBehalfOf] -= amount;\n        _saveReport();\n        poolTotalEUSDCirculation -= amount;\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address _user, uint256 _assetPrice) internal view {\n        if (((depositedAsset[_user] * _assetPrice * 100) / borrowed[_user]) < configurator.getSafeCollateralRatio(address(this))) revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _saveReport() internal {\n        feeStored += _newFee();\n        lastReportTime = block.timestamp;\n    }\n\n    function _newFee() internal view returns (uint256) {\n        return (poolTotalEUSDCirculation * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - lastReportTime)) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    function getBorrowedOf(address user) external view returns (uint256) {\n        return borrowed[user];\n    }\n\n    function getPoolTotalEUSDCirculation() external view returns (uint256) {\n        return poolTotalEUSDCirculation;\n    }\n\n    function getAsset() external view virtual returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {"
    }
  ]
}