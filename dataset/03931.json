{
  "Title": "[M02] Inverse price fetched from Uniswap",
  "Content": "The [`UniswapOracle`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol) contract keeps track of the Uniswap price of `USDC` for use throughout the protocol and stores the price as USDC-per-WETH. The [`update`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol#L48) function [checks the price on Uniswap](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol#L50) and, subject to some conditions, updates the price in the oracle. When checking the Uniswap price, Uniswap returns `price0Cumulative` and `price1Cumulative`, which contain the WETH-per-USDC and USDC-per-WETH prices, respectively. The boolean [`isPrice0`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol#L18) is then used to flag whether Uniswap’s `price0Cumulative` is the correct price to use in the oracle – and if `isPrice0` is `false`, the oracle instead uses `price1Cumulative`.\n\n\nHowever, the value of [`isPrice0`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol#L18) is [initialized](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/orchestration/CoreOrchestrator.sol#L236) incorrectly. The protocol initializes this value to `true`, but it can be seen in [Uniswap’s code](https://github.com/Uniswap/uniswap-v2-periphery/blob/dda62473e2da448bc9cb8f4514dadda4aeede5f4/contracts/libraries/UniswapV2OracleLibrary.sol#L30) that `price0Cumulative` actually holds the price of WETH-per-USDC, and `price1Cumulative`, instead, holds the price of USDC-per-WETH.\n\n\nDue to the fact that the update function [later performs an inversion](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/oracle/UniswapOracle.sol#L60), the final price is correctly stored as USDC-per-WETH. However, the inversion may cause a loss of accuracy on the USDC-per-WETH rate. Furthermore, the code is confusing to understand due to the false statements about what is being fetched from Uniswap and the lack of explanation regarding the inversion.\n\n\nConsider fetching the USDC-per-WETH from Uniswap, as implied by the code, and updating the logic to no longer invert the fetched price.\n\n\n**Update:** *Fixed in [PR#21](https://github.com/fei-protocol/fei-protocol-core/pull/21).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/UniswapOracle.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n// Referencing Uniswap Example Simple Oracle\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\nimport \"./IUniswapOracle.sol\";\nimport \"../refs/CoreRef.sol\";\n\n/// @title IUniswapOracle implementation contract\n/// @author Fei Protocol\ncontract UniswapOracle is IUniswapOracle, CoreRef {\n\tusing Decimal for Decimal.D256;\n\n\tIUniswapV2Pair public override pair;\n\tbool private isPrice0;\n\n\tuint public override priorCumulative; \n\tuint32 public override priorTimestamp;\n\n\tDecimal.D256 private twap = Decimal.zero();\n\tuint32 public override duration;\n\n\tbool public override killSwitch;\n\n\t/// @notice UniswapOracle constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pair Uniswap Pair to provide TWAP\n\t/// @param _duration TWAP duration\n\t/// @param _isPrice0 flag for using token0 or token1 for cumulative on Uniswap\n\tconstructor(\n\t\taddress _core, \n\t\taddress _pair, \n\t\tuint32 _duration,\n\t\tbool _isPrice0\n\t) public CoreRef(_core) {\n\t\tpair = IUniswapV2Pair(_pair);\n\t\t// Relative to USD per ETH price\n\t\tisPrice0 = _isPrice0;\n\n\t\tduration = _duration;\n\n\t\t_init();\n\t}\n\n\tfunction update() external override returns (bool) {\n\t\t(uint price0Cumulative, uint price1Cumulative, uint32 currentTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n\t\tuint32 deltaTimestamp = currentTimestamp - priorTimestamp;\n\t\tif(currentTimestamp <= priorTimestamp || deltaTimestamp < duration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tuint currentCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n\t\tuint deltaCumulative = (currentCumulative - priorCumulative) / 1e12;\n\n\t\tDecimal.D256 memory _twap = Decimal.ratio(2**112, deltaCumulative / deltaTimestamp);\n\t\ttwap = _twap;\n\n\t\tpriorTimestamp = currentTimestamp;\n\t\tpriorCumulative = currentCumulative;\n\n\t\temit Update(_twap.asUint256());\n\n\t\treturn true;\n\t}\n\n    function read() external view override returns (Decimal.D256 memory, bool) {\n    \tbool valid = !(killSwitch || twap.isZero());\n    \treturn (twap, valid);\n    }\n \n\tfunction setKillSwitch(bool _killSwitch) external override onlyGovernor {\n\t\tkillSwitch = _killSwitch;\n\t\temit KillSwitchUpdate(_killSwitch);\n\t}\n\n\tfunction setDuration(uint32 _duration) external override onlyGovernor {\n\t\tduration = _duration;\n\t\temit DurationUpdate(_duration);\n\t}\n\n\tfunction _init() internal {\n        uint price0Cumulative = pair.price0CumulativeLast();\n        uint price1Cumulative = pair.price1CumulativeLast();\n\n        (,, uint32 currentTimestamp) = pair.getReserves();\n\n        priorTimestamp = currentTimestamp;\n\t\tpriorCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n\t}\n\n    function _getCumulative(uint price0Cumulative, uint price1Cumulative) internal view returns (uint) {\n\t\treturn isPrice0 ? price0Cumulative : price1Cumulative;\n\t}\n}"
    },
    {
      "filename": "contracts/oracle/UniswapOracle.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n// Referencing Uniswap Example Simple Oracle\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\";\nimport \"./IUniswapOracle.sol\";\nimport \"../refs/CoreRef.sol\";\n\n/// @title IUniswapOracle implementation contract\n/// @author Fei Protocol\ncontract UniswapOracle is IUniswapOracle, CoreRef {\n\tusing Decimal for Decimal.D256;\n\n\tIUniswapV2Pair public override pair;\n\tbool private isPrice0;\n\n\tuint public override priorCumulative; \n\tuint32 public override priorTimestamp;\n\n\tDecimal.D256 private twap = Decimal.zero();\n\tuint32 public override duration;\n\n\tbool public override killSwitch;\n\n\t/// @notice UniswapOracle constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pair Uniswap Pair to provide TWAP\n\t/// @param _duration TWAP duration\n\t/// @param _isPrice0 flag for using token0 or token1 for cumulative on Uniswap\n\tconstructor(\n\t\taddress _core, \n\t\taddress _pair, \n\t\tuint32 _duration,\n\t\tbool _isPrice0\n\t) public CoreRef(_core) {\n\t\tpair = IUniswapV2Pair(_pair);\n\t\t// Relative to USD per ETH price\n\t\tisPrice0 = _isPrice0;\n\n\t\tduration = _duration;\n\n\t\t_init();\n\t}\n\n\tfunction update() external override returns (bool) {\n\t\t(uint price0Cumulative, uint price1Cumulative, uint32 currentTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n\t\tuint32 deltaTimestamp = currentTimestamp - priorTimestamp;\n\t\tif(currentTimestamp <= priorTimestamp || deltaTimestamp < duration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tuint currentCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n\t\tuint deltaCumulative = (currentCumulative - priorCumulative) / 1e12;\n\n\t\tDecimal.D256 memory _twap = Decimal.ratio(2**112, deltaCumulative / deltaTimestamp);\n\t\ttwap = _twap;\n\n\t\tpriorTimestamp = currentTimestamp;\n\t\tpriorCumulative = currentCumulative;\n\n\t\temit Update(_twap.asUint256());\n\n\t\treturn true;\n\t}\n\n    function read() external view override returns (Decimal.D256 memory, bool) {\n    \tbool valid = !(killSwitch || twap.isZero());\n    \treturn (twap, valid);\n    }\n \n\tfunction setKillSwitch(bool _killSwitch) external override onlyGovernor {\n\t\tkillSwitch = _killSwitch;\n\t\temit KillSwitchUpdate(_killSwitch);\n\t}\n\n\tfunction setDuration(uint32 _duration) external override onlyGovernor {\n\t\tduration = _duration;\n\t\temit DurationUpdate(_duration);\n\t}\n\n\tfunction _init() internal {\n        uint price0Cumulative = pair.price0CumulativeLast();\n        uint price1Cumulative = pair.price1CumulativeLast();\n\n        (,, uint32 currentTimestamp) = pair.getReserves();\n\n        priorTimestamp = currentTimestamp;\n\t\tpriorCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n\t}\n\n    function _getCumulative(uint price0Cumulative, uint price1Cumulative) internal view returns (uint) {\n\t\treturn isPrice0 ? price0Cumulative : price1Cumulative;\n\t}\n}"
    }
  ]
}