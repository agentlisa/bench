{
  "Title": "[L-14] Use `_safeMint` instead of `_mint` in NonfungiblePositionManager.sol",
  "Content": "In NonfungiblePositionManager::mint(), `_mint()` is used instead of `_safeMint()`. \n\nNonfungiblePositionManager inherits openzeppelin's ERC721.sol which provides both `_mint()` and `_safeMint()`. `_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements IERC721Receiver. \n\nCurrent `_mint()` might cause user to lose their NFT position if the caller is a contract but has no means to manage ERC721 tokens.\n\n```solidity\n//thruster-protocol/thruster-clmm/contracts/NonfungiblePositionManager.sol\n    function mint(\n        MintParams calldata params\n    )\n...\n        _mint(params.recipient, (tokenId = _nextId++));\n\n```\n(https://github.com/code-423n4/2024-02-thruster/blob/3896779349f90a44b46f2646094cb34fffd7f66e/thruster-protocol/thruster-clmm/contracts/NonfungiblePositionManager.sol#L153)\n\n### Recommendations\n\nUse `_safeMint()` instead.\n\n**[jooleseth (Thruster) acknowledged](https://github.com/code-423n4/2024-02-thruster-findings/issues/16#issuecomment-1984507461)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2024-02-thruster-findings/issues/16#issuecomment-2005553538):**\n > All seem valid and useful.\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-thruster",
  "Code": [
    {
      "filename": "contracts/token/ERC721/ERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}"
    },
    {
      "filename": "thruster-protocol/thruster-clmm/contracts/NonfungiblePositionManager.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"interfaces/INonfungiblePositionManager.sol\";\nimport \"interfaces/INonfungibleTokenPositionDescriptor.sol\";\nimport \"interfaces/IThrusterPool.sol\";\n\nimport \"contracts/ThrusterGas.sol\";\nimport \"contracts/base/ERC721Permit.sol\";\nimport \"contracts/base/LiquidityManagement.sol\";\nimport \"contracts/base/Multicall.sol\";\nimport \"contracts/base/PeripheryImmutableState.sol\";\nimport \"contracts/base/PeripheryValidation.sol\";\nimport \"contracts/base/PoolInitializer.sol\";\nimport \"contracts/base/SelfPermit.sol\";\nimport \"contracts/libraries/FixedPoint128.sol\";\nimport \"contracts/libraries/FullMath.sol\";\nimport \"contracts/libraries/PoolAddress.sol\";\nimport \"contracts/libraries/PositionKey.sol\";\n\n/// @title NFT positions\n/// @notice Wraps Thruster CLMM positions in the ERC721 non-fungible token interface\ncontract NonfungiblePositionManager is\n    INonfungiblePositionManager,\n    Multicall,\n    ERC721Permit,\n    PeripheryImmutableState,\n    PoolInitializer,\n    LiquidityManagement,\n    PeripheryValidation,\n    SelfPermit,\n    ThrusterGas\n{\n    // details about the Thruster position\n    struct Position {\n        // the nonce for permits\n        uint96 nonce;\n        // the address that is approved for spending this token\n        address operator;\n        // the ID of the pool with which this token is connected\n        uint80 poolId;\n        // the tick range of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // the liquidity of the position\n        uint128 liquidity;\n        // the fee growth of the aggregate position as of the last action on the individual position\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        // how many uncollected tokens are owed to the position, as of the last computation\n        uint128 tokensOwed0;\n        uint128 tokensOwed1;\n    }\n\n    /// @dev IDs of pools assigned by this contract\n    mapping(address => uint80) private _poolIds;\n\n    /// @dev Pool keys by pool ID, to save on SSTOREs for position data\n    mapping(uint80 => PoolAddress.PoolKey) private _poolIdToPoolKey;\n\n    /// @dev The token ID position data\n    mapping(uint256 => Position) private _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint176 private _nextId = 1;\n    /// @dev The ID of the next pool that is used for the first time. Skips 0\n    uint80 private _nextPoolId = 1;\n\n    /// @dev The address of the token descriptor contract, which handles generating token URIs for position tokens\n    address private immutable _tokenDescriptor;\n\n    constructor(address _factory, address _WETH9, address _tokenDescriptor_, address _manager)\n        ERC721Permit(\"Thruster Positions NFT\", \"THRUST-POS\", \"1\")\n        PeripheryImmutableState(_factory, _WETH9)\n        ThrusterGas(_manager)\n    {\n        _tokenDescriptor = _tokenDescriptor_;\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function positions(uint256 tokenId)\n        external\n        view\n        override\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        )\n    {\n        Position memory position = _positions[tokenId];\n        require(position.poolId != 0, \"Invalid token ID\");\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n        return (\n            position.nonce,\n            position.operator,\n            poolKey.token0,\n            poolKey.token1,\n            poolKey.fee,\n            position.tickLower,\n            position.tickUpper,\n            position.liquidity,\n            position.feeGrowthInside0LastX128,\n            position.feeGrowthInside1LastX128,\n            position.tokensOwed0,\n            position.tokensOwed1\n        );\n    }\n\n    /// @dev Caches a pool key\n    function cachePoolKey(address pool, PoolAddress.PoolKey memory poolKey) private returns (uint80 poolId) {\n        poolId = _poolIds[pool];\n        if (poolId == 0) {\n            _poolIds[pool] = (poolId = _nextPoolId++);\n            _poolIdToPoolKey[poolId] = poolKey;\n        }\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function mint(MintParams calldata params)\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)\n    {\n        IThrusterPool pool;\n        (liquidity, amount0, amount1, pool) = addLiquidity(\n            AddLiquidityParams({\n                token0: params.token0,\n                token1: params.token1,\n                fee: params.fee,\n                recipient: address(this),\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: params.amount0Desired,\n                amount1Desired: params.amount1Desired,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min\n            })\n        );\n\n        _mint(params.recipient, (tokenId = _nextId++));\n        {\n            // avoid stack too deep\n            bytes32 positionKey = PositionKey.compute(address(this), params.tickLower, params.tickUpper);\n            (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128,,) = pool.positions(positionKey);\n\n            // idempotent set\n            uint80 poolId = cachePoolKey(\n                address(pool), PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee})\n            );\n\n            _positions[tokenId] = Position({\n                nonce: 0,\n                operator: address(0),\n                poolId: poolId,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidity: liquidity,\n                feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n                tokensOwed0: 0,\n                tokensOwed1: 0\n            });\n        }\n\n        emit IncreaseLiquidity(tokenId, liquidity, amount0, amount1, params.tickLower, params.tickUpper, address(pool));\n    }\n\n    modifier isAuthorizedForToken(uint256 tokenId) {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Not approved\");\n        _;\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) {\n        require(_exists(tokenId));\n        return INonfungibleTokenPositionDescriptor(_tokenDescriptor).tokenURI(this, tokenId);\n    }\n\n    // save bytecode by removing implementation of unused method\n    function baseURI() public pure override returns (string memory) {}\n\n    /// @inheritdoc INonfungiblePositionManager\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1)\n    {\n        Position storage position = _positions[params.tokenId];\n\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n\n        IThrusterPool pool;\n        (liquidity, amount0, amount1, pool) = addLiquidity(\n            AddLiquidityParams({\n                token0: poolKey.token0,\n                token1: poolKey.token1,\n                fee: poolKey.fee,\n                tickLower: position.tickLower,\n                tickUpper: position.tickUpper,\n                amount0Desired: params.amount0Desired,\n                amount1Desired: params.amount1Desired,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: address(this)\n            })\n        );\n\n        bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);\n\n        // this is now updated to the current transaction\n        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128,,) = pool.positions(positionKey);\n\n        position.tokensOwed0 += uint128(\n            FullMath.mulDiv(\n                feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128, position.liquidity, FixedPoint128.Q128\n            )\n        );\n        position.tokensOwed1 += uint128(\n            FullMath.mulDiv(\n                feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128, position.liquidity, FixedPoint128.Q128\n            )\n        );\n\n        position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n        position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n        position.liquidity += liquidity;\n\n        emit IncreaseLiquidity(\n            params.tokenId, liquidity, amount0, amount1, position.tickLower, position.tickUpper, address(pool)\n        );\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        override\n        isAuthorizedForToken(params.tokenId)\n        checkDeadline(params.deadline)\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(params.liquidity > 0);\n        Position storage position = _positions[params.tokenId];\n\n        uint128 positionLiquidity = position.liquidity;\n        require(positionLiquidity >= params.liquidity);\n\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n        IThrusterPool pool = IThrusterPool(PoolAddress.computeAddress(factory, poolKey));\n        (amount0, amount1) = pool.burn(position.tickLower, position.tickUpper, params.liquidity);\n\n        require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, \"Price slippage check\");\n\n        bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);\n        // this is now updated to the current transaction\n        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128,,) = pool.positions(positionKey);\n\n        position.tokensOwed0 += uint128(amount0)\n            + uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128, positionLiquidity, FixedPoint128.Q128\n                )\n            );\n        position.tokensOwed1 += uint128(amount1)\n            + uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128, positionLiquidity, FixedPoint128.Q128\n                )\n            );\n\n        position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n        position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n        // subtraction is safe because we checked positionLiquidity is gte params.liquidity\n        position.liquidity = positionLiquidity - params.liquidity;\n\n        emit DecreaseLiquidity(\n            params.tokenId, params.liquidity, amount0, amount1, position.tickLower, position.tickUpper, address(pool)\n        );\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function collect(CollectParams calldata params)\n        external\n        payable\n        override\n        isAuthorizedForToken(params.tokenId)\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(params.amount0Max > 0 || params.amount1Max > 0);\n        // allow collecting to the nft position manager address with address 0\n        address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n        Position storage position = _positions[params.tokenId];\n\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n\n        IThrusterPool pool = IThrusterPool(PoolAddress.computeAddress(factory, poolKey));\n\n        (uint128 tokensOwed0, uint128 tokensOwed1) = (position.tokensOwed0, position.tokensOwed1);\n\n        // trigger an update of the position fees owed and fee growth snapshots if it has any liquidity\n        if (position.liquidity > 0) {\n            pool.burn(position.tickLower, position.tickUpper, 0);\n            (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128,,) =\n                pool.positions(PositionKey.compute(address(this), position.tickLower, position.tickUpper));\n\n            tokensOwed0 += uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128, position.liquidity, FixedPoint128.Q128\n                )\n            );\n            tokensOwed1 += uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128, position.liquidity, FixedPoint128.Q128\n                )\n            );\n\n            position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n            position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n        }\n\n        // compute the arguments to give to the pool#collect method\n        (uint128 amount0Collect, uint128 amount1Collect) = (\n            params.amount0Max > tokensOwed0 ? tokensOwed0 : params.amount0Max,\n            params.amount1Max > tokensOwed1 ? tokensOwed1 : params.amount1Max\n        );\n\n        // the actual amounts collected are returned\n        (amount0, amount1) =\n            pool.collect(recipient, position.tickLower, position.tickUpper, amount0Collect, amount1Collect);\n\n        // sometimes there will be a few less wei than expected due to rounding down in core, but we just subtract the full amount expected\n        // instead of the actual amount so we can burn the token\n        (position.tokensOwed0, position.tokensOwed1) = (tokensOwed0 - amount0Collect, tokensOwed1 - amount1Collect);\n\n        emit Collect(\n            params.tokenId,\n            recipient,\n            amount0Collect,\n            amount1Collect,\n            position.tickLower,\n            position.tickUpper,\n            address(pool)\n        );\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function burn(uint256 tokenId) external payable override isAuthorizedForToken(tokenId) {\n        Position storage position = _positions[tokenId];\n        require(position.liquidity == 0 && position.tokensOwed0 == 0 && position.tokensOwed1 == 0, \"Not cleared\");\n        delete _positions[tokenId];\n        _burn(tokenId);\n    }\n\n    function _getAndIncrementNonce(uint256 tokenId) internal override returns (uint256) {\n        return uint256(_positions[tokenId].nonce++);\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) public view override(ERC721, IERC721) returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _positions[tokenId].operator;\n    }\n\n    /// @dev Overrides _approve to use the operator in the position, which is packed with the position permit nonce\n    function _approve(address to, uint256 tokenId) internal override(ERC721) {\n        _positions[tokenId].operator = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n}"
    }
  ]
}