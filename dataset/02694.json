{
  "Title": "M-2: When tokenX is an ERC777 token, users can bypass maxLiquidity",
  "Content": "# Issue M-2: When tokenX is an ERC777 token, users can bypass maxLiquidity \n\nSource: https://github.com/sherlock-audit/2022-11-buffer-judging/issues/112 \n\n## Found by \ncccz\n\n## Summary\nWhen tokenX is an ERC777 token, users can use callbacks to provide liquidity exceeding maxLiquidity\n## Vulnerability Detail\nIn BufferBinaryPool._provide, when tokenX is an ERC777 token, the tokensToSend function of account will be called in tokenX.transferFrom before sending tokens. When the user calls provide again in tokensToSend, since BufferBinaryPool has not received tokens at this time, totalTokenXBalance() has not increased, and the following checks can be bypassed, so that users can provide liquidity exceeding maxLiquidity.\n```solidity\n         require(\n             balance + tokenXAmount <= maxLiquidity,\n             \"Pool has already reached it's max limit\"\n         );\n```\n## Impact\nusers can provide liquidity exceeding maxLiquidity.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-buffer/blob/main/contracts/contracts/core/BufferBinaryPool.sol#L216-L240\n## Tool used\n\nManual Review\n\n## Recommendation\nChange to\n```diff\n    function _provide(\n        uint256 tokenXAmount,\n        uint256 minMint,\n        address account\n    ) internal returns (uint256 mint) {\n+        bool success = tokenX.transferFrom(\n+            account,\n+            address(this),\n+            tokenXAmount\n+        );\n        uint256 supply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        require(\n            balance + tokenXAmount <= maxLiquidity,\n            \"Pool has already reached it's max limit\"\n        );\n\n        if (supply > 0 && balance > 0)\n            mint = (tokenXAmount * supply) / (balance);\n        else mint = tokenXAmount * INITIAL_RATE;\n\n        require(mint >= minMint, \"Pool: Mint limit is too large\");\n        require(mint > 0, \"Pool: Amount is too small\");\n\n-        bool success = tokenX.transferFrom(\n-            account,\n-            address(this),\n-            tokenXAmount\n-        );\n```\n\n## Discussion\n\n**0x00052**\n\nNeither tokenX (USDC or BFR) are ERC777, so not applicable to current contracts. Something to consider if the team plans to add and ERC777\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/24",
  "Code": [
    {
      "filename": "contracts/contracts/core/BufferBinaryPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport \"../interfaces/Interfaces.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @author Heisenberg\n * @title Buffer TokenX Liquidity Pool\n * @notice Accumulates liquidity in TokenX from LPs and distributes P&L in TokenX\n */\ncontract BufferBinaryPool is\n    ERC20(\"Buffer LP Token\", \"BLP\"),\n    AccessControl,\n    ILiquidityPool\n{\n    ERC20 public tokenX;\n    uint16 public constant ACCURACY = 1e3;\n    uint32 public constant INITIAL_RATE = 1;\n    uint32 public lockupPeriod = 10 minutes;\n    uint256 public lockedAmount;\n    uint256 public lockedPremium;\n    uint256 public maxLiquidity;\n    address public owner;\n    bytes32 public constant OPTION_ISSUER_ROLE =\n        keccak256(\"OPTION_ISSUER_ROLE\");\n\n    mapping(address => LockedLiquidity[]) public lockedLiquidity;\n    mapping(address => bool) public isHandler;\n    mapping(address => ProvidedLiquidity) public liquidityPerUser;\n\n    constructor(ERC20 _tokenX) {\n        tokenX = _tokenX;\n        owner = msg.sender;\n        maxLiquidity = 5000000 * 10**_tokenX.decimals();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /************************************************\n     *  ADMIN ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Used for adding or removing handlers\n     */\n    function setHandler(address _handler, bool _isActive)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        isHandler[_handler] = _isActive;\n    }\n\n    /**\n     * @notice Used for adjusting the max limit of the pool\n     */\n    function setMaxLiquidity(uint256 _maxLiquidity)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        maxLiquidity = _maxLiquidity;\n        emit UpdateMaxLiquidity(_maxLiquidity);\n    }\n\n    /************************************************\n     *  EXTERNAL/PUBLIC FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice ERC20 transferFrom. Overridden to allow handler to transfer without approval\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public virtual override returns (bool) {\n        if (isHandler[msg.sender]) {\n            _transfer(_sender, _recipient, _amount);\n            return true;\n        }\n\n        uint256 currentAllowance = allowance(_sender, msg.sender);\n        require(\n            currentAllowance >= _amount,\n            \"Pool: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(_sender, msg.sender, currentAllowance - _amount);\n        }\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice A provider supplies tokenX to the pool and receives BLP tokens\n     * @param minMint Minimum amount of tokens that should be received by a provider.\n                      Calling the provide function will require the minimum amount of tokens to be minted.\n                      The actual amount that will be minted could vary but can only be higher (not lower) than the minimum value.\n     */\n    function provide(uint256 tokenXAmount, uint256 minMint)\n        external\n        returns (uint256 mint)\n    {\n        mint = _provide(tokenXAmount, minMint, msg.sender);\n    }\n\n    /**\n     * @notice Called by handler to add liquidity for an account\n     */\n    function provideForAccount(\n        uint256 tokenXAmount,\n        uint256 minMint,\n        address account\n    ) external returns (uint256 mint) {\n        _validateHandler();\n        mint = _provide(tokenXAmount, minMint, account);\n    }\n\n    /**\n     * @notice Burns BLP and receives X from the pool\n     */\n    function withdraw(uint256 tokenXAmount) external {\n        _withdraw(tokenXAmount, msg.sender);\n    }\n\n    /**\n     * @notice Called by the Handler to burns BLP and receives X for a user\n     */\n    function withdrawForAccount(uint256 tokenXAmount, address account)\n        external\n        returns (uint256 burn)\n    {\n        _validateHandler();\n        burn = _withdraw(tokenXAmount, account);\n    }\n\n    /************************************************\n     *  OPTION ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @notice Called by BufferCallOptions to lock the funds\n     * @param id optionId\n     * @param tokenXAmount Amount of funds that should be locked in an option\n     * @param premium Premium paid to liquidity pool to lock the above funds\n     */\n    function lock(\n        uint256 id,\n        uint256 tokenXAmount,\n        uint256 premium\n    ) external override onlyRole(OPTION_ISSUER_ROLE) {\n        require(id == lockedLiquidity[msg.sender].length, \"Pool: Wrong id\");\n\n        require(\n            (lockedAmount + tokenXAmount) <= totalTokenXBalance(),\n            \"Pool: Amount is too large.\"\n        );\n\n        bool success = tokenX.transferFrom(msg.sender, address(this), premium);\n        require(success, \"Pool: The Premium transfer didn't go through\");\n\n        lockedLiquidity[msg.sender].push(\n            LockedLiquidity(tokenXAmount, premium, true)\n        );\n        lockedPremium = lockedPremium + premium;\n        lockedAmount = lockedAmount + tokenXAmount;\n    }\n\n    /**\n     * @notice Called by BufferOptions to unlock the funds\n     * @param id Id of LockedLiquidity that should be unlocked\n     */\n    function unlock(uint256 id) external override onlyRole(OPTION_ISSUER_ROLE) {\n        uint256 premium = _unlock(id);\n\n        emit Profit(id, premium);\n    }\n\n    /**\n     * @notice Called by BufferCallOptions to send funds to liquidity providers after an option's expiration\n     * @param id Id of LockedLiquidity\n     * @param to Provider\n     * @param tokenXAmount Funds that should be sent\n     */\n    function send(\n        uint256 id,\n        address to,\n        uint256 tokenXAmount\n    ) external override onlyRole(OPTION_ISSUER_ROLE) {\n        LockedLiquidity storage ll = lockedLiquidity[msg.sender][id];\n        require(ll.locked, \"Pool: lockedAmount is already unlocked\");\n        require(to != address(0));\n\n        ll.locked = false;\n        lockedPremium = lockedPremium - ll.premium;\n        lockedAmount = lockedAmount - ll.amount;\n\n        uint256 transferTokenXAmount = tokenXAmount > ll.amount\n            ? ll.amount\n            : tokenXAmount;\n\n        bool success = tokenX.transfer(to, transferTokenXAmount);\n        require(success, \"Pool: The Payout transfer didn't go through\");\n\n        if (transferTokenXAmount <= ll.premium)\n            emit Profit(id, ll.premium - transferTokenXAmount);\n        else emit Loss(id, transferTokenXAmount - ll.premium);\n    }\n\n    /************************************************\n     *  INTERNAL FUNCTIONS\n     ***********************************************/\n\n    function _provide(\n        uint256 tokenXAmount,\n        uint256 minMint,\n        address account\n    ) internal returns (uint256 mint) {\n        uint256 supply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        require(\n            balance + tokenXAmount <= maxLiquidity,\n            \"Pool has already reached it's max limit\"\n        );\n\n        if (supply > 0 && balance > 0)\n            mint = (tokenXAmount * supply) / (balance);\n        else mint = tokenXAmount * INITIAL_RATE;\n\n        require(mint >= minMint, \"Pool: Mint limit is too large\");\n        require(mint > 0, \"Pool: Amount is too small\");\n\n        bool success = tokenX.transferFrom(\n            account,\n            address(this),\n            tokenXAmount\n        );\n        require(success, \"Pool: The Provide transfer didn't go through\");\n\n        _mint(account, mint);\n\n        LockedAmount memory amountLocked = LockedAmount(block.timestamp, mint);\n        liquidityPerUser[account].lockedAmounts.push(amountLocked);\n        _updateLiquidity(account);\n\n        emit Provide(account, tokenXAmount, mint);\n    }\n\n    function _updateLiquidity(address account) internal {\n        (\n            uint256 unlockedAmount,\n            uint256 nextIndexForUnlock\n        ) = _getUnlockedLiquidity(account);\n\n        liquidityPerUser[account].unlockedAmount = unlockedAmount;\n        liquidityPerUser[account].nextIndexForUnlock = nextIndexForUnlock;\n    }\n\n    function _getUnlockedLiquidity(address account)\n        internal\n        view\n        returns (uint256 unlockedAmount, uint256 nextIndexForUnlock)\n    {\n        uint256 len = liquidityPerUser[account].lockedAmounts.length;\n        unlockedAmount = liquidityPerUser[account].unlockedAmount;\n        uint256 index = liquidityPerUser[account].nextIndexForUnlock;\n        nextIndexForUnlock = index;\n        for (uint256 n = index; n < len; n++) {\n            if (\n                liquidityPerUser[account].lockedAmounts[n].timestamp +\n                    lockupPeriod <=\n                block.timestamp\n            ) {\n                unlockedAmount += liquidityPerUser[account]\n                    .lockedAmounts[n]\n                    .amount;\n                nextIndexForUnlock = n + 1;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function _validateHandler() private view {\n        require(isHandler[msg.sender], \"Pool: forbidden\");\n    }\n\n    function _withdraw(uint256 tokenXAmount, address account)\n        internal\n        returns (uint256 burn)\n    {\n        require(\n            tokenXAmount <= availableBalance(),\n            \"Pool: Not enough funds on the pool contract. Please lower the amount.\"\n        );\n        uint256 totalSupply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        uint256 maxUserTokenXWithdrawal = (balanceOf(account) * balance) /\n            totalSupply;\n\n        uint256 tokenXAmountToWithdraw = maxUserTokenXWithdrawal < tokenXAmount\n            ? maxUserTokenXWithdrawal\n            : tokenXAmount;\n\n        burn = divCeil((tokenXAmountToWithdraw * totalSupply), balance);\n\n        _updateLiquidity(account);\n\n        require(\n            liquidityPerUser[account].unlockedAmount >= burn,\n            \"Pool: Withdrawal amount is greater than current unlocked amount\"\n        );\n        require(burn <= balanceOf(account), \"Pool: Amount is too large\");\n        require(burn > 0, \"Pool: Amount is too small\");\n\n        _burn(account, burn);\n\n        bool success = tokenX.transfer(account, tokenXAmountToWithdraw);\n        require(success, \"Pool: The Withdrawal didn't go through\");\n\n        emit Withdraw(account, tokenXAmountToWithdraw, burn);\n    }\n\n    function _unlock(uint256 id) internal returns (uint256 premium) {\n        LockedLiquidity storage ll = lockedLiquidity[msg.sender][id];\n        require(ll.locked, \"Pool: lockedAmount is already unlocked\");\n        ll.locked = false;\n\n        lockedPremium = lockedPremium - ll.premium;\n        lockedAmount = lockedAmount - ll.amount;\n        premium = ll.premium;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        if (!isHandler[from] && !isHandler[to] && from != address(0)) {\n            _updateLiquidity(from);\n            require(\n                liquidityPerUser[from].unlockedAmount >= value,\n                \"Pool: Transfer of funds in lock in period is blocked\"\n            );\n            liquidityPerUser[from].unlockedAmount -= value;\n            liquidityPerUser[to].unlockedAmount += value;\n        }\n    }\n\n    /************************************************\n     *  READ ONLY FUNCTIONS\n     ***********************************************/\n\n    /**\n     * @dev Returns the decimals of the token.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return tokenX.decimals();\n    }\n\n    /**\n     * @dev Converts BLP to tokenX.\n     */\n    function toTokenX(uint256 amount) public view returns (uint256) {\n        uint256 totalSupply = totalSupply();\n        uint256 balance = totalTokenXBalance();\n\n        return (amount * balance) / totalSupply;\n    }\n\n    /**\n     * @dev Returns available liquidity\n     */\n    function getUnlockedLiquidity(address account)\n        external\n        view\n        returns (uint256 unlockedAmount)\n    {\n        (unlockedAmount, ) = _getUnlockedLiquidity(account);\n    }\n\n    /**\n     * @notice Returns provider's share in X\n     */\n    function shareOf(address account) external view returns (uint256 share) {\n        if (totalSupply() > 0)\n            share = (totalTokenXBalance() * balanceOf(account)) / totalSupply();\n        else share = 0;\n    }\n\n    /**\n     * @notice Returns the amount of X available for withdrawals\n     */\n    function availableBalance() public view override returns (uint256 balance) {\n        return totalTokenXBalance() - lockedAmount;\n    }\n\n    /**\n     * @notice Returns the total balance of X provided to the pool\n     */\n    function totalTokenXBalance()\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        return tokenX.balanceOf(address(this)) - lockedPremium;\n    }\n\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n}"
    }
  ]
}