{
  "Title": "[M-04] Incorrect implementation of `RecordParser.readKeyValue()`",
  "Content": "\n`RecordParser.readKeyValue()` returns a wrong `value` if the terminator not found.<br>\nThis is a fundamental library and any contract using it may experience unexpected errors and problems due to this bug.\n\n### Proof of Concept\n\nThe implementation logic of `RecordParser.readKeyValue(bytes memory input, uint256 offset, uint256 len)` is roughly as follows:\n\n1.  Find the character `=` in the range `offset..(offset+len)` of input and record its position in `separator`.\n2.  Find the space character in the range `(separator+1)...(offset+len)` of input, and record its position in `terminator`.\n3.  Return `key: input[offset..separator]`, `value: input[(separator+1)..terminator]`, `nextOffset: terminator+1`\n\nThe problem is that if the space is not found in step 2, terminator will be set to `input.length` - [RecordParser.sol#L34](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/RecordParser.sol#L34):\n\n        if (terminator == type(uint256).max) {\n            terminator = input.length;\n        }\n\nThis is incorrect because the parameters passed require data to be read within range `offset..(offset+len)`, it should not return a value beyond `offset+len`.\n\nFor example, suppose we have: `input = \"...;key1=val1 key2=val2;...\"` and `offset` is the start position of `key2`.\n\nIf we call `readKeyValue(input, offset, 9)`, the function will return:\n\n    key: \"key2\"\n    value: \"val2;...\"\n    nextOffset: input.length+1\n\nThe returned `value` is wrong due to the incorrect implementation of RecordParser.\n\nThe correct return should be:\n\n    key: \"key2\"\n    value: \"val2\"\n    nextOffset: offset+9\n\nTest code for PoC:\n\n    diff --git a/contracts/dnsregistrar/mocks/DummyParser.sol b/contracts/dnsregistrar/mocks/DummyParser.sol\n    new file mode 100644\n    index 0000000..538e652\n    --- /dev/null\n    +++ b/contracts/dnsregistrar/mocks/DummyParser.sol\n    @@ -0,0 +1,34 @@\n    +pragma solidity ^0.8.4;\n    +\n    +import \"../../dnssec-oracle/BytesUtils.sol\";\n    +import \"../RecordParser.sol\";\n    +\n    +contract DummyParser {\n    +    using BytesUtils for bytes;\n    +\n    +    // parse data in format: name;key1=value1 key2=value2;url\n    +    function parseData(\n    +        bytes memory data,\n    +        uint256 kvCount\n    +    ) external pure returns (string memory name, string[] memory keys, string[] memory values, string memory url) {\n    +        uint256 len = data.length;\n    +        // retrieve name\n    +        uint256 sep1 = data.find(0, len, \";\");\n    +        name = string(data.substring(0, sep1));\n    +\n    +        // retrieve url\n    +        uint256 sep2 = data.find(sep1 + 1, len - sep1, \";\");\n    +        url = string(data.substring(sep2 + 1, len - sep2 - 1));\n    +\n    +        keys = new string[](kvCount);\n    +        values = new string[](kvCount);\n    +        // retrieve keys and values\n    +        uint256 offset = sep1 + 1;\n    +        for (uint256 i; i < kvCount && offset < len; i++) {\n    +            (bytes memory key, bytes memory val, uint256 nextOffset) = RecordParser.readKeyValue(data, offset, sep2 - offset);\n    +            keys[i] = string(key);\n    +            values[i] = string(val);\n    +            offset = nextOffset;\n    +        }\n    +    }\n    +}\n    diff --git a/test/DummyParser.test.js b/test/DummyParser.test.js\n    new file mode 100644\n    index 0000000..396557d\n    --- /dev/null\n    +++ b/test/DummyParser.test.js\n    @@ -0,0 +1,27 @@\n    +const { expect } = require('chai')\n    +const { ethers } = require('hardhat')\n    +const { toUtf8Bytes } = require('ethers/lib/utils')\n    +\n    +describe('DummyParser', () => {\n    +  let parser\n    +\n    +  before(async () => {\n    +    const factory = await ethers.getContractFactory('DummyParser')\n    +    parser = await factory.deploy()\n    +  })\n    +\n    +  it('parse data', async () => {\n    +    const data = \"usdt;issuer=tether decimals=18;https://tether.to\"\n    +    const [name, keys, values, url] = await parser.parseData(toUtf8Bytes(data), 2)\n    +    // correct name\n    +    expect(name).to.eq('usdt')\n    +    // correct keys and values\n    +    expect(keys[0]).to.eq('issuer')\n    +    expect(values[0]).to.eq('tether')\n    +    expect(keys[1]).to.eq('decimals')\n    +    // incorrect last value\n    +    expect(values[1]).to.eq('18;https://tether.to')\n    +    // correct url\n    +    expect(url).to.eq('https://tether.to')\n    +  })\n    +})\n    \\ No newline at end of file\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nWe should change [the assignment of `terminator`](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/RecordParser.sol#L34) so that it cannot exceed the query range:\n\n    diff --git a/contracts/dnsregistrar/RecordParser.sol b/contracts/dnsregistrar/RecordParser.sol\n    index 339f213..876a87f 100644\n    --- a/contracts/dnsregistrar/RecordParser.sol\n    +++ b/contracts/dnsregistrar/RecordParser.sol\n    @@ -31,11 +31,12 @@ library RecordParser {\n                 \" \"\n             );\n             if (terminator == type(uint256).max) {\n    -            terminator = input.length;\n    +            terminator = len + offset;\n    +            nextOffset = terminator;\n    +        } else {\n    +            nextOffset = terminator + 1;\n             }\n    -\n             key = input.substring(offset, separator - offset);\n             value = input.substring(separator + 1, terminator - separator - 1);\n    -        nextOffset = terminator + 1;\n         }\n     }\n\n**[Arachnid (ENS) acknowledged](https://github.com/code-423n4/2023-04-ens-findings/issues/246#issuecomment-1536266531)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnsregistrar/RecordParser.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"../dnssec-oracle/BytesUtils.sol\";\n\nlibrary RecordParser {\n    using BytesUtils for bytes;\n\n    /**\n     * @dev Parses a key-value record into a key and value.\n     * @param input The input string\n     * @param offset The offset to start reading at\n     */\n    function readKeyValue(\n        bytes memory input,\n        uint256 offset,\n        uint256 len\n    )\n        internal\n        pure\n        returns (bytes memory key, bytes memory value, uint256 nextOffset)\n    {\n        uint256 separator = input.find(offset, len, \"=\");\n        if (separator == type(uint256).max) {\n            return (\"\", \"\", type(uint256).max);\n        }\n\n        uint256 terminator = input.find(\n            separator,\n            len + offset - separator,\n            \" \"\n        );\n        if (terminator == type(uint256).max) {\n            terminator = input.length;\n        }\n\n        key = input.substring(offset, separator - offset);\n        value = input.substring(separator + 1, terminator - separator - 1);\n        nextOffset = terminator + 1;\n    }\n}"
    },
    {
      "filename": "contracts/dnsregistrar/RecordParser.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"../dnssec-oracle/BytesUtils.sol\";\n\nlibrary RecordParser {\n    using BytesUtils for bytes;\n\n    /**\n     * @dev Parses a key-value record into a key and value.\n     * @param input The input string\n     * @param offset The offset to start reading at\n     */\n    function readKeyValue(\n        bytes memory input,\n        uint256 offset,\n        uint256 len\n    )\n        internal\n        pure\n        returns (bytes memory key, bytes memory value, uint256 nextOffset)\n    {\n        uint256 separator = input.find(offset, len, \"=\");\n        if (separator == type(uint256).max) {\n            return (\"\", \"\", type(uint256).max);\n        }\n\n        uint256 terminator = input.find(\n            separator,\n            len + offset - separator,\n            \" \"\n        );\n        if (terminator == type(uint256).max) {\n            terminator = input.length;\n        }\n\n        key = input.substring(offset, separator - offset);\n        value = input.substring(separator + 1, terminator - separator - 1);\n        nextOffset = terminator + 1;\n    }\n}"
    }
  ]
}