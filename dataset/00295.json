{
  "Title": "Maximum 2 instead of 12 extra reward tokens are supported",
  "Content": "##### Description\nThe Convex ExtraRewardStashV3 contract allows the owner to add up to 12 tokens, while the Gearbox adapter supports only 2. As a result, the adapter cannot be used for pools with more than 2 reward tokens. \n\nThis issue is rated as MEDIUM severity because pools with 3 or more reward tokens will require redeployment of the adapter contract, but the likelihood of this issue is low.\n\nRelated code: only 2 reward tokens are supported - https://github.com/Gearbox-protocol/integrations-v3/blob/2575396b2c933953483dd85cb2d5900134349f80/contracts/adapters/convex/ConvexV1_BaseRewardPool.sol#L80-L91\n\n##### Recommendation\nWe recommend implementing support for the same number of reward tokens as in the Convex pool.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/adapters/convex/ConvexV1_BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2023.\npragma solidity ^0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ICreditManagerV3} from \"@gearbox-protocol/core-v3/contracts/interfaces/ICreditManagerV3.sol\";\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {AdapterType} from \"@gearbox-protocol/sdk-gov/contracts/AdapterType.sol\";\nimport {BitMask} from \"@gearbox-protocol/core-v3/contracts/libraries/BitMask.sol\";\n\nimport {IBooster} from \"../../integrations/convex/IBooster.sol\";\nimport {IBaseRewardPool} from \"../../integrations/convex/IBaseRewardPool.sol\";\nimport {IRewards, IExtraRewardWrapper, IAuraL2Coordinator} from \"../../integrations/convex/Interfaces.sol\";\nimport {IConvexV1BaseRewardPoolAdapter} from \"../../interfaces/convex/IConvexV1BaseRewardPoolAdapter.sol\";\n\n/// @title Convex V1 BaseRewardPool adapter interface\n/// @notice Implements logic for interacting with Convex reward pool\ncontract ConvexV1BaseRewardPoolAdapter is AbstractAdapter, IConvexV1BaseRewardPoolAdapter {\n    using BitMask for uint256;\n\n    AdapterType public constant override _gearboxAdapterType = AdapterType.CONVEX_V1_BASE_REWARD_POOL;\n    uint16 public constant override _gearboxAdapterVersion = 3_01;\n\n    /// @notice Address of a Curve LP token deposited into the Convex pool\n    address public immutable override curveLPtoken;\n\n    /// @notice Address of a Convex LP token staked in the reward pool\n    address public immutable override stakingToken;\n\n    /// @notice Address of a phantom token representing account's stake in the reward pool\n    address public immutable override stakedPhantomToken;\n\n    /// @notice Address of a reward token of the first extra reward pool, if any\n    address public immutable override extraReward1;\n\n    /// @notice Address of a reward token of the second extra reward pool, if any\n    address public immutable override extraReward2;\n\n    /// @notice Collateral token mask of a Curve LP token in the credit manager\n    uint256 public immutable override curveLPTokenMask;\n\n    /// @notice Collateral token mask of a Convex LP token in the credit manager\n    uint256 public immutable override stakingTokenMask;\n\n    /// @notice Collateral token mask of a reward pool stake token\n    uint256 public immutable override stakedTokenMask;\n\n    /// @notice Bitmask of all reward tokens of the pool (CRV, CVX, extra reward tokens, if any) in the credit manager\n    uint256 public immutable override rewardTokensMask;\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _baseRewardPool BaseRewardPool address\n    /// @param _stakedPhantomToken Reward pool stake token address\n    constructor(address _creditManager, address _baseRewardPool, address _stakedPhantomToken)\n        AbstractAdapter(_creditManager, _baseRewardPool) // U:[CVX1R-1]\n    {\n        stakingToken = address(IBaseRewardPool(_baseRewardPool).stakingToken()); // U:[CVX1R-1]\n        stakingTokenMask = _getMaskOrRevert(stakingToken); // U:[CVX1R-1]\n\n        stakedPhantomToken = _stakedPhantomToken; // U:[CVX1R-1]\n        stakedTokenMask = _getMaskOrRevert(stakedPhantomToken); // U:[CVX1R-1]\n\n        address booster = IBaseRewardPool(_baseRewardPool).operator();\n        IBooster.PoolInfo memory poolInfo = IBooster(booster).poolInfo(IBaseRewardPool(_baseRewardPool).pid());\n        curveLPtoken = poolInfo.lptoken; // U:[CVX1R-1]\n        curveLPTokenMask = _getMaskOrRevert(curveLPtoken); // U:[CVX1R-1]\n\n        uint256 _rewardTokensMask;\n\n        address rewardToken = address(IBaseRewardPool(_baseRewardPool).rewardToken());\n        _rewardTokensMask = _rewardTokensMask.enable(_getMaskOrRevert(rewardToken)); // U:[CVX1R-1]\n\n        _rewardTokensMask = _rewardTokensMask.enable(_getSecondaryRewardMask(booster)); // U:[CVX1R-1]\n\n        address _extraReward1;\n        address _extraReward2;\n        uint256 extraRewardLength = IBaseRewardPool(_baseRewardPool).extraRewardsLength();\n\n        if (extraRewardLength >= 1) {\n            uint256 _extraRewardMask;\n            (_extraReward1, _extraRewardMask) = _getExtraReward(0);\n            _rewardTokensMask = _rewardTokensMask.enable(_extraRewardMask);\n\n            if (extraRewardLength >= 2) {\n                (_extraReward2, _extraRewardMask) = _getExtraReward(1);\n                _rewardTokensMask = _rewardTokensMask.enable(_extraRewardMask);\n            }\n        }\n\n        extraReward1 = _extraReward1; // U:[CVX1R-2]\n        extraReward2 = _extraReward2; // U:[CVX1R-2]\n        rewardTokensMask = _rewardTokensMask; // U:[CVX1R-2]\n    }\n\n    /// @dev Returns `i`-th extra reward token and its collateral mask in the credit mnager\n    function _getExtraReward(uint256 i) internal view returns (address extraReward, uint256 extraRewardMask) {\n        extraReward = IRewards(IBaseRewardPool(targetContract).extraRewards(i)).rewardToken();\n\n        // `extraReward` might be a wrapper around the reward token, and there seems to be no reliable way to check it\n        // programatically, so we assume that it's a wrapper if it's not recognized as collateral in the credit manager\n        try ICreditManagerV3(creditManager).getTokenMaskOrRevert(extraReward) returns (uint256 mask) {\n            extraRewardMask = mask;\n        } catch {\n            try IExtraRewardWrapper(extraReward).token() returns (address baseToken) {\n                extraReward = baseToken;\n            } catch {\n                extraReward = IExtraRewardWrapper(extraReward).baseToken();\n            }\n            extraRewardMask = _getMaskOrRevert(extraReward);\n        }\n    }\n\n    /// @dev Aura on L2 networks can have a different contract instead of the secondary reward token\n    ///      in IBooster.minter(). If the minter is not recognized as collateral in CM, we assume that\n    ///      it is not the secondary reward and handle the situation\n    function _getSecondaryRewardMask(address booster) internal view returns (uint256 rewardMask) {\n        address reward = IBooster(booster).minter();\n\n        try ICreditManagerV3(creditManager).getTokenMaskOrRevert(reward) returns (uint256 mask) {\n            rewardMask = mask;\n        } catch {\n            reward = IAuraL2Coordinator(reward).auraOFT();\n            rewardMask = _getMaskOrRevert(reward);\n        }\n    }\n\n    // ----- //\n    // STAKE //\n    // ----- //\n\n    /// @notice Stakes Convex LP token in the reward pool\n    /// @dev `amount` parameter is ignored since calldata is passed directly to the target contract\n    function stake(uint256)\n        external\n        override\n        creditFacadeOnly // U:[CVX1R-3]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) = _stake(msg.data, false); // U:[CVX1R-4]\n    }\n\n    /// @notice Stakes the entire balance of Convex LP token in the reward pool, except the specified amount\n    /// @param leftoverAmount Amount of Convex LP to keep on the account\n    function stakeDiff(uint256 leftoverAmount)\n        external\n        override\n        creditFacadeOnly // U:[CVX1R-3]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        address creditAccount = _creditAccount(); // U:[CVX1R-5]\n\n        uint256 balance = IERC20(stakingToken).balanceOf(creditAccount); // U:[CVX1R-5]\n\n        if (balance > leftoverAmount) {\n            unchecked {\n                (tokensToEnable, tokensToDisable) =\n                    _stake(abi.encodeCall(IBaseRewardPool.stake, (balance - leftoverAmount)), leftoverAmount <= 1); // U:[CVX1R-5]\n            }\n        }\n    }\n\n    /// @dev Internal implementation of `stake` and `stakeDiff`\n    ///      - Staking token is approved because reward pool needs permission to transfer it\n    ///      - Staked token is enabled after the call\n    ///      - Staking token is only disabled when staking the entire balance\n    function _stake(bytes memory callData, bool disableStakingToken)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _approveToken(stakingToken, type(uint256).max); // U:[CVX1R-4,5]\n        _execute(callData); // U:[CVX1R-4,5]\n        _approveToken(stakingToken, 1); // U:[CVX1R-4,5]\n        (tokensToEnable, tokensToDisable) = (stakedTokenMask, disableStakingToken ? stakingTokenMask : 0);\n    }\n\n    // ----- //\n    // CLAIM //\n    // ----- //\n\n    /// @notice Claims rewards on the current position, enables reward tokens\n    function getReward()\n        external\n        override\n        creditFacadeOnly // U:[CVX1R-3]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _execute(msg.data); // U:[CVX1R-6]\n        (tokensToEnable, tokensToDisable) = (rewardTokensMask, 0); // U:[CVX1R-6]\n    }\n\n    // -------- //\n    // WITHDRAW //\n    // -------- //\n\n    /// @notice Withdraws Convex LP token from the reward pool\n    /// @param claim Whether to claim staking rewards\n    /// @dev `amount` parameter is ignored since calldata is passed directly to the target contract\n    function withdraw(uint256, bool claim)\n        external\n        override\n        creditFacadeOnly // U:[CVX1R-3]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) = _withdraw(msg.data, claim, false); // U:[CVX1R-7]\n    }\n\n    /// @notice Withdraws the entire balance of Convex LP token from the reward pool, except the specified amount\n    /// @param leftoverAmount Amount of staked Convex LP to keep on the account\n    /// @param claim Whether to claim staking rewards\n    function withdrawDiff(uint256 leftoverAmount, bool claim)\n        external\n        override\n        creditFacadeOnly // U:[CVX1R-3]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        address creditAccount = _creditAccount(); // U:[CVX1R-6]\n\n        uint256 balance = IERC20(stakedPhantomToken).balanceOf(creditAccount); // U:[CVX1R-6]\n\n        if (balance > leftoverAmount) {\n            unchecked {\n                (tokensToEnable, tokensToDisable) = _withdraw(\n                    abi.encodeCall(IBaseRewardPool.withdraw, (balance - leftoverAmount, claim)),\n                    claim,\n                    leftoverAmount <= 1\n                ); // U:[CVX1R-6]\n            }\n        }\n    }\n\n    /// @dev Internal implementation of `withdraw` and `withdrawDiff`\n    ///      - Staking token is enabled after the call\n    ///      - Staked token is only disabled when withdrawing the entire balance\n    ///      - Rewards tokens are enabled if `claim` is true\n    function _withdraw(bytes memory callData, bool claim, bool disableStakedToken)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _execute(callData); // U:[CVX1R-7,8]\n        (tokensToEnable, tokensToDisable) =\n            (stakingTokenMask.enable(claim ? rewardTokensMask : 0), disableStakedToken ? stakedTokenMask : 0);\n    }\n\n    // ------ //\n    // UNWRAP //\n    // ------ //\n\n    /// @notice Withdraws Convex LP token from the reward pool and unwraps it into Curve LP token\n    /// @param claim Whether to claim staking rewards\n    /// @dev `amount` parameter is ignored since calldata is passed directly to the target contract\n    function withdrawAndUnwrap(uint256, bool claim)\n        external\n        override\n        creditFacadeOnly // U:[CVX1R-3]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        (tokensToEnable, tokensToDisable) = _withdrawAndUnwrap(msg.data, claim, false); // U:[CVX1R-9]\n    }\n\n    /// @notice Withdraws the entire balance of Convex LP token from the reward pool, except the specified amount\n    ///         disables staked token\n    /// @param leftoverAmount Amount of staked token to keep on the account\n    /// @param claim Whether to claim staking rewards\n    function withdrawDiffAndUnwrap(uint256 leftoverAmount, bool claim)\n        external\n        override\n        creditFacadeOnly // U:[CVX1R-3]\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        address creditAccount = _creditAccount(); // U:[CVX1R-10]\n\n        uint256 balance = IERC20(stakedPhantomToken).balanceOf(creditAccount); // U:[CVX1R-10]\n\n        if (balance > leftoverAmount) {\n            unchecked {\n                (tokensToEnable, tokensToDisable) = _withdrawAndUnwrap(\n                    abi.encodeCall(IBaseRewardPool.withdrawAndUnwrap, (balance - leftoverAmount, claim)),\n                    claim,\n                    leftoverAmount <= 1\n                ); // U:[CVX1R-10]\n            }\n        }\n    }\n\n    /// @dev Internal implementation of `withdrawAndUnwrap` and `withdrawDiffAndUnwrap`\n    ///      - Curve LP token is enabled after the call\n    ///      - Staked token is only disabled when withdrawing the entire balance\n    ///      - Rewards tokens are enabled if `claim` is true\n    function _withdrawAndUnwrap(bytes memory callData, bool claim, bool disableStakedToken)\n        internal\n        returns (uint256 tokensToEnable, uint256 tokensToDisable)\n    {\n        _execute(callData); // U:[CVX1R-9,10]\n        (tokensToEnable, tokensToDisable) =\n            (curveLPTokenMask.enable(claim ? rewardTokensMask : 0), disableStakedToken ? stakedTokenMask : 0);\n    }\n}"
    }
  ]
}