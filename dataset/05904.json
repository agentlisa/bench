{
  "Title": "[H-04] `UniV3LiquidityAMO::recoverERC721` will cause `ERC721` tokens to be permanently locked in `rdpxV2Core`",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV3LiquidityAmo.sol#L324-L334> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1-L1308>\n\n`UniV3LiquidityAMO::recoverERC721` is a function created in order to be able to recover `ERC721` tokens from the `UniV3LiquidityAMO` contract. It can only be called by admin and will transfer all `ERC721` tokens to the `RdpxV2Core` contract. The problem is, that it won't be possible to do anything with these tokens after they are transferred to `rdpxV2Core`.\n\nIndeed, `RdpxV2Core` inherits from the following contracts:\n\n*   `AccessControl`,\n*   `ContractWhitelist`,\n*   `ERC721Holder`,\n*   `Pausable`\n\nand no contract from this list implement any logic allowing the NFT transfer (only `ERC721Holder` has something to do with NFTs, but it only allows to receive them, not to approve or transfer).\n\nMoreover, `rdpxV2Core` also doesn't have any logic allowing transfer or approval of NFTs:\n\n*   there is no generic `execute` function there\n*   no function implemented is related to `ERC721` tokens (except for `onERC721Received` inherited from `ERC721Holder`)\n*   it may seem possible to do a dirty hack and try to use `approveContractToSpend` in order to approve `ERC721` token. Theoretically, one would have to specify `ERC721` `tokenId` instead of `ERC20` token amount, so that `IERC20WithBurn(_token).approve(_spender, _amount);` in fact approves `ERC721` token with `tokenId == _amount`, but it fails with `[FAIL. Reason: EvmError: Revert]` and even if it didn't, it still wouldn't be possible to transfer `ERC721` token with `tokenId == 0` since there is `_validate(_amount > 0, 17);` inside `approveContractToSpend`\n\n### Impact\n\n`UniV3LiquidityAMO::recoverERC721` instead of recovering `ERC721`, locks all tokens in `rdpxV2Core` and it won't be possible to recover them from that contract.\n\n**Any use of `recoverERC721` will imply an irrecoverable loss for the protocol** and this function was implemented in order to be used at some point after all (even if only on emergency situations). Because of that, I'm submitting this issue as High.\n\n### Proof of Concept\n\nThis PoC only shows that `ERC721` token recovery will not be possible by calling `RdpxV2Core::approveContractToSpend`. Lack of functions doing `transfer` or `approve` or any other `ERC721` related functions in `RdpxV2Core` may just be observed by looking at the contract's code.\n\nPlease create the `MockERC721.sol` file in `mocks` directory and with the following code:\n\n```solidity\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MockERC721 is ERC721\n{\n    constructor() ERC721(\"...\", \"...\")\n    {\n\n    }\n\n    function giveNFT() public\n    {\n        _mint(msg.sender, 1);\n    }\n}\n```\n\nIt will just mint an `ERC721` token with `tokenId = 1`.\nPlease also run the following test:\n\n```solidity\n  function testNFT() public\n  {\n    // needed `import \"../../contracts/mocks/MockERC721.sol\";` at the beginning of the file\n\n    MockERC721 mockERC721 = new MockERC721();\n    mockERC721.giveNFT();\n    mockERC721.transferFrom(address(this), address(rdpxV2Core), 1);\n    \n    // approveContractToSpend won't be possible to use\n    vm.expectRevert();\n    rdpxV2Core.approveContractToSpend(address(mockERC721), address(this), 1);\n  }\n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nEither implement additional `ERC721` recovery function in `RdpxV2Core` or change `UniV3LiquidityAMO::recoverERC721` so that it transfers all NFTs to `msg.sender` instead of `RdpxV2Core` contract.\n\n**[psytama (Dopex) confirmed and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/935#issuecomment-1733780469):**\n > Change recover ERC721 function in uni v3 AMO.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/935#issuecomment-1755829336):**\n > The Warden has shown an incorrect hardcoded address in the `recoverERC721` if used it would cause an irrevocable loss of funds\n> \n> Technically speaking the Sponsor could use `execute` as a replacement, however the default function causes a loss so I'm inclined to agree with High Severity\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/amo/UniV3LiquidityAmo.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { TransferHelper } from \"../libraries/TransferHelper.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\n\n// Uniswamp V3\nimport \"../uniswap_V3/IUniswapV3Factory.sol\";\nimport \"../uniswap_V3/libraries/TickMath.sol\";\nimport \"../uniswap_V3/libraries/LiquidityAmounts.sol\";\nimport \"../uniswap_V3/periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../uniswap_V3/IUniswapV3Pool.sol\";\nimport \"../uniswap_V3/ISwapRouter.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\nabstract contract OracleLike {\n  function read() external view virtual returns (uint);\n\n  function uniswapPool() external view virtual returns (address);\n}\n\ncontract UniV3LiquidityAMO is AccessControl, ERC721Holder {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20WithBurn;\n\n  /* ========== STATE VARIABLES ========== */\n\n  // Uniswap v3\n  IUniswapV3Factory public univ3_factory;\n  INonfungiblePositionManager public univ3_positions;\n  ISwapRouter public univ3_router;\n\n  // Details about the AMO's uniswap positions\n  struct Position {\n    uint256 token_id;\n    address collateral_address;\n    uint128 liquidity; // the liquidity of the position\n    int24 tickLower; // the tick range of the position\n    int24 tickUpper;\n    uint24 fee_tier;\n  }\n\n  // Add liquidity param\n  struct AddLiquidityParams {\n    address _tokenA;\n    address _tokenB;\n    int24 _tickLower;\n    int24 _tickUpper;\n    uint24 _fee;\n    uint256 _amount0Desired;\n    uint256 _amount1Desired;\n    uint256 _amount0Min;\n    uint256 _amount1Min;\n  }\n\n  // Array of all Uni v3 NFT positions held by the AMO\n  Position[] public positions_array;\n\n  // Map token_id to Position\n  mapping(uint256 => Position) public positions_mapping;\n\n  // Rdpx address\n  address public rdpx;\n\n  // RdpxV2Core address\n  address public rdpxV2Core;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(address _rdpx, address _rdpxV2Core) {\n    rdpx = _rdpx;\n    rdpxV2Core = _rdpxV2Core;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    univ3_factory = IUniswapV3Factory(\n      0x1F98431c8aD98523631AE4a59f267346ea31F984\n    );\n    univ3_positions = INonfungiblePositionManager(\n      0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n    );\n    univ3_router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n  }\n\n  /* ========== VIEWS ========== */\n\n  // Returns this contract's liquidity in a specific [Rdpx]-[collateral] uni v3 pool\n  function liquidityInPool(\n    address _collateral_address,\n    int24 _tickLower,\n    int24 _tickUpper,\n    uint24 _fee\n  ) public view returns (uint128) {\n    IUniswapV3Pool get_pool = IUniswapV3Pool(\n      univ3_factory.getPool(address(rdpx), _collateral_address, _fee)\n    );\n\n    // goes into the pool's positions mapping, and grabs this address's liquidity\n    (uint128 liquidity, , , , ) = get_pool.positions(\n      keccak256(abi.encodePacked(address(this), _tickLower, _tickUpper))\n    );\n    return liquidity;\n  }\n\n  // Only counts non-withdrawn positions\n  function numPositions() public view returns (uint256) {\n    return positions_array.length;\n  }\n\n  /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL ========== */\n\n  // Iterate through all positions and collect fees accumulated\n  function collectFees() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint i = 0; i < positions_array.length; i++) {\n      Position memory current_position = positions_array[i];\n      INonfungiblePositionManager.CollectParams\n        memory collect_params = INonfungiblePositionManager.CollectParams(\n          current_position.token_id,\n          rdpxV2Core,\n          type(uint128).max,\n          type(uint128).max\n        );\n\n      // Send to custodian address\n      univ3_positions.collect(collect_params);\n    }\n  }\n\n  /* ---------------------------------------------------- */\n  /* ---------------------- Uni v3 ---------------------- */\n  /* ---------------------------------------------------- */\n\n  function approveTarget(\n    address _target,\n    address _token,\n    uint256 _amount,\n    bool use_safe_approve\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (use_safe_approve) {\n      // safeApprove needed for USDT and others for the first approval\n      // You need to approve 0 every time beforehand for USDT: it resets\n      TransferHelper.safeApprove(_token, _target, _amount);\n    } else {\n      IERC20WithBurn(_token).approve(_target, _amount);\n    }\n  }\n\n  // IUniswapV3Pool public current_uni_pool; // only used for mint callback; is set and accessed during execution of addLiquidity()\n  function addLiquidity(\n    AddLiquidityParams memory params\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20WithBurn(params._tokenA).transferFrom(\n      rdpxV2Core,\n      address(this),\n      params._amount0Desired\n    );\n    IERC20WithBurn(params._tokenB).transferFrom(\n      rdpxV2Core,\n      address(this),\n      params._amount1Desired\n    );\n\n    IERC20WithBurn(params._tokenA).approve(\n      address(univ3_positions),\n      params._amount0Desired\n    );\n    IERC20WithBurn(params._tokenB).approve(\n      address(univ3_positions),\n      params._amount1Desired\n    );\n\n    INonfungiblePositionManager.MintParams\n      memory mintParams = INonfungiblePositionManager.MintParams(\n        params._tokenA,\n        params._tokenB,\n        params._fee,\n        params._tickLower,\n        params._tickUpper,\n        params._amount0Desired,\n        params._amount1Desired,\n        params._amount0Min,\n        params._amount1Min,\n        address(this),\n        type(uint256).max\n      );\n\n    (uint256 tokenId, uint128 amountLiquidity, , ) = univ3_positions.mint(\n      mintParams\n    );\n\n    Position memory pos = Position(\n      tokenId,\n      params._tokenA == address(rdpx) ? params._tokenB : params._tokenA,\n      amountLiquidity,\n      params._tickLower,\n      params._tickUpper,\n      params._fee\n    );\n\n    positions_array.push(pos);\n    positions_mapping[tokenId] = pos;\n\n    // send tokens to rdpxV2Core\n    _sendTokensToRdpxV2Core(params._tokenA, params._tokenB);\n  }\n\n  function removeLiquidity(\n    uint256 positionIndex,\n    uint256 minAmount0,\n    uint256 minAmount1\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    Position memory pos = positions_array[positionIndex];\n    INonfungiblePositionManager.CollectParams\n      memory collect_params = INonfungiblePositionManager.CollectParams(\n        pos.token_id,\n        rdpxV2Core,\n        type(uint128).max,\n        type(uint128).max\n      );\n\n    (\n      ,\n      ,\n      address tokenA,\n      address tokenB,\n      ,\n      ,\n      ,\n      uint128 liquidity,\n      ,\n      ,\n      ,\n\n    ) = univ3_positions.positions(pos.token_id);\n\n    // remove liquidity\n    INonfungiblePositionManager.DecreaseLiquidityParams\n      memory decreaseLiquidityParams = INonfungiblePositionManager\n        .DecreaseLiquidityParams(\n          pos.token_id,\n          liquidity,\n          minAmount0,\n          minAmount1,\n          block.timestamp\n        );\n\n    univ3_positions.decreaseLiquidity(decreaseLiquidityParams);\n\n    univ3_positions.collect(collect_params);\n\n    univ3_positions.burn(pos.token_id);\n\n    positions_array[positionIndex] = positions_array[\n      positions_array.length - 1\n    ];\n    positions_array.pop();\n    delete positions_mapping[pos.token_id];\n\n    // send tokens to rdpxV2Core\n    _sendTokensToRdpxV2Core(tokenA, tokenB);\n\n    emit log(positions_array.length);\n    emit log(positions_mapping[pos.token_id].token_id);\n  }\n\n  // Swap tokenA into tokenB using univ3_router.ExactInputSingle()\n  // Uni V3 only\n  function swap(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee_tier,\n    uint256 _amountAtoB,\n    uint256 _amountOutMinimum,\n    uint160 _sqrtPriceLimitX96\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256) {\n    // transfer token from rdpx v2 core\n    IERC20WithBurn(_tokenA).transferFrom(\n      rdpxV2Core,\n      address(this),\n      _amountAtoB\n    );\n\n    ISwapRouter.ExactInputSingleParams memory swap_params = ISwapRouter\n      .ExactInputSingleParams(\n        _tokenA,\n        _tokenB,\n        _fee_tier,\n        address(this),\n        2105300114, // Expiration: a long time from now\n        _amountAtoB,\n        _amountOutMinimum,\n        _sqrtPriceLimitX96\n      );\n\n    // Approval\n    TransferHelper.safeApprove(_tokenA, address(univ3_router), _amountAtoB);\n\n    uint256 amountOut = univ3_router.exactInputSingle(swap_params);\n\n    _sendTokensToRdpxV2Core(_tokenA, _tokenB);\n    return amountOut;\n  }\n\n  /* ========== OWNER / GOVERNANCE FUNCTIONS ONLY ========== */\n  // Only owner or timelock can call, to limit risk\n\n  function recoverERC20(\n    address tokenAddress,\n    uint256 tokenAmount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Can only be triggered by owner or governance, not custodian\n    // Tokens are sent to the custodian, as a sort of safeguard\n    TransferHelper.safeTransfer(tokenAddress, rdpxV2Core, tokenAmount);\n\n    emit RecoveredERC20(tokenAddress, tokenAmount);\n  }\n\n  function recoverERC721(\n    address tokenAddress,\n    uint256 token_id\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Only the owner address can ever receive the recovery withdrawal\n    // INonfungiblePositionManager inherits IERC721 so the latter does not need to be imported\n    INonfungiblePositionManager(tokenAddress).safeTransferFrom(\n      address(this),\n      rdpxV2Core,\n      token_id\n    );\n    emit RecoveredERC721(tokenAddress, token_id);\n  }\n\n  // Generic proxy\n  function execute(\n    address _to,\n    uint256 _value,\n    bytes calldata _data\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (bool, bytes memory) {\n    (bool success, bytes memory result) = _to.call{ value: _value }(_data);\n    return (success, result);\n  }\n\n  /* ========== INTERNAL ========== */\n\n  /**\n   * @dev sends token A and B to the rdpxV2Core\n   */\n  function _sendTokensToRdpxV2Core(address tokenA, address tokenB) internal {\n    uint256 tokenABalance = IERC20WithBurn(tokenA).balanceOf(address(this));\n    uint256 tokenBBalance = IERC20WithBurn(tokenB).balanceOf(address(this));\n    // transfer token A and B from this contract to the rdpxV2Core\n    IERC20WithBurn(tokenA).safeTransfer(rdpxV2Core, tokenABalance);\n    IERC20WithBurn(tokenB).safeTransfer(rdpxV2Core, tokenBBalance);\n\n    // sync token balances\n    IRdpxV2Core(rdpxV2Core).sync();\n\n    emit LogAssetsTransfered(tokenABalance, tokenBBalance, tokenA, tokenB);\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RecoveredERC20(address token, uint256 amount);\n  event RecoveredERC721(address token, uint256 id);\n  event LogAssetsTransfered(\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    address tokenAAddress,\n    address tokenBAddress\n  );\n  /*\n   **  burn tokenAmount from the recipient and send tokens to the receipient\n   */\n  event log(uint);\n}"
    },
    {
      "filename": "contracts/core/RdpxV2Core.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { RdpxV2Bond } from \"./RdpxV2Bond.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IStableSwap } from \"../interfaces/IStableSwap.sol\";\nimport { IRdpxDecayingBonds } from \"../decaying-bonds/IRdpxDecayingBonds.sol\";\nimport { IDpxEthToken } from \"../dpxETH/IDpxEthToken.sol\";\nimport { IPerpetualAtlanticVault } from \"../perp-vault/IPerpetualAtlanticVault.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IDpxEthOracle } from \"../oracles/IDpxEthOracle.sol\";\nimport { IRdpxReserve } from \"../reserve/IRdpxReserve.sol\";\nimport { IRdpxV2Core } from \"./IRdpxV2Core.sol\";\nimport { IRdpxV2ReceiptToken } from \"../interfaces/IRdpxV2ReceiptToken.sol\";\nimport { IReLP } from \"../interfaces/IReLP.sol\";\n\n// Libraries\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title Rdpx V2 Core contract\n/// @author Dopex\n/// @notice The Rdpx V2 Corecontracts handles the bonding mechanism and peg of DpxEth\ncontract RdpxV2Core is\n  IRdpxV2Core,\n  AccessControl,\n  ContractWhitelist,\n  ERC721Holder,\n  Pausable\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20WithBurn;\n  using SafeERC20 for IDpxEthToken;\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @notice Addresses used by the contract\n  Addresses public addresses;\n\n  /// @notice The pricing oracle addresses\n  PricingOracleAddresses public pricingOracleAddresses;\n\n  /* Inital tokens in the reserve\n     index0: ZERO address\n     index1: weth\n     index2: rdpx\n     index3: dpxEth\n     index4: crv\n  */\n\n  /// @notice Array containg the reserve assets\n  ReserveAsset[] public reserveAsset;\n\n  /// @notice Array that contains the addresses of the AMO\n  address[] public amoAddresses;\n\n  /// @notice Token address that dpxEth is pegged to\n  address public weth;\n\n  /// @notice Array that contains the symbol of the reserve tokens\n  string[] public reserveTokens;\n\n  /// @notice Mapping that contains the index for a specific token in the reserves\n  mapping(string => uint256) public reservesIndex;\n\n  /// @dev Bond id => Bond\n  mapping(uint256 => Bond) public bonds;\n\n  /// @dev Option id => owned or not (boolean)\n  mapping(uint256 => bool) public optionsOwned;\n\n  /// @dev Funding paid for epoch\n  mapping(uint256 => bool) public fundingPaidFor;\n\n  /// @notice Precision used for prices, percentages and other calculations\n  uint256 public constant DEFAULT_PRECISION = 1e8;\n\n  /// @notice rDPX Ratio required when bonding\n  uint256 public constant RDPX_RATIO_PERCENTAGE = 25 * DEFAULT_PRECISION;\n\n  /// @notice ETH Ratio required when bonding\n  uint256 public constant ETH_RATIO_PERCENTAGE = 75 * DEFAULT_PRECISION;\n\n  /// @notice The % of rdpx to burn while bonding\n  uint256 public rdpxBurnPercentage = 50 * DEFAULT_PRECISION;\n\n  /// @notice The % of rdpx sent to fee distributor while bonding\n  uint256 public rdpxFeePercentage = 50 * DEFAULT_PRECISION;\n\n  /// @notice The slippage tolernce in swaps in 1e8 precision\n  uint256 public slippageTolerance = 5e5; // 0.5%\n\n  /// @notice Liquidity slippage tolerance\n  uint256 public liquiditySlippageTolerance = 5e5; // 0.5%\n\n  /// @notice Bond maturity\n  uint256 public bondMaturity;\n\n  /// @notice rDPX LP bond discount factor\n  uint256 public bondDiscountFactor;\n\n  /// @notice Total weth delegated\n  uint256 public totalWethDelegated;\n\n  /// @notice Whether reLP is active or not\n  bool public isReLPActive;\n\n  /// @notice Whether put options are requred\n  bool public putOptionsRequired;\n\n  /// @notice Delegates array\n  Delegate[] public delegates;\n\n  // ================================ CONSTRUCTOR ================================ //\n  constructor(address _weth) {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    weth = _weth;\n\n    // add Zero asset to reserveAsset\n    ReserveAsset memory zeroAsset = ReserveAsset({\n      tokenAddress: address(0),\n      tokenBalance: 0,\n      tokenSymbol: \"ZERO\"\n    });\n    reserveAsset.push(zeroAsset);\n    putOptionsRequired = true;\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit LogEmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Sets the rdpx burn percentage\n   * @dev    Can only be called by admin\n   * @param  _rdpxBurnPercentage the burn percentage to set in 1e8 precision\n   **/\n  function setRdpxBurnPercentage(\n    uint256 _rdpxBurnPercentage\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxBurnPercentage > 0, 3);\n    rdpxBurnPercentage = _rdpxBurnPercentage;\n    emit LogSetRdpxBurnPercentage(_rdpxBurnPercentage);\n  }\n\n  /**\n   * @notice Sets the rdpx fee percentage\n   * @dev    Can only be called by admin\n   * @param  _rdpxFeePercentage the fee percentage to set in 1e8 precision\n   **/\n  function setRdpxFeePercentage(\n    uint256 _rdpxFeePercentage\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxFeePercentage > 0, 3);\n    rdpxFeePercentage = _rdpxFeePercentage;\n    emit LogSetRdpxFeePercentage(_rdpxFeePercentage);\n  }\n\n  /**\n   * @notice Sets whether reLP is true or false\n   * @dev    Can only be called by admin\n   * @param  _isReLPActive the value to set\n   */\n  function setIsreLP(bool _isReLPActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    isReLPActive = _isReLPActive;\n    emit LogSetIsReLPActive(_isReLPActive);\n  }\n\n  /**\n   * @notice Sets whether put options are required or not\n   * @dev    Can only be called by admin\n   * @param  _putOptionsRequired the value to set\n   */\n  function setPutOptionsRequired(\n    bool _putOptionsRequired\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    putOptionsRequired = _putOptionsRequired;\n    emit LogSetputOptionsRequired(_putOptionsRequired);\n  }\n\n  /**\n   * @notice Update the bond maturity\n   * @dev    Can only be called by admin\n   * @param  _bondMaturity bond maturity\n   **/\n  function setBondMaturity(\n    uint256 _bondMaturity\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_bondMaturity > 0, 3);\n    bondMaturity = _bondMaturity;\n    emit LogSetBondMaturity(_bondMaturity);\n  }\n\n  /**\n   * @notice Adds a asset to the reserves tokens\n   * @dev    Can only be called by admin\n   **/\n  function addAssetTotokenReserves(\n    address _asset,\n    string memory _assetSymbol\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_asset != address(0), \"RdpxV2Core: asset cannot be 0 address\");\n\n    for (uint256 i = 1; i < reserveAsset.length; i++) {\n      require(\n        reserveAsset[i].tokenAddress != _asset,\n        \"RdpxV2Core: asset already exists\"\n      );\n    }\n\n    ReserveAsset memory asset = ReserveAsset({\n      tokenAddress: _asset,\n      tokenBalance: 0,\n      tokenSymbol: _assetSymbol\n    });\n    reserveAsset.push(asset);\n    reserveTokens.push(_assetSymbol);\n\n    reservesIndex[_assetSymbol] = reserveAsset.length - 1;\n\n    emit LogAssetAddedTotokenReserves(_asset, _assetSymbol);\n  }\n\n  /**\n   * @notice Removes a asset from the reserves tokens\n   * @dev    Can only be called by admin\n   **/\n  function removeAssetFromtokenReserves(\n    string memory _assetSymbol\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 index = reservesIndex[_assetSymbol];\n    _validate(index != 0, 18);\n\n    // remove the asset from the mapping\n    reservesIndex[_assetSymbol] = 0;\n\n    // add new index for the last element\n    reservesIndex[reserveTokens[reserveTokens.length - 1]] = index;\n\n    // update the index of reserveAsset with the last element\n    reserveAsset[index] = reserveAsset[reserveAsset.length - 1];\n\n    // remove the last element\n    reserveAsset.pop();\n    reserveTokens.pop();\n\n    emit LogAssetRemovedFromtokenReserves(_assetSymbol, index);\n  }\n\n  /**\n   * @notice Update contract addresses\n   * @dev    Can only be called by admin\n   * @param  _dopexAMMRouter dopex AMM router address\n   * @param  _dpxEthCurvePool DpxEth curve pool address\n   * @param  _rdpxDecayingBonds rdpx decaying bonds address\n   * @param  _perpetualAtlanticVault perpetual atlantic vault address\n   * @param  _perpetualAtlanticVaultLP perpetual atlantic vault LP address\n   * @param  _rdpxReserve rdpx reserve address\n   * @param  _rdpxV2ReceiptToken rdpxV2ReceiptToken contract address\n   * @param  _feeDistributor fee distributor address\n   **/\n  function setAddresses(\n    address _dopexAMMRouter,\n    address _dpxEthCurvePool,\n    address _rdpxDecayingBonds,\n    address _perpetualAtlanticVault,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxReserve,\n    address _rdpxV2ReceiptToken,\n    address _feeDistributor,\n    address _reLPContract,\n    address _receiptTokenBonds\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_dopexAMMRouter != address(0), 17);\n    _validate(_dpxEthCurvePool != address(0), 17);\n    _validate(_rdpxDecayingBonds != address(0), 17);\n    _validate(_perpetualAtlanticVault != address(0), 17);\n    _validate(_perpetualAtlanticVaultLP != address(0), 17);\n    _validate(_rdpxReserve != address(0), 17);\n    _validate(_rdpxV2ReceiptToken != address(0), 17);\n    _validate(_feeDistributor != address(0), 17);\n    _validate(_reLPContract != address(0), 17);\n    _validate(_receiptTokenBonds != address(0), 17);\n\n    addresses = Addresses({\n      dopexAMMRouter: _dopexAMMRouter,\n      dpxEthCurvePool: _dpxEthCurvePool,\n      rdpxDecayingBonds: _rdpxDecayingBonds,\n      perpetualAtlanticVault: _perpetualAtlanticVault,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxReserve: _rdpxReserve,\n      rdpxV2ReceiptToken: _rdpxV2ReceiptToken,\n      feeDistributor: _feeDistributor,\n      reLPContract: _reLPContract,\n      receiptTokenBonds: _receiptTokenBonds\n    });\n    IERC20WithBurn(weth).approve(\n      addresses.perpetualAtlanticVault,\n      type(uint256).max\n    );\n    IERC20WithBurn(weth).approve(addresses.dopexAMMRouter, type(uint256).max);\n    IERC20WithBurn(weth).approve(addresses.dpxEthCurvePool, type(uint256).max);\n    IERC20WithBurn(weth).approve(\n      addresses.rdpxV2ReceiptToken,\n      type(uint256).max\n    );\n    emit LogSetAddresses(addresses);\n  }\n\n  /**\n   * @notice Update token contract addresses\n   * @dev    Can only be called by admin\n   * @param  _rdpxPriceOracle rdpx price oracle address\n   * @param  _dpxEthPriceOracle DpxEth price oracle address\n   **/\n  function setPricingOracleAddresses(\n    address _rdpxPriceOracle,\n    address _dpxEthPriceOracle\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxPriceOracle != address(0), 17);\n    _validate(_dpxEthPriceOracle != address(0), 17);\n\n    pricingOracleAddresses = PricingOracleAddresses({\n      rdpxPriceOracle: _rdpxPriceOracle,\n      dpxEthPriceOracle: _dpxEthPriceOracle\n    });\n\n    emit LogSetPricingOracleAddresses(pricingOracleAddresses);\n  }\n\n  /**\n   * @notice Adds a AMO contract to the AMO address array\n   * @dev    Can only be called by admin\n   * @param  _addr the address to add to the AMO address array\n   */\n  function addAMOAddress(address _addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_addr != address(0), 17);\n    amoAddresses.push(_addr);\n  }\n\n  /**\n   * @notice Removes a AMO contract from the AMO address array\n   * @dev    Can only be called by admin\n   * @param  _index the index of the address to remove from the AMO address array\n   */\n  function removeAMOAddress(\n    uint256 _index\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_index < amoAddresses.length, 18);\n    amoAddresses[_index] = amoAddresses[amoAddresses.length - 1];\n    amoAddresses.pop();\n  }\n\n  /**\n   * @notice Approve a contract to spend a certain amount of tokens\n   * @dev    Can only be called by admin\n   * @param  _token the address of the token to approve\n   * @param  _spender the address of the contract to approve\n   * @param  _amount the amount to approve\n   */\n  function approveContractToSpend(\n    address _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_token != address(0), 17);\n    _validate(_spender != address(0), 17);\n    _validate(_amount > 0, 17);\n    IERC20WithBurn(_token).approve(_spender, _amount);\n  }\n\n  /**\n   * @notice Adds a contract to the contract whitelist\n   * @dev    Can only be called by admin\n   * @param  _addr the address to add to the contract whitelist\n   **/\n  function addToContractWhitelist(\n    address _addr\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_addr);\n  }\n\n  /**\n   * @notice Removes a contract from the contract whitelist\n   * @dev    Can only be called by admin\n   * @param  _addr the address to remove from the contract whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _addr\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_addr);\n  }\n\n  /**\n   * @notice Set the rDPX LP bond discount factor\n   * @dev    Can only be called by admin\n   * @param  _bondDiscountFactor the bond discount factor\n   **/\n  function setBondDiscount(\n    uint256 _bondDiscountFactor\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_bondDiscountFactor > 0, 3);\n    bondDiscountFactor = _bondDiscountFactor;\n\n    emit LogSetBondDiscountFactor(_bondDiscountFactor);\n  }\n\n  /**\n   * @notice Set the slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _slippageTolerance the slipage tolerance\n   **/\n  function setSlippageTolerance(\n    uint256 _slippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_slippageTolerance > 0, 3);\n    slippageTolerance = _slippageTolerance;\n\n    emit LogSetSlippageTolerance(_slippageTolerance);\n  }\n\n  // ================================ INTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Purchase rdpx put options\n   * @param _amount amount of rdpx to purchase\n   * @return premium amount of premium paid\n   */\n  function _purchaseOptions(\n    uint256 _amount\n  ) internal returns (uint256 premium) {\n    /**\n     * Purchase options and store ERC721 option id\n     * Note that the amount of options purchased is the amount of rDPX received\n     * from the user to sufficiently collateralize the underlying DpxEth stored in the bond\n     **/\n    uint256 optionId;\n\n    (premium, optionId) = IPerpetualAtlanticVault(\n      addresses.perpetualAtlanticVault\n    ).purchase(_amount, address(this));\n\n    optionsOwned[optionId] = true;\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= premium;\n  }\n\n  /**\n   * @notice issue bonds\n   * @param  _to The address to send the bond to\n   * @param  _amount The bond amount\n   * @return bondId The bond id\n   **/\n  function _issueBond(\n    address _to,\n    uint256 _amount\n  ) internal returns (uint256 bondId) {\n    bondId = RdpxV2Bond(addresses.receiptTokenBonds).mint(_to);\n    bonds[bondId] = Bond({\n      amount: _amount,\n      maturity: block.timestamp + bondMaturity,\n      timestamp: block.timestamp\n    });\n  }\n\n  /**\n   * @notice Swaps _amount of token a to token b\n   * @param _amount amount to swap\n   * @param _ethToDpxEth whether to swap ETH to dpxETH or dpxETH to ETH\n   * @param validate whether to validate the swap\n   * @param minAmount minimum amount of token b to receive\n   * @return amountOut amount of token b received\n   */\n  function _curveSwap(\n    uint256 _amount,\n    bool _ethToDpxEth,\n    bool validate,\n    uint256 minAmount\n  ) internal returns (uint256 amountOut) {\n    IStableSwap dpxEthCurvePool = IStableSwap(addresses.dpxEthCurvePool);\n\n    // First compute a reverse swapping of dpxETH to ETH to compute the amount of ETH required\n    address coin0 = dpxEthCurvePool.coins(0);\n    (uint256 a, uint256 b) = coin0 == weth ? (0, 1) : (1, 0);\n\n    // validate the swap for peg functions\n    if (validate) {\n      uint256 ethBalance = IStableSwap(addresses.dpxEthCurvePool).balances(a);\n      uint256 dpxEthBalance = IStableSwap(addresses.dpxEthCurvePool).balances(\n        b\n      );\n      _ethToDpxEth\n        ? _validate(\n          ethBalance + _amount <= (ethBalance + dpxEthBalance) / 2,\n          14\n        )\n        : _validate(\n          dpxEthBalance + _amount <= (ethBalance + dpxEthBalance) / 2,\n          14\n        );\n    }\n\n    // calculate minimum amount out\n    uint256 minOut = _ethToDpxEth\n      ? (((_amount * getDpxEthPrice()) / 1e8) -\n        (((_amount * getDpxEthPrice()) * slippageTolerance) / 1e16))\n      : (((_amount * getEthPrice()) / 1e8) -\n        (((_amount * getEthPrice()) * slippageTolerance) / 1e16));\n\n    // Swap the tokens\n    amountOut = dpxEthCurvePool.exchange(\n      _ethToDpxEth ? int128(int256(a)) : int128(int256(b)),\n      _ethToDpxEth ? int128(int256(b)) : int128(int256(a)),\n      _amount,\n      minAmount > 0 ? minAmount : minOut\n    );\n  }\n\n  /**\n   * @notice Deposits ETH and dpxETH to the ReceiptToken contract\n   * @param  _to The address to send the bond to\n   * @param  _amount The amount of ETH to add liquidity with\n   * @return receiptTokenAmount The amount of receipt token received\n   **/\n  function _stake(\n    address _to,\n    uint256 _amount\n  ) internal returns (uint256 receiptTokenAmount) {\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= _amount / 2;\n\n    IDpxEthToken(reserveAsset[reservesIndex[\"DPXETH\"]].tokenAddress).mint(\n      address(this),\n      _amount / 2\n    );\n\n    // deposit into the rdpxV2ReceiptToken contract\n    receiptTokenAmount = IRdpxV2ReceiptToken(addresses.rdpxV2ReceiptToken)\n      .deposit(_amount / 2);\n\n    // mint receipt token bonds\n    _issueBond(_to, receiptTokenAmount);\n  }\n\n  /**\n   * @notice Calculate the amounts received by delegate and delegatee after accounting for\n   *         delegate fee.\n   * @dev    Mint receipt tokens based on its respective share with a discount % in 1e8 precision.\n   *         The delegate fee is the percentage of the discount received by the delegatee\n   *         that is cut for them.\n   * @param  _wethRequired The wethRequired to bond\n   * @param  _rdpxRequired The rdpxRequired to bond\n   * @param  _amount The bond amount\n   * @param  _delegateFee The delegate fee\n   * @return amount1 The amount received by the delegate\n   * @return amount2 The amount received by the delegatee\n   **/\n  function _calculateAmounts(\n    uint256 _wethRequired,\n    uint256 _rdpxRequired,\n    uint256 _amount,\n    uint256 _delegateFee\n  ) internal view returns (uint256 amount1, uint256 amount2) {\n    // Commented below for better clarity\n    uint256 rdpxRequiredInWeth = (_rdpxRequired * getRdpxPrice()) / 1e8;\n\n    // amount required for delegatee\n    amount1 = ((rdpxRequiredInWeth * _amount) /\n      (rdpxRequiredInWeth + _wethRequired));\n\n    // account for delegate fee\n    amount1 = (amount1 * (100e8 - _delegateFee)) / 1e10;\n\n    amount2 = _amount - amount1;\n  }\n\n  /**\n   * @notice Transfers rdpx or burns the equivalent in rDPX Decaying bonds\n   * @param  _rdpxAmount The rdpx amount\n   * @param  _wethAmount The weth amount\n   * @param  _bondAmount The bond amount\n   * @param  _bondId The bond id of the rdpx decaying bond\n   **/\n  function _transfer(\n    uint256 _rdpxAmount,\n    uint256 _wethAmount,\n    uint256 _bondAmount,\n    uint256 _bondId\n  ) internal {\n    if (_bondId != 0) {\n      (, uint256 expiry, uint256 amount) = IRdpxDecayingBonds(\n        addresses.rdpxDecayingBonds\n      ).bonds(_bondId);\n\n      _validate(amount >= _rdpxAmount, 1);\n      _validate(expiry >= block.timestamp, 2);\n      _validate(\n        IRdpxDecayingBonds(addresses.rdpxDecayingBonds).ownerOf(_bondId) ==\n          msg.sender,\n        9\n      );\n\n      IRdpxDecayingBonds(addresses.rdpxDecayingBonds).decreaseAmount(\n        _bondId,\n        amount - _rdpxAmount\n      );\n\n      IRdpxReserve(addresses.rdpxReserve).withdraw(_rdpxAmount);\n\n      reserveAsset[reservesIndex[\"RDPX\"]].tokenBalance += _rdpxAmount;\n    } else {\n      // Transfer rDPX and ETH token from user\n      IERC20WithBurn(reserveAsset[reservesIndex[\"RDPX\"]].tokenAddress)\n        .safeTransferFrom(msg.sender, address(this), _rdpxAmount);\n\n      // burn the rdpx\n      IERC20WithBurn(reserveAsset[reservesIndex[\"RDPX\"]].tokenAddress).burn(\n        (_rdpxAmount * rdpxBurnPercent"
    }
  ]
}