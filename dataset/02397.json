{
  "Title": "Destruction of the EnsoWallet implementation contract",
  "Content": "##### Description\nAn attacker can make a direct call (not via proxy) to [EnsoWallet.initialize()](https://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoWallet.sol#L24) and execute the SELFDESTRUCT opcode or specify themself as EXECUTOR and gain the ability to execute SELFDESTRUCT later. Consequently, the current implementation contract will be destroyed, and all users' wallet functionality will be inaccessible until the core upgrade. The worst case occurs if an attack happens after EnsoBeacon.renounceAdministration(), and all users' funds will be frozen.\n##### Recommendation\nWe recommend disallowing direct calls to EnsoWallet.initialize().\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/EnsoWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@ensofinance/weiroll/contracts/VM.sol\";\nimport \"./access/AccessController.sol\";\nimport \"./wallet/ERC1271.sol\";\nimport \"./wallet/MinimalWallet.sol\";\nimport \"./interfaces/IEnsoWallet.sol\";\n\ncontract EnsoWallet is IEnsoWallet, VM, AccessController, ERC1271, MinimalWallet {\n    using StorageAPI for bytes32;\n\n    // Using same slot generation technique as eip-1967 -- https://eips.ethereum.org/EIPS/eip-1967\n    bytes32 internal constant SALT = bytes32(uint256(keccak256(\"enso.wallet.salt\")) - 1);\n\n    error AlreadyInit();\n\n    // @notice Initialize wallet by setting state and permissions\n    // @dev A wallet is considered initialized if the SALT is set in state. Subsequent calls to this function will fail.\n    // @param owner The address of the wallet owner\n    // @param salt The salt used to deploy the proxy that uses this contract as it's implementation\n    // @param commands The optional commands for executing a shortcut\n    // @param state The optional state for executing a shortcut\n    function initialize(\n        address owner,\n        bytes32 salt,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) external override payable {\n        if (SALT.getBytes32() != bytes32(0)) revert AlreadyInit();\n        SALT.setBytes32(salt);\n        _setPermission(OWNER_ROLE, owner, true);\n        _setPermission(EXECUTOR_ROLE, owner, true);\n        if (commands.length != 0) {\n            _execute(commands, state);\n        }\n    }\n\n    // @notice A function to execute an arbitrary call on another contract\n    // @param target The address of the target contract\n    // @param value The ether value that is to be sent with the call\n    // @param data The call data to be sent to the target\n    function execute(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) external payable isPermitted(EXECUTOR_ROLE) returns (bool success) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(gas(), target, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    // @notice Execute a shortcut from this contract\n    // @param commands An array of bytes32 values that encode calls\n    // @param state An array of bytes that are used to generate call data for each command\n    function executeShortcut(bytes32[] calldata commands, bytes[] calldata state)\n        external\n        payable\n        isPermitted(EXECUTOR_ROLE)\n        returns (bytes[] memory returnData)\n    {\n        returnData = _execute(commands, state);\n    }\n\n    // @notice Internal function for checking the ERC-1271 signer\n    // @param signer The address that signed a message\n    function _checkSigner(address signer) internal view override returns (bool) {\n        return _getPermission(OWNER_ROLE, signer);\n    }\n}"
    }
  ]
}