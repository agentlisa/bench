{
  "Title": "[M-12] `USDMPegRecovery.provide()` Will Fail If There Is An Excess Of `usdm` Tokens",
  "Content": "_Submitted by leastwood_\n\nThe `provide` function does not take a `_steps` argument and will instead calculate `addingLiquidity` by truncating amounts under `step`. As a result, if there is an excess of `usdm` such that the truncated amount exceeds the contract's `pool3` truncated balance, then the function will revert due to insufficient `pool3` collateral.\n\nThis will prevent guardians from effectively providing liquidity whenever tokens are available. Consider the following example:\n\n*   The contract has `500000e18` `usdm` tokens and `250000e18` `pool3` tokens.\n*   `addingLiquidity` will be calculated as `500000e18 / 250000e18 * 250000e18`.\n*   The function will attempt to add `500000e18` `usdm` and `pool3` tokens in which there are insufficient `pool3` tokens in the contract. As a result, it will revert even though there is an abundance of tokens that satisfy the `step` amount.\n\n### Proof of Concept\n\n[USDMPegRecovery.sol#L73-L82](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82)<br>\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n### Tools Used\n\nManual code review.<br>\nDiscussions with Taek.\n\n### Recommended Mitigation Steps\n\nConsider modifying the `provide` function such that a `_steps` argument can be supplied. This will allow guardians to maximise the amount of liquidity provided to the Curve pool.\n\n**[leekt (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/94)**\n\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/94#issuecomment-1095700551):**\n > The warden identified a logical fallacy that would prevent the code from providing liquidity.\n> \n> This is because the code is only accounting for one token, ignoring the other token's amount.\n> \n> Given the information I have, I agree with validity and severity of the finding. Mitigation could be achieved by following the warden's advice or by also using the balance of the `pool3` token to calculate the LP amounts.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/USDMPegRecovery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ICurveMetaPool } from \"./external/CurveInterfaces.sol\";\n\ncontract USDMPegRecovery is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    IERC20 public immutable usdm;\n\n    IERC20 public immutable pool3;\n\n    ICurveMetaPool public immutable usdm3crv;\n\n    address public immutable kpiOracle;\n\n    uint256 public step;\n\n    uint256 public startLiquidity;\n\n    struct Liquidity {\n        uint128 usdm;\n        uint128 pool3;\n    }\n\n    event Deposit(address indexed depositor, Liquidity deposits);\n\n    event Withdraw(address indexed withdrawer, Liquidity withdrawals);\n\n    Liquidity public totalLiquidity;\n\n    mapping(address => Liquidity) public userLiquidity;\n\n    mapping(address => bool) public isGuardian;\n\n    bool public unlockable;\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"!guardian\");\n        _;\n    }\n\n    constructor(\n        uint256 _startLiquidity,\n        address _kpiOracle\n    ) Ownable() {\n        startLiquidity = _startLiquidity;\n        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);\n        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);\n        step = 250000e18;\n        kpiOracle = _kpiOracle;\n    }\n\n    function addGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = true;\n    }\n\n    function removeGuardian(address _guardian) external onlyOwner {\n        isGuardian[_guardian] = false;\n    }\n\n    function enableUnlock() external {\n        require(msg.sender == kpiOracle, \"!oracle\");\n        unlockable = true;\n    }\n\n    function provide(uint256 _minimumLP) external onlyGuardian {\n        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n        // truncate amounts under step\n        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;\n        // match usdm : pool3 = 1 : 1\n        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n        usdm.approve(address(usdm3crv), addingLiquidity);\n        pool3.approve(address(usdm3crv), addingLiquidity);\n        usdm3crv.add_liquidity(amounts, _minimumLP);\n    }\n\n    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {\n        uint256 removingLiquidity = _steps * step;\n        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];\n        usdm3crv.remove_liquidity(_burningLPs, amounts);\n    }\n\n    function deposit(Liquidity calldata _deposits) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_deposits.usdm > 0) {\n            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));\n            total.usdm += _deposits.usdm;\n            user.usdm += _deposits.usdm;\n        }\n\n        if(_deposits.pool3 > 0) {\n            require(totalLiquidity.usdm > 4000000e18, \"usdm low\");\n            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));\n            total.pool3 += _deposits.pool3;\n            user.pool3 += _deposits.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Deposit(msg.sender, _deposits);\n    }\n\n    function withdraw(Liquidity calldata _withdrawal) external {\n        Liquidity memory total = totalLiquidity;\n        Liquidity memory user = userLiquidity[msg.sender];\n        if(_withdrawal.usdm > 0) {\n            require(unlockable, \"!unlock usdm\");\n            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));\n            total.usdm -= _withdrawal.usdm;\n            user.usdm -= _withdrawal.usdm;\n        }\n\n        if(_withdrawal.pool3 > 0) {\n            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));\n            total.pool3 -= _withdrawal.pool3;\n            user.pool3 -= _withdrawal.pool3;\n        }\n        totalLiquidity = total;\n        userLiquidity[msg.sender] = user;\n        emit Withdraw(msg.sender, _withdrawal);\n    }\n}"
    }
  ]
}