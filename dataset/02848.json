{
  "Title": "H-9: Public vaults can become insolvent because of missing `yIntercept` update",
  "Content": "# Issue H-9: Public vaults can become insolvent because of missing `yIntercept` update \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/197 \n\n## Found by \nzzykxx, 0xRajeev\n\n## Summary\n\nThe deduction of `yIntercept` during payments is missing in `beforePayment()` which can lead to vault insolvency.\n\n## Vulnerability Detail\n\n`yIntercept` is declared as \"sum of all LienToken amounts\" and documented elsewhere as \"yIntercept (virtual assets) of a PublicVault\". It is used to calculate the total assets of a public vault as: `slope.mulDivDown(delta_t, 1) + yIntercept`.\n\nIt is expected to be updated on deposits, payments, withdrawals, liquidations. However, the deduction of `yIntercept` during payments is missing in `beforePayment()`. As noted in the function's Natspec:\n```solidity\n /**\n   * @notice Hook to update the slope and yIntercept of the PublicVault on payment.\n   * The rate for the LienToken is subtracted from the total slope of the PublicVault, and recalculated in afterPayment().\n   * @param lienId The ID of the lien.\n   * @param amount The amount paid off to deduct from the yIntercept of the PublicVault.\n   */\n```\nthe amount of payment should be deducted from `yIntercept` but is missing. \n\n## Impact\n\nPoC: https://gist.github.com/berndartmueller/477cc1026d3fe3e226795a34bb8a903a\n\nThis missing update will inflate the inferred value of the public vault corresponding to its actual value leading to eventual insolvency because of resulting protocol miscalculations.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L427-L442\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate `yIntercept` in `beforePayment()` by the `amount` value.\n\n## Discussion\n\n**androolloyd**\n\ntagging @SantiagoGregory but i believe this is a documentation error, will address\n\n**secureum**\n\nEscalate for 2 USDC.\n\nGiven the vault insolvency impact as described and demonstrated by the PoC, we still think this is a high-severity impact (not Medium as judged). The other dup #92 also reported this as a High.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> Given the vault insolvency impact as described and demonstrated by the PoC, we still think this is a high-severity impact (not Medium as judged). The other dup #92 also reported this as a High.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721, IERC165} from \"gpl/interfaces/IERC721.sol\";\nimport {\n  IVault,\n  ERC4626Cloned,\n  ITokenBase,\n  ERC4626Base,\n  AstariaVaultBase\n} from \"gpl/ERC4626-Cloned.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ILienBase} from \"./interfaces/ILienToken.sol\";\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {LienToken} from \"./LienToken.sol\";\nimport {LiquidationAccountant} from \"./LiquidationAccountant.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {WithdrawProxy} from \"./WithdrawProxy.sol\";\n\nimport {Math} from \"./utils/Math.sol\";\nimport {Pausable} from \"./utils/Pausable.sol\";\n\ninterface IPublicVault is IERC165 {\n  function beforePayment(uint256 escrowId, uint256 amount) external;\n\n  function decreaseEpochLienCount(uint256 lienId) external;\n\n  function getLienEpoch(uint256 end) external view returns (uint256);\n\n  function afterPayment(uint256 lienId) external;\n}\n\n/**\n * @title Vault\n * @author androolloyd\n */\ncontract Vault is AstariaVaultBase, VaultImplementation, IVault {\n  using SafeTransferLib for ERC20;\n\n  function name() public view override returns (string memory) {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(underlying()).symbol()));\n  }\n\n  function symbol() public view override returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\"AST-V\", owner(), \"-\", ERC20(underlying()).symbol())\n      );\n  }\n\n  function _handleStrategistInterestReward(uint256 lienId, uint256 shares)\n    internal\n    virtual\n    override\n  {}\n\n  function deposit(uint256 amount, address)\n    public\n    virtual\n    override\n    returns (uint256)\n  {\n    require(msg.sender == owner(), \"only the appraiser can fund this vault\");\n    ERC20(underlying()).safeTransferFrom(\n      address(msg.sender),\n      address(this),\n      amount\n    );\n    return amount;\n  }\n\n  function withdraw(uint256 amount) external {\n    require(msg.sender == owner(), \"only the appraiser can exit this vault\");\n    ERC20(underlying()).safeTransferFrom(\n      address(this),\n      address(msg.sender),\n      amount\n    );\n  }\n}\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is Vault, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  // epoch seconds when yIntercept was calculated last\n  uint256 public last;\n  // sum of all LienToken amounts\n  uint256 public yIntercept;\n  // sum of all slopes of each LienToken\n  uint256 public slope;\n\n  // block.timestamp of first epoch\n  uint256 public withdrawReserve = 0;\n  uint256 liquidationWithdrawRatio = 0;\n  uint256 strategistUnclaimedShares = 0;\n  uint64 public currentEpoch = 0;\n\n  //mapping of epoch to number of open liens\n  mapping(uint256 => uint256) public liensOpenForEpoch;\n  // WithdrawProxies and LiquidationAccountants for each epoch.\n  // The first possible WithdrawProxy and LiquidationAccountant starts at index 0, i.e. an LP that marks a withdraw in epoch 0 to collect by the end of epoch *1* would use the 0th WithdrawProxy.\n  mapping(uint64 => address) public withdrawProxies;\n  mapping(uint64 => address) public liquidationAccountants;\n  mapping(uint64 => uint256) public liquidationsExpectedAtBoundary;\n\n  event YInterceptChanged(uint256 newYintercept);\n  event WithdrawReserveTransferred(uint256 amount);\n\n  function underlying()\n    public\n    view\n    virtual\n    override(ERC4626Base, AstariaVaultBase)\n    returns (address)\n  {\n    return super.underlying();\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override returns (uint256 assets) {\n    assets = redeemFutureEpoch(shares, receiver, owner, currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n    redeemFutureEpoch(shares, receiver, owner, currentEpoch);\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in an arbitrary future epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @param epoch The epoch to withdraw for.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not the current epoch or in the past\n    require(epoch >= currentEpoch, \"Exit epoch too low\");\n\n    require(msg.sender == owner, \"Only the owner can redeem\");\n    // check for rounding error since we round down in previewRedeem.\n\n    ERC20(address(this)).safeTransferFrom(owner, address(this), shares);\n\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(withdrawProxies[epoch]).mint(receiver, shares); // was withdrawProxies[withdrawEpoch]\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(uint64 epoch) internal {\n    if (withdrawProxies[epoch] == address(0)) {\n      address proxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).WITHDRAW_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(this), //owner\n          underlying() //token\n        )\n      );\n      withdrawProxies[epoch] = proxy;\n    }\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(Vault, ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  /**\n   * @notice Rotate epoch boundary. This must be called before the next epoch can begin.\n   */\n  function processEpoch() external {\n    // check to make sure epoch is over\n    require(getEpochEnd(currentEpoch) < block.timestamp, \"Epoch has not ended\");\n    require(withdrawReserve == 0, \"Withdraw reserve not empty\");\n    if (liquidationAccountants[currentEpoch] != address(0)) {\n      require(\n        LiquidationAccountant(liquidationAccountants[currentEpoch])\n          .getFinalAuctionEnd() < block.timestamp,\n        \"Final auction not ended\"\n      );\n    }\n\n    // split funds from LiquidationAccountant between PublicVault and WithdrawProxy if hasn't been already\n    if (\n      currentEpoch != 0 &&\n      liquidationAccountants[currentEpoch - 1] != address(0)\n    ) {\n      LiquidationAccountant(liquidationAccountants[currentEpoch - 1]).claim();\n    }\n\n    require(\n      liensOpenForEpoch[currentEpoch] == uint256(0),\n      \"loans are still open for this epoch\"\n    );\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if (withdrawProxies[currentEpoch] != address(0)) {\n      uint256 proxySupply = WithdrawProxy(withdrawProxies[currentEpoch])\n        .totalSupply();\n\n      liquidationWithdrawRatio = proxySupply.mulDivDown(1e18, totalSupply());\n\n      if (liquidationAccountants[currentEpoch] != address(0)) {\n        LiquidationAccountant(liquidationAccountants[currentEpoch])\n          .setWithdrawRatio(liquidationWithdrawRatio);\n      }\n\n      uint256 withdrawAssets = convertToAssets(proxySupply);\n      // compute the withdrawReserve\n      uint256 withdrawLiquidations = liquidationsExpectedAtBoundary[\n        currentEpoch\n      ].mulDivDown(liquidationWithdrawRatio, 1e18);\n      withdrawReserve = withdrawAssets - withdrawLiquidations;\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n\n      _decreaseYIntercept(withdrawAssets);\n    }\n\n    // increment epoch\n    currentEpoch++;\n  }\n\n  /**\n   * @notice Deploys a LiquidationAccountant for the WithdrawProxy for the upcoming epoch boundary.\n   * @return accountant The address of the deployed LiquidationAccountant.\n   */\n  function deployLiquidationAccountant() public returns (address accountant) {\n    require(\n      liquidationAccountants[currentEpoch] == address(0),\n      \"cannot deploy two liquidation accountants for the same epoch\"\n    );\n\n    _deployWithdrawProxyIfNotDeployed(currentEpoch);\n\n    accountant = ClonesWithImmutableArgs.clone(\n      IAstariaRouter(ROUTER()).LIQUIDATION_IMPLEMENTATION(),\n      abi.encodePacked(\n        underlying(),\n        ROUTER(),\n        address(this),\n        address(LIEN_TOKEN()),\n        address(withdrawProxies[currentEpoch])\n      )\n    );\n    liquidationAccountants[currentEpoch] = accountant;\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(IVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  event TransferWithdraw(uint256 a, uint256 b);\n\n  /**\n   * @notice Transfers funds from the PublicVault to the WithdrawProxy.\n   */\n\n  function transferWithdrawReserve() public {\n    // check the available balance to be withdrawn\n    uint256 withdraw = ERC20(underlying()).balanceOf(address(this));\n    emit TransferWithdraw(withdraw, withdrawReserve);\n\n    // prevent transfer of more assets then are available\n    if (withdrawReserve <= withdraw) {\n      withdraw = withdrawReserve;\n      withdrawReserve = 0;\n    } else {\n      withdrawReserve -= withdraw;\n    }\n    emit TransferWithdraw(withdraw, withdrawReserve);\n\n    address currentWithdrawProxy = withdrawProxies[currentEpoch - 1]; //\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      ERC20(underlying()).safeTransfer(currentWithdrawProxy, withdraw);\n      emit WithdrawReserveTransferred(withdraw);\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   * @param amount The amount of debt\n   */\n  function _afterCommitToLien(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n  {\n    // increment slope for the new lien\n    unchecked {\n      slope += LIEN_TOKEN().calculateSlope(lienId);\n    }\n\n    ILienToken.Lien memory lien = LIEN_TOKEN().getLien(lienId);\n\n    uint256 epoch = Math.ceilDiv(\n      lien.start + lien.duration - START(),\n      EPOCH_LENGTH()\n    ) - 1;\n\n    liensOpenForEpoch[epoch]++;\n    emit LienOpen(lienId, epoch);\n  }\n\n  event LienOpen(uint256 lienId, uint256 epoch);\n\n  /**\n   * @notice Retrieves the address of the LienToken contract for this PublicVault.\n   * @return The LienToken address.\n   */\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    return IAstariaRouter(ROUTER()).LIEN_TOKEN();\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n\n  function totalAssets() public view virtual override returns (uint256) {\n    if (last == 0 || yIntercept == 0) {\n      return ERC20(underlying()).balanceOf(address(this));\n    }\n    uint256 delta_t = block.timestamp - last;\n\n    return slope.mulDivDown(delta_t, 1) + yIntercept;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply + strategistUnclaimedShares;\n  }\n\n  /**\n   * @notice Mints earned fees by the strategist to the strategist address.\n   */\n  function claim() external onlyOwner {\n    _mint(owner(), strategistUnclaimedShares);\n    strategistUnclaimedShares = 0;\n  }\n\n  /**\n   * @notice Hook to update the slope and yIntercept of the PublicVault on payment.\n   * The rate for the LienToken is subtracted from the total slope of the PublicVault, and recalculated in afterPayment().\n   * @param lienId The ID of the lien.\n   * @param amount The amount paid off to deduct from the yIntercept of the PublicVault.\n   */\n  function beforePayment(uint256 lienId, uint256 amount) public onlyLienToken {\n    _handleStrategistInterestReward(lienId, amount);\n    uint256 lienSlope = LIEN_TOKEN().calculateSlope(lienId);\n    if (lienSlope > slope) {\n      slope = 0;\n    } else {\n      slope -= lienSlope;\n    }\n    last = block.timestamp;\n  }\n\n  /** @notice\n   * hook to modify the liens open for then given epoch\n   * @param epoch epoch to decrease liens of\n   */\n  function decreaseEpochLienCount(uint256 epoch) external {\n    require(\n      msg.sender == address(ROUTER()) || msg.sender == address(LIEN_TOKEN()),\n      \"only router or lien token\"\n    );\n    liensOpenForEpoch[epoch]--;\n  }\n\n  /** @notice\n   * hook to increase the amount of debt currently liquidated to discount in processEpoch\n   * @param amount the amount of debt liquidated\n   */\n  function increaseLiquidationsExpectedAtBoundary(uint256 amount) external {\n    require(msg.sender == ROUTER(), \"only router\");\n    liquidationsExpectedAtBoundary[currentEpoch] += amount;\n  }\n\n  /** @notice\n   * helper to return the LienEpoch for a given end date\n   * @param end time to compute the end for\n   */\n  function getLienEpoch(uint256 end) external view returns (uint256) {\n    return Math.ceilDiv(end - START(), EPOCH_LENGTH()) - 1;\n  }\n\n  function getEpochEnd(uint256 epoch) public view returns (uint256) {\n    return START() + (epoch + 1) * EPOCH_LENGTH();\n  }\n\n  function _increaseOpenLiens() internal {\n    liensOpenForEpoch[currentEpoch]++;\n  }\n\n  /**\n   * @notice Hook to recalculate the slope of a lien after a payment has been made.\n   * @param lienId The ID of the lien.\n   */\n  function afterPayment(uint256 lienId) public onlyLienToken {\n    slope += LIEN_TOKEN().calculateSlope(lienId);\n  }\n\n  modifier onlyLienToken() {\n    require(msg.sender == address(LIEN_TOKEN()));\n    _;\n  }\n\n  /**\n   * @notice After-deposit hook to update the yIntercept of the PublicVault to reflect a capital contribution.\n   * @param assets The amount of assets deposited to the PublicVault.\n   * @param shares The resulting amount of VaultToken shares that were issued.\n   */\n  function afterDeposit(uint256 assets, uint256 shares)\n    internal\n    virtual\n    override\n  {\n    yIntercept += assets;\n    emit YInterceptChanged(yIntercept);\n  }\n\n  /**\n   * @dev Handles the dilutive fees (on lien repayments) for strategists in VaultTokens.\n   * @param lienId The ID of the lien that received a payment.\n   * @param amount The amount that was paid.\n   */\n  function _handleStrategistInterestReward(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n  {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 interestOwing = LIEN_TOKEN().getInterest(lienId);\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 1000); //VAULT_FEE is a basis point\n      strategistUnclaimedShares += convertToShares(fee);\n    }\n  }\n\n  function updateVaultAfterLiquidation(uint256 lienSlope) public {\n    require(msg.sender == ROUTER(), \"can only be called by the router\");\n    uint256 delta_t = block.timestamp - last;\n\n    yIntercept = slope.mulDivDown(delta_t, 1) + yIntercept;\n    last = block.timestamp;\n    slope -= lienSlope;\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return yIntercept;\n  }\n\n  function _decreaseYIntercept(uint256 amount) internal {\n    yIntercept -= amount;\n    emit YInterceptChanged(yIntercept);\n  }\n\n  function decreaseYIntercept(uint256 amount) public {\n    require(\n      msg.sender == AUCTION_HOUSE() ||\n        (currentEpoch != 0 &&\n          msg.sender == liquidationAccountants[currentEpoch - 1]),\n      \"msg sender only from auction house or liquidation accountant\"\n    );\n    _decreaseYIntercept(amount);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return currentEpoch;\n  }\n\n  /**\n   * @notice Computes the time until the current epoch is over.\n   * @return Seconds until the current epoch ends.\n   */\n  function timeToEpochEnd() public view returns (uint256) {\n    uint256 epochEnd = START() + ((currentEpoch + 1) * EPOCH_LENGTH());\n\n    if (epochEnd >= block.timestamp) {\n      return uint256(0);\n    }\n\n    return block.timestamp - epochEnd; //\n  }\n\n  function getLiquidationAccountant(uint64 epoch)\n    public\n    view\n    returns (address)\n  {\n    return liquidationAccountants[epoch];\n  }\n}"
    }
  ]
}