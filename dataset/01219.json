{
  "Title": "Incorrect check for cRation_MAX",
  "Content": "# Incorrect check for cRation_MAX\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ShortRecordFacet.sol#L56\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ShortRecordFacet.sol#L56</a>\n\n\n## Summary\nThe current implementation of the check stops the user for increasing the collateral with the exact max amount.\n\n## Vulnerability Details\nHowever this is not a problem and funds are not at risk, it may be confusing for the user, the error he is going to see states that the amount sent by him is higher than the maximum, as it will still revert if it is equal to the maximum.\n\n## Impact\n\n## Tools Used\nManual Review\n\n## Recommendations\nChange this code:\nif (cRatio >= Constants.CRATIO_MAX) revert Errors.CollateralHigherThanMax();\nto this code\nif (cRatio > Constants.CRATIO_MAX) revert Errors.CollateralHigherThanMax();\n\nor implement a better error message if this is the intended behavior.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/ShortRecordFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ShortRecordFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Increases collateral of an active short\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param amount Eth amount to increase collateral by\n     *\n     */\n\n    function increaseCollateral(address asset, uint8 id, uint88 amount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n        STypes.VaultUser storage VaultUser = s.vaultUser[vault][msg.sender];\n        if (VaultUser.ethEscrowed < amount) revert Errors.InsufficientETHEscrowed();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n        short.updateErcDebt(asset);\n        uint256 yield = short.collateral.mul(short.zethYieldRate);\n        short.collateral += amount;\n\n        uint256 cRatio = short.getCollateralRatio(asset);\n        if (cRatio >= Constants.CRATIO_MAX) revert Errors.CollateralHigherThanMax();\n\n        //@dev reset flag info if new cratio is above primaryLiquidationCR\n        if (cRatio >= LibAsset.primaryLiquidationCR(asset)) {\n            short.resetFlag();\n        }\n\n        yield += amount.mul(Vault.zethYieldRate);\n        short.zethYieldRate = yield.divU80(short.collateral);\n\n        VaultUser.ethEscrowed -= amount;\n        Vault.zethCollateral += amount;\n        Asset.zethCollateral += amount;\n        emit Events.IncreaseCollateral(asset, msg.sender, id, amount);\n    }\n\n    /**\n     * @notice Decrease collateral of an active short\n     * @dev Cannot decrease below initial margin\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param amount Eth amount to decrease collateral by\n     *\n     */\n\n    function decreaseCollateral(address asset, uint8 id, uint88 amount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n        short.updateErcDebt(asset);\n        if (amount > short.collateral) revert Errors.InsufficientCollateral();\n\n        short.collateral -= amount;\n\n        uint256 cRatio = short.getCollateralRatio(asset);\n        if (cRatio < LibAsset.initialMargin(asset)) {\n            revert Errors.CollateralLowerThanMin();\n        }\n\n        uint256 vault = s.asset[asset].vault;\n        s.vaultUser[vault][msg.sender].ethEscrowed += amount;\n\n        LibShortRecord.disburseCollateral(\n            asset, msg.sender, amount, short.zethYieldRate, short.updatedAt\n        );\n        emit Events.DecreaseCollateral(asset, msg.sender, id, amount);\n    }\n\n    /**\n     * @notice Combine active shorts into one short\n     * @dev If any shorts are flagged the resulting short must have c-ratio > primaryLiquidationCR\n     *\n     * @param asset The market that will be impacted\n     * @param ids Array of short ids to be combined\n     *\n     */\n\n    function combineShorts(address asset, uint8[] memory ids)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, ids[0])\n    {\n        if (ids.length < 2) revert Errors.InsufficientNumberOfShorts();\n        // First short in the array\n        STypes.ShortRecord storage firstShort = s.shortRecords[asset][msg.sender][ids[0]];\n        // @dev Load initial short elements in struct to avoid stack too deep\n        MTypes.CombineShorts memory c;\n        c.shortFlagExists = firstShort.flaggerId != 0;\n        c.shortUpdatedAt = firstShort.updatedAt;\n\n        address _asset = asset;\n        uint88 collateral;\n        uint88 ercDebt;\n        uint256 yield;\n        uint256 ercDebtSocialized;\n        for (uint256 i = ids.length - 1; i > 0; i--) {\n            uint8 _id = ids[i];\n            _onlyValidShortRecord(_asset, msg.sender, _id);\n            STypes.ShortRecord storage currentShort =\n                s.shortRecords[_asset][msg.sender][_id];\n            // See if there is at least one flagged short\n            if (!c.shortFlagExists) {\n                if (currentShort.flaggerId != 0) {\n                    c.shortFlagExists = true;\n                }\n            }\n\n            //@dev Take latest time when combining shorts (prevent flash loan)\n            if (currentShort.updatedAt > c.shortUpdatedAt) {\n                c.shortUpdatedAt = currentShort.updatedAt;\n            }\n\n            {\n                uint88 currentShortCollateral = currentShort.collateral;\n                uint88 currentShortErcDebt = currentShort.ercDebt;\n                collateral += currentShortCollateral;\n                ercDebt += currentShortErcDebt;\n                yield += currentShortCollateral.mul(currentShort.zethYieldRate);\n                ercDebtSocialized += currentShortErcDebt.mul(currentShort.ercDebtRate);\n            }\n\n            if (currentShort.tokenId != 0) {\n                //@dev First short needs to have NFT so there isn't a need to burn and re-mint\n                if (firstShort.tokenId == 0) {\n                    revert Errors.FirstShortMustBeNFT();\n                }\n\n                LibShortRecord.burnNFT(currentShort.tokenId);\n            }\n\n            // Cancel this short and combine with short in ids[0]\n            LibShortRecord.deleteShortRecord(_asset, msg.sender, _id);\n        }\n\n        // Merge all short records into the short at position id[0]\n        firstShort.merge(ercDebt, ercDebtSocialized, collateral, yield, c.shortUpdatedAt);\n\n        // If at least one short was flagged, ensure resulting c-ratio > primaryLiquidationCR\n        if (c.shortFlagExists) {\n            if (\n                firstShort.getCollateralRatioSpotPrice(\n                    LibOracle.getSavedOrSpotOraclePrice(_asset)\n                ) < LibAsset.primaryLiquidationCR(_asset)\n            ) revert Errors.InsufficientCollateral();\n            // Resulting combined short has sufficient c-ratio to remove flag\n            firstShort.resetFlag();\n        }\n        emit Events.CombineShorts(asset, msg.sender, ids);\n    }\n}"
    }
  ]
}