{
  "Title": "[M02] Documentation issues",
  "Content": "Overall, the code base presents well documented functions and clear docstrings. However, there are some designs choices and parts of the code which lack of a proper description.\n\n\nThe [`ReserveSwapper`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L33) contract allows the governance to list orders on ERC20 token swaps. Any user can trade against those orders once listed. Tokens to be swapped must be owned by the reserve itself but  \n\nhow this contract is going to be used and which ERC20 are going to be traded is not documented anywhere. Moreover, in [line 51](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L51) from `ReserveSwapper.sol` it is clear that the reserve can have an unlimited `amount` of tokens to be sold but itâ€™s not clear nor documented this design choice and in which cases the governance can list an unlimited amount order for a specific token.  \n\nConsider adding proper documentation about the intentions over the use of this feature.\n\n\nThe [`Stake`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/governance/Stake.sol#L36) contract defines all the properties of the `ESDS` governance token. Balances and allowances for this token [are accounted as `uint96` variables](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/governance/Stake.sol#L59) in order to pack the [`CheckPoint`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/governance/Stake.sol#L65) struct into 128 bits.  \n\nBecause of this, every place in the code base that makes use of the `ESDS` tokens must carefully manage big balances or allowances in order to avoid overflows. As an example, the [`ReserveIssuer`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveIssuer.sol#L32) contract is defining the [`mintStake`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveIssuer.sol#L52) and [`burnStake`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveIssuer.sol#L66) functions that `mint` and `burn` `ESDS` tokens, but those functions are not properly documented to reflect the internal behavior of the `ESDS` token.  \n\nConsider carefully document any use of `ESDS` tokens outside of the `Stake` contract to prevent developers and users from performing miscalculations.\n\n\nThe [`redeem`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveComptroller.sol#L124) function from the `ReserveComptroller` contract retrieves `USDC` tokens in exchange of `ESD` tokens, which these are then burned.  \n\nBecause of the [`redemptionTax`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveState.sol#L86) that can be set to artificially manipulate the price, the actual [redeemed amount](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveComptroller.sol#L125), can be artificially lowered to any value, including zero.  \n\nConsider explicitly warn users about this possibility and properly document this behavior.\n\n\nIn [`line 104-107`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveComptroller.sol#L104-L107) from `ReserveComptroller.sol`, the docstrings are not clear about the fact that the user must first approve the contract to transfer tokens.  \n\nConsider adding this to the docstrings of the function.\n\n\n***Update**: Fixed on [pull request 15](https://github.com/emptysetsquad/emptyset/pull/15/commits/d75b1fc4569f7255ae733c32d331d8c95fc89764).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/reserve/ReserveSwapper.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"./ReserveComptroller.sol\";\nimport \"./ReserveState.sol\";\n\n/**\n * @title ReserveSwapper\n * @notice Logic for managing outstanding limit orders, allow the reserve to swap its held tokens\n */\ncontract ReserveSwapper is ReentrancyGuard, ReserveComptroller {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `amount` of the `makerToken`-`takerToken` order is registered with price `price`\n     */\n    event OrderRegistered(address indexed makerToken, address indexed takerToken, uint256 price, uint256 amount);\n\n    /**\n     * @notice Emitted when the reserve pays `takerAmount` of `takerToken` in exchange for `makerAmount` of `makerToken`\n     */\n    event Swap(address indexed makerToken, address indexed takerToken, uint256 takerAmount, uint256 makerAmount);\n\n    /**\n     * @notice Sets the `price` and `amount` of the specified `makerToken`-`takerToken` order\n     * @dev Owner only - governance hook\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the reserve wishes to sell\n     * @param takerToken Token that the reserve wishes to buy\n     * @param price Price as a ratio of takerAmount:makerAmount times 10^18\n     * @param amount Amount to decrement in ESD\n     */\n    function registerOrder(address makerToken, address takerToken, uint256 price, uint256 amount) external onlyOwner {\n        _updateOrder(makerToken, takerToken, price, amount);\n\n        emit OrderRegistered(makerToken, takerToken, price, amount);\n    }\n\n    /**\n     * @notice Purchases `makerToken` from the reserve in exchange for `takerAmount` of `takerToken`\n     * @dev Non-reentrant\n     *      Uses the state-defined price for the `makerToken`-`takerToken` order\n     *      Maker and taker tokens must be different\n     *      Cannot swap ESD\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the caller wishes to buy\n     * @param takerToken Token that the caller wishes to sell\n     * @param takerAmount Amount of takerToken to sell\n     */\n    function swap(address makerToken, address takerToken, uint256 takerAmount) external nonReentrant {\n        address dollar = registry().dollar();\n        require(makerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(takerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(makerToken != takerToken, \"ReserveSwapper: tokens equal\");\n\n        ReserveTypes.Order memory order = order(makerToken, takerToken);\n        uint256 makerAmount = Decimal.from(takerAmount).div(order.price, \"ReserveSwapper: no order\").asUint256();\n\n        if (order.amount != uint256(-1))\n            _decrementOrderAmount(makerToken, takerToken, makerAmount, \"ReserveSwapper: insufficient amount\");\n\n        _transferFrom(takerToken, msg.sender, address(this), takerAmount);\n        _transfer(makerToken, msg.sender, makerAmount);\n\n        emit Swap(makerToken, takerToken, takerAmount, makerAmount);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/reserve/ReserveSwapper.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"./ReserveComptroller.sol\";\nimport \"./ReserveState.sol\";\n\n/**\n * @title ReserveSwapper\n * @notice Logic for managing outstanding limit orders, allow the reserve to swap its held tokens\n */\ncontract ReserveSwapper is ReentrancyGuard, ReserveComptroller {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `amount` of the `makerToken`-`takerToken` order is registered with price `price`\n     */\n    event OrderRegistered(address indexed makerToken, address indexed takerToken, uint256 price, uint256 amount);\n\n    /**\n     * @notice Emitted when the reserve pays `takerAmount` of `takerToken` in exchange for `makerAmount` of `makerToken`\n     */\n    event Swap(address indexed makerToken, address indexed takerToken, uint256 takerAmount, uint256 makerAmount);\n\n    /**\n     * @notice Sets the `price` and `amount` of the specified `makerToken`-`takerToken` order\n     * @dev Owner only - governance hook\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the reserve wishes to sell\n     * @param takerToken Token that the reserve wishes to buy\n     * @param price Price as a ratio of takerAmount:makerAmount times 10^18\n     * @param amount Amount to decrement in ESD\n     */\n    function registerOrder(address makerToken, address takerToken, uint256 price, uint256 amount) external onlyOwner {\n        _updateOrder(makerToken, takerToken, price, amount);\n\n        emit OrderRegistered(makerToken, takerToken, price, amount);\n    }\n\n    /**\n     * @notice Purchases `makerToken` from the reserve in exchange for `takerAmount` of `takerToken`\n     * @dev Non-reentrant\n     *      Uses the state-defined price for the `makerToken`-`takerToken` order\n     *      Maker and taker tokens must be different\n     *      Cannot swap ESD\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the caller wishes to buy\n     * @param takerToken Token that the caller wishes to sell\n     * @param takerAmount Amount of takerToken to sell\n     */\n    function swap(address makerToken, address takerToken, uint256 takerAmount) external nonReentrant {\n        address dollar = registry().dollar();\n        require(makerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(takerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(makerToken != takerToken, \"ReserveSwapper: tokens equal\");\n\n        ReserveTypes.Order memory order = order(makerToken, takerToken);\n        uint256 makerAmount = Decimal.from(takerAmount).div(order.price, \"ReserveSwapper: no order\").asUint256();\n\n        if (order.amount != uint256(-1))\n            _decrementOrderAmount(makerToken, takerToken, makerAmount, \"ReserveSwapper: insufficient amount\");\n\n        _transferFrom(takerToken, msg.sender, address(this), takerAmount);\n        _transfer(makerToken, msg.sender, makerAmount);\n\n        emit Swap(makerToken, takerToken, takerAmount, makerAmount);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/governance/Stake.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../Interfaces.sol\";\n\n/*\n * audit-info: Forked from Compound's Comp contract:\n *             https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n *\n *             Sections that have been changed from the original have been denoted with audit notes\n *             Additionally \"Comp\" has been renamed to \"Stake\" throughout\n */\n\n/*\n * audit-info: Beginning of modified code section\n */\n\ncontract Stake is IManagedToken, Ownable {\n\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Empty Set Dollar Stake\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"ESDS\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    /// @dev Initialized at 0, use mint() for initial distribution to migrator & incentivizer(s)\n    uint public totalSupply;\n\n    /*\n     * audit-info: End of modified code section\n     */\n\n    /// @notice Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint96)) internal allowances;\n\n    /// @notice Official record of token balances for each account\n    mapping (address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*\n     * audit-info: Beginning of modified code section\n     */\n\n    /**\n     * @notice Mint new tokens\n     * @param rawAmount The number of tokens to be minted\n     */\n    function mint(uint rawAmount) public onlyOwner {\n        // mint the amount\n        uint96 amount = safe96(rawAmount, \"Stake::mint: amount exceeds 96 bits\");\n        totalSupply = safe96(SafeMath.add(totalSupply, amount), \"Stake::mint: totalSupply exceeds 96 bits\");\n\n        // transfer the amount to the recipient\n        balances[owner()] = add96(balances[owner()], amount, \"Stake::mint: transfer amount overflows\");\n        emit Transfer(address(0), owner(), amount);\n\n        // move delegates\n        _moveDelegates(address(0), delegates[owner()], amount);\n    }\n\n    /**\n     * @notice Mint new tokens\n     * @param rawAmount The number of tokens to be minted\n     */\n    function burn(uint rawAmount) public onlyOwner {\n        // burn the amount\n        uint96 amount = safe96(rawAmount, \"Stake::burn: amount exceeds 96 bits\");\n        totalSupply = safe96(\n            SafeMath.sub(totalSupply, amount, \"Stake::burn: amount exceeds totalSupply\"),\n            \"Stake::burn: totalSupply exceeds 96 bits\");\n\n        // transfer the amount to the recipient\n        balances[owner()] = sub96(balances[owner()], amount, \"Stake::burn: transfer amount overflows\");\n        emit Transfer(owner(), address(0), amount);\n\n        // move delegates\n        _moveDelegates(delegates[owner()], address(0), amount);\n    }\n\n    /*\n     * audit-info: End of modified code section\n     */\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, \"Stake::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external returns (bool) {\n        uint96 amount = safe96(rawAmount, \"Stake::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"Stake::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Stake::transferFrom: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Stake::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Stake::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"Stake::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"Stake::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(address src, address dst, uint96 amount) internal {\n        require(src != address(0), \"Stake::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Stake::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"Stake::_transferTokens: transfer amount exceeds balance\");\n        balances[dst] = add96(balances[dst], amount, \"Stake::_transferTokens: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Stake::_moveVotes: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Stake::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n        uint32 blockNumber = safe32(block.number, \"Stake::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/reserve/ReserveIssuer.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"./ReserveState.sol\";\n\n/**\n * @title ReserveIssuer\n * @notice Logic to manage the supply of ESDS\n */\ncontract ReserveIssuer is ReentrancyGuard, ReserveAccessors {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    /**\n      * @notice Emitted when `account` mints `amount` of ESDS\n      */\n    event MintStake(address account, uint256 mintAmount);\n\n    /**\n      * @notice Emitted when `amount` of ESDS is burned from the reserve\n      */\n    event BurnStake(uint256 burnAmount);\n\n    /**\n     * @notice Mints new ESDS tokens to a specified `account`\n     * @dev Non-reentrant\n     *      Owner only - governance hook\n     * @param account Account to mint ESDS to\n     * @param amount Amount of ESDS to mint\n     */\n    function mintStake(address account, uint256 amount) public onlyOwner nonReentrant {\n        address stake = registry().stake();\n\n        IManagedToken(stake).mint(amount);\n        IERC20(stake).safeTransfer(account, amount);\n\n        emit MintStake(account, amount);\n    }\n\n    /**\n     * @notice Burns all reserve-held ESDS tokens\n     * @dev Non-reentrant\n     *      Owner only - governance hook\n     */\n    function burnStake() public onlyOwner nonReentrant {\n        address stake = registry().stake();\n\n        uint256 stakeBalance = IERC20(stake).balanceOf(address(this));\n        IManagedToken(stake).burn(stakeBalance);\n\n        emit BurnStake(stakeBalance);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/reserve/ReserveComptroller.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"../lib/Decimal.sol\";\nimport \"../lib/TimeUtils.sol\";\nimport \"./ReserveState.sol\";\nimport \"./ReserveVault.sol\";\n\n/**\n * @title ReserveComptroller\n * @notice Reserve accounting logic for managing the ESD stablecoin.\n */\ncontract ReserveComptroller is ReentrancyGuard, ReserveAccessors, ReserveVault {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `account` purchases `mintAmount` ESD from the reserve for `costAmount` USDC\n     */\n    event Mint(address indexed account, uint256 mintAmount, uint256 costAmount);\n\n    /**\n     * @notice Emitted when `account` sells `costAmount` ESD to the reserve for `redeemAmount` USDC\n     */\n    event Redeem(address indexed account, uint256 costAmount, uint256 redeemAmount);\n\n    /**\n     * @notice Emitted when the stabilizer borrows `amount` ESD from the reserve\n     */\n    event Borrow(uint256 amount);\n\n    /**\n     * @notice Emitted when `account` settles `settleAmount` ESD of the reserve's debt for `costAmount` USDC\n     */\n    event Settle(address indexed account, uint256 settleAmount, uint256 proceedAmount);\n\n    /**\n     * @notice Per-day borrow limit expressed as a percentage of total supply\n     * @dev Represents limit * 10^18\n     */\n    uint256 private constant DAILY_BORROW_LIMIT = 0.002e18; // 107% APY\n\n    /**\n     * @notice Helper constant to convert ESD to USDC and vice versa\n     */\n    uint256 private constant USDC_DECIMAL_DIFF = 1e12;\n\n    // EXTERNAL\n\n    /**\n     * @notice The total value of the reserve-owned assets denominated in USDC\n     * @return Reserve total value\n     */\n    function reserveBalance() public view returns (uint256) {\n        uint256 internalBalance = _balanceOf(registry().usdc(), address(this));\n        uint256 vaultBalance = _balanceOfVault();\n        return internalBalance.add(vaultBalance);\n    }\n\n    /**\n     * @notice Rhe ratio of the {reserveBalance} to total ESD issuance\n     * @dev Assumes 1 ESD = 1 USDC, normalizing for decimals\n     * @return Reserve ratio\n     */\n    function reserveRatio() public view returns (Decimal.D256 memory) {\n        uint256 issuance = _totalSupply(registry().dollar());\n        return issuance == 0 ? Decimal.one() : Decimal.ratio(_fromUsdcAmount(reserveBalance()), issuance);\n    }\n\n    /**\n     * @notice The price that one ESD can currently be sold to the reserve for\n     * @dev Returned as a Decimal.D256\n     *      Normalizes for decimals (e.g. 1.00 USDC == Decimal.one())\n     * @return Current ESD redemption price\n     */\n    function redeemPrice() public view returns (Decimal.D256 memory) {\n        return Decimal.min(reserveRatio(), Decimal.one()).subOrZero(redemptionTax());\n    }\n\n    /**\n     * @notice Mints `amount` ESD to the caller in exchange for an equivalent amount of USDC\n     * @dev Non-reentrant\n     *      Normalizes for decimals\n     * @param amount Amount of ESD to mint\n     */\n    function mint(uint256 amount) external nonReentrant {\n        uint256 costAmount = _toUsdcAmount(amount);\n        _transferFrom(registry().usdc(), msg.sender, address(this), costAmount);\n        _supplyVault(costAmount);\n        _mintDollar(msg.sender, amount);\n\n        emit Mint(msg.sender, amount, costAmount);\n    }\n\n    /**\n     * @notice Burns `amount` ESD from the caller in exchange for USDC at the rate of {redeemPrice}\n     * @dev Non-reentrant\n     *      Normalizes for decimals\n     * @param amount Amount of ESD to mint\n     */\n    function redeem(uint256 amount) external nonReentrant {\n        uint256 redeemAmount = _toUsdcAmount(redeemPrice().mul(amount).asUint256());\n\n        _transferFrom(registry().dollar(), msg.sender, address(this), amount);\n        _burnDollar(amount);\n        _redeemVault(redeemAmount);\n        _transfer(registry().usdc(), msg.sender, redeemAmount);\n\n        emit Redeem(msg.sender, amount, redeemAmount);\n    }\n\n    /**\n     * @notice Allows the stabilizer to mint `amount` ESD to itself, while incrementing reserve debt equivalently\n     * @dev Non-reentrant\n     *      Only callable by the stabilizer\n     *      Increments reserve debt by `amount`\n     * @param amount Amount of ESD to borrow\n     */\n    function borrow(uint256 amount) external nonReentrant {\n        require(msg.sender == registry().stabilizer(), \"ReserveComptroller: not stabilizer\");\n\n        _syncBorrowed(amount);\n        _incrementDebt(amount);\n\n        _mintDollar(registry().stabilizer(), amount);\n\n        emit Borrow(amount);\n    }\n\n    /**\n     * @notice Burns `amount` ESD from the caller in exchange for equivalent amount of USDC\n     * @dev Non-reentrant\n     *      Normalizes for decimals\n     *      Offsets `amount` of the reserve debt from borrowing\n     *      Not available if there's insufficient debt\n     * @param amount Amount of ESD to burn\n     */\n    function settle(uint256 amount) external nonReentrant {\n        _decrementDebt(amount, \"ReserveComptroller: insufficient debt\");\n\n        uint256 proceedAmount = _toUsdcAmount(amount);\n\n        _transferFrom(registry().dollar(), msg.sender, address(this), amount);\n        _burnDollar(amount);\n        _redeemVault(proceedAmount);\n        _transfer(registry().usdc(), msg.sender, proceedAmount);\n\n        emit Settle(msg.sender, amount, proceedAmount);\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Mints `amount` ESD to `account`\n     * @dev Internal only\n     * @param account Account to receive minted ESD\n     * @param amount Amount of ESD to mint\n     */\n    function _mintDollar(address account, uint256 amount) internal {\n        address dollar = registry().dollar();\n\n        IManagedToken(dollar).mint(amount);\n        IERC20(dollar).safeTransfer(account, amount);\n    }\n\n    /**\n     * @notice Burns `amount` ESD held by the reserve\n     * @dev Internal only\n     * @param amount Amount of ESD to burn\n     */\n    function _burnDollar(uint256 amount) internal {\n        IManagedToken(r"
    }
  ]
}