{
  "Title": "Using a cached price in the critical shutdownMarket()",
  "Content": "# Using a cached price in the critical shutdownMarket()\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L36\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L36</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L37\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L37</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L44\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L44</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L99\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L99</a>\n\n\n## Summary\n\nThe `MarketShutdownFacet::shutdownMarket()` is a critical function allowing anyone to freeze the market permanently. The function determines whether or not the market will be frozen based on the asset collateral ratio calculated from a cached price, which can be outdated (too risky for this critical function). \n\nOnce the market is frozen, no one can unfreeze it.\n\n## Vulnerability Details\n\nThe `shutdownMarket()` allows anyone to call to [freeze the market permanently](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L44) when the [asset collateral ratio threshold (default of 1.1 ether) has been reached](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L37). Once the market is frozen, all shorters will lose access to their positions. Even the protocol's DAO or admin cannot unfreeze the market. Therefore, the `shutdownMarket()` becomes one of the most critical functions.\n\nTo calculate the asset collateral ratio (`cRatio`), the `shutdownMarket()` executes the [`_getAssetCollateralRatio()`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L36). However, the `_getAssetCollateralRatio()` calculates the `cRatio` using the [cached price loaded from the `LibOracle::getPrice()`](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L99).\n\nUsing the cached price in a critical function like `shutdownMarket()` is too risky, as the cached price can be outdated. The function should consider only a fresh price queried from Chainlink.\n\n```solidity\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n@>      uint256 cRatio = _getAssetCollateralRatio(asset);\n@>      if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n@>          Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    ...\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n@>      return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n```\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L36\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L37\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L44\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarketShutdownFacet.sol#L99\n\n## Impact\n\nUsing the cached price in a critical function like `shutdownMarket()` is too risky, as the cached price can be outdated. \n\nOnce the market is frozen, all shorters will lose access to their positions. Even the protocol's DAO or admin cannot unfreeze the market.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nThe `shutdownMarket()` requires the most accurate price, not just a cached price. Execute the `LibOracle::getOraclePrice()` to get the accurate price from Chainlink.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n        return Asset.zethCollateral.div(LibOracle.getPrice(asset).mul(Asset.ercDebt));\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarketShutdownFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {F, STypes} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarketShutdownFacet is Modifiers {\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    /**\n     * @notice Freezes the market permanently when c-ratio threshold reached\n     * @dev Market is closed and shorters lose access to their positions\n     * @dev Excess collateral when c-ratio > 1 sent to TAPP\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function shutdownMarket(address asset)\n        external\n        onlyValidAsset(asset)\n        isNotFrozen(asset)\n        nonReentrant\n    {\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        if (cRatio > LibAsset.minimumCR(asset)) {\n            revert Errors.SufficientCollateral();\n        } else {\n            STypes.Asset storage Asset = s.asset[asset];\n            uint256 vault = Asset.vault;\n            uint88 assetZethCollateral = Asset.zethCollateral;\n            s.vault[vault].zethCollateral -= assetZethCollateral;\n            Asset.frozen = F.Permanent;\n            if (cRatio > 1 ether) {\n                // More than enough collateral to redeem ERC 1:1, send extras to TAPP\n                uint88 excessZeth =\n                    assetZethCollateral - assetZethCollateral.divU88(cRatio);\n                s.vaultUser[vault][address(this)].ethEscrowed += excessZeth;\n                // Reduces c-ratio to 1\n                Asset.zethCollateral -= excessZeth;\n            }\n        }\n        emit Events.ShutdownMarket(asset);\n    }\n\n    /**\n     * @notice Allows user to redeem erc from their wallet and/or escrow at the oracle price of market shutdown\n     * @dev Market must be permanently frozen, redemptions drawn from the combined collateral of all short records\n     *\n     * @param asset The market that will be impacted\n     */\n\n    function redeemErc(address asset, uint88 amtWallet, uint88 amtEscrow)\n        external\n        isPermanentlyFrozen(asset)\n        nonReentrant\n    {\n        if (amtWallet > 0) {\n            asset.burnMsgSenderDebt(amtWallet);\n        }\n\n        if (amtEscrow > 0) {\n            s.assetUser[asset][msg.sender].ercEscrowed -= amtEscrow;\n        }\n\n        uint88 amtErc = amtWallet + amtEscrow;\n        uint256 cRatio = _getAssetCollateralRatio(asset);\n        // Discount redemption when asset is undercollateralized\n        uint88 amtZeth = amtErc.mulU88(LibOracle.getPrice(asset)).mulU88(cRatio);\n        s.vaultUser[s.asset[asset].vault][msg.sender].ethEscrowed += amtZeth;\n        emit Events.RedeemErc(asset, msg.sender, amtWallet, amtEscrow);\n    }\n\n    /**\n     * @notice Computes the c-ratio of an asset class\n     *\n     * @param asset The market that will be impacted\n     *\n     * @return cRatio\n     */\n\n    function _getAssetCollateralRatio(address asset)\n        private\n        view\n        returns (uint256 cRatio)\n    {\n        STypes.Asset storage As"
    }
  ]
}