{
  "Title": "[M-06] Off-by-one bug prevents the `_compareMinMax()` from detecting Chainlink aggregators' circuit-breaking events",
  "Content": "\nThe `WiseLending` protocol implements the `OracleHelper::_compareMinMax()` to detect the circuit-breaking events of Chainlink aggregators when an asset price goes outside of pre-determined min/max values. For instance, in case of a significant price drop (e.g., LUNA crash), the asset price reported by the Chainlink price feed will continue to be at the pre-determined `minAnswer` instead of the actual price.\n\nThe `_compareMinMax()`'s objective is to prevent such a crash event that would allow a user to borrow other assets with the wrongly reported asset price. For more, refer to the case of [Venus Protocol and Blizz Finance in the crash of LUNA](https://rekt.news/venus-blizz-rekt/).\n\nHowever, the current implementation of the `_compareMinMax()` got an off-by-one bug that would prevent the function from detecting the mentioned Chainlink aggregators' circuit-breaking events. In other words, the function will not revert the transaction if the flash crash event occurs as expected.\n\n### Proof of Concept\n\nIn the flash crash event, the Chainlink price feed will continue to return the `_answer` at the pre-determined `minAnswer` instead of the actual price.  In other words, the possible minimum value of the `_answer` would be `minAnswer`.\n\nSince the `_compareMinMax()` does not include the case of [`_answer == minAnswer`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L97) (also, `_answer` `==` `maxAnswer`), the function could not detect whether or not the crash event happens.\n\n```solidity\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n@>      if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n```\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L97>\n\n### Recommended Mitigation Steps\n\nAdd the cases `_answer` `==` `minAnswer` and `_answer` `==` `maxAnswer` like the snippet below:\n\n```diff\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n-       if (_answer > maxAnswer || _answer < minAnswer) {\n+       if (_answer >= maxAnswer || _answer <= minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n```\n\n### Assessed type\n\nOracle\n\n**[Trust (judge) decreased severity to Low](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2021143688)**\n\n**[serial-coder (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2022567278):**\n > @Trust - This is a valid medium issue as the `_compareMinMax()` was implemented incorrectly.\n> \n> Specifically, the `_compareMinMax()` does not include the edge cases **`_answer` `==` `minAnswer`** and **`_answer` `==` `maxAnswer`**. So, the function cannot detect the `minAnswer` or `maxAnswer` as expected.\n> \n> To elaborate, for example, the `minAnswer` the aggregator can report for the `LINK` (one of the tokens in scope) is [100000000000000](https://etherscan.io/address/0xbba12740DE905707251525477bAD74985DeC46D2#readContract#F19) (`10 ** 14`). Suppose, in the event of a flash crash, the price of the `LINK` token drops significantly below the `minAnswer` (below `10 ** 14`).\n> \n> However, the price feed will continue to report the pre-determined `minAnswer` (not the actual price). Since the `_compareMinMax()` does not include the case `_answer` `==` `minAnswer`, it cannot detect this flash crash event.\n> \n> In other words, the least reported price (i.e., `_answer`) will be the pre-determined `minAnswer`, not the actual price. Thus, the `_compareMinMax()` will never enter the [`if case` and revert the transaction](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L98) as expected because the `_answer` will never be less than the aggregator's `minAnswer`.\n> \n> ```solidity\n>     function _compareMinMax(\n>         IAggregator _tokenAggregator,\n>         int192 _answer\n>     )\n>         internal\n>         view\n>     {\n>         int192 maxAnswer = _tokenAggregator.maxAnswer();\n>         int192 minAnswer = _tokenAggregator.minAnswer();\n> \n> @>      if (_answer > maxAnswer || _answer < minAnswer) { //@audit -- The least reported price (i.e., `_answer`) will be the `minAnswer`. So, the function will never enter the \" if \" case\n>             revert OracleIsDead();\n>         }\n>     }\n> ```\n> \n> An example reference is [here](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18). As you can see, their recommendation includes the edge cases `_answer` `==` `minAnswer` and `_answer` `==` `maxAnswer`.\n> \n> *Note: to view the provided image, please see the original comment [here](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2022567278).*\n> \n> **Further on the TWAP Oracle:** \n> \n> Someone may argue that the protocol has the TWAP. \n> \n> I want to point out that the [TWAP setup for each price feed is only optional](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L144-L148). If the TWAP is not set, the price deviation comparison mechanism between the TWAP's price and Chainlink's price [will not be triggered](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L161-L171). For this reason, this issue deserves a Medium severity.\n\n**[Trust (judge) increased severity to Medium and commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2022731180):**\n > The impact demonstrated is an incorrect validation check, which in the case `maxAnswer/minAnswer` are used by the feed, will make detecting black swans fail. As the team assumes those protections are in place, Medium severity is appropriate.\n\n**[00xSEV (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2024357910):**\n > @Trust - Could you double-check that it's a valid issue? If we follow the link from the [Chainlink docs](https://docs.chain.link/data-feeds#monitoring-data-feeds) and check the code [here](https://github.com/smartcontractkit/libocr/blob/9e4afd8896f365b964bdf769ca28f373a3fb0300/contract/OffchainAggregator.sol#L68-L69) and [here](https://github.com/smartcontractkit/libocr/blob/9e4afd8896f365b964bdf769ca28f373a3fb0300/contract/OffchainAggregator.sol#L640):\n>\n> ```solidity\n>    * @param _minAnswer lowest answer the median of a report is allowed to be\n>    * @param _maxAnswer highest answer the median of a report is allowed to be\n> ```\n> \n> ```solidity\n> require(minAnswer <= median && median <= maxAnswer, \"median is out of min-max range\");\n> ```\n> \n> It means that if `median == minAnswer` or `median == maxAnswer` it still a valid value and we don't have to revert.\n\n**[serial-coder (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2024368780):**\n > @00xSEV - The least reported price will be the pre-determined `minAnswer`. If you do not include the case `==`, the `_compareMinMax()` will never enter the [`if case` and revert the transaction](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseOracleHub/OracleHelper.sol#L98). You cannot detect the black swan events without it.\n> \n> The reported price will never be less than the `minAnswer`. (Without the `==`, the `if` condition will always be `false`).\n> \n> ```solidity\n>     function _compareMinMax(\n>         IAggregator _tokenAggregator,\n>         int192 _answer\n>     )\n>         internal\n>         view\n>     {\n>         int192 maxAnswer = _tokenAggregator.maxAnswer();\n>         int192 minAnswer = _tokenAggregator.minAnswer();\n> \n> @>      if (_answer > maxAnswer || _answer < minAnswer) { //@audit -- The least reported price (i.e., `_answer`) will be the `minAnswer`. So, the function will never enter the \" if \" case\n>             revert OracleIsDead();\n>         }\n>     }\n> ```\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/251#issuecomment-2082910582):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregator()\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            revert AggregatorAlreadySet();\n        }\n\n        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n            revert FunctionDoesntExist();\n        }\n\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            revert AggregatorNotNecessary();\n        }\n\n        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n    }\n\n    function _checkFunctionExistence(\n        address _tokenAggregator\n    )\n        internal\n        returns (bool)\n    {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(\n                _tokenAggregator\n            )\n        }\n\n        if (size == 0) {\n            return false;\n        }\n\n        (bool success, ) = _tokenAggregator.call(\n            abi.encodeWithSignature(\n                \"maxAnswer()\"\n            )\n        );\n\n        return success;\n    }\n\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n        if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n\n    /**\n     * @dev Returns Twaps latest USD value\n     * by passing the underlying token address.\n     */\n    function latestResolverTwap(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.isUniPool == true) {\n\n            return _getTwapPrice(\n                _tokenAddress,\n                uniTwapPoolInfoStruct.oracle\n            ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n        }\n\n        return _getTwapDerivatePrice(\n            _tokenAddress,\n            uniTwapPoolInfoStruct\n        ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n    }\n\n    function _validateAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        uint256 fetchTwapValue;\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            fetchTwapValue = latestResolverTwap(\n                _tokenAddress\n            );\n        }\n\n        uint256 answer = _getChainlinkAnswer(\n            _tokenAddress\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            _compareMinMax(\n                tokenAggregatorFromTokenAddress[_tokenAddress],\n                int192(uint192(answer))\n            );\n        }\n\n        if (fetchTwapValue > 0) {\n\n            uint256 relativeDifference = _getRelativeDifference(\n                answer,\n                fetchTwapValue\n            );\n\n            _compareDifference(\n                relativeDifference\n            );\n        }\n\n        return answer;\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token.\n     */\n    function _writeUniTwapPoolInfoStruct(\n        address _tokenAddress,\n        address _oracle,\n        bool _isUniPool\n    )\n        internal\n    {\n        uniTwapPoolInfo[_tokenAddress] = UniTwapPoolInfo({\n            oracle: _oracle,\n            isUniPool: _isUniPool\n        });\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token and its derivative.\n     */\n    function _writeUniTwapPoolInfoStructDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address _oracleAddress,\n        address _partnerOracleAddress,\n        bool _isUniPool\n    )\n        internal\n    {\n        _writeUniTwapPoolInfoStruct(\n            _tokenAddress,\n            _oracleAddress,\n            _isUniPool\n        );\n\n        derivativePartnerTwap[_tokenAddress] = DerivativePartnerInfo(\n            _partnerTokenAddress,\n            _partnerOracleAddress\n        );\n    }\n\n    function _getRelativeDifference(\n        uint256 _answerUint256,\n        uint256 _fetchTwapValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_answerUint256 > _fetchTwapValue) {\n            return _answerUint256\n                * PRECISION_FACTOR_E4\n                / _fetchTwapValue;\n        }\n\n        return _fetchTwapValue\n            * PRECISION_FACTOR_E4\n            / _answerUint256;\n    }\n\n    function _compareDifference(\n        uint256 _relativeDifference\n    )\n        internal\n        view\n    {\n        if (_relativeDifference > ALLOWED_DIFFERENCE) {\n            revert OraclesDeviate();\n        }\n    }\n\n    function _getChainlinkAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            int256 answer,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n\n        return uint256(\n            answer\n        );\n    }\n\n    function getETHPriceInUSD()\n        public\n        view\n        returns (uint256)\n    {\n        if (_chainLinkIsDead(ETH_USD_PLACEHOLDER) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n    * @dev Retrieves the pool address for given\n    * tokens and fee from Uniswap V3 Factory.\n    */\n    function _getPool(\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        internal\n        view\n        returns (address pool)\n    {\n        return UNI_V3_FACTORY.getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n    }\n\n    /**\n    * @dev Validates if the given token address\n    * is one of the two specified token addresses.\n    */\n    function _validateTokenAddress(\n        address _tokenAddress,\n        address _token0,\n        address _token1\n    )\n        internal\n        pure\n    {\n        if (_tokenAddress == ZERO_ADDRESS) {\n            revert ZeroAddressNotAllowed();\n        }\n\n        if (_tokenAddress != _token0 && _tokenAddress != _token1) {\n            revert TokenAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the given pool\n    * address matches the expected pool address.\n    */\n    function _validatePoolAddress(\n        address _pool,\n        address _expectedPool\n    )\n        internal\n        pure\n    {\n        if (_pool == ZERO_ADDRESS) {\n            revert PoolDoesNotExist();\n        }\n\n        if (_pool != _expectedPool) {\n            revert PoolAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the price feed for\n    * a given token address is set.\n    */\n    function _validatePriceFeed(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\n            revert ChainLinkOracleNotSet();\n        }\n    }\n\n    /**\n    * @dev Validates if the TWAP oracle for\n    * a given token address is already set.\n    */\n    function _validateTwapOracle(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n            revert TwapOracleAlreadySet();\n        }\n    }\n\n    /**\n     * @dev Returns twapPrice by passing\n     * the underlying token address.\n     */\n    function _getTwapPrice(\n        address _tokenAddress,\n        address _oracle\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _oracle\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            WETH_ADDRESS\n        );\n    }\n\n    function _getOneUnit(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint128)\n    {\n        return uint128(\n            10 ** _tokenDecimals[_tokenAddress]\n        );\n    }\n\n    function _getAverageTick(\n        address _oracle\n    )\n        internal\n        view\n        returns (int24)\n    {\n        uint32[] memory secondsAgo = new uint32[](\n            2\n        );\n\n        secondsAgo[0] = TWAP_PERIOD;\n        secondsAgo[1] = 0;\n\n        (\n            int56[] memory tickCumulatives\n            ,\n        ) = IUniswapV3Pool(_oracle).observe(\n            secondsAgo\n        );\n\n        int56 twapPeriodInt56 = int56(\n            int32(TWAP_PERIOD)\n        );\n\n        int56 tickCumulativesDelta = tickCumulatives[1]\n            - tickCumulatives[0];\n\n        int24 tick = int24(\n            tickCumulativesDelta\n            / twapPeriodInt56\n        );\n\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % twapPeriodInt56 != 0)) {\n            tick--;\n        }\n\n        return tick;\n    }\n\n    /**\n     * @dev Returns priceFeed decimals by\n     * passing the underlying token address.\n     */\n    function decimals(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint8)\n    {\n        return priceFeed[_tokenAddress].decimals();\n    }\n\n    function _getTwapDerivatePrice(\n        address _tokenAddress,\n        UniTwapPoolInfo memory _uniTwapPoolInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        DerivativePartnerInfo memory partnerInfo = derivativePartnerTwap[\n            _tokenAddress\n        ];\n\n        uint256 firstQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _uniTwapPoolInfo.oracle\n            ),\n            _getOneUnit(\n                partnerInfo.partnerTokenAddress\n            ),\n            partnerInfo.partnerTokenAddress,\n            WETH_ADDRESS\n        );\n\n        uint256 secondQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                partnerInfo.partnerOracleAddress\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            partnerInfo.partnerTokenAddress\n        );\n\n        return firstQuote\n            * secondQuote\n            / uint256(\n                _getOneUnit(\n                    partnerInfo.partnerTokenAddress\n                )\n            );\n    }\n\n    /**\n     * @dev Stores expected heartbeat\n     * value for a pricing feed token.\n     */\n    function _recalibrate(\n        address _tokenAddress\n    )\n        internal\n    {\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink\n     * squencer is wroking.\n     */\n    function sequencerIsDead()\n        public\n        view\n        returns (bool)\n    {\n        if (IS_ARBITRUM_CHAIN == false) {\n            return false;\n        }\n\n        (\n            ,\n            int256 answer,\n            uint256 startedAt,\n            ,\n        ) = SEQUENCER.latestRoundData();\n\n        if (answer == 1) {\n            return true;\n        }\n\n        uint256 timeSinceUp = block.timestamp\n            - startedAt;\n\n        if (timeSinceUp <= GRACE_PEROID) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame\n     * for single {_tokenAddress}.\n     */\n    function _chainLinkIsDead(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // @TODO: Add a check for TWAP comparison on 2.5%\n        // if TWAP exists for the token.\n\n        if (heartBeat[_tokenAddress] == 0) {\n            revert HeartBeatNotSet();\n        }\n\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 upd = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        unchecked {\n            upd = block.timestamp < upd\n                ? block.timestamp\n                : block.timestamp - upd;\n\n            return upd > heartBeat[_tokenAddress];\n        }\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function _recalibratePreview(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestRoundId\n        );\n\n        if (iterationCount < MIN_ITERATION_COUNT) {\n            revert SampleTooSmall(\n                {\n                    size: iterationCount\n                }\n            );\n        }\n\n        uint80 i = 1;\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        while (i < iterationCount) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _tokenAddress,\n                latestRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff >= currentBiggest) {\n\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n\n            } else if (currentDiff > currentSecondBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations\n     * needed during heartbeat recalibration.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80 res)\n    {\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n            ? _latestAggregatorRoundId\n            : MAX_ROUND_COUNT;\n    }\n\n    /**\n     * @dev Fetches timestamp of a byteshifted\n     * aggregatorRound with specific _roundId.\n     */\n    function _getRoundTimestamp(\n        address _tokenAddress,\n        uint80 _roundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp\n            ,\n        ) = priceFeed[_tokenAddress].getRoundData(\n                _roundId\n            );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Routing latest round data from chainLink.\n     * Returns latestRoundData by passing underlying token address.\n     */\n    function getLatestRoundId(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (\n            uint80 roundId\n        )\n    {\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregator()\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            revert AggregatorAlreadySet();\n        }\n\n        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n            revert FunctionDoesntExist();\n        }\n\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            revert AggregatorNotNecessary();\n        }\n\n        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n    }\n\n    function _checkFunctionExistence(\n        address _tokenAggregator\n    )\n        internal\n        returns (bool)\n    {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(\n                _tokenAggregator\n            )\n        }\n\n        if (size == 0) {\n            return false;\n        }\n\n        (bool success, ) = _tokenAggregator.call(\n            abi.encodeWithSignature(\n                \"maxAnswer()\"\n            )\n        );\n\n        return success;\n    }\n\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n        if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n\n    /**\n     * @dev Returns Twaps latest USD value\n     * by passing the underlying token address.\n     */\n    function latestResolverTwap(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.isUniPool == true) {\n\n            return _getTwapPrice(\n                _tokenAddress,\n                uniTwapPoolInfoStruct.oracle\n            ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n        }\n\n        return _getTwapDerivatePrice(\n            _tokenAddress,\n            uniTwapPoolInfoStruct\n        ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n    }\n\n    function _validateAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        uint256 fetchTwapValue;\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            fetchTwapValue = latestResolverTwap(\n                _tokenAddress\n            );\n        }\n\n        uint256 answer = _getChainlinkAnswer(\n            _tokenAddress\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            _compareMinMax(\n                tokenAggregatorFromTokenAddress[_tokenAddress],\n                int192(uint192(answer))\n            );\n        }\n\n        if (fetchTwapValue > 0) {\n\n            uint256 relativeDifference = _getRelativeDifference(\n                answer,\n                fetchTwapValue\n            );\n\n            _compareDifference(\n                relativeDifference\n            );\n        }\n\n        return answer;\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token.\n     */\n    function _writeUniTwapPoolInfoStruct(\n        address _tokenAddress,\n        address _oracle,\n        bool _isUniPool\n    )\n        internal\n    {\n        uniTwapPoolInfo[_tokenAddress] = UniTwapPoolInfo({\n            oracle: _oracle,\n            isUniPool: _isUniPool\n        });\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token and its derivative.\n     */\n    function _writeUniTwapPoolInfoStructDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address _oracleAddress,\n        address _partnerOracleAddress,\n        bool _isUniPool\n    )\n        internal\n    {\n        _writeUniTwapPoolInfoStruct(\n            _tokenAddress,\n            _oracleAddress,\n            _isUniPool\n        );\n\n        derivativePartnerTwap[_tokenAddress] = DerivativePartnerInfo(\n            _partnerTokenAddress,\n            _partnerOracleAddress\n        );\n    }\n\n    function _getRelativeDifference(\n        uint256 _answerUint256,\n        uint256 _fetchTwapValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_answerUint256 > _fetchTwapValue) {\n            return _answerUint256\n                * PRECISION_FACTOR_E4\n                / _fetchTwapValue;\n        }\n\n        return _fetchTwapValue\n            * PRECISION_FACTOR_E4\n            / _answerUint256;\n    }\n\n    function _compareDifference(\n        uint256 _relativeDifference\n    )\n        internal\n        view\n    {\n        if (_relativeDifference > ALLOWED_DIFFERENCE) {\n            revert OraclesDeviate();\n        }\n    }\n\n    function _getChainlinkAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            int256 answer,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n\n        return uint256(\n            answer\n        );\n    }\n\n    function getETHPriceInUSD()\n        public\n        view\n        returns (uint256)\n    {\n        if (_chainLinkIsDead(ETH_USD_PLACEHOLDER) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n    * @dev Retrieves the pool address for given\n    * tokens and fee from Uniswap V3 Factory.\n    */\n    function _getPool(\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        internal\n        view\n        returns (address pool)\n    {\n        return UNI_V3_FACTORY.getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n    }\n\n    /**\n    * @dev Validates if the given token address\n    * is one of the two specified token addresses.\n    */\n    function _validateTokenAddress(\n        address _tokenAddress,\n        address _token0,\n        address _token1\n    )\n        internal\n        pure\n    {\n        if (_tokenAddress == ZERO_ADDRESS) {\n            revert ZeroAddressNotAllowed();\n        }\n\n        if (_tokenAddress != _token0 && _tokenAddress != _token1) {\n            revert TokenAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the given pool\n    * address matches the expected pool address.\n    */\n    function _validatePoolAddress(\n        address _pool,\n        address _expectedPool\n    )\n        internal\n        pure\n    {\n        if (_pool == ZERO_ADDRESS) {\n            revert PoolDoesNotExist();\n        }\n\n        if (_pool != _expectedPool) {\n            revert PoolAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the price feed for\n    * a given token address is set.\n    */\n    function _validatePriceFeed(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\n            revert ChainLinkOracleNotSet();\n        }\n    }\n\n    /**\n    * @dev Validates if the TWAP oracle for\n    * a given token address is already set.\n    */\n    function _validateTwapOracle(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n            revert TwapOracleAlreadySet();\n        }\n    }\n\n    /**\n     * @dev Returns twapPrice by passing\n     * the underlying token address.\n     */\n    function _getTwapPrice(\n        address _tokenAddress,\n        address _oracle\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _oracle\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            WETH_ADDRESS\n        );\n    }\n\n    function _getOneUnit(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint128)\n    {\n        return uint128(\n            10 ** _tokenDecimals[_tokenAddress]\n        );\n    }\n\n    function _getAverageTick(\n        address _oracle\n    )\n        internal\n        view\n        returns (int24)\n    {\n        uint32[] memory secondsAgo = new uint32[](\n            2\n        );\n\n        secondsAgo[0] = TWAP_PERIOD;\n        secondsAgo[1] = 0;\n\n        (\n            int56[] memory tickCumulatives\n            ,\n        ) = IUniswapV3Pool(_oracle).observe(\n            secondsAgo\n        );\n\n        int56 twapPeriodInt56 = int56(\n            int32(TWAP_PERIOD)\n        );\n\n        int56 tickCumulativesDelta = tickCumulatives[1]\n            - tickCumulatives[0];\n\n        int24 tick = int24(\n            tickCumulativesDelta\n            / twapPeriodInt56\n        );\n\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % twapPeriodInt56 != 0)) {\n            tick--;\n        }\n\n        return tick;\n    }\n\n    /**\n     * @dev Returns priceFeed decimals by\n     * passing the underlying token address.\n     */\n    function decimals(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint8)\n    {\n        return priceFeed[_tokenAddress].decimals();\n    }\n\n    function _getTwapDerivatePrice(\n        address _tokenAddress,\n        UniTwapPoolInfo memory _uniTwapPoolInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        DerivativePartnerInfo memory partnerInfo = derivativePartnerTwap[\n            _tokenAddress\n        ];\n\n        uint256 firstQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _uniTwapPoolInfo.oracle\n            ),\n            _getOneUnit(\n                partnerInfo.partnerTokenAddress\n            ),\n            partnerInfo.partnerTokenAddress,\n            WETH_ADDRESS\n        );\n\n        uint256 secondQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                partnerInfo.partnerOracleAddress\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            partnerInfo.partnerTokenAddress\n        );\n\n        return firstQuote\n            * secondQuote\n            / uint256(\n                _getOneUnit(\n                    partnerInfo.partnerTokenAddress\n                )\n            );\n    }\n\n    /**\n     * @dev Stores expected heartbeat\n     * value for a pricing feed token.\n     */\n    function _recalibrate(\n        address _tokenAddress\n    )\n        internal\n    {\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink\n     * squencer is wroking.\n     */\n    function sequencerIsDead()\n        public\n        view\n        returns (bool)\n    {\n        if (IS_ARBITRUM_CHAIN == false) {\n            return false;\n        }\n\n        (\n            ,\n            int256 answer,\n            uint256 startedAt,\n            ,\n        ) = SEQUENCER.latestRoundData();\n\n        if (answer == 1) {\n            return true;\n        }\n\n        uint256 timeSinceUp = block.timestamp\n            - startedAt;\n\n        if (timeSinceUp <= GRACE_PEROID) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame\n     * for single {_tokenAddress}.\n     */\n    function _chainLinkIsDead(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // @TODO: Add a check for TWAP comparison on 2.5%\n        // if TWAP exists for the token.\n\n        if (heartBeat[_tokenAddress] == 0) {\n            revert HeartBeatNotSet();\n        }\n\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 upd = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        unchecked {\n            upd = block.timestamp < upd\n                ? block.timestamp\n                : block.timestamp - upd;\n\n            return upd > heartBeat[_tokenAddress];\n        }\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function _recalibratePreview(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestRoundId\n        );\n\n        if (iterationCount < MIN_ITERATION_COUNT) {\n            revert SampleTooSmall(\n                {\n                    size: iterationCount\n                }\n            );\n        }\n\n        uint80 i = 1;\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        while (i < iterationCount) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _tokenAddress,\n                latestRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff >= currentBiggest) {\n\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n\n            } else if (currentDiff > currentSecondBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations\n     * needed during heartbeat recalibration.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80 res)\n    {\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n            ? _latestAggregatorRoundId\n            : MAX_ROUND_COUNT;\n    }\n\n    /**\n     * @dev Fetches timestamp of a byteshifted\n     * aggregatorRound with specific _roundId.\n     */\n    function _getRoundTimestamp(\n        address _tokenAddress,\n        uint80 _roundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp\n            ,\n        ) = priceFeed[_tokenAddress].getRoundData(\n                _roundId\n            );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Routing latest round data from chainLink.\n     * Returns latestRoundData by passing underlying token address.\n     */\n    function getLatestRoundId(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (\n            uint80 roundId\n        )\n    {\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregato"
    }
  ]
}