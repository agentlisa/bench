{
  "Title": "M-2: Funding#requestWithdraw uses incorrect withdraw address",
  "Content": "# Issue M-2: Funding#requestWithdraw uses incorrect withdraw address \n\nSource: https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/53 \n\n## Found by \n0x52, FastTiger, OrderSol, Varun\\_05, bughuntoor, dany.armstrong90\n## Summary\n\nWhen requesting a withdraw, `msg.sender` is used in place of the `from` address. This means that withdraws cannot be initiated on behalf of other users. This will break integrations that depend on this functionality leading to irretrievable funds.\n\n## Vulnerability Detail\n\n[Funding.sol#L69-L82](https://github.com/sherlock-audit/2023-12-jojo-exchange-update/blob/main/smart-contract-EVM/src/libraries/Funding.sol#L69-L82)\n\n    function requestWithdraw(\n        Types.State storage state,\n        address from,\n        uint256 primaryAmount,\n        uint256 secondaryAmount\n    )\n        external\n    {\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        state.pendingPrimaryWithdraw[msg.sender] = primaryAmount;\n        state.pendingSecondaryWithdraw[msg.sender] = secondaryAmount;\n        state.withdrawExecutionTimestamp[msg.sender] = block.timestamp + state.withdrawTimeLock;\n        emit RequestWithdraw(msg.sender, primaryAmount, secondaryAmount, state.withdrawExecutionTimestamp[msg.sender]);\n    }\n\nAs shown above the withdraw is accidentally queue to `msg.sender` NOT the `from` address. This means that all withdraws started on behalf of another user will actually trigger a withdraw from the `operator`. The result is that withdraw cannot be initiated on behalf of other users, even if the allowance is set properly, leading to irretrievable funds\n\n## Impact\n\nRequesting withdraws for other users is broken and strands funds\n\n## Code Snippet\n\n[Funding.sol#L69-L82](https://github.com/sherlock-audit/2023-12-jojo-exchange-update/blob/main/smart-contract-EVM/src/libraries/Funding.sol#L69-L82)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange all occurrences of `msg.sender` in stage changes to `from` instead.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { This is valid and a dupp of 082 with minimal impact}\n\n\n\n**detectiveking123**\n\n@nevillehuang do you believe this has enough impact to be considered valid?\n\n**JoscelynFarr**\n\nFixed PR: https://github.com/JOJOexchange/smart-contract-EVM/commit/82b5c85c9999ace00265382e7d1bc83036685069\n\n**IAm0x52**\n\nFix looks good. Now uses from instead of msg.sender\n\n**nevillehuang**\n\n@detectiveking123 @JoscelynFarr https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/30#issuecomment-1927840325\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/136",
  "Code": [
    {
      "filename": "smart-contract-EVM/src/libraries/Funding.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/internal/IPriceSource.sol\";\nimport \"../interfaces/IPerpetual.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/SignedDecimalMath.sol\";\nimport \"./Liquidation.sol\";\nimport \"./Operation.sol\";\nimport \"./Types.sol\";\n\nlibrary Funding {\n    using SafeERC20 for IERC20;\n\n    // ========== events ==========\n\n    event Deposit(address indexed to, address indexed payer, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event Withdraw(address indexed to, address indexed payer, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event RequestWithdraw(\n        address indexed payer, uint256 primaryAmount, uint256 secondaryAmount, uint256 executionTimestamp\n    );\n\n    event TransferIn(address trader, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event TransferOut(address trader, uint256 primaryAmount, uint256 secondaryAmount);\n\n    // ========== deposit ==========\n\n    function deposit(Types.State storage state, uint256 primaryAmount, uint256 secondaryAmount, address to) external {\n        if (primaryAmount > 0) {\n            IERC20(state.primaryAsset).safeTransferFrom(msg.sender, address(this), primaryAmount);\n            state.primaryCredit[to] += SafeCast.toInt256(primaryAmount);\n        }\n        if (secondaryAmount > 0) {\n            IERC20(state.secondaryAsset).safeTransferFrom(msg.sender, address(this), secondaryAmount);\n            state.secondaryCredit[to] += secondaryAmount;\n        }\n        emit Deposit(to, msg.sender, primaryAmount, secondaryAmount);\n    }\n\n    // ========== withdraw ==========\n\n    function isWithdrawValid(\n        Types.State storage state,\n        address spender,\n        address from,\n        uint256 primaryAmount,\n        uint256 secondaryAmount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return spender == from\n            || (\n                state.primaryCreditAllowed[from][spender] >= primaryAmount\n                    && state.secondaryCreditAllowed[from][spender] >= secondaryAmount\n            );\n    }\n\n    function requestWithdraw(\n        Types.State storage state,\n        address from,\n        uint256 primaryAmount,\n        uint256 secondaryAmount\n    )\n        external\n    {\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        state.pendingPrimaryWithdraw[msg.sender] = primaryAmount;\n        state.pendingSecondaryWithdraw[msg.sender] = secondaryAmount;\n        state.withdrawExecutionTimestamp[msg.sender] = block.timestamp + state.withdrawTimeLock;\n        emit RequestWithdraw(msg.sender, primaryAmount, secondaryAmount, state.withdrawExecutionTimestamp[msg.sender]);\n    }\n\n    function executeWithdraw(\n        Types.State storage state,\n        address from,\n        address to,\n        bool isInternal,\n        bytes memory param\n    )\n        external\n    {\n        require(state.withdrawExecutionTimestamp[from] <= block.timestamp, Errors.WITHDRAW_PENDING);\n        uint256 primaryAmount = state.pendingPrimaryWithdraw[from];\n        uint256 secondaryAmount = state.pendingSecondaryWithdraw[from];\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        state.pendingPrimaryWithdraw[from] = 0;\n        state.pendingSecondaryWithdraw[from] = 0;\n        // No need to change withdrawExecutionTimestamp, because we set pending\n        // withdraw amount to 0.\n        _withdraw(state, msg.sender, from, to, primaryAmount, secondaryAmount, isInternal, param);\n    }\n\n    function fastWithdraw(\n        Types.State storage state,\n        address from,\n        address to,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isInternal,\n        bytes memory param\n    )\n        external\n    {\n        require(\n            !state.fastWithdrawDisabled || state.fastWithdrawalWhitelist[msg.sender], Errors.FAST_WITHDRAW_NOT_ALLOWED\n        );\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        _withdraw(state, msg.sender, from, to, primaryAmount, secondaryAmount, isInternal, param);\n    }\n\n    function _withdraw(\n        Types.State storage state,\n        address spender,\n        address from,\n        address to,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isInternal,\n        bytes memory param\n    )\n        private\n    {\n        if (spender != from) {\n            state.primaryCreditAllowed[from][spender] -= primaryAmount;\n            state.secondaryCreditAllowed[from][spender] -= secondaryAmount;\n            emit Operation.FundOperatorAllowedChange(\n                from, spender, state.primaryCreditAllowed[from][spender], state.secondaryCreditAllowed[from][spender]\n            );\n        }\n        if (primaryAmount > 0) {\n            state.primaryCredit[from] -= SafeCast.toInt256(primaryAmount);\n            if (isInternal) {\n                state.primaryCredit[to] += SafeCast.toInt256(primaryAmount);\n            } else {\n                IERC20(state.primaryAsset).safeTransfer(to, primaryAmount);\n            }\n        }\n        if (secondaryAmount > 0) {\n            state.secondaryCredit[from] -= secondaryAmount;\n            if (isInternal) {\n                state.secondaryCredit[to] += secondaryAmount;\n            } else {\n                IERC20(state.secondaryAsset).safeTransfer(to, secondaryAmount);\n            }\n        }\n\n        if (primaryAmount > 0) {\n            // if trader withdraw primary asset, we should check if solid safe\n            require(Liquidation._isSolidIMSafe(state, from), Errors.ACCOUNT_NOT_SAFE);\n        } else {\n            // if trader didn't withdraw primary asset, normal safe check is enough\n            require(Liquidation._isIMSafe(state, from), Errors.ACCOUNT_NOT_SAFE);\n        }\n\n        if (isInternal) {\n            emit TransferIn(to, primaryAmount, secondaryAmount);\n            emit TransferOut(from, primaryAmount, secondaryAmount);\n        } else {\n            emit Withdraw(to, from, primaryAmount, secondaryAmount);\n        }\n\n        if (param.length != 0) {\n            require(Address.isContract(to), \"target is not a contract\");\n            (bool success,) = to.call(param);\n            if (success == false) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "smart-contract-EVM/src/libraries/Funding.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1\n*/\n\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/internal/IPriceSource.sol\";\nimport \"../interfaces/IPerpetual.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/SignedDecimalMath.sol\";\nimport \"./Liquidation.sol\";\nimport \"./Operation.sol\";\nimport \"./Types.sol\";\n\nlibrary Funding {\n    using SafeERC20 for IERC20;\n\n    // ========== events ==========\n\n    event Deposit(address indexed to, address indexed payer, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event Withdraw(address indexed to, address indexed payer, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event RequestWithdraw(\n        address indexed payer, uint256 primaryAmount, uint256 secondaryAmount, uint256 executionTimestamp\n    );\n\n    event TransferIn(address trader, uint256 primaryAmount, uint256 secondaryAmount);\n\n    event TransferOut(address trader, uint256 primaryAmount, uint256 secondaryAmount);\n\n    // ========== deposit ==========\n\n    function deposit(Types.State storage state, uint256 primaryAmount, uint256 secondaryAmount, address to) external {\n        if (primaryAmount > 0) {\n            IERC20(state.primaryAsset).safeTransferFrom(msg.sender, address(this), primaryAmount);\n            state.primaryCredit[to] += SafeCast.toInt256(primaryAmount);\n        }\n        if (secondaryAmount > 0) {\n            IERC20(state.secondaryAsset).safeTransferFrom(msg.sender, address(this), secondaryAmount);\n            state.secondaryCredit[to] += secondaryAmount;\n        }\n        emit Deposit(to, msg.sender, primaryAmount, secondaryAmount);\n    }\n\n    // ========== withdraw ==========\n\n    function isWithdrawValid(\n        Types.State storage state,\n        address spender,\n        address from,\n        uint256 primaryAmount,\n        uint256 secondaryAmount\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return spender == from\n            || (\n                state.primaryCreditAllowed[from][spender] >= primaryAmount\n                    && state.secondaryCreditAllowed[from][spender] >= secondaryAmount\n            );\n    }\n\n    function requestWithdraw(\n        Types.State storage state,\n        address from,\n        uint256 primaryAmount,\n        uint256 secondaryAmount\n    )\n        external\n    {\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        state.pendingPrimaryWithdraw[msg.sender] = primaryAmount;\n        state.pendingSecondaryWithdraw[msg.sender] = secondaryAmount;\n        state.withdrawExecutionTimestamp[msg.sender] = block.timestamp + state.withdrawTimeLock;\n        emit RequestWithdraw(msg.sender, primaryAmount, secondaryAmount, state.withdrawExecutionTimestamp[msg.sender]);\n    }\n\n    function executeWithdraw(\n        Types.State storage state,\n        address from,\n        address to,\n        bool isInternal,\n        bytes memory param\n    )\n        external\n    {\n        require(state.withdrawExecutionTimestamp[from] <= block.timestamp, Errors.WITHDRAW_PENDING);\n        uint256 primaryAmount = state.pendingPrimaryWithdraw[from];\n        uint256 secondaryAmount = state.pendingSecondaryWithdraw[from];\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        state.pendingPrimaryWithdraw[from] = 0;\n        state.pendingSecondaryWithdraw[from] = 0;\n        // No need to change withdrawExecutionTimestamp, because we set pending\n        // withdraw amount to 0.\n        _withdraw(state, msg.sender, from, to, primaryAmount, secondaryAmount, isInternal, param);\n    }\n\n    function fastWithdraw(\n        Types.State storage state,\n        address from,\n        address to,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isInternal,\n        bytes memory param\n    )\n        external\n    {\n        require(\n            !state.fastWithdrawDisabled || state.fastWithdrawalWhitelist[msg.sender], Errors.FAST_WITHDRAW_NOT_ALLOWED\n        );\n        require(isWithdrawValid(state, msg.sender, from, primaryAmount, secondaryAmount), Errors.WITHDRAW_INVALID);\n        _withdraw(state, msg.sender, from, to, primaryAmount, secondaryAmount, isInternal, param);\n    }\n\n    function _withdraw(\n        Types.State storage state,\n        address spender,\n        address from,\n        address to,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isInternal,\n        bytes memory param\n    )\n        private\n    {\n        if (spender != from) {\n            state.primaryCreditAllowed[from][spender] -= primaryAmount;\n            state.secondaryCreditAllowed[from][spender] -= secondaryAmount;\n            emit Operation.FundOperatorAllowedChange(\n                from, spender, state.primaryCreditAllowed[from][spender], state.secondaryCreditAllowed[from][spender]\n            );\n        }\n        if (primaryAmount > 0) {\n            state.primaryCredit[from] -= SafeCast.toInt256(primaryAmount);\n            if (isInternal) {\n                state.primaryCredit[to] += SafeCast.toInt256(primaryAmount);\n            } else {\n                IERC20(state.primaryAsset).safeTransfer(to, primaryAmount);\n            }\n        }\n        if (secondaryAmount > 0) {\n            state.secondaryCredit[from] -= secondaryAmount;\n            if (isInternal) {\n                state.secondaryCredit[to] += secondaryAmount;\n            } else {\n                IERC20(state.secondaryAsset).safeTransfer(to, secondaryAmount);\n            }\n        }\n\n        if (primaryAmount > 0) {\n            // if trader withdraw primary asset, we should check if solid safe\n            require(Liquidation._isSolidIMSafe(state, from), Errors.ACCOUNT_NOT_SAFE);\n        } else {\n            // if trader didn't withdraw primary asset, normal safe check is enough\n            require(Liquidation._isIMSafe(state, from), Errors.ACCOUNT_NOT_SAFE);\n        }\n\n        if (isInternal) {\n            emit TransferIn(to, primaryAmount, secondaryAmount);\n            emit TransferOut(from, primaryAmount, secondaryAmount);\n        } else {\n            emit Withdraw(to, from, primaryAmount, secondaryAmount);\n        }\n\n        if (param.length != 0) {\n            require(Address.isContract(to), \"target is not a contract\");\n            (bool success,) = to.call(param);\n            if (success == false) {\n                assembly {\n                    let ptr := mload(0x40)\n                    let size := returndatasize()\n                    returndatacopy(ptr, 0, size)\n                    revert(ptr, size)\n                }\n            }\n        }\n    }\n}"
    }
  ]
}