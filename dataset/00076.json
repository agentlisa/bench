{
  "Title": "LTV Duality Could Prevent Under-Collateralized Debt Mitigations",
  "Content": "Each vault configures the LTV of each acceptable collateral used for taking borrows backed by them. To reduce the pressure when the admin reduces the LTV for a collateral, which could end up in massive liquidations on positions backed by that collateral, the `LTVConfig` library uses a [ramp](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/types/LTVConfig.sol#L51-L55) between the old value and the target value. However, if a user has two accounts and wants to temporarily reduce the liquidity pressure while the ramp is still operational, the protocol will not allow it.\n\n\nLet us consider the following scenario:\n\n\n* `originalLTV` = `80`\n* `targetLTV` = `50`\n* `rampDuration` = `1 week`\n* `accountA_breakEven` = `75`\n* `accountB_breakEven` = `55`\n\n\nWhere the `breakEven` states the point at which the respective account will have a `healthScore` of 1. Originally, both accounts were sufficiently collateralized but after the ramp starts, the ramp's downtrend will eventually liquidate both accounts. The owner of both accounts, with the option to delay the liquidation of the accounts in the search for more collateral to be deposited in the near future (e.g., assets being withdrawn from an L2 bridge whose duration might be similar to 1 week), could prevent the upcoming liquidation of `accountA` by moving debt from `A` to `B` using the `pullDebt` function, which would move both `breakEven` points closer together.\n\n\nHowever, because the `requireAccountAndVaultStatusCheck` hook on `accountB` is triggered, the `checkAccountStatus` function from the `RiskManager` contract will be called, passing the execution to the [`checkLiquidity` function](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/RiskManager.sol#L79) which uses the [`BORROWING` type](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/shared/LiquidityUtils.sol#L47) for getting the LTV of the collateral. This means that all of its valuation will use the `targetLTV` instead of the current value in the ramp, failing the possibility of temporarily decreasing the pressure of the liquidations, even with the goal of injecting more collateral during the `rampDuration`.\n\n\nEven though the opposite direction of the debt transfer might not be allowed (compromising accounts with more burden), reducing the pressure on the ones that are closer to the liquidation stage will allow the owner to have more time to find more collateral and have enough for when the ramp ends.\n\n\nConsider using the LTV ramp when dealing with operations of debt transfer without increasing the actual overall debt to allow users the mitigation of the possible under-collateralized position due to a reduction in the LTV.\n\n\n***Update:** Acknowledged, not resolved. The Euler team stated:*\n\n\n\n> *We acknowledge the issue. In the current architecture it is not possible to discern what action triggered the account status check, so it would be difficult to perform a special case `pullDebt` during a ramp. While the ramp mechanism goes a long way in preventing user losses in events of LTV decreases, we acknowledge that in the specific edge-case situation described, the user's experience might be sub-optimal and note that instead of 'reducing pressure' the user would be encouraged to close the position.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/shared/types/LTVConfig.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {ConfigAmount} from \"./Types.sol\";\n\n/// @title LTVType\n/// @notice Enum of LTV types\nenum LTVType {\n    BORROWING,\n    LIQUIDATION\n}\n\n/// @title LTVConfig\n/// @notice This packed struct is used to store LTV configuration of a collateral\nstruct LTVConfig {\n    // Packed slot: 6 + 2 + 4 + 2 + 1 = 15\n    // The timestamp when the new liquidation LTV ramping is finished\n    uint48 targetTimestamp;\n    // The value of fully converged LTV value\n    ConfigAmount targetLTV;\n    // The time it takes the liquidation LTV to converge with borrowing LTV\n    uint32 rampDuration;\n    // The previous liquidation LTV value, from which the ramping begun\n    ConfigAmount originalLTV;\n    // A flag indicating the configuration was initialized for the collateral\n    bool initialized;\n}\n\n/// @title LTVConfigLib\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Library for getting and setting the LTV configurations\nlibrary LTVConfigLib {\n    // Is the collateral considered safe to liquidate\n    function isRecognizedCollateral(LTVConfig memory self) internal pure returns (bool) {\n        return self.targetTimestamp != 0;\n    }\n\n    // Get current LTV of a collateral. When liquidation LTV is lowered, it is ramped down to target value over a period of time.\n    function getLTV(LTVConfig memory self, LTVType ltvType) internal view returns (ConfigAmount) {\n        if (\n            ltvType == LTVType.BORROWING || block.timestamp >= self.targetTimestamp\n                || self.targetLTV >= self.originalLTV\n        ) {\n            return self.targetLTV;\n        }\n\n        uint256 currentLTV = self.originalLTV.toUint16();\n\n        unchecked {\n            uint256 targetLTV = self.targetLTV.toUint16();\n            uint256 timeRemaining = self.targetTimestamp - block.timestamp;\n\n            // targetLTV < originalLTV and timeRemaining < rampDuration\n            currentLTV = targetLTV + (currentLTV - targetLTV) * timeRemaining / self.rampDuration;\n        }\n        // because ramping happens only when LTV decreases, it's safe to down-cast the new value\n        return ConfigAmount.wrap(uint16(currentLTV));\n    }\n\n    function setLTV(LTVConfig memory self, ConfigAmount targetLTV, uint32 rampDuration)\n        internal\n        view\n        returns (LTVConfig memory newLTV)\n    {\n        newLTV.targetTimestamp = uint48(block.timestamp + rampDuration);\n        newLTV.targetLTV = targetLTV;\n        newLTV.rampDuration = rampDuration;\n        newLTV.originalLTV = self.getLTV(LTVType.LIQUIDATION);\n        newLTV.initialized = true;\n    }\n\n    // When LTV is cleared, the collateral can't be liquidated, as it's deemed unsafe\n    function clear(LTVConfig storage self) internal {\n        self.targetTimestamp = 0;\n        self.targetLTV = ConfigAmount.wrap(0);\n        self.rampDuration = 0;\n        self.originalLTV = ConfigAmount.wrap(0);\n    }\n}\n\nusing LTVConfigLib for LTVConfig global;"
    },
    {
      "filename": "src/EVault/modules/RiskManager.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IRiskManager} from \"../IEVault.sol\";\nimport {Base} from \"../shared/Base.sol\";\nimport {LiquidityUtils} from \"../shared/LiquidityUtils.sol\";\n\nimport \"../shared/types/Types.sol\";\n\n/// @title RiskManagerModule\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice An EVault module handling risk management, including vault and account health checks\nabstract contract RiskManagerModule is IRiskManager, Base, LiquidityUtils {\n    using TypesLib for uint256;\n\n    /// @inheritdoc IRiskManager\n    function accountLiquidity(address account, bool liquidation)\n        public\n        view\n        virtual\n        nonReentrantView\n        returns (uint256 collateralValue, uint256 liabilityValue)\n    {\n        VaultCache memory vaultCache = loadVault();\n\n        validateController(account);\n        address[] memory collaterals = getCollaterals(account);\n\n        return\n            calculateLiquidity(vaultCache, account, collaterals, liquidation ? LTVType.LIQUIDATION : LTVType.BORROWING);\n    }\n\n    /// @inheritdoc IRiskManager\n    function accountLiquidityFull(address account, bool liquidation)\n        public\n        view\n        virtual\n        nonReentrantView\n        returns (address[] memory collaterals, uint256[] memory collateralValues, uint256 liabilityValue)\n    {\n        VaultCache memory vaultCache = loadVault();\n\n        validateController(account);\n        validateOracle(vaultCache);\n        collaterals = getCollaterals(account);\n        collateralValues = new uint256[](collaterals.length);\n\n        for (uint256 i; i < collaterals.length; ++i) {\n            collateralValues[i] = getCollateralValue(\n                vaultCache, account, collaterals[i], liquidation ? LTVType.LIQUIDATION : LTVType.BORROWING\n            );\n        }\n\n        liabilityValue = getLiabilityValue(vaultCache, account, vaultStorage.users[account].getOwed());\n    }\n\n    /// @inheritdoc IRiskManager\n    function disableController() public virtual nonReentrant {\n        address account = EVCAuthenticate();\n\n        if (!vaultStorage.users[account].getOwed().isZero()) revert E_OutstandingDebt();\n\n        disableControllerInternal(account);\n    }\n\n    /// @inheritdoc IRiskManager\n    /// @dev The function doesn't have a re-entrancy lock, because onlyEVCChecks provides equivalent behaviour. It ensures that the caller\n    /// is the EVC, in 'checks in progress' state. In this state EVC will not accept any calls. Since all the functions which modify\n    /// vault state use callThroughEVC modifier, they are effectively blocked while the function executes. There are non-view functions without\n    /// callThroughEVC modifier (`flashLoan`, `disableCollateral`), but they don't change the vault's storage.\n    function checkAccountStatus(address account, address[] calldata collaterals)\n        public\n        virtual\n        reentrantOK\n        onlyEVCChecks\n        returns (bytes4 magicValue)\n    {\n        checkLiquidity(loadVault(), account, collaterals);\n\n        magicValue = IEVCVault.checkAccountStatus.selector;\n    }\n\n    /// @inheritdoc IRiskManager\n    /// @dev See comment about re-entrancy for `checkAccountStatus`\n    function checkVaultStatus() public virtual reentrantOK onlyEVCChecks returns (bytes4 magicValue) {\n        // Use the updating variant to make sure interest is accrued in storage before the interest rate update\n        VaultCache memory vaultCache = updateVault();\n        uint256 newInterestRate = computeInterestRate(vaultCache);\n\n        logVaultStatus(vaultCache, newInterestRate);\n\n        // We use the snapshot to check if the borrows or supply grew, and if so then we check the borrow and supply caps.\n        // If snapshot is initialized, then caps are configured.\n        // If caps are set in the middle of a batch, then snapshots represent the state of the vault at that time.\n        if (vaultCache.snapshotInitialized) {\n            vaultStorage.snapshotInitialized = vaultCache.snapshotInitialized = false;\n\n            Assets snapshotCash = snapshot.cash;\n            Assets snapshotBorrows = snapshot.borrows;\n\n            uint256 prevBorrows = snapshotBorrows.toUint();\n            uint256 borrows = vaultCache.totalBorrows.toAssetsUp().toUint();\n\n            if (borrows > vaultCache.borrowCap && borrows > prevBorrows) revert E_BorrowCapExceeded();\n\n            uint256 prevSupply = snapshotCash.toUint() + prevBorrows;\n            uint256 supply = totalAssetsInternal(vaultCache);\n\n            if (supply > vaultCache.supplyCap && supply > prevSupply) revert E_SupplyCapExceeded();\n\n            snapshot.reset();\n        }\n\n        callHookWithLock(vaultCache.hookedOps, OP_VAULT_STATUS_CHECK, address(evc));\n\n        magicValue = IEVCVault.checkVaultStatus.selector;\n    }\n}\n\n/// @dev Deployable module contract\ncontract RiskManager is RiskManagerModule {\n    constructor(Integrations memory integrations) Base(integrations) {}\n}"
    }
  ]
}