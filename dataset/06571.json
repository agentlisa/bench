{
  "Title": "[M-04] Unspent allowance may break functionality in AMO",
  "Content": "\n<https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L545> <br><https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L546> <br><https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L571>\n\nAn unspent allowance may cause a denial of service during the calls to `safeApprove()` in the AMO contract.\n\nThe AMO contract uses the `safeApprove()` function to grant the Curve pool permission to spend funds while adding liquidity. When adding liquidity into the Curve pool, the AMO contract needs to approve allowance so the AMM can pull tokens from the caller.\n\nThe `safeApprove()` function is a wrapper provided by the SafeERC20 library present in the OpenZeppelin contracts package, its implementation is the following:\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L45-L54>\n\n```solidity\nfunction safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n        (value == 0) || (token.allowance(address(this), spender) == 0),\n        \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}\n```\n\nAs the comment warns, this should only be used when setting an initial balance or resetting it to zero. In the AMO contract the use of `safeApprove()` is included in the functions that are in charge of adding liquidity to the Curve pool (`addLiquidity()` and `addLiquidityOnlyStETH()`), implying a repeatedly use whenever the allowance needs to be set so that the pool can pull the funds. As we can see in the implementation, if the current allowance is not zero the function will revert.\n\nThis means that any unspent allowance of xETH or stETH (i.e. `allowance(AMO, curvePool) > 0`) will cause a denial of service in the `addLiquidity()` and `addLiquidityOnlyStETH()` functions, potentially bricking the contract.\n\n### Proof of Concept\n\n1.  Suppose there is an unspent allowance of stETH in the AMO contract, `stETH.allowance(AMO, curvePool) > 0`.\n2.  Admin calls `addLiquidityOnlyStETH(stETHAmount, minLpOut)` with `stETHAmount > 0` to provide liquidity to the pool.\n3.  Transaction will be reverted in the call to `safeApprove()` as `(value == 0) || (token.allowance(address(this), spender) == 0)` will be false.\n\n### Recommendation\n\nSimply use `approve()`, or first reset the allowance to zero using `safeApprove(spender, 0)`, or use `safeIncreaseAllowance()`.\n\n### Note from warden\n\nEven though the deprecated usage of `safeApprove()` is mentioned in the automated findings, this report demonstrates how this function can cause a serious vulnerability that may end up bricking the contract.\n\n### Assessed type\nDoS\n\n**[vaporkane (xETH) confirmed](https://github.com/code-423n4/2023-05-xeth-findings/issues/29#issuecomment-1575445282)**\n\n**[xETH mitigated](https://github.com/code-423n4/2023-06-xeth-mitigation#mitigations-to-be-reviewed):**\n> Change `safeApprove` to approve.\n> \n> PR: https://github.com/code-423n4/2023-05-xeth/commit/793dade5217bd5751856f7cf0bccd4936286aeab\n\n**Status:** Mitigation confirmed. Full details in reports from [ronnyx2017](https://github.com/code-423n4/2023-06-xeth-mitigation-findings/issues/12), [bin2chen](https://github.com/code-423n4/2023-06-xeth-mitigation-findings/issues/6) and [d3e4](https://github.com/code-423n4/2023-06-xeth-mitigation-findings/issues/21).\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-xeth",
  "Code": [
    {
      "filename": "src/AMO2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/AccessControl.sol\";\nimport \"./interfaces/ICurvePool.sol\";\nimport {IXETH} from \"./interfaces/IXETH.sol\";\nimport {CVXStaker} from \"./CVXStaker.sol\";\n\ncontract xETH_AMO is AccessControl {\n    using SafeERC20 for IERC20;\n\n    /// @notice Thrown when the xETH-stETH LP balance of the AMO is too low for the rebalancing operation.\n    error LpBalanceTooLow();\n\n    /// @notice Thrown when either the stETH or xETH balance in the pool is zero, which would prevent rebalancing.\n    error ZeroBalancePool();\n\n    /// @notice Thrown when a zero address is provided as an input, which is not allowed.\n    error ZeroAddressProvided();\n\n    /// @notice Thrown when a function is called with a zero value, which is not allowed.\n    error ZeroValueProvided();\n\n    /// @notice Thrown when an invalid slippage value is provided, outside the allowed range.\n    error InvalidSlippageBPS();\n\n    /// @notice Thrown when a rebalance attempt is made before the cooldown period has finished.\n    error CooldownNotFinished();\n\n    /// @notice Thrown when a rebalance attempt is made, but the current pool ratios do not require rebalancing.\n    error RebalanceNotRequired();\n\n    /// @notice Thrown when a rebalanceUp operation is not allowed based on the current pool ratios.\n    error RebalanceUpNotAllowed();\n\n    /// @notice Thrown when a rebalanceDown operation is not allowed based on the current pool ratios.\n    error RebalanceDownNotAllowed();\n\n    /// @notice Thrown when the requested rebalanceUp operation exceeds the allowed rebalanceUpCap.\n    error RebalanceUpCapExceeded();\n\n    /// @notice Thrown when the requested rebalanceDown operation exceeds the allowed rebalanceDownCap.\n    error RebalanceDownCapExceeded();\n\n    /// @notice Emitted when a rebalanceUp operation is performed.\n    /// @param quote The chosen quote for rebalancing.\n    /// @param xETHamountReceived The actual amount of xETH received after burning LP tokens.\n    event RebalanceUpFinished(\n        RebalanceUpQuote quote,\n        uint256 xETHamountReceived\n    );\n\n    /// @notice Emitted when a rebalanceDown operation is performed.\n    /// @param quote The chosen quote for rebalancing.\n    /// @param lpAmountReceived The actual amount of xETH-stETH LP tokens received after minting xETH.\n    event RebalanceDownFinished(\n        RebalanceDownQuote quote,\n        uint256 lpAmountReceived\n    );\n\n    /// @notice Emitted when the defender address is updated.\n    /// @param oldDefender The previous defender address.\n    /// @param newDefender The new defender address.\n    event DefenderUpdated(address oldDefender, address newDefender);\n\n    /// @notice Emitted when the maxSlippageBPS is updated.\n    /// @param oldMaxSlippageBPS The previous max slippage value.\n    /// @param newMaxSlippageBPS The new max slippage value.\n    event MaxSlippageBPSUpdated(\n        uint256 oldMaxSlippageBPS,\n        uint256 newMaxSlippageBPS\n    );\n\n    /// @notice Emitted when the rebalanceUpCap is updated.\n    /// @param oldRebalanceUpCap The previous rebalanceUpCap value.\n    /// @param newRebalanceUpCap The new rebalanceUpCap value.\n    event RebalanceUpCapUpdated(\n        uint256 oldRebalanceUpCap,\n        uint256 newRebalanceUpCap\n    );\n\n    /// @notice Emitted when the rebalanceDownCap is updated.\n    /// @param oldRebalanceDownCap The previous rebalanceDownCap value.\n    /// @param newRebalanceDownCap The new rebalanceDownCap value.\n    event RebalanceDownCapUpdated(\n        uint256 oldRebalanceDownCap,\n        uint256 newRebalanceDownCap\n    );\n\n    /// @notice Emitted when the cooldownBlocks is updated.\n    /// @param oldCooldownBlocks The previous cooldownBlocks value.\n    /// @param newCooldownBlocks The new cooldownBlocks value.\n    event CooldownBlocksUpdated(\n        uint256 oldCooldownBlocks,\n        uint256 newCooldownBlocks\n    );\n\n    /// @notice Emitted when the CVXStaker address is updated.\n    /// @param oldCVXStaker The previous CVXStaker address.\n    /// @param newCVXStaker The new CVXStaker address.\n    event CVXStakerUpdated(address oldCVXStaker, address newCVXStaker);\n\n    /// @notice Emitted when the rebalance up threshold is set.\n    /// @param oldThreshold The old rebalance up threshold.\n    /// @param newThreshold The new rebalance up threshold.\n    event SetRebalanceUpThreshold(uint256 oldThreshold, uint256 newThreshold);\n\n    /// @notice Emitted when the rebalance down threshold is set.\n    /// @param oldThreshold The old rebalance down threshold.\n    /// @param newThreshold The new rebalance down threshold.\n    event SetRebalanceDownThreshold(uint256 oldThreshold, uint256 newThreshold);\n\n    /// @dev REBALANCE_DEFENDER_ROLE is the role that allows the defender to call rebalance()\n    bytes32 public constant REBALANCE_DEFENDER_ROLE =\n        keccak256(\"REBALANCE_DEFENDER_ROLE\");\n\n    /// @dev BASE_UNIT is the base unit used for calculations (1E18)\n    uint256 public constant BASE_UNIT = 1E18;\n\n    /// @dev xETHIndex is the index of xETH in the Curve pool\n    uint256 public immutable xETHIndex;\n\n    /// @dev stETHIndex is the index of stETH in the Curve pool\n    uint256 public immutable stETHIndex;\n\n    /// @dev xETH is the xETH token contract\n    IXETH public immutable xETH;\n\n    /// @dev stETH is the stETH token contract\n    IERC20 public immutable stETH;\n\n    /// @dev curvePool is the Curve pool contract\n    ICurvePool public immutable curvePool;\n\n    /// @dev maxSlippageBPS is the maximum slippage allowed when rebalancing\n    /// @notice 1E14 = 1 BPS\n    uint256 public maxSlippageBPS = 100 * 1E14;\n\n    /// @dev rebalanceUpCap is the maximum amount of xETH-stETH LP that can be burnt in a single rebalance\n    uint256 public rebalanceUpCap;\n\n    /// @dev rebalanceDownCap is the maximum amount of xETH that can be minted in a single rebalance\n    uint256 public rebalanceDownCap;\n\n    /// @dev lastRebalanceBlock is the block number of the last rebalance\n    uint256 public lastRebalanceBlock;\n\n    /// @dev cooldownBlocks is the number of blocks that must pass between rebalances\n    uint256 public cooldownBlocks = 1800; /// (6 * 60 * 60) / 12\n\n    /// @dev REBALANCE_UP_THRESHOLD is the upper threshold for the xETH-stETH LP ratio\n    /// @notice if the ratio is above this value, rebalanceUp() will be called\n    uint256 public REBALANCE_UP_THRESHOLD = 0.75E18;\n\n    /// @dev REBALANCE_DOWN_THRESHOLD is the lower threshold for the xETH-stETH LP ratio\n    /// @notice if the ratio is below this value, rebalanceDown() will be called\n    uint256 public REBALANCE_DOWN_THRESHOLD = 0.68E18;\n\n    /// @dev defender is the whitelisted bot that can call rebalance()\n    address public defender;\n\n    /// @dev cvxStaker is the CVX staking contract\n    CVXStaker public cvxStaker;\n\n    /// @dev afterCooldownPeriod is a modifier that checks if the cooldown period has passed\n    modifier afterCooldownPeriod() {\n        if (lastRebalanceBlock + cooldownBlocks >= block.number)\n            revert CooldownNotFinished();\n        _;\n        lastRebalanceBlock = block.number;\n    }\n\n    constructor(\n        address _xETH,\n        address _stETH,\n        address _curvePool,\n        address _cvxStaker,\n        bool isXETHToken0\n    ) {\n        if (\n            _xETH == address(0) ||\n            _stETH == address(0) ||\n            _curvePool == address(0) ||\n            _cvxStaker == address(0)\n        ) {\n            revert ZeroAddressProvided();\n        }\n\n        xETH = IXETH(_xETH);\n        stETH = IERC20(_stETH);\n        curvePool = ICurvePool(_curvePool);\n        cvxStaker = CVXStaker(_cvxStaker);\n\n        xETHIndex = isXETHToken0 ? 0 : 1;\n        stETHIndex = isXETHToken0 ? 1 : 0;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev preRebalanceCheck checks if a rebalance is even allowed based on pool ratios\n    function preRebalanceCheck() internal view returns (bool isRebalanceUp) {\n        uint256 stETHBal = curvePool.balances(stETHIndex);\n        uint256 xETHBal = curvePool.balances(xETHIndex);\n\n        /// @notice if either token balance is 0, the pool shall not be rebalanced\n        if (stETHBal == 0 || xETHBal == 0) revert ZeroBalancePool();\n\n        uint256 xEthPct = (xETHBal * BASE_UNIT) / (stETHBal + xETHBal);\n\n        /// @notice if the ratio is above the upper threshold, rebalanceUp() will be called\n        if (xEthPct > REBALANCE_UP_THRESHOLD) {\n            isRebalanceUp = true;\n        }\n        /// @notice if the ratio is below the lower threshold, rebalanceDown() will be called\n        /// @notice possible gas optimization here.\n        else if (xEthPct < REBALANCE_DOWN_THRESHOLD) {\n            isRebalanceUp = false;\n        }\n        /// @notice if the ratio is within the thresholds, the pool shall not be rebalanced\n        else {\n            revert RebalanceNotRequired();\n        }\n    }\n\n    struct RebalanceUpQuote {\n        uint256 lpBurn;\n        uint256 min_xETHReceived;\n    }\n\n    /**\n     * @dev Executes a rebalance up operation, which burns xETH-stETH LP to receive xETH.\n     * @param quote The quote for the rebalance operation provided by the rebalance defender.\n     * @return xETHReceived The amount of xETH received from the rebalance operation.\n     * @notice Only the rebalance defender can call this function.\n     * @notice The rebalance operation can only be performed after the cooldown period has elapsed.\n     */\n    function rebalanceUp(\n        RebalanceUpQuote memory quote\n    )\n        external\n        onlyRole(REBALANCE_DEFENDER_ROLE)\n        afterCooldownPeriod\n        returns (uint256 xETHReceived)\n    {\n        if (quote.lpBurn == 0) revert ZeroValueProvided();\n\n        bool isRebalanceUp = preRebalanceCheck();\n        if (!isRebalanceUp) revert RebalanceUpNotAllowed();\n\n        if (quote.lpBurn > rebalanceUpCap) revert RebalanceUpCapExceeded();\n\n        quote = bestRebalanceUpQuote(quote);\n\n        uint256 amoLpBal = cvxStaker.stakedBalance();\n\n        // if (amoLpBal == 0 || quote.lpBurn > amoLpBal) revert LpBalanceTooLow();\n        if (quote.lpBurn > amoLpBal) revert LpBalanceTooLow();\n\n        cvxStaker.withdrawAndUnwrap(quote.lpBurn, false, address(this));\n\n        xETHReceived = curvePool.remove_liquidity_one_coin(\n            quote.lpBurn,\n            int128(int(xETHIndex)),\n            quote.min_xETHReceived\n        );\n\n        xETH.burnShares(xETHReceived);\n\n        emit RebalanceUpFinished(quote, xETHReceived);\n    }\n\n    struct RebalanceDownQuote {\n        uint256 xETHAmount;\n        uint256 minLpReceived;\n    }\n\n    /**\n     * @dev Executes a rebalance down operation, which mints xETH and deposits into the Curve pool.\n     * @param quote The quote for the rebalance operation provided by the rebalance defender.\n     * @return lpAmountOut The amount of LP tokens received from the rebalance operation.\n     * @notice Only the rebalance defender can call this function.\n     * @notice The rebalance operation can only be performed after the cooldown period has elapsed.\n     */\n    function rebalanceDown(\n        RebalanceDownQuote memory quote\n    )\n        external\n        onlyRole(REBALANCE_DEFENDER_ROLE)\n        afterCooldownPeriod\n        returns (uint256 lpAmountOut)\n    {\n        if (quote.xETHAmount == 0) revert ZeroValueProvided();\n\n        bool isRebalanceUp = preRebalanceCheck();\n        if (isRebalanceUp) revert RebalanceDownNotAllowed();\n\n        if (quote.xETHAmount > rebalanceDownCap)\n            revert RebalanceDownCapExceeded();\n\n        quote = bestRebalanceDownQuote(quote);\n\n        xETH.mintShares(quote.xETHAmount);\n\n        uint256[2] memory amounts;\n        amounts[xETHIndex] = quote.xETHAmount;\n\n        IERC20(address(xETH)).approve(address(curvePool), quote.xETHAmount);\n\n        lpAmountOut = curvePool.add_liquidity(amounts, quote.minLpReceived);\n\n        IERC20(address(curvePool)).safeTransfer(\n            address(cvxStaker),\n            lpAmountOut\n        );\n        cvxStaker.depositAndStake(lpAmountOut);\n\n        emit RebalanceDownFinished(quote, lpAmountOut);\n    }\n\n    /// @dev applySlippage applies the maxSlippageBPS to the amount provided\n    function applySlippage(uint256 amount) internal view returns (uint256) {\n        return (amount * (BASE_UNIT - maxSlippageBPS)) / BASE_UNIT;\n    }\n\n    /**\n     * @dev Finds the best quote for rebalancing upwards.\n     * @param defenderQuote The quote provided by the rebalance defender.\n     * @return The best quote for rebalancing upwards.\n     * @notice This function is internal and cannot be called outside of the contract.\n     * @notice the defenderQuote should ideally be better than the contractQuote\n     * @notice if its not, the contractQuote gets executed as a safeguard, reducing the risk of a large sandwich\n     */\n    function bestRebalanceUpQuote(\n        RebalanceUpQuote memory defenderQuote\n    ) internal view returns (RebalanceUpQuote memory) {\n        RebalanceUpQuote memory bestQuote;\n        uint256 vp = curvePool.get_virtual_price();\n\n        /// @dev first lets fill the bestQuote with the contractQuote\n        bestQuote.lpBurn = defenderQuote.lpBurn;\n        bestQuote.min_xETHReceived = applySlippage(\n            (vp * defenderQuote.lpBurn) / BASE_UNIT\n        );\n\n        if (defenderQuote.min_xETHReceived > bestQuote.min_xETHReceived)\n            bestQuote.min_xETHReceived = defenderQuote.min_xETHReceived;\n\n        return bestQuote;\n    }\n\n    /**\n     * @dev Finds the best quote for rebalancing downwards.\n     * @param defenderQuote The quote provided by the rebalance defender.\n     * @return The best quote for rebalancing downwards.\n     * @notice the defenderQuote should ideally be better than the contractQuote\n     * @notice if its not, the contractQuote gets executed as a safeguard, reducing the risk of a large sandwich\n     */\n    function bestRebalanceDownQuote(\n        RebalanceDownQuote memory defenderQuote\n    ) internal view returns (RebalanceDownQuote memory) {\n        RebalanceDownQuote memory bestQuote;\n        uint256 vp = curvePool.get_virtual_price();\n\n        /// @dev first lets fill the bestQuote with the contractQuote\n        bestQuote.xETHAmount = defenderQuote.xETHAmount;\n        bestQuote.minLpReceived = applySlippage(\n            (BASE_UNIT * defenderQuote.xETHAmount) / vp\n        );\n\n        if (defenderQuote.minLpReceived > bestQuote.minLpReceived)\n            bestQuote.minLpReceived = defenderQuote.minLpReceived;\n\n        return bestQuote;\n    }\n\n    /**\n     * @dev Sets the address of the rebalance defender.\n     * @param newDefender The new rebalance defender address to be set.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new rebalance defender address cannot be set to the zero address.\n     * @notice If a previous defender was set, their `REBALANCE_DEFENDER_ROLE` is revoked and transferred to the new defender.\n     * @notice Emits a `DefenderUpdated` event.\n     */\n    function setRebalanceDefender(\n        address newDefender\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newDefender == address(0)) revert ZeroAddressProvided();\n\n        if (defender != address(0)) {\n            _revokeRole(REBALANCE_DEFENDER_ROLE, defender);\n        }\n\n        emit DefenderUpdated(defender, newDefender);\n\n        defender = newDefender;\n        _grantRole(REBALANCE_DEFENDER_ROLE, newDefender);\n    }\n\n    /**\n     * @dev Sets the maximum allowable slippage in basis points for trading.\n     * @param newMaxSlippageBPS The new maximum slippage in basis points to be set.\n     * @notice 1 BPS = 1E14\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new maximum slippage must be between 0.06% and 15% (in basis points).\n     * @notice Emits a `MaxSlippageBPSUpdated` event.\n     */\n    function setMaxSlippageBPS(\n        uint256 newMaxSlippageBPS\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        /// @dev the allowed minimum slippage is 0.06% and the maximum slippage is 15%\n        if (newMaxSlippageBPS < 6E14 || newMaxSlippageBPS > 1500E14) {\n            revert InvalidSlippageBPS();\n        }\n\n        emit MaxSlippageBPSUpdated(maxSlippageBPS, newMaxSlippageBPS);\n\n        maxSlippageBPS = newMaxSlippageBPS;\n    }\n\n    /**\n     * @dev Sets the maximum burning cap (rebalanceUp) in a single transaction.\n     * @param newRebalanceUpCap The new rebalance up cap to be set.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new rebalance up cap cannot be set to zero.\n     * @notice Emits a `RebalanceUpCapUpdated` event.\n     */\n    function setRebalanceUpCap(\n        uint256 newRebalanceUpCap\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newRebalanceUpCap == 0) revert ZeroValueProvided();\n\n        emit RebalanceUpCapUpdated(rebalanceUpCap, newRebalanceUpCap);\n\n        rebalanceUpCap = newRebalanceUpCap;\n    }\n\n    /**\n     * @dev Sets the maximum minting cap (rebalanceDown) in a single transaction.\n     * @param newRebalanceDownCap The new rebalance down cap to be set.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new rebalance down cap cannot be set to zero.\n     * @notice Emits a `RebalanceDownCapUpdated` event.\n     */\n    function setRebalanceDownCap(\n        uint256 newRebalanceDownCap\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newRebalanceDownCap == 0) revert ZeroValueProvided();\n\n        emit RebalanceDownCapUpdated(rebalanceDownCap, newRebalanceDownCap);\n\n        rebalanceDownCap = newRebalanceDownCap;\n    }\n\n    /**\n     * @dev Sets the number of blocks for the unstake cooldown period\n     * @param newCooldownBlocks The new number of blocks for the unstake cooldown period\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice Emits a CooldownBlocksUpdated event with the old and new cooldown block values\n     */\n    function setCooldownBlocks(\n        uint256 newCooldownBlocks\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newCooldownBlocks == 0) revert ZeroValueProvided();\n\n        emit CooldownBlocksUpdated(cooldownBlocks, newCooldownBlocks);\n\n        cooldownBlocks = newCooldownBlocks;\n    }\n\n    /**\n     * @dev Sets the CVX staking contract address\n     * @param _cvxStaker The address of the CVX staking contract\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new CVX staker contract address cannot be set to the zero address.\n     * @notice Emits a `CVXStakerUpdated` event.\n     */\n    function setCvxStaker(\n        address _cvxStaker\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_cvxStaker == address(0)) revert ZeroAddressProvided();\n\n        emit CVXStakerUpdated(address(cvxStaker), _cvxStaker);\n\n        cvxStaker = CVXStaker(_cvxStaker);\n    }\n\n    /**\n     * @dev Sets the threshold for triggering a `rebalanceUp` operation.\n     * @param newRebalanceUpThreshold The new threshold to be set.\n     * @notice Emits a `SetRebalanceUpThreshold` event with the old and new thresholds.\n     * @notice Requires the caller to have the `DEFAULT_ADMIN_ROLE`.\n     */\n    function setRebalanceUpThreshold(\n        uint256 newRebalanceUpThreshold\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        emit SetRebalanceUpThreshold(\n            REBALANCE_UP_THRESHOLD,\n            newRebalanceUpThreshold\n        );\n\n        REBALANCE_UP_THRESHOLD = newRebalanceUpThreshold;\n    }\n\n    /**\n     * @dev Sets the threshold for triggering a `rebalanceDown` operation.\n     * @param newRebalanceDownThreshold The new threshold to be set.\n     * @notice Emits a `SetRebalanceDownThreshold` event with the old and new thresholds.\n     * @notice Requires the caller to have the `DEFAULT_ADMIN_ROLE`.\n     */\n    function setRebalanceDownThreshold(\n        uint256 newRebalanceDownThreshold\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        emit SetRebalanceDownThreshold(\n            REBALANCE_DOWN_THRESHOLD,\n            newRebalanceDownThreshold\n        );\n\n        REBALANCE_DOWN_THRESHOLD = newRebalanceDownThreshold;\n    }\n\n    /**\n     * @dev Adds liquidity to the Curve pool using both xETH and stETH and stakes the resulting LP tokens in the CVX staking contract\n     * @param stETHAmount The amount of stETH to be deposited\n     * @param xETHAmount The amount of xETH to be deposited\n     * @param minLpOut The minimum amount of LP tokens to receive from the Curve pool\n     * @notice Transfers stETH and xETH from the caller to this contract, adds liquidity to the Curve pool, and stakes the resulting LP tokens in the CVX staking contract.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @return lpOut The amount of LP tokens received from the Curve pool\n     */\n    function addLiquidity(\n        uint256 stETHAmount,\n        uint256 xETHAmount,\n        uint256 minLpOut\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 lpOut) {\n        stETH.safeTransferFrom(msg.sender, address(this), stETHAmount);\n        xETH.mintShares(xETHAmount);\n\n        uint256[2] memory amounts;\n\n        amounts[xETHIndex] = xETHAmount;\n        amounts[stETHIndex] = stETHAmount;\n\n        IERC20(address(xETH)).safeApprove(address(curvePool), xETHAmount);\n        stETH.safeApprove(address(curvePool), stETHAmount);\n\n        lpOut = curvePool.add_liquidity(amounts, minLpOut);\n\n        /// @notice no need for safeApprove, direct transfer + deposit\n        IERC20(address(curvePool)).safeTransfer(address(cvxStaker), lpOut);\n        cvxStaker.depositAndStake(lpOut);\n    }\n\n    /**\n     * @notice Adds liquidity only with stETH and stakes the resulting LP tokens in the cvxCRV staking contract.\n     * @param stETHAmount The amount of stETH to add as liquidity.\n     * @param minLpOut The minimum expected amount of LP tokens to receive.\n     * @return lpOut The actual amount of LP tokens received.\n     */\n    function addLiquidityOnlyStETH(\n        uint256 stETHAmount,\n        uint256 minLpOut\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 lpOut) {\n        stETH.safeTransferFrom(msg.sender, address(this), stETHAmount);\n\n        uint256[2] memory amounts;\n\n        amounts[stETHIndex] = stETHAmount;\n\n        stETH.safeApprove(address(curvePool), stETHAmount);\n\n        lpOut = curvePool.add_liquidity(amounts, minLpOut);\n\n        /// @notice no need for safeApprove, direct transfer + deposit\n        IERC20(address(curvePool)).safeTransfer(address(cvxStaker), lpOut);\n        cvxStaker.depositAndStake(lpOut);\n    }\n\n    /**\n     * @dev Removes liquidity from the Curve pool using both xETH and stETH and transfers the resulting tokens to the caller\n     * @param lpAmount The amount of LP tokens to be burned\n     * @param minStETHOut The minimum amount of stETH to receive from the Curve pool\n     * @param minXETHOut The minimum amount of xETH to receive from the Curve pool\n     * @notice Checks if the AMO owns enough LP tokens, withdraws and unwraps them, and removes liquidity from the Curve pool.\n     *      The resulting xETH and stETH are then transferred to the caller.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @return outputs An array containing the resulting amounts of xETH and stETH received from the Curve pool\n     */\n    function removeLiquidity(\n        uint256 lpAmount,\n        uint256 minStETHOut,\n        uint256 minXETHOut\n    )\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        returns (uint256[2] memory outputs)\n    {\n        /// @dev check if AMO owns enough LP\n        uint256 amoBalance = cvxStaker.stakedBalance();\n\n        if (lpAmount > amoBalance) {\n            revert LpBalanceTooLow();\n        }\n\n        cvxStaker.withdrawAndUnwrap(lpAmount, false, address(this));\n\n        uint256[2] memory minAmounts;\n\n        minAmounts[xETHIndex] = minXETHOut;\n        minAmounts[stETHIndex] = minStETHOut;\n\n        outputs = curvePool.remove_liquidity(lpAmount, minAmounts);\n\n        xETH.burnShares(outputs[xETHIndex]);\n        stETH.safeTransfer(msg.sender, outputs[stETHIndex]);\n    }\n\n    /**\n     * @dev Removes liquidity from the Curve pool using only stETH and transfers the resulting stETH to the caller\n     * @param lpAmount The amount of LP tokens to be burned\n     * @param minStETHOut The minimum amount of stETH to receive from the Curve pool\n     * @notice Checks if the AMO owns enough LP tokens, withdraws and unwraps them, and removes liquidity from the Curve pool.\n     *      The resulting stETH is then transferred to the caller.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     */\n    function removeLiquidityOnlyStETH(\n        uint256 lpAmount,\n        uint256 minStETHOut\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        /// @dev check if AMO owns enough LP\n        uint256 amoBalance = cvxStaker.stakedBalance();\n\n        if (lpAmount > amoBalance) {\n            revert LpBalanceTooLow();\n        }\n\n        cvxStaker.withdrawAndUnwrap(lpAmount, false, address(this));\n\n        uint256[2] memory minAmounts;\n\n        minAmounts[stETHIndex] = minStETHOut;\n\n        uint256 output = curvePool.remove_liquidity_one_coin(\n            lpAmount,\n            int128(int(stETHIndex)),\n            minStETHOut\n        );\n\n        stETH.safeTransfer(msg.sender, output);\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on th"
    }
  ]
}