{
  "Title": "[N-06]  Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`",
  "Content": "While it doesn't save any gas because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.\n\n*There are 6 instances of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n59        bytes32 public constant DOMAIN_TYPEHASH =\n60:           keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n63        bytes32 public constant DELEGATION_TYPEHASH =\n64:           keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L59-L60\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n97        bytes32 public constant DOMAIN_TYPEHASH =\n98:           keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n101:      bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L97-L98\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n101       bytes32 public constant DOMAIN_TYPEHASH =\n102:          keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n105:      bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L101-L102\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-nounsdao",
  "Code": [
    {
      "filename": "contracts/base/ERC721Checkpointable.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title Vote checkpointing for an ERC-721 token\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// ERC721Checkpointable.sol uses and modifies part of Compound Lab's Comp.sol:\n// https://github.com/compound-finance/compound-protocol/blob/ae4388e780a8d596d97619d9704a931a2752c2bc/contracts/Governance/Comp.sol\n//\n// Comp.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// Checkpointing logic from Comp.sol has been used with the following modifications:\n// - `delegates` is renamed to `_delegates` and is set to private\n// - `delegates` is a public function that uses the `_delegates` mapping look-up, but unlike\n//   Comp.sol, returns the delegator's own address if there is no delegate.\n//   This avoids the delegator needing to \"delegate to self\" with an additional transaction\n// - `_transferTokens()` is renamed `_beforeTokenTransfer()` and adapted to hook into OpenZeppelin's ERC721 hooks.\n\npragma solidity ^0.8.6;\n\nimport './ERC721Enumerable.sol';\n\nabstract contract ERC721Checkpointable is ERC721Enumerable {\n    /// @notice Defines decimals as per ERC-20 convention to make integrations with 3rd party governance platforms easier\n    uint8 public constant decimals = 0;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) private _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @notice The votes a delegator can delegate, which is the current balance of the delegator.\n     * @dev Used when calling `_delegate()`\n     */\n    function votesToDelegate(address delegator) public view returns (uint96) {\n        return safe96(balanceOf(delegator), 'ERC721Checkpointable::votesToDelegate: amount exceeds 96 bits');\n    }\n\n    /**\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\n     * the delegator's own address if they haven't delegated.\n     * This avoids having to delegate to oneself.\n     */\n    function delegates(address delegator) public view returns (address) {\n        address current = _delegates[delegator];\n        return current == address(0) ? delegator : current;\n    }\n\n    /**\n     * @notice Adapted from `_transferTokens()` in `Comp.sol` to update delegate votes.\n     * @dev hooks into OpenZeppelin's `ERC721._transfer`\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation\n        _moveDelegates(delegates(from), delegates(to), 1);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        if (delegatee == address(0)) delegatee = msg.sender;\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'ERC721Checkpointable::delegateBySig: invalid signature');\n        require(nonce == nonces[signatory]++, 'ERC721Checkpointable::delegateBySig: invalid nonce');\n        require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, 'ERC721Checkpointable::getPriorVotes: not yet determined');\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n        address currentDelegate = delegates(delegator);\n\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        uint96 amount = votesToDelegate(delegator);\n\n        _moveDelegates(currentDelegate, delegatee, amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount underflows');\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount overflows');\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(\n            block.number,\n            'ERC721Checkpointable::_writeCheckpoint: block number exceeds 32 bits'\n        );\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}"
    },
    {
      "filename": "contracts/governance/NounsDAOLogicV1.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO logic version 1\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOLogicV1.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\n//\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOLogicV1 adds:\n// - Proposal Threshold basis points instead of fixed number\n//   due to the Noun token's increasing supply\n//\n// - Quorum Votes basis points instead of fixed number\n//   due to the Noun token's increasing supply\n//\n// - Per proposal storing of fixed `proposalThreshold`\n//   and `quorumVotes` calculated using the Noun token's total supply\n//   at the block the proposal was created and the basis point parameters\n//\n// - `ProposalCreatedWithRequirements` event that emits `ProposalCreated` parameters with\n//   the addition of `proposalThreshold` and `quorumVotes`\n//\n// - Votes are counted from the block a proposal is created instead of\n//   the proposal's voting start block to align with the parameters\n//   stored with the proposal\n//\n// - Veto ability which allows `veteor` to halt any proposal at any stage unless\n//   the proposal is executed.\n//   The `veto(uint proposalId)` logic is a modified version of `cancel(uint proposalId)`\n//   A `vetoed` flag was added to the `Proposal` struct to support this.\n//\n// NounsDAOLogicV1 removes:\n// - `initialProposalId` and `_initiate()` due to this being the\n//   first instance of the governance contract unlike\n//   GovernorBravo which upgrades GovernorAlpha\n//\n// - Value passed along using `timelock.executeTransaction{value: proposal.value}`\n//   in `execute(uint proposalId)`. This contract should not hold funds and does not\n//   implement `receive()` or `fallback()` functions.\n//\n\npragma solidity ^0.8.6;\n\nimport './NounsDAOInterfaces.sol';\n\ncontract NounsDAOLogicV1 is NounsDAOStorageV1, NounsDAOEvents {\n    /// @notice The name of this contract\n    string public constant name = 'Nouns DAO';\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\n\n    /// @notice The minimum setable quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS = 200; // 200 basis points or 2%\n\n    /// @notice The maximum setable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @param timelock_ The address of the NounsDAOExecutor\n     * @param nouns_ The address of the NOUN tokens\n     * @param vetoer_ The address allowed to unilaterally veto proposals\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\n     * * @param quorumVotesBPS_ The initial quorum votes threshold in basis points\n     */\n    function initialize(\n        address timelock_,\n        address nouns_,\n        address vetoer_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThresholdBPS_,\n        uint256 quorumVotesBPS_\n    ) public virtual {\n        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n        require(msg.sender == admin, 'NounsDAO::initialize: admin only');\n        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            'NounsDAO::initialize: invalid voting period'\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            'NounsDAO::initialize: invalid voting delay'\n        );\n        require(\n            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::initialize: invalid proposal threshold'\n        );\n        require(\n            quorumVotesBPS_ >= MIN_QUORUM_VOTES_BPS && quorumVotesBPS_ <= MAX_QUORUM_VOTES_BPS,\n            'NounsDAO::initialize: invalid proposal threshold'\n        );\n\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\n        emit VotingDelaySet(votingDelay, votingDelay_);\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\n        emit QuorumVotesBPSSet(quorumVotesBPS, quorumVotesBPS_);\n\n        timelock = INounsDAOExecutor(timelock_);\n        nouns = NounsTokenLike(nouns_);\n        vetoer = vetoer_;\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThresholdBPS = proposalThresholdBPS_;\n        quorumVotesBPS = quorumVotesBPS_;\n    }\n\n    struct ProposalTemp {\n        uint256 totalSupply;\n        uint256 proposalThreshold;\n        uint256 latestProposalId;\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        ProposalTemp memory temp;\n\n        temp.totalSupply = nouns.totalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = proposals[proposalCount];\n\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.quorumVotes = bps2Uint(quorumVotesBPS, temp.totalSupply);\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.vetoed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `quorumVotes`\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            newProposal.quorumVotes,\n            description\n        );\n\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        require(vetoer != address(0), 'NounsDAO::veto: veto power burned');\n        require(msg.sender == vetoer, 'NounsDAO::veto: only vetoer');\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::veto: cannot veto executed proposal');\n\n        Proposal storage proposal = proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'NounsDAO::castVoteBySig: invalid signature');\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), '');\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'NounsDAO::castVoteInternal: voter already voted');\n\n        /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n        uint96 votes = nouns.getPriorVotes(voter, proposal.startBlock - votingDelay);\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            'NounsDAO::_setVotingDelay: invalid voting delay'\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256"
    }
  ]
}