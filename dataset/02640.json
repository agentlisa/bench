{
  "Title": "M-11: priceLiquidity() may not work if PriceFeed.aggregator() is updated",
  "Content": "# Issue M-11: priceLiquidity() may not work if PriceFeed.aggregator() is updated \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/145 \n\n## Found by \ncccz\n\n## Summary\npriceLiquidity() may not work if PriceFeed.aggregator() is updated\n## Vulnerability Detail\nIn the constructor of the DepositReceipt_* contract, the value of minAnswer/maxAnswer in priceFeed.aggregator() is obtained and assigned to *MinPrice/*MaxPrice as the maximum/minimum price limit when calling the getOraclePrice function in priceLiquidity, and *MinPrice/*MaxPrice can not change.\n```solidity\n        IAccessControlledOffchainAggregator  aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = aggregator.minAnswer();\n        tokenMaxPrice = aggregator.maxAnswer();\n...\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n...\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            /*uint80 roundID*/,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            /*uint80 answeredInRound*/\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n```\nBut in the priceFeed contract, the address of the aggregator can be changed by the owner, which may cause the value of minAnswer/maxAnswer to change, and the price limit in the DepositReceipt_* contract to be invalid, and priceLiquidity() can not work.\n```solidity\n  function confirmAggregator(address _aggregator)\n    external\n    onlyOwner()\n  {\n    require(_aggregator == address(proposedAggregator), \"Invalid proposed aggregator\");\n    delete proposedAggregator;\n    setAggregator(_aggregator);\n  }\n\n\n  /*\n   * Internal\n   */\n\n  function setAggregator(address _aggregator)\n    internal\n  {\n    uint16 id = currentPhase.id + 1;\n    currentPhase = Phase(id, AggregatorV2V3Interface(_aggregator));\n    phaseAggregators[id] = AggregatorV2V3Interface(_aggregator);\n  }\n  ...\n    function aggregator()\n    external\n    view\n    returns (address)\n  {\n    return address(currentPhase.aggregator);\n  }\n```\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L66-L80\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L60-L64\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L107-L109\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol#L134-L135\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L90-L91\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol#L113-L114\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol#L164-L176\nhttps://etherscan.io/address/0xc7de7f4d4C9c991fF62a07D18b3E31e349833A18#code\nhttps://etherscan.io/address/0x72002129A3834d63C57d157DDF069deE37b08F24#code\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider getting latest priceFeed.aggregator().minAnswer()/maxAnswer() in priceLiquidity()\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. \n\nChainlink documents state: \"you can call functions on the aggregator directly, but it is a best practice to use the [AggregatorV3Interface](https://docs.chain.link/data-feeds/price-feeds/api-reference#aggregatorv3interface) to run functions on the proxy instead so that changes to the aggregator do not affect your application. Read the aggregator contract only if you need functions that are not available in the proxy.\"\n\nSo the auditor is right that we should not assume the AccessControlledOffchainAggregator is static. We will move these calls to occur on every call rather than in setup.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/58b8f3e14b416630971b7b17b500bbe22d2016aa\n\nNote there are two fixes in this commit relating to the priceLiquidity function. the other issue is #72 , the code for these changes doesn't overlap so should be clear, please ask me if it is not.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_ETH is  DepositReceipt_Base {\n    \n    //Price deviation limit when checking pool exchange rate against Chainlink Oracle\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    //deployed address of WETH on Optimism Mainnet\n    address private constant WETH = 0x4200000000000000000000000000000000000006;\n    \n    //Chainlink oracle sources\n    IAggregatorV3 ETHPriceFeed;\n    IAggregatorV3 tokenPriceFeed;\n    \n    // ten to the power of the number of decimals given by both price feeds\n    uint256 immutable oracleBase;\n    \n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _ETHPriceFeed,\n                address _tokenPriceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory WETHSymbol = abi.encodePacked(\"WETH\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(WETHSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(WETHSymbol), \"One token must be WETH\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n    \n        //fetch details for ETH price feed\n        ETHPriceFeed = IAggregatorV3(_ETHPriceFeed);\n        tokenPriceFeed = IAggregatorV3(_tokenPriceFeed);\n        IAccessControlledOffchainAggregator  ETHaggregator = IAccessControlledOffchainAggregator(ETHPriceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        ETHMinPrice = ETHaggregator.minAnswer();\n        ETHMaxPrice = ETHaggregator.maxAnswer();\n        uint256 ETHOracleDecimals = ETHPriceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n        require(ETHOracleDecimals == tokenPriceFeed.decimals());\n\n        //fetch details for Token price feed\n        \n        IAccessControlledOffchainAggregator  tokenAggregator = IAccessControlledOffchainAggregator(tokenPriceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = tokenAggregator.minAnswer();\n        tokenMaxPrice = tokenAggregator.maxAnswer();\n        // because we have checked both oracles have the same amount of decimals we only store one OracleBase\n        oracleBase = 10 ** ETHOracleDecimals; \n        \n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        \n        uint256 value0;\n        uint256 value1;\n        if (token0 == WETH){\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, WETH);\n            \n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 tokenOraclePrice = getOraclePrice(tokenPriceFeed, tokenMaxPrice, tokenMinPrice);\n            uint256 ETHOraclePrice = getOraclePrice(ETHPriceFeed, ETHMaxPrice, ETHMinPrice);\n            //reduce amountOut to the value of one token in dollars in the same scale as tokenOraclePrice (1e8)\n            uint256 valueOut = amountOut * ETHOraclePrice / HUNDRED / BASE; \n\n            //calculate acceptable deviations from oracle price\n            \n            uint256 lowerBound = (tokenOraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (tokenOraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            \n            require(lowerBound < valueOut, \"Price shift low detected\");\n            require(upperBound > valueOut, \"Price shift high detected\");\n\n            value0 = token0Amount * ETHOraclePrice;\n            \n            value1 = token1Amount * tokenOraclePrice;\n        }\n        //token1 must be WETH\n        else {\n            \n            //check swap value of 100tokens to WETH to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, WETH);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n            uint256 tokenOraclePrice = getOraclePrice(tokenPriceFeed, tokenMaxPrice, tokenMinPrice);\n            uint256 ETHOraclePrice = getOraclePrice(ETHPriceFeed, ETHMaxPrice, ETHMinPrice);\n            //reduce amountOut to the value of one token in dollars in the same scale as tokenOraclePrice (1e8)\n            uint256 valueOut = amountOut * ETHOraclePrice / HUNDRED / BASE; \n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (tokenOraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (tokenOraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < valueOut, \"Price shift low detected\");\n            require(upperBound > valueOut, \"Price shift high detected\");\n\n            value1 = token1Amount * ETHOraclePrice;\n            \n            value0 = token0Amount * tokenOraclePrice;\n        }\n        // because value0 and value1 are in the same scale we can reduce them to 1e18 scale after adding.\n        return((value0 + value1)/oracleBase);\n    }\n}"
    },
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_USDC is  DepositReceipt_Base {\n\n    uint256 private constant SCALE_SHIFT = 1e12; //brings USDC 6.d.p up to 18d.p. standard\n    uint256 private constant USDC_BASE = 1e6; //used for division in USDC 6.d.p scale\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    address private constant USDC = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607; \n\n    //Chainlink oracle source\n    IAggregatorV3 public priceFeed;\n    // ten to the power of the number of decimals given by the price feed\n    uint256 private immutable oracleBase;\n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory USDCSymbol = abi.encodePacked(\"USDC\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n        priceFeed = IAggregatorV3(_priceFeed);\n        IAccessControlledOffchainAggregator  aggregator = IAccessControlledOffchainAggregator(priceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = aggregator.minAnswer();\n        tokenMaxPrice = aggregator.maxAnswer();\n        oracleBase = 10 ** priceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        //USDC route \n        uint256 value0;\n        uint256 value1;\n        if (token0 == USDC){\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value0 = token0Amount * SCALE_SHIFT;\n            \n            value1 = (token1Amount * oraclePrice) / oracleBase;\n        }\n        //token1 must be USDC \n        else {\n            //hardcode value of USDC at $1\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, USDC);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 oraclePrice = getOraclePrice(priceFeed, tokenMaxPrice, tokenMinPrice);\n            amountOut = (amountOut * oracleBase) / USDC_BASE / HUNDRED; //shift USDC amount to same scale as oracle\n\n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (oraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (oraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < amountOut, \"Price shift low detected\");\n            require(upperBound > amountOut, \"Price shift high detected\");\n\n            value1 = token1Amount * SCALE_SHIFT;\n           \n            value0 = (token0Amount * oraclePrice) / oracleBase;\n        }\n        //Invariant: both value0 and value1 are in ETH scale 18.d.p now\n        //USDC has only 6 decimals so we bring it up to the same scale as other 18d.p ERC20s\n        return(value0 + value1);\n    }\n}"
    },
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_ETH is  DepositReceipt_Base {\n    \n    //Price deviation limit when checking pool exchange rate against Chainlink Oracle\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    //deployed address of WETH on Optimism Mainnet\n    address private constant WETH = 0x4200000000000000000000000000000000000006;\n    \n    //Chainlink oracle sources\n    IAggregatorV3 ETHPriceFeed;\n    IAggregatorV3 tokenPriceFeed;\n    \n    // ten to the power of the number of decimals given by both price feeds\n    uint256 immutable oracleBase;\n    \n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _ETHPriceFeed,\n                address _tokenPriceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory WETHSymbol = abi.encodePacked(\"WETH\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(WETHSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(WETHSymbol), \"One token must be WETH\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n    \n        //fetch details for ETH price feed\n        ETHPriceFeed = IAggregatorV3(_ETHPriceFeed);\n        tokenPriceFeed = IAggregatorV3(_tokenPriceFeed);\n        IAccessControlledOffchainAggregator  ETHaggregator = IAccessControlledOffchainAggregator(ETHPriceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        ETHMinPrice = ETHaggregator.minAnswer();\n        ETHMaxPrice = ETHaggregator.maxAnswer();\n        uint256 ETHOracleDecimals = ETHPriceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n        require(ETHOracleDecimals == tokenPriceFeed.decimals());\n\n        //fetch details for Token price feed\n        \n        IAccessControlledOffchainAggregator  tokenAggregator = IAccessControlledOffchainAggregator(tokenPriceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = tokenAggregator.minAnswer();\n        tokenMaxPrice = tokenAggregator.maxAnswer();\n        // because we have checked both oracles have the same amount of decimals we only store one OracleBase\n        oracleBase = 10 ** ETHOracleDecimals; \n        \n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        \n        uint256 value0;\n        uint256 value1;\n        if (token0 == WETH){\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, WETH);\n            \n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 tokenOraclePrice = getOraclePrice(tokenPriceFeed, tokenMaxPrice, tokenMinPrice);\n            uint256 ETHOraclePrice = getOraclePrice(ETHPriceFeed, ETHMaxPrice, ETHMinPrice);\n            //reduce amountOut to the value of one token in dollars in the same scale as tokenOraclePrice (1e8)\n            uint256 valueOut = amountOut * ETHOraclePrice / HUNDRED / BASE; \n\n            //calculate acceptable deviations from oracle price\n            \n            uint256 lowerBound = (tokenOraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (tokenOraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            \n            require(lowerBound < valueOut, \"Price shift low detected\");\n            require(upperBound > valueOut, \"Price shift high detected\");\n\n            value0 = token0Amount * ETHOraclePrice;\n            \n            value1 = token1Amount * tokenOraclePrice;\n        }\n        //token1 must be WETH\n        else {\n            \n            //check swap value of 100tokens to WETH to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, WETH);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n            uint256 tokenOraclePrice = getOraclePrice(tokenPriceFeed, tokenMaxPrice, tokenMinPrice);\n            uint256 ETHOraclePrice = getOraclePrice(ETHPriceFeed, ETHMaxPrice, ETHMinPrice);\n            //reduce amountOut to the value of one token in dollars in the same scale as tokenOraclePrice (1e8)\n            uint256 valueOut = amountOut * ETHOraclePrice / HUNDRED / BASE; \n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (tokenOraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (tokenOraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < valueOut, \"Price shift low detected\");\n            require(upperBound > valueOut, \"Price shift high detected\");\n\n            value1 = token1Amount * ETHOraclePrice;\n            \n            value0 = token0Amount * tokenOraclePrice;\n        }\n        // because value0 and value1 are in the same scale we can reduce them to 1e18 scale after adding.\n        return((value0 + value1)/oracleBase);\n    }\n}"
    },
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_ETH.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_ETH is  DepositReceipt_Base {\n    \n    //Price deviation limit when checking pool exchange rate against Chainlink Oracle\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    //deployed address of WETH on Optimism Mainnet\n    address private constant WETH = 0x4200000000000000000000000000000000000006;\n    \n    //Chainlink oracle sources\n    IAggregatorV3 ETHPriceFeed;\n    IAggregatorV3 tokenPriceFeed;\n    \n    // ten to the power of the number of decimals given by both price feeds\n    uint256 immutable oracleBase;\n    \n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _ETHPriceFeed,\n                address _tokenPriceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory WETHSymbol = abi.encodePacked(\"WETH\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(WETHSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(WETHSymbol), \"One token must be WETH\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n    \n        //fetch details for ETH price feed\n        ETHPriceFeed = IAggregatorV3(_ETHPriceFeed);\n        tokenPriceFeed = IAggregatorV3(_tokenPriceFeed);\n        IAccessControlledOffchainAggregator  ETHaggregator = IAccessControlledOffchainAggregator(ETHPriceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        ETHMinPrice = ETHaggregator.minAnswer();\n        ETHMaxPrice = ETHaggregator.maxAnswer();\n        uint256 ETHOracleDecimals = ETHPriceFeed.decimals();  //Chainlink USD oracles have 8d.p.\n        require(ETHOracleDecimals == tokenPriceFeed.decimals());\n\n        //fetch details for Token price feed\n        \n        IAccessControlledOffchainAggregator  tokenAggregator = IAccessControlledOffchainAggregator(tokenPriceFeed.aggregator());\n        //fetch the pricefeeds hard limits so we can be aware if these have been reached.\n        tokenMinPrice = tokenAggregator.minAnswer();\n        tokenMaxPrice = tokenAggregator.maxAnswer();\n        // because we have checked both oracles have the same amount of decimals we only store one OracleBase\n        oracleBase = 10 ** ETHOracleDecimals; \n        \n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external override view returns(uint256){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = viewQuoteRemoveLiquidity(_liquidity);\n        \n        uint256 value0;\n        uint256 value1;\n        if (token0 == WETH){\n            //check swap value of 100tokens to USDC to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token1, WETH);\n            \n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n\n            uint256 tokenOraclePrice = getOraclePrice(tokenPriceFeed, tokenMaxPrice, tokenMinPrice);\n            uint256 ETHOraclePrice = getOraclePrice(ETHPriceFeed, ETHMaxPrice, ETHMinPrice);\n            //reduce amountOut to the value of one token in dollars in the same scale as tokenOraclePrice (1e8)\n            uint256 valueOut = amountOut * ETHOraclePrice / HUNDRED / BASE; \n\n            //calculate acceptable deviations from oracle price\n            \n            uint256 lowerBound = (tokenOraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (tokenOraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            \n            require(lowerBound < valueOut, \"Price shift low detected\");\n            require(upperBound > valueOut, \"Price shift high detected\");\n\n            value0 = token0Amount * ETHOraclePrice;\n            \n            value1 = token1Amount * tokenOraclePrice;\n        }\n        //token1 must be WETH\n        else {\n            \n            //check swap value of 100tokens to WETH to protect against flash loan attacks\n            uint256 amountOut; //amount received by trade\n            bool stablePool; //if the traded pool is stable or volatile.\n            (amountOut, stablePool) = router.getAmountOut(HUNDRED_TOKENS, token0, WETH);\n            require(stablePool == stable, \"pricing occuring through wrong pool\" );\n            uint256 tokenOraclePrice = getOraclePrice(tokenPriceFeed, tokenMaxPrice, tokenMinPrice);\n            uint256 ETHOraclePrice = getOraclePrice(ETHPriceFeed, ETHMaxPrice, ETHMinPrice);\n            //reduce amountOut to the value of one token in dollars in the same scale as tokenOraclePrice (1e8)\n            uint256 valueOut = amountOut * ETHOraclePrice / HUNDRED / BASE; \n            //calculate acceptable deviations from oracle price\n            uint256 lowerBound = (tokenOraclePrice * (BASE - ALLOWED_DEVIATION)) / BASE;\n            uint256 upperBound = (tokenOraclePrice * (BASE + ALLOWED_DEVIATION)) / BASE;\n            //because 1 USDC = $1 we can compare its amount directly to bounds\n            require(lowerBound < valueOut, \"Price shift low detected\");\n            require(upperBound > valueOut, \"Price shift high detected\");\n\n            value1 = token1Amount * ETHOraclePrice;\n            \n            value0 = token0Amount * tokenOraclePrice;\n        }\n        // because value0 and value1 are in the same scale we can reduce them to 1e18 scale after adding.\n        return((value0 + value1)/oracleBase);\n    }\n}"
    },
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_USDC.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_Base.sol\";\n\ncontract DepositReceipt_USDC is  DepositReceipt_Base {\n\n    uint256 private constant SCALE_SHIFT = 1e12; //brings USDC 6.d.p up to 18d.p. standard\n    uint256 private constant USDC_BASE = 1e6; //used for division in USDC 6.d.p scale\n    uint256 private constant ALLOWED_DEVIATION = 5e16; //5% in 1e18 / ETH scale\n    address private constant USDC = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607; \n\n    //Chainlink oracle source\n    IAggregatorV3 public priceFeed;\n    // ten to the power of the number of decimals given by the price feed\n    uint256 private immutable oracleBase;\n\n    /**\n    *    @notice Zero address checks done in Templater that generates DepositReceipt and so not needed here.\n    **/\n    constructor(string memory _name, \n                string memory _symbol, \n                address _router, \n                address _token0,\n                address _token1,\n                bool _stable,\n                address _priceFeed) \n                ERC721(_name, _symbol){\n\n        //we dont want the `DEFAULT_ADMIN_ROLE` to exist as this doesn't require a \n        // time delay to add/remove any role and so is dangerous. \n        //So we ignore it and set our weaker admin role.\n        _setupRole(ADMIN_ROLE, msg.sender);\n        currentLastId = 1; //avoid id 0\n        //set up details for underlying tokens\n        router = IRouter(_router);\n\n        //here we check one token is USDC and that the other token has 18d.p.\n        //this prevents pricing mistakes and is defensive design against dev oversight.\n        //Obvious this is not a full check, a malicious ERC20 can set it's own symbol as USDC too \n        //but in practice as only the multi-sig should be deploying via Templater this is not a concern \n        \n        bytes memory USDCSymbol = abi.encodePacked(\"USDC\");\n        bytes memory token0Symbol = abi.encodePacked(IERC20Metadata(_token0).symbol());\n        //equality cannot be checked for strings so we hash them first.\n        if (keccak256(token0Symbol) == keccak256(USDCSymbol)){\n            require( IERC20Metadata(_token1).decimals() == 18, \"Token does not have 18dp\");\n        }\n        else\n        {   \n            bytes memory token1Symbol = abi.encodePacked(IERC20Metadata(_token1).symbol());\n            \n            require( keccak256(token1Symbol) == keccak256(USDCSymbol), \"One token must be USDC\");\n            require( IERC20Metadata(_token0).decimals() == 18, \"Token does not have 18dp\");\n            \n        }\n\n        token0 = _token0;\n        token1 = _token1;\n        stable = _stable;\n        priceFeed = IAggregatorV3(_priceFeed);\n        IAccessContro"
    }
  ]
}