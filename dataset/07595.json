{
  "Title": "[M-01] NameWrapper: Cannot prevent transfer while upgrade even with `CANNOT_TRANSFER` fuse regardless of the upgraded NameWrapper's implementation",
  "Content": "\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L408><br>\n<https://github.com/code-423n4/2022-11-ens/blob/2b0491fee2944f5543e862b1e5d223c9a3701554/contracts/wrapper/NameWrapper.sol#L436>\n\nUpon upgrade to a new `NameWrapper` contract, `owner` of the node will be set to the given `wrappedOwner`. Since the node will be `_burn`ed before calling the upgraded NameWrapper, the upgraded NameWrapper cannot check the old owner. Therefore, no matter the upgraded NameWrapper's implementation, it locks the information to check whether the old owner and newly given `wrappedOwner` are the same. If they are not the same, it means basically transferring the name to a new address.\n\nIn the case of resolver, the upgraded NameWrapper can check the old resolver by querying to the `ENS` registry, and prevent changing it if `CANNOT_SET_RESOLVER` fuse is burned.\n\n### Proof of Concept\n\nBelow is a snippet of the proof of concept. The whole code can be found in [this gist](https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol). And how to run test is in the comment in the gist.\n\nThe proof of concept below demonstrates upgrade process.\n\n```solidity\n// https://gist.github.com/zzzitron/7670730176e35d7b2322bc1f4b9737f0#file-2022-11-ens-versus-poc-t-sol-L215-L243\nfunction testM2TransferWhileUpgrade() public {\n// using the mock for upgrade contract\ndeployNameWrapperUpgrade();\nstring memory node_str = 'vitalik.eth';\nstring memory sub1_full = 'sub1.vitalik.eth';\nstring memory sub1_str = 'sub1';\n(, bytes32 node) = node_str.dnsEncodeName();\n(bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();\n\n// wrap parent and lock\nvm.prank(user1);\nregistrar.setApprovalForAll(address(nameWrapper), true);\nvm.prank(user1);\nnameWrapper.wrapETH2LD('vitalik', user1, type(uint16).max /* all fuses are burned */, address(0));\n// sanity check\n(address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(node));\nassertEq(owner, user1);\nassertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | type(uint16).max);\nassertEq(expiry, 2038123728);\n\n// upgrade as nameWrapper's owner\nvm.prank(root_owner);\nnameWrapper.setUpgradeContract(nameWrapperUpgrade);\nassertEq(address(nameWrapper.upgradeContract()), address(nameWrapperUpgrade));\n\n// user1 calls upgradeETH2LD\nvm.prank(user1);\nnameWrapper.upgradeETH2LD('vitalik', address(123) /* new owner */, address(531) /* resolver */);\n}\n```\n\nEven if the `CANNOT_TRANSFER` fuse is in effect, the user1 can call `upgradeETH2LD` with a new owner.\n\nBefore the `NameWrapper.upgradeETH2LD` calls the new upgraded NameWrapper `upgradeContract`, it calls `_prepareUpgrade`, which burns the node in question. It means, the current `NameWrapper.ownerOf(node)` will be zero.\n\nThe upgraded NameWrapper has only the given `wrappedOwner` which is supplied by the user, which does not guarantee to be the old owner (as the proof of concept above shows). As the ens registry and ETH registrar also do not have any information about the old owner, the upgraded NameWrapper should probably set the owner of the node to the given `wrappedOwner`, even if `CANNOT_TRANSFER` fuse is in effect.\n\nOn contrary to the owner, although `resolver` is given by the user on the `NameWrapper.upgradeETH2LD` function, it is possible to prevent changing it if the `CANNOT_SET_RESOLVER` fuse is burned, by querying to `ENSRegistry`.\n\n```solidity\n// NameWrapper\n\n408     function upgradeETH2LD(\n409         string calldata label,\n410         address wrappedOwner,\n411         address resolver\n412     ) public {\n413         bytes32 labelhash = keccak256(bytes(label));\n414         bytes32 node = _makeNode(ETH_NODE, labelhash);\n415         (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n416\n417         upgradeContract.wrapETH2LD(\n418             label,\n419             wrappedOwner,\n420             fuses,\n421             expiry,\n422             resolver\n423         );\n424     }\n\n840     function _prepareUpgrade(bytes32 node)\n841         private\n842         returns (uint32 fuses, uint64 expiry)\n843     {\n844         if (address(upgradeContract) == address(0)) {\n845             revert CannotUpgrade();\n846         }\n847\n848         if (!canModifyName(node, msg.sender)) {\n849             revert Unauthorised(node, msg.sender);\n850         }\n851\n852         (, fuses, expiry) = getData(uint256(node));\n853\n854         _burn(uint256(node));\n855     }\n```\n\nThe function `NameWrapper.upgrade` has the same problem.\n\n```solidity\n// NameWrapper\n436     function upgrade(\n437         bytes32 parentNode,\n438         string calldata label,\n439         address wrappedOwner,\n440         address resolver\n441     ) public {\n442         bytes32 labelhash = keccak256(bytes(label));\n443         bytes32 node = _makeNode(parentNode, labelhash);\n444         (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n445         upgradeContract.setSubnodeRecord(\n446             parentNode,\n447             label,\n448             wrappedOwner,\n449             resolver,\n450             0,\n451             fuses,\n452             expiry\n453         );\n454     }\n```\n\n### Tools Used\n\nfoundry\n\n### Recommended Mitigation Steps\n\nIf the `CANNOT_TRANSFER` fuse is set, enforce the `wrappedOwner` to be same as the `NameWrapper.ownerOf(node)`.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1336466603):**\n> From further testing, it seems like upgrading will ignore the value provided, here the changed POC\n>\n> ```solidity\n> function testM2TransferWhileUpgrade() public {\n>         // using the mock for upgrade contract\n>         deployNameWrapperUpgrade();\n>         string memory node_str = 'vitalik.eth';\n>         string memory sub1_full = 'sub1.vitalik.eth';\n>         string memory sub1_str = 'sub1';\n>         (, bytes32 node) = node_str.dnsEncodeName();\n>         (bytes memory sub1_dnsname, bytes32 sub1_node) = sub1_full.dnsEncodeName();\n>\n>         // wrap parent and lock\n>         vm.prank(user1);\n>         registrar.setApprovalForAll(address(nameWrapper), true);\n>         vm.prank(user1);\n>         nameWrapper.wrapETH2LD('vitalik', user1, type(uint16).max /* all fuses are burned */, address(0));\n>         // sanity check\n>         (address owner, uint32 fuses, uint64 expiry) = nameWrapper.getData(uint256(node));\n>         assertEq(owner, user1);\n>         assertEq(fuses, PARENT_CANNOT_CONTROL | IS_DOT_ETH | type(uint16).max);\n>         assertEq(expiry, 2038123728);\n>\n>         // upgrade as nameWrapper's owner\n>         vm.prank(root_owner);\n>         nameWrapper.setUpgradeContract(nameWrapperUpgrade);\n>         assertEq(address(nameWrapper.upgradeContract()), address(nameWrapperUpgrade));\n>\n>         // user1 calls upgradeETH2LD\n>         vm.prank(user1);\n>         address newOwner = address(123);\n>         nameWrapper.upgradeETH2LD('vitalik',  newOwner , address(531) /* resolver */);\n>         address secondOwner = nameWrapper.ownerOf(uint256(node));\n>         assertEq(secondOwner, newOwner);\n>     }\n> ```\n>\n> Which reverts as the secondOwner is actually address(0)\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1336468796):**\n> Changing the last line to<br>\n> `assertEq(secondOwner, address(0));`<br>\n> Makes the test pass\n\n**[jefflau (ENS) confirmed and commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1337576844):**\n> > In the case of resolver, the upgraded NameWrapper can check the old resolver by querying to the ENS registry, and prevent changing it if CANNOT_SET_RESOLVER fuse is burned.\n>\n> For this specific case, the public resolver checks for the owner on the NameWrapper. If the NameWrapper needed to be upgraded for any reason, the old resolver would be checking the old NameWrapper, and since the owner would be burnt, they would lock all records. So for this case I think it's reasonable to allow `CANNOT_SET_RESOLVER` to be bypassed in this specific case.\n>\n> > From further testing, it seems like upgrading will ignore the value provided, here the changed POC\n>\n> I think this test is incorrect, you should be checking the new NameWrapper, not the old NameWrapper. I believe this would pass:\n>\n> ```\n> address secondOwner = nameWrapperUpgrade.ownerOf(uint256(node));\n> assertEq(secondOwner, newOwner);\n> ```\n>\n> All things consider - I think the `CANNOT_TRANSFER` restriction that the warden mentioned does make sense.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1340204138):**\n> @jefflau - Took me a while but I have to agree with you, querying ownerOf on the `nameWrapperUpgrade` will return the new owner.\n>\n> I wrote a Bodge to make it work, but would like to flag that the function `wrapETH2LD` uses different parameters, and also the size of fuses is changed (uint32 vs uint16).\n>\n> Am assuming the upgradedWrapper will have a check for the old wrapper being the caller\n>\n> The code changes I made to verify the finding: [here](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1340204138).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1340216291):**\n> Per the discussion above, the Warden has shown how, despite burning the fuse to prevent transfers, due to the implementation of NameWrapper, a node can still be transferred during an upgrade.\n>\n> I believe that, technically this can be prevented by changing the implementation of the upgraded NameWrapper, and because it's reliant on that implementation, I agree with Medium Severity.\n>\n> Performing a check for ownership on the old wrapper, I believe, should offer sufficient mitigation.\n\n**[csanuragjain (warden) commented](https://github.com/code-423n4/2022-11-ens-findings/issues/6#issuecomment-1376898321):**\n> Fixed.<br>\n> The owner value is now derived from getData function which retrieves the current node owner. If it does not matches the assigned owner then CANNOT_TRANSFER fuse is always checked (non expired scenario)\n>\n> ```\n> (address currentOwner, uint32 fuses, uint64 expiry) = _prepareUpgrade(\n>             node\n>         );\n> if (wrappedOwner != currentOwner) {\n>             _preTransferCheck(uint256(node), fuses, expiry);\n>         }\n>\n> // Now _preTransferCheck checks ->\n>\n> if (fuses & CANNOT_TRANSFER != 0) {\n>                 revert OperationProhibited(bytes32(id));\n>             }\n> ```\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-ens",
  "Code": [
    {
      "filename": "contracts/wrapper/NameWrapper.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport {ERC1155Fuse, IERC165} from \"./ERC1155Fuse.sol\";\nimport {Controllable} from \"./Controllable.sol\";\nimport {INameWrapper, CANNOT_UNWRAP, CANNOT_BURN_FUSES, CANNOT_TRANSFER, CANNOT_SET_RESOLVER, CANNOT_SET_TTL, CANNOT_CREATE_SUBDOMAIN, PARENT_CANNOT_CONTROL, CAN_DO_EVERYTHING, IS_DOT_ETH, PARENT_CONTROLLED_FUSES, USER_SETTABLE_FUSES} from \"./INameWrapper.sol\";\nimport {INameWrapperUpgrade} from \"./INameWrapperUpgrade.sol\";\nimport {IMetadataService} from \"./IMetadataService.sol\";\nimport {ENS} from \"../registry/ENS.sol\";\nimport {IBaseRegistrar} from \"../ethregistrar/IBaseRegistrar.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {BytesUtils} from \"./BytesUtils.sol\";\nimport {ERC20Recoverable} from \"../utils/ERC20Recoverable.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror IncompatibleParent();\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror OperationProhibited(bytes32 node);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver,\n    ERC20Recoverable\n{\n    using BytesUtils for bytes;\n\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n    string public constant name = \"NameWrapper\";\n\n    uint64 private constant GRACE_PERIOD = 90 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ETH_LABELHASH =\n        0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            interfaceId == type(IERC721Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 Fuse */\n\n    /**\n     * @notice Gets the owner of a name\n     * @param id Label as a string of the .eth domain to wrap\n     * @return owner The owner of the name\n     */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /**\n     * @notice Gets the data for a name\n     * @param id Namehash of the name\n     * @return owner Owner of the name\n     * @return fuses Fuses of the name\n     * @return expiry Expiry of the name\n     */\n\n    function getData(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64 expiry\n        )\n    {\n        (owner, fuses, expiry) = super.getData(id);\n\n        bytes32 labelhash = _getEthLabelhash(bytes32(id), fuses);\n        if (labelhash != bytes32(0)) {\n            expiry = uint64(registrar.nameExpires(uint256(labelhash))) + GRACE_PERIOD;\n        }\n\n        if (expiry < block.timestamp) {\n            if (fuses & PARENT_CANNOT_CONTROL == PARENT_CANNOT_CONTROL) {\n                owner = address(0);\n            }\n            fuses = 0;\n        }\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     * @param _metadataService The new metadata service\n     */\n\n    function setMetadataService(IMetadataService _metadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _metadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @param tokenId The id of the token\n     * @return string uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!canModifyName(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function canModifyName(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (address owner, uint32 fuses, uint64 expiry) = getData(uint256(node));\n        return (owner == addr || isApprovedForAll(owner, addr)) && (fuses & IS_DOT_ETH == 0 || expiry - GRACE_PERIOD >= block.timestamp);\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label Label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param ownerControlledFuses Initial owner-controlled fuses to set\n     * @param resolver Resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) public override {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        _wrapETH2LD(label, wrappedOwner, ownerControlledFuses, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param ownerControlledFuses Initial owner-controlled fuses to set\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, ownerControlledFuses, resolver);\n    }\n\n    /**\n     * @notice Renews a .eth second-level domain.\n     * @dev Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function renew(\n        uint256 tokenId,\n        uint256 duration\n    ) external override onlyController returns (uint256 expires) {\n        return registrar.renew(tokenId, duration);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver Resolver contract\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        names[node] = name;\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (owner != msg.sender && !ens.isApprovedForAll(owner, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash Labelhash of the .eth domain\n     * @param registrant Sets the owner in the .eth registrar to this address\n     * @param controller Sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address registrant,\n        address controller\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        if (registrant == address(this)) {\n            revert IncorrectTargetOwner(registrant);\n        }\n        _unwrap(_makeNode(ETH_NODE, labelhash), controller);\n        registrar.safeTransferFrom(\n            address(this),\n            registrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode Parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash Labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param controller Sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address controller\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        if (controller == address(0x0) || controller == address(this)) {\n            revert IncorrectTargetOwner(controller);\n        }\n        _unwrap(_makeNode(parentNode, labelhash), controller);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node Namehash of the name\n     * @param ownerControlledFuses Owner-controlled fuses to burn\n     * @return New fuses\n     */\n\n    function setFuses(bytes32 node, uint16 ownerControlledFuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        // owner protected by onlyTokenOwner\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n        _setFuses(node, owner, ownerControlledFuses | oldFuses, expiry);\n        return ownerControlledFuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode Namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver Resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /** \n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode Parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash Labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses Fuses to burn\n     * @param expiry When the name will expire in seconds since the Unix epoch\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        _checkFusesAreSettable(node, fuses);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(uint256(node));\n        // max expiry is set to the expiry of the parent\n        (, uint32 parentFuses, uint64 maxExpiry) = getData(\n            uint256(parentNode)\n        );\n        if (parentNode == ROOT_NODE) {\n            if (!canModifyName(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n        } else {\n            if (!canModifyName(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n        }\n\n        _checkParentFuses(node, fuses, parentFuses);\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode Parent namehash of the subdomain\n     * @param label Label of the subdomain as a string\n     * @param owner New owner in the wrapper\n     * @param fuses Initial fuses for the wrapped subdomain\n     * @param expiry When the name will expire in seconds since the Unix epoch\n     * @return node Namehash of the subdomain\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        _checkFusesAreSettable(node, fuses);\n        bytes memory name = _saveLabel(parentNode, node, label);\n        expiry = _checkParentFusesAndExpiry(parentNode, node, fuses, expiry);\n\n        if (ownerOf(uint256(node)) == address(0)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _wrap(node, name, owner, fuses, expiry);\n        } else {\n            _updateName(parentNode, node, label, owner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param owner new owner in the wrapper\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry When the name will expire in seconds since the Unix epoch\n     * @return node Namehash of the subdomain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        _checkFusesAreSettable(node, fuses);\n        _saveLabel(parentNode, node, label);\n        expiry = _checkParentFusesAndExpiry(parentNode, node, fuses, expiry);\n        if (ownerOf(uint256(node)) == address(0)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _storeNameAndWrap(parentNode, node, label, owner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _updateName(parentNode, node, label, owner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node Namehash of the name to set a record for\n     * @param owner New owner in the registry\n     * @param resolver Resolver contract\n     * @param ttl Time to live in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & IS_DOT_ETH == IS_DOT_ETH) {\n                revert IncorrectTargetOwner(owner);\n            }\n            _unwrap(node, address(0));\n        } else {\n            address oldOwner = ownerOf(uint256(node));\n            _transfer(oldOwner, owner, uint256(node), 1, \"\");\n        }\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node Namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both CANNOT_CREATE_SUBDOMAIN and PARENT_CANNOT_CONTROL and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node Namehash of the name to check\n     * @param labelhash Labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(subnode);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(subnode);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node Namehash of the name\n     * @param fuseMask The fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint16 ownerControlledFuses,\n            address resolver\n        ) = abi.decode(data, (string, address, uint16, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, ownerControlledFuses, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _preTransferCheck(uint256 id, uint32 fuses, uint64 expiry) internal view override returns (bool) {\n        // For this check, treat .eth 2LDs as expiring at the start of the grace period.\n        if(fuses & IS_DOT_ETH == IS_DOT_ETH) {\n            expiry -= GRACE_PERIOD;\n        }\n\n        if(expiry < block.timestamp) {\n            // Transferable if the name was not emancipated\n            if(fuses & PARENT_CANNOT_CONTROL != 0) {\n                revert(\"ERC1155: insufficient balance for transfer\");\n            }\n        } else {\n            // Transferable if CANNOT_TRANSFER is unburned\n            if(fuses & CANNOT_TRANSFER != 0) {\n                revert OperationProhibited(bytes32(id));\n            }\n        }\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        _canFusesBeBurned(node, fuses);\n        address oldOwner = ownerOf(uint256(node));\n        if (oldOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, owner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _storeNameAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, owner, fuses, expiry);\n    }\n\n    function _saveLabel(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label\n    ) internal returns (bytes memory) {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        names[node] = name;\n        return name;\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!canModifyName(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (, fuses, expiry) = getData(uint256(node));\n\n        _burn(uint256(node));\n    }\n\n    function _updateName(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        address oldOwner = ownerOf(uint256(node));\n        bytes memory name = _addLabel(label, names[parentNode]);\n        if (names[node].length == 0) {\n            names[node] = name;\n        }\n        _setFuses(node, oldOwner, fuses, expiry);\n        if (owner == address(0)) {\n            _unwrap(node, address(0));\n        } else {\n            _transfer(oldOwner, owner, uint256(node), 1, \"\");\n        }\n    }\n\n    // wrapper function for stack limit\n    function _checkParentFusesAndExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint32 fuses,\n        uint64 expiry\n    ) internal view returns (uint64) {\n        (, , uint64 oldExpiry) = getData(uint256(node));\n        (, uint32 parentFuses, uint64 maxExpiry) = getData(\n            uint256(parentNode)\n        );\n        _checkParentFuses(node, fuses, parentFuses);\n        return _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n    }\n\n    function _checkParentFuses(\n        bytes32 node,\n        uint32 fuses,\n        uint32 parentFuses\n    ) internal pure {\n        bool isBurningParentControlledFuses = fuses & PARENT_CONTROLLED_FUSES !=\n            0;\n\n        bool parentHasNotBurnedCU = parentFuses & CANNOT_UNWRAP == 0;\n\n        if (isBurningParentControlledFuses && parentHasNotBurnedCU) {\n            revert OperationProhibited(node);\n        }\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) private {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        // hardcode dns-encoded eth string for gas savings\n        bytes memory name = _addLabel(label, \"\\x03eth\\x00\");\n        names[node] = name;\n\n        uint64 expiry = uint64(registrar.nameExpires(uint256(labelhash))) + GRACE_PERIOD;\n\n        _wrap(\n            node,\n            name,\n            wrappedOwner,\n            ownerControlledFuses | PARENT_CANNOT_CONTROL | IS_DOT_ETH,\n            expiry\n        );\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n    }\n\n    function _unwrap(bytes32 node, address owner) private {\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, owner);\n\n        emit NameUnwrapped(node, owner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        // If a non-parent controlled fuse is being burned, check PCC and CU are burnt\n        if (\n            fuses & ~PARENT_CONTROLLED_FUSES != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n\n    function _checkFusesAreSettable(bytes32 node, uint32 fuses) internal pure {\n        if (fuses | USER_SETTABLE_FUSES != USER_SETTABLE_FUSES) {\n            // Cannot directly burn other non-user settable fuses\n            revert OperationProhibited(node);\n        }\n    }\n\n    function _getEthLabelhash(bytes32 node, uint32 fuses)\n        internal\n        view\n        returns (bytes32 labelhash)\n    {\n        if (fuses & IS_DOT_ETH == IS_DOT_ETH) {\n            byt"
    }
  ]
}