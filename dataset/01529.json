{
  "Title": "M-4: `SafeERC20.safeApprove` reverts for changing existing approvals",
  "Content": "# Issue M-4: `SafeERC20.safeApprove` reverts for changing existing approvals \n\nSource: https://github.com/sherlock-audit/2023-06-tokensoft-judging/issues/141 \n\n## Found by \nAkshaySrivastav, Juntao, Musaka, auditsea, blackhole, circlelooper, jah, kutugu, ni8mare\n## Summary\n`SafeERC20.safeApprove` reverts when a non-zero approval is changed to a non-zero approval. The `CrosschainDistributor._setTotal` function tries to change an existing approval to a non-zero value which will revert.\n\n## Vulnerability Detail\nThe safeApprove function has explicit warning:\n```solidity\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n```\nBut still the `_setTotal` use it to change approval amount:\n```solidity\n  function _allowConnext(uint256 amount) internal {\n    token.safeApprove(address(connext), amount);\n  }\n\n  /** Reset Connext allowance when total is updated */\n  function _setTotal(uint256 _total) internal virtual override onlyOwner {\n    super._setTotal(_total);\n    _allowConnext(total - claimed);\n  }\n```\n\n## Impact\nDue to this bug all calls to `setTotal` function of `CrosschainContinuousVestingMerkle` and `CrosschainTrancheVestingMerkle` will get reverted.\n\nTokensoft airdrop protocol is meant to be used by other protocols and the ability to change `total` parameter is an intended offering. This feature will be important for those external protocols due to the different nature & requirement of every airdrop. But this feature will not be usable by airdrop owners due to the incorrect code implementation.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-tokensoft/blob/main/contracts/contracts/claim/abstract/CrosschainDistributor.sol#L35-L45\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider using 'safeIncreaseAllowance' and 'safeDecreaseAllowance' instead of `safeApprove` in `_setTotal`.\n\n\n\n## Discussion\n\n**cr-walker**\n\nGood catch, updating the code to simply set approval to zero first and then reset approval. I don't think any of the reentrancy attacks that `safeApprove()` is worried about are relevant here (neither the owner nor the connect protocol are going to use this to rug the contract, they both have much more direct ways to take tokens if malicious!)\n\n**cr-walker**\n\nFixed by https://github.com/SoftDAO/contracts/pull/12\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/100",
  "Code": [
    {
      "filename": "contracts/contracts/claim/abstract/CrosschainDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { AdvancedDistributor, IERC20 } from './AdvancedDistributor.sol';\nimport { Distributor } from './Distributor.sol';\nimport { IConnext } from '../../interfaces/IConnext.sol';\nimport { ICrosschain } from '../../interfaces/ICrosschain.sol';\n\nabstract contract CrosschainDistributor is AdvancedDistributor, ICrosschain {\n  using SafeERC20 for IERC20;\n\n  IConnext public immutable connext;\n  uint32 public immutable domain;\n\n  /**\n   * @notice Throws if the msg.sender is not connext\n   */\n  modifier onlyConnext() {\n    require(msg.sender == address(connext), '!connext');\n    _;\n  }\n\n  constructor(IConnext _connext, uint256 _total) {\n    connext = _connext;\n    domain = uint32(_connext.domain());\n    _allowConnext(_total);\n  }\n\n  /**\n  @dev allows Connext to withdraw tokens for cross-chain settlement. Connext may withdraw up to\n  the remaining quantity of tokens that can be claimed - the allowance must be set for cross-chain claims.\n  */\n  function _allowConnext(uint256 amount) internal {\n    token.safeApprove(address(connext), amount);\n  }\n\n  /** Reset Connext allowance when total is updated */\n  function _setTotal(uint256 _total) internal virtual override onlyOwner {\n    // effects\n    super._setTotal(_total);\n    // interactions\n    _allowConnext(total - claimed);\n  }\n\n  /** Reset Connext allowance when token is updated */\n  function _setToken(IERC20 _token) internal virtual override nonReentrant onlyOwner {\n    // interaction before effect!\n    // decrease allowance on old token\n    _allowConnext(0);\n\n    // effect\n    super._setToken(_token);\n\n    // interactions\n    // increase allowance on new token\n    _allowConnext(total - claimed);\n  }\n\n  /**\n   * @notice Settles claimed tokens to any valid Connext domain.\n   * @dev permissions are not checked: call only after a valid claim is executed\n   * @param _recipient: the address that will receive tokens\n   * @param _recipientDomain: the domain of the address that will receive tokens\n   * @param _amount: the amount of claims to settle\n   */\n  function _settleClaim(\n    address _beneficiary,\n    address _recipient,\n    uint32 _recipientDomain,\n    uint256 _amount\n  ) internal virtual {\n    bytes32 id;\n    if (_recipientDomain == 0 || _recipientDomain == domain) {\n      token.safeTransfer(_recipient, _amount);\n    } else {\n      id = connext.xcall(\n        _recipientDomain, // destination domain\n        _recipient, // to\n        address(token), // asset\n        _recipient, // delegate, only required for self-execution + slippage\n        _amount, // amount\n        0, // slippage -- assumes no pools on connext\n        bytes('') // calldata\n      );\n    }\n    emit CrosschainClaim(id, _beneficiary, _recipient, _recipientDomain, _amount);\n  }\n}"
    }
  ]
}