{
  "Title": "Witness Data Reader Skips the Last Line if There Is No New Line",
  "Content": "The [`ReadWitnessData`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-chain-ops/crossdomain/witness.go#L81-L142) function of OP-Chain-Ops utilizes `bufio`'s [`NewReader`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-chain-ops/crossdomain/witness.go#L88) to iterate through the file and retrieve all entries. To read each line, the function employs [`ReadString`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-chain-ops/crossdomain/witness.go#L92), which reads until a new line is encountered. However, this approach poses an issue â€“ if the last line of the file lacks a new line character (as is the case for text file `witness.txt`), the reader will trigger an `EOF` error, [causing an early break from the loop](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-chain-ops/crossdomain/witness.go#L94-L96) failing to read the last line.\n\n\nConsider redesigning the function logic in such a way the last line will be read correctly even if it does not end with a new line.\n\n\n***Update:** Acknowledged, not resolved. The Mantle team stated:*\n\n\n\n> *Acknowledged, only used for upgrading, will not fix it.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "op-chain-ops/crossdomain/witness.go",
      "content": "package crossdomain\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/bindings\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/hexutil\"\n)\n\n// SentMessage represents an entry in the JSON file that is created by\n// the `migration-data` package. Each entry represents a call to the\n// `LegacyMessagePasser`. The `who` should always be the\n// `L2CrossDomainMessenger` and the `msg` should be an abi encoded\n// `relayMessage(address,address,bytes,uint256)`\ntype SentMessage struct {\n\tWho common.Address `json:\"who\"`\n\tMsg hexutil.Bytes  `json:\"msg\"`\n}\n\n// NewSentMessageFromJSON will read a JSON file from disk given a path to the JSON\n// file. The JSON file this function reads from disk is an output from the\n// `migration-data` package.\nfunc NewSentMessageFromJSON(path string) ([]*SentMessage, error) {\n\tfile, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot find sent message json at %s: %w\", path, err)\n\t}\n\n\tvar j []*SentMessage\n\tif err := json.Unmarshal(file, &j); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn j, nil\n}\n\n// decodeWitnessCalldata abi decodes the calldata encoded in the input witness\n// file. It errors if the 4 byte selector is not specifically for `passMessageToL1`.\n// It also errors if the abi decoding fails.\nfunc decodeWitnessCalldata(msg []byte) ([]byte, error) {\n\tabi, err := bindings.LegacyMessagePasserMetaData.GetAbi()\n\tif err != nil {\n\t\tpanic(\"should always be able to get message passer abi\")\n\t}\n\n\tif size := len(msg); size < 4 {\n\t\treturn nil, fmt.Errorf(\"message too short: %d\", size)\n\t}\n\n\tmethod, err := abi.MethodById(msg[:4])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif method.Sig != \"passMessageToL1(bytes)\" {\n\t\treturn nil, fmt.Errorf(\"unknown method: %s\", method.Name)\n\t}\n\n\tout, err := method.Inputs.Unpack(msg[4:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcast, ok := out[0].([]byte)\n\tif !ok {\n\t\tpanic(\"should always be able to cast type []byte\")\n\t}\n\treturn cast, nil\n}\n\n// ReadWitnessData will read messages and addresses from a raw l2geth state\n// dump file.\nfunc ReadWitnessData(path string) ([]*SentMessage, OVMETHAddresses, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"cannot open witness data file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\trd := bufio.NewReader(f)\n\tvar witnesses []*SentMessage\n\taddresses := make(map[common.Address]bool)\n\tfor {\n\t\tline, err := rd.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tline = strings.TrimPrefix(line, \"\\n\")\n\t\tline = strings.TrimSuffix(line, \"\\n\")\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tsplits := strings.Split(line, \"|\")\n\t\tif len(splits) < 2 {\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid line: %s\", line)\n\t\t}\n\n\t\tswitch splits[0] {\n\t\tcase \"MSG\":\n\t\t\tif len(splits) != 3 {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"invalid line: %s\", line)\n\t\t\t}\n\n\t\t\tmsg := splits[2]\n\t\t\t// Make sure that the witness data has a 0x prefix\n\t\t\tif !strings.HasPrefix(msg, \"0x\") {\n\t\t\t\tmsg = \"0x\" + msg\n\t\t\t}\n\n\t\t\tmsgB := hexutil.MustDecode(msg)\n\n\t\t\t// Skip any errors\n\t\t\tcalldata, err := decodeWitnessCalldata(msgB)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"cannot decode witness calldata\", \"err\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\twitnesses = append(witnesses, &SentMessage{\n\t\t\t\tWho: common.HexToAddress(splits[1]),\n\t\t\t\tMsg: calldata,\n\t\t\t})\n\t\tcase \"ETH\":\n\t\t\taddresses[common.HexToAddress(splits[1])] = true\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid line: %s\", line)\n\t\t}\n\t}\n\n\treturn witnesses, addresses, nil\n}\n\n// ToLegacyWithdrawal will convert a SentMessageJSON to a LegacyWithdrawal\n// struct. This is useful because the LegacyWithdrawal struct has helper\n// functions on it that can compute the withdrawal hash and the storage slot.\nfunc (s *SentMessage) ToLegacyWithdrawal() (*LegacyWithdrawal, error) {\n\tdata := make([]byte, len(s.Who)+len(s.Msg))\n\tcopy(data, s.Msg)\n\tcopy(data[len(s.Msg):], s.Who[:])\n\n\tvar w LegacyWithdrawal\n\tif err := w.Decode(data); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &w, nil\n}\n\n// OVMETHAddresses represents a list of addresses that interacted with\n// the ERC20 representation of ether in the pre-bedrock system.\ntype OVMETHAddresses map[common.Address]bool\n\n// NewAddresses will read an addresses.json file from the filesystem.\nfunc NewAddresses(path string) (OVMETHAddresses, error) {\n\tfile, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot find addresses json at %s: %w\", path, err)\n\t}\n\n\tvar addresses []common.Address\n\tif err := json.Unmarshal(file, &addresses); err != nil {\n\t\treturn nil, err\n\t}\n\n\tovmeth := make(OVMETHAddresses)\n\tfor _, addr := range addresses {\n\t\tovmeth[addr] = true\n\t}\n\n\treturn ovmeth, nil\n}\n\n// Allowance represents the allowances that were set in the\n// legacy ERC20 representation of ether\ntype Allowance struct {\n\tFrom common.Address `json:\"fr\"`\n\tTo   common.Address `json:\"to\"`\n}\n\n// NewAllowances will read the ovm-allowances.json from the file system.\nfunc NewAllowances(path string) ([]*Allowance, error) {\n\tfile, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot find allowances json at %s: %w\", path, err)\n\t}\n\n\tvar allowances []*Allowance\n\tif err := json.Unmarshal(file, &allowances); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn allowances, nil\n}\n\n// MigrationData represents all of the data required to do a migration\ntype MigrationData struct {\n\t// OvmAddresses represents the set of addresses that interacted with the\n\t// LegacyERC20ETH contract before the evm equivalence upgrade\n\tOvmAddresses OVMETHAddresses\n\t// EvmAddresses represents the set of addresses that interacted with the\n\t// LegacyERC20ETH contract after the evm equivalence upgrade\n\tEvmAddresses OVMETHAddresses\n\t// OvmAllowances represents the set of allowances in the LegacyERC20ETH from\n\t// before the evm equivalence upgrade\n\tOvmAllowances []*Allowance\n\t// OvmMessages represents the set of withdrawals through the\n\t// L2CrossDomainMessenger from before the evm equivalence upgrade\n\tOvmMessages []*SentMessage\n\t// OvmMessages represents the set of withdrawals through the\n\t// L2CrossDomainMessenger from after the evm equivalence upgrade\n\tEvmMessages []*SentMessage\n}\n\nfunc (m *MigrationData) ToWithdrawals() (DangerousUnfilteredWithdrawals, []InvalidMessage, error) {\n\tmessages := make(DangerousUnfilteredWithdrawals, 0)\n\tinvalidMessages := make([]InvalidMessage, 0)\n\tfor _, msg := range m.OvmMessages {\n\t\twd, err := msg.ToLegacyWithdrawal()\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"error serializing OVM message: %w\", err)\n\t\t}\n\t\tmessages = append(messages, wd)\n\t}\n\tfor _, msg := range m.EvmMessages {\n\t\twd, err := msg.ToLegacyWithdrawal()\n\t\tif err != nil {\n\t\t\tlog.Warn(\"Discovered mal-formed withdrawal\", \"who\", msg.Who, \"data\", msg.Msg)\n\t\t\tinvalidMessages = append(invalidMessages, InvalidMessage(*msg))\n\t\t\tcontinue\n\t\t}\n\t\tmessages = append(messages, wd)\n\t}\n\treturn messages, invalidMessages, nil\n}\n\nfunc (m *MigrationData) Addresses() []common.Address {\n\taddresses := make([]common.Address, 0)\n\tfor addr := range m.EvmAddresses {\n\t\taddresses = append(addresses, addr)\n\t}\n\tfor addr := range m.OvmAddresses {\n\t\taddresses = append(addresses, addr)\n\t}\n\treturn addresses\n}\n\n// L1SystemContracts represents a sets of system contracts on L1\ntype L1SystemContracts struct {\n\tL1StandardBridgeProxy       common.Address `json:\"l1_standard_bridge_proxy\"`\n\tL1CrossDomainMessengerProxy common.Address `json:\"l1_cross_domain_messenger_proxy\"`\n\tL1ERC721BridgeProxy         common.Address `json:\"l1_erc721_bridge_proxy\"`\n\tSystemConfigProxy           common.Address `json:\"system_config_proxy\"`\n\tOptimismPortalProxy         common.Address `json:\"optimism_portal_proxy\"`\n}\n\n// NewL1SystemContracts will read the l1-system-contracts.json from the file system.\nfunc NewL1SystemContracts(path string) (*L1SystemContracts, error) {\n\tfile, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot find l1-system-contracts json at %s: %w\", path, err)\n\t}\n\n\tvar l1SystemContracts L1SystemContracts\n\tif err := json.Unmarshal(file, &l1SystemContracts); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &l1SystemContracts, nil\n}"
    }
  ]
}