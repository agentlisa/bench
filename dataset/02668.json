{
  "Title": "Imprecise function name",
  "Content": "In the `DesignatedVotingV2` contract, the [`retrieveRewards`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol#L109) function name suggests that the caller will gain possession of the rewards; this assumption is further reinforced by the docstring’s [description of the return value](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol#L107) as “amount of rewards that the user should receive”. However, instead of transferring rewards to the user, the `retrieveRewards` function restakes user’s rewards.\n\n\nTo avoid confusion, consider renaming the `retrieveRewards` function to `withdrawAndRestakeRewards` or some other name that more accurately describes its behavior.\n\n\n**Update:** *Fixed as of commit [`284c6842ed05b13cfdc82cb3b5dd897507696e8f`](https://github.com/UMAprotocol/protocol/pull/4071/commits/284c6842ed05b13cfdc82cb3b5dd897507696e8f) in [pull request #4071](https://github.com/UMAprotocol/protocol/pull/4071).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/MultiCaller.sol\";\nimport \"../../common/implementation/Stakeable.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/VotingV2Interface.sol\";\nimport \"./Constants.sol\";\n\n/**\n * @title Proxy to allow voting from another address.\n * @dev Allows a UMA token holder to designate another address to vote on their behalf.\n * Each voter must deploy their own instance of this contract.\n */\ncontract DesignatedVotingV2 is Stakeable, MultiCaller {\n    /****************************************\n     *    INTERNAL VARIABLES AND STORAGE    *\n     ****************************************/\n\n    enum Roles {\n        Owner, // Can set the Voter role. Is also permanently permissioned as the minter role.\n        Voter // Can vote through this contract.\n    }\n\n    // Reference to the UMA Finder contract, allowing Voting upgrades to be performed\n    // without requiring any calls to this contract.\n    FinderInterface private finder;\n\n    /**\n     * @notice Construct the DesignatedVoting contract.\n     * @param finderAddress keeps track of all contracts within the system based on their interfaceName.\n     * @param ownerAddress address of the owner of the DesignatedVoting contract.\n     * @param voterAddress address to which the owner has delegated their voting power.\n     */\n    constructor(\n        address finderAddress,\n        address ownerAddress,\n        address voterAddress\n    ) {\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), ownerAddress);\n        _createExclusiveRole(uint256(Roles.Voter), uint256(Roles.Owner), voterAddress);\n        _setWithdrawRole(uint256(Roles.Owner));\n        _setStakeRole(uint256(Roles.Owner));\n\n        finder = FinderInterface(finderAddress);\n    }\n\n    /****************************************\n     *   VOTING AND REWARD FUNCTIONALITY    *\n     ****************************************/\n\n    /**\n     * @notice Forwards a commit to Voting.\n     * @param identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param hash the keccak256 hash of the price you want to vote for and a random integer salt value.\n     */\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingContract().commitVote(identifier, time, ancillaryData, hash);\n    }\n\n    /**\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingContract().commitAndEmitEncryptedVote(identifier, time, ancillaryData, hash, encryptedVote);\n    }\n\n    /**\n     * @notice Forwards a reveal to Voting.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price used along with the `salt` to produce the `hash` during the commit phase.\n     * @param salt used along with the `price` to produce the `hash` during the commit phase.\n     */\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingContract().revealVote(identifier, time, price, ancillaryData, salt);\n    }\n\n    /**\n     * @notice Forwards a reward retrieval to Voting.\n     * @dev Rewards are added to the tokens already held by this contract.\n     * @return amount of rewards that the user should receive.\n     */\n    function retrieveRewards() public onlyRoleHolder(uint256(Roles.Voter)) returns (uint256) {\n        StakerInterface voting = StakerInterface(address(_getVotingContract()));\n        uint256 rewardsMinted = voting.withdrawRewards();\n        IERC20(address(voting.votingToken())).approve(address(voting), rewardsMinted);\n        voting.stake(rewardsMinted);\n    }\n\n    function _getVotingContract() private view returns (VotingV2Interface) {\n        return VotingV2Interface(finder.getImplementationAddress(OracleInterfaces.Oracle));\n    }\n}"
    }
  ]
}