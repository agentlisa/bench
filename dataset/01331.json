{
  "Title": "Spender can front-run calls to modify token allowances, resulting in DoS and/or spending more than was intended",
  "Content": "**Description:** When updating the allowance for a spender that is less than the value currently set, a well-known race condition allows the spender to spend more than the caller intended by front-running the transaction that performs this update. Due to the nature of the `ERC20::approve` implementation and [other](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ApprovalFacet.sol#L46-L54) [variants](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L104-L110) [used](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/MarketplaceFacet.sol#L244-L252) within the Beanstalk system, which update the mapping in storage corresponding to the given allowance, the spender can spend both the existing allowance plus any 'additional' allowance set by the in-flight transaction.\n\nFor example, consider the scenario:\n* Alice approves Bob 100 tokens.\n* Alice later decides to decrease this to 50.\n* Bob sees this transaction in the mempool and front-runs, spending his 100 token allowance.\n* Alice's transaction executes, and Bob's allowance is updated to 50.\n* Bob can now spend an additional 50 tokens, resulting in a total of 150 rather than the maximum of 50 as intended by Alice.\n\nSpecific functions named `decreaseTokenAllowance`, intended to decrease approvals for a token spender, have been introduced to both the [`TokenFacet`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L133-L154) and the [`ApprovalFacet`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/ApprovalFacet.sol#L84-L93). [`PodTransfer::decrementAllowancePods`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/market/MarketplaceFacet/PodTransfer.sol#L87-L98) similarly exists for the Pod Marketplace.\n\nThe issue, however, with these functions is that they are still susceptible to front-running in the sense that a malicious spender could force their execution to revert, violating the intention of the caller to decrease their allowance as they continue to spend that which is currently set. Rather than simply setting the allowance to zero if the caller passes an amount to subtract that is larger than the current allowance, these functions halt execution and revert. This is due to the following line of shared logic:\n\n```solidity\nrequire(\n    currentAllowance >= subtractedValue,\n    \"Silo: decreased allowance below zero\"\n);\n```\n\nConsider the following scenario:\n* Alice approves Bob 100 tokens.\n* Alice later decides to decrease this to 50.\n* Bob sees this transaction in the mempool and front-runs, spending 60 of his 100 token allowance.\n* Alice's transaction executes, but reverts given Bob's allowance is now 40.\n* Bob can now spend the remaining 40 tokens, resulting in a total of 100 rather than the decreased amount of 50 as intended by Alice.\n\nOf course, in this scenario, Bob could have just as easily front-run Alice's transaction and spent his entire existing allowance; however, the fact that he is able to perform a denial-of-service attack results in a degraded user experience. Similar to setting maximum approvals, these functions should handle maximum approval revocations to mitigate against this issue.\n\n**Impact:** Requiring that the intended subtracted allowance does not exceed the current allowance results in a degraded user experience and, more significantly, their loss of funds due to a different route to the same approval front-running attack vector.\n\n**Recommended Mitigation:** Set the allowance to zero if the intended subtracted value exceeds the current allowance.\n\n\\clearpage",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/silo/ApprovalFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"contracts/C.sol\";\nimport \"contracts/libraries/Silo/LibSilo.sol\";\nimport \"contracts/libraries/Silo/LibTokenSilo.sol\";\nimport \"contracts/libraries/Silo/LibSiloPermit.sol\";\nimport \"contracts/libraries/Silo/LibLegacyTokenSilo.sol\";\nimport \"./SiloFacet/Silo.sol\";\nimport \"./SiloFacet/TokenSilo.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"contracts/libraries/Convert/LibConvert.sol\";\nimport \"../ReentrancyGuard.sol\";\n\n/**\n * @author publius, pizzaman1337\n * @title Handles Approval related functions for the Silo\n **/\ncontract ApprovalFacet is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    event DepositApproval(\n        address indexed owner,\n        address indexed spender,\n        address token,\n        uint256 amount\n    );\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n\n    //////////////////////// APPROVE ////////////////////////\n\n    /** \n     * @notice Approve `spender` to Transfer Deposits for `msg.sender`.     \n     *\n     * Sets the allowance to `amount`.\n     * \n     * @dev Gas optimization: We neglect to check whether `token` is actually\n     * whitelisted. If a token is not whitelisted, it cannot be Deposited,\n     * therefore it cannot be Transferred.\n     */\n    function approveDeposit(\n        address spender,\n        address token,\n        uint256 amount\n    ) external payable nonReentrant {\n        require(spender != address(0), \"approve from the zero address\");\n        require(token != address(0), \"approve to the zero address\");\n        LibSiloPermit._approveDeposit(msg.sender, spender, token, amount);\n    }\n\n    /** \n     * @notice Increase the Transfer allowance for `spender`.\n     * \n     * @dev Gas optimization: We neglect to check whether `token` is actually\n     * whitelisted. If a token is not whitelisted, it cannot be Deposited,\n     * therefore it cannot be Transferred.\n     */\n    function increaseDepositAllowance(\n        address spender,\n        address token,\n        uint256 addedValue\n    ) public virtual nonReentrant returns (bool) {\n        LibSiloPermit._approveDeposit(\n            msg.sender,\n            spender,\n            token,\n            depositAllowance(msg.sender, spender, token).add(addedValue)\n        );\n        return true;\n    }\n\n    /** \n     * @notice Decrease the Transfer allowance for `spender`.\n     * \n     * @dev Gas optimization: We neglect to check whether `token` is actually\n     * whitelisted. If a token is not whitelisted, it cannot be Deposited,\n     * therefore it cannot be Transferred.\n     */\n    function decreaseDepositAllowance(\n        address spender,\n        address token,\n        uint256 subtractedValue\n    ) public virtual nonReentrant returns (bool) {\n        uint256 currentAllowance = depositAllowance(msg.sender, spender, token);\n        require(currentAllowance >= subtractedValue, \"Silo: decreased allowance below zero\");\n        LibSiloPermit._approveDeposit(msg.sender, spender, token, currentAllowance.sub(subtractedValue));\n        return true;\n    }\n\n    //////////////////////// PERMIT ////////////////////////\n\n    /*\n     * Farm balances and silo deposits support EIP-2612 permits, \n     * which allows Farmers to delegate use of their Farm balances \n     * through permits without the need for a separate transaction.\n     * https://eips.ethereum.org/EIPS/eip-2612 \n     */\n    \n    /** \n     * @notice permits multiple deposits.\n     * @param owner address to give permit\n     * @param spender address to permit\n     * @param tokens array of ERC20s to permit\n     * @param values array of amount (corresponding to tokens) to permit\n     * @param deadline expiration of signature (unix time) \n     * @param v recovery id\n     * @param r ECDSA signature output\n     * @param s ECDSA signature output\n     */\n    function permitDeposits(\n        address owner,\n        address spender,\n        address[] calldata tokens,\n        uint256[] calldata values,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable nonReentrant {\n        LibSiloPermit.permits(owner, spender, tokens, values, deadline, v, r, s);\n        for (uint256 i; i < tokens.length; ++i) {\n            LibSiloPermit._approveDeposit(owner, spender, tokens[i], values[i]);\n        }\n    }\n\n    /** \n     * @notice Increases the Deposit Transfer allowance of `spender`.\n     * \n     * @param owner address to give permit\n     * @param spender address to permit\n     * @param token ERC20 to permit\n     * @param value amount to permit\n     * @param deadline expiration of signature (unix time) \n     * @param v recovery id\n     * @param r ECDSA signature output\n     * @param s ECDSA signature output\n     */\n    function permitDeposit(\n        address owner,\n        address spender,\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable nonReentrant {\n        LibSiloPermit.permit(owner, spender, token, value, deadline, v, r, s);\n        LibSiloPermit._approveDeposit(owner, spender, token, value);\n    }\n\n    /** \n     * @notice Returns the current nonce for Deposit permits.\n     */ \n    function depositPermitNonces(address owner) public view virtual returns (uint256) {\n        return LibSiloPermit.nonces(owner);\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    function depositPermitDomainSeparator() external view returns (bytes32) {\n        return LibSiloPermit._domainSeparatorV4();\n    }\n\n\n    /**\n     * @notice Returns how much of a `token` Deposit that `spender` can transfer on behalf of `owner`.\n     * @param owner The account that has given `spender` approval to transfer Deposits. \n     * @param spender The address (contract or EOA) that is allowed to transfer Deposits on behalf of `owner`.\n     * @param token Whitelisted ERC20 token.\n     */\n    function depositAllowance(\n        address owner,\n        address spender,\n        address token\n    ) public view virtual returns (uint256) {\n        return s.a[owner].depositAllowances[spender][token];\n    }\n\n    // ERC1155 Approvals\n    function setApprovalForAll(\n        address spender, \n        bool approved\n    ) external {\n        s.a[msg.sender].isApprovedForAll[spender] = approved;\n        emit ApprovalForAll(msg.sender, spender, approved);\n    }\n\n    function isApprovedForAll(\n        address _owner, \n        address _operator\n    ) external view returns (bool) {\n        return s.a[_owner].isApprovedForAll[_operator];\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/farm/TokenFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC1155Receiver} from \"contracts/interfaces/IERC1155Receiver.sol\";\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/Token/LibWeth.sol\";\nimport \"contracts/libraries/Token/LibEth.sol\";\nimport \"contracts/libraries/Token/LibTokenPermit.sol\";\nimport \"contracts/libraries/Token/LibTokenApprove.sol\";\nimport \"../AppStorage.sol\";\nimport \"../ReentrancyGuard.sol\";\n\n/**\n * @author Publius\n * @title TokenFacet handles transfers of assets\n */\ncontract TokenFacet is IERC1155Receiver, ReentrancyGuard {\n    struct Balance {\n        uint256 internalBalance;\n        uint256 externalBalance;\n        uint256 totalBalance;\n    }\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    event InternalBalanceChanged(\n        address indexed user,\n        IERC20 indexed token,\n        int256 delta\n    );\n\n     event TokenApproval(\n        address indexed owner,\n        address indexed spender,\n        IERC20 token,\n        uint256 amount\n    );\n\n    //////////////////////// Transfer ////////////////////////\n\n    /**\n     * @notice transfers a token from msg.sender to `recipient`.\n     * @dev enables transfers between internal and external balances.\n     * \n     * @param token The token to transfer.\n     * @param recipient The recipient of the transfer.\n     * @param amount The amount to transfer.\n     * @param fromMode The source of token from the sender. See {LibTransfer.From}.\n     * @param toMode The destination of token to the recipient. See {LibTransfer.To}.\n     */\n    function transferToken(\n        IERC20 token,\n        address recipient,\n        uint256 amount,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable {\n        LibTransfer.transferToken(\n            token,\n            msg.sender,\n            recipient,\n            amount,\n            fromMode,\n            toMode\n        );\n    }\n\n    /**\n     * @notice transfers a token from `sender` to an `recipient` Internal balance.\n     * @dev differs from transferToken as it does not use msg.sender.\n     */\n    function transferInternalTokenFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount,\n        LibTransfer.To toMode\n    ) external payable nonReentrant {\n        LibTransfer.transferToken(\n            token,\n            sender,\n            recipient,\n            amount,\n            LibTransfer.From.INTERNAL,\n            toMode\n        );\n\n        if (sender != msg.sender) {\n            LibTokenApprove.spendAllowance(sender, msg.sender, token, amount);\n        }\n    }\n\n    //////////////////////// Transfer ////////////////////////\n\n    /**\n     * @notice approves a token for a spender.\n     * @dev this approves a token for both internal and external balances.\n     */\n    function approveToken(\n        address spender,\n        IERC20 token,\n        uint256 amount\n    ) external payable nonReentrant {\n        LibTokenApprove.approve(msg.sender, spender, token, amount);\n    }\n\n    /**\n     * @notice increases approval for a token for a spender.\n     */\n    function increaseTokenAllowance(\n        address spender,\n        IERC20 token,\n        uint256 addedValue\n    ) public virtual nonReentrant returns (bool) {\n        LibTokenApprove.approve(\n            msg.sender,\n            spender,\n            token,\n            LibTokenApprove.allowance(msg.sender, spender, token).add(addedValue)\n        );\n        return true;\n    }\n\n    \n    /**\n     * @notice decreases approval for a token for a spender.\n     */\n    function decreaseTokenAllowance(\n        address spender,\n        IERC20 token,\n        uint256 subtractedValue\n    ) public virtual nonReentrant returns (bool) {\n        uint256 currentAllowance = LibTokenApprove.allowance(\n            msg.sender,\n            spender,\n            token\n        );\n        require(\n            currentAllowance >= subtractedValue,\n            \"Silo: decreased allowance below zero\"\n        );\n        LibTokenApprove.approve(\n            msg.sender,\n            spender,\n            token,\n            currentAllowance.sub(subtractedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @notice returns the allowance for a token for a spender.\n     */\n    function tokenAllowance(\n        address account,\n        address spender,\n        IERC20 token\n    ) public view virtual returns (uint256) {\n        return LibTokenApprove.allowance(account, spender, token);\n    }\n\n    //////////////////////// Permit ////////////////////////\n\n    /**\n     * @notice approves a token for a spender using EIP2612.\n     */\n    function permitToken(\n        address owner,\n        address spender,\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable nonReentrant {\n        LibTokenPermit.permit(owner, spender, token, value, deadline, v, r, s);\n        LibTokenApprove.approve(owner, spender, IERC20(token), value);\n    }\n\n    /**\n     * @notice returns the current permit nonce for a token for an owner.\n     */\n    function tokenPermitNonces(address owner)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return LibTokenPermit.nonces(owner);\n    }\n\n    //////////////////////// ERC1155Reciever ////////////////////////\n\n    /**\n     * @notice ERC1155Reciever function that allows the silo to receive ERC1155 tokens.\n     * \n     * @dev as ERC1155 deposits are not accepted yet, \n     * this function will revert.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(\"Silo: ERC1155 deposits are not accepted yet.\");\n    }\n\n    /**\n     * @notice onERC1155BatchReceived function that allows the silo to receive ERC1155 tokens.\n     * \n     * @dev as ERC1155 deposits are not accepted yet, \n     * this function will revert.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(\"Silo: ERC1155 deposits are not accepted yet.\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function tokenPermitDomainSeparator() external view returns (bytes32) {\n        return LibTokenPermit._domainSeparatorV4();\n    }\n\n    //////////////////////// WETH ////////////////////////\n\n    /**\n     * @notice wraps ETH into WETH.\n     */\n    function wrapEth(uint256 amount, LibTransfer.To mode) external payable {\n        LibWeth.wrap(amount, mode);\n        LibEth.refundEth();\n    }\n\n    /**\n     * @notice unwraps WETH into ETH.\n     */\n    function unwrapEth(uint256 amount, LibTransfer.From mode) external payable {\n        LibWeth.unwrap(amount, mode);\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @notice returns the internal balance of a token for an account.\n     */\n    function getInternalBalance(address account, IERC20 token)\n        public\n        view\n        returns (uint256 balance)\n    {\n        balance = LibBalance.getInternalBalance(account, token);\n    }\n\n    /**\n     * @notice returns the internal balances of tokens for an account.\n     */\n    function getInternalBalances(address account, IERC20[] memory tokens)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ++i) {\n            balances[i] = getInternalBalance(account, tokens[i]);\n        }\n    }\n\n    // External\n\n    /**\n     * @notice returns the external balance of a token for an account.\n     */\n    function getExternalBalance(address account, IERC20 token)\n        public\n        view\n        returns (uint256 balance)\n    {\n        balance = token.balanceOf(account);\n    }\n\n    /**\n     * @notice returns the external balances of tokens for an account.\n     */\n    function getExternalBalances(address account, IERC20[] memory tokens)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ++i) {\n            balances[i] = getExternalBalance(account, tokens[i]);\n        }\n    }\n\n\n    /**\n     * @notice returns the total balance (internal and external) \n     * of a token \n     */\n    function getBalance(address account, IERC20 token)\n        public\n        view\n        returns (uint256 balance)\n    {\n        balance = LibBalance.getBalance(account, token);\n    }\n\n    /**\n     * @notice returns the total balances (internal and external) \n     * of a token for an account.\n     */\n    function getBalances(address account, IERC20[] memory tokens)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ++i) {\n            balances[i] = getBalance(account, tokens[i]);\n        }\n    }\n\n    /**\n     * @notice returns the total balance (internal and external) \n     * of a token, in a balance struct (internal, external, total).\n     */\n    function getAllBalance(address account, IERC20 token)\n        public\n        view\n        returns (Balance memory b)\n    {\n        b.internalBalance = getInternalBalance(account, token);\n        b.externalBalance = getExternalBalance(account, token);\n        b.totalBalance = b.internalBalance.add(b.externalBalance);\n    }\n\n    /**\n     * @notice returns the total balance (internal and external) \n     * of a token, in a balance struct (internal, external, total).\n     */\n    function getAllBalances(address account, IERC20[] memory tokens)\n        external\n        view\n        returns (Balance[] memory balances)\n    {\n        balances = new Balance[](tokens.length);\n        for (uint256 i; i < tokens.length; ++i) {\n            balances[i] = getAllBalance(account, tokens[i]);\n        }\n    }\n}"
    }
  ]
}