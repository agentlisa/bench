{
  "Title": "[G-01] Using immutable on variables that are only set in the constructor and never after (Save 8400 Gas)",
  "Content": "\n**This instance was missed by the bot.**\n\n**Gas per instance: 2.1K**<br>\n**Total Instances: 4**<br>\nTotal Gas Saved: `2.1 * 4 = 8400 Gas`\n\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV3LiquidityAmo.sol#L68-L72\n\n```solidity\nFile: /contracts/amo/UniV3LiquidityAmo.sol\n68:  // Rdpx address\n69:  address public rdpx;\n\n71:  // RdpxV2Core address\n72:  address public rdpxV2Core;\n```\n\n```diff\n   // Rdpx address\n-  address public rdpx;\n+  address public immutable rdpx;\n\n   // RdpxV2Core address\n-  address public rdpxV2Core;\n+  address public immutable rdpxV2Core;\n\n```\n\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L46\n```solidity\nFile: /contracts/perp-vault/PerpetualAtlanticVaultLP.sol\n46:  IPerpetualAtlanticVault public perpetualAtlanticVault;\n```\n\nhttps://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L66-L70\n```solidity\nFile: /contracts/perp-vault/PerpetualAtlanticVaultLP.sol\n66:  /// @dev address of rdpx token\n67:  address public rdpx;\n```\n\n```diff\n   /// @dev address of rdpx token\n-  address public rdpx;\n+  address public immutable rdpx;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/amo/UniV3LiquidityAmo.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { TransferHelper } from \"../libraries/TransferHelper.sol\";\nimport { IRdpxV2Core } from \"../core/IRdpxV2Core.sol\";\n\n// Uniswamp V3\nimport \"../uniswap_V3/IUniswapV3Factory.sol\";\nimport \"../uniswap_V3/libraries/TickMath.sol\";\nimport \"../uniswap_V3/libraries/LiquidityAmounts.sol\";\nimport \"../uniswap_V3/periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../uniswap_V3/IUniswapV3Pool.sol\";\nimport \"../uniswap_V3/ISwapRouter.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\nabstract contract OracleLike {\n  function read() external view virtual returns (uint);\n\n  function uniswapPool() external view virtual returns (address);\n}\n\ncontract UniV3LiquidityAMO is AccessControl, ERC721Holder {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20WithBurn;\n\n  /* ========== STATE VARIABLES ========== */\n\n  // Uniswap v3\n  IUniswapV3Factory public univ3_factory;\n  INonfungiblePositionManager public univ3_positions;\n  ISwapRouter public univ3_router;\n\n  // Details about the AMO's uniswap positions\n  struct Position {\n    uint256 token_id;\n    address collateral_address;\n    uint128 liquidity; // the liquidity of the position\n    int24 tickLower; // the tick range of the position\n    int24 tickUpper;\n    uint24 fee_tier;\n  }\n\n  // Add liquidity param\n  struct AddLiquidityParams {\n    address _tokenA;\n    address _tokenB;\n    int24 _tickLower;\n    int24 _tickUpper;\n    uint24 _fee;\n    uint256 _amount0Desired;\n    uint256 _amount1Desired;\n    uint256 _amount0Min;\n    uint256 _amount1Min;\n  }\n\n  // Array of all Uni v3 NFT positions held by the AMO\n  Position[] public positions_array;\n\n  // Map token_id to Position\n  mapping(uint256 => Position) public positions_mapping;\n\n  // Rdpx address\n  address public rdpx;\n\n  // RdpxV2Core address\n  address public rdpxV2Core;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(address _rdpx, address _rdpxV2Core) {\n    rdpx = _rdpx;\n    rdpxV2Core = _rdpxV2Core;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    univ3_factory = IUniswapV3Factory(\n      0x1F98431c8aD98523631AE4a59f267346ea31F984\n    );\n    univ3_positions = INonfungiblePositionManager(\n      0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n    );\n    univ3_router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n  }\n\n  /* ========== VIEWS ========== */\n\n  // Returns this contract's liquidity in a specific [Rdpx]-[collateral] uni v3 pool\n  function liquidityInPool(\n    address _collateral_address,\n    int24 _tickLower,\n    int24 _tickUpper,\n    uint24 _fee\n  ) public view returns (uint128) {\n    IUniswapV3Pool get_pool = IUniswapV3Pool(\n      univ3_factory.getPool(address(rdpx), _collateral_address, _fee)\n    );\n\n    // goes into the pool's positions mapping, and grabs this address's liquidity\n    (uint128 liquidity, , , , ) = get_pool.positions(\n      keccak256(abi.encodePacked(address(this), _tickLower, _tickUpper))\n    );\n    return liquidity;\n  }\n\n  // Only counts non-withdrawn positions\n  function numPositions() public view returns (uint256) {\n    return positions_array.length;\n  }\n\n  /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL ========== */\n\n  // Iterate through all positions and collect fees accumulated\n  function collectFees() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    for (uint i = 0; i < positions_array.length; i++) {\n      Position memory current_position = positions_array[i];\n      INonfungiblePositionManager.CollectParams\n        memory collect_params = INonfungiblePositionManager.CollectParams(\n          current_position.token_id,\n          rdpxV2Core,\n          type(uint128).max,\n          type(uint128).max\n        );\n\n      // Send to custodian address\n      univ3_positions.collect(collect_params);\n    }\n  }\n\n  /* ---------------------------------------------------- */\n  /* ---------------------- Uni v3 ---------------------- */\n  /* ---------------------------------------------------- */\n\n  function approveTarget(\n    address _target,\n    address _token,\n    uint256 _amount,\n    bool use_safe_approve\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (use_safe_approve) {\n      // safeApprove needed for USDT and others for the first approval\n      // You need to approve 0 every time beforehand for USDT: it resets\n      TransferHelper.safeApprove(_token, _target, _amount);\n    } else {\n      IERC20WithBurn(_token).approve(_target, _amount);\n    }\n  }\n\n  // IUniswapV3Pool public current_uni_pool; // only used for mint callback; is set and accessed during execution of addLiquidity()\n  function addLiquidity(\n    AddLiquidityParams memory params\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20WithBurn(params._tokenA).transferFrom(\n      rdpxV2Core,\n      address(this),\n      params._amount0Desired\n    );\n    IERC20WithBurn(params._tokenB).transferFrom(\n      rdpxV2Core,\n      address(this),\n      params._amount1Desired\n    );\n\n    IERC20WithBurn(params._tokenA).approve(\n      address(univ3_positions),\n      params._amount0Desired\n    );\n    IERC20WithBurn(params._tokenB).approve(\n      address(univ3_positions),\n      params._amount1Desired\n    );\n\n    INonfungiblePositionManager.MintParams\n      memory mintParams = INonfungiblePositionManager.MintParams(\n        params._tokenA,\n        params._tokenB,\n        params._fee,\n        params._tickLower,\n        params._tickUpper,\n        params._amount0Desired,\n        params._amount1Desired,\n        params._amount0Min,\n        params._amount1Min,\n        address(this),\n        type(uint256).max\n      );\n\n    (uint256 tokenId, uint128 amountLiquidity, , ) = univ3_positions.mint(\n      mintParams\n    );\n\n    Position memory pos = Position(\n      tokenId,\n      params._tokenA == address(rdpx) ? params._tokenB : params._tokenA,\n      amountLiquidity,\n      params._tickLower,\n      params._tickUpper,\n      params._fee\n    );\n\n    positions_array.push(pos);\n    positions_mapping[tokenId] = pos;\n\n    // send tokens to rdpxV2Core\n    _sendTokensToRdpxV2Core(params._tokenA, params._tokenB);\n  }\n\n  function removeLiquidity(\n    uint256 positionIndex,\n    uint256 minAmount0,\n    uint256 minAmount1\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    Position memory pos = positions_array[positionIndex];\n    INonfungiblePositionManager.CollectParams\n      memory collect_params = INonfungiblePositionManager.CollectParams(\n        pos.token_id,\n        rdpxV2Core,\n        type(uint128).max,\n        type(uint128).max\n      );\n\n    (\n      ,\n      ,\n      address tokenA,\n      address tokenB,\n      ,\n      ,\n      ,\n      uint128 liquidity,\n      ,\n      ,\n      ,\n\n    ) = univ3_positions.positions(pos.token_id);\n\n    // remove liquidity\n    INonfungiblePositionManager.DecreaseLiquidityParams\n      memory decreaseLiquidityParams = INonfungiblePositionManager\n        .DecreaseLiquidityParams(\n          pos.token_id,\n          liquidity,\n          minAmount0,\n          minAmount1,\n          block.timestamp\n        );\n\n    univ3_positions.decreaseLiquidity(decreaseLiquidityParams);\n\n    univ3_positions.collect(collect_params);\n\n    univ3_positions.burn(pos.token_id);\n\n    positions_array[positionIndex] = positions_array[\n      positions_array.length - 1\n    ];\n    positions_array.pop();\n    delete positions_mapping[pos.token_id];\n\n    // send tokens to rdpxV2Core\n    _sendTokensToRdpxV2Core(tokenA, tokenB);\n\n    emit log(positions_array.length);\n    emit log(positions_mapping[pos.token_id].token_id);\n  }\n\n  // Swap tokenA into tokenB using univ3_router.ExactInputSingle()\n  // Uni V3 only\n  function swap(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee_tier,\n    uint256 _amountAtoB,\n    uint256 _amountOutMinimum,\n    uint160 _sqrtPriceLimitX96\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256) {\n    // transfer token from rdpx v2 core\n    IERC20WithBurn(_tokenA).transferFrom(\n      rdpxV2Core,\n      address(this),\n      _amountAtoB\n    );\n\n    ISwapRouter.ExactInputSingleParams memory swap_params = ISwapRouter\n      .ExactInputSingleParams(\n        _tokenA,\n        _tokenB,\n        _fee_tier,\n        address(this),\n        2105300114, // Expiration: a long time from now\n        _amountAtoB,\n        _amountOutMinimum,\n        _sqrtPriceLimitX96\n      );\n\n    // Approval\n    TransferHelper.safeApprove(_tokenA, address(univ3_router), _amountAtoB);\n\n    uint256 amountOut = univ3_router.exactInputSingle(swap_params);\n\n    _sendTokensToRdpxV2Core(_tokenA, _tokenB);\n    return amountOut;\n  }\n\n  /* ========== OWNER / GOVERNANCE FUNCTIONS ONLY ========== */\n  // Only owner or timelock can call, to limit risk\n\n  function recoverERC20(\n    address tokenAddress,\n    uint256 tokenAmount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Can only be triggered by owner or governance, not custodian\n    // Tokens are sent to the custodian, as a sort of safeguard\n    TransferHelper.safeTransfer(tokenAddress, rdpxV2Core, tokenAmount);\n\n    emit RecoveredERC20(tokenAddress, tokenAmount);\n  }\n\n  function recoverERC721(\n    address tokenAddress,\n    uint256 token_id\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // Only the owner address can ever receive the recovery withdrawal\n    // INonfungiblePositionManager inherits IERC721 so the latter does not need to be imported\n    INonfungiblePositionManager(tokenAddress).safeTransferFrom(\n      address(this),\n      rdpxV2Core,\n      token_id\n    );\n    emit RecoveredERC721(tokenAddress, token_id);\n  }\n\n  // Generic proxy\n  function execute(\n    address _to,\n    uint256 _value,\n    bytes calldata _data\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (bool, bytes memory) {\n    (bool success, bytes memory result) = _to.call{ value: _value }(_data);\n    return (success, result);\n  }\n\n  /* ========== INTERNAL ========== */\n\n  /**\n   * @dev sends token A and B to the rdpxV2Core\n   */\n  function _sendTokensToRdpxV2Core(address tokenA, address tokenB) internal {\n    uint256 tokenABalance = IERC20WithBurn(tokenA).balanceOf(address(this));\n    uint256 tokenBBalance = IERC20WithBurn(tokenB).balanceOf(address(this));\n    // transfer token A and B from this contract to the rdpxV2Core\n    IERC20WithBurn(tokenA).safeTransfer(rdpxV2Core, tokenABalance);\n    IERC20WithBurn(tokenB).safeTransfer(rdpxV2Core, tokenBBalance);\n\n    // sync token balances\n    IRdpxV2Core(rdpxV2Core).sync();\n\n    emit LogAssetsTransfered(tokenABalance, tokenBBalance, tokenA, tokenB);\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RecoveredERC20(address token, uint256 amount);\n  event RecoveredERC721(address token, uint256 id);\n  event LogAssetsTransfered(\n    uint256 tokenAAmount,\n    uint256 tokenBAmount,\n    address tokenAAddress,\n    address tokenBAddress\n  );\n  /*\n   **  burn tokenAmount from the recipient and send tokens to the receipient\n   */\n  event log(uint);\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    }
  ]
}