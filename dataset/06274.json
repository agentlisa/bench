{
  "Title": "[G-08] Optimizing check order for cost efficient function execution",
  "Content": "\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (2100 gas) in a function that may ultimately revert in the unhappy case.\n\n<details>\n\n### Cheaper require statements should be performed first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L143-L161\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n143:    ) public virtual {\n144:        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n145:        if (msg.sender != admin) {\n146:            revert AdminOnly();\n147:        }\n148:        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n149:        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n150:        require(\n151:            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n152:            'NounsDAO::initialize: invalid voting period'\n153:        );\n154:        require(\n155:            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n156:            'NounsDAO::initialize: invalid voting delay'\n157:        );\n158:        require(\n159:            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n160:            'NounsDAO::initialize: invalid proposal threshold bps'\n161:        );\n```\nIn the above function, the first sanity checks(require statements) validates some state variables ie Involves reading from state which is quite expensive(2100 Cold ,100 warm). In this case we read `timelock` and `admin` . In case of a revert on other cheaper checks eg function parameter checks, we would end up wasting the gas spent validating the state variables ~4000 gas. To minimize this cost, we can first validate the variables that are cheaper to check. Reorder the checks as follows.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..1f02f8dd 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -141,10 +141,6 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint256 proposalThresholdBPS_,\n         DynamicQuorumParams calldata dynamicQuorumParams_\n     ) public virtual {\n-        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n         require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n         require(\n@@ -159,6 +155,10 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n             proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n             'NounsDAO::initialize: invalid proposal threshold bps'\n         );\n+        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n\n```\n\n### External calls + state reads are very expensive. Validate local/functional parameters first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L204-L221\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n204:        ProposalTemp memory temp;\n\n206:        temp.totalSupply = nouns.totalSupply();\n\n208:        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n210:        require(\n211:            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n212:            'NounsDAO::propose: proposer votes below proposal threshold'\n213:        );\n214:        require(\n215:            targets.length == values.length &&\n216:                targets.length == signatures.length &&\n217:                targets.length == calldatas.length,\n218:            'NounsDAO::propose: proposal function information arity mismatch'\n219:        );\n220:        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n221:        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n```\n\nIn our function above, we start by making some external function calls `nouns.totalSupply()` and reading from state `proposalThresholdBPS`. We then do some validation for some function parameters. As reading function parameters is cheaper, we should validate them first , so that if they don't pass our check, we can revert early and without too much gas.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..15ecc0c6 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -201,6 +201,15 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         bytes[] memory calldatas,\n         string memory description\n     ) public returns (uint256) {\n+        require(\n+            targets.length == values.length &&\n+                targets.length == signatures.length &&\n+                targets.length == calldatas.length,\n+            'NounsDAO::propose: proposal function information arity mismatch'\n+        );\n+        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n+        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n+\n         ProposalTemp memory temp;\n\n         temp.totalSupply = nouns.totalSupply();\n@@ -211,14 +220,6 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n             nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n             'NounsDAO::propose: proposer votes below proposal threshold'\n         );\n-        require(\n-            targets.length == values.length &&\n-                targets.length == signatures.length &&\n-                targets.length == calldatas.length,\n-            'NounsDAO::propose: proposal function information arity mismatch'\n-        );\n-        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n-        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n```\n\n### Validate function parameter first before reading from state\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L615-L617\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n615:    ) internal returns (uint96) {\n616:        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n617:        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n```\nAs `support` is a function parameter, it would be cheaper to validate it first before reading the state variable `ProposalState`.\n\nIn case of a revert on the check `support <= 2` we would not end up wasting too much gas validating the state variable.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..2c5034df 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -613,8 +613,8 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint256 proposalId,\n         uint8 support\n     ) internal returns (uint96) {\n-        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n         require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n+        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n```\n\n### Avoid validating state variables before validating function parameters\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L644-L651\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n644:    function _setVotingDelay(uint256 newVotingDelay) external {\n645:        if (msg.sender != admin) {\n646:            revert AdminOnly();\n647:        }\n648:        require(\n649:            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n650:            'NounsDAO::_setVotingDelay: invalid voting delay'\n651:        );\n```\nIn the above, the second check reads function parameters and constants. The first check reads from state. As it it more gas efficient to read function parameters and constants, we should validate it first.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..52a3bb63 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -642,13 +642,13 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n      * @param newVotingDelay new voting delay, in blocks\n      */\n     function _setVotingDelay(uint256 newVotingDelay) external {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         require(\n             newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n             'NounsDAO::_setVotingDelay: invalid voting delay'\n         );\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n```\n\n### Validate function parameters first before reading any state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L663-L669\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n663:        if (msg.sender != admin) {\n664:            revert AdminOnly();\n665:        }\n666:        require(\n667:            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n668:            'NounsDAO::_setVotingPeriod: invalid voting period'\n669:        );\n```\nReorder the checks to validate function parameters first as they are cheaper to read compared to state variables.\n\n```diff\n     function _setVotingPeriod(uint256 newVotingPeriod) external {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         require(\n             newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n             'NounsDAO::_setVotingPeriod: invalid voting period'\n         );\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n```\n\n### Validate Function parameter  before validating state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L681-L689\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n681:    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n682:        if (msg.sender != admin) {\n683:            revert AdminOnly();\n684:        }\n685:        require(\n686:            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n687:                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n688:            'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n689:        );\n```\nIn case of a revert on the function parameter validation, we might save some good amount of gas (SLOAD) that would have been used in reading `admin` which is a state variable.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..2a9aca20 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -679,14 +679,14 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n      * @param newProposalThresholdBPS new proposal threshold\n      */\n     function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         require(\n             newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                 newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n             'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n         );\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n```\n\n### Reorder the checks here to have cheaper checks first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L702-L711\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n702:    function _setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS) external {\n703:        if (msg.sender != admin) {\n704:            revert AdminOnly();\n705:        }\n706:        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n708:        require(\n709:            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n710:                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n711:            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n```\nWe have a check for function parameters against some constants variables. As this is a cheaper check, it should be done before any other check or any other operations.<br>\nMove the check to the beginning.\n\n```diff\n     function _setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS) external {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n-        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n-\n         require(\n             newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                 newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n             'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n         );\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n+        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n+\n         require(\n             newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n             'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n```\n\n### Function parameters should be validated first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L732-L741\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n732:    function _setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS) external {\n733:        if (msg.sender != admin) {\n734:            revert AdminOnly();\n735:        }\n736:        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n738:        require(\n739:            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n740:            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n741:        );\n```\nConsider validating the function parameter `newMaxQuorumVotesBPS` before reading from state . The first check `msg.sender != admin` involves reading a state variable `admin`. Reading from state is expensive. As it is, in case of a revert on the require statement on line 738, the gas consumed reading from state would be wasted.\n\n```diff\n     function _setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS) external {\n+        require(\n+            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n+            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n+        );\n         if (msg.sender != admin) {\n             revert AdminOnly();\n         }\n         DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n-        require(\n-            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n-            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n-        );\n```\n\n### Validate all function parameters first before reading any state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L783-L802\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n783:    function _setDynamicQuorumParams(\n784:        uint16 newMinQuorumVotesBPS,\n785:        uint16 newMaxQuorumVotesBPS,\n786:        uint32 newQuorumCoefficient\n787:    ) public {\n788:        if (msg.sender != admin) {\n789:            revert AdminOnly();\n790:        }\n791:        if (\n792:            newMinQuorumVotesBPS < MIN_QUORUM_VOTES_BPS_LOWER_BOUND ||\n793:            newMinQuorumVotesBPS > MIN_QUORUM_VOTES_BPS_UPPER_BOUND\n794:        ) {\n795:            revert InvalidMinQuorumVotesBPS();\n796:        }\n797:        if (newMaxQuorumVotesBPS > MAX_QUORUM_VOTES_BPS_UPPER_BOUND) {\n798:            revert InvalidMaxQuorumVotesBPS();\n799:        }\n800:        if (newMinQuorumVotesBPS > newMaxQuorumVotesBPS) {\n801:            revert MinQuorumBPSGreaterThanMaxQuorumBPS();\n802:        }\n```\n\n```diff\n@@ -785,9 +785,6 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint16 newMaxQuorumVotesBPS,\n         uint32 newQuorumCoefficient\n     ) public {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         if (\n             newMinQuorumVotesBPS < MIN_QUORUM_VOTES_BPS_LOWER_BOUND ||\n             newMinQuorumVotesBPS > MIN_QUORUM_VOTES_BPS_UPPER_BOUND\n@@ -800,7 +797,10 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         if (newMinQuorumVotesBPS > newMaxQuorumVotesBPS) {\n             revert MinQuorumBPSGreaterThanMaxQuorumBPS();\n         }\n-\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n+\n```\n\n### Validate function parameters before validating state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol#L78-L80\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol\n78:    function _setImplementation(address implementation_) public {\n79:        require(msg.sender == admin, 'NounsDAOProxy::_setImplementation: admin only');\n80:        require(implementation_ != address(0), 'NounsDAOProxy::_setImplementation: invalid implementation address');\n```\n\nThe first check, `msg.sender == admin` involves reading from state `admin` which is a bit expensive. The second check, however validates that a function parameter `implementation_` != `address(0)`. As the second check is cheaper , it should be done first so that in case it reverts , no gas would be wasted reading from state.\n\n```diff\n     function _setImplementation(address implementation_) public {\n-        require(msg.sender == admin, 'NounsDAOProxy::_setImplementation: admin only');\n         require(implementation_ != address(0), 'NounsDAOProxy::_setImplementation: invalid implementation address');\n-\n+        require(msg.sender == admin, 'NounsDAOProxy::_setImplementation: admin only');\n+\n```\n\n### Function parameters should be checked first before reading any state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol#L150-L153\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n150:        if (address(ds.timelock) != address(0)) revert CanOnlyInitializeOnce();\n151:        if (msg.sender != ds.admin) revert AdminOnly();\n152:        if (timelock_ == address(0)) revert InvalidTimelockAddress();\n153:        if (nouns_ == address(0)) revert InvalidNounsAddress();\n```\nThe first two checks involves reading some state variables ie `ds.timelock` and `ds.admin`. The next two simply checks some local variables(function parameters). Reading function parameters is cheaper than state variables and in case of a revert on the function parameter check, we would end up wasting too much gas on reading state. We should reorder the checks to have cheaper checks first.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\nindex 00c5ccdc..fee29faa 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n@@ -147,10 +147,10 @@ contract NounsDAOLogicV3 is NounsDAOStorageV3, NounsDAOEventsV3 {\n         NounsDAOParams calldata daoParams_,\n         DynamicQuorumParams calldata dynamicQuorumParams_\n     ) public virtual {\n-        if (address(ds.timelock) != address(0)) revert CanOnlyInitializeOnce();\n-        if (msg.sender != ds.admin) revert AdminOnly();\n         if (timelock_ == address(0)) revert InvalidTimelockAddress();\n         if (nouns_ == address(0)) revert InvalidNounsAddress();\n+        if (address(ds.timelock) != address(0)) revert CanOnlyInitializeOnce();\n+        if (msg.sender != ds.admin) revert AdminOnly();\n\n```\n\n### Validate parameters before making external function calls\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L351-L365\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n351:    function _setMinQuorumVotesBPS(NounsDAOStorageV3.StorageV3 storage ds, uint16 newMinQuorumVotesBPS)\n352:        external\n353:        onlyAdmin(ds)\n354:    {\n355:        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n\n357:        require(\n358:            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n359:                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n360:            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n361:        );\n362:        require(\n363:            newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n364:            'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n365:        );\n```\nWe make an external call `getDynamicQuorumParamsAt(block.number)` then we make some checks  for the function parameters. If the parameters don't meet our requirements, we would end up reverting. In case of a revert, it would mean that the gas spent making the external function call was wasted. We should reorder this checks to validate the parameters first before doing the external calls. This way, a revert on the parameter check would not waste gas doing the external call.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\nindex 4dcacae8..c2218691 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n@@ -352,13 +352,13 @@ library NounsDAOV3Admin {\n         external\n         onlyAdmin(ds)\n     {\n-        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n-\n         require(\n             newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                 newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n             'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n         );\n+        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n+\n         require(\n             newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n             'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n```\n\n### Avoid making external calls before validating function parameters\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L381-L390\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n381:    function _setMaxQuorumVotesBPS(NounsDAOStorageV3.StorageV3 storage ds, uint16 newMaxQuorumVotesBPS)\n382:        external\n383:        onlyAdmin(ds)\n384:    {\n385:        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n\n387:        require(\n388:            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n389:            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n390:        );\n```\nIn the above function, we are making an external `getDynamicQuorumParamsAt(block.number)` then we do some validity checks. In case of a revert when validating the function parameter `newMaxQuorumVotesBPS` the gas used making the external call would be wasted. Perform all validations first before making any external calls.\n\n```diff\n-        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n-\n         require(\n             newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n             'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n         );\n+        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n+\n```\n\n### Validate function parameters before validating state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L176-L178\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n176:        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n177:        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n178:        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n```\n\nIf we end up reverting on the checks for function parameters(`timelock_` and `nouns_`) the gas spent reading the state variable `timelock` would be wasted. As SLOAD are quite expensive, it would be wise to first validate the cheaper variables.\n\n```diff\n         __ReentrancyGuard_init_unchained();\n-        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n         require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n         require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n+        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n```\n\n### Validate all function parameters first before doing other operations \nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L279-L298\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n279:        checkGovernanceActive();\n\n281:        ProposalTemp memory temp;\n\n283:        temp.totalSupply = adjustedTotalSupply();\n\n285:        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n287:        require(\n288:            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n289:            'NounsDAO::propose: proposer votes below proposal threshold'\n290:        );\n291:        require(\n292:            targets.length == values.length &&\n293:                targets.length == signatures.length &&\n294:                targets.length == calldatas.length,\n295:            'NounsDAO::propose: proposal function information arity mismatch'\n296:        );\n297:        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n298:        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n```\n\n```diff\n+        require(\n+            targets.length == values.length &&\n+                targets.length == signatures.length &&\n+                targets.length == calldatas.length,\n+            'NounsDAO::propose: proposal function information arity mismatch'\n+        );\n+        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n+        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n+\n         checkGovernanceActive();\n\n         ProposalTemp memory temp;\n@@ -288,14 +297,6 @@ contract NounsDAOLogicV1Fork is UUPSUpgradeable, ReentrancyGuardUpgradeable, Nou\n             nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n             'NounsDAO::propose: proposer votes below proposal threshold'\n         );\n-        require(\n-            targets.length == values.length &&\n-                targets.length == signatures.length &&\n-                targets.length == calldatas.length,\n-            'NounsDAO::propose: proposal function information arity mismatch'\n-        );\n-        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n-        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n```\n\n### Reorder the checks to have the cheaper checks first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L617-L618\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n617:        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n618:        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n```\nThe first check involves reading a state variable while the second check just reads a function parameter. To minimize gas consumed in case of a revert on the second check, we should do it first as it's cheaper.\n\n```diff\n-        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n         require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n+        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n```\n\n### Validations that involve state reads should not be done at the beginning if we have other cheaper checks\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L646-L650\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n646:        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n647:        require(\n648:            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n649:            'NounsDAO::_setVotingDelay: invalid voting delay'\n650:        );\n```\nThe second check is cheaper as it just reads a function parameter and a constant variable.\n\n```diff\n     function _setVotingDelay(uint256 newVotingDelay) external {\n-        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n         require(\n             newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n             'NounsDAO::_setVotingDelay: invalid voting delay'\n         );\n+        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n         uint256 oldVotingDelay = votingDelay;\n         votingDelay = newVotingDelay;\n```\n\n### Reorder the checks to have cheaper checks first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L662-L666\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n66",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-nounsdao",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The Nouns DAO logic version 2\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOLogicV2.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\n//\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// See NounsDAOLogicV1 for initial GovernorBravoDelegate modifications.\n\n// NounsDAOLogicV2 adds:\n// - `quorumParamsCheckpoints`, which store dynamic quorum parameters checkpoints\n// to be used when calculating the dynamic quorum.\n// - `_setDynamicQuorumParams(DynamicQuorumParams memory params)`, which allows the\n// DAO to update the dynamic quorum parameters' values.\n// - `getDynamicQuorumParamsAt(uint256 blockNumber_)`\n// - Individual setters of the DynamicQuorumParams members:\n//    - `_setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS)`\n//    - `_setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS)`\n//    - `_setQuorumCoefficient(uint32 newQuorumCoefficient)`\n// - `minQuorumVotes` and `maxQuorumVotes`, which returns the current min and\n// max quorum votes using the current Noun supply.\n// - New `Proposal` struct member:\n//    - `totalSupply` used in dynamic quorum calculation.\n//    - `creationBlock` used for retrieving checkpoints of votes and dynamic quorum params. This now\n// allows changing `votingDelay` without affecting the checkpoints lookup.\n// - `quorumVotes(uint256 proposalId)`, which calculates and returns the dynamic\n// quorum for a specific proposal.\n// - `proposals(uint256 proposalId)` instead of the implicit getter, to avoid stack-too-deep error\n//\n// NounsDAOLogicV2 removes:\n// - `quorumVotes()` has been replaced by `quorumVotes(uint256 proposalId)`.\n\npragma solidity ^0.8.6;\n\nimport './NounsDAOInterfaces.sol';\n\ncontract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n    /// @notice The name of this contract\n    string public constant name = 'Nouns DAO';\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 1;\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\n\n    /// @notice The lower bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_LOWER_BOUND = 200; // 200 basis points or 2%\n\n    /// @notice The upper bound of minimum quorum votes basis points\n    uint256 public constant MIN_QUORUM_VOTES_BPS_UPPER_BOUND = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The upper bound of maximum quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS_UPPER_BOUND = 6_000; // 4,000 basis points or 60%\n\n    /// @notice The maximum setable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The maximum priority fee used to cap gas refunds in `castRefundableVote`\n    uint256 public constant MAX_REFUND_PRIORITY_FEE = 2 gwei;\n\n    /// @notice The vote refund gas overhead, including 7K for ETH transfer and 29K for general transaction overhead\n    uint256 public constant REFUND_BASE_GAS = 36000;\n\n    /// @notice The maximum gas units the DAO will refund voters on; supports about 9,190 characters\n    uint256 public constant MAX_REFUND_GAS_USED = 200_000;\n\n    /// @notice The maximum basefee the DAO will refund voters on\n    uint256 public constant MAX_REFUND_BASE_FEE = 200 gwei;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n    /// @dev Introduced these errors to reduce contract size, to avoid deployment failure\n    error AdminOnly();\n    error InvalidMinQuorumVotesBPS();\n    error InvalidMaxQuorumVotesBPS();\n    error MinQuorumBPSGreaterThanMaxQuorumBPS();\n    error UnsafeUint16Cast();\n    error VetoerOnly();\n    error PendingVetoerOnly();\n    error VetoerBurned();\n    error CantVetoExecutedProposal();\n    error CantCancelExecutedProposal();\n\n    /**\n     * @notice Used to initialize the contract during delegator contructor\n     * @param timelock_ The address of the NounsDAOExecutor\n     * @param nouns_ The address of the NOUN tokens\n     * @param vetoer_ The address allowed to unilaterally veto proposals\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\n     * @param dynamicQuorumParams_ The initial dynamic quorum parameters\n     */\n    function initialize(\n        address timelock_,\n        address nouns_,\n        address vetoer_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThresholdBPS_,\n        DynamicQuorumParams calldata dynamicQuorumParams_\n    ) public virtual {\n        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            'NounsDAO::initialize: invalid voting period'\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            'NounsDAO::initialize: invalid voting delay'\n        );\n        require(\n            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::initialize: invalid proposal threshold bps'\n        );\n\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\n        emit VotingDelaySet(votingDelay, votingDelay_);\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\n\n        timelock = INounsDAOExecutor(timelock_);\n        nouns = NounsTokenLike(nouns_);\n        vetoer = vetoer_;\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThresholdBPS = proposalThresholdBPS_;\n        _setDynamicQuorumParams(\n            dynamicQuorumParams_.minQuorumVotesBPS,\n            dynamicQuorumParams_.maxQuorumVotesBPS,\n            dynamicQuorumParams_.quorumCoefficient\n        );\n    }\n\n    struct ProposalTemp {\n        uint256 totalSupply;\n        uint256 proposalThreshold;\n        uint256 latestProposalId;\n        uint256 startBlock;\n        uint256 endBlock;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        ProposalTemp memory temp;\n\n        temp.totalSupply = nouns.totalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = _proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.vetoed = false;\n        newProposal.totalSupply = temp.totalSupply;\n        newProposal.creationBlock = block.number;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`\n        /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            minQuorumVotes(),\n            description\n        );\n\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        Proposal storage proposal = _proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        if (state(proposalId) == ProposalState.Executed) {\n            revert CantCancelExecutedProposal();\n        }\n\n        Proposal storage proposal = _proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) <= proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(uint256 proposalId) external {\n        if (vetoer == address(0)) {\n            revert VetoerBurned();\n        }\n\n        if (msg.sender != vetoer) {\n            revert VetoerOnly();\n        }\n\n        if (state(proposalId) == ProposalState.Executed) {\n            revert CantVetoExecutedProposal();\n        }\n\n        Proposal storage proposal = _proposals[proposalId];\n\n        proposal.vetoed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = _proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return _proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        Proposal storage proposal = _proposals[proposalId];\n        if (proposal.vetoed) {\n            return ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes(proposal.id)) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Returns the proposal details given a proposal id.\n     *     The `quorumVotes` member holds the *current* quorum, given the current votes.\n     * @param proposalId the proposal id to get the data for\n     * @return A `ProposalCondensed` struct with the proposal data\n     */\n    function proposals(uint256 proposalId) external view returns (ProposalCondensed memory) {\n        Proposal storage proposal = _proposals[proposalId];\n        return\n            ProposalCondensed({\n                id: proposal.id,\n                proposer: proposal.proposer,\n                proposalThreshold: proposal.proposalThreshold,\n                quorumVotes: quorumVotes(proposal.id),\n                eta: proposal.eta,\n                startBlock: proposal.startBlock,\n                endBlock: proposal.endBlock,\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                abstainVotes: proposal.abstainVotes,\n                canceled: proposal.canceled,\n                vetoed: proposal.vetoed,\n                executed: proposal.executed,\n                totalSupply: proposal.totalSupply,\n                creationBlock: proposal.creationBlock\n            });\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVote(uint256 proposalId, uint8 support) external {\n        castRefundableVoteInternal(proposalId, support, '');\n    }\n\n    /**\n     * @notice Cast a vote for a proposal, asking the DAO to refund gas costs.\n     * Users with > 0 votes receive refunds. Refunds are partial when using a gas priority fee higher than the DAO's cap.\n     * Refunds are partial when the DAO's balance is insufficient.\n     * No refund is sent when the DAO's balance is empty. No refund is sent to users with no votes.\n     * Voting takes place regardless of refund success.\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        castRefundableVoteInternal(proposalId, support, reason);\n    }\n\n    /**\n     * @notice Internal function that carries out refundable voting logic\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     * @dev Reentrancy is defended against in `castVoteInternal` at the `receipt.hasVoted == false` require statement.\n     */\n    function castRefundableVoteInternal(\n        uint256 proposalId,\n        uint8 support,\n        string memory reason\n    ) internal {\n        uint256 startGas = gasleft();\n        uint96 votes = castVoteInternal(msg.sender, proposalId, support);\n        emit VoteCast(msg.sender, proposalId, support, votes, reason);\n        if (votes > 0) {\n            _refundGas(startGas);\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'NounsDAO::castVoteBySig: invalid signature');\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), '');\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(\n        address voter,\n        uint256 proposalId,\n        uint8 support\n    ) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n        Proposal storage proposal = _proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, 'NounsDAO::castVoteInternal: voter already voted');\n\n        /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n        uint96 votes = nouns.getPriorVotes(voter, proposalCreationBlock(proposal));\n\n        if (support == 0) {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        } else if (support == 1) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else if (support == 2) {\n            proposal.abstainVotes = proposal.abstainVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        require(\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n            'NounsDAO::_setVotingDelay: invalid voting delay'\n        );\n        uint256 oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\n    }\n\n    /**\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        require(\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n            'NounsDAO::_setVotingPeriod: invalid voting period'\n        );\n        uint256 oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    }\n\n    /**\n     * @notice Admin function for setting the proposal threshold basis points\n     * @dev newProposalThresholdBPS must be greater than the hardcoded min\n     * @param newProposalThresholdBPS new proposal threshold\n     */\n    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        require(\n            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n            'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n        );\n        uint256 oldProposalThresholdBPS = proposalThresholdBPS;\n        proposalThresholdBPS = newProposalThresholdBPS;\n\n        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, proposalThresholdBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the minimum quorum votes bps\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     */\n    function _setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS) external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n        );\n        require(\n            newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n            'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMinQuorumVotesBPS = params.minQuorumVotesBPS;\n        params.minQuorumVotesBPS = newMinQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MinQuorumVotesBPSSet(oldMinQuorumVotesBPS, newMinQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the maximum quorum votes bps\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     */\n    function _setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS) external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        require(\n            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n        );\n        require(\n            params.minQuorumVotesBPS <= newMaxQuorumVotesBPS,\n            'NounsDAO::_setMaxQuorumVotesBPS: min quorum votes bps greater than max'\n        );\n\n        uint16 oldMaxQuorumVotesBPS = params.maxQuorumVotesBPS;\n        params.maxQuorumVotesBPS = newMaxQuorumVotesBPS;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MaxQuorumVotesBPSSet(oldMaxQuorumVotesBPS, newMaxQuorumVotesBPS);\n    }\n\n    /**\n     * @notice Admin function for setting the dynamic quorum coefficient\n     * @param newQuorumCoefficient the new coefficient, as a fixed point integer with 6 decimals\n     */\n    function _setQuorumCoefficient(uint32 newQuorumCoefficient) external {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n        uint32 oldQuorumCoefficient = params.quorumCoefficient;\n        params.quorumCoefficient = newQuorumCoefficient;\n\n        _writeQuorumParamsCheckpoint(params);\n\n        emit QuorumCoefficientSet(oldQuorumCoefficient, newQuorumCoefficient);\n    }\n\n    /**\n     * @notice Admin function for setting all the dynamic quorum parameters\n     * @param newMinQuorumVotesBPS minimum quorum votes bps\n     *     Must be between `MIN_QUORUM_VOTES_BPS_LOWER_BOUND` and `MIN_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be lower than or equal to maxQuorumVotesBPS\n     * @param newMaxQuorumVotesBPS maximum quorum votes bps\n     *     Must be lower than `MAX_QUORUM_VOTES_BPS_UPPER_BOUND`\n     *     Must be higher than or equal to minQuorumVotesBPS\n     * @param newQuorumCoefficient the new coefficient, as a fixed point integer with 6 decimals\n     */\n    function _setDynamicQuorumParams(\n        uint16 newMinQuorumVotesBPS,\n        uint16 newMaxQuorumVotesBPS,\n        uint32 newQuorumCoefficient\n    ) public {\n        if (msg.sender != admin) {\n            revert AdminOnly();\n        }\n        if (\n            newMinQuorumVotesBPS < MIN_QUORUM_VOTES_BPS_LOWER_BOUND ||\n            newMinQuorumVotesBPS > MIN_QUORUM_VOTES_BPS_UPPER_BOUND\n        ) {\n            revert InvalidMinQuorumVotesBPS();\n        }\n        if (newMaxQuorumVotesBPS > MAX_QUORUM_VOTES_BPS_UPPER_BOUND) {\n            revert InvalidMaxQuorumVotesBPS();\n        }\n        if (newMinQuorumVotesBPS > newMaxQuorumVotesBPS) {\n            revert MinQuorumBPSGreaterThanMaxQuorumBPS();\n        }\n\n        DynamicQuorumParams memory oldParams = getDynamicQuorumParamsAt(block.number);\n\n        DynamicQuorumParams memory params = DynamicQuorumParams({\n            minQuorumVotesBPS: newMinQuorumVotesBPS,\n            maxQuorumVotesBPS: newMaxQuorumVotesBPS,\n            quorumCoefficient: newQuorumCoefficient\n        });\n        _writeQuorumParamsCheckpoint(params);\n\n        emit MinQuorumVotesBPSSet(oldParams.minQuorumVotesBPS, params.minQuorumVotesBPS);\n        emit MaxQuoru"
    }
  ]
}