{
  "Title": "[L-01] delegator and/or representative should be allowed for arbitrary code execution besides restricted operations during unlocked period",
  "Content": "_Submitted by WatchPug_\n\n### Line References\n\n[Delegation.sol#L39-L46](https://github.com/pooltogether/v4-twab-delegator/blob/21bb53b2ea54a248bbd1d3170dbadd3a0c83d874/contracts/Delegation.sol#L39-L46)\n\n### Vulnerability details\n\n`Delegation` is a contract deployed dedicated to holding the `ticket` tokens for the `delegator` and they can then be `delegate` to a `delegatee`.\n\nOn the `Delegation` contract, there is a method named `executeCalls()` designed for \"Executes calls on behalf of this contract\" which allows arbitrary code execution for the owner.\n\nHowever, we found that the owner of `Delegation` will always be `TWABDelegator`, and the `TWABDelegator` will only use `Delegation.sol#executeCalls()` to call one particular address: the `ticket` address, and for only two methods: `transfer()` and `delegate()`.\n\nFurthermore, even though in `Delegation.sol#executeCalls()`, `calls[i].value` is used, the function is not being marked as `payable`, that makes it hard for calls that requires eth payments.\n\n[Delegation.sol#L39-L46](https://github.com/pooltogether/v4-twab-delegator/blob/21bb53b2ea54a248bbd1d3170dbadd3a0c83d874/contracts/Delegation.sol#L39-L46)\n\n```solidity\nfunction executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {\n  bytes[] memory response = new bytes[](calls.length);\n  for (uint256 i = 0; i < calls.length; i++) {\n    response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);\n  }\n  return response;\n}\n```\n\nWhile the `ticket` is being delegated through `TWABDelegator`, they won't be able to retrieve the tickets back until the `lockUntil`, without the ability to make arbitrary code execution, the `delegator` may miss some of the potential benefits as a holder of the `ticket` tokens, for example, an airdrop to all holders of the `ticket` tokens, or an NFT made mintable only for certain ticket holders.\n\n### Recommended Mitigation Steps\n\nConsider adding a new method on `TWABDelegator`:\n\n```solidity\nfunction executeCalls(\n  address _delegator,\n  uint256 _slot,\n  Delegation.Call[] memory calls\n) external payable returns (bytes[] memory) {\n  _requireDelegatorOrRepresentative(_delegator);\n  Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n\n  if (block.timestamp < _delegation.lockUntil()) {\n    for (uint256 i = 0; i < calls.length; i++) {\n      if (calls[i].to == address(ticket)) {\n        revert(\"TWABDelegator/delegation-locked\");\n      }\n    }\n  }\n\n  return _delegation.executeCalls{value: msg.value}(_calls);\n}\n```\n\nAnd also, consider making `Delegation.sol#executeCalls()` a `payable` method.\n\n**[PierrickGT (PoolTogether) acknowledged and commented](https://github.com/code-423n4/2022-02-pooltogether-findings/issues/27#issuecomment-1058241764):**\n > The issue outlined by the warden is relevant but users won't need to execute arbitrary calls cause potential rewards given out to ticket holders will be handled by our TWABRewards contract.\n> This contract retrieves users TWAB (Time-Weighted Average Balance) for a given period of time and calculate the amount of rewards they are eligible to. \n> Users can then `claimRewards` on behalf of others. So delegatees will be able to claim their rewards and delegators could claim on their behalf.\n> \n> [TwabRewards.sol#L410](https://github.com/pooltogether/v4-periphery/blob/348d2bf7cfcf5750bad4aae63b8ade5a2a45f188/contracts/TwabRewards.sol#L410)<br>\n> [ITwabRewards.sol#L94](https://github.com/pooltogether/v4-periphery/blob/348d2bf7cfcf5750bad4aae63b8ade5a2a45f188/contracts/interfaces/ITwabRewards.sol#L94)<br>\n> \n> For more informations about how the TWAB works, here is some documentation:\n> - [Time-Weighted Average Balance](https://dev.pooltogether.com/protocol/architecture/time-weighted-average-balance)\n> - [Better Reward Distribution](https://medium.com/pooltogether/better-reward-distribution-65d900f3cef0)\n> \n> Also, by restricting calls to the `transfer` and delegate` methods on the ticket, we limit the attack surface and any attack vector we may not have thought about.\n> \n> For the reasons above, I've acknowledged the issue but we won't implement the proposed solution\n\n**[0xleastwood (judge) decreased severity to Low and commented](https://github.com/code-423n4/2022-02-pooltogether-findings/issues/27#issuecomment-1062705166):**\n > I don't really see a case where `_delegateCall()` or `_transferCall()` will need to have some ETH attached with it. They are solely dealing with the Ticket ERC20 token and updating delegation data. Considering the fact that rewards are handled by a separate contract, I think its fair to downgrade this to `1 (Low Risk)`.\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-02-pooltogether",
  "Code": [
    {
      "filename": "contracts/Delegation.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/**\n * @title Contract instantiated via CREATE2 to handle a Delegation by a delegator to a delegatee.\n * @notice A Delegation allows his owner to execute calls on behalf of the contract.\n * @dev This contract is intended to be counterfactually instantiated via CREATE2 through the LowLevelDelegator contract.\n * @dev This contract will hold tickets that will be delegated to a chosen delegatee.\n */\ncontract Delegation {\n  /// @notice A structure to define arbitrary contract calls.\n  struct Call {\n    address to;\n    uint256 value;\n    bytes data;\n  }\n\n  /// @notice Contract owner.\n  address private _owner;\n\n  /// @notice Timestamp until which the delegation is locked.\n  uint96 public lockUntil;\n\n  /**\n   * @notice Initializes the delegation.\n   * @param _lockUntil Timestamp until which the delegation is locked\n   */\n  function initialize(uint96 _lockUntil) public {\n    require(_owner == address(0), \"Delegation/already-init\");\n    _owner = msg.sender;\n    lockUntil = _lockUntil;\n  }\n\n  /**\n   * @notice Executes calls on behalf of this contract.\n   * @param calls The array of calls to be executed\n   * @return An array of the return values for each of the calls\n   */\n  function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {\n    bytes[] memory response = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);\n    }\n    return response;\n  }\n\n  /**\n   * @notice Set the timestamp until which the delegation is locked.\n   * @param _lockUntil The timestamp until which the delegation is locked\n   */\n  function setLockUntil(uint96 _lockUntil) external onlyOwner {\n    lockUntil = _lockUntil;\n  }\n\n  /**\n   * @notice Executes a call to another contract.\n   * @param to The address to call\n   * @param value The Ether to pass along with the call\n   * @param data The call data\n   * @return The return data from the call\n   */\n  function _executeCall(\n    address to,\n    uint256 value,\n    bytes memory data\n  ) internal returns (bytes memory) {\n    (bool succeeded, bytes memory returnValue) = to.call{ value: value }(data);\n    require(succeeded, string(returnValue));\n    return returnValue;\n  }\n\n  /// @notice Modifier to only allow the contract owner to call a function\n  modifier onlyOwner() {\n    require(msg.sender == _owner, \"Delegation/only-owner\");\n    _;\n  }\n}"
    }
  ]
}