{
  "Title": "Event in secondaryLiquidation could be misused to show false liquidations ",
  "Content": "# Event in secondaryLiquidation could be misused to show false liquidations \n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L116\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallSecondaryFacet.sol#L116</a>\n\n\n## Summary\n\nThe **`liquidateSecondary`** function in the protocol is designed to emit events detailing the specifics of liquidation, which can be crucial for other protocols or front-end integrations that track secondary liquidations within the protocol. One of the values emitted is **`batches`**, which indicates which positions got liquidated. However the function emits the **`batches`** array as it initially receives it, even though it may skip positions that are not eligible for liquidation during its execution. This implies that the emitted event could represent incorrect data, indicating positions as liquidated even if they were not, due to their ineligibility.\n\n```solidity\nfunction liquidateSecondary(\n        address asset,\n        MTypes.BatchMC[] memory batches,\n        uint88 liquidateAmount,\n        bool isWallet\n    ) external onlyValidAsset(asset) isNotFrozen(asset) nonReentrant {\n        // Initial code\n\n        emit Events.LiquidateSecondary(asset, batches, msg.sender, isWallet);\n    }\n```\n\n## Impact\n\nThis inconsistency in the emitted event data can lead to incorrect data, indicating positions as liquidated even if they were not.\n\n## Tools Used\n\nManual Analysis\n\n## Recommendations\n\nModify the **`batches`** array before emitting it in the event, ensuring it accurately reflects the positions that were actually liquidated.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/MarginCallSecondaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IAsset} from \"interfaces/IAsset.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallSecondaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    /**\n     * @notice Liquidates short using liquidator's ercEscrowed or wallet\n     * @dev Secondary liquidation function. Doesn't need flag\n     * @dev Must liquidate all of the debt. No partial (unless TAPP short)\n     *\n     * @param asset The market that will be impacted\n     * @param batches Array of shorters and shortRecordIds to liquidate\n     * @param liquidateAmount Amount of ercDebt to liquidate\n     * @param isWallet Liquidate using wallet balance when true, ercEscrowed when false\n     *\n     */\n\n    //@dev If you want to liquidated more than uint88.max worth of erc in shorts, you must call liquidateSecondary multiple times\n    function liquidateSecondary(\n        address asset,\n        MTypes.BatchMC[] memory batches,\n        uint88 liquidateAmount,\n        bool isWallet\n    ) external onlyValidAsset(asset) isNotFrozen(asset) nonReentrant {\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        MTypes.MarginCallSecondary memory m;\n        uint256 minimumCR = LibAsset.minimumCR(asset);\n        uint256 oraclePrice = LibOracle.getSavedOrSpotOraclePrice(asset);\n        uint256 secondaryLiquidationCR = LibAsset.secondaryLiquidationCR(asset);\n\n        uint88 liquidatorCollateral;\n        uint88 liquidateAmountLeft = liquidateAmount;\n        for (uint256 i; i < batches.length;) {\n            m = _setMarginCallStruct(\n                asset, batches[i].shorter, batches[i].shortId, minimumCR, oraclePrice\n            );\n\n            unchecked {\n                ++i;\n            }\n\n            // If ineligible, skip to the next shortrecord instead of reverting\n            if (\n                m.shorter == msg.sender || m.cRatio > secondaryLiquidationCR\n                    || m.short.status == SR.Cancelled\n                    || m.short.id >= s.assetUser[asset][m.shorter].shortRecordId\n                    || m.short.id < Constants.SHORT_STARTING_ID\n                    || (m.shorter != address(this) && liquidateAmountLeft < m.short.ercDebt)\n            ) {\n                continue;\n            }\n\n            bool partialTappLiquidation;\n            // Setup partial liquidation of TAPP short\n            if (m.shorter == address(this)) {\n                partialTappLiquidation = liquidateAmountLeft < m.short.ercDebt;\n                if (partialTappLiquidation) {\n                    m.short.ercDebt = liquidateAmountLeft;\n                }\n            }\n\n            // Determine which secondary liquidation method to use\n            if (isWallet) {\n                IAsset tokenContract = IAsset(asset);\n                uint256 walletBalance = tokenContract.balanceOf(msg.sender);\n                if (walletBalance < m.short.ercDebt) continue;\n                tokenContract.burnFrom(msg.sender, m.short.ercDebt);\n                assert(tokenContract.balanceOf(msg.sender) < walletBalance);\n            } else {\n                if (AssetUser.ercEscrowed < m.short.ercDebt) {\n                    continue;\n                }\n                AssetUser.ercEscrowed -= m.short.ercDebt;\n            }\n\n            if (partialTappLiquidation) {\n                // Partial liquidation of TAPP short\n                _secondaryLiquidationHelperPartialTapp(m);\n            } else {\n                // Full liquidation\n                _secondaryLiquidationHelper(m);\n            }\n\n            // Update in memory for final state change after loops\n            liquidatorCollateral += m.liquidatorCollateral;\n            liquidateAmountLeft -= m.short.ercDebt;\n            if (liquidateAmountLeft == 0) break;\n        }\n\n        if (liquidateAmount == liquidateAmountLeft) {\n            revert Errors.MarginCallSecondaryNoValidShorts();\n        }\n\n        // Update finalized state changes\n        s.asset[asset].ercDebt -= liquidateAmount - liquidateAmountLeft;\n        s.vaultUser[m.vault][msg.sender].ethEscrowed += liquidatorCollateral;\n        emit Events.LiquidateSecondary(asset, batches, msg.sender, isWallet);\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint256 minimumCR,\n        uint256 oraclePrice\n    ) private returns (MTypes.MarginCallSecondary memory) {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n\n        MTypes.MarginCallSecondary memory m;\n        m.asset = asset;\n        m.short = s.shortRecords[asset][shorter][id];\n        m.vault = s.asset[asset].vault;\n        m.shorter = shorter;\n        m.minimumCR = minimumCR;\n        m.cRatio = m.short.getCollateralRatioSpotPrice(oraclePrice);\n        return m;\n    }\n\n    /**\n     * @notice Handles accounting for secondary liquidation methods (wallet and ercEscrowed)\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // +----------------+---------------+---------+-------+\n    // |     Cratio     |  Liquidator   | Shorter | Pool  |\n    // +----------------+---------------+---------+-------+\n    // | >= 1.5         | (cannot call) | n/a     | n/a   |\n    // | 1.1 <= c < 1.5 | 1             | c - 1   | 0     |\n    // | 1.0 < c 1.1    | 1             | 0       | c - 1 |\n    // | c <= 1         | c             | 0       | 0     |\n    // +----------------+---------------+---------+-------+\n    function _secondaryLiquidationHelper(MTypes.MarginCallSecondary memory m) private {\n        // @dev when cRatio <= 1 liquidator eats loss, so it's expected that only TAPP would call\n        m.liquidatorCollateral = m.short.collateral;\n\n        if (m.cRatio > 1 ether) {\n            uint88 ercDebtAtOraclePrice =\n                m.short.ercDebt.mulU88(LibOracle.getPrice(m.asset)); // eth\n            m.liquidatorCollateral = ercDebtAtOraclePrice;\n\n            // if cRatio > 110%, shorter gets remaining collateral\n            // Otherwise they take a penalty, and remaining goes to the pool\n            address remainingCollateralAddress =\n                m.cRatio > m.minimumCR ? m.shorter : address(this);\n\n            s.vaultUser[m.vault][remainingCollateralAddress].ethEscrowed +=\n                m.short.collateral - ercDebtAtOraclePrice;\n        }\n\n        LibShortRecord.disburseCollateral(\n            m.asset,\n            m.shorter,\n            m.short.collateral,\n            m.short.zethYieldRate,\n            m.short.updatedAt\n        );\n        LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    function _secondaryLiquidationHelperPartialTapp(MTypes.MarginCallSecondary memory m)\n        private\n    {\n        STypes.ShortRecord storage short =\n            s.shortRecords[m.asset][address(this)][m.short.id];\n        // Update erc balance\n        short.ercDebt -= m.short.ercDebt; // @dev m.short.ercDebt was updated earlier to equal erc filled\n        // Update eth balance\n        // If c-ratio < 1 then it's possible to lose eth owed over short collateral\n        m.liquidatorCollateral =\n            min88(m.short.ercDebt.mul(LibOracle.getPrice(m.asset)), m.short.collateral);\n        short.collateral -= m.liquidatorCollateral;\n        LibShortRecord.disburseCollateral(\n            m.asset,\n            m.shorter,\n            m.liquidatorCollateral,\n            m.short.zethYieldRate,\n            m.short.updatedAt\n        );\n    }\n}"
    }
  ]
}