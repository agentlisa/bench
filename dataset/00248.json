{
  "Title": "Lack of Input Validation",
  "Content": "The `BaseFee` parameter of type `big.Int` [is checked for not being `nil`](https://github.com/mantlenetworkio/mantle-v2/blob/bb0ff7002520ee936101c4c263ac02a66e7e3c96/op-node/rollup/types.go#L236-L238). However, a `big.Int` can be a negative number which does not make sense for `BaseFee` given that it should always be positive.\n\n\nConsider checking the `BaseFee` parameter both for not being `nil` and being a positive number just like other `big.Int` parameters (e.g., [chain ids are validated to be greater than 0 and not equal to 0](https://github.com/mantlenetworkio/mantle-v2/blob/bb0ff7002520ee936101c4c263ac02a66e7e3c96/op-node/rollup/types.go#L254-L259)).\n\n\n***Update:** Acknowledged, will resolve.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "op-node/rollup/types.go",
      "content": "package rollup\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\n\t\"github.com/ethereum-optimism/optimism/op-node/eth\"\n)\n\nvar (\n\tErrBlockTimeZero                 = errors.New(\"block time cannot be 0\")\n\tErrMissingChannelTimeout         = errors.New(\"channel timeout must be set, this should cover at least a L1 block time\")\n\tErrInvalidSeqWindowSize          = errors.New(\"sequencing window size must at least be 2\")\n\tErrMissingGenesisL1Hash          = errors.New(\"genesis L1 hash cannot be empty\")\n\tErrMissingGenesisL2Hash          = errors.New(\"genesis L2 hash cannot be empty\")\n\tErrGenesisHashesSame             = errors.New(\"achievement get! rollup inception: L1 and L2 genesis cannot be the same\")\n\tErrMissingGenesisL2Time          = errors.New(\"missing L2 genesis time\")\n\tErrMissingBatcherAddr            = errors.New(\"missing genesis system config batcher address\")\n\tErrMissingOverhead               = errors.New(\"missing genesis system config overhead\")\n\tErrMissingScalar                 = errors.New(\"missing genesis system config scalar\")\n\tErrMissingGasLimit               = errors.New(\"missing genesis system config gas limit\")\n\tErrMissingBaseFee                = errors.New(\"missing genesis system config base fee\")\n\tErrMissingBatchInboxAddress      = errors.New(\"missing batch inbox address\")\n\tErrMissingDepositContractAddress = errors.New(\"missing deposit contract address\")\n\tErrMissingL1ChainID              = errors.New(\"L1 chain ID must not be nil\")\n\tErrMissingL2ChainID              = errors.New(\"L2 chain ID must not be nil\")\n\tErrChainIDsSame                  = errors.New(\"L1 and L2 chain IDs must be different\")\n\tErrL1ChainIDNotPositive          = errors.New(\"L1 chain ID must be non-zero and positive\")\n\tErrL2ChainIDNotPositive          = errors.New(\"L2 chain ID must be non-zero and positive\")\n)\n\ntype Genesis struct {\n\t// The L1 block that the rollup starts *after* (no derived transactions)\n\tL1 eth.BlockID `json:\"l1\"`\n\t// The L2 block the rollup starts from (no transactions, pre-configured state)\n\tL2 eth.BlockID `json:\"l2\"`\n\t// Timestamp of L2 block\n\tL2Time uint64 `json:\"l2_time\"`\n\t// Initial system configuration values.\n\t// The L2 genesis block may not include transactions, and thus cannot encode the config values,\n\t// unlike later L2 blocks.\n\tSystemConfig eth.SystemConfig `json:\"system_config\"`\n}\n\ntype Config struct {\n\t// Genesis anchor point of the rollup\n\tGenesis Genesis `json:\"genesis\"`\n\t// Seconds per L2 block\n\tBlockTime uint64 `json:\"block_time\"`\n\t// Sequencer batches may not be more than MaxSequencerDrift seconds after\n\t// the L1 timestamp of the sequencing window end.\n\t//\n\t// Note: When L1 has many 1 second consecutive blocks, and L2 grows at fixed 2 seconds,\n\t// the L2 time may still grow beyond this difference.\n\tMaxSequencerDrift uint64 `json:\"max_sequencer_drift\"`\n\t// Number of epochs (L1 blocks) per sequencing window, including the epoch L1 origin block itself\n\tSeqWindowSize uint64 `json:\"seq_window_size\"`\n\t// Number of L1 blocks between when a channel can be opened and when it must be closed by.\n\tChannelTimeout uint64 `json:\"channel_timeout\"`\n\t// Required to verify L1 signatures\n\tL1ChainID *big.Int `json:\"l1_chain_id\"`\n\t// Required to identify the L2 network and create p2p signatures unique for this chain.\n\tL2ChainID *big.Int `json:\"l2_chain_id\"`\n\n\t// RegolithTime sets the activation time of the Regolith network-upgrade:\n\t// a pre-mainnet Bedrock change that addresses findings of the Sherlock contest related to deposit attributes.\n\t// \"Regolith\" is the loose deposited rock that sits on top of Bedrock.\n\t// Active if RegolithTime != nil && L2 block timestamp >= *RegolithTime, inactive otherwise.\n\tRegolithTime *uint64 `json:\"regolith_time,omitempty\"`\n\n\t// BaseFeeTime sets the activation time of the BaseFee network-upgrade:\n\t// Active if BaseFeeTime != nil && L2 block timestamp >= *BaseFeeTime, inactive otherwise.\n\tBaseFeeTime *uint64 `json:\"base_fee_time,omitempty\"`\n\n\t// Note: below addresses are part of the block-derivation process,\n\t// and required to be the same network-wide to stay in consensus.\n\n\t// L1 address that batches are sent to.\n\tBatchInboxAddress common.Address `json:\"batch_inbox_address\"`\n\t// L1 Deposit Contract Address\n\tDepositContractAddress common.Address `json:\"deposit_contract_address\"`\n\t// L1 System Config Address\n\tL1SystemConfigAddress common.Address `json:\"l1_system_config_address\"`\n\t// MANTLE DA MODIFY //\n\t// Use Da from MantleDA(EigenDA)\n\tMantleDaSwitch bool `json:\"mantle_da_switch\"`\n\t// MantleDA(EigenDA) DataLayrServiceManage contract address\n\tDataLayrServiceManagerAddr string `json:\"datalayr_service_manager_addr\"`\n}\n\n// ValidateL1Config checks L1 config variables for errors.\nfunc (cfg *Config) ValidateL1Config(ctx context.Context, client L1Client) error {\n\t// Validate the L1 Client Chain ID\n\tif err := cfg.CheckL1ChainID(ctx, client); err != nil {\n\t\treturn err\n\t}\n\n\t// Validate the Rollup L1 Genesis Blockhash\n\tif err := cfg.CheckL1GenesisBlockHash(ctx, client); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ValidateL2Config checks L2 config variables for errors.\nfunc (cfg *Config) ValidateL2Config(ctx context.Context, client L2Client) error {\n\t// Validate the L2 Client Chain ID\n\tif err := cfg.CheckL2ChainID(ctx, client); err != nil {\n\t\treturn err\n\t}\n\n\t// Validate the Rollup L2 Genesis Blockhash\n\tif err := cfg.CheckL2GenesisBlockHash(ctx, client); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (cfg *Config) TargetBlockNumber(timestamp uint64) (num uint64, err error) {\n\t// subtract genesis time from timestamp to get the time elapsed since genesis, and then divide that\n\t// difference by the block time to get the expected L2 block number at the current time. If the\n\t// unsafe head does not have this block number, then there is a gap in the queue.\n\tgenesisTimestamp := cfg.Genesis.L2Time\n\tif timestamp < genesisTimestamp {\n\t\treturn 0, fmt.Errorf(\"did not reach genesis time (%d) yet\", genesisTimestamp)\n\t}\n\twallClockGenesisDiff := timestamp - genesisTimestamp\n\t// Note: round down, we should not request blocks into the future.\n\tblocksSinceGenesis := wallClockGenesisDiff / cfg.BlockTime\n\treturn cfg.Genesis.L2.Number + blocksSinceGenesis, nil\n}\n\ntype L1Client interface {\n\tChainID(context.Context) (*big.Int, error)\n\tL1BlockRefByNumber(context.Context, uint64) (eth.L1BlockRef, error)\n}\n\n// CheckL1ChainID checks that the configured L1 chain ID matches the client's chain ID.\nfunc (cfg *Config) CheckL1ChainID(ctx context.Context, client L1Client) error {\n\tid, err := client.ChainID(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cfg.L1ChainID.Cmp(id) != 0 {\n\t\treturn fmt.Errorf(\"incorrect L1 RPC chain id %d, expected %d\", cfg.L1ChainID, id)\n\t}\n\treturn nil\n}\n\n// CheckL1GenesisBlockHash checks that the configured L1 genesis block hash is valid for the given client.\nfunc (cfg *Config) CheckL1GenesisBlockHash(ctx context.Context, client L1Client) error {\n\tl1GenesisBlockRef, err := client.L1BlockRefByNumber(ctx, cfg.Genesis.L1.Number)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif l1GenesisBlockRef.Hash != cfg.Genesis.L1.Hash {\n\t\treturn fmt.Errorf(\"incorrect L1 genesis block hash %d, expected %d\", cfg.Genesis.L1.Hash, l1GenesisBlockRef.Hash)\n\t}\n\treturn nil\n}\n\ntype L2Client interface {\n\tChainID(context.Context) (*big.Int, error)\n\tL2BlockRefByNumber(context.Context, uint64) (eth.L2BlockRef, error)\n}\n\n// CheckL2ChainID checks that the configured L2 chain ID matches the client's chain ID.\nfunc (cfg *Config) CheckL2ChainID(ctx context.Context, client L2Client) error {\n\tid, err := client.ChainID(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cfg.L2ChainID.Cmp(id) != 0 {\n\t\treturn fmt.Errorf(\"incorrect L2 RPC chain id, expected from config %d, obtained from client %d\", cfg.L2ChainID, id)\n\t}\n\treturn nil\n}\n\n// CheckL2GenesisBlockHash checks that the configured L2 genesis block hash is valid for the given client.\nfunc (cfg *Config) CheckL2GenesisBlockHash(ctx context.Context, client L2Client) error {\n\tl2GenesisBlockRef, err := client.L2BlockRefByNumber(ctx, cfg.Genesis.L2.Number)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif l2GenesisBlockRef.Hash != cfg.Genesis.L2.Hash {\n\t\treturn fmt.Errorf(\"incorrect L2 genesis block hash %d, expected %d\", cfg.Genesis.L2.Hash, l2GenesisBlockRef.Hash)\n\t}\n\treturn nil\n}\n\n// Check verifies that the given configuration makes sense\nfunc (cfg *Config) Check() error {\n\tif cfg.BlockTime == 0 {\n\t\treturn ErrBlockTimeZero\n\t}\n\tif cfg.ChannelTimeout == 0 {\n\t\treturn ErrMissingChannelTimeout\n\t}\n\tif cfg.SeqWindowSize < 2 {\n\t\treturn ErrInvalidSeqWindowSize\n\t}\n\tif cfg.Genesis.L1.Hash == (common.Hash{}) {\n\t\treturn ErrMissingGenesisL1Hash\n\t}\n\tif cfg.Genesis.L2.Hash == (common.Hash{}) {\n\t\treturn ErrMissingGenesisL2Hash\n\t}\n\tif cfg.Genesis.L2.Hash == cfg.Genesis.L1.Hash {\n\t\treturn ErrGenesisHashesSame\n\t}\n\tif cfg.Genesis.L2Time == 0 {\n\t\treturn ErrMissingGenesisL2Time\n\t}\n\tif cfg.Genesis.SystemConfig.BatcherAddr == (common.Address{}) {\n\t\treturn ErrMissingBatcherAddr\n\t}\n\tif cfg.Genesis.SystemConfig.Overhead == (eth.Bytes32{}) {\n\t\treturn ErrMissingOverhead\n\t}\n\tif cfg.Genesis.SystemConfig.Scalar == (eth.Bytes32{}) {\n\t\treturn ErrMissingScalar\n\t}\n\tif cfg.Genesis.SystemConfig.GasLimit == 0 {\n\t\treturn ErrMissingGasLimit\n\t}\n\tif cfg.Genesis.SystemConfig.BaseFee == nil {\n\t\treturn ErrMissingBaseFee\n\t}\n\tif cfg.BatchInboxAddress == (common.Address{}) {\n\t\treturn ErrMissingBatchInboxAddress\n\t}\n\tif cfg.DepositContractAddress == (common.Address{}) {\n\t\treturn ErrMissingDepositContractAddress\n\t}\n\tif cfg.L1ChainID == nil {\n\t\treturn ErrMissingL1ChainID\n\t}\n\tif cfg.L2ChainID == nil {\n\t\treturn ErrMissingL2ChainID\n\t}\n\tif cfg.L1ChainID.Cmp(cfg.L2ChainID) == 0 {\n\t\treturn ErrChainIDsSame\n\t}\n\tif cfg.L1ChainID.Sign() < 1 {\n\t\treturn ErrL1ChainIDNotPositive\n\t}\n\tif cfg.L2ChainID.Sign() < 1 {\n\t\treturn ErrL2ChainIDNotPositive\n\t}\n\treturn nil\n}\n\nfunc (c *Config) L1Signer() types.Signer {\n\treturn types.NewLondonSigner(c.L1ChainID)\n}\n\n// IsRegolith returns true if the Regolith hardfork is active at or past the given timestamp.\nfunc (c *Config) IsRegolith(timestamp uint64) bool {\n\treturn c.RegolithTime != nil && timestamp >= *c.RegolithTime\n}\n\n// IsBaseFee returns true if the BaseFee hardfork is active at or past the given timestamp.\nfunc (c *Config) IsBaseFee(timestamp uint64) bool {\n\treturn c.BaseFeeTime != nil && timestamp >= *c.BaseFeeTime\n}\n\n// Description outputs a banner describing the important parts of rollup configuration in a human-readable form.\n// Optionally provide a mapping of L2 chain IDs to network names to label the L2 chain with if not unknown.\n// The config should be config.Check()-ed before creating a description.\nfunc (c *Config) Description(l2Chains map[string]string) string {\n\t// Find and report the network the user is running\n\tvar banner string\n\tnetworkL2 := \"\"\n\tif l2Chains != nil {\n\t\tnetworkL2 = l2Chains[c.L2ChainID.String()]\n\t}\n\tif networkL2 == \"\" {\n\t\tnetworkL2 = \"unknown L2\"\n\t}\n\tnetworkL1 := params.NetworkNames[c.L1ChainID.String()]\n\tif networkL1 == \"\" {\n\t\tnetworkL1 = \"unknown L1\"\n\t}\n\tbanner += fmt.Sprintf(\"L2 Chain ID: %v (%s)\\n\", c.L2ChainID, networkL2)\n\tbanner += fmt.Sprintf(\"L1 Chain ID: %v (%s)\\n\", c.L1ChainID, networkL1)\n\t// Report the genesis configuration\n\tbanner += \"Bedrock starting point:\\n\"\n\tbanner += fmt.Sprintf(\"  L2 starting time: %d ~ %s\\n\", c.Genesis.L2Time, fmtTime(c.Genesis.L2Time))\n\tbanner += fmt.Sprintf(\"  L2 block: %s %d\\n\", c.Genesis.L2.Hash, c.Genesis.L2.Number)\n\tbanner += fmt.Sprintf(\"  L1 block: %s %d\\n\", c.Genesis.L1.Hash, c.Genesis.L1.Number)\n\t// Report the upgrade configuration\n\tbanner += \"Post-Bedrock Network Upgrades (timestamp based):\\n\"\n\tbanner += fmt.Sprintf(\"  - Regolith: %s\\n\", fmtForkTimeOrUnset(c.RegolithTime))\n\treturn banner\n}\n\n// LogDescription outputs a banner describing the important parts of rollup configuration in a log format.\n// Optionally provide a mapping of L2 chain IDs to network names to label the L2 chain with if not unknown.\n// The config should be config.Check()-ed before creating a description.\nfunc (c *Config) LogDescription(log log.Logger, l2Chains map[string]string) {\n\t// Find and report the network the user is running\n\tnetworkL2 := \"\"\n\tif l2Chains != nil {\n\t\tnetworkL2 = l2Chains[c.L2ChainID.String()]\n\t}\n\tif networkL2 == \"\" {\n\t\tnetworkL2 = \"unknown L2\"\n\t}\n\tnetworkL1 := params.NetworkNames[c.L1ChainID.String()]\n\tif networkL1 == \"\" {\n\t\tnetworkL1 = \"unknown L1\"\n\t}\n\tlog.Info(\"Rollup Config\", \"l2_chain_id\", c.L2ChainID, \"l2_network\", networkL2, \"l1_chain_id\", c.L1ChainID,\n\t\t\"l1_network\", networkL1, \"l2_start_time\", c.Genesis.L2Time, \"l2_block_hash\", c.Genesis.L2.Hash.String(),\n\t\t\"l2_block_number\", c.Genesis.L2.Number, \"l1_block_hash\", c.Genesis.L1.Hash.String(),\n\t\t\"l1_block_number\", c.Genesis.L1.Number, \"regolith_time\", fmtForkTimeOrUnset(c.RegolithTime))\n}\n\nfunc fmtForkTimeOrUnset(v *uint64) string {\n\tif v == nil {\n\t\treturn \"(not configured)\"\n\t}\n\tif *v == 0 { // don't output the unix epoch time if it's really just activated at genesis.\n\t\treturn \"@ genesis\"\n\t}\n\treturn fmt.Sprintf(\"@ %-10v ~ %s\", *v, fmtTime(*v))\n}\n\nfunc fmtTime(v uint64) string {\n\treturn time.Unix(int64(v), 0).Format(time.UnixDate)\n}\n\ntype Epoch uint64"
    },
    {
      "filename": "op-node/rollup/types.go",
      "content": "package rollup\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\n\t\"github.com/ethereum-optimism/optimism/op-node/eth\"\n)\n\nvar (\n\tErrBlockTimeZero                 = errors.New(\"block time cannot be 0\")\n\tErrMissingChannelTimeout         = errors.New(\"channel timeout must be set, this should cover at least a L1 block time\")\n\tErrInvalidSeqWindowSize          = errors.New(\"sequencing window size must at least be 2\")\n\tErrMissingGenesisL1Hash          = errors.New(\"genesis L1 hash cannot be empty\")\n\tErrMissingGenesisL2Hash          = errors.New(\"genesis L2 hash cannot be empty\")\n\tErrGenesisHashesSame             = errors.New(\"achievement get! rollup inception: L1 and L2 genesis cannot be the same\")\n\tErrMissingGenesisL2Time          = errors.New(\"missing L2 genesis time\")\n\tErrMissingBatcherAddr            = errors.New(\"missing genesis system config batcher address\")\n\tErrMissingOverhead               = errors.New(\"missing genesis system config overhead\")\n\tErrMissingScalar                 = errors.New(\"missing genesis system config scalar\")\n\tErrMissingGasLimit               = errors.New(\"missing genesis system config gas limit\")\n\tErrMissingBaseFee                = errors.New(\"missing genesis system config base fee\")\n\tErrMissingBatchInboxAddress      = errors.New(\"missing batch inbox address\")\n\tErrMissingDepositContractAddress = errors.New(\"missing deposit contract address\")\n\tErrMissingL1ChainID              = errors.New(\"L1 chain ID must not be nil\")\n\tErrMissingL2ChainID              = errors.New(\"L2 chain ID must not be nil\")\n\tErrChainIDsSame                  = errors.New(\"L1 and L2 chain IDs must be different\")\n\tErrL1ChainIDNotPositive          = errors.New(\"L1 chain ID must be non-zero and positive\")\n\tErrL2ChainIDNotPositive          = errors.New(\"L2 chain ID must be non-zero and positive\")\n)\n\ntype Genesis struct {\n\t// The L1 block that the rollup starts *after* (no derived transactions)\n\tL1 eth.BlockID `json:\"l1\"`\n\t// The L2 block the rollup starts from (no transactions, pre-configured state)\n\tL2 eth.BlockID `json:\"l2\"`\n\t// Timestamp of L2 block\n\tL2Time uint64 `json:\"l2_time\"`\n\t// Initial system configuration values.\n\t// The L2 genesis block may not include transactions, and thus cannot encode the config values,\n\t// unlike later L2 blocks.\n\tSystemConfig eth.SystemConfig `json:\"system_config\"`\n}\n\ntype Config struct {\n\t// Genesis anchor point of the rollup\n\tGenesis Genesis `json:\"genesis\"`\n\t// Seconds per L2 block\n\tBlockTime uint64 `json:\"block_time\"`\n\t// Sequencer batches may not be more than MaxSequencerDrift seconds after\n\t// the L1 timestamp of the sequencing window end.\n\t//\n\t// Note: When L1 has many 1 second consecutive blocks, and L2 grows at fixed 2 seconds,\n\t// the L2 time may still grow beyond this difference.\n\tMaxSequencerDrift uint64 `json:\"max_sequencer_drift\"`\n\t// Number of epochs (L1 blocks) per sequencing window, including the epoch L1 origin block itself\n\tSeqWindowSize uint64 `json:\"seq_window_size\"`\n\t// Number of L1 blocks between when a channel can be opened and when it must be closed by.\n\tChannelTimeout uint64 `json:\"channel_timeout\"`\n\t// Required to verify L1 signatures\n\tL1ChainID *big.Int `json:\"l1_chain_id\"`\n\t// Required to identify the L2 network and create p2p signatures unique for this chain.\n\tL2ChainID *big.Int `json:\"l2_chain_id\"`\n\n\t// RegolithTime sets the activation time of the Regolith network-upgrade:\n\t// a pre-mainnet Bedrock change that addresses findings of the Sherlock contest related to deposit attributes.\n\t// \"Regolith\" is the loose deposited rock that sits on top of Bedrock.\n\t// Active if RegolithTime != nil && L2 block timestamp >= *RegolithTime, inactive otherwise.\n\tRegolithTime *uint64 `json:\"regolith_time,omitempty\"`\n\n\t// BaseFeeTime sets the activation time of the BaseFee network-upgrade:\n\t// Active if BaseFeeTime != nil && L2 block timestamp >= *BaseFeeTime, inactive otherwise.\n\tBaseFeeTime *uint64 `json:\"base_fee_time,omitempty\"`\n\n\t// Note: below addresses are part of the block-derivation process,\n\t// and required to be the same network-wide to stay in consensus.\n\n\t// L1 address that batches are sent to.\n\tBatchInboxAddress common.Address `json:\"batch_inbox_address\"`\n\t// L1 Deposit Contract Address\n\tDepositContractAddress common.Address `json:\"deposit_contract_address\"`\n\t// L1 System Config Address\n\tL1SystemConfigAddress common.Address `json:\"l1_system_config_address\"`\n\t// MANTLE DA MODIFY //\n\t// Use Da from MantleDA(EigenDA)\n\tMantleDaSwitch bool `json:\"mantle_da_switch\"`\n\t// MantleDA(EigenDA) DataLayrServiceManage contract address\n\tDataLayrServiceManagerAddr string `json:\"datalayr_service_manager_addr\"`\n}\n\n// ValidateL1Config checks L1 config variables for errors.\nfunc (cfg *Config) ValidateL1Config(ctx context.Context, client L1Client) error {\n\t// Validate the L1 Client Chain ID\n\tif err := cfg.CheckL1ChainID(ctx, client); err != nil {\n\t\treturn err\n\t}\n\n\t// Validate the Rollup L1 Genesis Blockhash\n\tif err := cfg.CheckL1GenesisBlockHash(ctx, client); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// ValidateL2Config checks L2 config variables for errors.\nfunc (cfg *Config) ValidateL2Config(ctx context.Context, client L2Client) error {\n\t// Validate the L2 Client Chain ID\n\tif err := cfg.CheckL2ChainID(ctx, client); err != nil {\n\t\treturn err\n\t}\n\n\t// Validate the Rollup L2 Genesis Blockhash\n\tif err := cfg.CheckL2GenesisBlockHash(ctx, client); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (cfg *Config) TargetBlockNumber(timestamp uint64) (num uint64, err error) {\n\t// subtract genesis time from timestamp to get the time elapsed since genesis, and then divide that\n\t// difference by the block time to get the expected L2 block number at the current time. If the\n\t// unsafe head does not have this block number, then there is a gap in the queue.\n\tgenesisTimestamp := cfg.Genesis.L2Time\n\tif timestamp < genesisTimestamp {\n\t\treturn 0, fmt.Errorf(\"did not reach genesis time (%d) yet\", genesisTimestamp)\n\t}\n\twallClockGenesisDiff := timestamp - genesisTimestamp\n\t// Note: round down, we should not request blocks into the future.\n\tblocksSinceGenesis := wallClockGenesisDiff / cfg.BlockTime\n\treturn cfg.Genesis.L2.Number + blocksSinceGenesis, nil\n}\n\ntype L1Client interface {\n\tChainID(context.Context) (*big.Int, error)\n\tL1BlockRefByNumber(context.Context, uint64) (eth.L1BlockRef, error)\n}\n\n// CheckL1ChainID checks that the configured L1 chain ID matches the client's chain ID.\nfunc (cfg *Config) CheckL1ChainID(ctx context.Context, client L1Client) error {\n\tid, err := client.ChainID(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cfg.L1ChainID.Cmp(id) != 0 {\n\t\treturn fmt.Errorf(\"incorrect L1 RPC chain id %d, expected %d\", cfg.L1ChainID, id)\n\t}\n\treturn nil\n}\n\n// CheckL1GenesisBlockHash checks that the configured L1 genesis block hash is valid for the given client.\nfunc (cfg *Config) CheckL1GenesisBlockHash(ctx context.Context, client L1Client) error {\n\tl1GenesisBlockRef, err := client.L1BlockRefByNumber(ctx, cfg.Genesis.L1.Number)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif l1GenesisBlockRef.Hash != cfg.Genesis.L1.Hash {\n\t\treturn fmt.Errorf(\"incorrect L1 genesis block hash %d, expected %d\", cfg.Genesis.L1.Hash, l1GenesisBlockRef.Hash)\n\t}\n\treturn nil\n}\n\ntype L2Client interface {\n\tChainID(context.Context) (*big.Int, error)\n\tL2BlockRefByNumber(context.Context, uint64) (eth.L2BlockRef, error)\n}\n\n// CheckL2ChainID checks that the configured L2 chain ID matches the client's chain ID.\nfunc (cfg *Config) CheckL2ChainID(ctx context.Context, client L2Client) error {\n\tid, err := client.ChainID(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cfg.L2ChainID.Cmp(id) != 0 {\n\t\treturn fmt.Errorf(\"incorrect L2 RPC chain id, expected from config %d, obtained from client %d\", cfg.L2ChainID, id)\n\t}\n\treturn nil\n}\n\n// CheckL2GenesisBlockHash checks that the configured L2 genesis block hash is valid for the given client.\nfunc (cfg *Config) CheckL2GenesisBlockHash(ctx context.Context, client L2Client) error {\n\tl2GenesisBlockRef, err := client.L2BlockRefByNumber(ctx, cfg.Genesis.L2.Number)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif l2GenesisBlockRef.Hash != cfg.Genesis.L2.Hash {\n\t\treturn fmt.Errorf(\"incorrect L2 genesis block hash %d, expected %d\", cfg.Genesis.L2.Hash, l2GenesisBlockRef.Hash)\n\t}\n\treturn nil\n}\n\n// Check verifies that the given configuration makes sense\nfunc (cfg *Config) Check() error {\n\tif cfg.BlockTime == 0 {\n\t\treturn ErrBlockTimeZero\n\t}\n\tif cfg.ChannelTimeout == 0 {\n\t\treturn ErrMissingChannelTimeout\n\t}\n\tif cfg.SeqWindowSize < 2 {\n\t\treturn ErrInvalidSeqWindowSize\n\t}\n\tif cfg.Genesis.L1.Hash == (common.Hash{}) {\n\t\treturn ErrMissingGenesisL1Hash\n\t}\n\tif cfg.Genesis.L2.Hash == (common.Hash{}) {\n\t\treturn ErrMissingGenesisL2Hash\n\t}\n\tif cfg.Genesis.L2.Hash == cfg.Genesis.L1.Hash {\n\t\treturn ErrGenesisHashesSame\n\t}\n\tif cfg.Genesis.L2Time == 0 {\n\t\treturn ErrMissingGenesisL2Time\n\t}\n\tif cfg.Genesis.SystemConfig.BatcherAddr == (common.Address{}) {\n\t\treturn ErrMissingBatcherAddr\n\t}\n\tif cfg.Genesis.SystemConfig.Overhead == (eth.Bytes32{}) {\n\t\treturn ErrMissingOverhead\n\t}\n\tif cfg.Genesis.SystemConfig.Scalar == (eth.Bytes32{}) {\n\t\treturn ErrMissingScalar\n\t}\n\tif cfg.Genesis.SystemConfig.GasLimit == 0 {\n\t\treturn ErrMissingGasLimit\n\t}\n\tif cfg.Genesis.SystemConfig.BaseFee == nil {\n\t\treturn ErrMissingBaseFee\n\t}\n\tif cfg.BatchInboxAddress == (common.Address{}) {\n\t\treturn ErrMissingBatchInboxAddress\n\t}\n\tif cfg.DepositContractAddress == (common.Address{}) {\n\t\treturn ErrMissingDepositContractAddress\n\t}\n\tif cfg.L1ChainID == nil {\n\t\treturn ErrMissingL1ChainID\n\t}\n\tif cfg.L2ChainID == nil {\n\t\treturn ErrMissingL2ChainID\n\t}\n\tif cfg.L1ChainID.Cmp(cfg.L2ChainID) == 0 {\n\t\treturn ErrChainIDsSame\n\t}\n\tif cfg.L1ChainID.Sign() < 1 {\n\t\treturn ErrL1ChainIDNotPositive\n\t}\n\tif cfg.L2ChainID.Sign() < 1 {\n\t\treturn ErrL2ChainIDNotPositive\n\t}\n\treturn nil\n}\n\nfunc (c *Config) L1Signer() types.Signer {\n\treturn types.NewLondonSigner(c.L1ChainID)\n}\n\n// IsRegolith returns true if the Regolith hardfork is active at or past the given timestamp.\nfunc (c *Config) IsRegolith(timestamp uint64) bool {\n\treturn c.RegolithTime != nil && timestamp >= *c.RegolithTime\n}\n\n// IsBaseFee returns true if the BaseFee hardfork is active at or past the given timestamp.\nfunc (c *Config) IsBaseFee(timestamp uint64) bool {\n\treturn c.BaseFeeTime != nil && timestamp >= *c.BaseFeeTime\n}\n\n// Description outputs a banner describing the important parts of rollup configuration in a human-readable form.\n// Optionally provide a mapping of L2 chain IDs to network names to label the L2 chain with if not unknown.\n// The config should be config.Check()-ed before creating a description.\nfunc (c *Config) Description(l2Chains map[string]string) string {\n\t// Find and report the network the user is running\n\tvar banner string\n\tnetworkL2 := \"\"\n\tif l2Chains != nil {\n\t\tnetworkL2 = l2Chains[c.L2ChainID.String()]\n\t}\n\tif networkL2 == \"\" {\n\t\tnetworkL2 = \"unknown L2\"\n\t}\n\tnetworkL1 := params.NetworkNames[c.L1ChainID.String()]\n\tif networkL1 == \"\" {\n\t\tnetworkL1 = \"unknown L1\"\n\t}\n\tbanner += fmt.Sprintf(\"L2 Chain ID: %v (%s)\\n\", c.L2ChainID, networkL2)\n\tbanner += fmt.Sprintf(\"L1 Chain ID: %v (%s)\\n\", c.L1ChainID, networkL1)\n\t// Report the genesis configuration\n\tbanner += \"Bedrock starting point:\\n\"\n\tbanner += fmt.Sprintf(\"  L2 starting time: %d ~ %s\\n\", c.Genesis.L2Time, fmtTime(c.Genesis.L2Time))\n\tbanner += fmt.Sprintf(\"  L2 block: %s %d\\n\", c.Genesis.L2.Hash, c.Genesis.L2.Number)\n\tbanner += fmt.Sprintf(\"  L1 block: %s %d\\n\", c.Genesis.L1.Hash, c.Genesis.L1.Number)\n\t// Report the upgrade configuration\n\tbanner += \"Post-Bedrock Network Upgrades (timestamp based):\\n\"\n\tbanner += fmt.Sprintf(\"  - Regolith: %s\\n\", fmtForkTimeOrUnset(c.RegolithTime))\n\treturn banner\n}\n\n// LogDescription outputs a banner describing the important parts of rollup configuration in a log format.\n// Optionally provide a mapping of L2 chain IDs to network names to label the L2 chain with if not unknown.\n// The config should be config.Check()-ed before creating a description.\nfunc (c *Config) LogDescription(log log.Logger, l2Chains map[string]string) {\n\t// Find and report the network the user is running\n\tnetworkL2 := \"\"\n\tif l2Chains != nil {\n\t\tnetworkL2 = l2Chains[c.L2ChainID.String()]\n\t}\n\tif networkL2 == \"\" {\n\t\tnetworkL2 = \"unknown L2\"\n\t}\n\tnetworkL1 := params.NetworkNames[c.L1ChainID.String()]\n\tif networkL1 == \"\" {\n\t\tnetworkL1 = \"unknown L1\"\n\t}\n\tlog.Info(\"Rollup Config\", \"l2_chain_id\", c.L2ChainID, \"l2_network\", networkL2, \"l1_chain_id\", c.L1ChainID,\n\t\t\"l1_network\", networkL1, \"l2_start_time\", c.Genesis.L2Time, \"l2_block_hash\", c.Genesis.L2.Hash.String(),\n\t\t\"l2_block_number\", c.Genesis.L2.Number, \"l1_block_hash\", c.Genesis.L1.Hash.String(),\n\t\t\"l1_block_number\", c.Genesis.L1.Number, \"regolith_time\", fmtForkTimeOrUnset(c.RegolithTime))\n}\n\nfunc fmtForkTimeOrUnset(v *uint64) string {\n\tif v == nil {\n\t\treturn \"(not configured)\"\n\t}\n\tif *v == 0 { // don't output the unix epoch time if it's really just activated at genesis.\n\t\treturn \"@ genesis\"\n\t}\n\treturn fmt.Sprintf(\"@ %-10v ~ %s\", *v, fmtTime(*v))\n}\n\nfunc fmtTime(v uint64) string {\n\treturn time.Unix(int64(v), 0).Format(time.UnixDate)\n}\n\ntype Epoch uint64"
    }
  ]
}