{
  "Title": "[M-01] Update in strategy will cause wrong issuance of shares",
  "Content": "\n<https://github.com/code-423n4/2023-11-kelp/blob/main/src/LRTOracle.sol#L70><br>\n<https://github.com/code-423n4/2023-11-kelp/blob/main/src/LRTDepositPool.sol#L49><br>\n<https://github.com/code-423n4/2023-11-kelp/blob/main/src/LRTDepositPool.sol#L84><br>\n<https://github.com/code-423n4/2023-11-kelp/blob/main/src/NodeDelegator.sol#L122-L123>\n\nIf there is update in strategy, `getTotalAssetDeposits(asset)` will reduce for asset. Because it checks for the [assets deposited in NodeDelegator](https://github.com/code-423n4/2023-11-kelp/blob/main/src/LRTDepositPool.sol#L84). NodeDelegator.getAssetBalance() will check for asset balance for the strategy of the user. If strategy is updated, then the balance of old strategy won't be taken into account which will reduce the totalDeposits. This will reduce the rsETH share price and cause more rsETH shares to be minted for the depositors. Thus, depositors can immediately deposit and their shares are worth more than their deposit.\n\n### Proof of Concept\n\n    contract LRTDepositPoolTest is BaseTest, RSETHTest {\n        LRTDepositPool public lrtDepositPool;\n        LRTOracle public lrtOracle;\n        NodeDelegator public nodeDelegator;\n        ILRTConfig public ilrtConfig;\n        MockEigenStrategyManager public mockEigenStraregyManager;\n        MockStrategy public mockStrategy1;\n        MockStrategy public mockStrategy2;\n\n        function setUp() public virtual override(RSETHTest, BaseTest) {\n            super.setUp();\n            // deploy LRTDepositPool\n            ProxyAdmin proxyAdmin = new ProxyAdmin();\n            LRTDepositPool contractImpl = new LRTDepositPool();\n            TransparentUpgradeableProxy contractProxy = new TransparentUpgradeableProxy(\n                    address(contractImpl),\n                    address(proxyAdmin),\n                    \"\"\n                );\n            lrtDepositPool = LRTDepositPool(address(contractProxy));\n\n            //deploy rsETH\n            proxyAdmin = new ProxyAdmin();\n            RSETH tokenImpl = new RSETH();\n            TransparentUpgradeableProxy tokenProxy = new TransparentUpgradeableProxy(\n                    address(tokenImpl),\n                    address(proxyAdmin),\n                    \"\"\n                );\n            rseth = RSETH(address(tokenProxy));\n\n            //deploy lrtConfig\n            proxyAdmin = new ProxyAdmin();\n            LRTConfig lrtConfigImpl = new LRTConfig();\n            TransparentUpgradeableProxy lrtConfigProxy = new TransparentUpgradeableProxy(\n                    address(lrtConfigImpl),\n                    address(proxyAdmin),\n                    \"\"\n                );\n\n            lrtConfig = LRTConfig(address(lrtConfigProxy));\n\n            // initialize RSETH. LRTCOnfig is already initialized in RSETHTest\n            // rseth.initialize(address(admin), address(lrtConfig));\n            // add rsETH to LRT config\n            // lrtConfig.setRSETH(address(rseth));\n            // add oracle to LRT config\n\n            // deploy LRTOracle\n            ProxyAdmin proxyAdmin1 = new ProxyAdmin();\n            lrtOracle = new LRTOracle();\n            TransparentUpgradeableProxy contractProxy1 = new TransparentUpgradeableProxy(\n                    address(lrtOracle),\n                    address(proxyAdmin1),\n                    \"\"\n                );\n            lrtOracle = LRTOracle(address(contractProxy1));\n\n            // deploy NodeDelegator\n            proxyAdmin1 = new ProxyAdmin();\n            nodeDelegator = new NodeDelegator();\n            contractProxy1 = new TransparentUpgradeableProxy(\n                address(nodeDelegator),\n                address(proxyAdmin1),\n                \"\"\n            );\n            nodeDelegator = NodeDelegator(address(contractProxy1));\n\n            lrtConfig.initialize(\n                admin,\n                address(stETH),\n                address(rETH),\n                address(cbETH),\n                address(rseth)\n            );\n            rseth.initialize(admin, address(lrtConfig));\n            lrtOracle.initialize(address(lrtConfig));\n            nodeDelegator.initialize(address(lrtConfig));\n            lrtDepositPool.initialize(address(lrtConfig));\n\n            mockEigenStraregyManager = new MockEigenStrategyManager();\n            mockStrategy1 = new MockStrategy(address(stETH), 0);\n            mockStrategy2 = new MockStrategy(address(stETH), 0);\n\n            vm.startPrank(admin);\n            lrtConfig.setContract(\n                keccak256(\"LRT_DEPOSIT_POOL\"),\n                address(lrtDepositPool)\n            );\n            lrtConfig.setContract(\n                keccak256(\"EIGEN_STRATEGY_MANAGER\"),\n                address(mockEigenStraregyManager)\n            );\n            lrtConfig.grantRole(keccak256(\"MANAGER\"), manager);\n            lrtConfig.setRSETH(address(rseth));\n            vm.stopPrank();\n\n            vm.startPrank(manager);\n            lrtOracle.updatePriceOracleFor(\n                address(stETH),\n                address(new LRTOracleMock())\n            );\n            lrtOracle.updatePriceOracleFor(\n                address(rETH),\n                address(new LRTOracleMock())\n            );\n            lrtOracle.updatePriceOracleFor(\n                address(cbETH),\n                address(new LRTOracleMock())\n            );\n            // lrtConfig.addNewSupportedAsset(address(randomToken), 100_000 ether);\n            // lrtOracle.updatePriceOracleFor(\n            //     address(randomToken),\n            //     address(new LRTOracleMock())\n            // );\n            vm.stopPrank();\n\n            vm.startPrank(admin);\n            lrtConfig.updateAssetStrategy(address(stETH), address(mockStrategy1));\n\n            lrtConfig.setContract(LRTConstants.LRT_ORACLE, address(lrtOracle));\n            // add minter role for rseth to lrtDepositPool\n            rseth.grantRole(rseth.MINTER_ROLE(), address(lrtDepositPool));\n\n            address[] memory nodeDelegatorContracts = new address[](1);\n            nodeDelegatorContracts[0] = address(nodeDelegator);\n            lrtDepositPool.addNodeDelegatorContractToQueue(nodeDelegatorContracts);\n            vm.stopPrank();\n        }\n\n    function test_update_strategy_cause_wrong_minting_of_shares() public {\n            //NOTE: comment line 207-211 in setup for this\n            vm.startPrank(admin);\n            lrtConfig.grantRole(LRTConstants.MANAGER, manager);\n            vm.stopPrank();\n            vm.startPrank(alice);\n            stETH.approve(address(lrtDepositPool), 10 ether);\n            lrtDepositPool.depositAsset(address(stETH), 10 ether); //NOTE: 10000000000000000000 rsETH amount minted\n            vm.stopPrank();\n            vm.startPrank(manager);\n            lrtDepositPool.transferAssetToNodeDelegator(\n                0,\n                address(stETH),\n                10 ether\n            );\n            vm.stopPrank();\n            vm.startPrank(admin);\n            lrtConfig.updateAssetStrategy(address(stETH), address(mockStrategy2));\n            lrtConfig.updateAssetStrategy(address(rETH), address(mockStrategy2));\n            lrtConfig.updateAssetStrategy(address(cbETH), address(mockStrategy2));\n\n            vm.stopPrank();\n            vm.startPrank(alice);\n            stETH.approve(address(lrtDepositPool), 10 ether);\n            lrtDepositPool.depositAsset(address(stETH), 10 ether); //NOTE:   2500000000000000000 rsETH amount minted even after fixing deposit bug\n            vm.stopPrank();\n        }\n    }\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nWhile updating the strategy, ensure that balance deposited in previous strategy for same asset is accounted while minting the shares.\n\n### Assessed type\n\nERC4626\n\n**[gus (Kelp) disputed and commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/197#issuecomment-1825335776):**\n > The Eigenlayer has a 1-1 mapping for asset and its strategy.  We don't believe this an issue with KelpDAO or its code but with Eigenlayer if it upgrades its protocol to have multiple strategies for an asset.  Then if this occurs, KelpDAO will also have to upgrade its contracts to ensure the compatibility to Eigenlayer.<br>\n> Also, if Eigenlayer changes strategies, they are responsible to migrate the internal accounting to the new address. \n\n**[manoj9april (Kelp) commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/197#issuecomment-1833168052):**\n > Currently Eigenlayer's implementation allows them to have multiple startegies for any asset.<br>\n> -> But we can continue to deposit into one strategy for a asset and it won't be a problem for us. That is assuming 1:1 mapping won't harm us.\n> \n> Above assumptions will only create problem in case, Eigenlayer wants to spread the current funds into multiple strategies for any asset in future upgrades. And in this case, they will provide proper heads up ahead of time and we can upgrade along with them accordingly.\n> \n> In case they change their strategy for any asset, we can point to new strategy address and it should work fine. And in this case Eigenlayer should should take care of all migration of funds from old to new strategy.\n> \n> But as currently nothing has been decided at Eigenlayer end. I believe we are good with our current assumption of 1:1. It would be overkill to assume anything else as of now.\n> \n> Please check the attached conversation with Eigenlayer team.<br>\n> Discord: https://discord.com/channels/1089434273720832071/1096331191243788379\n\n**[0xDjango (judge) invalidated and commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/197#issuecomment-1836498666):**\n > Kelp has provided adequate reasoning behind the current design. I agree that it is unlikely that a breaking change from the Eigenlayer protocol would not be properly communicated ahead of time. Designing around this potentiality would impose added risk in the current design.\n\n**[radev\\_sw (warden) commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/197#issuecomment-1837271970):**\n > Hey, @0xDjango.\n> \n> I disagree with the reasons provided above.\n> \n> > *We don't believe this an issue with KelpDAO or its code but with Eigenlayer if it upgrades its protocol to have multiple strategies for an asset.*\n> \n> The problem lies specifically in how Kelp DAO upgrades the strategy for assets. Nothing related to the functionality of EigenLayer Strategies.\n> \n> Let's view at the code of startegy upgrading\n> ```js\n>     function updateAssetStrategy(\n>         address asset,\n>         address strategy\n>     )\n>         external\n>         onlyRole(DEFAULT_ADMIN_ROLE)\n>         onlySupportedAsset(asset)\n>     {\n>         UtilLib.checkNonZeroAddress(strategy);\n>         if (assetStrategy[asset] == strategy) {\n>             revert ValueAlreadyInUse();\n>         }\n>         assetStrategy[asset] = strategy;\n>     }\n> ```\n> \n> As we can see, when an EigenLayer Strategy for an asset is changed, there is currently no mechanism in place to migrate user deposits from the old strategy to the new one. It is precisely in this scenario that the vulnerability arises.\n> \n> If a strategy update occurs, the function `getTotalAssetDeposits(asset)` will show a reduced value for that asset. This reduction happens because the function references assets deposited in NodeDelegator. Specifically, `NodeDelegator.sol#getAssetBalance()` assesses the asset balance based on the user's current strategy. When a strategy update takes place, the balance associated with the previous strategy is no longer considered, leading to a decrease in `totalDeposits`. As a result, the share price of `rsETH` decreases, prompting the system to mint more `rsETH` shares for depositors. Consequently, depositors can make immediate deposits, gaining shares that are more valuable than the actual amount they deposited.\n> \n> This vulnerability describes **significant flaws** in the KelpDAO protocol flow. Nothing related to the functionality of EigenLayer Strategies.\n> \n> > *But as currently nothing has been decided at Eigenlayer end. I believe we are good with our current assumption of 1:1. It would be a overkill to assume anything else as of now.*\n> \n> The recommendations in this report do not make any assumptions about the implementation of 1:1 mapping. Instead, they specifically suggest updating the `updateAssetStrategy()` function. In a way that update would enable the transfer of user deposits from the old strategy to the new strategy once the new strategy is set. (as in my issue [\\#644](https://github.com/code-423n4/2023-11-kelp-findings/issues/644) writes)\n> \n> I believe the issue has been misjudged and should be mitigated to High Severity Issue.\n\n**[manoj9april (Kelp) commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/197#issuecomment-1837404596):**\n > @radev\\_sw - KelpDao will only update the strategy address when EigenLayer updates strategy for any asset (which EigenLayer currently has no plans as such).\n> \n> Even if above scenario takes place. EigenLayer should provide proper communications ahead of time. And we can go through follow below steps:\n> - Eigenlayer communicates strategy update\n> - KelpDao pauses its protocol for a mutually decided duration\n> - EigenLayer migrates its state from old contracts to new contracts\n> - KelpDao points to new strategy contract\n> - KelpDao resumes\n> \n> If migration of contract state is not possible at EigenLayer and they (Eigenlayer) decomission their old strategy, only in this scenario<br>\n> KelpDao will have to withdraw its funds from old strategy and redelgate it to new strategy. And these steps will be done in complete visibility and transparency with proper timelocks.\n> But sees no harm or loss to funds or miscalculation.\n\n**[0xDjango (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-11-kelp-findings/issues/197#issuecomment-1839037847):**\n > This will be upgraded to MEDIUM. \n> \n> The warden accurately explains how **Kelp's** internal accounting will be broken if they decide to use the `updateAssetStrategy()` function. If Kelp changes the strategy address, rsETH share prices will decrease in a way that should not occur.\n> \n> While Kelp describes the list of actions that they would take in the case they would need to change the strategy address, the implementation does not protect against the possibility of the broken accounting.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-11-kelp",
  "Code": [
    {
      "filename": "src/LRTOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { IPriceFetcher } from \"./interfaces/IPriceFetcher.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/// @title LRTOracle Contract\n/// @notice oracle contract that calculates the exchange rate of assets\ncontract LRTOracle is ILRTOracle, LRTConfigRoleChecker, PausableUpgradeable {\n    mapping(address asset => address priceOracle) public override assetPriceOracle;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides Asset/ETH exchange rate\n    /// @dev reads from priceFetcher interface which may fetch price from any supported oracle\n    /// @param asset the asset for which exchange rate is required\n    /// @return assetPrice exchange rate of asset\n    function getAssetPrice(address asset) public view onlySupportedAsset(asset) returns (uint256) {\n        return IPriceFetcher(assetPriceOracle[asset]).getAssetPrice(asset);\n    }\n\n    /// @notice Provides RSETH/ETH exchange rate\n    /// @dev calculates based on stakedAsset value received from eigen layer\n    /// @return rsETHPrice exchange rate of RSETH\n    function getRSETHPrice() external view returns (uint256 rsETHPrice) {\n        address rsETHTokenAddress = lrtConfig.rsETH();\n        uint256 rsEthSupply = IRSETH(rsETHTokenAddress).totalSupply();\n\n        if (rsEthSupply == 0) {\n            return 1 ether;\n        }\n\n        uint256 totalETHInPool;\n        address lrtDepositPoolAddr = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        address[] memory supportedAssets = lrtConfig.getSupportedAssetList();\n        uint256 supportedAssetCount = supportedAssets.length;\n\n        for (uint16 asset_idx; asset_idx < supportedAssetCount;) {\n            address asset = supportedAssets[asset_idx];\n            uint256 assetER = getAssetPrice(asset);\n\n            uint256 totalAssetAmt = ILRTDepositPool(lrtDepositPoolAddr).getTotalAssetDeposits(asset);\n            totalETHInPool += totalAssetAmt * assetER;\n\n            unchecked {\n                ++asset_idx;\n            }\n        }\n\n        return totalETHInPool / rsEthSupply;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev add/update the price oracle of any supported asset\n    /// @dev only LRTManager is allowed\n    /// @param asset asset address for which oracle price needs to be added/updated\n    function updatePriceOracleFor(\n        address asset,\n        address priceOracle\n    )\n        external\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        UtilLib.checkNonZeroAddress(priceOracle);\n        assetPriceOracle[asset] = priceOracle;\n        emit AssetPriceOracleUpdate(asset, priceOracle);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n\n        // interactions\n        uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n        emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n    }\n\n    /// @dev private function to mint rseth. It calculates rseth amount to mint based on asset amount and asset exchange\n    /// rates from oracle\n    /// @param _asset Asset address\n    /// @param _amount Asset amount to mint rseth\n    /// @return rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n        (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT manager\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorCount) {\n            revert MaximumNodeDelegatorCountReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n            nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            emit NodeDelegatorAddedinQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorCount_ Maximum count of node delegator\n    function updateMaxNodeDelegatorCount(uint256 maxNodeDelegatorCount_) external onlyLRTAdmin {\n        maxNodeDelegatorCount = maxNodeDelegatorCount_;\n        emit MaxNodeDelegatorCountUpdated(maxNodeDelegatorCount);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n\n        // interactions\n        uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);\n\n        emit AssetDeposit(asset, depositAmount, rsethAmountMinted);\n    }\n\n    /// @dev private function to mint rseth. It calculates rseth amount to mint based on asset amount and asset exchange\n    /// rates from oracle\n    /// @param _asset Asset address\n    /// @param _amount Asset amount to mint rseth\n    /// @return rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {\n        (rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);\n\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT manager\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorCount) {\n            revert MaximumNodeDelegatorCountReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n            nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            emit NodeDelegatorAddedinQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorCount_ Maximum count of node delegator\n    function updateMaxNodeDelegatorCount(uint256 maxNodeDelegatorCount_) external onlyLRTAdmin {\n        maxNodeDelegatorCount = maxNodeDelegatorCount_;\n        emit MaxNodeDelegatorCountUpdated(maxNodeDelegatorCount);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/NodeDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { IStrategy } from \"./interfaces/IStrategy.sol\";\nimport { IEigenStrategyManager } from \"./interfaces/IEigenStrategyManager.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title NodeDelegator Contract\n/// @notice The contract that handles the depositing of assets into strategies\ncontract NodeDelegator is INodeDelegator, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /// @notice Approves the maximum amount of an asset to the eigen strategy manager\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function maxApproveToEigenStrategyManager(address asset)\n        external\n        override\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n        IERC20(asset).approve(eigenlayerStrategyManagerAddress, type(uint256).max);\n    }\n\n    /// @notice Deposits an asset lying in this NDC into its strategy\n    /// @dev only supported assets can be deposited and only called by the LRT manager\n    /// @param asset the asset to deposit\n    function depositAssetIntoStrategy(address asset)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address strategy = lrtConfig.assetStrategy(asset);\n        IERC20 token = IERC20(asset);\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        uint256 balance = token.balanceOf(address(this));\n\n        emit AssetDepositIntoStrategy(asset, strategy, balance);\n\n        IEigenStrategyManager(eigenlayerStrategyManagerAddress).depositIntoStrategy(IStrategy(strategy), token, balance);\n    }\n\n    /// @notice Transfers an asset back to the LRT deposit pool\n    /// @dev only supported assets can be transferred and only called by the LRT manager\n    /// @param asset the asset to transfer\n    /// @param amount the amount to transfer\n    function transferBackToLRTDepositPool(\n        address asset,\n        uint256 amount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n        onlyLRTManager\n    {\n        address lrtDepositPool = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        if (!IERC20(asset).transfer(lrtDepositPool, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice Fetches balance of all assets staked in eigen layer through this contract\n    /// @return assets the assets that the node delegator has deposited into strategies\n    /// @return assetBalances the balances of the assets that the node delegator has deposited into strategies\n    function getAssetBalances()\n        external\n        view\n        override\n        returns (address[] memory assets, uint256[] memory assetBalances)\n    {\n        address eigenlayerStrategyManagerAddress = lrtConfig.getContract(LRTConstants.EIGEN_STRATEGY_MANAGER);\n\n        (IStrategy[] memory strategies,) =\n            IEigenStrategyManager(eigenlayerStrategyManagerAddress).getDeposits(address(this));\n\n        uint256 strategiesLength = strategies.length;\n        assets = new address[](strategiesLength);\n        assetBalances = new uint256[](strategiesLength);\n\n        for (uint256 i = 0; i < strategiesLength;) {\n            assets[i] = address(IStrategy(strategies[i]).underlyingToken());\n            assetBalances[i] = IStrategy(strategies[i]).userUnderlyingView(address(this));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Returns the balance of an asset that the node delegator has deposited into the strategy\n    /// @param asset the asset to get the balance of\n    /// @return stakedBalance the balance of the asset\n    function getAssetBalance(address asset) external view override returns (uint256) {\n        address strategy = lrtConfig.assetStrategy(asset);\n        return IStrategy(strategy).userUnderlyingView(address(this));\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    },
    {
      "filename": "src/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorCount;\n\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorCount = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount staked in eigen layer through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        // Question: is here the right place to have this? Could it be in LRTConfig?\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    function depositAsset(\n        address asset,\n        uint256 depositAmount\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        if (depositAmount == 0) {\n            revert InvalidAmount();\n        }\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {"
    }
  ]
}