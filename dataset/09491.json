{
  "Title": "[N-08] Remove `include` for ds-test",
  "Content": "\nTest code should not be mixed in with production code. The production version should be extended and have its functions overridden for testing purposes\n\n1.  File: src/SupplySchedule.sol (line [4](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/SupplySchedule.sol#L4))\n\n```solidity\nimport \"ds-test/test.sol\";\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-badger-citadel",
  "Code": [
    {
      "filename": "src/SupplySchedule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"ds-test/test.sol\";\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {MathUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IVault} from \"./interfaces/badger/IVault.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\nSupply schedules are defined in terms of Epochs\n\n*/\ncontract SupplySchedule is GlobalAccessControlManaged, DSTest {\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n\n    uint256 public constant epochLength = 21 days;\n    uint256 public globalStartTimestamp;\n\n    /// epoch index * epoch length = start time\n\n    mapping(uint256 => uint256) public epochRate;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event MintingStartTimeSet(uint256 globalStartTimestamp);\n    event EpochSupplyRateSet(uint256 epoch, uint256 rate);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    function initialize(address _gac) public initializer {\n        __GlobalAccessControlManaged_init(_gac);\n        _setEpochRates();\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    // @dev duplicate of getMintable() with debug print added\n    // @dev this function is out of scope for reviews and audits\n\n    function getEpochAtTimestamp(uint256 _timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        require(\n            globalStartTimestamp > 0,\n            \"SupplySchedule: minting not started\"\n        );\n        return (_timestamp - globalStartTimestamp) / epochLength;\n    }\n\n    function getCurrentEpoch() public view returns (uint256) {\n        return getEpochAtTimestamp(block.timestamp);\n    }\n\n    function getEmissionsForEpoch(uint256 _epoch)\n        public\n        view\n        returns (uint256)\n    {\n        return epochRate[_epoch] * epochLength;\n    }\n\n    function getEmissionsForCurrentEpoch() public view returns (uint256) {\n        uint256 epoch = getCurrentEpoch();\n        return getEmissionsForEpoch(epoch);\n    }\n\n    function getMintable(uint256 lastMintTimestamp)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 cachedGlobalStartTimestamp = globalStartTimestamp;\n        require(\n            cachedGlobalStartTimestamp > 0,\n            \"SupplySchedule: minting not started\"\n        );\n        require(\n            block.timestamp > lastMintTimestamp,\n            \"SupplySchedule: already minted up to current block\"\n        );\n\n        if (lastMintTimestamp < cachedGlobalStartTimestamp) {\n            lastMintTimestamp = cachedGlobalStartTimestamp;\n        }\n\n        uint256 mintable = 0;\n\n        uint256 startingEpoch = (lastMintTimestamp - cachedGlobalStartTimestamp) /\n            epochLength;\n\n        uint256 endingEpoch = (block.timestamp - cachedGlobalStartTimestamp) /\n            epochLength;\n\n        for (uint256 i = startingEpoch; i <= endingEpoch; /** See below ++i */) {\n            uint256 rate = epochRate[i];\n\n            uint256 epochStartTime = cachedGlobalStartTimestamp + i * epochLength;\n            uint256 epochEndTime = cachedGlobalStartTimestamp + (i + 1) * epochLength;\n\n            uint256 time = MathUpgradeable.min(block.timestamp, epochEndTime) -\n                MathUpgradeable.max(lastMintTimestamp, epochStartTime);\n\n            mintable += rate * time;\n\n            unchecked { ++i; }\n        }\n\n        return mintable;\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    function setMintingStart(uint256 _globalStartTimestamp)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n        gacPausable\n    {\n        require(\n            globalStartTimestamp == 0,\n            \"SupplySchedule: minting already started\"\n        );\n        require(\n            _globalStartTimestamp >= block.timestamp,\n            \"SupplySchedule: minting must start at or after current time\"\n        );\n\n        globalStartTimestamp = _globalStartTimestamp;\n        emit MintingStartTimeSet(_globalStartTimestamp);\n    }\n\n    function setEpochRate(uint256 _epoch, uint256 _rate)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n        gacPausable\n    {\n        require(\n            epochRate[_epoch] == 0,\n            \"SupplySchedule: rate already set for given epoch\"\n        );\n        // TODO: Require this epoch is in the future. What happens if no data is set? (It just fails to mint until set)\n        epochRate[_epoch] = _rate;\n        emit EpochSupplyRateSet(_epoch, _rate);\n    }\n\n    /// ========================\n    /// ===== Test actions =====\n    /// ========================\n\n    // @dev Set rates for the initial epochs\n    function _setEpochRates() internal {\n        epochRate[0] = 593962000000000000000000 / epochLength;\n        epochRate[1] = 591445000000000000000000 / epochLength;\n        epochRate[2] = 585021000000000000000000 / epochLength;\n        epochRate[3] = 574138000000000000000000 / epochLength;\n        epochRate[4] = 558275000000000000000000 / epochLength;\n        epochRate[5] = 536986000000000000000000 / epochLength;\n    }\n\n    function getMintableDebug(uint256 lastMintTimestamp) external {\n        require(\n            globalStartTimestamp > 0,\n            \"SupplySchedule: minting not started\"\n        );\n        require(\n            lastMintTimestamp > globalStartTimestamp,\n            \"SupplySchedule: attempting to mint before start block\"\n        );\n        require(\n            block.timestamp > lastMintTimestamp,\n            \"SupplySchedule: already minted up to current block\"\n        );\n\n        uint256 mintable = 0;\n\n        emit log_named_uint(\"mintable\", mintable);\n        emit log_named_uint(\"block.timestamp\", block.timestamp);\n        emit log_named_uint(\"lastMintTimestamp\", lastMintTimestamp);\n        emit log_named_uint(\"globalStartTimestamp\", globalStartTimestamp);\n        emit log_named_uint(\"epochLength\", epochLength);\n\n        uint256 startingEpoch = (lastMintTimestamp - globalStartTimestamp) /\n            epochLength;\n        emit log_named_uint(\"startingEpoch\", startingEpoch);\n\n        uint256 endingEpoch = (block.timestamp - globalStartTimestamp) /\n            epochLength;\n        emit log_named_uint(\"endingEpoch\", endingEpoch);\n\n        for (uint256 i = startingEpoch; i <= endingEpoch; i++) {\n            uint256 rate = epochRate[i];\n\n            uint256 epochStartTime = globalStartTimestamp + i * epochLength;\n            uint256 epochEndTime = globalStartTimestamp + (i + 1) * epochLength;\n\n            emit log_named_uint(\"epoch iteration\", i);\n            emit log_named_uint(\"epochStartTime\", epochStartTime);\n            emit log_named_uint(\"epochEndTime\", epochEndTime);\n\n            uint256 time = MathUpgradeable.min(block.timestamp, epochEndTime) -\n                MathUpgradeable.max(lastMintTimestamp, epochStartTime);\n\n            emit log_named_uint(\"time to mint over\", time);\n\n            mintable += rate * time;\n\n            emit log_named_uint(\"mintable from this iteration\", rate * time);\n            emit log_named_uint(\n                \"total mintable after this iteration\",\n                mintable\n            );\n        }\n\n        // return mintable;\n    }\n}"
    }
  ]
}