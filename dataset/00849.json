{
  "Title": "Inability to revoke rights given in `setAllowedSelectorsForClient` and `setAllowedSelectorsForOperator`",
  "Content": "##### Description\nThe issue is found in [`setAllowedSelectorsForClient`](https://github.com/p2p-org/p2p-ssv-proxy/blob/9dd4728002d9c275e29e8ba38bcf7d90efc7531b/src/p2pSsvProxyFactory/P2pSsvProxyFactory.sol#L285) and [`setAllowedSelectorsForOperator`](https://github.com/p2p-org/p2p-ssv-proxy/blob/9dd4728002d9c275e29e8ba38bcf7d90efc7531b/src/p2pSsvProxyFactory/P2pSsvProxyFactory.sol#L304) functions of `P2pSsvProxyFactory` contract.\nThese functions currently grant access rights for invoking `SsvNetwork` functions directly by `client` and `operator` through [`P2pSsvProxy.fallback`](https://github.com/p2p-org/p2p-ssv-proxy/blob/9dd4728002d9c275e29e8ba38bcf7d90efc7531b/src/p2pSsvProxy/P2pSsvProxy.sol#L154-L156) but do not provide a mechanism to revoke these rights. This shortfall presents a significant security risk, especially in scenarios where excessive permissions are incorrectly assigned by the `owner`. Additionally, the `ssvNetwork` is an upgradeable proxy contract, and the inability to revoke rights in the event of an interface change further increases the vulnerability. \nThis issue is classified as `medium` due to the risks associated with the irreversibility of incorrectly granted access.\n\n##### Recommendation\nTo mitigate this risk, it is recommended to introduce `onlyOwner` functions that enable the revocation of rights for both the `client` and `operator` in invoking specific functions of the `SsvNetwork` through `P2pSsvProxy`.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/p2pSsvProxyFactory/P2pSsvProxyFactory.sol",
      "content": "// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport \"../@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"../interfaces/IDepositContract.sol\";\nimport \"../interfaces/p2p/IFeeDistributor.sol\";\nimport \"../interfaces/p2p/IFeeDistributorFactory.sol\";\nimport \"../interfaces/ssv/ISSVViews.sol\";\n\nimport \"../assetRecovering/OwnableAssetRecoverer.sol\";\nimport \"../access/OwnableWithOperator.sol\";\nimport \"../p2pSsvProxy/P2pSsvProxy.sol\";\nimport \"../structs/P2pStructs.sol\";\nimport \"./IP2pSsvProxyFactory.sol\";\n\n/// @notice Passed address is not a valid FeeDistributorFactory\n/// @param _passedAddress Passed address\nerror P2pSsvProxyFactory__NotFeeDistributorFactory(address _passedAddress);\n\n/// @notice Passed address is not a valid FeeDistributor\n/// @param _passedAddress Passed address\nerror P2pSsvProxyFactory__NotFeeDistributor(address _passedAddress);\n\n/// @notice Passed address is not a valid P2pSsvProxy\n/// @param _passedAddress Passed address\nerror P2pSsvProxyFactory__NotP2pSsvProxy(address _passedAddress);\n\n/// @notice Caller in not an allowed SSV operator owner\n/// @param _caller Caller address\nerror P2pSsvProxyFactory__NotAllowedSsvOperatorOwner(address _caller);\n\n/// @notice Cannot add an already existing SSV operator owner address\n/// @param _ssvOperatorOwner an already existing SSV operator owner address\nerror P2pSsvProxyFactory__SsvOperatorOwnerAlreadyExists(address _ssvOperatorOwner);\n\n/// @notice Cannot remove a nonexisting SSV operator owner address\n/// @param _ssvOperatorOwner a nonexisting SSV operator owner address\nerror P2pSsvProxyFactory__SsvOperatorOwnerDoesNotExist(address _ssvOperatorOwner);\n\n/// @notice This SSV operator ID is not allowed. Check both the operator owner address and the ID for being allowed\n/// @param _ssvOperatorOwner operator owner address\n/// @param _ssvOperatorId operator ID\nerror P2pSsvProxyFactory__SsvOperatorNotAllowed(address _ssvOperatorOwner, uint64 _ssvOperatorId);\n\n/// @notice All operators should belong to different owners\n/// @param _ssvOperatorOwner operator owner who owns at least 2 of the passed operator IDs\n/// @param _ssvOperatorId1 passed operator ID owned by the same owner\n/// @param _ssvOperatorId2 passed operator ID owned by the same owner\nerror P2pSsvProxyFactory__DuplicateOperatorOwnersNotAllowed(\n    address _ssvOperatorOwner,\n    uint64 _ssvOperatorId1,\n    uint64 _ssvOperatorId2\n);\n\n/// @notice All the SSV operator IDs must be unique\n/// @param _ssvOperatorId duplicated operator ID\nerror P2pSsvProxyFactory__DuplicateIdsNotAllowed(uint64 _ssvOperatorId);\n\n/// @notice ETH value passed with the transaction must be equal to the needed value\n/// @param _needed needed ETH value\n/// @param _paid actually sent ETH value\nerror P2pSsvProxyFactory__NotEnoughEtherPaidToCoverSsvFees(uint256 _needed, uint256 _paid);\n\n/// @notice ETH value passed with the transaction must be equal to 32 times validator count\n/// @param _actualEthValue actually sent ETH value\nerror P2pSsvProxyFactory__EthValueMustBe32TimesValidatorCount(uint256 _actualEthValue);\n\n/// @dev We assume, SSV won't either drop 7539x or soar higher than 100 ETH.\n/// If it does, this contract won't be operational and another contract will have to be deployed.\nerror P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiOutOfRange();\n\n/// @notice SSV per ETH exchange rate has not been set. Cannot register validators without it.\nerror P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiNotSet();\n\n/// @notice This SSV operator ID does not belong to the passed owner\n/// @param _operatorId SSV operator ID\n/// @param _passedOwner passed address for SSV operator owner\n/// @param _actualOwner actual SSV operator owner address\nerror P2pSsvProxyFactory__SsvOperatorIdDoesNotBelongToOwner(\n    uint64 _operatorId,\n    address _passedOwner,\n    address _actualOwner\n);\n\n/// @notice Should pass at least 1 selector\nerror P2pSsvProxyFactory__CannotSetZeroSelectors();\n\n/// @notice Should pass at least 1 SSV operator owner\nerror P2pSsvProxyFactory__CannotSetZeroAllowedSsvOperatorOwners();\n\n/// @notice Should pass at least 1 SSV operator owner\nerror P2pSsvProxyFactory__CannotRemoveZeroAllowedSsvOperatorOwners();\n\n/// @notice There should equal number of pubkeys, signatures, and depositDataRoots\n/// @param _ssvValidatorsLength validators list length\n/// @param _signaturesLength signatures list length\n/// @param _depositDataRootsLength depositDataRoots list length\nerror P2pSsvProxyFactory__DepositDataArraysShouldHaveTheSameLength(\n    uint256 _ssvValidatorsLength,\n    uint256 _signaturesLength,\n    uint256 _depositDataRootsLength\n);\n\n/// @title Entry point for SSV validator registration\n/// @dev Deploys P2pSsvProxy instances\ncontract P2pSsvProxyFactory is OwnableAssetRecoverer, OwnableWithOperator, ERC165, IP2pSsvProxyFactory {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Beacon Deposit Contract\n    IDepositContract private immutable i_depositContract;\n\n    /// @notice FeeDistributorFactory\n    IFeeDistributorFactory private immutable i_feeDistributorFactory;\n\n    /// @notice SSV ERC-20 token\n    IERC20 private immutable i_ssvToken;\n\n    /// @notice SSVNetworkViews\n    ISSVViews private immutable i_ssvViews;\n\n    /// @notice Template set by P2P to be used for new FeeDistributor instances.\n    /// @dev Can be changed by P2P at any time. It will only affect the new clusters.\n    /// Existing clusters will keep their existing FeeDistributor instance.\n    address private s_referenceFeeDistributor;\n\n    /// @notice Template set by P2P to be used for new P2pSsvProxy instances.\n    /// @dev Can be changed by P2P at any time. It will only affect the new clusters.\n    /// Existing clusters will keep their existing P2pSsvProxy instance.\n    P2pSsvProxy private s_referenceP2pSsvProxy;\n\n    /// @notice a set of addresses of SSV operator owners (both P2P and partners).\n    /// @dev Only P2P can add or remove addresses from the set.\n    EnumerableSet.AddressSet private s_allowedSsvOperatorOwners;\n\n    /// @notice a mapping of (operator owner address → SSV operator IDs list).\n    /// @dev The list of allowed SSV operator IDs for each address is limited to 8 IDs.\n    /// The operator owner can update only their list. P2P can update lists of any owners.\n    mapping(address => uint64[MAX_ALLOWED_SSV_OPERATOR_IDS]) private s_allowedSsvOperatorIds;\n\n    /// @notice a mapping of (client address → a list of addresses of the deployed client P2pSsvProxy instances).\n    /// @dev Updated automatically during P2pSsvProxy instance deployment.\n    mapping(address => address[]) private s_allClientP2pSsvProxies;\n\n    /// @notice a list of all ever deployed client P2pSsvProxy instances.\n    /// @dev Updated automatically during P2pSsvProxy instance deployment.\n    address[] private s_allP2pSsvProxies;\n\n    /// @notice a mapping to check if a certain selector (function signature) is allowed for clients to call on SSVNetwork via P2pSsvProxy.\n    mapping(bytes4 => bool) private s_clientSelectors;\n\n    /// @notice a mapping to check if a certain selector (function signature) is allowed for a P2P operator to call on SSVNetwork via P2pSsvProxy.\n    mapping(bytes4 => bool) private s_operatorSelectors;\n\n    /// @notice Exchange rate between SSV and ETH set by P2P.\n    /// @dev (If 1 SSV = 0.007539 ETH, it should be 0.007539 * 10^18 = 7539000000000000).\n    /// Only used during validator registration without ETH deposits to cover SSV token costs with client ETH.\n    /// SSV tokens exchanged with this rate cannot be withdrawn by the client.\n    /// P2P is willing to tolarate potential discrepancies with the market exchange rate for the sake of simplicity.\n    /// The client agrees to this rate when calls `registerValidators` function.\n    uint256 private s_ssvPerEthExchangeRateDividedByWei;\n\n    /// @notice If the given _ssvOperatorOwner is not allowed, revert\n    modifier onlyAllowedSsvOperatorOwner(address _ssvOperatorOwner) {\n        bool isAllowed = s_allowedSsvOperatorOwners.contains(_ssvOperatorOwner);\n        if (!isAllowed) {\n            revert P2pSsvProxyFactory__NotAllowedSsvOperatorOwner(_ssvOperatorOwner);\n        }\n        _;\n    }\n\n    /// @notice If the msg.sender is not an allowed SSV operator owner, revert\n    modifier onlySsvOperatorOwner() {\n        bool isAllowed = s_allowedSsvOperatorOwners.contains(msg.sender);\n        if (!isAllowed) {\n            revert P2pSsvProxyFactory__NotAllowedSsvOperatorOwner(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Revert if either 1) one of the operator IDs is not allowed 2) at least 2 operator IDs belong to the same owner\n    modifier onlyAllowedOperators(SsvOperator[] calldata _operators) {\n        uint256 operatorCount = _operators.length;\n        for (uint256 i = 0; i < operatorCount;) {\n            address currentOperatorOwner = _operators[i].owner;\n\n            uint64[MAX_ALLOWED_SSV_OPERATOR_IDS] memory allowedIds = s_allowedSsvOperatorIds[currentOperatorOwner];\n\n            bool isAllowed;\n            for (uint256 j = 0; j < MAX_ALLOWED_SSV_OPERATOR_IDS;) {\n                if (allowedIds[j] == _operators[i].id) {\n                    isAllowed = true;\n                    break;\n                }\n\n                unchecked {++j;}\n            }\n            if (!isAllowed) {\n                revert P2pSsvProxyFactory__SsvOperatorNotAllowed(currentOperatorOwner, _operators[i].id);\n            }\n\n            for (uint256 k = 0; k < operatorCount;) {\n                if (i != k && currentOperatorOwner == _operators[k].owner) {\n                    revert P2pSsvProxyFactory__DuplicateOperatorOwnersNotAllowed(\n                        currentOperatorOwner,\n                        _operators[i].id,\n                        _operators[k].id\n                    );\n                }\n\n                unchecked {++k;}\n            }\n\n            unchecked {++i;}\n        }\n\n        _;\n    }\n\n    /// @dev Set values that are constant, common for all clients, known at the initial deploy time.\n    /// @param _feeDistributorFactory FeeDistributorFactory address\n    /// @param _referenceFeeDistributor reference FeeDistributor address\n    constructor(\n        address _feeDistributorFactory,\n        address _referenceFeeDistributor\n    ) {\n        if (!ERC165Checker.supportsInterface(_feeDistributorFactory, type(IFeeDistributorFactory).interfaceId)) {\n            revert P2pSsvProxyFactory__NotFeeDistributorFactory(_feeDistributorFactory);\n        }\n        i_feeDistributorFactory = IFeeDistributorFactory(_feeDistributorFactory);\n\n        if (!ERC165Checker.supportsInterface(_referenceFeeDistributor, type(IFeeDistributor).interfaceId)) {\n            revert P2pSsvProxyFactory__NotFeeDistributor(_referenceFeeDistributor);\n        }\n\n        s_referenceFeeDistributor = _referenceFeeDistributor;\n        emit P2pSsvProxyFactory__ReferenceFeeDistributorSet(_referenceFeeDistributor);\n\n        i_depositContract = (block.chainid == 1)\n            ? IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa)\n            : IDepositContract(0xff50ed3d0ec03aC01D4C79aAd74928BFF48a7b2b);\n\n        i_ssvToken = (block.chainid == 1)\n            ? IERC20(0x9D65fF81a3c488d585bBfb0Bfe3c7707c7917f54)\n            : IERC20(0x3a9f01091C446bdE031E39ea8354647AFef091E7);\n\n        i_ssvViews = (block.chainid == 1)\n            ? ISSVViews(0xafE830B6Ee262ba11cce5F32fDCd760FFE6a66e4)\n            : ISSVViews(0xAE2C84c48272F5a1746150ef333D5E5B51F68763);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setSsvPerEthExchangeRateDividedByWei(uint256 _ssvPerEthExchangeRateDividedByWei) external onlyOwner {\n        if (_ssvPerEthExchangeRateDividedByWei < 10 ** 12 || _ssvPerEthExchangeRateDividedByWei > 10 ** 20) {\n            revert P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiOutOfRange();\n        }\n\n        s_ssvPerEthExchangeRateDividedByWei = _ssvPerEthExchangeRateDividedByWei;\n        emit P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiSet(_ssvPerEthExchangeRateDividedByWei);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setReferenceP2pSsvProxy(address _referenceP2pSsvProxy) external onlyOwner {\n        if (!ERC165Checker.supportsInterface(_referenceP2pSsvProxy, type(IP2pSsvProxy).interfaceId)) {\n            revert P2pSsvProxyFactory__NotP2pSsvProxy(_referenceP2pSsvProxy);\n        }\n\n        s_referenceP2pSsvProxy = P2pSsvProxy(_referenceP2pSsvProxy);\n        emit P2pSsvProxyFactory__ReferenceP2pSsvProxySet(_referenceP2pSsvProxy);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setAllowedSelectorsForClient(bytes4[] calldata _selectors) external onlyOwner {\n        uint256 count = _selectors.length;\n\n        if (count == 0) {\n            revert P2pSsvProxyFactory__CannotSetZeroSelectors();\n        }\n\n        for (uint256 i = 0; i < count;) {\n            s_clientSelectors[_selectors[i]] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit P2pSsvProxyFactory__AllowedSelectorsForClientSet(_selectors);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setAllowedSelectorsForOperator(bytes4[] calldata _selectors) external onlyOwner {\n        uint256 count = _selectors.length;\n\n        if (count == 0) {\n            revert P2pSsvProxyFactory__CannotSetZeroSelectors();\n        }\n\n        for (uint256 i = 0; i < count;) {\n            s_operatorSelectors[_selectors[i]] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit P2pSsvProxyFactory__AllowedSelectorsForOperatorSet(_selectors);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setReferenceFeeDistributor(\n        address _referenceFeeDistributor\n    ) external onlyOperatorOrOwner {\n        if (!ERC165Checker.supportsInterface(_referenceFeeDistributor, type(IFeeDistributor).interfaceId)) {\n            revert P2pSsvProxyFactory__NotFeeDistributor(_referenceFeeDistributor);\n        }\n\n        s_referenceFeeDistributor = _referenceFeeDistributor;\n        emit P2pSsvProxyFactory__ReferenceFeeDistributorSet(_referenceFeeDistributor);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setAllowedSsvOperatorOwners(\n        address[] calldata _allowedSsvOperatorOwners\n    ) external onlyOperatorOrOwner {\n        uint256 count = _allowedSsvOperatorOwners.length;\n\n        if (count == 0) {\n            revert P2pSsvProxyFactory__CannotSetZeroAllowedSsvOperatorOwners();\n        }\n\n        for (uint256 i = 0; i < count;) {\n            address allowedSsvOperatorOwner = _allowedSsvOperatorOwners[i];\n\n            if (!s_allowedSsvOperatorOwners.add(allowedSsvOperatorOwner)) {\n                revert P2pSsvProxyFactory__SsvOperatorOwnerAlreadyExists(allowedSsvOperatorOwner);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit P2pSsvProxyFactory__AllowedSsvOperatorOwnersSet(_allowedSsvOperatorOwners);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function removeAllowedSsvOperatorOwners(\n        address[] calldata _allowedSsvOperatorOwnersToRemove\n    ) external onlyOperatorOrOwner {\n        uint256 count = _allowedSsvOperatorOwnersToRemove.length;\n\n        if (count == 0) {\n            revert P2pSsvProxyFactory__CannotRemoveZeroAllowedSsvOperatorOwners();\n        }\n\n        for (uint256 i = 0; i < count;) {\n            address allowedSsvOperatorOwnersToRemove = _allowedSsvOperatorOwnersToRemove[i];\n\n            if (!s_allowedSsvOperatorOwners.remove(allowedSsvOperatorOwnersToRemove)) {\n                revert P2pSsvProxyFactory__SsvOperatorOwnerDoesNotExist(allowedSsvOperatorOwnersToRemove);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit P2pSsvProxyFactory__AllowedSsvOperatorOwnersRemoved(_allowedSsvOperatorOwnersToRemove);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setSsvOperatorIds(\n        uint64[MAX_ALLOWED_SSV_OPERATOR_IDS] calldata _operatorIds\n    ) external onlySsvOperatorOwner {\n        _setSsvOperatorIds(_operatorIds, msg.sender);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function setSsvOperatorIds(\n        uint64[MAX_ALLOWED_SSV_OPERATOR_IDS] calldata _operatorIds,\n        address _ssvOperatorOwner\n    ) external onlyOperatorOrOwner onlyAllowedSsvOperatorOwner(_ssvOperatorOwner) {\n        _setSsvOperatorIds(_operatorIds, _ssvOperatorOwner);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function clearSsvOperatorIds() external onlySsvOperatorOwner {\n        _clearSsvOperatorIds(msg.sender);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function clearSsvOperatorIds(\n        address _ssvOperatorOwner\n    ) external onlyOperatorOrOwner {\n        _clearSsvOperatorIds(_ssvOperatorOwner);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function predictP2pSsvProxyAddress(\n        address _feeDistributorInstance\n    ) public view returns (address) {\n        return Clones.predictDeterministicAddress(\n            address(s_referenceP2pSsvProxy),\n            bytes32(bytes20(_feeDistributorInstance))\n        );\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function createP2pSsvProxy(\n        address _feeDistributorInstance\n    ) external onlyOperatorOrOwner returns(address p2pSsvProxyInstance) {\n        p2pSsvProxyInstance = _createP2pSsvProxy(_feeDistributorInstance);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function depositEthAndRegisterValidators(\n        DepositData calldata _depositData,\n        address _withdrawalCredentialsAddress,\n\n        SsvPayload calldata _ssvPayload,\n\n        FeeRecipient calldata _clientConfig,\n        FeeRecipient calldata _referrerConfig\n    ) external payable returns (address p2pSsvProxy) {\n        _makeBeaconDeposits(_depositData, _withdrawalCredentialsAddress, _ssvPayload.ssvValidators);\n\n        p2pSsvProxy = _registerValidators(_ssvPayload, _clientConfig, _referrerConfig);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function registerValidators(\n        SsvPayload calldata _ssvPayload,\n        FeeRecipient calldata _clientConfig,\n        FeeRecipient calldata _referrerConfig\n    ) external payable returns (address p2pSsvProxy) {\n        _checkEthValue(_ssvPayload.tokenAmount);\n\n        p2pSsvProxy = _registerValidators(_ssvPayload, _clientConfig, _referrerConfig);\n    }\n\n    /// @notice Register validators with SSV (up to 60, calldata size is the limit) without ETH deposits\n    /// @dev Common logic for depositEthAndRegisterValidators and registerValidators functions\n    /// @param _ssvPayload a stuct with data necessary for SSV registration (see `SsvPayload` struct for details)\n    /// @param _clientConfig address and basis points (percent * 100) of the client (for FeeDistributor)\n    /// @param _referrerConfig address and basis points (percent * 100) of the referrer (for FeeDistributor)\n    /// @return p2pSsvProxy client P2pSsvProxy instance that became the SSV cluster owner\n    function _registerValidators(\n        SsvPayload calldata _ssvPayload,\n        FeeRecipient calldata _clientConfig,\n        FeeRecipient calldata _referrerConfig\n    ) private onlyAllowedOperators(_ssvPayload.ssvOperators) returns (address p2pSsvProxy) {\n        address feeDistributorInstance = _createFeeDistributor(_clientConfig, _referrerConfig);\n        p2pSsvProxy = _createP2pSsvProxy(feeDistributorInstance);\n\n        i_ssvToken.transfer(address(p2pSsvProxy), _ssvPayload.tokenAmount);\n\n        P2pSsvProxy(p2pSsvProxy).registerValidators(\n            _ssvPayload,\n            feeDistributorInstance\n        );\n\n        emit P2pSsvProxyFactory__RegistrationCompleted(p2pSsvProxy);\n    }\n\n    /// @notice Deploy P2pSsvProxy instance if not deployed before\n    /// @param _feeDistributorInstance The address of FeeDistributor instance\n    /// @return p2pSsvProxyInstance client P2pSsvProxy instance that has been deployed\n    function _createP2pSsvProxy(\n        address _feeDistributorInstance\n    ) private returns(address p2pSsvProxyInstance) {\n        p2pSsvProxyInstance = predictP2pSsvProxyAddress(_feeDistributorInstance);\n        if (p2pSsvProxyInstance.code.length == 0) { // if p2pSsvProxyInstance doesn't exist, deploy it\n            if (!ERC165Checker.supportsInterface(_feeDistributorInstance, type(IFeeDistributor).interfaceId)) {\n                revert P2pSsvProxyFactory__NotFeeDistributor(_feeDistributorInstance);\n            }\n\n            // clone the reference implementation of P2pSsvProxy\n            p2pSsvProxyInstance = Clones.cloneDeterministic(\n                address(s_referenceP2pSsvProxy),\n                bytes32(bytes20(_feeDistributorInstance))\n            );\n\n            // set the client address to the cloned P2pSsvProxy instance\n            P2pSsvProxy(p2pSsvProxyInstance).initialize(_feeDistributorInstance);\n\n            address client = IFeeDistributor(_feeDistributorInstance).client();\n\n            // append new P2pSsvProxy address to all client P2pSsvProxies array\n            s_allClientP2pSsvProxies[client].push(p2pSsvProxyInstance);\n\n            // append new P2pSsvProxy address to all P2pSsvProxies array\n            s_allP2pSsvProxies.push(p2pSsvProxyInstance);\n\n            // emit event with the address of the newly created instance for the external listener\n            emit P2pSsvProxyFactory__P2pSsvProxyCreated(\n                p2pSsvProxyInstance,\n                client,\n                _feeDistributorInstance\n            );\n        }\n    }\n\n    /// @notice Deploy FeeDistributor instance if not deployed before\n    /// @param _clientConfig address and basis points (percent * 100) of the client (for FeeDistributor)\n    /// @param _referrerConfig address and basis points (percent * 100) of the referrer (for FeeDistributor)\n    /// @return feeDistributorInstance client FeeDistributor instance that has been deployed\n    function _createFeeDistributor(\n        FeeRecipient calldata _clientConfig,\n        FeeRecipient calldata _referrerConfig\n    ) private returns(address feeDistributorInstance) {\n        address referenceFeeDistributor_ = s_referenceFeeDistributor;\n\n        feeDistributorInstance = i_feeDistributorFactory.predictFeeDistributorAddress(\n            referenceFeeDistributor_,\n            _clientConfig,\n            _referrerConfig\n        );\n        if (feeDistributorInstance.code.length == 0) {\n            // if feeDistributorInstance doesn't exist, deploy it\n            i_feeDistributorFactory.createFeeDistributor(\n                referenceFeeDistributor_,\n                _clientConfig,\n                _referrerConfig\n            );\n        }\n    }\n\n    /// @notice Check ETH value for validator registrations without ETH deposits.\n    /// @dev P2P cannot afford totally free validator registrations since they are paid with P2P's SSV tokens.\n    /// It's OK for validator registrations with ETH deposits since we can be confident in the existense of EL rewards\n    /// that will cover the SSV tokens cost in that case.\n    /// If there are no ETH deposits, to prevent draining of SSV tokens from P2pSsvProxyFactory,\n    /// the client pays for the used SSV tokens.\n    /// The client will only need to pay once. Starting from the next month, P2P will be depositing SSV tokens to the clusters\n    /// the same way as with ETH deposits.\n    /// @param _tokenAmount amount of ERC-20 SSV tokens for validator registration\n    function _checkEthValue(\n        uint256 _tokenAmount\n    ) private view {\n        uint256 exchangeRate = s_ssvPerEthExchangeRateDividedByWei;\n        if (exchangeRate == 0) {\n            revert P2pSsvProxyFactory__SsvPerEthExchangeRateDividedByWeiNotSet();\n        }\n\n        uint256 ssvTokensValueInWei = (_tokenAmount * exchangeRate) / 10**18;\n        if (msg.value != ssvTokensValueInWei) {\n            revert P2pSsvProxyFactory__NotEnoughEtherPaidToCoverSsvFees(ssvTokensValueInWei, msg.value);\n        }\n    }\n\n    /// @notice Set SSV operator IDs list for a SSV operator owner\n    /// @param _operatorIds SSV operator IDs list\n    /// @param _ssvOperatorOwner SSV operator owner\n    function _setSsvOperatorIds(\n        uint64[MAX_ALLOWED_SSV_OPERATOR_IDS] calldata _operatorIds,\n        address _ssvOperatorOwner\n    ) private {\n        for (uint i = 0; i < _operatorIds.length;) {\n            uint64 id = _operatorIds[i];\n\n            for (uint j = i + 1; j < _operatorIds.length;) {\n                if (id == _operatorIds[j] && id != 0) {\n                    revert P2pSsvProxyFactory__DuplicateIdsNotAllowed(id);\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n\n            if (id != 0) {\n                (address actualOwner,,,,,) = i_ssvViews.getOperatorById(id);\n                if (actualOwner != _ssvOperatorOwner) {\n                    revert P2pSsvProxyFactory__SsvOperatorIdDoesNotBelongToOwner(id, _ssvOperatorOwner, actualOwner);\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        s_allowedSsvOperatorIds[_ssvOperatorOwner] = _operatorIds;\n        emit P2pSsvProxyFactory__SsvOperatorIdsSet(_ssvOperatorOwner, _operatorIds);\n    }\n\n    /// @notice Clear SSV operator IDs list for a SSV operator owner\n    /// @param _ssvOperatorOwner SSV operator owner\n    function _clearSsvOperatorIds(\n        address _ssvOperatorOwner\n    ) private {\n        delete s_allowedSsvOperatorIds[_ssvOperatorOwner];\n        emit P2pSsvProxyFactory__SsvOperatorIdsCleared(_ssvOperatorOwner);\n    }\n\n    /// @notice Make ETH2 (Beacon) deposits via the official Beacon Deposit Contract\n    /// @param _depositData signatures and depositDataRoots from Beacon deposit data\n    /// @param _withdrawalCredentialsAddress address for 0x01 withdrawal credentials from Beacon deposit data (1 for the batch)\n    /// @param _ssvValidators list of pubkeys and SSV sharesData\n    function _makeBeaconDeposits(\n        DepositData calldata _depositData,\n        address _withdrawalCredentialsAddress,\n        SsvValidator[] calldata _ssvValidators\n    ) private {\n        uint256 validatorCount = _ssvValidators.length;\n\n        if (msg.value != COLLATERAL * validatorCount) {\n            revert P2pSsvProxyFactory__EthValueMustBe32TimesValidatorCount(msg.value);\n        }\n\n        if (_depositData.signatures.length != validatorCount || _depositData.depositDataRoots.length != validatorCount) {\n            revert P2pSsvProxyFactory__DepositDataArraysShouldHaveTheSameLength(\n                validatorCount,\n                _depositData.signatures.length,\n                _depositData.depositDataRoots.length\n            );\n        }\n\n        for (uint256 i = 0; i < validatorCount;) {\n            // ETH deposit\n            bytes memory withdrawalCredentials = abi.encodePacked(\n                hex'010000000000000000000000',\n                _withdrawalCredentialsAddress\n            );\n            i_depositContract.deposit{value: COLLATERAL}(\n                _ssvValidators[i].pubkey,\n                withdrawalCredentials,\n                _depositData.signatures[i],\n                _depositData.depositDataRoots[i]\n            );\n\n            unchecked {++i;}\n        }\n    }\n\n    /// @inheritdoc IOwnable\n    function owner() public view override(Ownable, OwnableBase, IOwnable) returns (address) {\n        return super.owner();\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getFeeDistributorFactory() external view returns (address) {\n        return address(i_feeDistributorFactory);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getAllClientP2pSsvProxies(\n        address _client\n    ) external view returns (address[] memory) {\n        return s_allClientP2pSsvProxies[_client];\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getAllP2pSsvProxies() external view returns (address[] memory) {\n        return s_allP2pSsvProxies;\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function isClientSelectorAllowed(bytes4 _selector) external view returns (bool) {\n        return s_clientSelectors[_selector];\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function isOperatorSelectorAllowed(bytes4 _selector) external view returns (bool) {\n        return s_operatorSelectors[_selector];\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getAllowedSsvOperatorIds(address _ssvOperatorOwner) external view returns (uint64[MAX_ALLOWED_SSV_OPERATOR_IDS] memory) {\n        return s_allowedSsvOperatorIds[_ssvOperatorOwner];\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getAllowedSsvOperatorOwners() external view returns (address[] memory) {\n        return s_allowedSsvOperatorOwners.values();\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getReferenceFeeDistributor() external view returns (address) {\n        return s_referenceFeeDistributor;\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getReferenceP2pSsvProxy() external view returns (address) {\n        return address(s_referenceP2pSsvProxy);\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getSsvPerEthExchangeRateDividedByWei() external view returns (uint256) {\n        return s_ssvPerEthExchangeRateDividedByWei;\n    }\n\n    /// @inheritdoc IP2pSsvProxyFactory\n    function getNeededAmountOfEtherToCoverSsvFees(uint256 _tokenAmount) external view returns (uint256) {\n        return (_tokenAmount * s_ssvPerEthExchangeRateDividedByWei) / 10**18;\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IP2pSsvProxyFactory).interfaceId || super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "src/p2pSsvProxy/P2pSsvProxy.sol",
      "content": "// SPDX-FileCopyrightText: 2023 P2P Validator <info@p2p.org>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport \"../@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../constants/P2pConstants.sol\";\nimport \"../interfaces/ssv/ISSVNetwork.sol\";\nimport \"../interfaces/IDepositContract.sol\";\nimport \"../interfaces/p2p/IFeeDistributorFactory.sol\";\nimport \"../access/OwnableWithOperator.sol\";\nimport \"../assetRecovering/OwnableAssetRecoverer.sol\";\nimport \"../structs/P2pStructs.sol\";\nimport \"../p2pSsvProxyFactory/IP2pSsvProxyFactory.sol\";\nimport \"./IP2pSsvProxy.sol\";\n\n\n/// @notice _referenceFeeDistributor should implement IFeeDistributor interface\n/// @param _passedAddress passed address for _referenceFeeDistributor\nerror P2pSsvProxy__NotFeeDistributor(address _passedAddress);\n\n/// @notice Should be a P2pSsvProxyFactory contract\n/// @param _passedAddress passed address that does not support IP2pSsvProxyFactory interface\nerror P2pSsvProxy__NotP2pSsvProxyFactory(address _passedAddress);\n\n/// @notice Throws if called by any account other than the client.\n/// @param _caller address of the caller\n/// @param _client address of the client\nerror P2pSsvProxy__CallerNotClient(address _caller, address _client);\n\n/// @notice The caller was neither operator nor owner\n/// @param _caller address of the caller\n/// @param _operator address of the operator\n/// @param _owner address of the owner\nerror P2pSsvProxy__CallerNeitherOperatorNorOwner(address _caller, address _operator, address _owner);\n\n/// @notice The caller was neither operator nor owner nor client\n/// @param _caller address of the caller\nerror P2pSsvProxy__CallerNeitherOperatorNorOwnerNorClient(address _caller);\n\n/// @notice Only factory can call `initialize`.\n/// @param _msgSender sender address.\n/// @param _actualFactory the actual factory address that can call `initialize`.\nerror P2pSsvProxy__NotP2pSsvProxyFactoryCalled(address _msgSender, IP2pSsvProxyFactory _actualFactory);\n\n/// @notice _pubkeys and _operatorIds arrays should have the same lengths\nerror P2pSsvProxy__AmountOfParametersError();\n\n/// @notice Selector is not allowed for the caller.\n/// @param _caller caller address\n/// @param _selector function selector to be called on SSVNetwork\nerror P2pSsvProxy__SelectorNotAllowed(address _caller, bytes4 _selector);\n\n/// @title Proxy for SSVNetwork calls.\n/// @dev Each instance of P2pSsvProxy corresponds to 1 FeeDistributor instance.\n/// Thus, client to P2pSsvProxy instances is a 1-to-many relation.\n/// SSV tokens are managed by P2P.\n/// Clients cover the costs of SSV tokens by EL rewards via FeeDistributor instance.\ncontract P2pSsvProxy is OwnableAssetRecoverer, ERC165, IP2pSsvProxy {\n\n    /// @notice P2pSsvProxyFactory addre"
    }
  ]
}