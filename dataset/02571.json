{
  "Title": "H-4: Vault's `totalStrategyTokenGlobal` will not be in sync",
  "Content": "# Issue H-4: Vault's `totalStrategyTokenGlobal` will not be in sync \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/15 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe `strategyContext.vaultState.totalStrategyTokenGlobal` variable that tracks the number of strategy tokens held in the vault will not be in sync and will cause accounting issues within the vault.\n\n## Vulnerability Detail\n\n> This affects both the TwoToken and Boosted3Token vaults\n\nThe `StrategyUtils._convertStrategyTokensToBPTClaim` function might return zero if a small number of `strategyTokenAmount` is passed into the function. If `(strategyTokenAmount * context.vaultState.totalBPTHeld)` is smaller than `context.vaultState.totalStrategyTokenGlobal`, the `bptClaim` will be zero.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L18\n\n```solidity\nFile: StrategyUtils.sol\n17:     /// @notice Converts strategy tokens to BPT\n18:     function _convertStrategyTokensToBPTClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n19:         internal pure returns (uint256 bptClaim) {\n20:         require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n21:         if (context.vaultState.totalStrategyTokenGlobal > 0) {\n22:             bptClaim = (strategyTokenAmount * context.vaultState.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n23:         }\n24:     }\n```\n\nIn Line 441 of the `Boosted3TokenPoolUtils._redeem` function below, if `bptClaim` is zero, it will return zero and exit the function immediately.\n\nIf a small number of `strategyTokens` is passed into the `_redeem` function and the `bptClaim` ends up as zero, the caller of the `_redeem` function will assume that all the `strategyTokens` have been redeemed.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L432\n\n```solidity\nFile: Boosted3TokenPoolUtils.sol\n432:     function _redeem(\n433:         ThreeTokenPoolContext memory poolContext,\n434:         StrategyContext memory strategyContext,\n435:         AuraStakingContext memory stakingContext,\n436:         uint256 strategyTokens,\n437:         uint256 minPrimary\n438:     ) internal returns (uint256 finalPrimaryBalance) {\n439:         uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n440: \n441:         if (bptClaim == 0) return 0;\n442: \n443:         finalPrimaryBalance = _unstakeAndExitPool({\n444:             stakingContext: stakingContext,\n445:             poolContext: poolContext,\n446:             bptClaim: bptClaim,\n447:             minPrimary: minPrimary\n448:         });\n449: \n450:         strategyContext.vaultState.totalBPTHeld -= bptClaim;\n451:         strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n452:         strategyContext.vaultState.setStrategyVaultState(); \n453:     }\n```\n\nThe following function shows an example of the caller of the `_redeem` function at Line 171 below accepting the zero value as it does not revert when the zero value is returned by the `_redeem` function. Thus, it will consider the small number of `strategyTokens` to be redeemed. Note that the `_redeemFromNotional` function calls the `_redeem` function under the hood.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/BaseStrategyVault.sol#L163\n\n```solidity\nFile: BaseStrategyVault.sol\n163:     function redeemFromNotional(\n164:         address account,\n165:         address receiver,\n166:         uint256 strategyTokens,\n167:         uint256 maturity,\n168:         uint256 underlyingToRepayDebt,\n169:         bytes calldata data\n170:     ) external onlyNotional returns (uint256 transferToReceiver) {\n171:         uint256 borrowedCurrencyAmount = _redeemFromNotional(account, strategyTokens, maturity, data);\n172: \n173:         uint256 transferToNotional;\n174:         if (account == address(this) || borrowedCurrencyAmount <= underlyingToRepayDebt) {\n175:             // It may be the case that insufficient tokens were redeemed to repay the debt. If this\n176:             // happens the Notional will attempt to recover the shortfall from the account directly.\n177:             // This can happen if an account wants to reduce their leverage by paying off debt but\n178:             // does not want to sell strategy tokens to do so.\n179:             // The other situation would be that the vault is calling redemption to deleverage or\n180:             // settle. In that case all tokens go back to Notional.\n181:             transferToNotional = borrowedCurrencyAmount;\n182:         } else {\n183:             transferToNotional = underlyingToRepayDebt;\n184:             unchecked { transferToReceiver = borrowedCurrencyAmount - underlyingToRepayDebt; }\n185:         }\n186: \n187:         if (_UNDERLYING_IS_ETH) {\n188:             if (transferToReceiver > 0) payable(receiver).transfer(transferToReceiver);\n189:             if (transferToNotional > 0) payable(address(NOTIONAL)).transfer(transferToNotional);\n190:         } else {\n191:             if (transferToReceiver > 0) _UNDERLYING_TOKEN.checkTransfer(receiver, transferToReceiver);\n192:             if (transferToNotional > 0) _UNDERLYING_TOKEN.checkTransfer(address(NOTIONAL), transferToNotional);\n193:         }\n194:     }\n```\n\nSubsequently, on Notional side, it will deduct the redeemed strategy tokens from its`vaultState.totalStrategyTokens` state (Refer to Line 177 below)\n\nhttps://github.com/notional-finance/contracts-v2/blob/63eb0b46ec37e5fc5447bdde3d951dd90f245741/contracts/external/actions/VaultAction.sol#L157\n\n```solidity\nFile: VaultAction.sol\n156:     /// @notice Redeems strategy tokens to cash\n157:     function _redeemStrategyTokensToCashInternal(\n158:         VaultConfig memory vaultConfig,\n159:         uint256 maturity,\n160:         uint256 strategyTokensToRedeem,\n161:         bytes calldata vaultData\n162:     ) private nonReentrant returns (int256 assetCashRequiredToSettle, int256 underlyingCashRequiredToSettle) {\n163:         // If the vault allows further re-entrancy then set the status back to the default\n164:         if (vaultConfig.getFlag(VaultConfiguration.ALLOW_REENTRANCY)) {\n165:             reentrancyStatus = _NOT_ENTERED;\n166:         }\n167: \n168:         VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig.vault, maturity);\n169:         (int256 assetCashReceived, uint256 underlyingToReceiver) = vaultConfig.redeemWithoutDebtRepayment(\n170:             vaultConfig.vault, strategyTokensToRedeem, maturity, vaultData\n171:         );\n172:         require(assetCashReceived > 0);\n173:         // Safety check to ensure that the vault does not somehow receive tokens in this scenario\n174:         require(underlyingToReceiver == 0);\n175: \n176:         vaultState.totalAssetCash = vaultState.totalAssetCash.add(uint256(assetCashReceived));\n177:         vaultState.totalStrategyTokens = vaultState.totalStrategyTokens.sub(strategyTokensToRedeem);\n178:         vaultState.setVaultState(vaultConfig.vault);\n179: \n180:         emit VaultRedeemStrategyToken(vaultConfig.vault, maturity, assetCashReceived, strategyTokensToRedeem);\n181:         return _getCashRequiredToSettle(vaultConfig, vaultState, maturity);\n182:     }\n```\n\nHowever, the main issue is that when a small number of `strategyTokens` are redeemed and `bptClaim` is zero, the `_redeem` function will exit at Line 441 immediately. Thus, the redeemed strategy tokens are not deducted from the `strategyContext.vaultState.totalStrategyTokenGlobal` accounting variable on the Vault side. \n\nThus, `strategyContext.vaultState.totalStrategyTokenGlobal` on the Vault side will not be in sync with the `vaultState.totalStrategyTokens` on the Notional side.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L432\n\n```solidity\nFile: Boosted3TokenPoolUtils.sol\n432:     function _redeem(\n433:         ThreeTokenPoolContext memory poolContext,\n434:         StrategyContext memory strategyContext,\n435:         AuraStakingContext memory stakingContext,\n436:         uint256 strategyTokens,\n437:         uint256 minPrimary\n438:     ) internal returns (uint256 finalPrimaryBalance) {\n439:         uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n440: \n441:         if (bptClaim == 0) return 0;\n442: \n443:         finalPrimaryBalance = _unstakeAndExitPool({\n444:             stakingContext: stakingContext,\n445:             poolContext: poolContext,\n446:             bptClaim: bptClaim,\n447:             minPrimary: minPrimary\n448:         });\n449: \n450:         strategyContext.vaultState.totalBPTHeld -= bptClaim;\n451:         strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n452:         strategyContext.vaultState.setStrategyVaultState(); \n453:     }\n```\n\n## Impact\n\nThe `strategyContext.vaultState.totalStrategyTokenGlobal` variable that tracks the number of strategy tokens held in the vault will not be in sync and will cause accounting issues within the vault. This means that the actual total strategy tokens in circulation and the `strategyContext.vaultState.totalStrategyTokenGlobal` will be different. The longer the issue is left unfixed, the larger the differences between them.\n\nThe `strategyContext.vaultState.totalStrategyTokenGlobal` will be larger than expected because it does not deduct the number of strategy tokens when it should be under certain conditions.\n\nOne example of the impact is as follows: The affected variable is used within the `_convertStrategyTokensToBPTClaim` and `_convertBPTClaimToStrategyTokens`, `_getBPTHeldInMaturity` functions. These functions are used within the deposit and redeem functions of the vault. Therefore, the number of strategy tokens or assets the users receive will not be accurate and might be less or more than expected.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L18\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol#L432\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L209\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe number of strategy tokens redeemed needs to be deducted from the vault's `totalStrategyTokenGlobal` regardless of the `bptClaim` value. Otherwise, the vault's `totalStrategyTokenGlobal` will not be in sync.\n\nWhen `bptClaim` is zero, it does not always mean that no strategy token has been redeemed. Based on the current vault implementation, the `bptClaim` might be zero because the number of strategy tokens to be redeemed is too small and thus it causes Solidity to round down to zero.\n\n```diff\nfunction _redeem(\n    ThreeTokenPoolContext memory poolContext,\n    StrategyContext memory strategyContext,\n    AuraStakingContext memory stakingContext,\n    uint256 strategyTokens,\n    uint256 minPrimary\n) internal returns (uint256 finalPrimaryBalance) {\n    uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n+\tstrategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n+\tstrategyContext.vaultState.setStrategyVaultState();\n+\n    if (bptClaim == 0) return 0;\n\n    finalPrimaryBalance = _unstakeAndExitPool({\n        stakingContext: stakingContext,\n        poolContext: poolContext,\n        bptClaim: bptClaim,\n        minPrimary: minPrimary\n    });\n\n    strategyContext.vaultState.totalBPTHeld -= bptClaim;\n-   strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n    strategyContext.vaultState.setStrategyVaultState(); \n}\n```\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/balancer/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport { StrategyContext, TradeParams } from \"../../BalancerVaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n\n    /// @notice Converts strategy tokens to BPT\n    function _convertStrategyTokensToBPTClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 bptClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            bptClaim = (strategyTokenAmount * context.vaultState.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function _convertBPTClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.vaultState.totalBPTHeld == 0) {\n            // Strategy tokens are in 8 decimal precision, BPT is in 18. Scale the minted amount down.\n            return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                BalancerConstants.BALANCER_PRECISION;\n        }\n\n        // BPT held in maturity is calculated before the new BPT tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new bpt balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.vaultState.totalBPTHeld;\n    }\n\n    function _executeTradeExactIn(\n        TradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        bool useDynamicSlippage\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n        if (useDynamicSlippage) {\n            require(params.oracleSlippagePercentOrLimit <= Constants.SLIPPAGE_LIMIT_PRECISION);\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            useDynamicSlippage ? 0 : params.oracleSlippagePercentOrLimit,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                trade.sellToken = Deployments.WRAPPED_STETH.stETH();\n                uint256 amountBeforeUnwrap = IERC20(trade.sellToken).balanceOf(address(this));\n                // NOTE: the amount returned by unwrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.unwrap(trade.amount);\n                trade.amount = IERC20(trade.sellToken).balanceOf(address(this)) - amountBeforeUnwrap;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH)) {\n                trade.buyToken = Deployments.WRAPPED_STETH.stETH();\n            }\n        }\n\n        if (useDynamicSlippage) {\n            /// @dev params.oracleSlippagePercentOrLimit checked above\n            (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n                params.dexId, tradingModule, uint32(params.oracleSlippagePercentOrLimit)\n            );\n        } else {\n            (amountSold, amountBought) = trade._executeTrade(\n                params.dexId, tradingModule\n            );\n        }\n\n        if (params.tradeUnwrapped) {\n            if (sellToken == address(Deployments.WRAPPED_STETH)) {\n                // Setting amountSold to the original wstETH amount because _executeTradeWithDynamicSlippage\n                // returns the amount of stETH sold in this case\n                /// @notice amountSold == amount because this function only supports EXACT_IN trades\n                amountSold = amount;\n            }\n            if (buyToken == address(Deployments.WRAPPED_STETH) && amountBought > 0) {\n                // trade.buyToken == stETH here\n                IERC20(trade.buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n                uint256 amountBeforeWrap = Deployments.WRAPPED_STETH.balanceOf(address(this));\n                /// @notice the amount returned by wrap is not always accurate for some reason\n                Deployments.WRAPPED_STETH.wrap(amountBought);\n                amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - amountBeforeWrap;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/pool/Boosted3TokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    ThreeTokenPoolContext,\n    TwoTokenPoolContext,\n    BoostedOracleContext,\n    UnderlyingPoolContext,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../pool/Boosted3TokenPoolUtils.sol\";\nimport {StableMath} from \"../math/StableMath.sol\";\nimport {LinearMath} from \"../math/LinearMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {ILinearPool} from \"../../../../../interfaces/balancer/IBalancerPool.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TwoTokenPoolUtils} from \"./TwoTokenPoolUtils.sol\";\nimport {FixedPoint} from \"../math/FixedPoint.sol\";\n\nlibrary Boosted3TokenPoolUtils {\n    using TypeConvert for uint256;\n    using FixedPoint for uint256;\n    using TypeConvert for int256;\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using StrategyUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    // Preminted BPT is sometimes called Phantom BPT, as the preminted BPT (which is deposited in the Vault as balance of\n    // the Pool) doesn't belong to any entity until transferred out of the Pool. The Pool's arithmetic behaves as if it\n    // didn't exist, and the BPT total supply is not a useful value: we rely on the 'virtual supply' (how much BPT is\n    // actually owned by some entity) instead.\n    uint256 private constant _MAX_TOKEN_BALANCE = 2**(112) - 1;\n\n    function _getScaleFactor(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 scaleFactor) {\n        if (tokenIndex == 0) {\n            scaleFactor = poolContext.basePool.primaryScaleFactor;\n        } else if (tokenIndex == 1) {\n            scaleFactor = poolContext.basePool.secondaryScaleFactor;\n        } else if (tokenIndex == 2) {\n            scaleFactor = poolContext.tertiaryScaleFactor;\n        }\n    }\n\n    function _getPrecision(\n        ThreeTokenPoolContext memory poolContext,\n        uint8 tokenIndex\n    ) private pure returns(uint256 precision) {\n        if (tokenIndex == 0) {\n            precision = 10**poolContext.basePool.primaryDecimals;\n        } else if (tokenIndex == 1) {\n            precision = 10**poolContext.basePool.secondaryDecimals;\n        } else if (tokenIndex == 2) {\n            precision = 10**poolContext.tertiaryDecimals;\n        }\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint8 tokenIndex\n    ) internal pure returns (uint256 spotPrice) {\n        require(tokenIndex < 3);  /// @dev invalid token index\n\n        // Exchange rate of primary currency = 1\n        if (tokenIndex == 0) {\n            return BalancerConstants.BALANCER_PRECISION;\n        }\n\n        uint256[] memory balances = _getScaledBalances(poolContext);\n        uint256 invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n        spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n    }\n\n    function _getUnderlyingBPTOut(\n        UnderlyingPoolContext memory pool,\n        uint256 mainIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcBptOutPerMainIn({\n            mainIn: mainIn,\n            mainBalance: scaledMainBalance,\n            wrappedBalance: scaledWrappedBalance,\n            bptSupply: pool.virtualSupply,\n            params: LinearMath.Params({\n                fee: pool.fee,\n                lowerTarget: pool.lowerTarget,\n                upperTarget: pool.upperTarget\n            }) \n        });\n    }\n\n    function _getUnderlyingMainOut(\n        UnderlyingPoolContext memory pool,\n        uint256 bptIn\n    ) private pure returns (uint256) {\n        uint256 scaledMainBalance = pool.mainBalance * pool.mainScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n        uint256 scaledWrappedBalance = pool.wrappedBalance * pool.wrappedScaleFactor /\n            BalancerConstants.BALANCER_PRECISION;\n\n        // Convert from linear pool BPT to primary Amount\n        return LinearMath._calcMainOutPerBptIn({\n            bptIn: bptIn,\n            mainBalance: scaledMainBalance,\n            wrappedBalance: scaledWrappedBalance,\n            bptSupply: pool.virtualSupply,\n            params: LinearMath.Params({\n                fee: pool.fee,\n                lowerTarget: pool.lowerTarget,\n                upperTarget: pool.upperTarget\n            }) \n        });\n    }\n\n    /// @notice Spot price is always expressed in terms of the primary currency\n    function _getSpotPriceWithInvariant(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint8 tokenIndex\n    ) private pure returns (uint256 spotPrice) {\n        // Trade 1 unit of tokenIn for tokenOut to get the spot price\n        // AmountIn needs to be in underlying precision because mainScaleFactor\n        // will convert it to 1e18\n        uint256 amountIn = _getPrecision(poolContext, tokenIndex);\n\n        UnderlyingPoolContext memory inPool = oracleContext.underlyingPools[tokenIndex];\n        amountIn = amountIn * inPool.mainScaleFactor / BalancerConstants.BALANCER_PRECISION;\n        uint256 linearBPTIn = _getUnderlyingBPTOut(inPool, amountIn);\n\n        linearBPTIn = linearBPTIn * _getScaleFactor(poolContext, tokenIndex) / BalancerConstants.BALANCER_PRECISION;\n\n        uint256 linearBPTOut = StableMath._calcOutGivenIn({\n            amplificationParameter: oracleContext.ampParam,\n            balances: balances,\n            tokenIndexIn: tokenIndex,\n            tokenIndexOut: 0, // Primary index\n            tokenAmountIn: linearBPTIn,\n            invariant: invariant\n        });\n\n        linearBPTOut = linearBPTOut * BalancerConstants.BALANCER_PRECISION / _getScaleFactor(poolContext, 0);\n\n        UnderlyingPoolContext memory outPool = oracleContext.underlyingPools[0];\n        spotPrice = _getUnderlyingMainOut(outPool, linearBPTOut);\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / outPool.mainScaleFactor;\n\n        // Convert precision back to 1e18 after downscaling by mainScaleFactor\n        // primary currency = index 0\n        spotPrice = spotPrice * BalancerConstants.BALANCER_PRECISION / _getPrecision(poolContext, 0);\n    }\n\n    function _validateSpotPrice(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory context,\n        address tokenIn,\n        address tokenOut,\n        uint8 tokenIndex,\n        uint256[] memory balances,\n        uint256 invariant\n    ) private view {\n        (int256 answer, int256 decimals) = context.tradingModule.getOraclePrice(tokenOut, tokenIn);\n        require(decimals == int256(BalancerConstants.BALANCER_PRECISION));\n        \n        uint256 spotPrice = _getSpotPriceWithInvariant({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            balances: balances, \n            invariant: invariant,\n            tokenIndex: tokenIndex\n        });\n\n        uint256 oraclePrice = answer.toUint();\n        uint256 lowerLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS - context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n        uint256 upperLimit = (oraclePrice * \n            (BalancerConstants.VAULT_PERCENT_BASIS + context.vaultSettings.oraclePriceDeviationLimitPercent)) / \n            BalancerConstants.VAULT_PERCENT_BASIS;\n\n        // Check spot price against oracle price to make sure it hasn't been manipulated\n        if (spotPrice < lowerLimit || upperLimit < spotPrice) {\n            revert Errors.InvalidPrice(oraclePrice, spotPrice);\n        }\n    }\n\n    function _validateTokenPrices(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256[] memory balances,\n        uint256 invariant\n    ) private view {\n        address primaryUnderlying = ILinearPool(address(poolContext.basePool.primaryToken)).getMainToken();\n        address secondaryUnderlying = ILinearPool(address(poolContext.basePool.secondaryToken)).getMainToken();\n        address tertiaryUnderlying = ILinearPool(address(poolContext.tertiaryToken)).getMainToken();\n\n        _validateSpotPrice({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenOut: secondaryUnderlying,\n            tokenIndex: 1, // secondary index\n            balances: balances,\n            invariant: invariant\n        });\n\n        _validateSpotPrice({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            context: strategyContext,\n            tokenIn: primaryUnderlying,\n            tokenOut: tertiaryUnderlying,\n            tokenIndex: 2, // tertiary index\n            balances: balances,\n            invariant: invariant\n        });\n    }\n\n    function _getVirtualSupply(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) internal view returns (uint256 virtualSupply) {\n        // The initial amount of BPT pre-minted is _PREMINTED_TOKEN_BALANCE, and it goes entirely to the pool balance in\n        // the vault. So the virtualSupply (the amount of BPT supply in circulation) is defined as:\n        // virtualSupply = totalSupply() - _balances[_bptIndex]\n        virtualSupply = poolContext.basePool.basePool.pool.totalSupply() - oracleContext.bptBalance;\n    }\n\n    function _getScaledBalances(ThreeTokenPoolContext memory poolContext) \n        private pure returns (uint256[] memory amountsWithoutBpt) {\n        amountsWithoutBpt = new uint256[](3);\n        amountsWithoutBpt[0] = poolContext.basePool.primaryBalance * poolContext.basePool.primaryScaleFactor \n            / BalancerConstants.BALANCER_PRECISION;\n        amountsWithoutBpt[1] = poolContext.basePool.secondaryBalance * poolContext.basePool.secondaryScaleFactor\n            / BalancerConstants.BALANCER_PRECISION;\n        amountsWithoutBpt[2] = poolContext.tertiaryBalance * poolContext.tertiaryScaleFactor\n            / BalancerConstants.BALANCER_PRECISION;        \n    }\n\n    function _getVirtualSupplyAndBalances(\n        ThreeTokenPoolContext memory poolContext, \n        BoostedOracleContext memory oracleContext\n    ) private view returns (uint256 virtualSupply, uint256[] memory amountsWithoutBpt) {\n        virtualSupply = _getVirtualSupply(poolContext, oracleContext);\n        amountsWithoutBpt = _getScaledBalances(poolContext);\n    }\n\n    function _getValidatedPoolData(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 virtualSupply, uint256[] memory balances, uint256 invariant) {\n        (virtualSupply, balances) = \n            _getVirtualSupplyAndBalances(poolContext, oracleContext);\n\n        // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n        invariant = StableMath._calculateInvariant(\n            oracleContext.ampParam, balances, true // roundUp = true\n        );\n\n        // validate spot prices against oracle prices\n        _validateTokenPrices({\n            poolContext: poolContext,\n            oracleContext: oracleContext,\n            strategyContext: strategyContext,\n            balances: balances,\n            invariant: invariant\n        });\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Boosted pool can't use the Balancer oracle, using Chainlink instead\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        ThreeTokenPoolContext memory poolContext,\n        BoostedOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        (\n           uint256 virtualSupply, \n           uint256[] memory balances, \n           uint256 invariant\n        ) = _getValidatedPoolData(poolContext, oracleContext, strategyContext);\n\n        // NOTE: For Boosted 3 token pools, the LP token (BPT) is just another\n        // token in the pool. So, we first use _calcTokenOutGivenExactBptIn\n        // to calculate the value of 1 BPT. Then, we scale it to the BPT\n        // amount to get the value in terms of the primary currency.\n        // Use virtual total supply and zero swap fees for joins\n        uint256 linearBPTAmount = StableMath._calcTokenOutGivenExactBptIn({\n            amp: oracleContext.ampParam, \n            balances: balances, \n            tokenIndex: 0, // Primary index\n            bptAmountIn: BalancerConstants.BALANCER_PRECISION, // 1 BPT \n            bptTotalSupply: virtualSupply, \n            swapFeePercentage: oracleContext.swapFeePercentage, \n            currentInvariant: invariant\n        });\n\n        // Downscale BPT out\n        linearBPTAmount = linearBPTAmount * BalancerConstants.BALANCER_PRECISION / poolContext.basePool.primaryScaleFactor;\n\n        // Primary underlying pool = index 0\n        primaryAmount = _getUnderlyingMainOut(oracleContext.underlyingPools[0], linearBPTAmount);\n\n        uint256 primaryPrecision = 10 ** poolContext.basePool.primaryDecimals;\n        primaryAmount = (primaryAmount * bptAmount * primaryPrecision) / BalancerConstants.BALANCER_PRECISION_SQUARED;\n    }\n\n    function _approveBalancerTokens(ThreeTokenPoolContext memory poolContext, address bptSpender) internal {\n        poolContext.basePool._approveBalancerTokens(bptSpender);\n\n        IERC20(poolContext.tertiaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n\n        // For boosted pools, the tokens inside pool context are AaveLinearPool tokens.\n        // So, we need to approve the _underlyingToken (primary borrow currency) for trading.\n        ILinearPool underlyingPool = ILinearPool(poolContext.basePool.primaryToken);\n        address primaryUnderlyingAddress = BalancerUtils.getTokenAddress(underlyingPool.getMainToken());\n        IERC20(primaryUnderlyingAddress).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _joinPoolExactTokensIn(ThreeTokenPoolContext memory context, uint256 primaryAmount, uint256 minBPT)\n        private returns (uint256 bptAmount) {\n        ILinearPool underlyingPool = ILinearPool(address(context.basePool.primaryToken));\n\n        // Swap underlyingToken for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: underlyingPool.getMainToken(),\n            tokenOut: address(underlyingPool),\n            amountIn: primaryAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for Boosted BPT\n        bptAmount = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(underlyingPool),\n            tokenOut: address(context.basePool.basePool.pool), // Boosted pool\n            amountIn: linearPoolBPT,\n            limit: minBPT\n        });\n    }\n\n    function _exitPoolExactBPTIn(ThreeTokenPoolContext memory context, uint256 bptExitAmount, uint256 minPrimary)\n        private returns (uint256 primaryBalance) {\n        ILinearPool underlyingPool = ILinearPool(address(context.basePool.primaryToken));\n\n        // Swap Boosted BPT for LinearPool BPT\n        uint256 linearPoolBPT = BalancerUtils._swapGivenIn({\n            poolId: context.basePool.basePool.poolId,\n            tokenIn: address(context.basePool.basePool.pool), // Boosted pool\n            tokenOut: address(underlyingPool),\n            amountIn: bptExitAmount,\n            limit: 0 // slippage checked on the second swap\n        });\n\n        // Swap LinearPool BPT for underlyingToken\n        primaryBalance = BalancerUtils._swapGivenIn({\n            poolId: underlyingPool.getPoolId(),\n            tokenIn: address(underlyingPool),\n            tokenOut: underlyingPool.getMainToken(),\n            amountIn: linearPoolBPT,\n            limit: minPrimary\n        }); \n    }\n\n    function _deposit(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: deposit,\n            minBPT: minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        strategyContext.vaultState.totalBPTHeld += bptMinted;\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _redeem(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        uint256 minPrimary\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        finalPrimaryBalance = _unstakeAndExitPool({\n            stakingContext: stakingContext,\n            poolContext: poolContext,\n            bptClaim: bptClaim,\n            minPrimary: minPrimary\n        });\n\n        strategyContext.vaultState.totalBPTHeld -= bptClaim;\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 deposit,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        bptMinted = _joinPoolExactTokensIn(poolContext, deposit, minBPT);\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext._getVirtualSupply(oracleContext)\n        );\n        uint256 bptHeldAfterJoin = strategyContext.vaultState.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n        if (!success) revert Errors.StakeFailed();\n    }\n\n    function _unstakeAndExitPool(\n        ThreeTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary\n    ) internal returns (uint256 primaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        bool success = stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n        if (!success) revert Errors.UnstakeFailed();\n\n        primaryBalance = _exitPoolExactBPTIn(poolContext, bptClaim, minPrimary); \n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        ThreeTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        BoostedOracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n        \n        underlyingValue = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptClaim\n        ).toInt();\n    }\n}"
    },
    {
      "filename": "contracts/vaults/BaseStrategyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Token, TokenType} from \"../global/Types.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IStrategyVault} from \"../../interfaces/notional/IStrategyVault.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../trading/TradeHandler.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nabstract contract BaseStrategyVault is Initializable, IStrategyVault, AccessControlUpgradeable {\n    using TokenUtils for IERC20;\n    using TradeHandler for Trade;\n\n    bytes32 internal constant NORMAL_SETTLEMENT_ROLE = keccak256(\"NORMAL_SETTLEMENT_ROLE\");\n    bytes32 internal constant EMERGENCY_SETTLEMENT_ROLE = keccak256(\"EMERGENCY_SETTLEMENT_ROLE\");\n    bytes32 internal constant POST_MATURITY_SETTLEMENT_ROLE = keccak256(\"POST_MATURITY_SETTLEMENT_ROLE\");\n    bytes32 internal constant REWARD_REINVESTMENT_ROLE = keccak256(\"REWARD_REINVESTMENT_ROLE\");\n\n    /// @notice Hardcoded on the implementation contract during deployment\n    NotionalProxy public immutable NOTIONAL;\n    ITradingModule public immutable TRADING_MODULE;\n    uint8 constant internal INTERNAL_TOKEN_DECIMALS = 8;\n\n    // Borrowing Currency ID the vault is configured with\n    uint16 private _BORROW_CURRENCY_ID;\n    // True if the underlying is ETH\n    bool private _UNDERLYING_IS_ETH;\n    // Address of the underlying token\n    IERC20 private _UNDERLYING_TOKEN;\n    // NOTE: end of first storage slot here\n\n    // Name of the vault\n    string private _NAME;\n\n\n    /**************************************************************************/\n    /* Global Modifiers, Constructor and Initializer                          */\n    /**************************************************************************/\n    modifier onlyNotional() {\n        require(msg.sender == address(NOTIONAL));\n        _;\n    }\n\n    modifier onlyNotionalOwner() {\n        require(msg.sender == address(NOTIONAL.owner()));\n        _;\n    }\n    \n    /// @notice Set the NOTIONAL address on deployment\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_) initializer {\n        NOTIONAL = notional_;\n        TRADING_MODULE = tradingModule_;\n    }\n\n    /// @notice Override this method and revert if the contract should not receive ETH.\n    /// Upgradeable proxies must have this implemented on the proxy for transfer calls\n    /// succeed (use nProxy for this).\n    receive() external virtual payable {\n        // Allow ETH transfers to succeed\n    }\n\n    /// @notice All strategy vaults MUST implement 8 decimal precision\n    function decimals() public override view returns (uint8) {\n        return INTERNAL_TOKEN_DECIMALS;\n    }\n\n    function name() external override view returns (string memory) {\n        return _NAME;\n    }\n\n    function strategy() external virtual view returns (bytes4);\n\n    function _borrowCurrencyId() internal view returns (uint16) {\n        return _BORROW_CURRENCY_ID;\n    }\n\n    function _underlyingToken() internal view returns (IERC20) {\n        return _UNDERLYING_TOKEN;\n    }\n\n    function _isUnderlyingETH() internal view returns (bool) {\n        return _UNDERLYING_IS_ETH;\n    }\n\n    /// @notice Can only be called once during initialization\n    function __INIT_VAULT(\n        string memory name_,\n        uint16 borrowCurrencyId_\n    ) internal onlyInitializing {\n        _NAME = name_;\n        _BORROW_CURRENCY_ID = borrowCurrencyId_;\n\n        address underlyingAddress = _getNotionalUnderlyingToken(borrowCurrencyId_);\n        _UNDERLYING_TOKEN = IERC20(underlyingAddress);\n        _UNDERLYING_IS_ETH = underlyingAddress == address(0);\n        _setupRole(DEFAULT_ADMIN_ROLE, NOTIONAL.owner());\n    }\n\n    function _getNotionalUnderlyingToken(uint16 currencyId) internal view returns (address) {\n        (Token memory assetToken, Token memory underlyingToken) = NOTIONAL.getCurrency(currencyId);\n\n        return assetToken.tokenType == TokenType.NonMintable ?\n            assetToken.tokenAddress : underlyingToken.tokenAddress;\n    }\n\n    /// @notice Can be used to delegate call to the TradingModule's implementation in order to execute\n    /// a trade.\n    function _executeTrade(\n        uint16 dexId,\n        Trade memory trade\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        return trade._executeTrade(dexId, TRADING_MODULE);\n    }\n\n    /***************"
    }
  ]
}