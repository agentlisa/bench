{
  "Title": "[M-02] `_payoutToken[s]()` is not compatible with tokens with missing return value",
  "Content": "\n[PA1D.sol#L317](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L317)<br>\n[PA1D.sol#L340](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L340)<br>\n\nPayout is blocked and tokens are stuck in contract.\n\n### Proof of Concept\n\n`PA1D._payoutToken()` and `PA1D._payoutTokens()` call `ERC20.transfer()` in a require-statement to send tokens to a list of payout recipients.<br>\nSome tokens do not return a bool (e.g. USDT, BNB, OMG) on ERC20 methods. But since the require-statement expects a `bool`, for such a token a `void` return will also cause a revert, despite an otherwise successful transfer. That is, the token payout will always revert for such tokens.\n\n### Recommended Mitigation Steps\n\nUse [OpenZeppelin's SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol), which handles the return value check as well as non-standard-compliant tokens.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/456#issuecomment-1306632476):**\n > Low priority, but can be updated to ensure compatibility with all ERC20 tokens.\n\n**[alexanderattar (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/456#issuecomment-1306632476):**\n > [Feature/holo 612 royalty smart contract improvements](https://github.com/holographxyz/holograph-protocol/pull/93)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-holograph-contest",
  "Code": [
    {
      "filename": "src/enforcer/PA1D.sol",
      "content": "/*HOLOGRAPH_LICENSE_HEADER*/\n\n/*SOLIDITY_COMPILER_VERSION*/\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/PA1DInterface.sol\";\n\nimport \"../struct/ZoraBidShares.sol\";\n\n/**\n * @title PA1D (CXIP)\n * @author CXIP-Labs\n * @notice A smart contract for providing royalty info, collecting royalties, and distributing it to configured payout wallets.\n * @dev This smart contract is not intended to be used directly. Apply it to any of your ERC721 or ERC1155 smart contracts through a delegatecall fallback.\n */\ncontract PA1D is Admin, Owner, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.defaultBp')) - 1)\n   */\n  bytes32 constant _defaultBpSlot = precomputeslot(\"eip1967.Holograph.PA1D.defaultBp\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.defaultReceiver')) - 1)\n   */\n  bytes32 constant _defaultReceiverSlot = precomputeslot(\"eip1967.Holograph.PA1D.defaultReceiver\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.initialized')) - 1)\n   */\n  bytes32 constant _initializedPaidSlot = precomputeslot(\"eip1967.Holograph.PA1D.initialized\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.payout.addresses')) - 1)\n   */\n  bytes32 constant _payoutAddressesSlot = precomputeslot(\"eip1967.Holograph.PA1D.payout.addresses\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.payout.bps')) - 1)\n   */\n  bytes32 constant _payoutBpsSlot = precomputeslot(\"eip1967.Holograph.PA1D.payout.bps\");\n\n  string constant _bpString = \"eip1967.Holograph.PA1D.bp\";\n  string constant _receiverString = \"eip1967.Holograph.PA1D.receiver\";\n  string constant _tokenAddressString = \"eip1967.Holograph.PA1D.tokenAddress\";\n\n  /**\n   * @notice Event emitted when setting/updating royalty info/fees. This is used by Rarible V1.\n   * @dev Emits event in order to comply with Rarible V1 royalty spec.\n   * @param tokenId Specific token id for which royalty info is being set, set as 0 for all tokens inside of the smart contract.\n   * @param recipients Address array of wallets that will receive tha royalties.\n   * @param bps Uint256 array of base points(percentages) that each wallet(specified in recipients) will receive from the royalty payouts. Make sure that all the base points add up to a total of 10000.\n   */\n  event SecondarySaleFees(uint256 tokenId, address[] recipients, uint256[] bps);\n\n  /**\n   * @dev Use this modifier to lock public functions that should not be accesible to non-owners.\n   */\n  modifier onlyOwner() override {\n    require(isOwner(), \"PA1D: caller not an owner\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"PA1D: already initialized\");\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_ownerSlot, caller())\n    }\n    (address receiver, uint256 bp) = abi.decode(initPayload, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function initPA1D(bytes memory initPayload) external returns (bytes4) {\n    uint256 initialized;\n    assembly {\n      initialized := sload(_initializedPaidSlot)\n    }\n    require(initialized == 0, \"PA1D: already initialized\");\n    (address receiver, uint256 bp) = abi.decode(initPayload, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    initialized = 1;\n    assembly {\n      sstore(_initializedPaidSlot, initialized)\n    }\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Check if message sender is a legitimate owner of the smart contract\n   * @dev We check owner, admin, and identity for a more comprehensive coverage.\n   * @return Returns true is message sender is an owner.\n   */\n  function isOwner() private view returns (bool) {\n    return (msg.sender == getOwner() ||\n      msg.sender == getAdmin() ||\n      msg.sender == Owner(address(this)).getOwner() ||\n      msg.sender == Admin(address(this)).getAdmin());\n  }\n\n  /**\n   * @dev Gets the default royalty payment receiver address from storage slot.\n   * @return receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _getDefaultReceiver() private view returns (address payable receiver) {\n    assembly {\n      receiver := sload(_defaultReceiverSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty payment receiver address to storage slot.\n   * @param receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _setDefaultReceiver(address receiver) private {\n    assembly {\n      sstore(_defaultReceiverSlot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the default royalty base points(percentage) from storage slot.\n   * @return bp Royalty base points(percentage) for royalty payouts.\n   */\n  function _getDefaultBp() private view returns (uint256 bp) {\n    assembly {\n      bp := sload(_defaultBpSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty base points(percentage) to storage slot.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function _setDefaultBp(uint256 bp) private {\n    assembly {\n      sstore(_defaultBpSlot, bp)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty payment receiver address, for a particular token id, from storage slot.\n   * @return receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _getReceiver(uint256 tokenId) private view returns (address payable receiver) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      receiver := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty payment receiver address, for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the receiver for.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _setReceiver(uint256 tokenId, address receiver) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      sstore(slot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty base points(percentage), for a particular token id, from storage slot.\n   * @return bp Royalty base points(percentage) for the royalty payouts of a specific token id.\n   */\n  function _getBp(uint256 tokenId) private view returns (uint256 bp) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      bp := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty base points(percentage), for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the base points for.\n   * @param bp Uint256 of royalty percentage, provided in base points format, for a particular token id.\n   */\n  function _setBp(uint256 tokenId, uint256 bp) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      sstore(slot, bp)\n    }\n  }\n\n  function _getPayoutAddresses() private view returns (address payable[] memory addresses) {\n    // The slot hash has been precomputed for gas optimizaion\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    addresses = new address payable[](length);\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      addresses[i] = value;\n    }\n  }\n\n  function _setPayoutAddresses(address payable[] memory addresses) private {\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length = addresses.length;\n    assembly {\n      sstore(slot, length)\n    }\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = addresses[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getPayoutBps() private view returns (uint256[] memory bps) {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    bps = new uint256[](length);\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      bps[i] = value;\n    }\n  }\n\n  function _setPayoutBps(uint256[] memory bps) private {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length = bps.length;\n    assembly {\n      sstore(slot, length)\n    }\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = bps[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getTokenAddress(string memory tokenName) private view returns (address tokenAddress) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      tokenAddress := sload(slot)\n    }\n  }\n\n  function _setTokenAddress(string memory tokenName, address tokenAddress) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      sstore(slot, tokenAddress)\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers ETH to all payout recipients.\n   */\n  function _payoutEth() private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    // accommodating the 2300 gas stipend\n    // adding 1x for each item in array to accomodate rounding errors\n    uint256 gasCost = (23300 * length) + length;\n    uint256 balance = address(this).balance;\n    require(balance - gasCost > 10000, \"PA1D: Not enough ETH to transfer\");\n    balance = balance - gasCost;\n    uint256 sending;\n    // uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      addresses[i].transfer(sending);\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers tokens to all payout recipients.\n   * @param tokenAddress Smart contract address of ERC20 token.\n   */\n  function _payoutToken(address tokenAddress) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    ERC20 erc20 = ERC20(tokenAddress);\n    uint256 balance = erc20.balanceOf(address(this));\n    require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n    uint256 sending;\n    //uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers multiple tokens to all payout recipients.\n   * @dev Try to use _payoutToken and handle each token individually.\n   * @param tokenAddresses Array of smart contract addresses of ERC20 tokens.\n   */\n  function _payoutTokens(address[] memory tokenAddresses) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    ERC20 erc20;\n    uint256 balance;\n    uint256 sending;\n    for (uint256 t = 0; t < tokenAddresses.length; t++) {\n      erc20 = ERC20(tokenAddresses[t]);\n      balance = erc20.balanceOf(address(this));\n      require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n      // uint256 sent;\n      for (uint256 i = 0; i < addresses.length; i++) {\n        sending = ((bps[i] * balance) / 10000);\n        require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n        // sent = sent + sending;\n      }\n    }\n  }\n\n  /**\n   * @dev This function validates that the call is being made by an authorised wallet.\n   * @dev Will revert entire tranaction if it fails.\n   */\n  function _validatePayoutRequestor() private view {\n    if (!isOwner()) {\n      bool matched;\n      address payable[] memory addresses = _getPayoutAddresses();\n      address payable sender = payable(msg.sender);\n      for (uint256 i = 0; i < addresses.length; i++) {\n        if (addresses[i] == sender) {\n          matched = true;\n          break;\n        }\n      }\n      require(matched, \"PA1D: sender not authorized\");\n    }\n  }\n\n  /**\n   * @notice Set the wallets and percentages for royalty payouts.\n   * @dev Function can only we called by owner, admin, or identity wallet.\n   * @dev Addresses and bps arrays must be equal length. Bps values added together must equal 10000 exactly.\n   * @param addresses An array of all the addresses that will be receiving royalty payouts.\n   * @param bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function configurePayouts(address payable[] memory addresses, uint256[] memory bps) public onlyOwner {\n    require(addresses.length == bps.length, \"PA1D: missmatched array lenghts\");\n    uint256 totalBp;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      totalBp = totalBp + bps[i];\n    }\n    require(totalBp == 10000, \"PA1D: bps down't equal 10000\");\n    _setPayoutAddresses(addresses);\n    _setPayoutBps(bps);\n  }\n\n  /**\n   * @notice Show the wallets and percentages of payout recipients.\n   * @dev These are the recipients that will be getting royalty payouts.\n   * @return addresses An array of all the addresses that will be receiving royalty payouts.\n   * @return bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function getPayoutInfo() public view returns (address payable[] memory addresses, uint256[] memory bps) {\n    addresses = _getPayoutAddresses();\n    bps = _getPayoutBps();\n  }\n\n  /**\n   * @notice Get payout of all ETH in smart contract.\n   * @dev Distribute all the ETH(minus gas fees) to payout recipients.\n   */\n  function getEthPayout() public {\n    _validatePayoutRequestor();\n    _payoutEth();\n  }\n\n  /**\n   * @notice Get payout for a specific token address. Token must have a positive balance!\n   * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n   * @param tokenAddress An address of the token for which to issue payouts for.\n   */\n  function getTokenPayout(address tokenAddress) public {\n    _validatePayoutRequestor();\n    _payoutToken(tokenAddress);\n  }\n\n  /**\n   * @notice Get payouts for tokens listed by address. Tokens must have a positive balance!\n   * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n   * @param tokenAddresses An address array of tokens to issue payouts for.\n   */\n  function getTokensPayout(address[] memory tokenAddresses) public {\n    _validatePayoutRequestor();\n    _payoutTokens(tokenAddresses);\n  }\n\n  /**\n   * @notice Set the royalty information for entire contract, or a specific token.\n   * @dev Take great care to not make this function accessible by other public functions in your overlying smart contract.\n   * @param tokenId Set a specific token id, or leave at 0 to set as default parameters.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function setRoyalties(\n    uint256 tokenId,\n    address payable receiver,\n    uint256 bp\n  ) public onlyOwner {\n    if (tokenId == 0) {\n      _setDefaultReceiver(receiver);\n      _setDefaultBp(bp);\n    } else {\n      _setReceiver(tokenId, receiver);\n      _setBp(tokenId, bp);\n    }\n    address[] memory receivers = new address[](1);\n    receivers[0] = address(receiver);\n    uint256[] memory bps = new uint256[](1);\n    bps[0] = bp;\n    emit SecondarySaleFees(tokenId, receivers, bps);\n  }\n\n  // IEIP2981\n  function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultReceiver(), (_getDefaultBp() * value) / 10000);\n    } else {\n      return (_getReceiver(tokenId), (_getBp(tokenId) * value) / 10000);\n    }\n  }\n\n  // Rarible V1\n  function getFeeBps(uint256 tokenId) public view returns (uint256[] memory) {\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      bps[0] = _getDefaultBp();\n    } else {\n      bps[0] = _getBp(tokenId);\n    }\n    return bps;\n  }\n\n  // Rarible V1\n  function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n    }\n    return receivers;\n  }\n\n  // Rarible V2(not being used since it creates a conflict with Manifold royalties)\n  // struct Part {\n  //     address payable account;\n  //     uint96 value;\n  // }\n\n  // function getRoyalties(uint256 tokenId) public view returns (Part[] memory) {\n  //     return royalties[id];\n  // }\n\n  // Manifold\n  function getRoyalties(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // Foundation\n  function getFees(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // SuperRare\n  // Hint taken from Manifold's RoyaltyEngine(https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol)\n  // To be quite honest, SuperRare is a closed marketplace. They're working on opening it up but looks like they want to use private smart contracts.\n  // We'll just leave this here for just in case they open the flood gates.\n  function tokenCreator(\n    address,\n    /* contractAddress*/\n    uint256 tokenId\n  ) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // SuperRare\n  function calculateRoyaltyFee(\n    address,\n    /* contractAddress */\n    uint256 tokenId,\n    uint256 amount\n  ) public view returns (uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultBp() * amount) / 10000;\n    } else {\n      return (_getBp(tokenId) * amount) / 10000;\n    }\n  }\n\n  // Zora\n  // we indicate that this contract operates market functions\n  function marketContract() public view returns (address) {\n    return address(this);\n  }\n\n  // Zora\n  // we indicate that the receiver is the creator, to convince the smart contract to pay\n  function tokenCreators(uint256 tokenId) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // Zora\n  // we provide the percentage that needs to be paid out from the sale\n  function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {\n    // this information is outside of the scope of our\n    bidShares.prevOwner.value = 0;\n    bidShares.owner.value = 0;\n    if (_getReceiver(tokenId) == address(0)) {\n      bidShares.creator.value = _getDefaultBp();\n    } else {\n      bidShares.creator.value = _getBp(tokenId);\n    }\n    return bidShares;\n  }\n\n  /**\n   * @notice Get the smart contract address of a token by common name.\n   * @dev Used only to identify really major/common tokens. Avoid using due to gas usages.\n   * @param tokenName The ticker symbol of the token. For example \"USDC\" or \"DAI\".\n   * @return The smart contract address of the token ticker symbol. Or zero address if not found.\n   */\n  function getTokenAddress(string memory tokenName) public view returns (address) {\n    return _getTokenAddress(tokenName);\n  }\n}"
    },
    {
      "filename": "src/enforcer/PA1D.sol",
      "content": "/*HOLOGRAPH_LICENSE_HEADER*/\n\n/*SOLIDITY_COMPILER_VERSION*/\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/PA1DInterface.sol\";\n\nimport \"../struct/ZoraBidShares.sol\";\n\n/**\n * @title PA1D (CXIP)\n * @author CXIP-Labs\n * @notice A smart contract for providing royalty info, collecting royalties, and distributing it to configured payout wallets.\n * @dev This smart contract is not intended to be used directly. Apply it to any of your ERC721 or ERC1155 smart contracts through a delegatecall fallback.\n */\ncontract PA1D is Admin, Owner, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.defaultBp')) - 1)\n   */\n  bytes32 constant _defaultBpSlot = precomputeslot(\"eip1967.Holograph.PA1D.defaultBp\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.defaultReceiver')) - 1)\n   */\n  bytes32 constant _defaultReceiverSlot = precomputeslot(\"eip1967.Holograph.PA1D.defaultReceiver\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.initialized')) - 1)\n   */\n  bytes32 constant _initializedPaidSlot = precomputeslot(\"eip1967.Holograph.PA1D.initialized\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.payout.addresses')) - 1)\n   */\n  bytes32 constant _payoutAddressesSlot = precomputeslot(\"eip1967.Holograph.PA1D.payout.addresses\");\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.payout.bps')) - 1)\n   */\n  bytes32 constant _payoutBpsSlot = precomputeslot(\"eip1967.Holograph.PA1D.payout.bps\");\n\n  string constant _bpString = \"eip1967.Holograph.PA1D.bp\";\n  string constant _receiverString = \"eip1967.Holograph.PA1D.receiver\";\n  string constant _tokenAddressString = \"eip1967.Holograph.PA1D.tokenAddress\";\n\n  /**\n   * @notice Event emitted when setting/updating royalty info/fees. This is used by Rarible V1.\n   * @dev Emits event in order to comply with Rarible V1 royalty spec.\n   * @param tokenId Specific token id for which royalty info is being set, set as 0 for all tokens inside of the smart contract.\n   * @param recipients Address array of wallets that will receive tha royalties.\n   * @param bps Uint256 array of base points(percentages) that each wallet(specified in recipients) will receive from the royalty payouts. Make sure that all the base points add up to a total of 10000.\n   */\n  event SecondarySaleFees(uint256 tokenId, address[] recipients, uint256[] bps);\n\n  /**\n   * @dev Use this modifier to lock public functions that should not be accesible to non-owners.\n   */\n  modifier onlyOwner() override {\n    require(isOwner(), \"PA1D: caller not an owner\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"PA1D: already initialized\");\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_ownerSlot, caller())\n    }\n    (address receiver, uint256 bp) = abi.decode(initPayload, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function initPA1D(bytes memory initPayload) external returns (bytes4) {\n    uint256 initialized;\n    assembly {\n      initialized := sload(_initializedPaidSlot)\n    }\n    require(initialized == 0, \"PA1D: already initialized\");\n    (address receiver, uint256 bp) = abi.decode(initPayload, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    initialized = 1;\n    assembly {\n      sstore(_initializedPaidSlot, initialized)\n    }\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Check if message sender is a legitimate owner of the smart contract\n   * @dev We check owner, admin, and identity for a more comprehensive coverage.\n   * @return Returns true is message sender is an owner.\n   */\n  function isOwner() private view returns (bool) {\n    return (msg.sender == getOwner() ||\n      msg.sender == getAdmin() ||\n      msg.sender == Owner(address(this)).getOwner() ||\n      msg.sender == Admin(address(this)).getAdmin());\n  }\n\n  /**\n   * @dev Gets the default royalty payment receiver address from storage slot.\n   * @return receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _getDefaultReceiver() private view returns (address payable receiver) {\n    assembly {\n      receiver := sload(_defaultReceiverSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty payment receiver address to storage slot.\n   * @param receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _setDefaultReceiver(address receiver) private {\n    assembly {\n      sstore(_defaultReceiverSlot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the default royalty base points(percentage) from storage slot.\n   * @return bp Royalty base points(percentage) for royalty payouts.\n   */\n  function _getDefaultBp() private view returns (uint256 bp) {\n    assembly {\n      bp := sload(_defaultBpSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty base points(percentage) to storage slot.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function _setDefaultBp(uint256 bp) private {\n    assembly {\n      sstore(_defaultBpSlot, bp)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty payment receiver address, for a particular token id, from storage slot.\n   * @return receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _getReceiver(uint256 tokenId) private view returns (address payable receiver) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      receiver := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty payment receiver address, for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the receiver for.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _setReceiver(uint256 tokenId, address receiver) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      sstore(slot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty base points(percentage), for a particular token id, from storage slot.\n   * @return bp Royalty base points(percentage) for the royalty payouts of a specific token id.\n   */\n  function _getBp(uint256 tokenId) private view returns (uint256 bp) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      bp := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty base points(percentage), for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the base points for.\n   * @param bp Uint256 of royalty percentage, provided in base points format, for a particular token id.\n   */\n  function _setBp(uint256 tokenId, uint256 bp) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      sstore(slot, bp)\n    }\n  }\n\n  function _getPayoutAddresses() private view returns (address payable[] memory addresses) {\n    // The slot hash has been precomputed for gas optimizaion\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    addresses = new address payable[](length);\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      addresses[i] = value;\n    }\n  }\n\n  function _setPayoutAddresses(address payable[] memory addresses) private {\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length = addresses.length;\n    assembly {\n      sstore(slot, length)\n    }\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = addresses[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getPayoutBps() private view returns (uint256[] memory bps) {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    bps = new uint256[](length);\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      bps[i] = value;\n    }\n  }\n\n  function _setPayoutBps(uint256[] memory bps) private {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length = bps.length;\n    assembly {\n      sstore(slot, length)\n    }\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = bps[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getTokenAddress(string memory tokenName) private view returns (address tokenAddress) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      tokenAddress := sload(slot)\n    }\n  }\n\n  function _setTokenAddress(string memory tokenName, address tokenAddress) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      sstore(slot, tokenAddress)\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers ETH to all payout recipients.\n   */\n  function _payoutEth() private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    // accommodating the 2300 gas stipend\n    // adding 1x for each item in array to accomodate rounding errors\n    uint256 gasCost = (23300 * length) + length;\n    uint256 balance = address(this).balance;\n    require(balance - gasCost > 10000, \"PA1D: Not enough ETH to transfer\");\n    balance = balance - gasCost;\n    uint256 sending;\n    // uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      addresses[i].transfer(sending);\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers tokens to all payout recipients.\n   * @param tokenAddress Smart contract address of ERC20 token.\n   */\n  function _payoutToken(address tokenAddress) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    ERC20 erc20 = ERC20(tokenAddress);\n    uint256 balance = erc20.balanceOf(address(this));\n    require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n    uint256 sending;\n    //uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers multiple tokens to all payout recipients.\n   * @dev Try to use _payoutToken and handle each token individually.\n   * @param tokenAddresses Array of smart contract addresses of ERC20 tokens.\n   */\n  function _payoutTokens(addres"
    }
  ]
}