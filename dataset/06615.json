{
  "Title": "[G-16] Use assembly to perform efficient back-to-back calls",
  "Content": "If a similar external call is performed back-to-back, we can use assembly to reuse any function signatures and function parameters that stay the same. In addition, we can also reuse the same memory space for each function call (`scratch space` + `free memory pointer` + `zero slot`), which can potentially allow us to avoid memory expansion costs.\n\n**Note:** In order to do this optimization safely we will cache the free memory pointer value and restore it once we are done with our function calls. We will also set the zero slot back to 0 if necessary.\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/Pool/PoolRegistry.sol#L239-L245\n\nGas Savings for `PoolRegistry.createRegistryPool`, obtained via protocol's tests: Avg 1049 gas.\n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  645562   |  683114   |  664419  |   23   | \n| After  |  644525   |  682065   |  663370  |   23   | \n\n```solidity\nFile: contracts/Pool/PoolRegistry.sol\n239:        comptrollerProxy.setCloseFactor(closeFactor);\n240:        comptrollerProxy.setLiquidationIncentive(liquidationIncentive);\n241:        comptrollerProxy.setMinLiquidatableCollateral(minLiquidatableCollateral);\n242:        comptrollerProxy.setPriceOracle(PriceOracle(priceOracle));\n243:\n244:        // Start transferring ownership to msg.sender\n245:        comptrollerProxy.transferOwnership(msg.sender);\n```\n```diff\ndiff --git a/contracts/Pool/PoolRegistry.sol b/contracts/Pool/PoolRegistry.sol\nindex 5cf376f..b2d696a 100644\n--- a/contracts/Pool/PoolRegistry.sol\n+++ b/contracts/Pool/PoolRegistry.sol\n@@ -236,13 +236,28 @@ contract PoolRegistry is Ownable2StepUpgradeable, AccessControlledV8, PoolRegist\n         uint256 poolId = _registerPool(name, proxyAddress);\n\n         // Set Venus pool parameters\n-        comptrollerProxy.setCloseFactor(closeFactor);\n-        comptrollerProxy.setLiquidationIncentive(liquidationIncentive);\n-        comptrollerProxy.setMinLiquidatableCollateral(minLiquidatableCollateral);\n-        comptrollerProxy.setPriceOracle(PriceOracle(priceOracle));\n-\n-        // Start transferring ownership to msg.sender\n-        comptrollerProxy.transferOwnership(msg.sender);\n+        assembly {\n+            // function signature for setCloseFactor(uint256)\n+            mstore(0x00, 0x12348e96)\n+            mstore(0x20, calldataload(0x44))\n+            if iszero(call(gas(), comptrollerProxy, 0x00, 0x1c, 0x24, 0x00, 0x00)) {revert(0, 0)}\n+            // function signature for setLiquidationIncentive(uint256)\n+            mstore(0x00, 0xa8431081)\n+            mstore(0x20, calldataload(0x64))\n+            if iszero(call(gas(), comptrollerProxy, 0x00, 0x1c, 0x24, 0x00, 0x00)) {revert(0, 0)}\n+            // function signature for setMinLiquidatableCollateral(uint256)\n+            mstore(0x00, 0x520b6c74)\n+            mstore(0x20, calldataload(0x84))\n+            if iszero(call(gas(), comptrollerProxy, 0x00, 0x1c, 0x24, 0x00, 0x00)) {revert(0, 0)}\n+            // function signature for setPriceOracle(address)\n+            mstore(0x00, 0x530e784f)\n+            mstore(0x20, calldataload(0xa4))\n+            if iszero(call(gas(), comptrollerProxy, 0x00, 0x1c, 0x24, 0x00, 0x00)) {revert(0, 0)}\n+            // function signature for transferOwnership(address)\n+            mstore(0x00, 0xf2fde38b)\n+            mstore(0x20, caller())\n+            if iszero(call(gas(), comptrollerProxy, 0x00, 0x1c, 0x24, 0x00, 0x00)) {revert(0, 0)}\n+        }\n\n         // Register the pool with this PoolRegistry\n         return (poolId, proxyAddress);\n```\n\n## GasReport output with all optimizations applied\n*Note: please see warden's [original submission](https://github.com/code-423n4/2023-05-venus-findings/issues/538) for full details.*\n\n**[chechu (Venus) confirmed and commented](https://github.com/code-423n4/2023-05-venus-findings/issues/538#issuecomment-1560162579):**\n > G-01\tConfirm<br>\n> G-02\tTBD<br>\n> G-03\tTBD<br>\n> G-04\tConfirm<br>\n> G-05\tConfirm<br>\n> G-06\tConfirm<br>\n> G-07\tConfirm<br>\n> G-08\tConfirm<br>\n> G-09\tConfirm<br>\n> G-10\tDisagree with severity<br>\n> G-11\tDisagree with severity<br>\n> G-12\tDisagree with severity<br>\n> G-13\tConfirm<br>\n> G-14\tTBR<br>\n> G-15\tDisagree with severity<br>\n> G-16\tDisagree with severity<br>\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/Pool/PoolRegistry.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../Comptroller.sol\";\nimport \"../Factories/VTokenProxyFactory.sol\";\nimport \"../Factories/JumpRateModelFactory.sol\";\nimport \"../Factories/WhitePaperInterestRateModelFactory.sol\";\nimport \"../WhitePaperInterestRateModel.sol\";\nimport \"../VToken.sol\";\nimport \"../InterestRateModel.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlManager.sol\";\nimport \"../Shortfall/Shortfall.sol\";\nimport \"../VTokenInterfaces.sol\";\nimport \"./PoolRegistryInterface.sol\";\n\n/**\n * @title PoolRegistry\n * @notice PoolRegistry is a registry for Venus interest rate pools.\n */\ncontract PoolRegistry is Ownable2StepUpgradeable, AccessControlledV8, PoolRegistryInterface {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    enum InterestRateModels {\n        WhitePaper,\n        JumpRate\n    }\n\n    struct AddMarketInput {\n        address comptroller;\n        address asset;\n        uint8 decimals;\n        string name;\n        string symbol;\n        InterestRateModels rateModel;\n        uint256 baseRatePerYear;\n        uint256 multiplierPerYear;\n        uint256 jumpMultiplierPerYear;\n        uint256 kink_;\n        uint256 collateralFactor;\n        uint256 liquidationThreshold;\n        uint256 reserveFactor;\n        AccessControlManager accessControlManager;\n        address beaconAddress;\n        uint256 initialSupply;\n        address vTokenReceiver;\n        uint256 supplyCap;\n        uint256 borrowCap;\n    }\n\n    /**\n     * @notice VTokenProxyFactory contract address\n     */\n    VTokenProxyFactory public vTokenFactory;\n\n    /**\n     * @notice JumpRateModelFactory contract address\n     */\n    JumpRateModelFactory public jumpRateFactory;\n\n    /**\n     * @notice WhitePaperInterestRateModelFactory contract address\n     */\n    WhitePaperInterestRateModelFactory public whitePaperFactory;\n\n    /**\n     * @notice Shortfall contract address\n     */\n    Shortfall public shortfall;\n\n    /**\n     * @notice Shortfall contract address\n     */\n    address payable public protocolShareReserve;\n\n    /**\n     * @notice Maps pool's comptroller address to metadata.\n     */\n    mapping(address => VenusPoolMetaData) public metadata;\n\n    /**\n     * @dev Maps pool ID to pool's comptroller address\n     */\n    mapping(uint256 => address) private _poolsByID;\n\n    /**\n     * @dev Total number of pools created.\n     */\n    uint256 private _numberOfPools;\n\n    /**\n     * @dev Maps comptroller address to Venus pool Index.\n     */\n    mapping(address => VenusPool) private _poolByComptroller;\n\n    /**\n     * @dev Maps pool's comptroller address to asset to vToken.\n     */\n    mapping(address => mapping(address => address)) private _vTokens;\n\n    /**\n     * @dev Maps asset to list of supported pools.\n     */\n    mapping(address => address[]) private _supportedPools;\n\n    /**\n     * @dev Emitted when a new Venus pool is added to the directory.\n     */\n    event PoolRegistered(address indexed comptroller, VenusPool pool);\n\n    /**\n     * @dev Emitted when a pool name is set.\n     */\n    event PoolNameSet(address indexed comptroller, string oldName, string newName);\n\n    /**\n     * @dev Emitted when a pool metadata is updated.\n     */\n    event PoolMetadataUpdated(\n        address indexed comptroller,\n        VenusPoolMetaData oldMetadata,\n        VenusPoolMetaData newMetadata\n    );\n\n    /**\n     * @dev Emitted when a Market is added to the pool.\n     */\n    event MarketAdded(address indexed comptroller, address vTokenAddress);\n\n    /**\n     * @notice Event emitted when shortfall contract address is changed\n     */\n    event NewShortfallContract(address indexed oldShortfall, address indexed newShortfall);\n\n    /**\n     * @notice Event emitted when protocol share reserve contract address is changed\n     */\n    event NewProtocolShareReserve(address indexed oldProtocolShareReserve, address indexed newProtocolShareReserve);\n\n    /**\n     * @notice Thrown if trying to set a zero address where it's not allowed\n     */\n    error ZeroAddressNotAllowed();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the deployer to owner.\n     * @param vTokenFactory_ vToken factory address.\n     * @param jumpRateFactory_ jump rate factory address.\n     * @param whitePaperFactory_ white paper factory address.\n     * @param protocolShareReserve_ protocol's shares reserve address.\n     * @param accessControlManager_ AccessControlManager contract address.\n     */\n    function initialize(\n        VTokenProxyFactory vTokenFactory_,\n        JumpRateModelFactory jumpRateFactory_,\n        WhitePaperInterestRateModelFactory whitePaperFactory_,\n        Shortfall shortfall_,\n        address payable protocolShareReserve_,\n        address accessControlManager_\n    ) external initializer {\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n\n        vTokenFactory = vTokenFactory_;\n        jumpRateFactory = jumpRateFactory_;\n        whitePaperFactory = whitePaperFactory_;\n        _setShortfallContract(shortfall_);\n        _setProtocolShareReserve(protocolShareReserve_);\n    }\n\n    /**\n     * @notice Sets protocol share reserve contract address\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\n     * @custom:access Only Governance\n     */\n    function setProtocolShareReserve(address payable protocolShareReserve_) external onlyOwner {\n        _setProtocolShareReserve(protocolShareReserve_);\n    }\n\n    /**\n     * @notice Sets shortfall contract address\n     * @param shortfall_ The address of the shortfall contract\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\n     * @custom:access Only Governance\n     */\n    function setShortfallContract(Shortfall shortfall_) external onlyOwner {\n        _setShortfallContract(shortfall_);\n    }\n\n    /**\n     * @dev Deploys a new Venus pool and adds to the directory.\n     * @param name The name of the pool\n     * @param beaconAddress The upgradeable beacon contract address for Comptroller implementation\n     * @param closeFactor The pool's close factor (scaled by 1e18)\n     * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18)\n     * @param priceOracle The pool's PriceOracle address\n     * @param maxLoopsLimit The maximum limit for the loops can iterate.\n     * @return index The index of the registered Venus pool\n     * @return proxyAddress The the Comptroller proxy address\n     */\n    function createRegistryPool(\n        string calldata name,\n        address beaconAddress,\n        uint256 closeFactor,\n        uint256 liquidationIncentive,\n        uint256 minLiquidatableCollateral,\n        address priceOracle,\n        uint256 maxLoopsLimit,\n        address accessControlManager\n    ) external virtual returns (uint256 index, address proxyAddress) {\n        _checkAccessAllowed(\"createRegistryPool(string,address,uint256,uint256,uint256,address,uint256,address)\");\n        // Input validation\n        require(beaconAddress != address(0), \"PoolRegistry: Invalid Comptroller beacon address.\");\n        require(priceOracle != address(0), \"PoolRegistry: Invalid PriceOracle address.\");\n\n        BeaconProxy proxy = new BeaconProxy(\n            beaconAddress,\n            abi.encodeWithSelector(Comptroller.initialize.selector, maxLoopsLimit, accessControlManager)\n        );\n\n        proxyAddress = address(proxy);\n        Comptroller comptrollerProxy = Comptroller(proxyAddress);\n\n        uint256 poolId = _registerPool(name, proxyAddress);\n\n        // Set Venus pool parameters\n        comptrollerProxy.setCloseFactor(closeFactor);\n        comptrollerProxy.setLiquidationIncentive(liquidationIncentive);\n        comptrollerProxy.setMinLiquidatableCollateral(minLiquidatableCollateral);\n        comptrollerProxy.setPriceOracle(PriceOracle(priceOracle));\n\n        // Start transferring ownership to msg.sender\n        comptrollerProxy.transferOwnership(msg.sender);\n\n        // Register the pool with this PoolRegistry\n        return (poolId, proxyAddress);\n    }\n\n    /**\n     * @notice Add a market to an existing pool and then mint to provide initial supply.\n     * @param input The structure describing the parameters for adding a market to a pool.\n     */\n    function addMarket(AddMarketInput memory input) external {\n        _checkAccessAllowed(\"addMarket(AddMarketInput)\");\n        require(input.comptroller != address(0), \"PoolRegistry: Invalid comptroller address\");\n        require(input.asset != address(0), \"PoolRegistry: Invalid asset address\");\n        require(input.beaconAddress != address(0), \"PoolRegistry: Invalid beacon address\");\n        require(input.vTokenReceiver != address(0), \"PoolRegistry: Invalid vTokenReceiver address\");\n\n        // solhint-disable-next-line reason-string\n        require(\n            _vTokens[input.comptroller][input.asset] == address(0),\n            \"PoolRegistry: Market already added for asset comptroller combination\"\n        );\n\n        InterestRateModel rate;\n        if (input.rateModel == InterestRateModels.JumpRate) {\n            rate = InterestRateModel(\n                jumpRateFactory.deploy(\n                    input.baseRatePerYear,\n                    input.multiplierPerYear,\n                    input.jumpMultiplierPerYear,\n                    input.kink_,\n                    input.accessControlManager\n                )\n            );\n        } else {\n            rate = InterestRateModel(whitePaperFactory.deploy(input.baseRatePerYear, input.multiplierPerYear));\n        }\n\n        Comptroller comptroller = Comptroller(input.comptroller);\n        uint256 underlyingDecimals = IERC20Metadata(input.asset).decimals();\n\n        VTokenProxyFactory.VTokenArgs memory initializeArgs = VTokenProxyFactory.VTokenArgs(\n            input.asset,\n            comptroller,\n            rate,\n            10**(underlyingDecimals + 18 - input.decimals),\n            input.name,\n            input.symbol,\n            input.decimals,\n            msg.sender,\n            input.accessControlManager,\n            VTokenInterface.RiskManagementInit(address(shortfall), protocolShareReserve),\n            input.beaconAddress,\n            input.reserveFactor\n        );\n\n        VToken vToken = vTokenFactory.deployVTokenProxy(initializeArgs);\n\n        comptroller.supportMarket(vToken);\n        comptroller.setCollateralFactor(vToken, input.collateralFactor, input.liquidationThreshold);\n\n        uint256[] memory newSupplyCaps = new uint256[](1);\n        uint256[] memory newBorrowCaps = new uint256[](1);\n        VToken[] memory vTokens = new VToken[](1);\n\n        newSupplyCaps[0] = input.supplyCap;\n        newBorrowCaps[0] = input.borrowCap;\n        vTokens[0] = vToken;\n\n        comptroller.setMarketSupplyCaps(vTokens, newSupplyCaps);\n        comptroller.setMarketBorrowCaps(vTokens, newBorrowCaps);\n\n        _vTokens[input.comptroller][input.asset] = address(vToken);\n        _supportedPools[input.asset].push(input.comptroller);\n\n        IERC20Upgradeable token = IERC20Upgradeable(input.asset);\n        uint256 amountToSupply = _transferIn(token, msg.sender, input.initialSupply);\n        token.safeApprove(address(vToken), 0);\n        token.safeApprove(address(vToken), amountToSupply);\n        vToken.mintBehalf(input.vTokenReceiver, amountToSupply);\n\n        emit MarketAdded(address(comptroller), address(vToken));\n    }\n\n    /**\n     * @notice Modify existing Venus pool name.\n     */\n    function setPoolName(address comptroller, string calldata name) external {\n        _checkAccessAllowed(\"setPoolName(address,string)\");\n        _ensureValidName(name);\n        string memory oldName = _poolByComptroller[comptroller].name;\n        _poolByComptroller[comptroller].name = name;\n        emit PoolNameSet(comptroller, oldName, name);\n    }\n\n    /**\n     * @notice Update metadata of an existing pool.\n     */\n    function updatePoolMetadata(address comptroller, VenusPoolMetaData memory _metadata) external {\n        _checkAccessAllowed(\"updatePoolMetadata(address,VenusPoolMetaData)\");\n        VenusPoolMetaData memory oldMetadata = metadata[comptroller];\n        metadata[comptroller] = _metadata;\n        emit PoolMetadataUpdated(comptroller, oldMetadata, _metadata);\n    }\n\n    /**\n     * @notice Returns arrays of all Venus pools' data.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getAllPools() external view override returns (VenusPool[] memory) {\n        VenusPool[] memory _pools = new VenusPool[](_numberOfPools);\n        for (uint256 i = 1; i <= _numberOfPools; ++i) {\n            address comptroller = _poolsByID[i];\n            _pools[i - 1] = (_poolByComptroller[comptroller]);\n        }\n        return _pools;\n    }\n\n    /**\n     * @param comptroller The comptroller proxy address associated to the pool\n     * @return  Returns Venus pool\n     */\n    function getPoolByComptroller(address comptroller) external view override returns (VenusPool memory) {\n        return _poolByComptroller[comptroller];\n    }\n\n    /**\n     * @param comptroller comptroller of Venus pool\n     * @return Returns Metadata of Venus pool\n     */\n    function getVenusPoolMetadata(address comptroller) external view override returns (VenusPoolMetaData memory) {\n        return metadata[comptroller];\n    }\n\n    function getVTokenForAsset(address comptroller, address asset) external view override returns (address) {\n        return _vTokens[comptroller][asset];\n    }\n\n    function getPoolsSupportedByAsset(address asset) external view override returns (address[] memory) {\n        return _supportedPools[asset];\n    }\n\n    /**\n     * @dev Adds a new Venus pool to the directory (without checking msg.sender).\n     * @param name The name of the pool\n     * @param comptroller The pool's Comptroller proxy contract address\n     * @return The index of the registered Venus pool\n     */\n    function _registerPool(string calldata name, address comptroller) internal returns (uint256) {\n        VenusPool memory venusPool = _poolByComptroller[comptroller];\n\n        require(venusPool.creator == address(0), \"PoolRegistry: Pool already exists in the directory.\");\n        _ensureValidName(name);\n\n        _numberOfPools++;\n\n        VenusPool memory pool = VenusPool(name, msg.sender, comptroller, block.number, block.timestamp);\n\n        _poolsByID[_numberOfPools] = comptroller;\n        _poolByComptroller[comptroller] = pool;\n\n        emit PoolRegistered(comptroller, pool);\n        return _numberOfPools;\n    }\n\n    function _transferIn(\n        IERC20Upgradeable token,\n        address from,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(from, address(this), amount);\n        uint256 balanceAfter = token.balanceOf(address(this));\n        return balanceAfter - balanceBefore;\n    }\n\n    function _setShortfallContract(Shortfall shortfall_) internal {\n        if (address(shortfall_) == address(0)) {\n            revert ZeroAddressNotAllowed();\n        }\n        address oldShortfall = address(shortfall);\n        shortfall = shortfall_;\n        emit NewShortfallContract(oldShortfall, address(shortfall_));\n    }\n\n    function _setProtocolShareReserve(address payable protocolShareReserve_) internal {\n        if (protocolShareReserve_ == address(0)) {\n            revert ZeroAddressNotAllowed();\n        }\n        address oldProtocolShareReserve = protocolShareReserve;\n        protocolShareReserve = protocolShareReserve_;\n        emit NewProtocolShareReserve(oldProtocolShareReserve, protocolShareReserve_);\n    }\n\n    function _ensureValidName(string calldata name) internal pure {\n        require(bytes(name).length <= 100, \"Pool's name is too large\");\n    }\n}"
    }
  ]
}