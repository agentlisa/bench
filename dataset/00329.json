{
  "Title": "M-4: The router is not compatible with fee on transfers tokens",
  "Content": "# Issue M-4: The router is not compatible with fee on transfers tokens \n\nSource: https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/67 \n\n## Found by \n1337, MohammedRizwan, Solidity\\_ATL\\_Team\\_2, joshuajee, juan, zzykxx\n## Summary\n\nThe router is not compatible with fee on transfers tokens.\n\n## Vulnerability Detail\n\nLet's take as example the [removeLiquidity](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/periphery/GoatRouterV1.sol#L111) function:\n\n```solidity\naddress pair = GoatV1Factory(FACTORY).getPool(token);\n\nIERC20(pair).safeTransferFrom(msg.sender, pair, liquidity); //-> 1. Transfers liquidity tokens to the pair\n(amountWeth, amountToken) = GoatV1Pair(pair).burn(to); //-> 2. Burns the liquidity tokens and sends WETH and TOKEN to the recipient\nif (amountWeth < wethMin) { //-> 3. Ensures enough WETH has been transferred\n    revert GoatErrors.InsufficientWethAmount();\n}\nif (amountToken < tokenMin) { //4. Ensures enough TOKEN has been transferred\n    revert GoatErrors.InsufficientTokenAmount();\n}\n```\n\nIt does the following:\n\n1. Transfers liquidity tokens to the pair.\n2. Burns the liquidity tokens and sends WETH and TOKEN to the recipient `to`.\n3. Ensures enough WETH has been transferred.\n4. Ensures enough TOKEN has been transferred.\n\nAt point `4` the router doesn't account for the fee paid to transfer TOKEN. The recipient didn't actually receive `amountToken`, but slightly less because a fee has been charged.\n\nAnother interesting example is the [removeLiquidityETH](https://github.com/sherlock-audit/2024-03-goat-trading/blob/main/goat-trading/contracts/periphery/GoatRouterV1.sol#L131) which first burns the liquidity and transfers the tokens to the router itself, and then from the router the tokens are transferred to the recipient. This will charge double the fees.\n\nThis is just two examples to highlight the fact that these kind of tokens are not supported, but the other functions in the router have similar issues that can cause all sorts of trouble including reverts and loss of funds.\n\n## Impact\n\nThe router is not compatible with fee on transfers tokens.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd functionality to the router to support fee on transfer tokens, a good example of where this is correctly implememented is the [Uniswap Router02](https://etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D).\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  as per the readMe the contract should support FOT; medium(1)\n\n\n\n**F01ivor4**\n\nI think issue https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/40 is not same\n\n**F01ivor4**\n\nThe problem is on the router. And https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/40 is wrong.\n\n**F01ivor4**\n\nAlso, https://github.com/sherlock-audit/2024-03-goat-trading-judging/issues/3 is wrong\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/178",
  "Code": [
    {
      "filename": "goat-trading/contracts/periphery/GoatRouterV1.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// library imports\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// local imports\nimport {GoatTypes} from \"../library/GoatTypes.sol\";\nimport {GoatV1Factory} from \"../exchange/GoatV1Factory.sol\";\nimport {GoatV1Pair} from \"../exchange/GoatV1Pair.sol\";\nimport {GoatErrors} from \"../library/GoatErrors.sol\";\nimport {GoatLibrary} from \"../library/GoatLibrary.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\n/**\n * @title Goat V1 Router\n * @notice Router for stateless execution of swaps and liquidity provision\n * @dev This contract is used for adding/removing liquidity, swapping tokens and withdrawing fees\n * @dev This contract is stateless and does not store any data\n * @author Goat Trading -- Chiranjibi Poudyal, Robert M.C. Forster\n */\ncontract GoatV1Router is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address public immutable FACTORY;\n    address public immutable WETH;\n    uint32 private constant MAX_UINT32 = type(uint32).max;\n    uint8 private constant ZERO = 0;\n\n    modifier ensure(uint256 deadline) {\n        if (block.timestamp > deadline) {\n            revert GoatErrors.Expired();\n        }\n        _;\n    }\n\n    constructor(address factory, address weth) {\n        FACTORY = factory;\n        WETH = weth;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n\n    function addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external nonReentrant ensure(deadline) returns (uint256, uint256, uint256) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars = _ensurePoolAndPrepareLiqudityParameters(\n            token, tokenDesired, wethDesired, tokenMin, wethMin, initParams, false\n        );\n\n        IERC20(vars.token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n        if (vars.wethAmount != 0) {\n            IERC20(WETH).safeTransferFrom(msg.sender, vars.pair, vars.wethAmount);\n        }\n        vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n        if (vars.isNewPair) {\n            vars.wethAmount =\n                initParams.bootstrapEth == initParams.initialEth ? initParams.initialEth : initParams.virtualEth;\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.liquidity);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 tokenDesired,\n        uint256 tokenMin,\n        uint256 ethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external payable ensure(deadline) returns (uint256, uint256, uint256) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars =\n            _ensurePoolAndPrepareLiqudityParameters(token, tokenDesired, msg.value, tokenMin, ethMin, initParams, true);\n        IERC20(token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n        if (vars.wethAmount != 0) {\n            IWETH(WETH).deposit{value: vars.wethAmount}();\n            IERC20(WETH).safeTransfer(vars.pair, vars.wethAmount);\n        }\n\n        vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > vars.wethAmount) {\n            (bool success,) = payable(msg.sender).call{value: msg.value - vars.wethAmount}(\"\");\n            if (!success) {\n                revert GoatErrors.EthTransferFailed();\n            }\n        }\n\n        if (vars.isNewPair) {\n            vars.wethAmount =\n                initParams.bootstrapEth == initParams.initialEth ? initParams.initialEth : initParams.virtualEth;\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.liquidity);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address token,\n        uint256 liquidity,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline\n    ) public nonReentrant ensure(deadline) returns (uint256 amountWeth, uint256 amountToken) {\n        address pair = GoatV1Factory(FACTORY).getPool(token);\n\n        IERC20(pair).safeTransferFrom(msg.sender, pair, liquidity);\n        (amountWeth, amountToken) = GoatV1Pair(pair).burn(to);\n        if (amountWeth < wethMin) {\n            revert GoatErrors.InsufficientWethAmount();\n        }\n        if (amountToken < tokenMin) {\n            revert GoatErrors.InsufficientTokenAmount();\n        }\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 tokenMin,\n        uint256 ethMin,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256 amountWeth, uint256 amountToken) {\n        (amountWeth, amountToken) = removeLiquidity(token, liquidity, tokenMin, ethMin, address(this), deadline);\n        IERC20(token).safeTransfer(to, amountToken);\n        IWETH(WETH).withdraw(amountWeth);\n        (bool success,) = to.call{value: amountWeth}(\"\");\n        if (!success) {\n            revert GoatErrors.EthTransferFailed();\n        }\n    }\n\n    /* ----------------------------- SWAP FUNCTIONS ----------------------------- */\n    function swapWethForExactTokens(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        external\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountTokenOut)\n    {\n        GoatV1Pair pair;\n        (amountTokenOut, pair) = _getAmountTokenOut(amountIn, amountOutMin, token);\n        IERC20(WETH).safeTransferFrom(msg.sender, address(pair), amountIn);\n        pair.swap(amountTokenOut, ZERO, to);\n    }\n\n    function swapExactETHForTokens(uint256 amountOutMin, address token, address to, uint256 deadline)\n        external\n        payable\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountTokenOut)\n    {\n        GoatV1Pair pair;\n        (amountTokenOut, pair) = _getAmountTokenOut(msg.value, amountOutMin, token);\n        IWETH(WETH).deposit{value: msg.value}();\n        IERC20(WETH).safeTransfer(address(pair), msg.value);\n        pair.swap(amountTokenOut, 0, to);\n    }\n\n    function swapExactTokensForWeth(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        public\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountWethOut)\n    {\n        if (amountIn == 0) {\n            revert GoatErrors.InsufficientInputAmount();\n        }\n\n        GoatTypes.LocalVariables_PairStateInfo memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (pair == GoatV1Pair(address(0))) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        if (pair.vestingUntil() != type(uint32).max) {\n            (uint112 reserveEth, uint112 reserveToken) = pair.getStateInfoAmm();\n            amountWethOut = GoatLibrary.getWethAmountOutAmm(amountIn, reserveEth, reserveToken);\n        } else {\n            (vars.reserveEth, vars.reserveToken, vars.virtualEth,,, vars.virtualToken) = pair.getStateInfoForPresale();\n\n            amountWethOut = GoatLibrary.getWethAmountOutPresale(\n                amountIn, vars.reserveEth, vars.reserveToken, vars.virtualEth, vars.virtualToken\n            );\n        }\n\n        if (amountWethOut < amountOutMin) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n        IERC20(token).safeTransferFrom(msg.sender, address(pair), amountIn);\n        pair.swap(0, amountWethOut, to);\n    }\n\n    /* ------------------------------ WITHDRAW FEES ----------------------------- */\n    function withdrawFees(address token, address to) external nonReentrant {\n        if (to == address(0)) {\n            revert GoatErrors.ZeroAddress();\n        }\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n\n        if (address(pair) == address(0)) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        pair.withdrawFees(to);\n    }\n\n    /* ----------------------------- PUBLIC VIEW FUNCTIONS ----------------------------- */\n\n    function getActualBootstrapTokenAmount(\n        uint256 virtualEth,\n        uint256 bootstrapEth,\n        uint256 initialEth,\n        uint256 initialTokenMatch\n    ) public pure returns (uint256 actualTokenAmount) {\n        return GoatLibrary.getActualBootstrapTokenAmount(virtualEth, bootstrapEth, initialEth, initialTokenMatch);\n    }\n\n    /* --------------------------- INTERNAL FUNCTIONS --------------------------- */\n    function _addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams\n    ) internal returns (uint256, uint256, bool) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            // First time liquidity provider\n            pair = GoatV1Pair(GoatV1Factory(FACTORY).createPair(token, initParams));\n            vars.isNewPair = true;\n        }\n\n        if (vars.isNewPair) {\n            if (initParams.initialEth < initParams.bootstrapEth) {\n                /**\n                 * @dev if it's a first mint and pool is not directly converting to AMM,\n                 * initialTokenMatch and virtualEth is used for liquidity calculation\n                 */\n                (vars.tokenAmount, vars.wethAmount) = (initParams.initialTokenMatch, initParams.virtualEth);\n            } else {\n                vars.actualTokenAmount = GoatLibrary.getBootstrapTokenAmountForAmm(\n                    initParams.virtualEth, initParams.bootstrapEth, initParams.initialTokenMatch\n                );\n                /**\n                 * @dev if it's a first mint and pool is directly converting to AMM,\n                 * actual calculated token amount and real weth is used for liquidity calculation\n                 */\n                (vars.tokenAmount, vars.wethAmount) = (vars.actualTokenAmount, initParams.initialEth);\n            }\n        } else {\n            /**\n             * @dev This block is accessed after the presale period is over and the pool is converted to AMM\n             */\n            (uint256 wethReserve, uint256 tokenReserve) = pair.getReserves();\n            uint256 tokenAmountOptimal = GoatLibrary.quote(wethDesired, wethReserve, tokenReserve);\n            if (tokenAmountOptimal <= tokenDesired) {\n                if (tokenAmountOptimal < tokenMin) {\n                    revert GoatErrors.InsufficientTokenAmount();\n                }\n                (vars.tokenAmount, vars.wethAmount) = (tokenAmountOptimal, wethDesired);\n            } else {\n                uint256 wethAmountOptimal = GoatLibrary.quote(tokenDesired, tokenReserve, wethReserve);\n                assert(wethAmountOptimal <= wethDesired);\n                if (wethAmountOptimal < wethMin) revert GoatErrors.InsufficientWethAmount();\n                (vars.tokenAmount, vars.wethAmount) = (tokenDesired, wethAmountOptimal);\n            }\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.isNewPair);\n    }\n\n    function _ensurePoolAndPrepareLiqudityParameters(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams,\n        bool isEth\n    ) internal returns (GoatTypes.LocalVariables_AddLiquidity memory vars) {\n        if (token == WETH || token == address(0)) {\n            revert GoatErrors.WrongToken();\n        }\n        vars.token = token;\n        (vars.tokenAmount, vars.wethAmount, vars.isNewPair) =\n            _addLiquidity(token, tokenDesired, wethDesired, tokenMin, wethMin, initParams);\n\n        if (vars.isNewPair) {\n            // only for the first time\n            vars.wethAmount = Math.min(initParams.initialEth, initParams.bootstrapEth);\n            vars.actualTokenAmount = GoatLibrary.getActualBootstrapTokenAmount(\n                initParams.virtualEth, initParams.bootstrapEth, vars.wethAmount, initParams.initialTokenMatch\n            );\n        } else {\n            vars.actualTokenAmount = vars.tokenAmount;\n        }\n        if (isEth && wethDesired != vars.wethAmount) {\n            revert GoatErrors.InvalidEthAmount();\n        }\n        vars.pair = GoatV1Factory(FACTORY).getPool(vars.token);\n    }\n\n    function _getAmountTokenOut(uint256 amountIn, uint256 amountOutMin, address token)\n        internal\n        view\n        returns (uint256 amountTokenOut, GoatV1Pair pair)\n    {\n        if (amountIn == 0) {\n            revert GoatErrors.InsufficientInputAmount();\n        }\n        GoatTypes.LocalVariables_PairStateInfo memory vars;\n        pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        if (pair.vestingUntil() != MAX_UINT32) {\n            /**\n             * @dev If pool is not in presale period, then it's in AMM mode\n             * Normal amountOut calculation is done with real reserves\n             */\n            (uint112 reserveEth, uint112 reserveToken) = pair.getStateInfoAmm();\n            amountTokenOut = GoatLibrary.getTokenAmountOutAmm(amountIn, reserveEth, reserveToken);\n        } else {\n            /**\n             * @dev If pool is in presale period,\n             * amountOut calculation is done with inflated reserves and initParams\n             */\n            (\n                vars.reserveEth,\n                vars.reserveToken,\n                vars.virtualEth,\n                vars.initialTokenMatch,\n                vars.bootstrapEth,\n                vars.virtualToken\n            ) = pair.getStateInfoForPresale();\n\n            uint256 tokenAmountForAmm =\n                GoatLibrary.getBootstrapTokenAmountForAmm(vars.virtualEth, vars.bootstrapEth, vars.initialTokenMatch);\n            amountTokenOut = GoatLibrary.getTokenAmountOutPresale(\n                amountIn,\n                vars.virtualEth,\n                vars.reserveEth,\n                vars.bootstrapEth,\n                vars.reserveToken,\n                vars.virtualToken,\n                tokenAmountForAmm\n            );\n        }\n        if (amountTokenOut < amountOutMin) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n    }\n}"
    },
    {
      "filename": "goat-trading/contracts/periphery/GoatRouterV1.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// library imports\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n// local imports\nimport {GoatTypes} from \"../library/GoatTypes.sol\";\nimport {GoatV1Factory} from \"../exchange/GoatV1Factory.sol\";\nimport {GoatV1Pair} from \"../exchange/GoatV1Pair.sol\";\nimport {GoatErrors} from \"../library/GoatErrors.sol\";\nimport {GoatLibrary} from \"../library/GoatLibrary.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\n\n/**\n * @title Goat V1 Router\n * @notice Router for stateless execution of swaps and liquidity provision\n * @dev This contract is used for adding/removing liquidity, swapping tokens and withdrawing fees\n * @dev This contract is stateless and does not store any data\n * @author Goat Trading -- Chiranjibi Poudyal, Robert M.C. Forster\n */\ncontract GoatV1Router is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address public immutable FACTORY;\n    address public immutable WETH;\n    uint32 private constant MAX_UINT32 = type(uint32).max;\n    uint8 private constant ZERO = 0;\n\n    modifier ensure(uint256 deadline) {\n        if (block.timestamp > deadline) {\n            revert GoatErrors.Expired();\n        }\n        _;\n    }\n\n    constructor(address factory, address weth) {\n        FACTORY = factory;\n        WETH = weth;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n\n    function addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external nonReentrant ensure(deadline) returns (uint256, uint256, uint256) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars = _ensurePoolAndPrepareLiqudityParameters(\n            token, tokenDesired, wethDesired, tokenMin, wethMin, initParams, false\n        );\n\n        IERC20(vars.token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n        if (vars.wethAmount != 0) {\n            IERC20(WETH).safeTransferFrom(msg.sender, vars.pair, vars.wethAmount);\n        }\n        vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n        if (vars.isNewPair) {\n            vars.wethAmount =\n                initParams.bootstrapEth == initParams.initialEth ? initParams.initialEth : initParams.virtualEth;\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.liquidity);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 tokenDesired,\n        uint256 tokenMin,\n        uint256 ethMin,\n        address to,\n        uint256 deadline,\n        GoatTypes.InitParams memory initParams\n    ) external payable ensure(deadline) returns (uint256, uint256, uint256) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars =\n            _ensurePoolAndPrepareLiqudityParameters(token, tokenDesired, msg.value, tokenMin, ethMin, initParams, true);\n        IERC20(token).safeTransferFrom(msg.sender, vars.pair, vars.actualTokenAmount);\n        if (vars.wethAmount != 0) {\n            IWETH(WETH).deposit{value: vars.wethAmount}();\n            IERC20(WETH).safeTransfer(vars.pair, vars.wethAmount);\n        }\n\n        vars.liquidity = GoatV1Pair(vars.pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > vars.wethAmount) {\n            (bool success,) = payable(msg.sender).call{value: msg.value - vars.wethAmount}(\"\");\n            if (!success) {\n                revert GoatErrors.EthTransferFailed();\n            }\n        }\n\n        if (vars.isNewPair) {\n            vars.wethAmount =\n                initParams.bootstrapEth == initParams.initialEth ? initParams.initialEth : initParams.virtualEth;\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.liquidity);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address token,\n        uint256 liquidity,\n        uint256 tokenMin,\n        uint256 wethMin,\n        address to,\n        uint256 deadline\n    ) public nonReentrant ensure(deadline) returns (uint256 amountWeth, uint256 amountToken) {\n        address pair = GoatV1Factory(FACTORY).getPool(token);\n\n        IERC20(pair).safeTransferFrom(msg.sender, pair, liquidity);\n        (amountWeth, amountToken) = GoatV1Pair(pair).burn(to);\n        if (amountWeth < wethMin) {\n            revert GoatErrors.InsufficientWethAmount();\n        }\n        if (amountToken < tokenMin) {\n            revert GoatErrors.InsufficientTokenAmount();\n        }\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 tokenMin,\n        uint256 ethMin,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256 amountWeth, uint256 amountToken) {\n        (amountWeth, amountToken) = removeLiquidity(token, liquidity, tokenMin, ethMin, address(this), deadline);\n        IERC20(token).safeTransfer(to, amountToken);\n        IWETH(WETH).withdraw(amountWeth);\n        (bool success,) = to.call{value: amountWeth}(\"\");\n        if (!success) {\n            revert GoatErrors.EthTransferFailed();\n        }\n    }\n\n    /* ----------------------------- SWAP FUNCTIONS ----------------------------- */\n    function swapWethForExactTokens(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        external\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountTokenOut)\n    {\n        GoatV1Pair pair;\n        (amountTokenOut, pair) = _getAmountTokenOut(amountIn, amountOutMin, token);\n        IERC20(WETH).safeTransferFrom(msg.sender, address(pair), amountIn);\n        pair.swap(amountTokenOut, ZERO, to);\n    }\n\n    function swapExactETHForTokens(uint256 amountOutMin, address token, address to, uint256 deadline)\n        external\n        payable\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountTokenOut)\n    {\n        GoatV1Pair pair;\n        (amountTokenOut, pair) = _getAmountTokenOut(msg.value, amountOutMin, token);\n        IWETH(WETH).deposit{value: msg.value}();\n        IERC20(WETH).safeTransfer(address(pair), msg.value);\n        pair.swap(amountTokenOut, 0, to);\n    }\n\n    function swapExactTokensForWeth(uint256 amountIn, uint256 amountOutMin, address token, address to, uint256 deadline)\n        public\n        ensure(deadline)\n        nonReentrant\n        returns (uint256 amountWethOut)\n    {\n        if (amountIn == 0) {\n            revert GoatErrors.InsufficientInputAmount();\n        }\n\n        GoatTypes.LocalVariables_PairStateInfo memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (pair == GoatV1Pair(address(0))) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        if (pair.vestingUntil() != type(uint32).max) {\n            (uint112 reserveEth, uint112 reserveToken) = pair.getStateInfoAmm();\n            amountWethOut = GoatLibrary.getWethAmountOutAmm(amountIn, reserveEth, reserveToken);\n        } else {\n            (vars.reserveEth, vars.reserveToken, vars.virtualEth,,, vars.virtualToken) = pair.getStateInfoForPresale();\n\n            amountWethOut = GoatLibrary.getWethAmountOutPresale(\n                amountIn, vars.reserveEth, vars.reserveToken, vars.virtualEth, vars.virtualToken\n            );\n        }\n\n        if (amountWethOut < amountOutMin) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n        IERC20(token).safeTransferFrom(msg.sender, address(pair), amountIn);\n        pair.swap(0, amountWethOut, to);\n    }\n\n    /* ------------------------------ WITHDRAW FEES ----------------------------- */\n    function withdrawFees(address token, address to) external nonReentrant {\n        if (to == address(0)) {\n            revert GoatErrors.ZeroAddress();\n        }\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n\n        if (address(pair) == address(0)) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        pair.withdrawFees(to);\n    }\n\n    /* ----------------------------- PUBLIC VIEW FUNCTIONS ----------------------------- */\n\n    function getActualBootstrapTokenAmount(\n        uint256 virtualEth,\n        uint256 bootstrapEth,\n        uint256 initialEth,\n        uint256 initialTokenMatch\n    ) public pure returns (uint256 actualTokenAmount) {\n        return GoatLibrary.getActualBootstrapTokenAmount(virtualEth, bootstrapEth, initialEth, initialTokenMatch);\n    }\n\n    /* --------------------------- INTERNAL FUNCTIONS --------------------------- */\n    function _addLiquidity(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams\n    ) internal returns (uint256, uint256, bool) {\n        GoatTypes.LocalVariables_AddLiquidity memory vars;\n        GoatV1Pair pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            // First time liquidity provider\n            pair = GoatV1Pair(GoatV1Factory(FACTORY).createPair(token, initParams));\n            vars.isNewPair = true;\n        }\n\n        if (vars.isNewPair) {\n            if (initParams.initialEth < initParams.bootstrapEth) {\n                /**\n                 * @dev if it's a first mint and pool is not directly converting to AMM,\n                 * initialTokenMatch and virtualEth is used for liquidity calculation\n                 */\n                (vars.tokenAmount, vars.wethAmount) = (initParams.initialTokenMatch, initParams.virtualEth);\n            } else {\n                vars.actualTokenAmount = GoatLibrary.getBootstrapTokenAmountForAmm(\n                    initParams.virtualEth, initParams.bootstrapEth, initParams.initialTokenMatch\n                );\n                /**\n                 * @dev if it's a first mint and pool is directly converting to AMM,\n                 * actual calculated token amount and real weth is used for liquidity calculation\n                 */\n                (vars.tokenAmount, vars.wethAmount) = (vars.actualTokenAmount, initParams.initialEth);\n            }\n        } else {\n            /**\n             * @dev This block is accessed after the presale period is over and the pool is converted to AMM\n             */\n            (uint256 wethReserve, uint256 tokenReserve) = pair.getReserves();\n            uint256 tokenAmountOptimal = GoatLibrary.quote(wethDesired, wethReserve, tokenReserve);\n            if (tokenAmountOptimal <= tokenDesired) {\n                if (tokenAmountOptimal < tokenMin) {\n                    revert GoatErrors.InsufficientTokenAmount();\n                }\n                (vars.tokenAmount, vars.wethAmount) = (tokenAmountOptimal, wethDesired);\n            } else {\n                uint256 wethAmountOptimal = GoatLibrary.quote(tokenDesired, tokenReserve, wethReserve);\n                assert(wethAmountOptimal <= wethDesired);\n                if (wethAmountOptimal < wethMin) revert GoatErrors.InsufficientWethAmount();\n                (vars.tokenAmount, vars.wethAmount) = (tokenDesired, wethAmountOptimal);\n            }\n        }\n        return (vars.tokenAmount, vars.wethAmount, vars.isNewPair);\n    }\n\n    function _ensurePoolAndPrepareLiqudityParameters(\n        address token,\n        uint256 tokenDesired,\n        uint256 wethDesired,\n        uint256 tokenMin,\n        uint256 wethMin,\n        GoatTypes.InitParams memory initParams,\n        bool isEth\n    ) internal returns (GoatTypes.LocalVariables_AddLiquidity memory vars) {\n        if (token == WETH || token == address(0)) {\n            revert GoatErrors.WrongToken();\n        }\n        vars.token = token;\n        (vars.tokenAmount, vars.wethAmount, vars.isNewPair) =\n            _addLiquidity(token, tokenDesired, wethDesired, tokenMin, wethMin, initParams);\n\n        if (vars.isNewPair) {\n            // only for the first time\n            vars.wethAmount = Math.min(initParams.initialEth, initParams.bootstrapEth);\n            vars.actualTokenAmount = GoatLibrary.getActualBootstrapTokenAmount(\n                initParams.virtualEth, initParams.bootstrapEth, vars.wethAmount, initParams.initialTokenMatch\n            );\n        } else {\n            vars.actualTokenAmount = vars.tokenAmount;\n        }\n        if (isEth && wethDesired != vars.wethAmount) {\n            revert GoatErrors.InvalidEthAmount();\n        }\n        vars.pair = GoatV1Factory(FACTORY).getPool(vars.token);\n    }\n\n    function _getAmountTokenOut(uint256 amountIn, uint256 amountOutMin, address token)\n        internal\n        view\n        returns (uint256 amountTokenOut, GoatV1Pair pair)\n    {\n        if (amountIn == 0) {\n            revert GoatErrors.InsufficientInputAmount();\n        }\n        GoatTypes.LocalVariables_PairStateInfo memory vars;\n        pair = GoatV1Pair(GoatV1Factory(FACTORY).getPool(token));\n        if (address(pair) == address(0)) {\n            revert GoatErrors.GoatPoolDoesNotExist();\n        }\n        if (pair.vestingUntil() != MAX_UINT32) {\n            /**\n             * @dev If pool is not in presale period, then it's in AMM mode\n             * Normal amountOut calculation is done with real reserves\n             */\n            (uint112 reserveEth, uint112 reserveToken) = pair.getStateInfoAmm();\n            amountTokenOut = GoatLibrary.getTokenAmountOutAmm(amountIn, reserveEth, reserveToken);\n        } else {\n            /**\n             * @dev If pool is in presale period,\n             * amountOut calculation is done with inflated reserves and initParams\n             */\n            (\n                vars.reserveEth,\n                vars.reserveToken,\n                vars.virtualEth,\n                vars.initialTokenMatch,\n                vars.bootstrapEth,\n                vars.virtualToken\n            ) = pair.getStateInfoForPresale();\n\n            uint256 tokenAmountForAmm =\n                GoatLibrary.getBootstrapTokenAmountForAmm(vars.virtualEth, vars.bootstrapEth, vars.initialTokenMatch);\n            amountTokenOut = GoatLibrary.getTokenAmountOutPresale(\n                amountIn,\n                vars.virtualEth,\n                vars.reserveEth,\n                vars.bootstrapEth,\n                vars.reserveToken,\n                vars.virtualToken,\n                tokenAmountForAmm\n            );\n        }\n        if (amountTokenOut < amountOutMin) {\n            revert GoatErrors.InsufficientAmountOut();\n        }\n    }\n}"
    }
  ]
}