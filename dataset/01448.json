{
  "Title": "M-1: `emergency_shutdown` role is not enough for emergency shutdown.",
  "Content": "# Issue M-1: `emergency_shutdown` role is not enough for emergency shutdown. \n\nSource: https://github.com/sherlock-audit/2023-08-cooler-judging/issues/1 \n\n## Found by \nthekmj, ubermensch\n\nThere are two protocol roles, `emergency_shutdown` and `cooler_overseer`. The `emergency_shutdown` should have the ability to shutdown the Clearinghouse.\n\nHowever, in the current contract, `emergency_shutdown` role does not have said ability. An address will need both `emergency_shutdown` and `cooler_overseer` to perform said action.\n\nWe have also confirmed with the protocol team that the two roles will be held by two different multisigs, with the shutdown multisig having a lower threshold and more holders. Thereby governance will not be able to act as quickly to emergencies than expected.\n\n## Vulnerability Detail\n\nLet's examine the function `emergencyShutdown()`:\n\n```solidity \nfunction emergencyShutdown() external onlyRole(\"emergency_shutdown\") {\n    active = false;\n\n    // If necessary, defund sDAI.\n    uint256 sdaiBalance = sdai.balanceOf(address(this));\n    if (sdaiBalance != 0) defund(sdai, sdaiBalance);\n\n    // If necessary, defund DAI.\n    uint256 daiBalance = dai.balanceOf(address(this));\n    if (daiBalance != 0) defund(dai, daiBalance);\n\n    emit Deactivated();\n}\n```\n\nThis has the modifier `onlyRole(\"emergency_shutdown\")`. However, this also calls function `defund()`, which has the modifier `onlyRole(\"cooler_overseer\")`\n\n```solidity\nfunction defund(ERC20 token_, uint256 amount_) public onlyRole(\"cooler_overseer\") {\n```\n\nTherefore, the role `emergency_shutdown` will not have the ability to shutdown the protocol, unless it also has the overseer role.\n\n### Proof of concept\n\nTo get a coded PoC, make the following modifications to the test case:\n- In `Clearinghouse.t.sol`, comment out line 125 (so that `overseer` only has `emergency_shutdown` role)\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/test/Clearinghouse.t.sol#L125\n\n```solidity\n//rolesAdmin.grantRole(\"cooler_overseer\", overseer);\nrolesAdmin.grantRole(\"emergency_shutdown\", overseer);\n```\n\n- Run the following test command (to just run a single test `test_emergencyShutdown()`):\n```sh\nforge test --match-test test_emergencyShutdown\n```\n\nThe test will fail with the `ROLES_RequireRole()` error.\n## Impact\n\n`emergency_shutdown` role cannot emergency shutdown the protocol\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Clearinghouse.sol#L339\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Clearinghouse.sol#L360-L372\n\n## Tool used\n\nManual Review, Foundry/Forge\n\n## Recommendation\n\nThere are two ways to mitigate this issue:\n- Separate the logic for emergency shutdown and defunding. i.e. do not defund when emergency shutdown, but rather defund separately after shutdown. \n- Move the defunding logic to a separate internal function, so that emergency shutdown function can directly call defunding without going through a modifier.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because it can be considered low as roles can be given again and there is no loss of funds\n\n\n\n**0xRusowsky**\n\nfair point, but it still should be low as a user can have several roles\n\n**Oot2k**\n\nI have to disagree, a user can indeed have several roles, but that can not be ensured/ if there are two separate roles they should be considered separate. \n\n\n**ohmzeus**\n\nFix: https://github.com/ohmzeus/Cooler/pull/50\n\n**jkoppel**\n\nFix confirmed.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/107",
  "Code": [
    {
      "filename": "Cooler/src/test/Clearinghouse.t.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {console2 as console} from \"forge-std/console2.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\n\nimport {MockOhm} from \"test/mocks/MockOhm.sol\";\nimport {MockStaking} from \"test/mocks/MockStaking.sol\";\nimport {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {MockERC4626} from \"solmate/test/utils/mocks/MockERC4626.sol\";\n\nimport {Permissions, Keycode, fromKeycode, toKeycode} from \"olympus-v3/Kernel.sol\";\nimport {RolesAdmin, Kernel, Actions} from \"olympus-v3/policies/RolesAdmin.sol\";\nimport {OlympusRoles, ROLESv1} from \"olympus-v3/modules/ROLES/OlympusRoles.sol\";\nimport {OlympusMinter, MINTRv1} from \"olympus-v3/modules/MINTR/OlympusMinter.sol\";\nimport {OlympusTreasury, TRSRYv1} from \"olympus-v3/modules/TRSRY/OlympusTreasury.sol\";\n\nimport {Clearinghouse, Cooler, CoolerFactory, CoolerCallback} from \"src/Clearinghouse.sol\";\n\n// Tests for Clearinghouse\n//\n// Clearinghouse Setup and Permissions.\n// [X] configureDependencies\n// [X] requestPermissions\n//\n// Clearinghouse Functions\n// [X] rebalance\n//     [X] can't if the contract is deactivated.\n//     [X] can't rebalance faster than the funding cadence.\n//     [X] Treasury approvals for the clearing house are correct.\n//     [X] if necessary, sends excess DSR funds back to the Treasury.\n//     [X] if a rebalances are missed, can execute several rebalances if FUND_CADENCE allows it.\n// [X] sweepIntoDSR\n//     [X] excess DAI is deposited into DSR.\n// [X] defund\n//     [X] only \"cooler_overseer\" can call.\n//     [X] cannot defund gOHM.\n//     [X] sends input ERC20 token back to the Treasury.\n// [X] emergencyShutdown\n//     [X] only \"emergency_shutdown\" can call.\n//     [X] deactivates and defunds.\n// [X] restartAfterShutdown\n//     [X] only \"cooler_overseer\" can call.\n//     [X] reactivates.\n// [X] lendToCooler\n//     [X] only lend to coolers issued by coolerFactory.\n//     [X] only collateral = gOHM + only debt = DAI.\n//     [x] user and cooler new gOHM balances are correct.\n//     [x] user and cooler new DAI balances are correct.\n// [X] rollLoan\n//     [X] only roll coolers issued by coolerFactory.\n//     [X] roll by adding more collateral.\n//     [X] roll by paying the interest.\n//     [X] user and cooler new gOHM balances are correct.\n// [X] onRepay\n//     [X] only coolers issued by coolerFactory can call.\n//     [X] receivables are updated.\n// [X] claimDefaulted\n//     [X] only coolers issued by coolerFactory can call.\n//     [X] receivables are updated.\n//     [X] OHM supply is properly burnt.\n\n/// @dev Although there is sDAI in the treasury, the sDAI will be equal to\n///      DAI values everytime we convert between them. This is because no external\n///      DAI is being added to the sDAI vault, so the exchange rate is 1:1. This\n///      does not cause any issues with our testing.\ncontract ClearinghouseTest is Test {\n    MockOhm internal ohm;\n    MockERC20 internal gohm;\n    MockERC20 internal dai;\n    MockERC4626 internal sdai;\n\n    Kernel public kernel;\n    OlympusRoles internal ROLES;\n    OlympusMinter internal MINTR;\n    OlympusTreasury internal TRSRY;\n    RolesAdmin internal rolesAdmin;\n    Clearinghouse internal clearinghouse;\n    CoolerFactory internal factory;\n    Cooler internal testCooler;\n\n    address internal user;\n    address internal others;\n    address internal overseer;\n    uint256 internal initialSDai;\n\n    function setUp() public {\n        address[] memory users = (new UserFactory()).create(3);\n        user = users[0];\n        others = users[1];\n        overseer = users[2];\n\n        MockStaking staking = new MockStaking();\n        factory = new CoolerFactory();\n\n        ohm = new MockOhm(\"olympus\", \"OHM\", 9);\n        gohm = new MockERC20(\"olympus\", \"gOHM\", 18);\n        dai = new MockERC20(\"dai\", \"DAI\", 18);\n        sdai = new MockERC4626(dai, \"sDai\", \"sDAI\");\n\n        kernel = new Kernel(); // this contract will be the executor\n\n        TRSRY = new OlympusTreasury(kernel);\n        MINTR = new OlympusMinter(kernel, address(ohm));\n        ROLES = new OlympusRoles(kernel);\n\n        clearinghouse = new Clearinghouse(\n            address(gohm),\n            address(staking),\n            address(sdai),\n            address(factory),\n            address(kernel)\n        );\n        rolesAdmin = new RolesAdmin(kernel);\n\n        kernel.executeAction(Actions.InstallModule, address(TRSRY));\n        kernel.executeAction(Actions.InstallModule, address(MINTR));\n        kernel.executeAction(Actions.InstallModule, address(ROLES));\n\n        kernel.executeAction(Actions.ActivatePolicy, address(clearinghouse));\n        kernel.executeAction(Actions.ActivatePolicy, address(rolesAdmin));\n\n        /// Configure access control\n        rolesAdmin.grantRole(\"cooler_overseer\", overseer);\n        rolesAdmin.grantRole(\"emergency_shutdown\", overseer);\n\n        // Setup clearinghouse initial conditions\n        uint mintAmount = 200_000_000e18; // Init treasury with 200 million\n        dai.mint(address(TRSRY), mintAmount);\n        // Deposit all reserves into the DSR\n        vm.startPrank(address(TRSRY));\n        dai.approve(address(sdai), mintAmount);\n        sdai.deposit(mintAmount, address(TRSRY));\n        vm.stopPrank();\n\n        // Initial rebalance to fund the clearinghouse\n        clearinghouse.rebalance();\n\n        testCooler = Cooler(factory.generateCooler(gohm, dai));\n\n        // Skip 1 week ahead to allow rebalances\n        skip(1 weeks);\n\n        // Initial funding of clearinghouse is equal to FUND_AMOUNT\n        assertEq(sdai.maxWithdraw(address(clearinghouse)), clearinghouse.FUND_AMOUNT());\n\n        // Fund others so that TRSRY is not the only with sDAI shares\n        dai.mint(others, mintAmount * 33);\n        vm.startPrank(others);\n        dai.approve(address(sdai), mintAmount * 33);\n        sdai.deposit(mintAmount * 33, others);\n        vm.stopPrank();\n    }\n\n    // --- HELPER FUNCTIONS ----------------------------------------------\n\n    function _fundUser(uint256 gohmAmount_) internal {\n        // Mint gOHM\n        gohm.mint(user, gohmAmount_);\n        // Approve clearinghouse\n        vm.prank(user);\n        gohm.approve(address(clearinghouse), gohmAmount_);\n    }\n\n    function _createLoanForUser(\n        uint256 loanAmount_\n    ) internal returns (Cooler cooler, uint256 gohmNeeded, uint256 loanID) {\n        // Create the Cooler\n        vm.prank(user);\n        cooler = Cooler(factory.generateCooler(gohm, dai));\n\n        // Ensure user has enough collateral\n        gohmNeeded = cooler.collateralFor(loanAmount_, clearinghouse.LOAN_TO_COLLATERAL());\n        _fundUser(gohmNeeded);\n\n        vm.prank(user);\n        loanID = clearinghouse.lendToCooler(cooler, loanAmount_);\n    }\n\n    function _skip(uint256 seconds_) internal {\n        vm.warp(block.timestamp + seconds_);\n        if (block.timestamp >= clearinghouse.fundTime()) {\n            clearinghouse.rebalance();\n        }\n    }\n\n    // --- SETUP, DEPENDENCIES, AND PERMISSIONS --------------------------\n\n    function test_configureDependencies() public {\n        Keycode[] memory expectedDeps = new Keycode[](3);\n        expectedDeps[0] = toKeycode(\"TRSRY\");\n        expectedDeps[1] = toKeycode(\"MINTR\");\n        expectedDeps[2] = toKeycode(\"ROLES\");\n\n        Keycode[] memory deps = clearinghouse.configureDependencies();\n        // Check: configured dependencies storage\n        assertEq(deps.length, expectedDeps.length);\n        assertEq(fromKeycode(deps[0]), fromKeycode(expectedDeps[0]));\n        assertEq(fromKeycode(deps[1]), fromKeycode(expectedDeps[1]));\n        assertEq(fromKeycode(deps[2]), fromKeycode(expectedDeps[2]));\n    }\n\n    function test_requestPermissions() public {\n        Permissions[] memory expectedPerms = new Permissions[](4);\n        Keycode TRSRY_KEYCODE = toKeycode(\"TRSRY\");\n        Keycode MINTR_KEYCODE = toKeycode(\"MINTR\");\n        expectedPerms[0] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n        expectedPerms[1] = Permissions(TRSRY_KEYCODE, TRSRY.increaseWithdrawApproval.selector);\n        expectedPerms[2] = Permissions(TRSRY_KEYCODE, TRSRY.withdrawReserves.selector);\n        expectedPerms[3] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n\n        Permissions[] memory perms = clearinghouse.requestPermissions();\n        // Check: permission storage\n        assertEq(perms.length, expectedPerms.length);\n        for (uint256 i = 0; i < perms.length; i++) {\n            assertEq(fromKeycode(perms[i].keycode), fromKeycode(expectedPerms[i].keycode));\n            assertEq(perms[i].funcSelector, expectedPerms[i].funcSelector);\n        }\n    }\n\n    // --- LEND TO COOLER ------------------------------------------------\n\n    function testRevert_lendToCooler_NotFromFactory() public {\n        CoolerFactory maliciousFactory = new CoolerFactory();\n        Cooler maliciousCooler = Cooler(maliciousFactory.generateCooler(gohm, dai));\n        // Coolers not created by the CoolerFactory could be malicious.\n        vm.prank(address(maliciousCooler));\n        vm.expectRevert(CoolerCallback.OnlyFromFactory.selector);\n        clearinghouse.lendToCooler(maliciousCooler, 1e18);\n    }\n\n    function testRevert_lendToCooler_NotGohmDai() public {\n        MockERC20 wagmi = new MockERC20(\"wagmi\", \"WAGMI\", 18);\n        MockERC20 ngmi = new MockERC20(\"ngmi\", \"NGMI\", 18);\n\n        // Clearinghouse only accepts gOHM-DAI\n        Cooler badCooler1 = Cooler(factory.generateCooler(wagmi, ngmi));\n        vm.expectRevert(Clearinghouse.BadEscrow.selector);\n        clearinghouse.lendToCooler(badCooler1, 1e18);\n        // Clearinghouse only accepts gOHM-DAI\n        Cooler badCooler2 = Cooler(factory.generateCooler(gohm, ngmi));\n        vm.expectRevert(Clearinghouse.BadEscrow.selector);\n        clearinghouse.lendToCooler(badCooler2, 1e18);\n        // Clearinghouse only accepts gOHM-DAI\n        Cooler badCooler3 = Cooler(factory.generateCooler(wagmi, dai));\n        vm.expectRevert(Clearinghouse.BadEscrow.selector);\n        clearinghouse.lendToCooler(badCooler3, 1e18);\n    }\n\n    function testFuzz_lendToCooler(uint256 loanAmount_) public {\n        // Loan amount cannot exceed Clearinghouse funding\n        loanAmount_ = bound(loanAmount_, 0, clearinghouse.FUND_AMOUNT());\n\n        (Cooler cooler, uint256 gohmNeeded, uint256 loanID) = _createLoanForUser(loanAmount_);\n\n        // Check: balances\n        assertEq(gohm.balanceOf(address(cooler)), gohmNeeded);\n        assertEq(dai.balanceOf(address(user)), loanAmount_);\n        assertEq(dai.balanceOf(address(cooler)), 0);\n        // Check: clearinghouse storage\n        assertEq(clearinghouse.receivables(), clearinghouse.debtForCollateral(gohmNeeded));\n        assertApproxEqAbs(clearinghouse.receivables(), cooler.getLoan(loanID).amount, 1e4);\n    }\n\n    // --- ROLL LOAN -----------------------------------------------------\n\n    function testFuzz_rollLoan_pledgingExtraCollateral(uint256 loanAmount_) public {\n        // Loan amount cannot exceed Clearinghouse funding\n        loanAmount_ = bound(loanAmount_, 0, clearinghouse.FUND_AMOUNT());\n\n        (Cooler cooler, uint256 gohmNeeded, uint256 loanID) = _createLoanForUser(loanAmount_);\n        Cooler.Loan memory initLoan = cooler.getLoan(loanID);\n\n        // Move forward to half duration of the loan\n        _skip(clearinghouse.DURATION() / 2);\n\n        // Cache DAI balance and extra interest to be paid\n        uint256 initDaiUser = dai.balanceOf(user);\n        uint256 initReceivables = clearinghouse.receivables();\n        uint256 interestExtra = cooler.interestFor(\n            initLoan.amount,\n            clearinghouse.INTEREST_RATE(),\n            clearinghouse.DURATION()\n        );\n        // Ensure user has enough collateral to roll the loan\n        uint256 gohmExtra = cooler.newCollateralFor(loanID);\n        _fundUser(gohmExtra);\n        // Roll loan\n        vm.prank(user);\n        clearinghouse.rollLoan(cooler, loanID);\n\n        Cooler.Loan memory newLoan = cooler.getLoan(loanID);\n\n        // Check: balances\n        assertEq(gohm.balanceOf(address(cooler)), gohmNeeded + gohmExtra);\n        assertEq(dai.balanceOf(user), initDaiUser);\n        // Check: cooler storage\n        assertEq(newLoan.amount, initLoan.amount + interestExtra);\n        assertEq(newLoan.unclaimed, initLoan.unclaimed);\n        assertEq(newLoan.collateral, initLoan.collateral + gohmExtra);\n        assertEq(newLoan.expiry, initLoan.expiry + initLoan.request.duration);\n        // Check: clearinghouse storage\n        assertEq(clearinghouse.receivables(), initReceivables + interestExtra);\n    }\n\n    function testFuzz_rollLoan_repayingInterest(uint256 loanAmount_) public {\n        // Loan amount cannot exceed Clearinghouse funding\n        // Loan amount must exceed 0.0001 gOHM, so that repaying the interest decollaterizes de loan.\n        loanAmount_ = bound(loanAmount_, 1e14, clearinghouse.FUND_AMOUNT());\n\n        (Cooler cooler, uint256 gohmNeeded, uint256 loanID) = _createLoanForUser(loanAmount_);\n        Cooler.Loan memory initLoan = cooler.getLoan(loanID);\n\n        // Move forward to half duration of the loan\n        _skip(clearinghouse.DURATION() / 2);\n\n        vm.startPrank(user);\n        // Cache DAI balance and extra interest to be paid in the future\n        uint256 initDaiUser = dai.balanceOf(user);\n        uint256 initReceivables = clearinghouse.receivables();\n        // Repay the interest of the loan (interest = owed debt - borrowed amount)\n        uint256 repay = initLoan.amount - initLoan.request.amount;\n        dai.approve(address(cooler), repay);\n        uint256 decollateralized = cooler.repayLoan(loanID, repay);\n        // Roll loan\n        gohm.approve(address(clearinghouse), decollateralized);\n        clearinghouse.rollLoan(cooler, loanID);\n        vm.stopPrank();\n\n        Cooler.Loan memory newLoan = cooler.getLoan(loanID);\n\n        // Check: balances\n        assertEq(gohm.balanceOf(address(cooler)), gohmNeeded);\n        assertEq(dai.balanceOf(user), initDaiUser - repay);\n        // Check: cooler storage\n        assertEq(newLoan.amount, initLoan.amount);\n        assertEq(newLoan.unclaimed, initLoan.unclaimed);\n        assertEq(newLoan.collateral, initLoan.collateral);\n        assertEq(newLoan.expiry, initLoan.expiry + initLoan.request.duration);\n        // Check: clearinghouse storage\n        assertEq(clearinghouse.receivables(), initReceivables);\n    }\n\n    function testRevert_rollLoan_NotFromFactory() public {\n        CoolerFactory maliciousFactory = new CoolerFactory();\n        Cooler maliciousCooler = Cooler(maliciousFactory.generateCooler(gohm, dai));\n\n        // Coolers not created by the CoolerFactory could be malicious.\n        vm.prank(others);\n        vm.expectRevert(CoolerCallback.OnlyFromFactory.selector);\n        clearinghouse.rollLoan(maliciousCooler, 0);\n    }\n\n    // --- REBALANCE TREASURY --------------------------------------------\n\n    function test_rebalance_pullFunds() public {\n        uint256 oneMillion = 1e24;\n        uint256 sdaiOneMillion = sdai.previewWithdraw(1e24);\n        uint256 daiInitCH = sdai.maxWithdraw(address(clearinghouse));\n        uint256 sdaiInitCH = sdai.balanceOf(address(clearinghouse));\n\n        // Burn 1 mil from clearinghouse to simulate assets being lent\n        vm.prank(address(clearinghouse));\n        sdai.withdraw(oneMillion, address(0x0), address(clearinghouse));\n\n        assertEq(\n            sdai.maxWithdraw(address(clearinghouse)),\n            daiInitCH - oneMillion,\n            \"init DAI balance CH\"\n        );\n        assertEq(\n            sdai.balanceOf(address(clearinghouse)),\n            sdaiInitCH - sdaiOneMillion,\n            \"init sDAI balance CH\"\n        );\n        assertEq(\n            TRSRY.reserveDebt(dai, address(clearinghouse)),\n            clearinghouse.FUND_AMOUNT(),\n            \"init DAI debt CH\"\n        );\n        // Test if clearinghouse pulls in 1 mil DAI from treasury\n        uint256 daiInitTRSRY = sdai.maxWithdraw(address(TRSRY));\n        uint256 sdaiInitTRSRY = sdai.balanceOf(address(TRSRY));\n\n        clearinghouse.rebalance();\n\n        assertEq(daiInitTRSRY - oneMillion, sdai.maxWithdraw(address(TRSRY)), \"DAI balance TRSRY\");\n        assertEq(\n            sdaiInitTRSRY - sdaiOneMillion,\n            sdai.balanceOf(address(TRSRY)),\n            \"sDAI balance TRSRY\"\n        );\n        assertEq(\n            clearinghouse.FUND_AMOUNT(),\n            sdai.maxWithdraw(address(clearinghouse)),\n            \"FUND_AMOUNT\"\n        );\n        assertEq(\n            clearinghouse.FUND_AMOUNT() + oneMillion,\n            TRSRY.reserveDebt(dai, address(clearinghouse)),\n            \"DAI debt CH\"\n        );\n    }\n\n    function test_rebalance_returnFunds() public {\n        uint256 oneMillion = 1e24;\n        uint256 sdaiOneMillion = sdai.previewWithdraw(1e24);\n        uint256 daiInitCH = sdai.maxWithdraw(address(clearinghouse));\n        uint256 sdaiInitCH = sdai.balanceOf(address(clearinghouse));\n\n        // Mint 1 million to clearinghouse and sweep to simulate assets being repaid\n        dai.mint(address(clearinghouse), oneMillion);\n        clearinghouse.sweepIntoDSR();\n\n        assertEq(\n            sdai.maxWithdraw(address(clearinghouse)),\n            daiInitCH + oneMillion,\n            \"init DAI balance CH\"\n        );\n        assertEq(\n            sdai.balanceOf(address(clearinghouse)),\n            sdaiInitCH + sdaiOneMillion,\n            \"init sDAI balance CH\"\n        );\n        assertEq(\n            TRSRY.reserveDebt(dai, address(clearinghouse)),\n            clearinghouse.FUND_AMOUNT(),\n            \"init DAI debt CH\"\n        );\n\n        uint256 daiInitTRSRY = sdai.maxWithdraw(address(TRSRY));\n        uint256 sdaiInitTRSRY = sdai.balanceOf(address(TRSRY));\n\n        clearinghouse.rebalance();\n\n        assertEq(daiInitTRSRY + oneMillion, sdai.maxWithdraw(address(TRSRY)), \"DAI balance TRSRY\");\n        assertEq(\n            sdaiInitTRSRY + sdaiOneMillion,\n            sdai.balanceOf(address(TRSRY)),\n            \"sDAI balance TRSRY\"\n        );\n        assertEq(\n            clearinghouse.FUND_AMOUNT(),\n            sdai.maxWithdraw(address(clearinghouse)),\n            \"FUND_AMOUNT\"\n        );\n        assertEq(\n            clearinghouse.FUND_AMOUNT() - oneMillion,\n            TRSRY.reserveDebt(dai, address(clearinghouse)),\n            \"DAI debt CH\"\n        );\n    }\n\n    function test_rebalance_deactivated_returnFunds() public {\n        vm.prank(overseer);\n        clearinghouse.emergencyShutdown();\n\n        // Simulate loan repayments\n        uint256 oneMillion = 1e24;\n        deal(address(sdai), address(clearinghouse), oneMillion);\n        uint256 sdaiInitTRSRY = sdai.balanceOf(address(TRSRY));\n        // Rebalances only defund when the contract is deactivated.\n        clearinghouse.rebalance();\n        assertEq(sdai.balanceOf(address(clearinghouse)), 0);\n        assertEq(sdai.balanceOf(address(TRSRY)), sdaiInitTRSRY + oneMillion);\n    }\n\n    function testRevert_rebalance_early() public {\n        bool canRebalance;\n        // Rebalance to be up-to-date with the FUND_CADENCE.\n        canRebalance = clearinghouse.rebalance();\n        assertEq(canRebalance, true);\n        // Second rebalance is ahead of time, and will not happen.\n        canRebalance = clearinghouse.rebalance();\n        assertEq(canRebalance, false);\n    }\n\n    // Should be able to rebalance multiple times if past due\n    function test_rebalance_pastDue() public {\n        // Already skipped 1 week ahead in setup. Do once more and call rebalance twice.\n        skip(2 weeks);\n        for (uint i; i < 3; i++) {\n            clearinghouse.rebalance();\n        }\n    }\n\n    // --- SWEEP INTO DSR ------------------------------------------------\n\n    function test_sweepIntoDSR() public {\n        uint256 sdaiBal = sdai.balanceOf(address(clearinghouse));\n\n        // Mint 1 million to clearinghouse and sweep to simulate assets being repaid\n        dai.mint(address(clearinghouse), 1e24);\n        clearinghouse.sweepIntoDSR();\n\n        assertEq(sdai.balanceOf(address(clearinghouse)), sdaiBal + 1e24);\n    }\n\n    // --- DEFUND CLEARINGHOUSE ------------------------------------------\n\n    function test_defund() public {\n        uint256 sdaiTrsryBal = sdai.balanceOf(address(TRSRY));\n        uint256 initDebtCH = TRSRY.reserveDebt(dai, address(clearinghouse));\n\n        vm.prank(overseer);\n        clearinghouse.defund(sdai, 1e24);\n        assertEq(sdai.balanceOf(address(TRSRY)), sdaiTrsryBal + 1e24);\n        assertEq(TRSRY.reserveDebt(dai, address(clearinghouse)), initDebtCH - sdai.previewRedeem(1e24));\n    }\n\n    function testRevert_defund_gohm() public {\n        vm.prank(overseer);\n        vm.expectRevert(Clearinghouse.OnlyBurnable.selector);\n        clearinghouse.defund(gohm, 1e24);\n    }\n\n    function testRevert_defund_onlyRole() public {\n        vm.prank(others);\n        vm.expectRevert();\n        clearinghouse.defund(gohm, 1e24);\n    }\n\n    // --- EMERGENCY SHUTDOWN CLEARINGHOUSE ------------------------------\n\n    function test_emergencyShutdown() public {\n        uint256 sdaiTrsryBal = sdai.balanceOf(address(TRSRY));\n        uint256 sdaiCHBal = sdai.balanceOf(address(clearinghouse));\n\n        vm.prank(overseer);\n        clearinghouse.emergencyShutdown();\n        assertEq(clearinghouse.active(), false);\n        assertEq(sdai.balanceOf(address(TRSRY)), sdaiTrsryBal + sdaiCHBal);\n    }\n\n    function testRevert_emergencyShutdown_onlyRole() public {\n        vm.prank(others);\n        vm.expectRevert();\n        clearinghouse.emergencyShutdown();\n    }\n\n    function test_reactivate() public {\n        vm.startPrank(overseer);\n        clearinghouse.emergencyShutdown();\n        assertEq(clearinghouse.active(), false);\n        clearinghouse.reactivate();\n        assertEq(clearinghouse.active(), true);\n        vm.stopPrank();\n    }\n\n    function testRevert_restartAfterShutdown_onlyRole() public {\n        vm.prank(others);\n        vm.expectRevert();\n        clearinghouse.reactivate();\n    }\n\n    // --- CALLBACKS: ON LOAN REPAYMENT ----------------------------------\n\n    function testFuzz_onRepay(uint256 loanAmount_) public {\n        // Loan amount cannot exceed Clearinghouse funding\n        // Loan amount must exceed 0.0001 gOHM, so that repaying the interest decollaterizes de loan.\n        loanAmount_ = bound(loanAmount_, 1e14, clearinghouse.FUND_AMOUNT());\n\n        (Cooler cooler, , uint256 loanID) = _createLoanForUser(loanAmount_);\n        Cooler.Loan memory initLoan = cooler.getLoan(loanID);\n\n        // Move forward to half duration of the loan\n        _skip(clearinghouse.DURATION() / 2);\n\n        vm.startPrank(user);\n        // Cache clearinghouse receivables\n        uint256 initReceivables = clearinghouse.receivables();\n        // Repay the interest of the loan (interest = owed debt - borrowed amount)\n        uint256 repay = initLoan.amount - initLoan.request.amount;\n        dai.approve(address(cooler), repay);\n        cooler.repayLoan(loanID, repay);\n\n        // Check: clearinghouse storage\n        assertEq(clearinghouse.receivables(), initReceivables - repay);\n        assertApproxEqAbs(clearinghouse.receivables(), cooler.getLoan(loanID).amount, 1e4);\n    }\n\n    function testRevert_onRepay_notFromFactory() public {\n        CoolerFactory maliciousFactory = new CoolerFactory();\n        Cooler maliciousCooler = Cooler(maliciousFactory.generateCooler(gohm, dai));\n        // Coolers not created by the CoolerFactory could be malicious.\n        vm.prank(address(maliciousCooler));\n        vm.expectRevert(CoolerCallback.OnlyFromFactory.selector);\n        clearinghouse.onRepay(0, 1e18);\n    }\n\n    // --- CLAIM DEFAULTED ----------------------------------\n\n    function testFuzz_claimDefaulted(uint256 loanAmount_, uint256 elapsedTime_) public {\n        // Loan amount cannot exceed Clearinghouse funding\n        // Loan amount must exceed 0.0001 gOHM, so that repaying the interest decollaterizes de loan.\n        loanAmount_ = bound(loanAmount_, 1e14, clearinghouse.FUND_AMOUNT() / 3);\n        elapsedTime_ = bound(elapsedTime_, 1, 2 ** 32);\n\n        (Cooler cooler1, uint256 gohmNeeded1, uint256 loanID1) = _createLoanForUser(loanAmount_);\n        (Cooler cooler2, uint256 gohmNeeded2, uint256 loanID2) = _createLoanForUser(loanAmount_ * 2);\n        Cooler.Loan memory initLoan1 = cooler1.getLoan(loanID1);\n        Cooler.Loan memory initLoan2 = cooler2.getLoan(loanID2);\n\n        // Move forward after both loans have ended\n        _skip(clearinghouse.DURATION() + elapsedTime_);\n\n        {\n        // Cache clearinghouse receivables and TRSRY debt\n        uint256 initReceivables = clearinghouse.receivables();\n        uint256 initDebt = TRSRY.reserveDebt(sdai, address(clearinghouse));\n\n        // Simulate unstaking outcome after defaults\n        ohm.mint(address(clearinghouse), gohmNeeded1 + gohmNeeded2);\n        {\n            uint256[] memory ids = new uint256[](2);\n            address[] memory coolers = new address[](2);\n            ids[0] = loanID1;\n            ids[1] = loanID2;\n            coolers[0] = address(cooler1);\n            coolers[1] = address(cooler2);\n\n            deal(address(gohm), others, 0);\n            // Claim defaulted loans\n            vm.prank(others);\n            clearinghouse.claimDefaulted(coolers, ids);\n        }\n        {\n            uint256 daiReceivables = initLoan1.amount + initLoan2.amount;\n            uint256 sdaiDebt = sdai.previewDeposit(\n                daiReceivables - clearinghouse.interestFromDebt(daiReceivables)\n            );\n            // Check: clearinghouse storage\n            assertEq(\n                clearinghouse.receivables(),\n                initReceivables > daiReceivables ? initReceivables - daiReceivables : 0\n            );\n            // Check: TRSRY storage\n            assertApproxEqAbs(\n                TRSRY.reserveDebt(sdai, address(clearinghouse)),\n                initDebt > sdaiDebt ? initDebt - sdaiDebt : 0,\n                1e4\n            );\n        }\n        }\n        {\n            uint256 keeperRewards = gohm.balanceOf(others);\n            // After defaults the clearing house keeps the collateral (which is supposed to be unstaked and burned)\n            assertEq(\n                gohm.balanceOf(address(clearinghouse)),\n                gohmNeeded1 + gohmNeeded2 - keeperRewards,\n                \"gOHM balance\"\n            );\n            // Check: OHM supply = keeper rewards (only minted before burning)\n            assertEq(ohm.totalSupply(), keeperRewards, \"OHM supply\");\n\n            {\n            uint256 maxAuctionReward1 = gohmNeeded1 * 5e16 / 1e18;\n            uint256 maxAuctionReward2 = gohmNeeded2 * 5e16 / 1e18;\n            uint256 maxRewards = (maxAuctionReward1 < clearinghouse.MAX_REWARD())\n                ? maxAuctionReward1\n                : clearinghouse.MAX_REWARD();\n            maxRewards = (maxAuctionReward2 < clearinghouse.MAX_REWARD())\n                ? maxRewards + maxAuctionReward2\n                : maxRewards + clearinghouse.MAX_REWARD();\n            // Check: keeper rewards can't exceed 5% of defaulted collateral\n            if (elapsedTime_ >= 7 days) {\n                assertApproxEqAbs(keeperRewards, maxRewards, 1e4, \"rewards <= 5% collat && MAX_REWARD\");\n            } else {\n                assertApproxEqAbs(\n                    keeperRewards,\n                    maxRewards * elapsedTime_ / 7 days,\n                    1e4,\n                    \"rewards <= auction\"\n                );\n            }\n            }\n        }\n    }\n\n    function testRevert_claimDefaulted_inputLengthDiscrepancy() public {\n        uint256[] memory ids = new uint256[](2);\n        address[] memory coolers = new address[](1);\n        ids[0] = 12345;\n        ids[1] = 67890;\n        coolers[0] = others;\n\n        vm.prank(overseer);\n        // Both input arrays must have the same length\n        vm.expectRevert(Clearinghouse.LengthDiscrepancy.selector);\n        clearinghouse.claimDefaulted(coolers, ids);\n    }\n\n    function testRevert_claimDefaulted_NotFromFactory() public {\n        CoolerFactory maliciousFactory = new CoolerFactory();\n        Cooler maliciousCooler = Cooler(maliciousFactory.generateCooler(gohm, dai));\n\n        uint256[] memory ids = new uint256[](1);\n        address[] memory coolers = new address[](1);\n        ids[0] = 12345;\n        coolers[0] = address(maliciousCooler);\n\n        // Coolers not created by the CoolerFactory could be malicious.\n        vm.prank(others);\n        vm.expectRevert(CoolerCallback.OnlyFromFactory.selector);\n        clearinghouse.claimDefaulted(coolers, ids);\n    }\n}"
    },
    {
      "filename": "Cooler/src/Clearinghouse.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {ROLESv1, RolesConsumer} from \"olympus-v3/modules/ROLES/OlympusRoles.sol\";\nimport {TRSRYv1} from \"olympus-v3/modules/TRSRY/TRSRY.v1.sol\";\nimport {MINTRv1} from \"olympus-v3/modules/MINTR/MINTR.v1.sol\";\nimport \"olympus-v3/Kernel.sol\";\n\nimport {IStaking} from \"interfaces/IStaking.sol\";\n\nimport {CoolerFactory, Cooler} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Olympus Clearinghouse.\n/// @notice Olympus Clearinghouse (Policy) Contract.\n/// @dev    The Olympus Clearinghouse is a lending facility built on top of Cooler Loans. The Clearinghouse\n///         ensures that OHM holders can take loans against their gOHM holdings according to the parameters\n///         approved by the community in OIP-144 and its subsequent RFCs. The Clearinghouse parameters are\n///         immutable, because of that, if backing was to increase substantially, a new governance process\n///         to fork this implementation with upgraded parameters should take place.\n///         Although the Cooler contracts allow lenders to transfer ownership of their repayment rights, the\n///         Clearinghouse doesn't implement any functions to use that feature.\ncontract Clearinghouse is Policy, RolesConsumer, CoolerCallback {\n\n    // --- ERRORS ----------------------------------------------------\n\n    error BadEscrow();\n    error DurationMaximum();\n    error OnlyBurnable();\n    error TooEarlyToFund();\n    error LengthDiscrepancy();\n\n    // --- EVENTS ----------------------------------------------------\n\n    event Deactivated();\n    event Reactivated();\n    \n    // --- RELEVANT CONTRACTS ----------------------------------------\n\n    ERC20 public immutable dai;             // Debt token\n    ERC4626 public immutable sdai;          // Idle DAI will wrapped into sDAI\n    ERC20 public immutable gOHM;            // Collateral token\n    IStaking public immutable staking;      // Necessary to unstake (and burn) OHM from defaults\n    \n    // --- MODULES ---------------------------------------------------\n\n    TRSRYv1 public TRSRY;      // Olympus V3 Treasury Module\n    MINTRv1 public MINTR;      // Olympus V3 Minter Module\n\n    // --- PARAMETER BOUNDS ------------------------------------------\n\n    uint256 public constant INTEREST_RATE = 5e15;               // 0.5% anually\n    uint256 public constant LOAN_TO_COLLATERAL = 3000e18;       // 3,000 DAI/gOHM\n    uint256 public constant DURATION = 121 days;                // Four months\n    uint256 public constant FUND_CADENCE = 7 days;              // One week\n    uint256 public constant FUND_AMOUNT = 18_000_000e18;        // 18 million\n    uint256 public constant MAX_REWARD = 1e17;                  // 0.1 gOHM\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice determines whether the contract can be funded or not.\n    bool public active;\n\n    /// @notice timestamp at which the next rebalance can occur.\n    uint256 public fundTime;\n\n    /// @notice outstanding loan receivables.\n    /// Incremented when a loan is taken or rolled.\n    /// Decremented when a loan is repaid or collateral is burned.\n    uint256 public receivables;\n\n    // --- INITIALIZATION --------------------------------------------\n\n    constructor(\n        address gohm_,\n        address staking_,\n        address sdai_,\n        address coolerFactory_,\n        address kernel_\n    ) Policy(Kernel(kernel_)) CoolerCallback(coolerFactory_) {\n        // Store the relevant contracts.\n        gOHM = ERC20(gohm_);\n        staking = IStaking(staking_);\n        sdai = ERC4626(sdai_);\n        dai = ERC20(sdai.asset());\n        \n        // Initialize the contract status and its funding schedule.\n        active = true;\n        fundTime = block.timestamp;\n    }\n\n    /// @notice Default framework setup. Configure dependencies for olympus-v3 modules.\n    /// @dev    This function will be called when the `executor` installs the Clearinghouse"
    }
  ]
}