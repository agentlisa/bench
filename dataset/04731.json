{
  "Title": "[M-03] Removing token from the whitelist may cause DoS due to limited USDC amount",
  "Content": "\nUsers won't be able to withdraw `USDC` tokens from `asdUSDC`.\n\n### Proof of Concept\n\nConsider a situation where we have two whitelisted `USDC` versions 1 and 2:\n\n```\n    usdcBalances[usdc1] = 1000\n    usdcBalances[usdc2] = 500\n    asdUSDC total supply = 1500\n```\n\nAfter some time, `asdUSDC` owner removes `usdc2` from the whitelist. It creates a situation where `1500` `asdUSDC` is only backed by `1000` `usdc1` tokens, since it's no longer possible to withdraw `usdc2`. \n\n<https://github.com/code-423n4/2024-03-canto/blob/main/contracts/asd/asdUSDC.sol#L52>\n\n```solidity\n    function withdraw(address _usdcVersion, uint256 _amount) external returns (uint256) {\n        // check whitelist\n>>      require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n        // burn tokens\n        _burn(msg.sender, _amount);\n        // calculate amount to withdraw\n        uint256 amountToWithdraw = _amount / (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        // check balance\n        require(usdcBalances[_usdcVersion] >= amountToWithdraw, \"ASDUSDC: Not enough USDC balance\");\n        // transfer USDC\n        usdcBalances[_usdcVersion] -= amountToWithdraw;\n        SafeERC20.safeTransfer(ERC20(_usdcVersion), msg.sender, amountToWithdraw);\n        emit Withdrawal(_usdcVersion, amountToWithdraw);\n        return amountToWithdraw;\n    }\n```\n\nIf former `usdc2` holders withdraw their `500` `asdUSDC` for `usdc1`, there will be no `usdc1` left for other users.\n\n### Recommended Mitigation Steps\n\nConsider removing the require block from `withdraw` function.\n\n```diff\n- require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n```\n\n**[dsudit01 (Canto) confirmed and commented](https://github.com/code-423n4/2024-03-canto-findings/issues/3#issuecomment-2040432302):**\n > PR [here](https://github.com/Plex-Engineer/ASD-V2/pull/1).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-canto",
  "Code": [
    {
      "filename": "contracts/asd/asdUSDC.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title ASDUSDC\n * @notice This contract wraps multiple versions of USDC into one token\n */\ncontract ASDUSDC is ERC20, Ownable {\n    mapping(address => bool) public whitelistedUSDCVersions;\n    mapping(address => uint256) public usdcBalances;\n\n    event Deposit(address _version, uint _amount);\n    event Withdrawal(address _version, uint _amount);\n\n    constructor() ERC20(\"ASD USDC\", \"asdUSDC\") {}\n\n    /**\n     * @notice Add a USDC version to the whitelist\n     * @param _usdcVersion Address of the USDC version to add\n     */\n    function updateWhitelist(address _usdcVersion, bool _isWhitelisted) external onlyOwner {\n        whitelistedUSDCVersions[_usdcVersion] = _isWhitelisted;\n    }\n\n    /**\n     * @notice Deposit USDC and mint asdUSDC tokens\n     * @param _usdcVersion Address of the USDC version to deposit\n     * @param _amount Amount of USDC to deposit\n     * @return Amount of asdUSDC tokens minted\n     */\n    function deposit(address _usdcVersion, uint256 _amount) external returns (uint256) {\n        // check whitelist\n        require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n        SafeERC20.safeTransferFrom(ERC20(_usdcVersion), msg.sender, address(this), _amount);\n        usdcBalances[_usdcVersion] += _amount;\n        // Mint the same amount of asdUSDC tokens but take decimals into account\n        uint256 amountToMint = _amount * (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        _mint(msg.sender, amountToMint);\n        emit Deposit(_usdcVersion, _amount);\n        return amountToMint;\n    }\n\n    /**\n     * @notice Withdraw USDC and burn asdUSDC tokens\n     * @param _usdcVersion Address of the USDC version to withdraw\n     * @param _amount Amount of asdUSDC tokens to burn\n     * @return Amount of USDC withdrawn\n     */\n    function withdraw(address _usdcVersion, uint256 _amount) external returns (uint256) {\n        // check whitelist\n        require(whitelistedUSDCVersions[_usdcVersion], \"ASDUSDC: USDC version not whitelisted\");\n        // burn tokens\n        _burn(msg.sender, _amount);\n        // calculate amount to withdraw\n        uint256 amountToWithdraw = _amount / (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        // check balance\n        require(usdcBalances[_usdcVersion] >= amountToWithdraw, \"ASDUSDC: Not enough USDC balance\");\n        // transfer USDC\n        usdcBalances[_usdcVersion] -= amountToWithdraw;\n        SafeERC20.safeTransfer(ERC20(_usdcVersion), msg.sender, amountToWithdraw);\n        emit Withdrawal(_usdcVersion, amountToWithdraw);\n        return amountToWithdraw;\n    }\n\n    /**\n     * @notice Recover any USDC that was sent to the contract by mistake\n     * @param _usdcVersion Address of the USDC version to recover\n     * @return Amount of USDC minted\n     */\n    function recover(address _usdcVersion) external onlyOwner returns (uint256) {\n        // recover amount\n        uint amountToRecover = ERC20(_usdcVersion).balanceOf(address(this)) - usdcBalances[_usdcVersion];\n        usdcBalances[_usdcVersion] += amountToRecover;\n        // mint tokens\n        uint256 amountToMint = amountToRecover * (10 ** (this.decimals() - ERC20(_usdcVersion).decimals()));\n        _mint(msg.sender, amountToMint);\n        return amountToMint;\n    }\n}"
    }
  ]
}