{
  "Title": "[M01] Approval process can be front-run",
  "Content": "The ERC-20 standard [`approve`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L110-L129) function lets `NOTE` owners specify a `spender` that may transfer up to `rawAmount` tokens from the owner’s balance.  \n\nThe same `approve` function is used to make changes to this limit imposed on a `spender`, by calling the function again which replaces the value in the [`allowances` mapping](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L28).\n\n\nPerforming a direct overwrite of the value in the `allowances` mapping is susceptible to front-running scenarios by an attacker (e.g., an approved `spender`). By monitoring the mempool for changes in the allowances, an attacker could spend both the previous and new `allowances` limits.\n\n\nAlthough this vulnerability is acknowledged [in a comment](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L112), it is not mitigated. Consider using the `safeIncreaseAllowance` and the `safeDecreaseAllowance` methods from the [OpenZeppelin’s `SafeERC20` library](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#SafeERC20).\n\n\n***Update:** Acknowledged, and will not fix. Notional’s statement for this issue:*\n\n\n\n> \n>  \\_Won’t fix, unclear how one would resolve this in the “approve” method without adding the separate atomic increaseAllowance and decreaseAllowance methods. My feeling on this issue is that it has to be dealt with client side anyway (increaseAllowance / decreaseAllowance are non-standard) and if the client is savvy enough to be aware of those methods it can also enforce that the allowance is set to zero before it is increased. Also just from a practical perspective, allowances are generally set to MAX*UINT256 or 0 for most apps anyway just to simplify the user experience.*\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/external/governance/NoteERC20.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\n\n/// @title Note ERC20 Token\n/// Fork of Compound Comp token at commit hash\n/// https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\ncontract NoteERC20 is Initializable {\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Notional\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"NOTE\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 8;\n\n    /// @notice Total number of tokens in circulation (100 million NOTE)\n    uint256 public constant totalSupply = 100000000e8;\n\n    /// @notice Notional router address\n    NotionalProxy public notionalProxy;\n\n    // Allowance amounts on behalf of others\n    mapping(address => mapping(address => uint96)) internal allowances;\n\n    // Official record of token balances for each account\n    mapping(address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @notice Initialize note token with initial grants\n    /// @param initialAccounts initial address to grant tokens to\n    /// @param initialGrantAmount amount to grant address initially\n    /// @param notionalProxy_ address of notional proxy\n    function initialize(\n        address[] calldata initialAccounts,\n        uint96[] calldata initialGrantAmount,\n        NotionalProxy notionalProxy_\n    ) public initializer {\n        require(initialGrantAmount.length == initialAccounts.length);\n\n        notionalProxy = notionalProxy_;\n        uint96 totalGrants;\n        for (uint256 i; i < initialGrantAmount.length; i++) {\n            totalGrants = _add96(totalGrants, initialGrantAmount[i], \"\");\n            balances[initialAccounts[i]] = initialGrantAmount[i];\n\n            emit Transfer(address(0), initialAccounts[i], initialGrantAmount[i]);\n        }\n\n        require(totalGrants == totalSupply);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param account The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function allowance(address account, address spender) external view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev This will overwrite the approval amount for `spender`\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n    ///  emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = _safe96(rawAmount, \"Note::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function balanceOf(address account) external view returns (uint256) {\n        return balances[account];\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev emit:Transfer\n    /// @param dst The address of the destination account\n    /// @param rawAmount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\n        uint96 amount = _safe96(rawAmount, \"Note::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev emit:Transfer emit:Approval\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param rawAmount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = _safe96(rawAmount, \"Note::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance =\n                _sub96(\n                    spenderAllowance,\n                    amount,\n                    \"Note::transferFrom: transfer amount exceeds spender allowance\"\n                );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /// @notice Delegate votes from `msg.sender` to `delegatee`\n    /// @param delegatee The address to delegate votes to\n    /// @dev emit:DelegatesChanged\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /// @notice Delegates votes from signatory to `delegatee`\n    /// @dev emit:DelegatesChanged\n    /// @param delegatee The address to delegate votes to\n    /// @param nonce The contract state required to match the signature\n    /// @param expiry The time at which to expire the signature\n    /// @param v The recovery byte of the signature\n    /// @param r Half of the ECDSA signature pair\n    /// @param s Half of the ECDSA signature pair\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Note::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Note::delegateBySig: invalid nonce\");\n        require(block.timestamp <= expiry, \"Note::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /// @notice Gets the current votes balance for `account`\n    /// @param account The address to get votes balance\n    /// @return The number of current votes for `account`\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        uint96 currentVotes = nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n        return\n            _add96(\n                currentVotes,\n                getUnclaimedVotes(account),\n                \"Note::getCurrentVotes: uint96 overflow\"\n            );\n    }\n\n    /// @notice Determine the prior number of votes for an account as of a block number\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    /// @param account The address of the account to check\n    /// @param blockNumber The block number to get the vote balance at\n    /// @return The number of votes the account had as of the given block\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"Note::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n\n        return\n            _add96(\n                checkpoints[account][lower].votes,\n                getUnclaimedVotes(account),\n                \"Note::getPriorVotes: uint96 overflow\"\n            );\n    }\n\n    /// @notice Notional counts unclaimed incentives as part of a users' voting power. There is no\n    /// need to checkpoint these values because they cannot be transferred or delegated.\n    /// @param account the address of the Notional account to check\n    /// @return Total number of unclaimed tokens accrued on the Notional account\n    function getUnclaimedVotes(address account) public view returns (uint96) {\n        // NOTE: this code has been removed for an open zeppelin audit of the governance contracts\n        // uint256 votes = notionalProxy.nTokenGetClaimableIncentives(account, block.timestamp);\n        // require(votes <= type(uint96).max);\n        return 0;\n    }\n\n    /// @dev Changes delegates from one address to another\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    /// @dev Transfers tokens and inherits the delegate from the destination address\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 amount\n    ) internal {\n        require(src != address(0), \"Note::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Note::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = _sub96(\n            balances[src],\n            amount,\n            \"Note::_transferTokens: transfer amount exceeds balance\"\n        );\n        balances[dst] = _add96(\n            balances[dst],\n            amount,\n            \"Note::_transferTokens: transfer amount overflows\"\n        );\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    /// @dev Transfers delegates and writes a checkpoint for `getPriorVotes` to use\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew =\n                    _sub96(srcRepOld, amount, \"Note::_moveVotes: vote amount underflow\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew =\n                    _add96(dstRepOld, amount, \"Note::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    /// @dev Writes checkpoints for `getPriorVotes`, this is somewhat inefficient as it uses\n    /// 20000 gas per transfer of delegated tokens. The goal is prevent voters from borrowing\n    /// a large number of votes for a short period to vote for or against a proposal. It's unclear\n    /// if there is a better model than this one here. Using only a single checkpoint means that\n    /// a delegate could be the victim of a denial of service attack where an attacker continually\n    /// transfers tokens to them to prevent them from voting.\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber =\n            _safe32(block.number, \"Note::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function _safe32(uint256 n, string memory errorMessage) private pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function _safe96(uint256 n, string memory errorMessage) private pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function _add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function _sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) private pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}"
    },
    {
      "filename": "contracts/external/governance/NoteERC20.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\n\n/// @title Note ERC20 Token\n/// Fork of Compound Comp token at commit hash\n/// https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\ncontract NoteERC20 is Initializable {\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Notional\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"NOTE\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 8;\n\n    /// @notice Total number of tokens in circulation (100 million NOTE)\n    uint256 public constant totalSupply = 100000000e8;\n\n    /// @notice Notional router address\n    NotionalProxy public notionalProxy;\n\n    // Allowance amounts on behalf of others\n    mapping(address => mapping(address => uint96)) internal allowances;\n\n    // Official record of token balances for each account\n    mapping(address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @notice Initialize note token with initial grants\n    /// @param initialAccounts initial address to grant tokens to\n    /// @param initialGrantAmount amount to grant address initially\n    /// @param notionalProxy_ address of notional proxy\n    function initialize(\n        address[] calldata initialAccounts,\n        uint96[] calldata initialGrantAmount,\n        NotionalProxy notionalProxy_\n    ) public initializer {\n        require(initialGrantAmount.length == initialAccounts.length);\n\n        notionalProxy = notionalProxy_;\n        uint96 totalGrants;\n        for (uint256 i; i < initialGrantAmount.length; i++) {\n            totalGrants = _add96(totalGrants, initialGrantAmount[i], \"\");\n            balances[initialAccounts[i]] = initialGrantAmount[i];\n\n            emit Transfer(address(0), initialAccounts[i], initialGrantAmount[i]);\n        }\n\n        require(totalGrants == totalSupply);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param account The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function allowance(address account, address spender) external view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev This will overwrite the approval amount for `spender`\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n    ///  emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = _safe96(rawAmount, \"Note::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function balanceOf(address account) external view returns (uint256) {\n        return balances[account];\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev emit:Transfer\n    /// @param dst The address of the destination account\n    /// @param rawAmount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\n        uint96 amount = _safe96(rawAmount, \"Note::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev emit:Transfer emit:Approval\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param rawAmount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = _safe96(rawAmount, \"Note::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance =\n                _sub96(\n                    spenderAllowance,\n                    amount,\n                    \"Note::transferFrom: transfer amount exceeds spender allowance\"\n                );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /// @notice Delegate votes from `msg.sender` to `delegatee`\n    /// @param delegatee The address to delegate votes to\n    /// @dev emit:DelegatesChanged\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /// @notice Delegates votes from signatory to `delegatee`\n    /// @dev emit:DelegatesChanged\n    /// @param delegatee The address to delegate votes to\n    /// @param nonce The contract state required to match the signature\n    /// @param expiry The time at which to expire the signature\n    /// @param v The recovery byte of the signature\n    /// @param r Half of the ECDSA signature pair\n    /// @param s Half of the ECDSA signature pair\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Note::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Note::delegateBySig: invalid nonce\");\n        require(block.timestamp <= expiry, \"Note::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /// @notice Gets the current votes balance for `account`\n    /// @param account The address to get votes balance\n    /// @return The number of current votes for `account`\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        uint96 currentVotes = nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n        return\n            _add96(\n                currentVotes,\n                getUnclaimedVotes(account),\n                \"Note::getCurrentVotes: uint96 overflow\"\n            );\n    }\n\n    /// @notice Determine the prior number of votes for an account as of a block number\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    /// @param account The address of the account to check\n    /// @param blockNumber The block number to get the vote balance at\n    /// @return The number of votes the account had as of the given block\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"Note::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n\n        return\n            _add96(\n                checkpoints[account][lower].votes,\n                getUnclaimedVotes(account),\n                \"Note::getPriorVotes: uint96 overflow\"\n            );\n    }\n\n    /// @notice Notional counts unclaimed incentives as part of a users' voting power. There is no\n    /// need to checkpoint these values because they cannot be transferred or delegated.\n    /// @param account the address of the Notional account to check\n    /// @return Total number of unclaimed tokens accrued on the Notional account\n    function getUnclaimedVotes(address account) public view returns (uint96) {\n        // NOTE: this code has been removed for an open zeppelin audit of the governance contracts\n        // uint256 votes = notionalProxy.nTokenGetClaimableIncentives(account, block.timestamp);\n        // require(votes <= type(uint96).max);\n        return 0;\n    }\n\n    /// @dev Changes delegates from one address to another\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    /// @dev Transfers tokens and inherits the delegate from the destination address\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 amount\n    ) internal {\n        require(src != address(0), \"Note::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Note::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = _sub96(\n            balances[src],\n            amount,\n            \"Note::_transferTokens: transfer amount exceeds balance\"\n        );\n        balances[dst] = _add96(\n            balances[dst],\n            amount,\n            \"Note::_transferTokens: transfer amount overflows\"\n        );\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    /// @dev Transfers delegates and writes a checkpoint for `getPriorVotes` to use\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew =\n                    _sub96(srcRepOld, amount, \"Note::_moveVotes: vote amount underflow\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew =\n                    _add96(dstRepOld, amount, \"Note::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    /// @dev Writes checkpoints for `getPriorVotes`, this is somewhat inefficient as it uses\n    /// 20000 gas per transfer of delegated tokens. The goal is prevent voters from borrowing\n    /// a large number of votes for a short period to vote for or against a proposal. It's unclear\n    /// if there is a better model than this one here. Using only a single checkpoint means that\n    /// a delegate could be the victim of a denial of service attack where an attacker continually\n    /// transfers tokens to them to prevent them from voting.\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber =\n            _safe32(block.number, \"Note::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function _safe32(uint256 n, string memory errorMessage) private pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function _safe96(uint256 n, string memory errorMessage) private pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function _add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function _sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) private pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}"
    },
    {
      "filename": "contracts/external/governance/NoteERC20.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\n\n/// @titl"
    }
  ]
}