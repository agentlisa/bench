{
  "Title": "[H-02] The check for value transfer success is made after the return statement in `_withdrawFromYieldPool` of `LidoVault`",
  "Content": "\nUsers can lose their funds\n\n### Proof of Concept\n\n[LidoVault.sol#L142](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142)<br>\n\nThe code checks transaction success after returning the transfer value and finishing execution. If the call fails the transaction won't revert since  require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID); won't execute.\n\nUsers will have withdrawn without getting their funds back.\n\n### Recommended Mitigation Steps\n\nReturn the function after the success check\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157)**\n\n**[iris112 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157):**\n > [Fix the issue of return before require sturdyfi/code4rena-may-2022#9](https://github.com/sturdyfi/code4rena-may-2022/pull/9)\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/157#issuecomment-1145546283):**\n > Issue is rather clear-cut.\n\n\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-05-sturdy-contest",
  "Code": [
    {
      "filename": "smart-contracts/LidoVault.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {GeneralVault} from '../GeneralVault.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IWETH} from '../../../misc/interfaces/IWETH.sol';\nimport {Errors} from '../../libraries/helpers/Errors.sol';\nimport {TransferHelper} from '../../libraries/helpers/TransferHelper.sol';\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {CurveswapAdapter} from '../../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title LidoVault\n * @notice stETH/ETH Vault by using Lido, Uniswap, Curve\n * @author Sturdy\n **/\ncontract LidoVault is GeneralVault {\n  using SafeERC20 for IERC20;\n\n  /**\n   * @dev Receive Ether\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Grab excess stETH which was from rebasing on Lido\n   *  And convert stETH -> ETH -> asset, deposit to pool\n   */\n  function processYield() external override onlyAdmin {\n    // Get yield from lendingPool\n    address LIDO = _addressesProvider.getAddress('LIDO');\n    uint256 yieldStETH = _getYield(LIDO);\n\n    // move yield to treasury\n    if (_vaultFee > 0) {\n      uint256 treasuryStETH = _processTreasury(yieldStETH);\n      yieldStETH = yieldStETH.sub(treasuryStETH);\n    }\n\n    // Exchange stETH -> ETH via Curve\n    uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _addressesProvider.getAddress('STETH_ETH_POOL'),\n      LIDO,\n      ETH,\n      yieldStETH,\n      200\n    );\n\n    // ETH -> WETH\n    address weth = _addressesProvider.getAddress('WETH');\n    IWETH(weth).deposit{value: receivedETHAmount}();\n\n    // transfer WETH to yieldManager\n    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');\n    TransferHelper.safeTransfer(weth, yieldManager, receivedETHAmount);\n\n    emit ProcessYield(_addressesProvider.getAddress('WETH'), receivedETHAmount);\n  }\n\n  /**\n   * @dev Get yield amount based on strategy\n   */\n  function getYieldAmount() external view returns (uint256) {\n    return _getYieldAmount(_addressesProvider.getAddress('LIDO'));\n  }\n\n  /**\n   * @dev Get price per share based on yield strategy\n   */\n  function pricePerShare() external view override returns (uint256) {\n    return 1e18;\n  }\n\n  /**\n   * @dev Deposit to yield pool based on strategy and receive stAsset\n   */\n  function _depositToYieldPool(address _asset, uint256 _amount)\n    internal\n    override\n    returns (address, uint256)\n  {\n    address LIDO = _addressesProvider.getAddress('LIDO');\n    uint256 assetAmount = _amount;\n    if (_asset == address(0)) {\n      // Case of ETH deposit from user, user has to send ETH\n      require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);\n\n      // Deposit ETH to Lido and receive stETH\n      (bool sent, bytes memory data) = LIDO.call{value: msg.value}('');\n      require(sent, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n\n      assetAmount = msg.value;\n    } else {\n      // Case of stETH deposit from user, receive stETH from user\n      require(_asset == LIDO, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n      IERC20(LIDO).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Make lendingPool to transfer required amount\n    IERC20(LIDO).safeApprove(address(_addressesProvider.getLendingPool()), assetAmount);\n    return (LIDO, assetAmount);\n  }\n\n  /**\n   * @dev Get Withdrawal amount of stAsset based on strategy\n   */\n  function _getWithdrawalAmount(address _asset, uint256 _amount)\n    internal\n    view\n    override\n    returns (address, uint256)\n  {\n    // In this vault, return same amount of asset.\n    return (_addressesProvider.getAddress('LIDO'), _amount);\n  }\n\n  /**\n   * @dev Withdraw from yield pool based on strategy with stAsset and deliver asset\n   */\n  function _withdrawFromYieldPool(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) internal override returns (uint256) {\n    address LIDO = _addressesProvider.getAddress('LIDO');\n    if (_asset == address(0)) {\n      // Case of ETH withdraw request from user, so exchange stETH -> ETH via curve\n      uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(\n        _addressesProvider,\n        _addressesProvider.getAddress('STETH_ETH_POOL'),\n        LIDO,\n        ETH,\n        _amount,\n        200\n      );\n\n      // send ETH to user\n      (bool sent, bytes memory data) = address(_to).call{value: receivedETHAmount}('');\n      return receivedETHAmount;\n      require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID);\n    } else {\n      // Case of stETH withdraw request from user, so directly send\n      require(_asset == LIDO, Errors.VT_COLLATERAL_WITHDRAW_INVALID);\n      IERC20(LIDO).safeTransfer(_to, _amount);\n    }\n    return _amount;\n  }\n\n  /**\n   * @dev Move some yield to treasury\n   */\n  function _processTreasury(uint256 _yieldAmount) internal returns (uint256) {\n    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);\n    IERC20(_addressesProvider.getAddress('LIDO')).safeTransfer(_treasuryAddress, treasuryAmount);\n    return treasuryAmount;\n  }\n}"
    }
  ]
}