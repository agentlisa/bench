{
  "Title": "M-5: When APR late rate is lower than APR, an OCC locker bullet loan borrower can pay way less interests by calling the loan",
  "Content": "# Issue M-5: When APR late rate is lower than APR, an OCC locker bullet loan borrower can pay way less interests by calling the loan \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/97 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0x73696d616f, Ironsidesec, KupiaSec, SilverChariot, saidam017, sl1, thank\\_you, y4y\n## Summary\nA bullet loan borrower can pay less interests by calling [`callLoan`](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCC/OCC_Modular.sol#L492)  at the end of payment period.\n\n## Vulnerability Detail\nIn `OCC_Modular` contract, the protocol can create loan offers, and users can accept them. The loan has two types, one being bullet, and the other being amortization. In the bullet loan, borrowers only need to pay back interests for each interval, and principle at the last term.\n\n`amountOwed` returns the payment amount needed for each loan id:\n\n```solidity\n    function amountOwed(uint256 id) public view returns (\n        uint256 principal, uint256 interest, uint256 lateFee, uint256 total\n    ) {\n        // 0 == Bullet.\n        if (loans[id].paymentSchedule == 0) {\n            if (loans[id].paymentsRemaining == 1) { principal = loans[id].principalOwed; }\n        }\n        // 1 == Amortization (only two options, use else here).\n        else { principal = loans[id].principalOwed / loans[id].paymentsRemaining; }\n\n        // Add late fee if past loans[id].paymentDueBy.\n        if (block.timestamp > loans[id].paymentDueBy && loans[id].state == LoanState.Active) {\n            lateFee = loans[id].principalOwed * (block.timestamp - loans[id].paymentDueBy) *\n                loans[id].APRLateFee / (86400 * 365 * BIPS);\n        }\n        interest = loans[id].principalOwed * loans[id].paymentInterval * loans[id].APR / (86400 * 365 * BIPS);\n        total = principal + interest + lateFee;\n    }\n```\n\nAnd we see, there is a `lateFee` for any loans which is overdue. The later the borrower pays back the loan, the more late fees will be accumulated. Plus, the under writer role can always set the loan to default when it's way passed grace period. `callLoan` provides an option for borrowers to payback all he/she owes immediately and settles the loan. In this function, `amountOwed` is called once:\n\n```solidity\n    function callLoan(uint256 id) external nonReentrant {\n        require(\n            _msgSender() == loans[id].borrower || IZivoeGlobals_OCC(GBL).isLocker(_msgSender()), \n            \"OCC_Modular::callLoan() _msgSender() != loans[id].borrower && !isLocker(_msgSender())\"\n        );\n        require(loans[id].state == LoanState.Active, \"OCC_Modular::callLoan() loans[id].state != LoanState.Active\");\n\n        uint256 principalOwed = loans[id].principalOwed;\n        (, uint256 interestOwed, uint256 lateFee,) = amountOwed(id);\n\n        emit LoanCalled(id, principalOwed + interestOwed + lateFee, principalOwed, interestOwed, lateFee);\n\n        // Transfer interest to YDL if in same format, otherwise keep here for 1INCH forwarding.\n        if (stablecoin == IZivoeYDL_OCC(IZivoeGlobals_OCC(GBL).YDL()).distributedAsset()) {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), IZivoeGlobals_OCC(GBL).YDL(), interestOwed + lateFee);\n        }\n        else {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), OCT_YDL, interestOwed + lateFee);\n        }\n\n        IERC20(stablecoin).safeTransferFrom(_msgSender(), owner(), principalOwed);\n\n        loans[id].principalOwed = 0;\n        loans[id].paymentDueBy = 0;\n        loans[id].paymentsRemaining = 0;\n        loans[id].state = LoanState.Repaid;\n    }\n```\n\nThis means, only one interval's late fee is taken into account for this calculation. When the late fee rate is less than APR, and the payment is way overdue, it's possible for such borrower to skip a few interests and late fee payment.\n\n```solidity\n    function test_OCC_Late_Payment_Loan_ALL() public {\n        uint256 borrowAmount = 20 * 10 ** 18;\n        uint256 APR;\n        uint256 APRLateFee;\n        uint256 term;\n        uint256 paymentInterval;\n        uint256 gracePeriod;\n        int8 paymentSchedule = 0;\n        \n        APR = 1000;\n        APRLateFee = 500;\n        term = 10;\n        paymentInterval = options[1];\n        gracePeriod = uint256(10 days) % 90 days + 7 days;\n        mint(\"DAI\", address(tim), 100 * 10 **18);\n        hevm.startPrank(address(roy));\n        OCC_Modular_DAI.createOffer(\n            address(tim), borrowAmount, APR, APRLateFee, term, paymentInterval, gracePeriod, paymentSchedule\n        );\n        hevm.stopPrank();\n\n        uint256 loanId = OCC_Modular_DAI.loanCounter() - 1;\n\n        hevm.startPrank(address(tim));\n        IERC20(DAI).approve(address(OCC_Modular_DAI), type(uint256).max);\n        OCC_Modular_DAI.acceptOffer(loanId);\n        (, , uint256[10] memory info) = OCC_Modular_DAI.loanInfo(loanId);\n        hevm.warp(info[3] + (info[4] * term));\n        uint256 balanceBefore = IERC20(DAI).balanceOf(address(tim));\n        while (info[4] > 0) {\n            OCC_Modular_DAI.makePayment(loanId);\n            (, , info) = OCC_Modular_DAI.loanInfo(loanId);\n        }\n        uint256 balanceAfter = IERC20(DAI).balanceOf(address(tim));\n        uint256 diff = balanceBefore - balanceAfter;\n        console.log(\"paid total when payments are late for each interval:\", diff);\n        console.log(\"total interests:\", diff - borrowAmount);\n        hevm.stopPrank();\n    }\n\n    function test_OCC_Normal_Payment_Loan() public {\n        uint256 borrowAmount = 20 * 10 ** 18;\n        uint256 APR;\n        uint256 APRLateFee;\n        uint256 term;\n        uint256 paymentInterval;\n        uint256 gracePeriod;\n        int8 paymentSchedule = 0;\n        \n        APR = 1000;\n        APRLateFee = 500;\n        term = 10;\n        paymentInterval = options[1];\n        gracePeriod = uint256(10 days) % 90 days + 7 days;\n        mint(\"DAI\", address(tim), 100 * 10 ** 18);\n        hevm.startPrank(address(roy));\n        OCC_Modular_DAI.createOffer(\n            address(tim), borrowAmount, APR, APRLateFee, term, paymentInterval, gracePeriod, paymentSchedule\n        );\n        hevm.stopPrank();\n\n        uint256 loanId = OCC_Modular_DAI.loanCounter() - 1;\n\n        hevm.startPrank(address(tim));\n        IERC20(DAI).approve(address(OCC_Modular_DAI), type(uint256).max);\n        OCC_Modular_DAI.acceptOffer(loanId);\n        (, , uint256[10] memory info) = OCC_Modular_DAI.loanInfo(loanId);\n        hevm.warp(info[3]);\n        uint256 balanceBefore = IERC20(DAI).balanceOf(address(tim));\n        while (info[4] > 0) {\n            OCC_Modular_DAI.makePayment(loanId);\n            (, , info) = OCC_Modular_DAI.loanInfo(loanId);\n            hevm.warp(info[3]);\n        }\n        uint256 balanceAfter = IERC20(DAI).balanceOf(address(tim));\n        uint256 diff = balanceBefore - balanceAfter;\n        console.log(\"paid total when loan is solved normally:\", diff);\n        console.log(\"total interests:\", diff - borrowAmount);\n        hevm.stopPrank();\n    }\n\n    function test_OCC_Late_Call_Loan() public {\n        uint256 borrowAmount = 20 * 10 ** 18;\n        uint256 APR;\n        uint256 APRLateFee;\n        uint256 term;\n        uint256 paymentInterval;\n        uint256 gracePeriod;\n        int8 paymentSchedule = 0;\n        \n        APR = 1000;\n        APRLateFee = 500;\n        term = 10;\n        paymentInterval = options[1];\n        gracePeriod = uint256(10 days) % 90 days + 7 days;\n        mint(\"DAI\", address(tim), 100 * 10 ** 18);\n        hevm.startPrank(address(roy));\n        OCC_Modular_DAI.createOffer(\n            address(tim), borrowAmount, APR, APRLateFee, term, paymentInterval, gracePeriod, paymentSchedule\n        );\n        hevm.stopPrank();\n\n        uint256 loanId = OCC_Modular_DAI.loanCounter() - 1;\n\n        hevm.startPrank(address(tim));\n        IERC20(DAI).approve(address(OCC_Modular_DAI), type(uint256).max);\n        OCC_Modular_DAI.acceptOffer(loanId);\n        (, , uint256[10] memory info) = OCC_Modular_DAI.loanInfo(loanId);\n        hevm.warp(info[3] + (info[4] * term));\n        uint256 balanceBefore = IERC20(DAI).balanceOf(address(tim));\n        OCC_Modular_DAI.callLoan(loanId);\n        uint256 balanceAfter = IERC20(DAI).balanceOf(address(tim));\n        uint256 diff = balanceBefore - balanceAfter;\n        console.log(\"paid total when use `callLoan` at the end:\", diff);\n        console.log(\"total interests:\", diff - borrowAmount);\n        hevm.stopPrank();\n    }\n```\n\nIn the above test cases, all three of them will have the same borrower, and borrow the same loan, with same details and everything. One of them simulating when a borrower pays all charges normally till the end of term, another one waits till the very end to pay back the loan with late fees, and the last one also wait till the end, except calls `callLoan` to settle the loan instead of normally paying back each interval's amount.\n\nAfter running the test cases, the following will be logged:\n\n```plaintext\n[PASS] test_OCC_Late_Call_Loan() (gas: 373730) \nLogs:\n  paid total when use `callLoan` at the end: 20076715499746321663\n  total interests: 76715499746321663       \n\n[PASS] test_OCC_Late_Payment_Loan_ALL() (gas: 565561)  \nLogs:\n  paid total when payments are late for each interval: 20767126458650431246\n  total interests: 767126458650431246  \n\n[PASS] test_OCC_Normal_Payment_Loan() (gas: 569173)\nLogs:\npaid total when loan is solved normally: 20767123287671232870\ntotal interests: 767123287671232870\n```\n\nAs we can see, while `callLoan` also needs to pay the late fee penalty, it still charges way less than normally paying back the loan. This makes a borrower being able to skip a few interests fee, with the cost of little late fees.\n\n## Impact\nThe PoC provided above is certainly an exaggerated edge case, but it's also possible when late fees are aribitrary, as long as the loan is not set to default by under writers, the borrower can skip paying quite some interest fees by exploiting this at the cost of a few late fees. This is more likely to happen when intervals are set to 7 days, as the minimum grace period is 7 days.\n\n\n## Code Snippet\n```solidity\n    function callLoan(uint256 id) external nonReentrant {\n        require(\n            _msgSender() == loans[id].borrower || IZivoeGlobals_OCC(GBL).isLocker(_msgSender()), \n            \"OCC_Modular::callLoan() _msgSender() != loans[id].borrower && !isLocker(_msgSender())\"\n        );\n        require(loans[id].state == LoanState.Active, \"OCC_Modular::callLoan() loans[id].state != LoanState.Active\");\n\n        uint256 principalOwed = loans[id].principalOwed;\n        (, uint256 interestOwed, uint256 lateFee,) = amountOwed(id);\n\n        emit LoanCalled(id, principalOwed + interestOwed + lateFee, principalOwed, interestOwed, lateFee);\n\n        // Transfer interest to YDL if in same format, otherwise keep here for 1INCH forwarding.\n        if (stablecoin == IZivoeYDL_OCC(IZivoeGlobals_OCC(GBL).YDL()).distributedAsset()) {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), IZivoeGlobals_OCC(GBL).YDL(), interestOwed + lateFee);\n        }\n        else {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), OCT_YDL, interestOwed + lateFee);\n        }\n\n        IERC20(stablecoin).safeTransferFrom(_msgSender(), owner(), principalOwed);\n\n        loans[id].principalOwed = 0;\n        loans[id].paymentDueBy = 0;\n        loans[id].paymentsRemaining = 0;\n        loans[id].state = LoanState.Repaid;\n    }\n```\n\n## Tool used\n\nManual Review, foundry\n\n## Recommendation\nProhibits bullet loan borrowers from calling `callLoan` when the loan is late and still has more than 1 intervals to finish.\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium, if there are more than 1 interest payments missed by borrower, then `callLoan` takes only 1 period payment, allowing borrower to skip paying the other periods interest and lateFee payments.\n\n\n\n**pseudonaut**\n\nThis is not a valid issue - calling a loan is much different than making a payment as it requires the full amount of principal vs. (in the case of bullet loans) a single payment with interest only\n\n\n**panprog**\n\nYes, it's much different from making a payment, but it still allows to bypass paying additional interests/late fees, for example, when only a few payment periods are remaining and it makes sense to simply `callLoan` instead of doing last 2-3 interest and latefee payments at the expense of protocol / depositors.\n\nKeeping this as medium.\n\n**panprog**\n\nSponsor response:\n> intended functionality, user has option to callLoan at any point in time, and if you're saying they have late-fee's than theoretically the loan could be defaulted and likely would at that point preventing callLoan\n\n**panprog**\n\nThis is from [docs](https://docs.zivoe.com/user-docs/borrowers/how-do-defaults-work):\n> In some cases, the grace period may be longer than the payment interval, and the borrower may miss several loan payments before a loan enters default. In such an event, the borrower must resolve each missed payment before late fees stop accruing. \n\nSo it's possible that grace period is longer than payment interval. Example: payment interval = 7 days, grace period = 28 days.\nBorrower can simply stop paying 28 days before the loan is due. At the end of the loan he will have 4 missed payments, at which point he simply `callLoan` and pay only 1 missed payment + late fees from it, skipping paying the other 3 missed payments and late fees from them. Depending on late fees this can be cheaper for borrower than paying all 4 payments on time.\nScenario A (paying on time): 28 days * APR payments\nScenario B (calling loan in the end): 7 days * APR +  28 days * lateFee APR\n\nIf lateFee is less than APR, then borrower is better off skipping the last 4 payments and doing `callLoan` in the end.\n\nKeeping this medium.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCC/OCC_Modular.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IZivoeGlobals_OCC {\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns the net defaults in the system.\n    function defaults() external view returns (uint256);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    function isKeeper(address) external view returns (bool);\n\n    /// @notice Returns \"true\" if a locker is whitelisted for DAO interactions and accounting accessibility.\n    /// @param  locker  The address of the locker to check for.\n    function isLocker(address locker) external view returns (bool);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice Call when a default is resolved, decreases net defaults system-wide.\n    /// @dev    The value \"amount\" should be standardized to WEI.\n    /// @param  amount The default amount that has been resolved.\n    function decreaseDefaults(uint256 amount) external;\n\n    /// @notice Call when a default occurs, increases net defaults system-wide.\n    /// @dev    The value \"amount\" should be standardized to WEI.\n    /// @param  amount The default amount.\n    function increaseDefaults(uint256 amount) external;\n}\n\ninterface IZivoeYDL_OCC {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\n\n\n/// @notice  OCC stands for \"On-Chain Credit\".\n///          A \"Bullet\" loan is an interest-only loan, with principal repaid in full at the end.\n///          An \"Amortization\" loan is a principal and interest loan, with consistent payments until fully \"Repaid\".\n///          This locker is responsible for handling accounting of loans.\n///          This locker is responsible for handling payments and distribution of payments.\n///          This locker is responsible for handling defaults and liquidations (if needed).\ncontract OCC_Modular is ZivoeLocker, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    /// @dev Tracks payment schedule type of the loan.\n    enum LoanSchedule { Bullet, Amortization }\n\n    /// @dev    Tracks state of the loan, enabling or disabling certain actions (function calls).\n    /// @param  Null Default state, loan isn't offered yet.\n    /// @param  Offered Loan offer has been created, not accepted (it could have passed expiry date).\n    /// @param  Active Loan has been accepted, is currently receiving payments.\n    /// @param  Repaid Loan was accepted, and has been fully repaid.\n    /// @param  Defaulted Loan has defaulted, payments were missed, gracePeriod passed, and markDefault() called.\n    /// @param  Cancelled Loan offer was created, then cancelled prior to acceptance.\n    /// @param  Resolved Loan was accepted, then there was a default, then the full amount of principal was repaid.\n    /// @param  Combined Loan was accepted, then combined with other loans while active.\n    enum LoanState { \n        Null,\n        Offered,\n        Active,\n        Repaid,\n        Defaulted,\n        Cancelled,\n        Resolved,\n        Combined\n    }\n\n    /// @dev Tracks approved combination.\n    struct Combine {\n        uint256[] loans;                /// @dev The loans approved for combination.\n        uint256 APRLateFee;             /// @dev The late fee APR.\n        uint256 term;                   /// @dev The term of the resulting combined loan.\n        uint256 paymentInterval;        /// @dev The paymentInterval of the resulting combined loan.\n        uint256 gracePeriod;            /// @dev The gracePeriod of the resulting combined loan.\n        uint256 expires;                /// @dev The expiration of this combination.\n        int8 paymentSchedule;           /// @dev The paymentSchedule of the resulting combined loan.\n        bool valid;                     /// @dev The validity of the combination (if it can be executed).\n    }\n\n    /// @dev Tracks the loan.\n    struct Loan {\n        address borrower;               /// @dev The address that receives capital when the loan is accepted.\n        uint256 principalOwed;          /// @dev The amount of principal still owed on the loan.\n        uint256 APR;                    /// @dev The annualized percentage rate charged on the outstanding principal.\n        uint256 APRLateFee;             /// @dev The APR charged on the outstanding principal if payment is late.\n        uint256 paymentDueBy;           /// @dev The timestamp (in seconds) for when the next payment is due.\n        uint256 paymentsRemaining;      /// @dev The number of payments remaining until the loan is \"Repaid\".\n        uint256 term;                   /// @dev The number of paymentIntervals that will occur (e.g. 12, 24).\n        uint256 paymentInterval;        /// @dev The interval of time between payments (in seconds).\n        uint256 offerExpiry;            /// @dev The block.timestamp at which the offer for this loan expires.\n        uint256 gracePeriod;            /// @dev The number of seconds a borrower has to makePayment() before default.\n        int8 paymentSchedule;           /// @dev The payment schedule of the loan (0 = \"Bullet\" or 1 = \"Amortization\").\n        LoanState state;                /// @dev The state of the loan.\n    }\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n    address public immutable stablecoin;        /// @dev The stablecoin for this OCC contract.\n    address public immutable underwriter;       /// @dev The entity that is allowed to underwrite (a.k.a. issue) loans.\n\n    address public OCT_YDL;                     /// @dev Facilitates swaps and forwards distributedAsset() to YDL.\n    \n    uint256 public combineCounter;              /// @dev Incrementor for \"combinations\" mapping.\n    uint256 public loanCounter;                 /// @dev Incrementor for \"loans\" mapping.\n\n    uint256 private constant BIPS = 10000;\n\n    /// @dev Mapping of approved loan combinations.\n    mapping(uint256 => Combine) public combinations;\n\n    /// @dev Mapping of loans approved for conversion to amortization payment schedule.\n    mapping (uint256 => bool) public conversionToAmortization;\n    \n    /// @dev Mapping of loans approved for conversion to bullet payment schedule.\n    mapping (uint256 => bool) public conversionToBullet;\n\n    /// @dev Mapping of loans approved for extension, key is the loan ID, output is paymentIntervals extension.\n    mapping (uint256 => uint256) public extensions;\n\n    /// @dev Mapping of loans and their information, key is the ID of the loan, output is the Loan struct information.\n    mapping (uint256 => Loan) public loans;\n\n    /// @dev Mapping of loans approved for refinancing, key is the ID of the loan, output is APR it can refinance to.\n    mapping(uint256 => uint256) public refinancing;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCC_Modular contract.\n    /// @param  DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param  _stablecoin The stablecoin for this OCC contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _underwriter The entity that is allowed to call createOffer() and markRepaid().\n    /// @param  _OCT_YDL The contract that facilitates swaps and forwards distributedAsset() to YDL.\n    constructor(address DAO, address _stablecoin, address _GBL, address _underwriter, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        stablecoin = _stablecoin;\n        GBL = _GBL;\n        underwriter = _underwriter;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during applyCombine().\n    /// @param  borrower The borrower combining their loans.\n    /// @param  loanIDs The IDs of the loans that were combined.\n    /// @param  term The resulting term of the combined loan.\n    /// @param  paymentInterval The resulting paymentInterval of the combined loan.\n    /// @param  gracePeriod The resulting gracePeriod of the combined loan.\n    /// @param  paymentSchedule The payment schedule of the combined loan (0 = \"Bullet\" or 1 = \"Amortization\").\n    event CombineApplied(\n        address indexed borrower, \n        uint256[] loanIDs, \n        uint256 term,\n        uint256 paymentInterval,\n        uint256 gracePeriod,\n        int8 indexed paymentSchedule\n    );\n\n    /// @notice Emitted during approveCombine().\n    /// @param  id The ID of the combination approval in \"combinations\" mapping.\n    /// @param  loanIDs The IDs of the loans that can be combined.\n    /// @param  term The resulting term of the combined loan that is permitted.\n    /// @param  paymentInterval The resulting paymentInterval of the combined loan.\n    /// @param  gracePeriod The resulting gracePeriod of the combined loan that is permitted.\n    /// @param  expires The expiration of this combination.\n    /// @param  paymentSchedule The payment schedule of the combined loan (0 = \"Bullet\" or 1 = \"Amortization\").\n    event CombineApproved(\n        uint256 indexed id, \n        uint256[] loanIDs,\n        uint256 APRLateFee,\n        uint256 term,\n        uint256 paymentInterval, \n        uint256 gracePeriod,\n        uint256 expires,\n        int8 indexed paymentSchedule\n    );\n\n    /// @notice Emitted during applyCombine().\n    /// @param  borrower        The address borrowing (that will receive the loan).\n    /// @param  id              Identifier for the loan offer created.\n    /// @param  borrowAmount    The amount to borrow (in other words, initial principal).\n    /// @param  APR             The annualized percentage rate charged on the outstanding principal.\n    /// @param  APRLateFee      The APR charged for late payments.\n    /// @param  paymentDueBy    The timestamp (in seconds) for when the next payment is due.\n    /// @param  term            The term or \"duration\" of the loan (number of paymentIntervals that will occur).\n    /// @param  paymentInterval The interval of time between payments (in seconds).\n    /// @param  gracePeriod     The number of seconds a borrower has to makePayment() before loan could default.\n    /// @param  paymentSchedule The payment schedule type (\"Bullet\" or \"Amortization\").\n    event CombineLoanCreated(\n        address indexed borrower,\n        uint256 indexed id,\n        uint256 borrowAmount,\n        uint256 APR,\n        uint256 APRLateFee,\n        uint256 paymentDueBy,\n        uint256 term,\n        uint256 paymentInterval,\n        uint256 gracePeriod,\n        int8 indexed paymentSchedule\n    );\n\n    /// @notice Emitted during unapproveCombine().\n    /// @param  id The ID of the combine to unapprove.\n    event CombineUnapproved(uint256 id);\n\n    /// @notice Emitted during applyConversionToAmortization().\n    /// @param  id The loan ID converted to amortization payment schedule.\n    event ConversionToAmortizationApplied(uint256 indexed id);\n\n    /// @notice Emitted during unapproveConversionToAmortization().\n    /// @param  id The loan ID approved for conversion.\n    event ConversionToAmortizationApproved(uint256 indexed id);\n\n    /// @notice Emitted during approveConversionToBullet().\n    /// @param  id The loan ID unapproved for conversion.\n    event ConversionToAmortizationUnapproved(uint256 indexed id);\n\n    /// @notice Emitted during applyConversionToBullet().\n    /// @param  id The loan ID converted to bullet payment schedule.\n    event ConversionToBulletApplied(uint256 indexed id);\n\n    /// @notice Emitted during approveConversionToBullet().\n    /// @param  id The loan ID approved for conversion.\n    event ConversionToBulletApproved(uint256 indexed id);\n\n    /// @notice Emitted during unapproveConversionToBullet().\n    /// @param  id The loan ID unapproved for conversion.\n    event ConversionToBulletUnapproved(uint256 indexed id);\n\n    /// @notice Emitted during markDefault().\n    /// @param id Identifier for the loan which is now \"defaulted\".\n    /// @param principalDefaulted The amount defaulted on.\n    event DefaultMarked(uint256 indexed id, uint256 principalDefaulted);\n\n    /// @notice Emitted during resolveDefault().\n    /// @param id The identifier for the loan in default that is resolved (or partially).\n    /// @param amount The amount of principal paid back.\n    /// @param payee The address responsible for resolving the default.\n    /// @param resolved Denotes if the loan is fully resolved (false if partial).\n    event DefaultResolved(uint256 indexed id, uint256 amount, address indexed payee, bool resolved);\n\n    /// @notice Emitted during applyExtension().\n    /// @param  id The identifier of the loan extending its payment schedule.\n    /// @param  intervals The number of intervals the loan is extended for.\n    event ExtensionApplied(uint256 indexed id, uint256 intervals);\n\n    /// @notice Emitted during approveExtension().\n    /// @param  id The identifier of the loan receiving approval for extension.\n    /// @param  intervals The number of intervals the approved loan may be extended.\n    event ExtensionApproved(uint256 indexed id, uint256 intervals);\n\n    /// @notice Emitted during unapproveExtension().\n    /// @param  id The identifier of the loan losing approval for extension.\n    event ExtensionUnapproved(uint256 indexed id);\n\n    /// @notice Emitted during supplyInterest().\n    /// @param id The identifier for the loan that is supplied additional interest.\n    /// @param amount The amount of interest supplied.\n    /// @param payee The address responsible for supplying additional interest.\n    event InterestSupplied(uint256 indexed id, uint256 amount, address indexed payee);\n\n    /// @notice Emitted during callLoan().\n    /// @param id Identifier for the loan which is called.\n    /// @param amount The total amount of the payment.\n    /// @param interest The interest portion of \"amount\" paid.\n    /// @param principal The principal portion of \"amount\" paid.\n    /// @param lateFee The lateFee portion of \"amount\" paid.\n    event LoanCalled(uint256 indexed id, uint256 amount, uint256 principal, uint256 interest, uint256 lateFee);\n\n    /// @notice Emitted during acceptOffer().\n    /// @param  id Identifier for the offer accepted.\n    /// @param  principal The amount of stablecoin lent out.\n    /// @param  borrower The address borrowing the amount (principal).\n    /// @param  paymentDueBy Timestamp (unix seconds) by which next payment is due.\n    event OfferAccepted(uint256 indexed id, uint256 principal, address indexed borrower, uint256 paymentDueBy);\n\n    /// @notice Emitted during cancelOffer().\n    /// @param  id Identifier for the loan offer cancelled.\n    event OfferCancelled(uint256 indexed id);\n\n    /// @notice Emitted during createOffer().\n    /// @param  borrower        The address borrowing (that will receive the loan).\n    /// @param  id              Identifier for the loan offer created.\n    /// @param  borrowAmount    The amount to borrow (in other words, initial principal).\n    /// @param  APR             The annualized percentage rate charged on the outstanding principal.\n    /// @param  APRLateFee      The APR charged for late payments.\n    /// @param  term            The term or \"duration\" of the loan (number of paymentIntervals that will occur).\n    /// @param  paymentInterval The interval of time between payments (in seconds).\n    /// @param  offerExpiry     The block.timestamp at which the offer for this loan expires (hardcoded 2 weeks).\n    /// @param  gracePeriod     The number of seconds a borrower has to makePayment() before loan could default.\n    /// @param  paymentSchedule The payment schedule type (\"Bullet\" or \"Amortization\").\n    event OfferCreated(\n        address indexed borrower,\n        uint256 indexed id,\n        uint256 borrowAmount,\n        uint256 APR,\n        uint256 APRLateFee,\n        uint256 term,\n        uint256 paymentInterval,\n        uint256 offerExpiry,\n        uint256 gracePeriod,\n        int8 indexed paymentSchedule\n    );\n\n    /// @notice Emitted during makePayment() and processPayment().\n    /// @param id Identifier for the loan on which payment is made.\n    /// @param payee The address which made payment on the loan.\n    /// @param amount The total amount of the payment.\n    /// @param principal The principal portion of \"amount\" paid.\n    /// @param interest The interest portion of \"amount\" paid.\n    /// @param lateFee The lateFee portion of \"amount\" paid.\n    /// @param nextPaymentDue The timestamp by which next payment is due.\n    event PaymentMade(\n        uint256 indexed id, \n        address indexed payee, \n        uint256 amount, \n        uint256 principal, \n        uint256 interest, \n        uint256 lateFee, \n        uint256 nextPaymentDue\n    );\n\n    /// @notice Emitted during applyRefinance().\n    /// @param  id The loan ID refinancing its APR.\n    /// @param  APRNew The new APR of the loan.\n    /// @param  APRPrior The prior APR of the loan.\n    event RefinanceApplied(uint256 indexed id, uint256 APRNew, uint256 APRPrior);\n\n    /// @notice Emitted during approveRefinance().\n    /// @param  id The loan ID approved for refinance.\n    /// @param  APR The APR the loan is approved to refinance to.\n    event RefinanceApproved(uint256 indexed id, uint256 APR);\n\n    /// @notice Emitted during unapproveRefinance().\n    /// @param  id The loan ID unapproved for refinance.\n    event RefinanceUnapproved(uint256 indexed id);\n\n    /// @notice Emitted during markRepaid().\n    /// @param id Identifier for loan which is now \"repaid\".\n    event RepaidMarked(uint256 indexed id);\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n    \n\n    // ---------------\n    //    Modifiers\n    // ---------------\n\n    /// @notice This modifier ensures that the caller is the entity that is allowed to issue loans.\n    modifier isUnderwriter() {\n        require(_msgSender() == underwriter, \"OCC_Modular::isUnderwriter() _msgSender() != underwriter\");\n        _;\n    }\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLocker().\n    function canPush() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pushToLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Returns information for a given loan.\n    /// @dev    Refer to documentation on Loan struct for return param information.\n    /// @param  id The ID of the loan.\n    /// @return borrower The borrower of the loan.\n    /// @return paymentSchedule The structure of the payment schedule.\n    /// @return info The remaining information for the loan:\n    ///                  info[0] = principalOwed\n    ///                  info[1] = APR\n    ///                  info[2] = APRLateFee\n    ///                  info[3] = paymentDueBy\n    ///                  info[4] = paymentsRemaining\n    ///                  info[5] = term\n    ///                  info[6] = paymentInterval\n    ///                  info[7] = offerExpiry\n    ///                  info[8] = gracePeriod\n    ///                  info[9] = loanState\n    function loanInfo(uint256 id) external view returns (\n        address borrower, int8 paymentSchedule, uint256[10] memory info\n    ) {\n        borrower = loans[id].borrower;\n        paymentSchedule = loans[id].paymentSchedule;\n        info[0] = loans[id].principalOwed;\n        info[1] = loans[id].APR;\n        info[2] = loans[id].APRLateFee;\n        info[3] = loans[id].paymentDueBy;\n        info[4] = loans[id].paymentsRemaining;\n        info[5] = loans[id].term;\n        info[6] = loans[id].paymentInterval;\n        info[7] = loans[id].offerExpiry;\n        info[8] = loans[id].gracePeriod;\n        info[9] = uint256(loans[id].state);\n    }\n\n    /// @notice Returns information for amount owed on next payment of a particular loan.\n    /// @param  id The ID of the loan.\n    /// @return principal The amount of principal owed.\n    /// @return interest The amount of interest owed.\n    /// @return lateFee The amount of late fees owed.\n    /// @return total Full amount owed, combining principal plus interest.\n    function amountOwed(uint256 id) public view returns (\n        uint256 principal, uint256 interest, uint256 lateFee, uint256 total\n    ) {\n        // 0 == Bullet.\n        if (loans[id].paymentSchedule == 0) {\n            if (loans[id].paymentsRemaining == 1) { principal = loans[id].principalOwed; }\n        }\n        // 1 == Amortization (only two options, use else here).\n        else { principal = loans[id].principalOwed / loans[id].paymentsRemaining; }\n\n        // Add late fee if past loans[id].paymentDueBy.\n        if (block.timestamp > loans[id].paymentDueBy && loans[id].state == LoanState.Active) {\n            lateFee = loans[id].principalOwed * (block.timestamp - loans[id].paymentDueBy) *\n                loans[id].APRLateFee / (86400 * 365 * BIPS);\n        }\n        interest = loans[id].principalOwed * loans[id].paymentInterval * loans[id].APR / (86400 * 365 * BIPS);\n        total = principal + interest + lateFee;\n    }\n\n    /// @notice Funds and initiates a loan.\n    /// @param  id The ID of the loan.\n    function acceptOffer(uint256 id) external nonReentrant {\n        require(\n            loans[id].state == LoanState.Offered, \n            \"OCC_Modular::acceptOffer() loans[id].state != LoanState.Offered\"\n        );\n        require(\n            block.timestamp < loans[id].offerExpiry, \n            \"OCC_Modular::acceptOffer() block.timestamp >= loans[id].offerExpiry\"\n        );\n        require(\n            _msgSender() == loans[id].borrower, \n            \"OCC_Modular::acceptOffer() _msgSender() != loans[id].borrower\"\n        );\n\n        // \"Friday\" Payment Standardization, minimum 7-day lead-time\n        // block.timestamp - block.timestamp % 7 days + 9 days + paymentInterval\n        emit OfferAccepted(\n            id, \n            loans[id].principalOwed, \n            loans[id].borrower, \n            block.timestamp - block.timestamp % 7 days + 9 days + loans[id].paymentInterval\n        );\n\n        loans[id].state = LoanState.Active;\n        loans[id].paymentDueBy = block.timestamp - block.timestamp % 7 days + 9 days + loans[id].paymentInterval;\n        IERC20(stablecoin).safeTransfer(loans[id].borrower, loans[id].principalOwed);\n    }\n\n    /// @notice Pays off the loan in full, plus additional interest for paymentInterval.\n    /// @dev    Only the \"borrower\" of the loan may elect this option.\n    /// @param  id The loan to pay off early.\n    function callLoan(uint256 id) external nonReentrant {\n        require(\n            _msgSender() == loans[id].borrower || IZivoeGlobals_OCC(GBL).isLocker(_msgSender()), \n            \"OCC_Modular::callLoan() _msgSender() != loans[id].borrower && !isLocker(_msgSender())\"\n        );\n        require(loans[id].state == LoanState.Active, \"OCC_Modular::callLoan() loans[id].state != LoanState.Active\");\n\n        uint256 principalOwed = loans[id].principalOwed;\n        (, uint256 interestOwed, uint256 lateFee,) = amountOwed(id);\n\n        emit LoanCalled(id, principalOwed + interestOwed + lateFee, principalOwed, interestOwed, lateFee);\n\n        // Transfer interest to YDL if in same format, otherwise keep here for 1INCH forwarding.\n        if (stablecoin == IZivoeYDL_OCC(IZivoeGlobals_OCC(GBL).YDL()).distributedAsset()) {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), IZivoeGlobals_OCC(GBL).YDL(), interestOwed + lateFee);\n        }\n        else {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), OCT_YDL, interestOwed + lateFee);\n        }\n\n        IERC20(stablecoin).safeTransferFrom(_msgSender(), owner(), principalOwed);\n\n        loans[id].principalOwed = 0;\n        loans[id].paymentDueBy = 0;\n        loans[id].paymentsRemaining = 0;\n        loans[id].state = LoanState.Repaid;\n    }\n\n    /// @notice Cancels a loan offer.\n    /// @param id The ID of the loan.\n    function cancelOffer(uint256 id) isUnderwriter external {\n        require(\n            loans[id].state == LoanState.Offered, \n            \"OCC_Modular::cancelOffer() loans[id].state != LoanState.Offered\"\n        );\n        emit OfferCancelled(id);\n        loans[id].state = LoanState.Cancelled;\n    }\n\n    /// @notice                 Create a loan offer.\n    /// @param  borrower        The address to borrow (that receives the loan).\n    /// @param  borrowAmount    The amount to borrow (in other words, initial principal).\n    /// @param  APR             The annualized percentage rate charged on the outstanding principal.\n    /// @param  APRLateFee      The APR charged for late payments.\n    /// @param  term            The term or \"duration\" of the loan (number of paymentIntervals that will occur).\n    /// @param  paymentInterval The interval of time between payments (in seconds).\n    /// @param  gracePeriod     The number of seconds a borrower has to makePayment() before loan could default.\n    /// @param  paymentSchedule The payment schedule type (\"Bullet\" or \"Amortization\").\n    function createOffer(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 APR,\n        uint256 APRLateFee,\n        uint256 term,\n        uint256 paymentInterval,\n        uint256 gracePeriod,\n        int8 paymentSchedule\n    ) isUnderwriter external {\n        require(term > 0, \"OCC_Modular::createOffer() term == 0\");\n        require(\n            paymentInterval == 86400 * 7 || paymentInterval == 86400 * 14 || paymentInterval == 86400 * 28 || \n            paymentInterval == 86400 * 91 || paymentInterval == 86400 * 364, \n            \"OCC_Modular::createOffer() invalid paymentInterval value, try: 86400 * (7 || 14 || 28 || 91 || 364)\"\n        );\n        require(gracePeriod >= 7 days, \"OCC_Modular::createOffer() gracePeriod < 7 days\");\n        require(paymentSchedule <= 1, \"OCC_Modular::createOffer() paymentSchedule > 1\");\n\n        emit OfferCreated(\n            borrower, loanCounter, borrowAmount, APR, APRLateFee, term,\n            paymentInterval, block.timestamp + 3 days, gracePeriod, paymentSchedule\n        );\n\n        loans[loanCounter] = Loan(\n            borrower, borrowAmount, APR, APRLateFee, 0, term, term, paymentInterval, block.timestamp + 3 days,\n            gracePeriod, paymentSchedule, LoanState.Offered\n        );\n\n        loanCounter += 1;\n    }\n\n    /// @notice Make a payment on a loan.\n    /// @dev    Anyone is allowed to make a payment on someone's loan.\n    /// @param  id The ID of the loan.\n    function makePayment(uint256 id) external nonReentrant {\n        require(loans[id].state == LoanState.Active, \"OCC_Modular::makePayment() loans[id].state != LoanState.Active\");\n\n        (uint256 principalOwed, uint256 interestOwed, uint256 lateFee,) = amountOwed(id);\n\n        emit PaymentMade(\n            id, _msgSender(), principalOwed + interestOwed + lateFee, principalOwed,\n            interestOwed, lateFee, loans[id].paymentDueBy + loans[id].paymentInterval\n        );\n\n        // Transfer interest + lateFee to YDL if in same format, otherwise keep here for 1INCH forwarding.\n        if (stablecoin == IZivoeYDL_OCC(IZivoeGlobals_OCC(GBL).YDL()).distributedAsset()) {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), IZivoeGlobals_OCC(GBL).YDL(), interestOwed + lateFee);\n        }\n        else {\n            IERC20(stablecoin).safeTransferFrom(_msgSender(), OCT_YDL, interestOwed + lateFee);\n        }\n        if (principalOwed > 0) { IERC20(stablecoin).safeTransferFrom(_msgSender(), owner(), principalOwed); }\n\n        if (loans[id].paymentsRemaining == 1) {\n            loans[id].state = LoanState.Repaid;\n            loans[id].paymentDueBy = 0;\n        }\n        else { loans[id].paymentDueBy += loans[id].paymentInterval; }\n\n        loans[id].principalOwed -= principalOwed;\n        loans[id].paymentsRemaining -= 1;\n    }\n\n    /// @notice Mark a loan insolvent if a payment hasn't been made beyond the corresponding grace period.\n    /// @param  id The ID of the loan.\n    function markDefault(uint256 id) external isUnderwriter {\n        require(loans[id].state == LoanState.Active, \"OCC_Modular::markDefault() loans[id].state != LoanState.Active\");\n        require( \n            loans[id].paymentDueBy + loans[id].gracePeriod < block.timestamp, \n            \"OCC_Modular::markDefault() loans[id].paymentDueBy + loans[id].gracePeriod >= block.timestamp\"\n        );\n        \n        emit DefaultMarked(id, loans[id].principalOwed);\n        loans[id].state = LoanState.Defaulted;\n        IZivoeGlobals_OCC(GBL).increaseDefaults(\n            IZivoeGlobals_OCC(GBL).standardize(loans[id].principalOwed, stablecoin)\n        );\n    }\n\n    /// @notice Underwriter specifies a loan has been repaid fully via interest deposits in terms of off-chain debt.\n    /// @param  id The ID of the loan.\n    function markRepaid(uint256 id) external isUnderwriter {\n        require(\n            loans[id].state == LoanState.Resolved, \n            \"OCC_Modular::markRepaid() loans[id].state != LoanState.Resolved\"\n        );\n        emit RepaidMarked(id);\n        loans[id].state = LoanState.Repaid;\n        loans[id].paymentDueBy = 0;\n    }\n\n    /// @notice Process a payment for a loan, on behalf of another borrower.\n    /// @dev    Only \"keepeers\" and \"underwriter\" can call this function, taking payment from the \"borrower\".\n    /// @dev    Only allowed to call this if block.timestamp > paymentDueBy - 12 hours.\n    /// @param  id The ID of the loan.\n    function processPayment(uint256 id) external nonReentrant {\n        require(\n            _msgSender() == underwriter || IZivoeGlobals_OCC(GBL).isKeeper(_msgSender()),\n            \"OCC_Modular::processPayment() _msgSender() != underwriter && !IZivoeGlobals_OCC(GBL).isKeeper(_msgSender())\"\n        );\n        require(\n            loans[id].state == LoanState.Active, \n            \"OCC_Modular::processPayment() loans[id].state != LoanState.Active\"\n        );\n        require(\n            block.timestamp > loans[id].paymentDueBy - 12 hours, \n            \"OCC_Modular::processPayment() block.timestamp <= loans[id].paymentDueBy - 12 hours\"\n        );\n\n        (uint256 principalOwed, uint256 interestOwed, uint256 lateFee,) = amountOwed(id);\n\n        emit PaymentMade(\n            id, loans[id].borrower, principalOwed + interestOwed + lateFee, principalOwed,\n            interestOwed, lateFee, loans[id].paymentDueBy + loans[id].paymentInterval\n        );\n\n        // Transfer interest to YDL if in same format, otherwise keep here for 1INCH forwarding.\n        if (stablecoin == IZivoeYDL_OCC(IZivoeGlobals_OCC(GBL).YDL()).distributedAsset()) {\n            IERC20(stablecoin).safeTransferFrom(\n                loans[id].borrower, IZivoeGlobals_OCC(GBL).YDL(), interestOwed + lateFee\n            );\n        }\n        else {\n            IERC20(stablecoin).safeTransferFrom(loans[id].borrower, OCT_YDL, interestOwed + lateFee);\n        }\n        \n        if (principalOwed > 0) { IERC20(stablecoin).safeTransferFrom(loans[id].borrower, owner(), principalOwed); }\n\n        if (loans[id].paymentsRemaining == 1) {\n            loans[id].state = LoanState.Repaid;\n            loans[id].paymentDueBy = 0;\n        }\n        else { loans[id].paymentDueBy += loans[id].paymentInterval; }\n\n        loans[id].principalOwed -= principalOwed;\n        loans[id].paymentsRemaining -= 1;\n    }\n\n    /// @notice Make a full (or partial) payment to resolve an insolvent loan.\n    /// @param  id The ID of the loan.\n    /// @param  amount The amount of principal to pay down.\n    function resolveDefault(uint256 id, uint256 amount) external nonReentrant {"
    }
  ]
}