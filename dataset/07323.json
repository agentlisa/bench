{
  "Title": "[L-12] The minimum transaction value of 21,000 gas may change in the future",
  "Content": "\nAny transaction has a 'base fee' of 21,000 gas in order to cover the cost of an elliptic curve operation that recovers the sender address from the signature, as well as the disk space of storing the transaction, according to the Ethereum White Paper.\n\n```solidity\n\ncontracts/smart-contract-wallet/SmartAccount.sol:\n  192:     function execTransaction(\n  193:         Transaction memory _tx,\n  194:         uint256 batchId,\n  195:         FeeRefund memory refundInfo,\n  196:         bytes memory signatures\n  197:     ) public payable virtual override returns (bool success) {\n  198:         // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n  199:         //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n  200:         uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n  201:         //console.log(\"init %s\", 21000 + msg.data.length * 8);\n  202:         bytes32 txHash;\n  203:         // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n  204:         {\n  205:             bytes memory txHashData =\n  206:                 encodeTransactionData(\n  207:                     // Transaction info\n  208:                     _tx,\n  209:                     // Payment info\n  210:                     refundInfo,\n  211:                     // Signature info\n  212:                     nonces[batchId]\n  213:                 );\n  214:             // Increase nonce and execute transaction.\n  215:             // Default space aka batchId is 0\n  216:             nonces[batchId]++;\n  217:             txHash = keccak256(txHashData);\n  218:             checkSignatures(txHash, txHashData, signatures);\n  219:         }\n\n```\n\nhttps://ethereum-magicians.org/t/some-medium-term-dust-cleanup-ideas/6287\n\nWhy do txs cost 21000 gas?<br>\nTo understand how special-purpose cheap withdrawals could be done, it helps first to understand what goes into the 21000 gas in a tx. The cost of processing a tx includes:<br>\n- Two account writes (a balance-editing CALL normally costs 9000 gas)\n- A signature verification (compare: the ECDSA precompile costs 3000 gas)\n- The transaction data (~100 bytes, so 1600 gas, though originally it cost 6800)\n- Some more gas was tacked on to account for transaction-specific overhead, bringing the total to 21000.\n\n[protocol_params.go#L31](https://github.com/ethereum/go-ethereum/blob/b8f9b3779fbdc62d5a935b57f1360608fa4600b4/params/protocol_params.go#L31)\n\nThe minimum transaction value of 21,000 gas may change in the future, so it is recommended to make this value updatable.\n\n### Recommended Mitigation Steps\n\nAdd this code;\n\n```js\n\nuint256 txcost = 21_000;\n\n function changeTxCost(uint256 _amount) public onlyOwner {\n        txcost = _amount;\n    }\n\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "params/protocol_params.go",
      "content": "// Copyright 2015 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage params\n\nimport \"math/big\"\n\nconst (\n\tGasLimitBoundDivisor uint64 = 1024    // The bound divisor of the gas limit, used in update calculations.\n\tMinGasLimit          uint64 = 5000    // Minimum the gas limit may ever be.\n\tGenesisGasLimit      uint64 = 4712388 // Gas limit of the Genesis block.\n\n\tMaximumExtraDataSize  uint64 = 32    // Maximum size extra data may be after Genesis.\n\tExpByteGas            uint64 = 10    // Times ceil(log256(exponent)) for the EXP instruction.\n\tSloadGas              uint64 = 50    // Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added.\n\tCallValueTransferGas  uint64 = 9000  // Paid for CALL when the value transfer is non-zero.\n\tCallNewAccountGas     uint64 = 25000 // Paid for CALL when the destination address didn't exist prior.\n\tTxGas                 uint64 = 21000 // Per transaction not creating a contract. NOTE: Not payable on data of calls between transactions.\n\tTxGasContractCreation uint64 = 53000 // Per transaction that creates a contract. NOTE: Not payable on data of calls between transactions.\n\tTxDataZeroGas         uint64 = 4     // Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions.\n\tQuadCoeffDiv          uint64 = 512   // Divisor for the quadratic particle of the memory cost equation.\n\tLogDataGas            uint64 = 8     // Per byte in a LOG* operation's data.\n\tCallStipend           uint64 = 2300  // Free gas given at beginning of call.\n\n\tSha3Gas     uint64 = 30 // Once per SHA3 operation.\n\tSha3WordGas uint64 = 6  // Once per word of the SHA3 operation's data.\n\n\tSstoreSetGas    uint64 = 20000 // Once per SLOAD operation.\n\tSstoreResetGas  uint64 = 5000  // Once per SSTORE operation if the zeroness changes from zero.\n\tSstoreClearGas  uint64 = 5000  // Once per SSTORE operation if the zeroness doesn't change.\n\tSstoreRefundGas uint64 = 15000 // Once per SSTORE operation if the zeroness changes to zero.\n\n\tNetSstoreNoopGas  uint64 = 200   // Once per SSTORE operation if the value doesn't change.\n\tNetSstoreInitGas  uint64 = 20000 // Once per SSTORE operation from clean zero.\n\tNetSstoreCleanGas uint64 = 5000  // Once per SSTORE operation from clean non-zero.\n\tNetSstoreDirtyGas uint64 = 200   // Once per SSTORE operation from dirty.\n\n\tNetSstoreClearRefund      uint64 = 15000 // Once per SSTORE operation for clearing an originally existing storage slot\n\tNetSstoreResetRefund      uint64 = 4800  // Once per SSTORE operation for resetting to the original non-zero value\n\tNetSstoreResetClearRefund uint64 = 19800 // Once per SSTORE operation for resetting to the original zero value\n\n\tJumpdestGas      uint64 = 1     // Once per JUMPDEST operation.\n\tEpochDuration    uint64 = 30000 // Duration between proof-of-work epochs.\n\tCallGas          uint64 = 40    // Once per CALL operation & message call transaction.\n\tCreateDataGas    uint64 = 200   //\n\tCallCreateDepth  uint64 = 1024  // Maximum depth of call/create stack.\n\tExpGas           uint64 = 10    // Once per EXP instruction\n\tLogGas           uint64 = 375   // Per LOG* operation.\n\tCopyGas          uint64 = 3     //\n\tStackLimit       uint64 = 1024  // Maximum size of VM stack allowed.\n\tTierStepGas      uint64 = 0     // Once per operation, for a selection of them.\n\tLogTopicGas      uint64 = 375   // Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas.\n\tCreateGas        uint64 = 32000 // Once per CREATE operation & contract-creation transaction.\n\tCreate2Gas       uint64 = 32000 // Once per CREATE2 operation\n\tSuicideRefundGas uint64 = 24000 // Refunded following a suicide operation.\n\tMemoryGas        uint64 = 3     // Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL.\n\tTxDataNonZeroGas uint64 = 68    // Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions.\n\n\tMaxCodeSize = 24576 // Maximum bytecode to permit for a contract\n\n\t// Precompiled contract gas prices\n\n\tEcrecoverGas            uint64 = 3000   // Elliptic curve sender recovery gas price\n\tSha256BaseGas           uint64 = 60     // Base price for a SHA256 operation\n\tSha256PerWordGas        uint64 = 12     // Per-word price for a SHA256 operation\n\tRipemd160BaseGas        uint64 = 600    // Base price for a RIPEMD160 operation\n\tRipemd160PerWordGas     uint64 = 120    // Per-word price for a RIPEMD160 operation\n\tIdentityBaseGas         uint64 = 15     // Base price for a data copy operation\n\tIdentityPerWordGas      uint64 = 3      // Per-work price for a data copy operation\n\tModExpQuadCoeffDiv      uint64 = 20     // Divisor for the quadratic particle of the big int modular exponentiation\n\tBn256AddGas             uint64 = 500    // Gas needed for an elliptic curve addition\n\tBn256ScalarMulGas       uint64 = 40000  // Gas needed for an elliptic curve scalar multiplication\n\tBn256PairingBaseGas     uint64 = 100000 // Base price for an elliptic curve pairing check\n\tBn256PairingPerPointGas uint64 = 80000  // Per-point price for an elliptic curve pairing check\n)\n\nvar (\n\tDifficultyBoundDivisor = big.NewInt(2048)   // The bound divisor of the difficulty, used in the update calculations.\n\tGenesisDifficulty      = big.NewInt(131072) // Difficulty of the Genesis block.\n\tMinimumDifficulty      = big.NewInt(131072) // The minimum that the difficulty may ever be.\n\tDurationLimit          = big.NewInt(13)     // The decision boundary on the blocktime duration used to determine whether difficulty should go up or not.\n)"
    }
  ]
}