{
  "Title": "Transceiver invariants and ownership synchronicity can be broken by unsafe Transceiver upgrades",
  "Content": "**Description:** Transceivers are upgradeable contracts integral to the cross-chain message handling of NTT tokens. While `WormholeTransceiver` is a specific implementation of the `Transceiver` contract, NTT Managers can integrate with Transceivers of any custom implementation.\n\n[`Transceiver::_checkImmutables`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/Transceiver/Transceiver.sol#L72-L77) is an internal virtual function that verifies that invariants are not violated during an upgrade. Two checks in this function are that a) the NTT Manager address remains the same and b) the underlying NTT token address remains the same.\n\nHowever, the current logic allows integrators to bypass these checks by either:\n1. Overriding the `_checkImmutables()` function without the above checks.\n2. Calling [`Implementation::_setMigratesImmutables`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/Implementation.sol#L101-L103) with a `true` input. This effectively bypasses the `_checkImmutables()` function validation during an upgrade.\n\nBased on the understanding that Transceivers are deployed by integrators external to NTT Manager owners, regardless of the high trust assumptions associated with integrators, it is risky for NTT Managers to delegate power to Transceivers to silently upgrade a transceiver contract that can potentially violate the NTT Manager invariants.\n\nOne example of this involves the intended ownership model. Within [`Transceiver::_initialize`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/Transceiver/Transceiver.sol#L44-L53), the owner of the Transceiver is set to the owner of the `NttManager` contract:\n```solidity\nfunction _initialize() internal virtual override {\n    // check if the owner is the deployer of this contract\n    if (msg.sender != deployer) {\n        revert UnexpectedDeployer(deployer, msg.sender);\n    }\n\n    __ReentrancyGuard_init();\n    // owner of the transceiver is set to the owner of the nttManager\n    __PausedOwnable_init(msg.sender, getNttManagerOwner());\n}\n```\n\nHowever, the transferring of this ownership via `Transceiver::transferTransceiverOwnership` is only allowed by the NTT Manager itself:\n```solidity\n/// @dev transfer the ownership of the transceiver to a new address\n/// the nttManager should be able to update transceiver ownership.\nfunction transferTransceiverOwnership(address newOwner) external onlyNttManager {\n    _transferOwnership(newOwner);\n}\n```\n\nWhen the owner of the NTT Manager is changed by calling [`NttManagerState::transferOwnership`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManagerState.sol#L193-L203), the owner of all the Transceivers is changed with it:\n```solidity\n/// @notice Transfer ownership of the Manager contract and all Endpoint contracts to a new owner.\nfunction transferOwnership(address newOwner) public override onlyOwner {\n    super.transferOwnership(newOwner);\n    // loop through all the registered transceivers and set the new owner of each transceiver to the newOwner\n    address[] storage _registeredTransceivers = _getRegisteredTransceiversStorage();\n    _checkRegisteredTransceiversInvariants();\n\n    for (uint256 i = 0; i < _registeredTransceivers.length; i++) {\n        ITransceiver(_registeredTransceivers[i]).transferTransceiverOwnership(newOwner);\n    }\n}\n```\n\nThis design is intended to ensure that the NTT Manager's owner is kept in sync across all transceivers, access-controlled to prevent unauthorized ownership changes, but transceiver ownership can still be transferred directly as the public `OwnableUpgradeable::transferOwnership` function has not been overridden. Even if Transceiver ownership changes, the Manager is permitted to change it again via the above function.\n\nHowever, this behavior can be broken if the new owner of a Transceiver performs a contract upgrade without the immutables check. In this way, they can change the NTT Manager, preventing the correct manager from having permissions as expected. As a result, `NttManagerState::transferOwnership` will revert if any one Transceiver is out of sync with the others, and since it is not possible to remove an already registered transceiver, this function will cease to be useful. Instead, each Transceiver will be forced to be manually updated to the new owner unless the modified Transceiver is reset back to the previous owner so that this function can be called again.\n\n**Impact:** While this issue may require the owner of a Transceiver to misbehave, a scenario where a Transceiver is silently upgraded with a new NTT Manager or NTT Manager token can be problematic for cross-chain transfers and so is prescient to note.\n\n**Proof of Concept:** The below PoC calls the `_setMigratesImmutables()` function with the `true` boolean, effectively bypassing the `_checkImmutables()` invariant check. As a result, a subsequent call to `NttManagerState::transferOwnership` is demonstrated to revert. This test should be added to the contract in `Upgrades.t.sol` before running, and the revert in `MockWormholeTransceiverContract::transferOwnership` should be removed to reflect the true functionality.\n\n```solidity\nfunction test_immutableUpgradePoC() public {\n    // create the new mock ntt manager contract\n    NttManager newImpl = new MockNttManagerContract(\n        nttManagerChain1.token(), IManagerBase.Mode.BURNING, chainId1, 1 days, false\n    );\n    MockNttManagerContract newNttManager =\n        MockNttManagerContract(address(new ERC1967Proxy(address(newImpl), \"\")));\n    newNttManager.initialize();\n\n    // transfer transceiver ownership\n    wormholeTransceiverChain1.transferOwnership(makeAddr(\"new transceiver owner\"));\n\n    // create the new transceiver implementation, specifying the new ntt manager\n    WormholeTransceiver wormholeTransceiverChain1Implementation = new MockWormholeTransceiverImmutableAllow(\n        address(newNttManager),\n        address(wormhole),\n        address(relayer),\n        address(0x0),\n        FAST_CONSISTENCY_LEVEL,\n        GAS_LIMIT\n    );\n\n    // perform the transceiver upgrade\n    wormholeTransceiverChain1.upgrade(address(wormholeTransceiverChain1Implementation));\n\n    // ntt manager ownership transfer should fail and revert\n    vm.expectRevert(abi.encodeWithSelector(ITransceiver.CallerNotNttManager.selector, address(this)));\n    nttManagerChain1.transferOwnership(makeAddr(\"new ntt manager owner\"));\n}\n```\n\n**Recommended Mitigation:** Consider making `Transceiver::_checkImmutables` and `Implementation::_setMigratesImmutables` private functions for Transceivers. If the `_checkImmutables()` function has to be overridden, consider exposing another function that is called inside `_checkImmutables` as follows:\n\n```solidity\nfunction _checkImmutables() private view override {\n    assert(this.nttManager() == nttManager);\n    assert(this.nttManagerToken() == nttManagerToken);\n   _checkAdditionalImmutables();\n}\n\nfunction _checkAdditionalImmutables() private view virtual override {}\n```\n\n**Wormhole Foundation:** The manager is a trusted entity and will not deliberately break their own upgrades. The manager has the ability to set the owner for any transceiver, although most NTT deployments will likely share the same owner across all supported transceivers\n\n**Cyfrin:** Acknowledged.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/Transceiver/Transceiver.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"wormhole-solidity-sdk/Utils.sol\";\n\nimport \"../libraries/TransceiverStructs.sol\";\nimport \"../libraries/PausableOwnable.sol\";\nimport \"../libraries/external/ReentrancyGuardUpgradeable.sol\";\nimport \"../libraries/Implementation.sol\";\n\nimport \"../interfaces/INttManager.sol\";\nimport \"../interfaces/ITransceiver.sol\";\n\nabstract contract Transceiver is\n    ITransceiver,\n    PausableOwnable,\n    ReentrancyGuardUpgradeable,\n    Implementation\n{\n    /// @dev updating bridgeNttManager requires a new Transceiver deployment.\n    /// Projects should implement their own governance to remove the old Transceiver\n    /// contract address and then add the new one.\n    address public immutable nttManager;\n    address public immutable nttManagerToken;\n    address immutable deployer;\n\n    constructor(address _nttManager) {\n        nttManager = _nttManager;\n        nttManagerToken = INttManager(nttManager).token();\n        deployer = msg.sender;\n    }\n\n    /// =============== MODIFIERS ===============================================\n\n    modifier onlyNttManager() {\n        if (msg.sender != nttManager) {\n            revert CallerNotNttManager(msg.sender);\n        }\n        _;\n    }\n\n    /// =============== ADMIN ===============================================\n\n    function _initialize() internal virtual override {\n        // check if the owner is the deployer of this contract\n        if (msg.sender != deployer) {\n            revert UnexpectedDeployer(deployer, msg.sender);\n        }\n\n        __ReentrancyGuard_init();\n        // owner of the transceiver is set to the owner of the nttManager\n        __PausedOwnable_init(msg.sender, getNttManagerOwner());\n    }\n\n    /// @dev transfer the ownership of the transceiver to a new address\n    /// the nttManager should be able to update transceiver ownership.\n    function transferTransceiverOwnership(address newOwner) external onlyNttManager {\n        _transferOwnership(newOwner);\n    }\n\n    /// @dev pause the transceiver.\n    function _pauseTransceiver() internal {\n        _pause();\n    }\n\n    function upgrade(address newImplementation) external onlyOwner {\n        _upgrade(newImplementation);\n    }\n\n    function _migrate() internal virtual override {}\n\n    // @define This method checks that the the referecnes to the nttManager and its corresponding function\n    // are correct When new immutable variables are added, this function should be updated.\n    function _checkImmutables() internal view virtual override {\n        assert(this.nttManager() == nttManager);\n        assert(this.nttManagerToken() == nttManagerToken);\n    }\n\n    /// =============== GETTERS & SETTERS ===============================================\n\n    function getNttManagerOwner() public view returns (address) {\n        return IOwnableUpgradeable(nttManager).owner();\n    }\n\n    function getNttManagerToken() public view virtual returns (address) {\n        return nttManagerToken;\n    }\n\n    /// =============== TRANSCEIVING LOGIC ===============================================\n\n    /// @inheritdoc ITransceiver\n    function quoteDeliveryPrice(\n        uint16 targetChain,\n        TransceiverStructs.TransceiverInstruction memory instruction\n    ) external view returns (uint256) {\n        return _quoteDeliveryPrice(targetChain, instruction);\n    }\n\n    /// @inheritdoc ITransceiver\n    function sendMessage(\n        uint16 recipientChain,\n        TransceiverStructs.TransceiverInstruction memory instruction,\n        bytes memory nttManagerMessage,\n        bytes32 recipientNttManagerAddress\n    ) external payable nonReentrant onlyNttManager {\n        _sendMessage(\n            recipientChain,\n            msg.value,\n            msg.sender,\n            recipientNttManagerAddress,\n            instruction,\n            nttManagerMessage\n        );\n    }\n\n    /// ============================= INTERNAL =========================================\n\n    function _sendMessage(\n        uint16 recipientChain,\n        uint256 deliveryPayment,\n        address caller,\n        bytes32 recipientNttManagerAddress,\n        TransceiverStructs.TransceiverInstruction memory transceiverInstruction,\n        bytes memory nttManagerMessage\n    ) internal virtual;\n\n    // @define This method is called by the BridgeNttManager contract to send a cross-chain message.\n    // @reverts if:\n    //     - `recipientNttManagerAddress` does not match the address of this manager contract\n    function _deliverToNttManager(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        bytes32 recipientNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory payload\n    ) internal virtual {\n        if (recipientNttManagerAddress != toWormholeFormat(nttManager)) {\n            revert UnexpectedRecipientNttManagerAddress(\n                toWormholeFormat(nttManager), recipientNttManagerAddress\n            );\n        }\n        INttManager(nttManager).attestationReceived(sourceChainId, sourceNttManagerAddress, payload);\n    }\n\n    function _quoteDeliveryPrice(\n        uint16 targetChain,\n        TransceiverStructs.TransceiverInstruction memory transceiverInstruction\n    ) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "evm/src/libraries/Implementation.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"./external/Initializable.sol\";\nimport \"openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\n\n/// @dev This contract should be used as a base contract for implementation contracts\n///      that are used with ERC1967Proxy.\n///      It ensures that the contract cannot be initialized directly, only through\n///      the proxy (by disabling initializers in the constructor).\n///      It also exposes a migrate function that is called during upgrades.\nabstract contract Implementation is Initializable, ERC1967Upgrade {\n    address immutable _this;\n\n    error OnlyDelegateCall();\n    error NotMigrating();\n\n    constructor() {\n        _disableInitializers();\n        _this = address(this);\n    }\n\n    modifier onlyDelegateCall() {\n        _checkDelegateCall();\n        _;\n    }\n\n    struct _Migrating {\n        bool isMigrating;\n    }\n\n    struct _Bool {\n        bool value;\n    }\n\n    bytes32 private constant MIGRATING_SLOT = bytes32(uint256(keccak256(\"ntt.migrating\")) - 1);\n\n    bytes32 private constant MIGRATES_IMMUTABLES_SLOT =\n        bytes32(uint256(keccak256(\"ntt.migratesImmutables\")) - 1);\n\n    function _getMigratingStorage() private pure returns (_Migrating storage $) {\n        uint256 slot = uint256(MIGRATING_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getMigratesImmutablesStorage() internal pure returns (_Bool storage $) {\n        uint256 slot = uint256(MIGRATES_IMMUTABLES_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _checkDelegateCall() internal view {\n        if (address(this) == _this) {\n            revert OnlyDelegateCall();\n        }\n    }\n\n    function initialize() external onlyDelegateCall initializer {\n        _initialize();\n    }\n\n    function migrate() external onlyDelegateCall reinitializer(_getInitializedVersion() + 1) {\n        // NOTE: we add the reinitializer() modifier so that onlyInitializing\n        // functions can be called inside\n        if (!_getMigratingStorage().isMigrating) {\n            revert NotMigrating();\n        }\n        _migrate();\n    }\n\n    function _migrate() internal virtual;\n\n    function _initialize() internal virtual;\n\n    function _checkImmutables() internal view virtual;\n\n    function _upgrade(address newImplementation) internal {\n        _checkDelegateCall();\n        _upgradeTo(newImplementation);\n\n        _Migrating storage _migrating = _getMigratingStorage();\n        assert(!_migrating.isMigrating);\n        _migrating.isMigrating = true;\n\n        this.migrate();\n        if (!this.getMigratesImmutables()) {\n            _checkImmutables();\n        }\n        _setMigratesImmutables(false);\n\n        _migrating.isMigrating = false;\n    }\n\n    function getMigratesImmutables() public view returns (bool) {\n        return _getMigratesImmutablesStorage().value;\n    }\n\n    function _setMigratesImmutables(bool value) internal {\n        _getMigratesImmutablesStorage().value = value;\n    }\n}"
    },
    {
      "filename": "evm/src/Transceiver/Transceiver.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"wormhole-solidity-sdk/Utils.sol\";\n\nimport \"../libraries/TransceiverStructs.sol\";\nimport \"../libraries/PausableOwnable.sol\";\nimport \"../libraries/external/ReentrancyGuardUpgradeable.sol\";\nimport \"../libraries/Implementation.sol\";\n\nimport \"../interfaces/INttManager.sol\";\nimport \"../interfaces/ITransceiver.sol\";\n\nabstract contract Transceiver is\n    ITransceiver,\n    PausableOwnable,\n    ReentrancyGuardUpgradeable,\n    Implementation\n{\n    /// @dev updating bridgeNttManager requires a new Transceiver deployment.\n    /// Projects should implement their own governance to remove the old Transceiver\n    /// contract address and then add the new one.\n    address public immutable nttManager;\n    address public immutable nttManagerToken;\n    address immutable deployer;\n\n    constructor(address _nttManager) {\n        nttManager = _nttManager;\n        nttManagerToken = INttManager(nttManager).token();\n        deployer = msg.sender;\n    }\n\n    /// =============== MODIFIERS ===============================================\n\n    modifier onlyNttManager() {\n        if (msg.sender != nttManager) {\n            revert CallerNotNttManager(msg.sender);\n        }\n        _;\n    }\n\n    /// =============== ADMIN ===============================================\n\n    function _initialize() internal virtual override {\n        // check if the owner is the deployer of this contract\n        if (msg.sender != deployer) {\n            revert UnexpectedDeployer(deployer, msg.sender);\n        }\n\n        __ReentrancyGuard_init();\n        // owner of the transceiver is set to the owner of the nttManager\n        __PausedOwnable_init(msg.sender, getNttManagerOwner());\n    }\n\n    /// @dev transfer the ownership of the transceiver to a new address\n    /// the nttManager should be able to update transceiver ownership.\n    function transferTransceiverOwnership(address newOwner) external onlyNttManager {\n        _transferOwnership(newOwner);\n    }\n\n    /// @dev pause the transceiver.\n    function _pauseTransceiver() internal {\n        _pause();\n    }\n\n    function upgrade(address newImplementation) external onlyOwner {\n        _upgrade(newImplementation);\n    }\n\n    function _migrate() internal virtual override {}\n\n    // @define This method checks that the the referecnes to the nttManager and its corresponding function\n    // are correct When new immutable variables are added, this function should be updated.\n    function _checkImmutables() internal view virtual override {\n        assert(this.nttManager() == nttManager);\n        assert(this.nttManagerToken() == nttManagerToken);\n    }\n\n    /// =============== GETTERS & SETTERS ===============================================\n\n    function getNttManagerOwner() public view returns (address) {\n        return IOwnableUpgradeable(nttManager).owner();\n    }\n\n    function getNttManagerToken() public view virtual returns (address) {\n        return nttManagerToken;\n    }\n\n    /// =============== TRANSCEIVING LOGIC ===============================================\n\n    /// @inheritdoc ITransceiver\n    function quoteDeliveryPrice(\n        uint16 targetChain,\n        TransceiverStructs.TransceiverInstruction memory instruction\n    ) external view returns (uint256) {\n        return _quoteDeliveryPrice(targetChain, instruction);\n    }\n\n    /// @inheritdoc ITransceiver\n    function sendMessage(\n        uint16 recipientChain,\n        TransceiverStructs.TransceiverInstruction memory instruction,\n        bytes memory nttManagerMessage,\n        bytes32 recipientNttManagerAddress\n    ) external payable nonReentrant onlyNttManager {\n        _sendMessage(\n            recipientChain,\n            msg.value,\n            msg.sender,\n            recipientNttManagerAddress,\n            instruction,\n            nttManagerMessage\n        );\n    }\n\n    /// ============================= INTERNAL =========================================\n\n    function _sendMessage(\n        uint16 recipientChain,\n        uint256 deliveryPayment,\n        address caller,\n        bytes32 recipientNttManagerAddress,\n        TransceiverStructs.TransceiverInstruction memory transceiverInstruction,\n        bytes memory nttManagerMessage\n    ) internal virtual;\n\n    // @define This method is called by the BridgeNttManager contract to send a cross-chain message.\n    // @reverts if:\n    //     - `recipientNttManagerAddress` does not match the address of this manager contract\n    function _deliverToNttManager(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        bytes32 recipientNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory payload\n    ) internal virtual {\n        if (recipientNttManagerAddress != toWormholeFormat(nttManager)) {\n            revert UnexpectedRecipientNttManagerAddress(\n                toWormholeFormat(nttManager), recipientNttManagerAddress\n            );\n        }\n        INttManager(nttManager).attestationReceived(sourceChainId, sourceNttManagerAddress, payload);\n    }\n\n    function _quoteDeliveryPrice(\n        uint16 targetChain,\n        TransceiverStructs.TransceiverInstruction memory transceiverInstruction\n    ) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "evm/src/NttManager/NttManagerState.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"wormhole-solidity-sdk/Utils.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\n\nimport \"../libraries/external/OwnableUpgradeable.sol\";\nimport \"../libraries/external/ReentrancyGuardUpgradeable.sol\";\nimport \"../libraries/TransceiverStructs.sol\";\nimport \"../libraries/TransceiverHelpers.sol\";\nimport \"../libraries/RateLimiter.sol\";\nimport \"../libraries/PausableOwnable.sol\";\nimport \"../libraries/Implementation.sol\";\nimport \"../libraries/TrimmedAmount.sol\";\n\nimport \"../interfaces/INttManager.sol\";\nimport \"../interfaces/INttManagerState.sol\";\nimport \"../interfaces/INttManagerEvents.sol\";\nimport \"../interfaces/INTTToken.sol\";\nimport \"../interfaces/ITransceiver.sol\";\n\nimport \"./TransceiverRegistry.sol\";\n\nabstract contract NttManagerState is\n    INttManagerState,\n    INttManagerEvents,\n    RateLimiter,\n    TransceiverRegistry,\n    PausableOwnable,\n    ReentrancyGuardUpgradeable,\n    Implementation\n{\n    using TrimmedAmountLib for uint256;\n    using TrimmedAmountLib for TrimmedAmount;\n    // =============== Immutables ============================================================\n\n    address public immutable token;\n    address immutable deployer;\n    INttManager.Mode public immutable mode;\n    uint16 public immutable chainId;\n    uint256 immutable evmChainId;\n    uint8 public immutable tokenDecimals_;\n\n    // =============== Setup =================================================================\n\n    constructor(\n        address _token,\n        INttManager.Mode _mode,\n        uint16 _chainId,\n        uint64 _rateLimitDuration,\n        bool _skipRateLimiting\n    ) RateLimiter(_rateLimitDuration, _skipRateLimiting) {\n        token = _token;\n        tokenDecimals_ = _initializeTokenDecimals();\n        mode = _mode;\n        chainId = _chainId;\n        evmChainId = block.chainid;\n        // save the deployer (check this on initialization)\n        deployer = msg.sender;\n    }\n\n    function __NttManager_init() internal onlyInitializing {\n        // check if the owner is the deployer of this contract\n        if (msg.sender != deployer) {\n            revert UnexpectedDeployer(deployer, msg.sender);\n        }\n        __PausedOwnable_init(msg.sender, msg.sender);\n        __ReentrancyGuard_init();\n        _setOutboundLimit(TrimmedAmountLib.max(tokenDecimals_));\n    }\n\n    function _initialize() internal virtual override {\n        __NttManager_init();\n        _checkThresholdInvariants();\n        _checkTransceiversInvariants();\n    }\n\n    function _migrate() internal virtual override {\n        _checkThresholdInvariants();\n        _checkTransceiversInvariants();\n    }\n\n    // =============== Storage ==============================================================\n\n    bytes32 private constant MESSAGE_ATTESTATIONS_SLOT =\n        bytes32(uint256(keccak256(\"ntt.messageAttestations\")) - 1);\n\n    bytes32 private constant MESSAGE_SEQUENCE_SLOT =\n        bytes32(uint256(keccak256(\"ntt.messageSequence\")) - 1);\n\n    bytes32 private constant PEERS_SLOT = bytes32(uint256(keccak256(\"ntt.peers\")) - 1);\n\n    bytes32 private constant THRESHOLD_SLOT = bytes32(uint256(keccak256(\"ntt.threshold\")) - 1);\n\n    // =============== Storage Getters/Setters ==============================================\n\n    function _getThresholdStorage() private pure returns (INttManager._Threshold storage $) {\n        uint256 slot = uint256(THRESHOLD_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getMessageAttestationsStorage()\n        internal\n        pure\n        returns (mapping(bytes32 => INttManager.AttestationInfo) storage $)\n    {\n        uint256 slot = uint256(MESSAGE_ATTESTATIONS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getMessageSequenceStorage() internal pure returns (INttManager._Sequence storage $) {\n        uint256 slot = uint256(MESSAGE_SEQUENCE_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _getPeersStorage()\n        internal\n        pure\n        returns (mapping(uint16 => NttManagerPeer) storage $)\n    {\n        uint256 slot = uint256(PEERS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    // =============== Public Getters ========================================================\n\n    /// @inheritdoc INttManagerState\n    function getMode() public view returns (uint8) {\n        return uint8(mode);\n    }\n\n    /// @inheritdoc INttManagerState\n    function getThreshold() public view returns (uint8) {\n        return _getThresholdStorage().num;\n    }\n\n    /// @inheritdoc INttManagerState\n    function isMessageApproved(bytes32 digest) public view returns (bool) {\n        uint8 threshold = getThreshold();\n        return messageAttestations(digest) >= threshold && threshold > 0;\n    }\n\n    /// @inheritdoc INttManagerState\n    function nextMessageSequence() external view returns (uint64) {\n        return _getMessageSequenceStorage().num;\n    }\n\n    /// @inheritdoc INttManagerState\n    function isMessageExecuted(bytes32 digest) public view returns (bool) {\n        return _getMessageAttestationsStorage()[digest].executed;\n    }\n\n    /// @inheritdoc INttManagerState\n    function getPeer(uint16 chainId_) external view returns (NttManagerPeer memory) {\n        return _getPeersStorage()[chainId_];\n    }\n\n    /// @inheritdoc INttManagerState\n    function transceiverAttestedToMessage(bytes32 digest, uint8 index) public view returns (bool) {\n        return\n            _getMessageAttestationsStorage()[digest].attestedTransceivers & uint64(1 << index) > 0;\n    }\n\n    /// @inheritdoc INttManagerState\n    function messageAttestations(bytes32 digest) public view returns (uint8 count) {\n        return countSetBits(_getMessageAttestations(digest));\n    }\n\n    // =============== ADMIN ==============================================================\n\n    /// @inheritdoc INttManagerState\n    function upgrade(address newImplementation) external onlyOwner {\n        _upgrade(newImplementation);\n    }\n\n    /// @inheritdoc INttManagerState\n    function pause() public onlyOwnerOrPauser {\n        _pause();\n    }\n\n    /// @notice Transfer ownership of the Manager contract and all Endpoint contracts to a new owner.\n    function transferOwnership(address newOwner) public override onlyOwner {\n        super.transferOwnership(newOwner);\n        // loop through all the registered transceivers and set the new owner of each transceiver to the newOwner\n        address[] storage _registeredTransceivers = _getRegisteredTransceiversStorage();\n        _checkRegisteredTransceiversInvariants();\n\n        for (uint256 i = 0; i < _registeredTransceivers.length; i++) {\n            ITransceiver(_registeredTransceivers[i]).transferTransceiverOwnership(newOwner);\n        }\n    }\n\n    /// @inheritdoc INttManagerState\n    function setTransceiver(address transceiver) external onlyOwner {\n        _setTransceiver(transceiver);\n\n        INttManager._Threshold storage _threshold = _getThresholdStorage();\n        // We do not automatically increase the threshold here.\n        // Automatically increasing the threshold can result in a scenario\n        // where in-flight messages can't be redeemed.\n        // For example: Assume there is 1 Transceiver and the threshold is 1.\n        // If we were to add a new Transceiver, the threshold would increase to 2.\n        // However, all messages that are either in-flight or that are sent on\n        // a source chain that does not yet have 2 Transceivers will only have been\n        // sent from a single transceiver, so they would never be able to get\n        // redeemed.\n        // Instead, we leave it up to the owner to manually update the threshold\n        // after some period of time, ideally once all chains have the new Transceiver\n        // and transfers that were sent via the old configuration are all complete.\n        // However if the threshold is 0 (the initial case) we do increment to 1.\n        if (_threshold.num == 0) {\n            _threshold.num = 1;\n        }\n\n        emit TransceiverAdded(transceiver, _getNumTransceiversStorage().enabled, _threshold.num);\n    }\n\n    /// @inheritdoc INttManagerState\n    function removeTransceiver(address transceiver) external onlyOwner {\n        _removeTransceiver(transceiver);\n\n        INttManager._Threshold storage _threshold = _getThresholdStorage();\n        uint8 numEnabledTransceivers = _getNumTransceiversStorage().enabled;\n\n        if (numEnabledTransceivers < _threshold.num) {\n            _threshold.num = numEnabledTransceivers;\n        }\n\n        emit TransceiverRemoved(transceiver, _threshold.num);\n    }\n\n    /// @inheritdoc INttManagerState\n    function setThreshold(uint8 threshold) external onlyOwner {\n        if (threshold == 0) {\n            revert ZeroThreshold();\n        }\n\n        INttManager._Threshold storage _threshold = _getThresholdStorage();\n        uint8 oldThreshold = _threshold.num;\n\n        _threshold.num = threshold;\n        _checkThresholdInvariants();\n\n        emit ThresholdChanged(oldThreshold, threshold);\n    }\n\n    /// @inheritdoc INttManagerState\n    function setPeer(uint16 peerChainId, bytes32 peerContract, uint8 decimals) public onlyOwner {\n        if (peerChainId == 0) {\n            revert InvalidPeerChainIdZero();\n        }\n        if (peerContract == bytes32(0)) {\n            revert InvalidPeerZeroAddress();\n        }\n        if (decimals == 0) {\n            revert InvalidPeerDecimals();\n        }\n\n        NttManagerPeer memory oldPeer = _getPeersStorage()[peerChainId];\n\n        _getPeersStorage()[peerChainId].peerAddress = peerContract;\n        _getPeersStorage()[peerChainId].tokenDecimals = decimals;\n\n        _setInboundLimit(TrimmedAmountLib.max(tokenDecimals_), peerChainId);\n\n        emit PeerUpdated(\n            peerChainId, oldPeer.peerAddress, oldPeer.tokenDecimals, peerContract, decimals\n        );\n    }\n\n    /// @inheritdoc INttManagerState\n    function setOutboundLimit(uint256 limit) external onlyOwner {\n        _setOutboundLimit(limit.trim(tokenDecimals_, tokenDecimals_));\n    }\n\n    /// @inheritdoc INttManagerState\n    function setInboundLimit(uint256 limit, uint16 chainId_) external onlyOwner {\n        _setInboundLimit(limit.trim(tokenDecimals_, tokenDecimals_), chainId_);\n    }\n\n    // =============== Internal ==============================================================\n\n    function _setTransceiverAttestedToMessage(bytes32 digest, uint8 index) internal {\n        _getMessageAttestationsStorage()[digest].attestedTransceivers |= uint64(1 << index);\n    }\n\n    function _setTransceiverAttestedToMessage(bytes32 digest, address transceiver) internal {\n        _setTransceiverAttestedToMessage(digest, _getTransceiverInfosStorage()[transceiver].index);\n\n        emit MessageAttestedTo(\n            digest, transceiver, _getTransceiverInfosStorage()[transceiver].index\n        );\n    }\n\n    /// @dev Returns the bitmap of attestations from enabled transceivers for a given message.\n    function _getMessageAttestations(bytes32 digest) internal view returns (uint64) {\n        uint64 enabledTransceiverBitmap = _getEnabledTransceiversBitmap();\n        return\n            _getMessageAttestationsStorage()[digest].attestedTransceivers & enabledTransceiverBitmap;\n    }\n\n    function _getEnabledTransceiverAttestedToMessage(\n        bytes32 digest,\n        uint8 index\n    ) internal view returns (bool) {\n        return _getMessageAttestations(digest) & uint64(1 << index) != 0;\n    }\n\n    /// @dev Verify that the peer address saved for `sourceChainId` matches the `peerAddress`.\n    function _verifyPeer(uint16 sourceChainId, bytes32 peerAddress) internal view {\n        if (_getPeersStorage()[sourceChainId].peerAddress != peerAddress) {\n            revert InvalidPeer(sourceChainId, peerAddress);\n        }\n    }\n\n    // @dev Mark a message as executed.\n    // This function will retuns `true` if the message has already been executed.\n    function _replayProtect(bytes32 digest) internal returns (bool) {\n        // check if this message has already been executed\n        if (isMessageExecuted(digest)) {\n            return true;\n        }\n\n        // mark this message as executed\n        _getMessageAttestationsStorage()[digest].executed = true;\n\n        return false;\n    }\n\n    function _useMessageSequence() internal returns (uint64 currentSequence) {\n        currentSequence = _getMessageSequenceStorage().num;\n        _getMessageSequenceStorage().num++;\n    }\n\n    function _initializeTokenDecimals() internal view returns (uint8) {\n        (, bytes memory queriedDecimals) = token.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        return abi.decode(queriedDecimals, (uint8));\n    }\n\n    /// ============== Invariants =============================================\n\n    /// @dev When we add new immutables, this function should be updated\n    function _checkImmutables() internal view override {\n        assert(this.token() == token);\n        assert(this.tokenDecimals_() == tokenDecimals_);\n        assert(this.mode() == mode);\n        assert(this.chainId() == chainId);\n        assert(this.rateLimitDuration() == rateLimitDuration);\n    }\n\n    function _checkRegisteredTransceiversInvariants() internal view {\n        if (_getRegisteredTransceiversStorage().length != _getNumTransceiversStorage().registered) {\n            revert RetrievedIncorrectRegisteredTransceivers(\n                _getRegisteredTransceiversStorage().length, _getNumTransceiversStorage().registered\n            );\n        }\n    }\n\n    function _checkThresholdInvariants() internal view {\n        uint8 threshold = _getThresholdStorage().num;\n        _NumTransceivers memory numTransceivers = _getNumTransceiversStorage();\n\n        // invariant: threshold <= enabledTransceivers.length\n        if (threshold > numTransceivers.enabled) {\n            revert ThresholdTooHigh(threshold, numTransceivers.enabled);\n        }\n\n        if (numTransceivers.registered > 0) {\n            if (threshold == 0) {\n                revert ZeroThreshold();\n            }\n        }\n    }\n}"
    }
  ]
}