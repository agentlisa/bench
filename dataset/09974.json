{
  "Title": "[M-07] Fee-on-transfer token donations in `Shelter` break withdrawals",
  "Content": "_Submitted by cmichel, also found by Dravee, IllIllI, and Ruhum_\n\n[Shelter.sol#L34](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L34)<br>\n\nThe `Sheler.donate` function `transferFrom`s `_amount` and adds the entire `_amount` to `savedTokens[_token]`.<br>\nBut the actual received token amount from the transfer can be less for fee-on-transfer tokens.\n\nThe last person to withdraw will not be able to as `withdraw` uses a share computation for the entire `savedTokens[_token]` amount.<br>\nThe calculated `amount` will then be higher than the actual contract balance.\n\n```solidity\nfunction donate(IERC20 _token, uint256 _amount) external {\n    require(activated[_token] != 0, \"!activated\");\n    savedTokens[_token] += _amount;\n    // @audit fee-on-transfer. then fails for last person in `withdraw`\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n}\n\nfunction withdraw(IERC20 _token, address _to) external override {\n    // @audit percentage on storage var, not on actual balance\n    uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n    // @audit amount might not be in contract anymore as savedTokens[_token] is over-reported\n    _token.safeTransfer(_to, amount);\n}\n```\n\n### Recommended Mitigation Steps\n\nIn `donate`, add only the actual transferred amounts (computed by `post-transfer balance - pre-transfer balance`) to `savedTokens[_token]`.\n\n**[leekt (Concur) acknowledged](https://github.com/code-423n4/2022-02-concur-findings/issues/180)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/180#issuecomment-1088119261):**\n > The warden has identified a specific interaction between a `feeOnTransfer` token and the Shelter Contract.\n> \n> Because the Shelter Contract can receive any token, and anyone could claim them based on percentage, and because some people will lose the ability to claim due to the internal accounting being incorrect, I believe that in this instance the finding is valid, and of medium severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/Shelter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IShelter } from \"./interfaces/IShelter.sol\";\nimport { IShelterClient } from \"./interfaces/IShelterClient.sol\";\n\ncontract Shelter is IShelter {\n    using SafeERC20 for IERC20;\n\n    IShelterClient public immutable client;\n\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    mapping(IERC20 => mapping(address => bool)) public override claimed;\n\n    mapping(IERC20 => uint256) public activated;\n\n    mapping(IERC20 => uint256) public savedTokens;\n\n    modifier onlyClient {\n        require(msg.sender == address(client), \"!client\");\n        _;\n    }\n\n    constructor(IShelterClient _client){\n        client = _client;\n    }\n\n    function donate(IERC20 _token, uint256 _amount) external {\n        require(activated[_token] != 0, \"!activated\");\n        savedTokens[_token] += _amount;\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function activate(IERC20 _token) external override onlyClient {\n        activated[_token] = block.timestamp;\n        savedTokens[_token] = _token.balanceOf(address(this));\n        emit ShelterActivated(_token);\n    }\n\n    function deactivate(IERC20 _token) external override onlyClient {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\");\n        activated[_token] = 0;\n        savedTokens[_token] = 0;\n        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));\n        emit ShelterDeactivated(_token);\n    }\n\n    function withdraw(IERC20 _token, address _to) external override {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");\n        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n        claimed[_token][_to] = true;\n        emit ExitShelter(_token, msg.sender, _to, amount);\n        _token.safeTransfer(_to, amount);\n    }\n}"
    }
  ]
}