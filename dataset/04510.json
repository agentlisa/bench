{
  "Title": "Lack of check might lead to gasÂ burn",
  "Content": "The [`incrementMinterAllowance`](https://github.com/centrehq/centre-tokens/blob/4b9ebf3941a48e41e7363fee729035610a71ca66/contracts/minting/MintController.sol#L92) function can be called with a parameter value of `allowanceIncrement = 0`. This would lead to gas expenditure with no state changes or useful computation.\n\n\nConsider checking that `allowanceIncrement > 0` to avoid unnecessary gas costs.\n\n\n***Update:*** *the* `incrementMinterAllowance` *function* [*now requires*](https://github.com/centrehq/centre-tokens/blob/fbb6cfeb503ece6719cd456f82e6ef1602145db3/contracts/minting/MintController.sol#L153) *that its (renamed)* `_allowanceIncrement` *parameter is greater than* `0`*.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/minting/MintController.sol",
      "content": "/**\n* Copyright CENTRE SECZ 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is furnished to\n* do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\npragma solidity ^0.4.24;\n\nimport './Controller.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\n\n// Using an interface for managing minters so that MintController\n// can be used for managing minters with different contracts.\ninterface MinterManagementInterface {\n    function isMinter(address account) external view returns (bool);\n    function minterAllowance(address minter) external view returns (uint256);\n    function configureMinter(address minter, uint256 minterAllowedAmount) external returns (bool);\n    function removeMinter(address minter) external returns (bool);\n}\n\n/**\n * @title MintController\n * @dev allows control of configure/remove minter by different addresses\n *\n */\ncontract MintController is Controller {\n    using SafeMath for uint256;\n\n    MinterManagementInterface public minterManager;\n\n    event MinterManagerSet(address indexed oldMinterManager, address indexed newMinterManager);\n    event MinterConfigured(address indexed msgSender, address indexed minter, uint256 allowance);\n    event MinterRemoved(address indexed msgSender, address indexed minter);\n    event MinterAllowanceIncrement(address indexed msgSender, address indexed minter, uint256 increment, uint256 newAllowance);\n\n    constructor(address _minterManager) public {\n        minterManager =  MinterManagementInterface(_minterManager);\n    }\n\n    // onlyOwner functions\n\n    /**\n     * @dev sets the minterManager\n     */\n    function setMinterManager(address _newMinterManager) onlyOwner public returns (bool) {\n        emit MinterManagerSet(minterManager, _newMinterManager);\n        minterManager = MinterManagementInterface(_newMinterManager);\n        return true;\n    }\n\n    // onlyController functions\n\n    /**\n     * @dev remove the controller's minter.\n     */\n    function removeMinter() onlyController public returns (bool) {\n        address minter = controllers[msg.sender];\n        emit MinterRemoved(msg.sender, minter);\n        return minterManager.removeMinter(minter);\n    }\n\n    /**\n     * @dev Enables the minter and sets its allowance\n     */\n    function configureMinter(uint256 newAllowance) onlyController public returns (bool) {\n        address minter = controllers[msg.sender];\n        emit MinterConfigured(msg.sender, minter, newAllowance);\n        return internal_setMinterAllowance(minter, newAllowance);\n    }\n\n     /**\n     * @dev Increases the minter allowance if and only if the minter is\n     * currently active. The controller can safely send a signed incrementMinterAllowance()\n     * transaction to a minter and not worry about it being used to undo a removeMinter()\n     * transaction.\n     */\n     function incrementMinterAllowance(uint256 allowanceIncrement) onlyController public returns (bool) {\n        address minter = controllers[msg.sender];\n        require(minterManager.isMinter(minter));\n\n        uint256 currentAllowance = minterManager.minterAllowance(minter);\n        uint256 newAllowance = currentAllowance.add(allowanceIncrement);\n\n        emit MinterAllowanceIncrement(msg.sender, minter, allowanceIncrement, newAllowance);\n        return internal_setMinterAllowance(minter, newAllowance);\n    }\n\n   // Internal functions\n\n    /**\n     * @dev Uses the MinterManagementInterface to enable the minter and set its allowance.\n     */\n   function internal_setMinterAllowance(address minter, uint256 newAllowance) internal returns (bool) {\n        return minterManager.configureMinter(minter, newAllowance);\n    }\n}"
    },
    {
      "filename": "contracts/minting/MintController.sol",
      "content": "/**\n* Copyright CENTRE SECZ 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n* THE SOFTWARE.\n*/\n\npragma solidity ^0.4.24;\n\nimport \"./Controller.sol\";\nimport \"./MinterManagementInterface.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title MintController\n * @notice The MintController contract manages minters for a contract that \n * implements the MinterManagerInterface. It lets the owner designate certain \n * addresses as controllers, and these controllers then manage the \n * minters by adding and removing minters, as well as modifying their minting \n * allowance. A controller may manage exactly one minter, but the same minter \n * address may be managed by multiple controllers.\n * @dev MintController inherits from the Controller contract. It treats the \n * Controller workers as minters.\n */\ncontract MintController is Controller {\n    using SafeMath for uint256;\n\n    /**\n    * @title MinterManagementInterface\n    * @notice MintController calls the minterManager to execute/record minter \n    * management tasks, as well as to query the status of a minter address.\n    */\n    MinterManagementInterface internal minterManager;\n\n    event MinterManagerSet(\n        address indexed _oldMinterManager,\n        address indexed _newMinterManager\n    );\n    event MinterConfigured(\n        address indexed _msgSender,\n        address indexed _minter,\n        uint256 _allowance\n    );\n    event MinterRemoved(\n        address indexed _msgSender,\n        address indexed _minter\n    );\n    event MinterAllowanceIncremented(\n        address indexed _msgSender,\n        address indexed _minter,\n        uint256 _increment,\n        uint256 _newAllowance\n    );\n\n    event MinterAllowanceDecremented(\n        address indexed msgSender,\n        address indexed minter,\n        uint256 decrement,\n        uint256 newAllowance\n    );\n\n    /**\n     * @notice Initializes the minterManager.\n     * @param _minterManager The address of the minterManager contract.\n     */\n    constructor(address _minterManager) public {\n        minterManager = MinterManagementInterface(_minterManager);\n    }\n\n    /**\n     * @notice gets the minterManager\n     */\n    function getMinterManager(\n    )\n        external\n        view\n        returns (MinterManagementInterface)\n    {\n        return minterManager;\n    }\n\n    // onlyOwner functions\n\n    /**\n     * @notice Sets the minterManager.\n     * @param _newMinterManager The address of the new minterManager contract.\n     */\n    function setMinterManager(\n        address _newMinterManager\n    )\n        public\n        onlyOwner\n    {\n        emit MinterManagerSet(address(minterManager), _newMinterManager);\n        minterManager = MinterManagementInterface(_newMinterManager);\n    }\n\n    // onlyController functions\n\n    /**\n     * @notice Removes the controller's own minter.\n     */\n    function removeMinter() public onlyController returns (bool) {\n        address minter = controllers[msg.sender];\n        emit MinterRemoved(msg.sender, minter);\n        return minterManager.removeMinter(minter);\n    }\n\n    /**\n     * @notice Enables the minter and sets its allowance.\n     * @param _newAllowance New allowance to be set for minter.\n     */\n    function configureMinter(\n        uint256 _newAllowance\n    )\n        public\n        onlyController\n        returns (bool)\n    {\n        address minter = controllers[msg.sender];\n        emit MinterConfigured(msg.sender, minter, _newAllowance);\n        return internal_setMinterAllowance(minter, _newAllowance);\n    }\n\n    /**\n     * @notice Increases the minter's allowance if and only if the minter is an \n     * active minter.\n     * @dev An minter is considered active if minterManager.isMinter(minter) \n     * returns true.\n     */\n    function incrementMinterAllowance(\n        uint256 _allowanceIncrement\n    )\n        public\n        onlyController\n        returns (bool)\n    {\n        require(_allowanceIncrement > 0, \n            \"Allowance increment must be greater than 0\");\n        address minter = controllers[msg.sender];\n        require(minterManager.isMinter(minter), \n            \"Can only increment allowance for minters in minterManager\");\n\n        uint256 currentAllowance = minterManager.minterAllowance(minter);\n        uint256 newAllowance = currentAllowance.add(_allowanceIncrement);\n\n        emit MinterAllowanceIncremented(\n            msg.sender,\n            minter,\n            _allowanceIncrement,\n            newAllowance\n        );\n\n        return internal_setMinterAllowance(minter, newAllowance);\n    }\n\n    /**\n     * @notice decreases the minter allowance if and only if the minter is\n     * currently active. The controller can safely send a signed \n     * decrementMinterAllowance() transaction to a minter and not worry \n     * about it being used to undo a removeMinter() transaction.\n     */\n    function decrementMinterAllowance(\n        uint256 _allowanceDecrement\n    )\n        public\n        onlyController\n        returns (bool)\n    {\n        require(_allowanceDecrement > 0, \n            \"Allowance decrement must be greater than 0\");\n        address minter = controllers[msg.sender];\n        require(minterManager.isMinter(minter), \n            \"Can only decrement allowance for minters in minterManager\");\n\n        uint256 currentAllowance = minterManager.minterAllowance(minter);\n        uint256 actualAllowanceDecrement = (\n            currentAllowance > _allowanceDecrement ? \n            _allowanceDecrement : currentAllowance\n        );\n        uint256 newAllowance = currentAllowance.sub(actualAllowanceDecrement);\n\n        emit MinterAllowanceDecremented(\n            msg.sender,\n            minter,\n            actualAllowanceDecrement,\n            newAllowance\n        );\n\n        return internal_setMinterAllowance(minter, newAllowance);\n    }\n\n    // Internal functions\n\n    /**\n     * @notice Uses the MinterManagementInterface to enable the minter and\n     * set its allowance.\n     * @param _minter Minter to set new allowance of.\n     * @param _newAllowance New allowance to be set for minter.\n     */\n    function internal_setMinterAllowance(\n        address _minter,\n        uint256 _newAllowance\n    )\n        internal\n        returns (bool)\n    {\n        return minterManager.configureMinter(_minter, _newAllowance);\n    }\n}"
    }
  ]
}