{
  "Title": "[L-08] `address.call{value:x}()` should be used instead of `payable.transfer()`",
  "Content": "\nThe use of `payable.transfer()` is heavily frowned upon because it can lead to the locking of funds. The `transfer()` call requires that the recipient has a `payable` callback, only provides 2300 gas for its operation. This means the following cases can cause the transfer to fail:\n\n*   The contract does not have a `payable` callback\n*   The contract's `payable` callback spends more than 2300 gas (which is only enough to emit something)\n*   The contract is called through a proxy which itself uses up the 2300 gas\n\n```solidity\nFile: backd/contracts/vault/VaultReserve.sol   #1\n\n81            payable(msg.sender).transfer(amount);\n```\n\nuses the `onlyVault` modifier, and vaults currently have empty `payable` callbacks, so they don't currently revert\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/VaultReserve.sol#L81>\n\n```solidity\nFile: backd/contracts/vault/EthVault.sol   #2\n\n29        payable(to).transfer(amount);\n```\n\nuses the `onlyPoolOrGovernance` modifier, and pools currently have an empty `payable` callback, so they don't currently rever. Governance is currently deployed and not seeing issues, so presumably it also has an empty `payable` callback\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/EthVault.sol#L29>\n\n```solidity\nFile: backd/contracts/vault/EthVault.sol   #3\n\n37        payable(addressProvider.getTreasury()).transfer(amount);\n```\n\nthe treasury is currently deployed and not seeing issues, so presumably it also has an empty `payable` callback\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/EthVault.sol#L37>\n\n```solidity\nFile: backd/contracts/strategies/BkdEthCvx.sol   #4\n\n77            payable(vault).transfer(amount);\n```\n\nvaults currently have an empty `payable` callback\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/BkdEthCvx.sol#L77>\n\n```solidity\nFile: backd/contracts/strategies/BkdEthCvx.sol   #5\n\n93        payable(vault).transfer(amount);\n```\n\nvaults currently have an empty `payable` callback\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/BkdEthCvx.sol#L93>\n\n```solidity\nFile: backd/contracts/strategies/BkdEthCvx.sol   #6\n\n117        payable(vault).transfer(underlyingBalance);\n```\n\nvaults currently have an empty `payable` callback\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/BkdEthCvx.sol#L117>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/vault/VaultReserve.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IVaultReserve.sol\";\nimport \"../../libraries/Errors.sol\";\n\nimport \"../access/Authorization.sol\";\nimport \"../vault/Vault.sol\";\n\n/**\n * @notice Contract holding vault reserves\n * @dev ETH reserves are stored under address(0)\n */\ncontract VaultReserve is IVaultReserve, Authorization {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant _INITIAL_WITHDRAWAL_DELAY = 3 days;\n\n    mapping(address => mapping(address => uint256)) private _balances;\n    mapping(address => uint256) private _lastWithdrawal;\n\n    uint256 public minWithdrawalDelay;\n\n    modifier onlyVault() {\n        require(_roleManager().hasRole(Roles.VAULT, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IRoleManager roleManager) Authorization(roleManager) {\n        minWithdrawalDelay = _INITIAL_WITHDRAWAL_DELAY;\n    }\n\n    /**\n     * @notice Deposit funds into vault reserve.\n     * @notice Only callable by a whitelisted vault.\n     * @param token Token to deposit.\n     * @param amount Amount to deposit.\n     * @return True if deposit was successful.\n     */\n    function deposit(address token, uint256 amount)\n        external\n        payable\n        override\n        onlyVault\n        returns (bool)\n    {\n        if (token == address(0)) {\n            require(msg.value == amount, Error.INVALID_AMOUNT);\n            _balances[msg.sender][token] += msg.value;\n            return true;\n        }\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBalance = IERC20(token).balanceOf(address(this));\n        uint256 received = newBalance - balance;\n        require(received >= amount, Error.INVALID_AMOUNT);\n        _balances[msg.sender][token] += received;\n        emit Deposit(msg.sender, token, amount);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw funds from vault reserve.\n     * @notice Only callable by a whitelisted vault.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     * @return True if withdrawal was successful.\n     */\n    function withdraw(address token, uint256 amount) external override onlyVault returns (bool) {\n        require(canWithdraw(msg.sender), Error.RESERVE_ACCESS_EXCEEDED);\n        uint256 accountBalance = _balances[msg.sender][token];\n        require(accountBalance >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _balances[msg.sender][token] -= amount;\n        _lastWithdrawal[msg.sender] = block.timestamp;\n\n        if (token == address(0)) {\n            payable(msg.sender).transfer(amount);\n        } else {\n            IERC20(token).safeTransfer(msg.sender, amount);\n        }\n        emit Withdraw(msg.sender, token, amount);\n        return true;\n    }\n\n    /**\n     * @notice Check token balance of a specific vault.\n     * @param vault Vault to check balance of.\n     * @param token Token to check balance in.\n     * @return Token balance of vault.\n     */\n    function getBalance(address vault, address token) public view override returns (uint256) {\n        return _balances[vault][token];\n    }\n\n    /**\n     * @notice returns true if the vault is allowed to withdraw from the reserve\n     */\n    function canWithdraw(address vault) public view returns (bool) {\n        return block.timestamp >= _lastWithdrawal[vault] + minWithdrawalDelay;\n    }\n}"
    },
    {
      "filename": "backd/contracts/vault/EthVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./Vault.sol\";\n\ncontract EthVault is Vault {\n    using AddressProviderHelpers for IAddressProvider;\n\n    address private constant _UNDERLYING = address(0);\n\n    constructor(IController controller) Vault(controller) {}\n\n    receive() external payable {}\n\n    function initialize(\n        address _pool,\n        uint256 _debtLimit,\n        uint256 _targetAllocation,\n        uint256 _bound\n    ) external virtual override initializer {\n        _initialize(_pool, _debtLimit, _targetAllocation, _bound);\n    }\n\n    function getUnderlying() public pure override returns (address) {\n        return _UNDERLYING;\n    }\n\n    function _transfer(address to, uint256 amount) internal override {\n        payable(to).transfer(amount);\n    }\n\n    function _depositToReserve(uint256 amount) internal override {\n        reserve.deposit{value: amount}(_UNDERLYING, amount);\n    }\n\n    function _depositToTreasury(uint256 amount) internal override {\n        payable(addressProvider.getTreasury()).transfer(amount);\n    }\n\n    function _payStrategist(uint256 amount, address strategist) internal override {\n        if (strategist == address(0)) return;\n        ILiquidityPool(pool).depositFor{value: amount}(strategist, amount);\n    }\n\n    function _availableUnderlying() internal view override returns (uint256) {\n        return address(this).balance;\n    }\n}"
    },
    {
      "filename": "backd/contracts/vault/EthVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./Vault.sol\";\n\ncontract EthVault is Vault {\n    using AddressProviderHelpers for IAddressProvider;\n\n    address private constant _UNDERLYING = address(0);\n\n    constructor(IController controller) Vault(controller) {}\n\n    receive() external payable {}\n\n    function initialize(\n        address _pool,\n        uint256 _debtLimit,\n        uint256 _targetAllocation,\n        uint256 _bound\n    ) external virtual override initializer {\n        _initialize(_pool, _debtLimit, _targetAllocation, _bound);\n    }\n\n    function getUnderlying() public pure override returns (address) {\n        return _UNDERLYING;\n    }\n\n    function _transfer(address to, uint256 amount) internal override {\n        payable(to).transfer(amount);\n    }\n\n    function _depositToReserve(uint256 amount) internal override {\n        reserve.deposit{value: amount}(_UNDERLYING, amount);\n    }\n\n    function _depositToTreasury(uint256 amount) internal override {\n        payable(addressProvider.getTreasury()).transfer(amount);\n    }\n\n    function _payStrategist(uint256 amount, address strategist) internal override {\n        if (strategist == address(0)) return;\n        ILiquidityPool(pool).depositFor{value: amount}(strategist, amount);\n    }\n\n    function _availableUnderlying() internal view override returns (uint256) {\n        return address(this).balance;\n    }\n}"
    },
    {
      "filename": "backd/contracts/strategies/BkdEthCvx.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./ConvexStrategyBase.sol\";\n\n/**\n * This is the BkdEthCvx strategy, which is designed to be used by a Backd ETH Vault.\n * The strategy holds ETH as it's underlying and allocates liquidity to Convex via given Curve Pool with 2 underlying tokens.\n * Rewards received on Convex (CVX, CRV), are sold in part for the underlying.\n * A share of earned CVX & CRV are retained on behalf of the Backd community to participate in governance.\n */\ncontract BkdEthCvx is ConvexStrategyBase {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    constructor(\n        address vault_,\n        address strategist_,\n        uint256 convexPid_,\n        address curvePool_,\n        uint256 curveIndex_,\n        IAddressProvider addressProvider_,\n        address strategySwapper_\n    )\n        ConvexStrategyBase(\n            vault_,\n            strategist_,\n            convexPid_,\n            curvePool_,\n            curveIndex_,\n            addressProvider_,\n            strategySwapper_\n        )\n    {\n        // Setting default values\n        imbalanceToleranceIn = 0.0007e18;\n        imbalanceToleranceOut = 0.0104e18;\n\n        // Approvals\n        (address lp_, , , , , ) = _BOOSTER.poolInfo(convexPid_);\n        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);\n    }\n\n    receive() external payable {}\n\n    function name() external pure override returns (string memory) {\n        return \"BkdEthCvx\";\n    }\n\n    function balance() public view override returns (uint256) {\n        return _underlyingBalance() + _lpToUnderlying(_stakedBalance() + _lpBalance());\n    }\n\n    function _deposit() internal override returns (bool) {\n        // Depositing into Curve Pool\n        uint256 underlyingBalance = _underlyingBalance();\n        if (underlyingBalance == 0) return false;\n        uint256[2] memory amounts;\n        amounts[curveIndex] = underlyingBalance;\n        curvePool.add_liquidity{value: underlyingBalance}(\n            amounts,\n            _minLpAccepted(underlyingBalance)\n        );\n\n        // Depositing into Convex and Staking\n        if (!_BOOSTER.depositAll(convexPid, true)) return false;\n        return true;\n    }\n\n    function _withdraw(uint256 amount) internal override returns (bool) {\n        uint256 underlyingBalance = _underlyingBalance();\n\n        // Transferring from idle balance if enough\n        if (underlyingBalance >= amount) {\n            payable(vault).transfer(amount);\n            emit Withdraw(amount);\n            return true;\n        }\n\n        // Unstaking needed LP Tokens from Convex\n        uint256 requiredUnderlyingAmount = amount - underlyingBalance;\n        uint256 maxLpBurned = _maxLpBurned(requiredUnderlyingAmount);\n        uint256 requiredLpAmount = maxLpBurned - _lpBalance();\n        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;\n\n        // Removing needed liquidity from Curve\n        uint256[2] memory amounts;\n        // solhint-disable-next-line reentrancy\n        amounts[curveIndex] = requiredUnderlyingAmount;\n        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);\n        payable(vault).transfer(amount);\n        return true;\n    }\n\n    function _withdrawAll() internal override returns (uint256) {\n        // Unstaking and withdrawing from Convex pool\n        uint256 stakedBalance = _stakedBalance();\n        if (stakedBalance > 0) {\n            if (!rewards.withdrawAndUnwrap(stakedBalance, false)) return 0;\n        }\n\n        // Removing liquidity from Curve\n        uint256 lpBalance = _lpBalance();\n        if (lpBalance > 0) {\n            curvePool.remove_liquidity_one_coin(\n                lpBalance,\n                int128(uint128(curveIndex)),\n                _minUnderlyingAccepted(lpBalance)\n            );\n        }\n\n        // Transferring underlying to vault\n        uint256 underlyingBalance = _underlyingBalance();\n        if (underlyingBalance == 0) return 0;\n        payable(vault).transfer(underlyingBalance);\n        return underlyingBalance;\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @notice Calculates the minimum LP to accept when depositing underlying into Curve Pool.\n     * @param _underlyingAmount Amount of underlying that is being deposited into Curve Pool.\n     * @return The minimum LP balance to accept.\n     */\n    function _minLpAccepted(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceIn);\n    }\n\n    /**\n     * @notice Calculates the maximum LP to accept burning when withdrawing amount from Curve Pool.\n     * @param _underlyingAmount Amount of underlying that is being widthdrawn from Curve Pool.\n     * @return The maximum LP balance to accept burning.\n     */\n    function _maxLpBurned(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE + imbalanceToleranceOut);\n    }\n\n    /**\n     * @notice Calculates the minimum underlying to accept when burning LP tokens to withdraw from Curve Pool.\n     * @param _lpAmount Amount of LP tokens being burned to withdraw from Curve Pool.\n     * @return The minimum underlying balance to accept.\n     */\n    function _minUnderlyingAccepted(uint256 _lpAmount) internal view returns (uint256) {\n        return _lpToUnderlying(_lpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceOut);\n    }\n\n    /**\n     * @notice Converts an amount of underlying into their estimated LP value.\n     * @dev Uses get_virtual_price which is less suceptible to manipulation.\n     *  But is also less accurate to how much could be withdrawn.\n     * @param _underlyingAmount Amount of underlying to convert.\n     * @return The estimated value in the LP.\n     */\n    function _underlyingToLp(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingAmount.scaledDiv(curvePool.get_virtual_price());\n    }\n\n    /**\n     * @notice Converts an amount of LP into their estimated underlying value.\n     * @dev Uses get_virtual_price which is less suceptible to manipulation.\n     *  But is also less accurate to how much could be withdrawn.\n     * @param _lpAmount Amount of LP to convert.\n     * @return The estimated value in the underlying.\n     */\n    function _lpToUnderlying(uint256 _lpAmount) internal view returns (uint256) {\n        return _lpAmount.scaledMul(curvePool.get_virtual_price());\n    }\n}"
    },
    {
      "filename": "backd/contracts/strategies/BkdEthCvx.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./ConvexStrategyBase.sol\";\n\n/**\n * This is the BkdEthCvx strategy, which is designed to be used by a Backd ETH Vault.\n * The strategy holds ETH as it's underlying and allocates liquidity to Convex via given Curve Pool with 2 underlying tokens.\n * Rewards received on Convex (CVX, CRV), are sold in part for the underlying.\n * A share of earned CVX & CRV are retained on behalf of the Backd community to participate in governance.\n */\ncontract BkdEthCvx is ConvexStrategyBase {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    constructor(\n        address vault_,\n        address strategist_,\n        uint256 convexPid_,\n        address curvePool_,\n        uint256 curveIndex_,\n        IAddressProvider addressProvider_,\n        address strategySwapper_\n    )\n        ConvexStrategyBase(\n            vault_,\n            strategist_,\n            convexPid_,\n            curvePool_,\n            curveIndex_,\n            addressProvider_,\n            strategySwapper_\n        )\n    {\n        // Setting default values\n        imbalanceToleranceIn = 0.0007e18;\n        imbalanceToleranceOut = 0.0104e18;\n\n        // Approvals\n        (address lp_, , , , , ) = _BOOSTER.poolInfo(convexPid_);\n        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);\n    }\n\n    receive() external payable {}\n\n    function name() external pure override returns (string memory) {\n        return \"BkdEthCvx\";\n    }\n\n    function balance() public view override returns (uint256) {\n        return _underlyingBalance() + _lpToUnderlying(_stakedBalance() + _lpBalance());\n    }\n\n    function _deposit() internal override returns (bool) {\n        // Depositing into Curve Pool\n        uint256 underlyingBalance = _underlyingBalance();\n        if (underlyingBalance == 0) return false;\n        uint256[2] memory amounts;\n        amounts[curveIndex] = underlyingBalance;\n        curvePool.add_liquidity{value: underlyingBalance}(\n            amounts,\n            _minLpAccepted(underlyingBalance)\n        );\n\n        // Depositing into Convex and Staking\n        if (!_BOOSTER.depositAll(convexPid, true)) return false;\n        return true;\n    }\n\n    function _withdraw(uint256 amount) internal override returns (bool) {\n        uint256 underlyingBalance = _underlyingBalance();\n\n        // Transferring from idle balance if enough\n        if (underlyingBalance >= amount) {\n            payable(vault).transfer(amount);\n            emit Withdraw(amount);\n            return true;\n        }\n\n        // Unstaking needed LP Tokens from Convex\n        uint256 requiredUnderlyingAmount = amount - underlyingBalance;\n        uint256 maxLpBurned = _maxLpBurned(requiredUnderlyingAmount);\n        uint256 requiredLpAmount = maxLpBurned - _lpBalance();\n        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;\n\n        // Removing needed liquidity from Curve\n        uint256[2] memory amounts;\n        // solhint-disable-next-line reentrancy\n        amounts[curveIndex] = requiredUnderlyingAmount;\n        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);\n        payable(vault).transfer(amount);\n        return true;\n    }\n\n    function _withdrawAll() internal override returns (uint256) {\n        // Unstaking and withdrawing from Convex pool\n        uint256 stakedBalance = _stakedBalance();\n        if (stakedBalance > 0) {\n            if (!rewards.withdrawAndUnwrap(stakedBalance, false)) return 0;\n        }\n\n        // Removing liquidity from Curve\n        uint256 lpBalance = _lpBalance();\n        if (lpBalance > 0) {\n            curvePool.remove_liquidity_one_coin(\n                lpBalance,\n                int128(uint128(curveIndex)),\n                _minUnderlyingAccepted(lpBalance)\n            );\n        }\n\n        // Transferring underlying to vault\n        uint256 underlyingBalance = _underlyingBalance();\n        if (underlyingBalance == 0) return 0;\n        payable(vault).transfer(underlyingBalance);\n        return underlyingBalance;\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @notice Calculates the minimum LP to accept when depositing underlying into Curve Pool.\n     * @param _underlyingAmount Amount of underlying that is being deposited into Curve Pool.\n     * @return The minimum LP balance to accept.\n     */\n    function _minLpAccepted(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceIn);\n    }\n\n    /**\n     * @notice Calculates the maximum LP to accept burning when withdrawing amount from Curve Pool.\n     * @param _underlyingAmount Amount of underlying that is being widthdrawn from Curve Pool.\n     * @return The maximum LP balance to accept burning.\n     */\n    function _maxLpBurned(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE + imbalanceToleranceOut);\n    }\n\n    /**\n     * @notice Calculates the minimum underlying to accept when burning LP tokens to withdraw from Curve Pool.\n     * @param _lpAmount Amount of LP tokens being burned to withdraw from Curve Pool.\n     * @return The minimum underlying balance to accept.\n     */\n    function _minUnderlyingAccepted(uint256 _lpAmount) internal view returns (uint256) {\n        return _lpToUnderlying(_lpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceOut);\n    }\n\n    /**\n     * @notice Converts an amount of underlying into their estimated LP value.\n     * @dev Uses get_virtual_price which is less suceptible to manipulation.\n     *  But is also less accurate to how much could be withdrawn.\n     * @param _underlyingAmount Amount of underlying to convert.\n     * @return The estimated value in the LP.\n     */\n    function _underlyingToLp(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingAmount.scaledDiv(curvePool.get_virtual_price());\n    }\n\n    /**\n     * @notice Converts an amount of LP into their estimated underlying value.\n     * @dev Uses get_virtual_price which is less suceptible to manipulation.\n     *  But is also less accurate to how much could be withdrawn.\n     * @param _lpAmount Amount of LP to convert.\n     * @return The estimated value in the underlying.\n     */\n    function _lpToUnderlying(uint256 _lpAmount) internal view returns (uint256) {\n        return _lpAmount.scaledMul(curvePool.get_virtual_price());\n    }\n}"
    },
    {
      "filename": "backd/contracts/strategies/BkdEthCvx.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./ConvexStrategyBase.sol\";\n\n/**\n * This is the BkdEthCvx strategy, which is designed to be used by a Backd ETH Vault.\n * The strategy holds ETH as it's underlying and allocates liquidity to Convex via given Curve Pool with 2 underlying tokens.\n * Rewards received on Convex (CVX, CRV), are sold in part for the underlying.\n * A share of earned CVX & CRV are retained on behalf of the Backd community to participate in governance.\n */\ncontract BkdEthCvx is ConvexStrategyBase {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    constructor(\n        address vault_,\n        address strategist_,\n        uint256 convexPid_,\n        address curvePool_,\n        uint256 curveIndex_,\n        IAddressProvider addressProvider_,\n        address strategySwapper_\n    )\n        ConvexStrategyBase(\n            vault_,\n            strategist_,\n            convexPid_,\n            curvePool_,\n            curveIndex_,\n            addressProvider_,\n            strategySwapper_\n        )\n    {\n        // Setting default values\n        imbalanceToleranceIn = 0.0007e18;\n        imbalanceToleranceOut = 0.0104e18;\n\n        // Approvals\n        (address lp_, , , , , ) = _BOOSTER.poolInfo(convexPid_);\n        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);\n    }\n\n    receive() external payable {}\n\n    function name() external pure override returns (string memory) {\n        return \"BkdEthCvx\";\n    }\n\n    function balance() public view override returns (uint256) {\n        return _underlyingBalance() + _lpToUnderlying(_stakedBalance() + _lpBalance());\n    }\n\n    function _deposit() internal override returns (bool) {\n        // Depositing into Curve Pool\n        uint256 underlyingBalance = _underlyingBalance();\n        if (underlyingBalance == 0) return false;\n        uint256[2] memory amounts;\n        amounts[curveIndex] = underlyingBalance;\n        curvePool.add_liquidity{value: underlyingBalance}(\n            amounts,\n            _minLpAccepted(underlyingBalance)\n        );\n\n        // Depositing into Convex and Staking\n        if (!_BOOSTER.depositAll(convexPid, true)) return false;\n        return true;\n    }\n\n    function _withdraw(uint256 amount) internal override returns (bool) {\n        uint256 underlyingBalance = _underlyingBalance();\n\n        // Transferring from idle balance if enough\n        if (underlyingBalance >= amount) {\n            payable(vault).transfer(amount);\n            emit Withdraw(amount);\n            return true;\n        }\n\n        // Unstaking needed LP Tokens from Convex\n        uint256 requiredUnderlyingAmount = amount - underlyingBalance;\n        uint256 maxLpBurned = _maxLpBurned(requiredUnderlyingAmount);\n        uint256 requiredLpAmount = maxLpBurned - _lpBalance();\n        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;\n\n        // Removing needed liquidity from Curve\n        uint256[2] memory amounts;\n        // solhint-disable-next-line reentrancy\n        amounts[curveIndex] = requiredUnderlyingAmount;\n        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);\n        payable(vault).transfer(amount);\n        return true;\n    }\n\n    function _withdrawAll() internal override returns (uint256) {\n        // Unstaking and withdrawing from Convex pool\n        uint256 stakedBalance = _stakedBalance();\n        if (stakedBalance > 0) {\n            if (!rewards.withdrawAndUnwrap(stakedBalance, false)) return 0;\n        }\n\n        // Removing liquidity from Curve\n        uint256 lpBalance = _lpBalance();\n        if (lpBalance > 0) {\n            curvePool.remove_liquidity_one_coin(\n                lpBalance,\n                int128(uint128(curveIndex)),\n                _minUnderlyingAccepted(lpBalance)\n            );\n        }\n\n        // Transferring underlying to vault\n        uint256 underlyingBalance = _underlyingBalance();\n        if (underlyingBalance == 0) return 0;\n        payable(vault).transfer(underlyingBalance);\n        return underlyingBalance;\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @notice Calculates the minimum LP to accept when depositing underlying into Curve Pool.\n     * @param _underlyingAmount Amount of underlying that is being deposited into Curve Pool.\n     * @return The minimum LP balance to accept.\n     */\n    function _minLpAccepted(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceIn);\n    }\n\n    /**\n     * @notice Calculates the maximum LP to accept burning when withdrawing amount from Curve Pool.\n     * @param _underlyingAmount Amount of underlying that is being widthdrawn from Curve Pool.\n     * @return The maximum LP balance to accept burning.\n     */\n    function _maxLpBurned(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE + imbalanceToleranceOut);\n    }\n\n    /**\n     * @notice Calculates the minimum underlying to accept when burning LP tokens to withdraw from Curve Pool.\n     * @param _lpAmount Amount of LP tokens being burned to withdraw from Curve Pool.\n     * @return The minimum underlying balance to accept.\n     */\n    function _minUnderlyingAccepted(uint256 _lpAmount) internal view returns (uint256) {\n        return _lpToUnderlying(_lpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceOut);\n    }\n\n    /**\n     * @notice Converts an amount of underlying into their estimated LP value.\n     * @dev Uses get_virtual_price which is less suceptible to manipulation.\n     *  But is also less accurate to how much could be withdrawn.\n     * @param _underlyingAmount Amount of underlying to convert.\n     * @return The estimated value in the LP.\n     */\n    function _underlyingToLp(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingAmount.scaledDiv(curvePool.get_virtual_price());\n    }\n\n    /**\n     * @notice Converts an amount of LP into their estimated underlying value.\n     * @dev Uses get_virtual_price which is less suceptible to manipulation.\n     *  But is also less accurate to how much could be withdrawn.\n     * @param _lpAmount Amount of LP to convert.\n     * @return The estimated value in the underlying.\n     */\n    function _lpToUnderlying(uint256 _lpAmount) internal view returns (uint256) {\n        return _lpAmount.scaledMul(curvePool.get_virtual_price());\n    }\n}"
    }
  ]
}