{
  "Title": "[H-06] The lender could possibly lose unclaimed rewards in case a bucket goes bankrupt",
  "Content": "\nWhen the lender calls `PositionManager.memorializePositions` method the following happens:\n\n1.  Records bucket indexes along with its deposit times and lpBalances\n2.  Transfers LP ownership from the lender to PositionManager contract.\n\nIn point 1, it checks if there is a previous deposit and the bucket went bankrupt after prior memorialization, then it zero out the previous tracked LP. However, the lender could still have unclaimed rewards. In this case, the lender loses the rewards due to the lack of claiming rewards before zeroing out the previous tracked LP balance. If you check claim rewards functionality in RewardsManager, the bucket being not bankrupt is not a requirement. Please note that claiming rewards relies on the tracked LP balance in PositionManager.\n\n### Proof of Concept\n\n*   `PositionManager.memorializePositions` method\n    *   check for previous deposits and zero out the previous tracked LP if bucket is bankrupt\n    ```\n    \t// check for previous deposits\n    \tif (position.depositTime != 0) {\n    \t\t// check that bucket didn't go bankrupt after prior memorialization\n    \t\tif (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n    \t\t\t// if bucket did go bankrupt, zero out the LP tracked by position manager\n    \t\t\tposition.lps = 0;\n    \t\t}\n    \t}\n\n    ```\n    <https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L192-L199>\n\n*   In RewardsManager, check `claimRewards` and `_claimRewards`  method. there is no a check for bucket's bankruptcy.\n\n    <https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L114>\n\n    <https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L561>\n\n### Recommended Mitigation Steps\n\nOn memorializePositions, check if the lender already claimed his/her rewards before zeroing out the previous tracked LP.\n\n**[ith-harvey (Ajna) disputed](https://github.com/code-423n4/2023-05-ajna-findings/issues/329#issuecomment-1608467083)**\n\n**[grandizzy (Ajna) commented](https://github.com/code-423n4/2023-05-ajna-findings/issues/329#issuecomment-1609466700):**\n> That is by design and we acknowledge that documentation of bucket bankruptcy can be improved. When a bucket goes bankrupt (which shouldn't happen often but only when there's bad debt in pool to settle) the lender won't lose only their rewards but will also lose all the shares in that bucket / LP (which has higher impact than rewards).<br>\n> Also the recommendation of:<br>\n> `On memorializePositions, check if the lender already claimed his/her rewards before zeroing out the previous tracked LP.`\n> \n> Would imply making position manager contract aware of rewards manager contract and we don't want to couple those 2 in reference implementation. However, additional position and rewards manager could be developed by 3rd parties and could take into consideration this recommendation.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { ERC20 }           from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { ERC721 }          from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport { EnumerableSet }   from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport { IPositionManagerDerivedState } from './interfaces/position/IPositionManagerDerivedState.sol';\nimport { Position }                     from './interfaces/position/IPositionManagerState.sol';\n\nimport { ERC20PoolFactory }  from './ERC20PoolFactory.sol';\nimport { ERC721PoolFactory } from './ERC721PoolFactory.sol';\n\nimport { PermitERC721 } from './base/PermitERC721.sol';\n\nimport {\n    _lpToQuoteToken,\n    _priceAt\n}                      from './libraries/helpers/PoolHelper.sol';\nimport { tokenSymbol } from './libraries/helpers/SafeTokenNamer.sol';\n\nimport { PositionNFTSVG } from './libraries/external/PositionNFTSVG.sol';\n\n/**\n *  @title  Position Manager Contract\n *  @notice Used by Pool lenders to optionally mint `NFT` that represents their positions.\n *          `Lenders` can:\n *          - `mint` positions `NFT` token for a specific pool\n *          - `memorialize` positions for given buckets\n *          - `move liquidity` in pool\n *          - `redeem` positions for given buckets\n *          - `burn` positions `NFT`\n */\ncontract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, ReentrancyGuard {\n\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeERC20     for ERC20;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => address) public override poolKey;\n\n    /// @dev Mapping of `token id => ajna pool address` for which token was minted.\n    mapping(uint256 => mapping(uint256 => Position)) internal positions;\n    /// @dev Mapping of `token id => nonce` value used for permit.\n    mapping(uint256 => uint96)                       internal nonces;\n    /// @dev Mapping of `token id => bucket indexes` associated with position.\n    mapping(uint256 => EnumerableSet.UintSet)        internal positionIndexes;\n\n    /// @dev Id of the next token that will be minted. Skips `0`.\n    uint176 private _nextId = 1;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev The `ERC20` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC20PoolFactory  private immutable erc20PoolFactory;\n    /// @dev The `ERC721` pools factory contract, used to check if address is an `Ajna` pool.\n    ERC721PoolFactory private immutable erc721PoolFactory;\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `moveLiquidity` function local vars.\n    struct MoveLiquidityLocalVars {\n        uint256 bucketLP;         // [WAD] amount of LP in from bucket\n        uint256 bucketCollateral; // [WAD] amount of collateral in from bucket\n        uint256 bankruptcyTime;   // from bucket bankruptcy time\n        uint256 bucketDeposit;    // [WAD] from bucket deposit\n        uint256 depositTime;      // lender deposit time in from bucekt\n        uint256 maxQuote;         // [WAD] max amount that can be moved from bucket\n        uint256 lpbAmountFrom;    // [WAD] the LP redeemed from bucket\n        uint256 lpbAmountTo;      // [WAD] the LP awarded in to bucket\n    }\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    /**\n     *  @dev   Modifier used to check if sender can interact with token id.\n     *  @param pool_    `Ajna` pool address.\n     *  @param tokenId_ Id of positions `NFT`.\n     */\n    modifier mayInteract(address pool_, uint256 tokenId_) {\n\n        // revert if token id is not a valid / minted id\n        _requireMinted(tokenId_);\n\n        // revert if sender is not owner of or entitled to operate on token id\n        if (!_isApprovedOrOwner(msg.sender, tokenId_)) revert NoAuth();\n\n        // revert if the token id is not minted for given pool address\n        if (pool_ != poolKey[tokenId_]) revert WrongPool();\n\n        _;\n    }\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(\n        ERC20PoolFactory erc20Factory_,\n        ERC721PoolFactory erc721Factory_\n    ) PermitERC721(\"Ajna Positions NFT-V1\", \"AJNA-V1-POS\", \"1\") {\n        erc20PoolFactory  = erc20Factory_;\n        erc721PoolFactory = erc721Factory_;\n    }\n\n    /********************************/\n    /*** Owner External Functions ***/\n    /********************************/\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `nonces`: remove `tokenId` nonce\n     *  @dev    `poolKey`: remove `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev       token id is not a valid / minted id\n     *  @dev       sender is not owner `NoAuth()`\n     *  @dev       token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Burn`\n     */\n    function burn(\n        BurnParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        // revert if trying to burn an positions token that still has liquidity\n        if (positionIndexes[params_.tokenId].length() != 0) revert LiquidityNotRemoved();\n\n        // remove permit nonces and pool mapping for burned token\n        delete nonces[params_.tokenId];\n        delete poolKey[params_.tokenId];\n\n        _burn(params_.tokenId);\n\n        emit Burn(msg.sender, params_.tokenId);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    - `lenderInfo()`: get lender position in bucket\n     *  @dev    - `transferLP()`: transfer `LP` ownership to `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: add bucket index\n     *  @dev    `positions`: update `tokenId => bucket id` position\n     *  @dev    === Revert on ===\n     *  @dev    positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MemorializePosition`\n     */\n    function memorializePositions(\n        MemorializePositionsParams calldata params_\n    ) external override {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool   pool  = IPool(poolKey[params_.tokenId]);\n        address owner = ownerOf(params_.tokenId);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            // record bucket index at which a position has added liquidity\n            // slither-disable-next-line unused-return\n            positionIndex.add(index);\n\n            (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);\n\n            Position memory position = positions[params_.tokenId][index];\n\n            // check for previous deposits\n            if (position.depositTime != 0) {\n                // check that bucket didn't go bankrupt after prior memorialization\n                if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n                    // if bucket did go bankrupt, zero out the LP tracked by position manager\n                    position.lps = 0;\n                }\n            }\n\n            // update token position LP\n            position.lps += lpBalance;\n            // set token's position deposit time to the original lender's deposit time\n            position.depositTime = depositTime;\n\n            // save position in storage\n            positions[params_.tokenId][index] = position;\n\n            unchecked { ++i; }\n        }\n\n        // update pool LP accounting and transfer ownership of LP to PositionManager contract\n        pool.transferLP(owner, address(this), params_.indexes);\n\n        emit MemorializePosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    === Write state ===\n     *  @dev    `poolKey`: update `tokenId => pool` mapping\n     *  @dev    === Revert on ===\n     *  @dev    provided pool not valid `NotAjnaPool()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Mint`\n     */\n    function mint(\n        MintParams calldata params_\n    ) external override nonReentrant returns (uint256 tokenId_) {\n        tokenId_ = _nextId++;\n\n        // revert if the address is not a valid Ajna pool\n        if (!_isAjnaPool(params_.pool, params_.poolSubsetHash)) revert NotAjnaPool();\n\n        // record which pool the tokenId was minted in\n        poolKey[tokenId_] = params_.pool;\n\n        _mint(params_.recipient, tokenId_);\n\n        emit Mint(params_.recipient, params_.pool, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `bucketInfo()`: get from bucket info\n     *  @dev    `moveQuoteToken()`: move liquidity between buckets\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positionIndexes`: add to bucket index\n     *  @dev    `positions`: update from bucket position\n     *  @dev    `positions`: update to bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - positions token to burn has liquidity `LiquidityNotRemoved()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveLiquidity`\n     */\n    function moveLiquidity(\n        MoveLiquidityParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {\n        Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];\n\n        MoveLiquidityLocalVars memory vars;\n        vars.depositTime = fromPosition.depositTime;\n\n        // handle the case where owner attempts to move liquidity after they've already done so\n        if (vars.depositTime == 0) revert RemovePositionFailed();\n\n        // ensure bucketDeposit accounts for accrued interest\n        IPool(params_.pool).updateInterest();\n\n        // retrieve info of bucket from which liquidity is moved  \n        (\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bankruptcyTime,\n            vars.bucketDeposit,\n        ) = IPool(params_.pool).bucketInfo(params_.fromIndex);\n\n        // check that bucket hasn't gone bankrupt since memorialization\n        if (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();\n\n        // calculate the max amount of quote tokens that can be moved, given the tracked LP\n        vars.maxQuote = _lpToQuoteToken(\n            vars.bucketLP,\n            vars.bucketCollateral,\n            vars.bucketDeposit,\n            fromPosition.lps,\n            vars.bucketDeposit,\n            _priceAt(params_.fromIndex)\n        );\n\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        // remove bucket index from which liquidity is moved from tracked positions\n        if (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();\n\n        // update bucket set at which a position has liquidity\n        // slither-disable-next-line unused-return\n        positionIndex.add(params_.toIndex);\n\n        // move quote tokens in pool\n        (\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo,\n        ) = IPool(params_.pool).moveQuoteToken(\n            vars.maxQuote,\n            params_.fromIndex,\n            params_.toIndex,\n            params_.expiry\n        );\n\n        Position storage toPosition = positions[params_.tokenId][params_.toIndex];\n\n        // update position LP state\n        fromPosition.lps -= vars.lpbAmountFrom;\n        toPosition.lps   += vars.lpbAmountTo;\n        // update position deposit time to the from bucket deposit time\n        toPosition.depositTime = vars.depositTime;\n\n        emit MoveLiquidity(\n            ownerOf(params_.tokenId),\n            params_.tokenId,\n            params_.fromIndex,\n            params_.toIndex,\n            vars.lpbAmountFrom,\n            vars.lpbAmountTo\n        );\n    }\n\n    /**\n     *  @inheritdoc IPositionManagerOwnerActions\n     *  @dev    External calls to `Pool` contract:\n     *  @dev    `increaseLPAllowance()`: approve ownership for transfer\n     *  @dev    `transferLP()`: transfer `LP` ownership from `PositionManager` contract\n     *  @dev    === Write state ===\n     *  @dev    `positionIndexes`: remove from bucket index\n     *  @dev    `positions`: delete bucket position\n     *  @dev    === Revert on ===\n     *  @dev    - `mayInteract`:\n     *  @dev      token id is not a valid / minted id\n     *  @dev      sender is not owner `NoAuth()`\n     *  @dev      token id not minted for given pool `WrongPool()`\n     *  @dev    - position not tracked `RemoveLiquidityFailed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RedeemPosition`\n     */\n    function reedemPositions(\n        RedeemPositionsParams calldata params_\n    ) external override mayInteract(params_.pool, params_.tokenId) {\n        EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];\n\n        IPool pool = IPool(params_.pool);\n\n        uint256 indexesLength = params_.indexes.length;\n        uint256[] memory lpAmounts = new uint256[](indexesLength);\n\n        uint256 index;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            index = params_.indexes[i];\n\n            Position memory position = positions[params_.tokenId][index];\n\n            if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();\n\n            // check that bucket didn't go bankrupt after memorialization\n            if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) revert BucketBankrupt();\n\n            // remove bucket index at which a position has added liquidity\n            if (!positionIndex.remove(index)) revert RemovePositionFailed();\n\n            lpAmounts[i] = position.lps;\n\n            // remove LP tracked by position manager at bucket index\n            delete positions[params_.tokenId][index];\n\n            unchecked { ++i; }\n        }\n\n        address owner = ownerOf(params_.tokenId);\n\n        // approve owner to take over the LP ownership (required for transferLP pool call)\n        pool.increaseLPAllowance(owner, params_.indexes, lpAmounts);\n        // update pool lps accounting and transfer ownership of lps from PositionManager contract\n        pool.transferLP(address(this), owner, params_.indexes);\n\n        emit RedeemPosition(owner, params_.tokenId, params_.indexes);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Retrieves token's next nonce for permit.\n     *  @param  tokenId_ Address of the `Ajna` pool to retrieve accumulators of.\n     *  @return Incremented token permit nonce.\n     */\n    function _getAndIncrementNonce(\n        uint256 tokenId_\n    ) internal override returns (uint256) {\n        return uint256(nonces[tokenId_]++);\n    }\n\n    /**\n     *  @notice Checks that a provided pool address was deployed by an `Ajna` factory.\n     *  @param  pool_       Address of the `Ajna` pool.\n     *  @param  subsetHash_ Factory's subset hash pool.\n     *  @return `True` if a valid `Ajna` pool, `false` otherwise.\n     */\n    function _isAjnaPool(\n        address pool_,\n        bytes32 subsetHash_\n    ) internal view returns (bool) {\n        address collateralAddress = IPool(pool_).collateralAddress();\n        address quoteAddress      = IPool(pool_).quoteTokenAddress();\n\n        address erc20DeployedPoolAddress  = erc20PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n        address erc721DeployedPoolAddress = erc721PoolFactory.deployedPools(subsetHash_, collateralAddress, quoteAddress);\n\n        return (pool_ == erc20DeployedPoolAddress || pool_ == erc721DeployedPoolAddress);\n    }\n\n    /**\n     *  @notice Checks that a bucket index associated with a given `NFT` didn't go bankrupt after memorialization.\n     *  @param  pool_        The address of the pool of memorialized position.\n     *  @param  index_       The bucket index to check deposit time for.\n     *  @param  depositTime_ The recorded deposit time of the position.\n     *  @return `True` if the bucket went bankrupt after that position memorialzied their `LP`.\n     */\n    function _bucketBankruptAfterDeposit(\n        IPool pool_,\n        uint256 index_,\n        uint256 depositTime_\n    ) internal view returns (bool) {\n        (, , uint256 bankruptcyTime, , ) = pool_.bucketInfo(index_);\n        return depositTime_ <= bankruptcyTime;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getLP(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (uint256) {\n        Position memory position = positions[tokenId_][index_];\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, position.depositTime) ? 0 : position.lps;\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexes(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory) {\n        return positionIndexes[tokenId_].values();\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionIndexesFiltered(\n        uint256 tokenId_\n    ) external view override returns (uint256[] memory filteredIndexes_) {\n        uint256[] memory indexes = positionIndexes[tokenId_].values();\n        uint256 indexesLength = indexes.length;\n\n        // filter out bankrupt buckets\n        filteredIndexes_ = new uint256[](indexesLength);\n        uint256 filteredIndexesLength = 0;\n        IPool pool = IPool(poolKey[tokenId_]);\n        for (uint256 i = 0; i < indexesLength; ) {\n            if (!_bucketBankruptAfterDeposit(pool, indexes[i], positions[tokenId_][indexes[i]].depositTime)) {\n                filteredIndexes_[filteredIndexesLength++] = indexes[i];\n            }\n            unchecked { ++i; }\n        }\n\n        // resize array\n        assembly { mstore(filteredIndexes_, filteredIndexesLength) }\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function getPositionInfo(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (uint256, uint256) {\n        return (\n            positions[tokenId_][index_].lps,\n            positions[tokenId_][index_].depositTime\n        );\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isPositionBucketBankrupt(\n        uint256 tokenId_,\n        uint256 index_\n    ) external view override returns (bool) {\n        return _bucketBankruptAfterDeposit(IPool(poolKey[tokenId_]), index_, positions[tokenId_][index_].depositTime);\n    }\n\n    /// @inheritdoc IPositionManagerDerivedState\n    function isIndexInPosition(\n        uint256 tokenId_,\n        uint256 index_\n    ) external override view returns (bool) {\n        return positionIndexes[tokenId_].contains(index_);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(\n        uint256 tokenId_\n    ) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId_));\n\n        address collateralTokenAddress = IPool(poolKey[tokenId_]).collateralAddress();\n        address quoteTokenAddress      = IPool(poolKey[tokenId_]).quoteTokenAddress();\n\n        PositionNFTSVG.ConstructTokenURIParams memory params = PositionNFTSVG.ConstructTokenURIParams({\n            collateralTokenSymbol: tokenSymbol(collateralTokenAddress),\n            quoteTokenSymbol:      tokenSymbol(quoteTokenAddress),\n            tokenId:               tokenId_,\n            pool:                  poolKey[tokenId_],\n            owner:                 ownerOf(tokenId_),\n            indexes:               positionIndexes[tokenId_].values()\n        });\n\n        return PositionNFTSVG.constructTokenURI(params);\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { IERC721 }         from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport {\n    IRewardsManager,\n    IRewardsManagerOwnerActions,\n    IRewardsManagerState,\n    IRewardsManagerDerivedState\n} from './interfaces/rewards/IRewardsManager.sol';\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n\nimport { PositionManager } from './PositionManager.sol';\n\nimport { Maths } from './libraries/internal/Maths.sol';\n\n/**\n *  @title  Rewards (staking) Manager contract\n *  @notice Pool lenders can optionally mint `NFT` that represents their positions.\n *          The Rewards contract allows pool lenders with positions `NFT` to stake and earn `Ajna` tokens. \n *          Lenders with `NFT`s can:\n *          - `stake` token\n *          - `update bucket exchange rate` and earn rewards\n *          - `claim` rewards\n *          - `unstake` token\n */\ncontract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token `LP` `NFT` rewards.\n     */\n    uint256 internal constant REWARD_CAP = 0.8 * 1e18;\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token update rewards.\n     */\n    uint256 internal constant UPDATE_CAP = 0.1 * 1e18;\n    /**\n     * @notice Reward factor by which to scale the total rewards earned.\n     * @dev ensures that rewards issued to staked lenders in a given pool are less than the `Ajna` tokens burned in that pool.\n     */\n    uint256 internal constant REWARD_FACTOR = 0.5 * 1e18;\n    /**\n     * @notice Reward factor by which to scale rewards earned for updating a buckets exchange rate.\n     */\n    uint256 internal constant UPDATE_CLAIM_REWARD = 0.05 * 1e18;\n    /**\n     * @notice Time period after a burn event in which buckets exchange rates can be updated.\n     */\n    uint256 internal constant UPDATE_PERIOD = 2 weeks;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev `tokenID => epoch => bool has claimed` mapping.\n    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;\n    /// @dev `epoch => rewards claimed` mapping.\n    mapping(uint256 => uint256) public override rewardsClaimed;\n    /// @dev `epoch => update bucket rate rewards claimed` mapping.\n    mapping(uint256 => uint256) public override updateRewardsClaimed;\n\n    /// @dev Mapping of per pool bucket exchange rates at a given burn event `poolAddress => bucketIndex => epoch => bucket exchange rate`.\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal bucketExchangeRates;\n\n    /// @dev Mapping `tokenID => Stake info`.\n    mapping(uint256 => StakeInfo) internal stakes;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev Address of the `Ajna` token.\n    address public immutable ajnaToken;\n    /// @dev The `PositionManager` contract\n    IPositionManager public immutable positionManager;\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(address ajnaToken_, IPositionManager positionManager_) {\n        if (ajnaToken_ == address(0)) revert DeployWithZeroAddress();\n\n        ajnaToken = ajnaToken_;\n        positionManager = positionManager_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    already claimed `AlreadyClaimed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     */\n    function claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n\n        _claimRewards(stakeInfo, tokenId_, epochToClaim_, true, stakeInfo.ajnaPool);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    invalid index params `MoveStakedLiquidityInvalid()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveStakedLiquidity`\n     */\n    function moveStakedLiquidity(\n        uint256 tokenId_,\n        uint256[] memory fromBuckets_,\n        uint256[] memory toBuckets_,\n        uint256 expiry_\n    ) external nonReentrant override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        // check move array sizes match to be able to match on index\n        uint256 fromBucketLength = fromBuckets_.length;\n        if (fromBucketLength != toBuckets_.length) revert MoveStakedLiquidityInvalid();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // claim rewards before moving liquidity, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            curBurnEpoch,\n            false,\n            ajnaPool\n        );\n\n        uint256 fromIndex;\n        uint256 toIndex;\n        for (uint256 i = 0; i < fromBucketLength; ) {\n            fromIndex = fromBuckets_[i];\n            toIndex = toBuckets_[i];\n\n            // call out to position manager to move liquidity between buckets\n            IPositionManagerOwnerActions.MoveLiquidityParams memory moveLiquidityParams = IPositionManagerOwnerActions.MoveLiquidityParams(\n                tokenId_,\n                ajnaPool,\n                fromIndex,\n                toIndex,\n                expiry_\n            );\n            positionManager.moveLiquidity(moveLiquidityParams);\n\n            // update to bucket state\n            BucketState storage toBucket = stakeInfo.snapshot[toIndex];\n            toBucket.lpsAtStakeTime  = uint128(positionManager.getLP(tokenId_, toIndex));\n            toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex));\n            delete stakeInfo.snapshot[fromIndex];\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit MoveStakedLiquidity(tokenId_, fromBuckets_, toBuckets_);\n\n        // update to bucket list exchange rates, from buckets are aready updated on claim\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            toBuckets_\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Stake`\n     */\n    function stake(\n        uint256 tokenId_\n    ) external override {\n        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);\n\n        // check that msg.sender is owner of tokenId\n        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();\n\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n        stakeInfo.owner    = msg.sender;\n        stakeInfo.ajnaPool = ajnaPool;\n\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // record the staking epoch\n        stakeInfo.stakingEpoch = uint96(curBurnEpoch);\n\n        // initialize last time interaction at staking epoch\n        stakeInfo.lastClaimedEpoch = uint96(curBurnEpoch);\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n\n            uint256 bucketId = positionIndexes[i];\n\n            BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n            // record the number of lps in bucket at the time of staking\n            bucketState.lpsAtStakeTime = uint128(positionManager.getLP(\n                tokenId_,\n                bucketId\n            ));\n            // record the bucket exchange rate at the time of staking\n            bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId));\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit Stake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT to this contract\n        IERC721(address(positionManager)).transferFrom(msg.sender, address(this), tokenId_);\n\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            positionIndexes\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     *  @dev    - `Unstake`\n     */\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            IPool(ajnaPool).currentBurnEpoch(),\n            false,\n            ajnaPool\n        );\n\n        // remove bucket snapshots recorded at the time of staking\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n            delete stakeInfo.snapshot[positionIndexes[i]]; // reset BucketState struct for current position\n\n            unchecked { ++i; }\n        }\n\n        // remove recorded stake info\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).transferFrom(address(this), msg.sender, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Emit events ===\n     *  @dev    - `UpdateExchangeRates`\n     */\n    function updateBucketExchangeRatesAndClaim(\n        address pool_,\n        uint256[] calldata indexes_\n    ) external override returns (uint256 updateReward) {\n        updateReward = _updateBucketExchangeRates(pool_, indexes_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /***"
    }
  ]
}