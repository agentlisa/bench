{
  "Title": "[M-10] Router Owner Could Be Rugged By Admin",
  "Content": "_Submitted by xiaoming90, also found by unforgiven_\n\nAssume that Alice's router has large amount of liquidity inside.\n\nAssume that the Connext Admin decided to remove a router owned by Alice. The Connext Admin will call the `RoutersFacet.removeRouter` function, and all information related to Alice's router will be erased (set to 0x0) from the `s.routerPermissionInfo`.\n\n[RoutersFacet.sol#L293](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293)<br>\n\n```solidity\n  function removeRouter(address router) external onlyOwner {\n    // Sanity check: not empty\n    if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();\n\n    // Sanity check: needs removal\n    if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();\n\n    // Update mapping\n    s.routerPermissionInfo.approvedRouters[router] = false;\n\n    // Emit event\n    emit RouterRemoved(router, msg.sender);\n\n    // Remove router owner\n    address _owner = s.routerPermissionInfo.routerOwners[router];\n    if (_owner != address(0)) {\n      emit RouterOwnerAccepted(router, _owner, address(0));\n      // delete routerOwners[router];\n      s.routerPermissionInfo.routerOwners[router] = address(0);\n    }\n\n    // Remove router recipient\n    address _recipient = s.routerPermissionInfo.routerRecipients[router];\n    if (_recipient != address(0)) {\n      emit RouterRecipientSet(router, _recipient, address(0));\n      // delete routerRecipients[router];\n      s.routerPermissionInfo.routerRecipients[router] = address(0);\n    }\n\n    // Clear any proposed ownership changes\n    s.routerPermissionInfo.proposedRouterOwners[router] = address(0);\n    s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;\n  }\n```\n\nAlice is aware that her router has been removed by Connext Admin, so she decided to withdraw the liquidity from her previous router by calling `RoutersFacet.removeRouterLiquidityFor`.\n\nHowever, when Alice called the `RoutersFacet.removeRouterLiquidityFor` function, it will revert every single time. This is because the condition `msg.sender != getRouterOwner(_router)` will always fail.\n\n[RoutersFacet.sol#L490](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490)<br>\n\n```solidity\n  /**\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _to The address that will receive the liquidity being removed\n   * @param _router The address of the router\n   */\n  function removeRouterLiquidityFor(\n    uint256 _amount,\n    address _local,\n    address payable _to,\n    address _router\n  ) external nonReentrant whenNotPaused {\n    // Caller must be the router owner\n    if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();\n\n    // Remove liquidity\n    _removeLiquidityForRouter(_amount, _local, _to, _router);\n  }\n```\n\nSince the `RoutersFacet.removeRouter` function has earlier erased all information related to Alice's router within `s.routerPermissionInfo`, the `getRouterOwner` function will always return the router address.\n\nIn this case, the router address will not match against `msg.sender` address/Alice address, thus Alice attempts to call `removeRouterLiquidityFor` will always revert.\n\n[RoutersFacet.sol#L212](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212)<br>\n\n```solidity\n  function getRouterOwner(address _router) public view returns (address) {\n    address _owner = s.routerPermissionInfo.routerOwners[_router];\n    return _owner == address(0) ? _router : _owner;\n  }\n```\n\n### Impact\n\nRouter owner who provides liquidity could be rugged by Connext admin. When this happen, the router owner funds will be struck  within the `RoutersFacet` contract, and there is no way for the router owner to retrieve their liquidity.\n\nIn the worst case scenario, a compromised Connext admin could remove all routers, and cause all liquidity to be struck within `RoutersFacet` and no router owner could withdraw their liquidity from the contract. Next, the `RouterFacet` contract could be upgraded to include additional function to withdraw all liquidity from the contract to an arbitrary wallet address.\n\n### Recommended Mitigation Steps\n\nThe router owner is still entitled to their own liquidity even though their router has been removed by Connext Admin. Thus, they should be given the right to take back their liquidity when such an event happens. The contract should update its implementation to support this. This will give more assurance to the router owner.\n\n**[jakekidd (Connext) acknowledged and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/150#issuecomment-1166615569):**\n > The language here is slightly exaggerated - router funds could not be stolen by the Owner; the Owner can only prevent the router from accessing them by revoking their approval.\n> \n> However, it's still a valid concern, and one that will ultimately be addressed once router permissioning/whitelisting is removed permanently *or* the Owner role will be delegated to governance.\n> \n> The problem with the mitigation step proposed here is that the owner might not be set in some cases, so it's not a complete solution. So even if router approval is revoked, but we leave the assignment in the ownership mapping, in cases where the router did not assign an owner they won't be able to withdraw.\n> \n> There might be a better solution here by leaving the recipient in the corresponding mapping instead. In the `removeLiquidityFor` function, we can handle the case where the router's approval/ownership has been revoked by sending the funds to the recipient regardless of the caller. Unlike the owner, the recipient is always set on router registration.\n\n**[jakekidd (Connext) confirmed and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/150#issuecomment-1166615780):**\n > Changing this to be confirmed - would like to resolve this issue by carrying out the solution described in above comment ^\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/150#issuecomment-1214244936):**\n > I think this is only a valid `medium` because the admin is an EOA and not delegated to a governance contract. Keeping it as is.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/facets/RoutersFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {AppStorage} from \"../libraries/LibConnextStorage.sol\";\n\n/**\n * @notice\n * This contract is designed to manage router access, meaning it maintains the\n * router recipients, owners, and the router whitelist itself.\n *\n * As a router, there are three important permissions:\n * `router` - this is the address that will sign bids sent to the sequencer\n * `routerRecipient` - this is the address that receives funds when liquidity is withdrawn\n * `routerOwner` - this is the address permitted to update recipients and propose new owners\n *\n * In cases where the owner is not set, the caller should be the `router` itself. In cases where the\n * `routerRecipient` is not set, the funds can be removed to anywhere.\n *\n * When setting a new `routerOwner`, the current owner (or router) must create a proposal, which\n * can be accepted by the proposed owner after the delay period. If the proposed owner is the empty\n * address, then it must be accepted by the current owner.\n */\ncontract RoutersFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error RoutersFacet__acceptProposedRouterOwner_notElapsed();\n  error RoutersFacet__setRouterRecipient_notNewRecipient();\n  error RoutersFacet__onlyRouterOwner_notRouterOwner();\n  error RoutersFacet__onlyProposedRouterOwner_notRouterOwner();\n  error RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner();\n  error RoutersFacet__removeRouter_routerEmpty();\n  error RoutersFacet__removeRouter_notAdded();\n  error RoutersFacet__setupRouter_routerEmpty();\n  error RoutersFacet__setupRouter_alreadyAdded();\n  error RoutersFacet__proposeRouterOwner_notNewOwner();\n  error RoutersFacet__proposeRouterOwner_badRouter();\n  error RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\n  error RoutersFacet__addLiquidityForRouter_routerEmpty();\n  error RoutersFacet__addLiquidityForRouter_amountIsZero();\n  error RoutersFacet__addLiquidityForRouter_badRouter();\n  error RoutersFacet__addLiquidityForRouter_badAsset();\n  error RoutersFacet__removeRouterLiquidity_recipientEmpty();\n  error RoutersFacet__removeRouterLiquidity_amountIsZero();\n  error RoutersFacet__removeRouterLiquidity_insufficientFunds();\n  error RoutersFacet__removeRouterLiquidityFor_notOwner();\n  error RoutersFacet__setLiquidityFeeNumerator_tooSmall();\n  error RoutersFacet__setLiquidityFeeNumerator_tooLarge();\n  error RoutersFacet__approveRouterForPortal_notRouter();\n  error RoutersFacet__approveRouterForPortal_alreadyApproved();\n  error RoutersFacet__unapproveRouterForPortal_notApproved();\n\n  // ============ Properties ============\n\n  // ============ Constants ============\n  uint256 private constant _delay = 7 days;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new router is added\n   * @param router - The address of the added router\n   * @param caller - The account that called the function\n   */\n  event RouterAdded(address indexed router, address caller);\n\n  /**\n   * @notice Emitted when an existing router is removed\n   * @param router - The address of the removed router\n   * @param caller - The account that called the function\n   */\n  event RouterRemoved(address indexed router, address caller);\n\n  /**\n   * @notice Emitted when the recipient of router is updated\n   * @param router - The address of the added router\n   * @param prevRecipient  - The address of the previous recipient of the router\n   * @param newRecipient  - The address of the new recipient of the router\n   */\n  event RouterRecipientSet(address indexed router, address indexed prevRecipient, address indexed newRecipient);\n\n  /**\n   * @notice Emitted when the owner of router is proposed\n   * @param router - The address of the added router\n   * @param prevProposed  - The address of the previous proposed\n   * @param newProposed  - The address of the new proposed\n   */\n  event RouterOwnerProposed(address indexed router, address indexed prevProposed, address indexed newProposed);\n\n  /**\n   * @notice Emitted when the owner of router is accepted\n   * @param router - The address of the added router\n   * @param prevOwner  - The address of the previous owner of the router\n   * @param newOwner  - The address of the new owner of the router\n   */\n  event RouterOwnerAccepted(address indexed router, address indexed prevOwner, address indexed newOwner);\n\n  /**\n   * @notice Emitted when the maxRoutersPerTransfer variable is updated\n   * @param maxRoutersPerTransfer - The maxRoutersPerTransfer new value\n   * @param caller - The account that called the function\n   */\n  event MaxRoutersPerTransferUpdated(uint256 maxRoutersPerTransfer, address caller);\n\n  /**\n   * @notice Emitted when the LIQUIDITY_FEE_NUMERATOR variable is updated\n   * @param liquidityFeeNumerator - The LIQUIDITY_FEE_NUMERATOR new value\n   * @param caller - The account that called the function\n   */\n  event LiquidityFeeNumeratorUpdated(uint256 liquidityFeeNumerator, address caller);\n\n  /**\n   * @notice Emitted when a router is approved for Portal\n   * @param router - The address of the approved router\n   * @param caller - The account that called the function\n   */\n  event RouterApprovedForPortal(address router, address caller);\n\n  /**\n   * @notice Emitted when a router is disapproved for Portal\n   * @param router - The address of the disapproved router\n   * @param caller - The account that called the function\n   */\n  event RouterUnapprovedForPortal(address router, address caller);\n\n  /**\n   * @notice Emitted when a router adds liquidity to the contract\n   * @param router - The address of the router the funds were credited to\n   * @param local - The address of the token added (all liquidity held in local asset)\n   * @param amount - The amount of liquidity added\n   * @param caller - The account that called the function\n   */\n  event RouterLiquidityAdded(\n    address indexed router,\n    address local,\n    bytes32 canonicalId,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when a router withdraws liquidity from the contract\n   * @param router - The router you are removing liquidity from\n   * @param to - The address the funds were withdrawn to\n   * @param local - The address of the token withdrawn\n   * @param amount - The amount of liquidity withdrawn\n   * @param caller - The account that called the function\n   */\n  event RouterLiquidityRemoved(address indexed router, address to, address local, uint256 amount, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Asserts caller is the router owner (if set) or the router itself\n   */\n  modifier onlyRouterOwner(address _router) {\n    address owner = s.routerPermissionInfo.routerOwners[_router];\n    if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\n      revert RoutersFacet__onlyRouterOwner_notRouterOwner();\n    _;\n  }\n\n  /**\n   * @notice Asserts caller is the proposed router. If proposed router is address(0), then asserts\n   * the owner is calling the function (if set), or the router itself is calling the function\n   */\n  modifier onlyProposedRouterOwner(address _router) {\n    address proposed = s.routerPermissionInfo.proposedRouterOwners[_router];\n    if (proposed == address(0)) {\n      address owner = s.routerPermissionInfo.routerOwners[_router];\n      if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\n        revert RoutersFacet__onlyProposedRouterOwner_notRouterOwner();\n    } else {\n      if (msg.sender != proposed) revert RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner();\n    }\n    _;\n  }\n\n  // ============ Getters ==============\n\n  function LIQUIDITY_FEE_NUMERATOR() public view returns (uint256) {\n    return s.LIQUIDITY_FEE_NUMERATOR;\n  }\n\n  function LIQUIDITY_FEE_DENOMINATOR() public view returns (uint256) {\n    return s.LIQUIDITY_FEE_DENOMINATOR;\n  }\n\n  /**\n   * @notice Returns the approved router for the given router address\n   * @param _router The relevant router address\n   */\n  function getRouterApproval(address _router) public view returns (bool) {\n    return s.routerPermissionInfo.approvedRouters[_router];\n  }\n\n  /**\n   * @notice Returns the recipient for the specified router\n   * @dev The recipient (if set) receives all funds when router liquidity is removed\n   * @param _router The relevant router address\n   */\n  function getRouterRecipient(address _router) public view returns (address) {\n    return s.routerPermissionInfo.routerRecipients[_router];\n  }\n\n  /**\n   * @notice Returns the router owner if it is set, or the router itself if not\n   * @dev Uses logic function here to handle the case where router owner is not set.\n   * Other getters within this interface use explicitly the stored value\n   * @param _router The relevant router address\n   */\n  function getRouterOwner(address _router) public view returns (address) {\n    address _owner = s.routerPermissionInfo.routerOwners[_router];\n    return _owner == address(0) ? _router : _owner;\n  }\n\n  /**\n   * @notice Returns the currently proposed router owner\n   * @dev All routers must wait for the delay timeout before accepting a new owner\n   * @param _router The relevant router address\n   */\n  function getProposedRouterOwner(address _router) public view returns (address) {\n    return s.routerPermissionInfo.proposedRouterOwners[_router];\n  }\n\n  /**\n   * @notice Returns the currently proposed router owner timestamp\n   * @dev All routers must wait for the delay timeout before accepting a new owner\n   * @param _router The relevant router address\n   */\n  function getProposedRouterOwnerTimestamp(address _router) public view returns (uint256) {\n    return s.routerPermissionInfo.proposedRouterTimestamp[_router];\n  }\n\n  function maxRoutersPerTransfer() public view returns (uint256) {\n    return s.maxRoutersPerTransfer;\n  }\n\n  function routerBalances(address _router, address _asset) public view returns (uint256) {\n    return s.routerBalances[_router][_asset];\n  }\n\n  /**\n   * @notice Returns whether the router is approved for portals or not\n   * @param _router The relevant router address\n   */\n  function getRouterApprovalForPortal(address _router) public view returns (bool) {\n    return s.routerPermissionInfo.approvedForPortalRouters[_router];\n  }\n\n  // ============ Admin methods ==============\n\n  /**\n   * @notice Used to set router initial properties\n   * @param router Router address to setup\n   * @param owner Initial Owner of router\n   * @param recipient Initial Recipient of router\n   */\n  function setupRouter(\n    address router,\n    address owner,\n    address recipient\n  ) external onlyOwner {\n    // Sanity check: not empty\n    if (router == address(0)) revert RoutersFacet__setupRouter_routerEmpty();\n\n    // Sanity check: needs approval\n    if (s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__setupRouter_alreadyAdded();\n\n    // Approve router\n    s.routerPermissionInfo.approvedRouters[router] = true;\n\n    // Emit event\n    emit RouterAdded(router, msg.sender);\n\n    // Update routerOwner (zero address possible)\n    if (owner != address(0)) {\n      s.routerPermissionInfo.routerOwners[router] = owner;\n      emit RouterOwnerAccepted(router, address(0), owner);\n    }\n\n    // Update router recipient\n    if (recipient != address(0)) {\n      s.routerPermissionInfo.routerRecipients[router] = recipient;\n      emit RouterRecipientSet(router, address(0), recipient);\n    }\n  }\n\n  /**\n   * @notice Used to remove routers that can transact crosschain\n   * @param router Router address to remove\n   */\n  function removeRouter(address router) external onlyOwner {\n    // Sanity check: not empty\n    if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();\n\n    // Sanity check: needs removal\n    if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();\n\n    // Update mapping\n    s.routerPermissionInfo.approvedRouters[router] = false;\n\n    // Emit event\n    emit RouterRemoved(router, msg.sender);\n\n    // Remove router owner\n    address _owner = s.routerPermissionInfo.routerOwners[router];\n    if (_owner != address(0)) {\n      emit RouterOwnerAccepted(router, _owner, address(0));\n      // delete routerOwners[router];\n      s.routerPermissionInfo.routerOwners[router] = address(0);\n    }\n\n    // Remove router recipient\n    address _recipient = s.routerPermissionInfo.routerRecipients[router];\n    if (_recipient != address(0)) {\n      emit RouterRecipientSet(router, _recipient, address(0));\n      // delete routerRecipients[router];\n      s.routerPermissionInfo.routerRecipients[router] = address(0);\n    }\n\n    // Clear any proposed ownership changes\n    s.routerPermissionInfo.proposedRouterOwners[router] = address(0);\n    s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;\n  }\n\n  /**\n   * @notice Used to set the max amount of routers a payment can be routed through\n   * @param _newMaxRouters The new max amount of routers\n   */\n  function setMaxRoutersPerTransfer(uint256 _newMaxRouters) external onlyOwner {\n    if (_newMaxRouters == 0 || _newMaxRouters == s.maxRoutersPerTransfer)\n      revert RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\n\n    emit MaxRoutersPerTransferUpdated(_newMaxRouters, msg.sender);\n\n    s.maxRoutersPerTransfer = _newMaxRouters;\n  }\n\n  /**\n   * @notice Sets the LIQUIDITY_FEE_NUMERATOR\n   * @dev Admin can set LIQUIDITY_FEE_NUMERATOR variable, Liquidity fee should be less than 5%\n   * @param _numerator new LIQUIDITY_FEE_NUMERATOR\n   */\n  function setLiquidityFeeNumerator(uint256 _numerator) external onlyOwner {\n    // Slightly misleading: the liquidity fee numerator is not the amount charged,\n    // but the amount received after fees are deducted (e.g. 9995/10000 would be .005%).\n    uint256 denominator = s.LIQUIDITY_FEE_DENOMINATOR;\n    if (_numerator < (denominator * 95) / 100) revert RoutersFacet__setLiquidityFeeNumerator_tooSmall();\n\n    if (_numerator > denominator) revert RoutersFacet__setLiquidityFeeNumerator_tooLarge();\n    s.LIQUIDITY_FEE_NUMERATOR = _numerator;\n\n    emit LiquidityFeeNumeratorUpdated(_numerator, msg.sender);\n  }\n\n  /**\n   * @notice Allow router to use Portals\n   * @param _router - The router address to approve\n   */\n  function approveRouterForPortal(address _router) external onlyOwner {\n    if (!s.routerPermissionInfo.approvedRouters[_router]) revert RoutersFacet__approveRouterForPortal_notRouter();\n    if (s.routerPermissionInfo.approvedForPortalRouters[_router])\n      revert RoutersFacet__approveRouterForPortal_alreadyApproved();\n\n    s.routerPermissionInfo.approvedForPortalRouters[_router] = true;\n\n    emit RouterApprovedForPortal(_router, msg.sender);\n  }\n\n  /**\n   * @notice Remove router access to use Portals\n   * @param _router - The router address to remove approval\n   */\n  function unapproveRouterForPortal(address _router) external onlyOwner {\n    if (!s.routerPermissionInfo.approvedForPortalRouters[_router])\n      revert RoutersFacet__unapproveRouterForPortal_notApproved();\n\n    s.routerPermissionInfo.approvedForPortalRouters[_router] = false;\n\n    emit RouterUnapprovedForPortal(_router, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Sets the designated recipient for a router\n   * @dev Router should only be able to set this once otherwise if router key compromised,\n   * no problem is solved since attacker could just update recipient\n   * @param router Router address to set recipient\n   * @param recipient Recipient Address to set to router\n   */\n  function setRouterRecipient(address router, address recipient) external onlyRouterOwner(router) {\n    // Check recipient is changing\n    address _prevRecipient = s.routerPermissionInfo.routerRecipients[router];\n    if (_prevRecipient == recipient) revert RoutersFacet__setRouterRecipient_notNewRecipient();\n\n    // Set new recipient\n    s.routerPermissionInfo.routerRecipients[router] = recipient;\n\n    // Emit event\n    emit RouterRecipientSet(router, _prevRecipient, recipient);\n  }\n\n  /**\n   * @notice Current owner or router may propose a new router owner\n   * @param router Router address to set recipient\n   * @param proposed Proposed owner Address to set to router\n   */\n  function proposeRouterOwner(address router, address proposed) external onlyRouterOwner(router) {\n    // Check that proposed is different than current owner\n    if (getRouterOwner(router) == proposed) revert RoutersFacet__proposeRouterOwner_notNewOwner();\n\n    // Check that proposed is different than current proposed\n    address _currentProposed = s.routerPermissionInfo.proposedRouterOwners[router];\n    if (_currentProposed == proposed) revert RoutersFacet__proposeRouterOwner_badRouter();\n\n    // Set proposed owner + timestamp\n    s.routerPermissionInfo.proposedRouterOwners[router] = proposed;\n    s.routerPermissionInfo.proposedRouterTimestamp[router] = block.timestamp;\n\n    // Emit event\n    emit RouterOwnerProposed(router, _currentProposed, proposed);\n  }\n\n  /**\n   * @notice New router owner must accept role, or previous if proposed is 0x0\n   * @param router Router address to set recipient\n   */\n  function acceptProposedRouterOwner(address router) external onlyProposedRouterOwner(router) {\n    address owner = getRouterOwner(router);\n\n    // Check timestamp has passed\n    if (block.timestamp - s.routerPermissionInfo.proposedRouterTimestamp[router] <= _delay)\n      revert RoutersFacet__acceptProposedRouterOwner_notElapsed();\n\n    // Get current owner + proposed\n    address _proposed = s.routerPermissionInfo.proposedRouterOwners[router];\n\n    // Update the current owner\n    s.routerPermissionInfo.routerOwners[router] = _proposed;\n\n    // Reset proposal + timestamp\n    if (_proposed != address(0)) {\n      s.routerPermissionInfo.proposedRouterOwners[router] = address(0);\n    }\n    s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;\n\n    // Emit event\n    emit RouterOwnerAccepted(router, owner, _proposed);\n  }\n\n  /**\n   * @notice This is used by anyone to increase a router's available liquidity for a given asset.\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the asset you're adding liquidity for. If adding liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _router The router you are adding liquidity on behalf of\n   */\n  function addRouterLiquidityFor(\n    uint256 _amount,\n    address _local,\n    address _router\n  ) external payable nonReentrant whenNotPaused {\n    _addLiquidityForRouter(_amount, _local, _router);\n  }\n\n  /**\n   * @notice This is used by any router to increase their available liquidity for a given asset.\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the asset you're adding liquidity for. If adding liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   */\n  function addRouterLiquidity(uint256 _amount, address _local) external payable nonReentrant whenNotPaused {\n    _addLiquidityForRouter(_amount, _local, msg.sender);\n  }\n\n  /**\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _to The address that will receive the liquidity being removed\n   * @param _router The address of the router\n   */\n  function removeRouterLiquidityFor(\n    uint256 _amount,\n    address _local,\n    address payable _to,\n    address _router\n  ) external nonReentrant whenNotPaused {\n    // Caller must be the router owner\n    if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();\n\n    // Remove liquidity\n    _removeLiquidityForRouter(_amount, _local, _to, _router);\n  }\n\n  /**\n   * @notice This is used by any router to decrease their available liquidity for a given asset.\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _to The address that will receive the liquidity being removed if no router recipient exists.\n   */\n  function removeRouterLiquidity(\n    uint256 _amount,\n    address _local,\n    address payable _to\n  ) external nonReentrant whenNotPaused {\n    _removeLiquidityForRouter(_amount, _local, _to, msg.sender);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Contains the logic to verify + increment a given routers liquidity\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the nomad representation of the asset\n   * @param _router - The router you are adding liquidity on behalf of\n   */\n  function _addLiquidityForRouter(\n    uint256 _amount,\n    address _local,\n    address _router\n  ) internal {\n    // Sanity check: router is sensible\n    if (_router == address(0)) revert RoutersFacet__addLiquidityForRouter_routerEmpty();\n\n    // Sanity check: nonzero amounts\n    if (_amount == 0) revert RoutersFacet__addLiquidityForRouter_amountIsZero();\n\n    // Get the canonical asset id from the representation\n    (, bytes32 canonicalId) = s.tokenRegistry.getTokenId(_local == address(0) ? address(s.wrapper) : _local);\n\n    // Router is approved\n    if (!_isRouterOwnershipRenounced() && !getRouterApproval(_router))\n      revert RoutersFacet__addLiquidityForRouter_badRouter();\n\n    // Asset is approved\n    if (!_isAssetOwnershipRenounced() && !s.approvedAssets[canonicalId])\n      revert RoutersFacet__addLiquidityForRouter_badAsset();\n\n    // Transfer funds to contract\n    (address asset, uint256 received) = AssetLogic.handleIncomingAsset(_local, _amount, 0);\n\n    // Update the router balances. Happens after pulling funds to account for\n    // the fee on transfer tokens\n    s.routerBalances[_router][asset] += received;\n\n    // Emit event\n    emit RouterLiquidityAdded(_router, asset, canonicalId, received, msg.sender);\n  }\n\n  /**\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _to The address that will receive the liquidity being removed\n   * @param _router The address of the router\n   */\n  function _removeLiquidityForRouter(\n    uint256 _amount,\n    address _local,\n    address payable _to,\n    address _router\n  ) internal {\n    // transfer to specicfied recipient IF recipient not set\n    address recipient = getRouterRecipient(_router);\n    recipient = recipient == address(0) ? _to : recipient;\n\n    // Sanity check: to is sensible\n    if (recipient == address(0)) revert RoutersFacet__removeRouterLiquidity_recipientEmpty();\n\n    // Sanity check: nonzero amounts\n    if (_amount == 0) revert RoutersFacet__removeRouterLiquidity_amountIsZero();\n\n    // Get the local key\n    address key = _local == address(0) ? address(s.wrapper) : _local;\n\n    // Get existing router balance\n    uint256 routerBalance = s.routerBalances[_router][key];\n\n    // Sanity check: amount can be deducted for the router\n    if (routerBalance < _amount) revert RoutersFacet__removeRouterLiquidity_insufficientFunds();\n\n    // Update router balances\n    unchecked {\n      s.routerBalances[_router][key] = routerBalance - _amount;\n    }\n\n    // Transfer from contract to specified to\n    AssetLogic.transferAssetFromContract(key, recipient, _amount);\n\n    // Emit event\n    emit RouterLiquidityRemoved(_router, recipient, _local, _amount, msg.sender);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/facets/RoutersFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {AppStorage} from \"../libraries/LibConnextStorage.sol\";\n\n/**\n * @notice\n * This contract is designed to manage router access, meaning it maintains the\n * router recipients, owners, and the router whitelist itself.\n *\n * As a router, there are three important permissions:\n * `router` - this is the address that will sign bids sent to the sequencer\n * `routerRecipient` - this is the address that receives funds when liquidity is withdrawn\n * `routerOwner` - this is the address permitted to update recipients and propose new owners\n *\n * In cases where the owner is not set, the caller should be the `router` itself. In cases where the\n * `routerRecipient` is not set, the funds can be removed to anywhere.\n *\n * When setting a new `routerOwner`, the current owner (or router) must create a proposal, which\n * can be accepted by the proposed owner after the delay period. If the proposed owner is the empty\n * address, then it must be accepted by the current owner.\n */\ncontract RoutersFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error RoutersFacet__acceptProposedRouterOwner_notElapsed();\n  error RoutersFacet__setRouterRecipient_notNewRecipient();\n  error RoutersFacet__onlyRouterOwner_notRouterOwner();\n  error RoutersFacet__onlyProposedRouterOwner_notRouterOwner();\n  error RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner();\n  error RoutersFacet__removeRouter_routerEmpty();\n  error RoutersFacet__removeRouter_notAdded();\n  error RoutersFacet__setupRouter_routerEmpty();\n  error RoutersFacet__setupRouter_alreadyAdded();\n  error RoutersFacet__proposeRouterOwner_notNewOwner();\n  error RoutersFacet__proposeRouterOwner_badRouter();\n  error RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\n  error RoutersFacet__addLiquidityForRouter_routerEmpty();\n  error RoutersFacet__addLiquidityForRouter_amountIsZero();\n  error RoutersFacet__addLiquidityForRouter_badRouter();\n  error RoutersFacet__addLiquidityForRouter_badAsset();\n  error RoutersFacet__removeRouterLiquidity_recipientEmpty();\n  error RoutersFacet__removeRouterLiquidity_amountIsZero();\n  error RoutersFacet__removeRouterLiquidity_insufficientFunds();\n  error RoutersFacet__removeRouterLiquidityFor_notOwner();\n  error RoutersFacet__setLiquidityFeeNumerator_tooSmall();\n  error RoutersFacet__setLiquidityFeeNumerator_tooLarge();\n  error RoutersFacet__approveRouterForPortal_notRouter();\n  error RoutersFacet__approveRouterForPortal_alreadyApproved();\n  error RoutersFacet__unapproveRouterForPortal_notApproved();\n\n  // ============ Properties ============\n\n  // ============ Constants ============\n  uint256 private constant _delay = 7 days;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new router is added\n   * @param router - The address of the added router\n   * @param caller - The account that called the function\n   */\n  event RouterAdded(address indexed router, address caller);\n\n  /**\n   * @notice Emitted when an existing router is removed\n   * @param router - The address of the removed router\n   * @param caller - The account that called the function\n   */\n  event RouterRemoved(address indexed router, address caller);\n\n  /**\n   * @notice Emitted when the recipient of router is updated\n   * @param router - The address of the added router\n   * @param prevRecipient  - The address of the previous recipient of the router\n   * @param newRecipient  - The address of the new recipient of the router\n   */\n  event RouterRecipientSet(address indexed router, address indexed prevRecipient, address indexed newRecipient);\n\n  /**\n   * @notice Emitted when the owner of router is proposed\n   * @param router - The address of the added router\n   * @param prevProposed  - The address of the previous proposed\n   * @param newProposed  - The address of the new proposed\n   */\n  event RouterOwnerProposed(address indexed router, address indexed prevProposed, address indexed newProposed);\n\n  /**\n   * @notice Emitted when the owner of router is accepted\n   * @param router - The address of the added router\n   * @param prevOwner  - The address of the previous owner of the router\n   * @param newOwner  - The address of the new owner of the router\n   */\n  event RouterOwnerAccepted(address indexed router, address indexed prevOwner, address indexed newOwner);\n\n  /**\n   * @notice Emitted when the maxRoutersPerTransfer variable is updated\n   * @param maxRoutersPerTransfer - The maxRoutersPerTransfer new value\n   * @param caller - The account that called the function\n   */\n  event MaxRoutersPerTransferUpdated(uint256 maxRoutersPerTransfer, address caller);\n\n  /**\n   * @notice Emitted when the LIQUIDITY_FEE_NUMERATOR variable is updated\n   * @param liquidityFeeNumerator - The LIQUIDITY_FEE_NUMERATOR new value\n   * @param caller - The account that called the function\n   */\n  event LiquidityFeeNumeratorUpdated(uint256 liquidityFeeNumerator, address caller);\n\n  /**\n   * @notice Emitted when a router is approved for Portal\n   * @param router - The address of the approved router\n   * @param caller - The account that called the function\n   */\n  event RouterApprovedForPortal(address router, address caller);\n\n  /**\n   * @notice Emitted when a router is disapproved for Portal\n   * @param router - The address of the disapproved router\n   * @param caller - The account that called the function\n   */\n  event RouterUnapprovedForPortal(address router, address caller);\n\n  /**\n   * @notice Emitted when a router adds liquidity to the contract\n   * @param router - The address of the router the funds were credited to\n   * @param local - The address of the token added (all liquidity held in local asset)\n   * @param amount - The amount of liquidity added\n   * @param caller - The account that called the function\n   */\n  event RouterLiquidityAdded(\n    address indexed router,\n    address local,\n    bytes32 canonicalId,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when a router withdraws liquidity from the contract\n   * @param router - The router you are removing liquidity from\n   * @param to - The address the funds were withdrawn to\n   * @param local - The address of the token withdrawn\n   * @param amount - The amount of liquidity withdrawn\n   * @param caller - The account that called the function\n   */\n  event RouterLiquidityRemoved(address indexed router, address to, address local, uint256 amount, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Asserts caller is the router owner (if set) or the router itself\n   */\n  modifier onlyRouterOwner(address _router) {\n    address owner = s.routerPermissionInfo.routerOwners[_router];\n    if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\n      revert RoutersFacet__onlyRouterOwner_notRouterOwner();\n    _;\n  }\n\n  /**\n   * @notice Asserts caller is the proposed router. If proposed router is address(0), then asserts\n   * the owner is calling the function (if set), or the router itself is calling the function\n   */\n  modifier onlyProposedRouterOwner(address _router) {\n    address proposed = s.routerPermissionInfo.proposedRouterOwners[_router];\n    if (proposed == address(0)) {\n      address owner = s.routerPermissionInfo.routerOwners[_router];\n      if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\n        revert RoutersFacet__onlyProposedRouterOwner_notRouterOwner();\n    } else {\n      if (msg.sender != proposed) revert RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner();\n    }\n    _;\n  }\n\n  // ============ Getters ==============\n\n  function LIQUIDITY_FEE_NUMERATOR() public view returns (uint256) {\n    return s.LIQUIDITY_FEE_NUMERATOR;\n  }\n\n  function LIQUIDITY_FEE_DENOMINATOR() public view returns (uint256) {\n    return s.LIQUIDITY_FEE_DENOMINATOR;\n  }\n\n  /**\n   * @notice Returns the approved router for"
    }
  ]
}