{
  "Title": "M-23: Fee collector can grief the protocol by withdrawing trading fees that could still need to be returned to Party A",
  "Content": "# Issue M-23: Fee collector can grief the protocol by withdrawing trading fees that could still need to be returned to Party A \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/299 \n\n## Found by \nAkshaySrivastav, Ch\\_301, Lilyjjo, Ruhum, berndartmueller, bitsurfer, libratus, simon135\n## Summary\n\nThe fee collector can grief the SYMM protocol by withdrawing the collected trading fees, resulting in an underflow error when attempting to return trading fees to Party A due to the lack of available funds.\n\n## Vulnerability Detail\n\n[Trading fees are collected](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L119) whenever Party A creates a new quote via the `sendQuote` function in the `PartyAFacetImpl` library. The accumulated fees are accounted for in the `accountLayout.balances[GlobalAppStorage.layout().feeCollector]` storage variable, the same `balances` mapping that is also used to account for the balances for Party A and Party B. The fee collector can withdraw the received trading fees at any time with the `deposit` function in the `AccountFacet` contract.\n\nHowever, as trading fees are potentially returned to Party A, for example, when a quote gets canceled or expires, [deducting the returned trading fees](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L139) from the fee collector's balance can potentially revert with an underflow error if the balance is insufficient.\n\n## Impact\n\nIf insufficient funds are available in the fee collector's balance (`accountLayout.balances[GlobalAppStorage.layout().feeCollector]`), attempting to return trading fees to Party A will revert with an underflow error. This will grief and DoS the following functions until the fee collector's balance is sufficiently replenished:\n\n- `PartyAFacetImpl.requestToCancelQuote` in [line 136](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L136)\n- `PartyAFacetImpl.forceCancelQuote` in [line 227](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L227)\n- `PartyBFacetImpl.acceptCancelRequest` in [line 70](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L70)\n- `PartyBFacetImpl.openPosition` in [line 231](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L231)\n- `LibQuote.expireQuote` in [line 241](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L241)\n\n## Code Snippet\n\n[contracts/libraries/LibQuote.sol#L139](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L139)\n\n```solidity\n135: function returnTradingFee(uint256 quoteId) internal {\n136:     AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n137:     uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n138:     accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] += tradingFee;\n139:     accountLayout.balances[GlobalAppStorage.layout().feeCollector] -= tradingFee; // @audit-issue potentially reverts with an underflow error\n140: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider accounting the received trading fees in separate variables and keep track of the fees which can still be returned to Party A and only allow withdrawing the received fees that are non-returnable.\n\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 usdc\nThis is not valid M. This is not permanent, only temporary. Insufficient funds are available in the fee collector's balance, which occurs when the collector withdraws most of the balance. fee collector should be from protocol. so this is an administrator error.\n\n**sherlock-admin2**\n\n > Escalate for 10 usdc\n> This is not valid M. This is not permanent, only temporary. Insufficient funds are available in the fee collector's balance, which occurs when the collector withdraws most of the balance. fee collector should be from protocol. so this is an administrator error.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**CodingNameKiki**\n\nShould be invalid, admins are trusted authors.\n\n<img width=\"736\" alt=\"Screenshot 2023-07-26 at 15 30 51\" src=\"https://github.com/sherlock-audit/2023-06-symmetrical-judging/assets/112419701/8790342c-f601-4bd8-984d-e15626f7db73\">\n\n\n**berndartmueller**\n\nThe fee collector (`feeCollector`) is not necessarily the admin of the protocol (i.e., the fee collector address is not controlled by the admin). Thus the medium severity.\n\n**mstpr**\n\nEscalate\n\nfee collector address is set by the admin role which admin is trusted hence the fee collector should also be trusted. \n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/control/ControlFacet.sol#L235-L240\n\n**sherlock-admin2**\n\n > Escalate\n> \n> fee collector address is set by the admin role which admin is trusted hence the fee collector should also be trusted. \n> \n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/control/ControlFacet.sol#L235-L240\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**JeffCX**\n\n> Escalate\n> \n> fee collector address is set by the admin role which admin is trusted hence the fee collector should also be trusted.\n> \n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/control/ControlFacet.sol#L235-L240\n\nAgree with this escalation \n\n```solidity\n    function setFeeCollector(\n        address feeCollector\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\n        emit SetFeeCollector(GlobalAppStorage.layout().feeCollector, feeCollector);\n        GlobalAppStorage.layout().feeCollector = feeCollector;\n    }\n```\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/8\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAfter further review and internal discussion, the ownership of the fee collector is not relevant in the context of this report. The reason is that there is a logic error in the code, and it must be fixed. So when the users request to open a position, their trading fee is temporarily locked/escrowed in the contract under the fee collector account. If the users decide to cancel their pending position later, the trading fee will be refunded to the users. The main bug is that if the fee collector collects all the fees, there won't be any locked funds left in the fee collector account to refund the users if they cancel the position. The fees collected must be regularly distributed to the stakers. The issue here is all the fees pending/settled is together under once account. \nSo although the fee collector can be considered TRUSTED, the fee collector can still make the protocol malfunction by behaving in a trusted way, by claiming the fees.\nConsidering this a valid medium. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [securitygrid](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/299/#issuecomment-1651708343): rejected\n- [mstpr](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/299/#issuecomment-1653478089): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterRequestToClosePosition(\n            quoteId,\n            closePrice,\n            quantityToClose,\n            upnlSig\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            accountLayout.partyANonces[quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function forceCancelCloseRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyAFacet: Invalid state\"\n        );\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function forceClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        uint256 filledAmount = quote.quantityToClose;\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCloseCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(\n            quote.orderType == OrderType.LIMIT,\n            \"PartyBFacet: Quote's order type should be LIMIT\"\n        );\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                upnlSig.price >=\n                    quote.requestedClosePrice +\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        } else {\n            require(\n                upnlSig.price <=\n                    quote.requestedClosePrice -\n                        (quote.requestedClosePrice * maLayout.forceCloseGapRatio) /\n                        1e18,\n                \"PartyAFacet: Requested close price not reached\"\n            );\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(\n            quoteId,\n            filledAmount,\n            quote.requestedClosePrice,\n            upnlSig\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, quote.requestedClosePrice);\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n            quote.partyA\n        ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n            quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n            indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n            quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n\n    function returnTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] += tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] -= tradingFee;\n    }\n\n    function receiveTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] -= tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] += tradingFee;\n    }\n\n    function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        quote.modifyTimestamp = block.timestamp;\n\n        LockedValues memory lockedValues = LockedValues(\n            quote.lockedValues.cva -\n                ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.mm -\n                ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.lf -\n                ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n        );\n        accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n            lockedValues\n        );\n        quote.lockedValues = lockedValues;\n\n        (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n            closedPrice,\n            filledAmount,\n            quote\n        );\n        if (hasMadeProfit) {\n            accountLayout.allocatedBalances[quote.partyA] += pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n        } else {\n            accountLayout.allocatedBalances[quote.partyA] -= pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n        }\n\n        quote.avgClosedPrice =\n            (quote.avgClosedPrice * quote.closedAmount + filledAmount * closedPrice) /\n            (quote.closedAmount + filledAmount);\n\n        quote.closedAmount += filledAmount;\n        quote.quantityToClose -= filledAmount;\n\n        if (quote.closedAmount == quote.quantity) {\n            quote.quoteStatus = QuoteStatus.CLOSED;\n            quote.requestedClosePrice = 0;\n            removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n        ) {\n            quote.quoteStatus = QuoteStatus.OPENED;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n        } else {\n            require(\n                quote.lockedValues.total() >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\"\n            );\n        }\n    }\n\n    function expireQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(block.timestamp > quote.deadline, \"LibQuote: Quote isn't expired\");\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING ||\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"LibQuote: Invalid state\"\n        );\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"LibQuote: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"LibQuote: PartyB isn't solvent\"\n        );\n        if (\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            // send trading Fee back to partyA\n            LibQuote.returnTradingFee(quoteId);\n            removeFromPartyAPendingQuotes(quote);\n            if (\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n            ) {\n                accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n                removeFromPartyBPendingQuotes(quote);\n            }\n            quote.quoteStatus = QuoteStatus.EXPIRED;\n            result = QuoteStatus.EXPIRED;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0;\n            quote.quoteStatus = QuoteStatus.OPENED;\n            result = QuoteStatus.OPENED;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterRequestToClosePosition(\n            quoteId,\n            closePrice,\n            quantityToClose,\n            upnlSig\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            accountLayout.partyANonces[quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage"
    }
  ]
}