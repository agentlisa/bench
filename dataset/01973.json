{
  "Title": "H-14: Deadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed",
  "Content": "# Issue H-14: Deadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/145 \n\n## Found by \nBauer, Breeje, ctf\\_sec\n## Summary\n\nDeadline check is not effective, allowing outdated slippage and allow pending transaction to be unexpected executed\n\n## Vulnerability Detail\n\nIn the current implementation in CurveSpell.sol\n\n```solidity\n{\n\t// 2. Swap rewards tokens to debt token\n\tuint256 rewards = _doCutRewardsFee(CRV);\n\t_ensureApprove(CRV, address(swapRouter), rewards);\n\tswapRouter.swapExactTokensForTokens(\n\t\trewards,\n\t\t0,\n\t\tswapPath,\n\t\taddress(this),\n\t\ttype(uint256).max\n\t);\n}\n```\n\nthe deadline check is set to type(uint256).max, which means the deadline check is disabled!\n\nIn IChiSpell. the swap is directedly call on the pool instead of the router\n\n```solidity\nSWAP_POOL.swap(\n\taddress(this),\n\t// if withdraw token is Token0, then swap token1 -> token0 (false)\n\t!isTokenA,\n\tamountToSwap.toInt256(),\n\tisTokenA\n\t\t? param.sqrtRatioLimit + deltaSqrt\n\t\t: param.sqrtRatioLimit - deltaSqrt, // slippaged price cap\n\tabi.encode(address(this))\n);\n```\n\nand it has no deadline check for the transaction when swapping\n\n## Impact\n\nAMMs provide their users with an option to limit the execution of their pending actions, such as swaps or adding and removing liquidity. The most common solution is to include a deadline timestamp as a parameter (for example see Uniswap V2 and Uniswap V3). If such an option is not present, users can unknowingly perform bad trades:\n\nAlice wants to swap 100 tokens for 1 ETH and later sell the 1 ETH for 1000 DAI.\n\nThe transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n\nWhen the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of ETH could have drastically changed. She will still get 1 ETH but the DAI value of that output might be significantly lower. \n\nShe has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\nThe swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it. \n\nThe price of tokens has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her maximum slippage value (sqrtPriceLimitX96 and minOut in terms of the Spell contracts) is outdated and would allow for significant slippage.\n\nA MEV bot detects the pending transaction. Since the outdated maximum slippage value now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/CurveSpell.sol#L162-L175\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol use block.timstamp for swapping deadline for Uniswap V2 and swap with Unsiwap Router V3 instead of the pool directly!\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/CurveSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWCurveGauge.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\n/**\n * @title CurveSpell\n * @author BlueberryProtocol\n * @notice CurveSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Curve pools\n */\ncontract CurveSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev address of Wrapped Curve Gauge\n    IWCurveGauge public wCurveGauge;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of CRV token\n    address public CRV;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wCurveGauge_,\n        address crvOracle_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wCurveGauge_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wCurveGauge = IWCurveGauge(wCurveGauge_);\n        CRV = address(wCurveGauge.CRV());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWCurveGauge(wCurveGauge_).setApprovalForAll(address(bank_), true);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param crvLp Address of crv lp token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(address crvLp, uint256 maxPosSize) external onlyOwner {\n        _addStrategy(crvLp, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Curve pool with 2 underlying tokens, with staking to Curve gauge\n     * @param minLPMint Desired LP token amount (slippage control)\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address lp = strategies[param.strategyId].vault;\n        if (wCurveGauge.getLpFromGaugeId(param.farmingPoolId) != lp)\n            revert Errors.INCORRECT_LP(lp);\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(lp);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on curve\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n\n        // 6. Take out collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 decodedGid, ) = wCurveGauge.decodeId(pos.collId);\n            if (param.farmingPoolId != decodedGid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wCurveGauge))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wCurveGauge.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CRV);\n        }\n\n        // 7. Deposit on Curve Gauge, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lp).balanceOf(address(this));\n        _ensureApprove(lp, address(wCurveGauge), lpAmount);\n        uint256 id = wCurveGauge.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wCurveGauge), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        IUniswapV2Router02 swapRouter,\n        address[] calldata swapPath\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wCurveGauge))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wCurveGauge.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(param.amountPosRemove);\n        wCurveGauge.burn(pos.collId, param.amountPosRemove);\n\n        {\n            // 2. Swap rewards tokens to debt token\n            uint256 rewards = _doCutRewardsFee(CRV);\n            _ensureApprove(CRV, address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath,\n                address(this),\n                type(uint256).max\n            );\n        }\n\n        {\n            (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n                crvLp\n            );\n            // 3. Calculate actual amount to remove\n            uint256 amountPosRemove = param.amountPosRemove;\n            if (amountPosRemove == type(uint256).max) {\n                amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(\n                    address(this)\n                );\n            }\n\n            // 4. Remove liquidity\n            int128 tokenIndex;\n            for (uint256 i = 0; i < tokens.length; i++) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = int128(uint128(i));\n                    break;\n                }\n            }\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CRV);\n    }\n}"
    }
  ]
}