{
  "Title": "Missing minimum and maximum deposit checks for bridge contract interactions",
  "Content": "# Missing minimum and maximum deposit checks for bridge contract interactions\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/rocket-pool/rocketpool/blob/master/contracts/contract/deposit/RocketDepositPool.sol#L94\">https://github.com/rocket-pool/rocketpool/blob/master/contracts/contract/deposit/RocketDepositPool.sol#L94</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/rocket-pool/rocketpool/blob/master/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsDeposit.sol#L18\">https://github.com/rocket-pool/rocketpool/blob/master/contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsDeposit.sol#L18</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/bridges/BridgeReth.sol#L70-L81\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/bridges/BridgeReth.sol#L70-L81</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/rocket-pool/rocketpool/blob/master/contracts/contract/deposit/RocketDepositPool.sol#L107-L117\">https://github.com/rocket-pool/rocketpool/blob/master/contracts/contract/deposit/RocketDepositPool.sol#L107-L117</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/Constants.sol#L21\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/Constants.sol#L21</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/lidofinance/lido-dao/blob/master/contracts/0.4.24/Lido.sol#L930-L936\">https://github.com/lidofinance/lido-dao/blob/master/contracts/0.4.24/Lido.sol#L930-L936</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/bridges/BridgeSteth.sol#L71-L78\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/bridges/BridgeSteth.sol#L71-L78</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/lidofinance/lido-dao/blob/master/contracts/0.4.24/Lido.sol#L405-L407\">https://github.com/lidofinance/lido-dao/blob/master/contracts/0.4.24/Lido.sol#L405-L407</a>\n\n\n## Summary\nUpdated MIN check and new MAX check required in ```BridgeRouterFacet.sol::depositEth()```, which calls ```depositEth()``` in both of the bridge contracts; ```BridgeReth.sol``` and ```BridgeSteth.sol```. The staking protocols these bridge contracts interact with both implement deposit limits which should be aligned to.\n\n## Assumptions\nAssumed that the DittoEth has merged functions from two of ```Lido.fi``` protocol's contracts into one mock contract given that the ```submit()``` function used in ```BridgeSteth.sol::depositEth()``` comes from ```Lido.sol``` contract and other functions come from ```StETH.sol```. In recommendations I continue to use this assumption for simplicity. \n\n## Vulnerability Details\n### BridgeRouterFacet.sol\nThere is a minimum deposit check in ```BridgeRouterFacet.sol::depositEth()``` which is ```0.0001 ether``` which is not high enough.\n\n### BridgeReth.sol\n```rocketDepositPool.sol::deposit()``` implements a minimum value of ```0.01 ether``` defined at ```RocketDAOProtocolSettingsDeposit.sol#L18``` and used at ```RocketDepositPool.sol#L94``` (see links).\nIt further implements a dynamic maximum allowed value, depending on current conditions, and is checked in the code block at ```RocketDAOProtocolSettingsDeposit.sol#L107-L117``` (linked). The checks in the code block are activated if ```msg.value``` is greater than ```160 ether```.\n\n### BridgeSteth.sol\nNo minimum allowed value.\nThe maximum allowed value in ```Lido.sol::submit()``` is dynamic, depending on considerations such as network conditions and protocol needs. The staking limit is checked in the code block at ```Lido.sol#L930-L936``` (linked). The checks in the code block will be activated if ```isStakingLimitSet``` is ```true```.\n\n## Impact\n### BridgeReth.sol\nAny deposit below allowed minimum ```0.01 ether``` or above current allowed maximum will cause the transaction to revert. This means the user's transaction will fail and user will lose the gas costs associated with that transaction and user will have bad user experience.\n\n### BridgeSteth.sol\nAny deposit above current allowed maximum will cause the transaction to revert. This means the user's transaction will fail and user will lose the gas costs associated with that transaction and user will have bad user experience.\n\n## Tools Used\nManual Review\n\n## Recommendations\n### ```Constants.sol```\nIncrease minimum deposit stored at ```Constants.MIN_DEPOSIT``` to ```0.01 ether``` to match ```BridgeReth.sol```\n\n### ```BridgeReth.sol```\nUpdate ```BridgeReth.sol::depositEth()``` to include:\n - A maximum check, using ```rocketDepositPool::getMaximumDepositAmount()```, that ```msg.value``` does not breach current allowed maximum.\n\n```\nfunction depositEth() external payable onlyDiamond returns (uint256) {\n    IRocketDepositPool rocketDepositPool = IRocketDepositPool(\n        rocketStorage.getAddress(ROCKET_DEPOSIT_POOL_TYPEHASH)\n    );\n    \n    // Maximum deposit check\n>>> uint256 maxDepositAmount = rocketDepositPool.getMaximumDepositAmount();\n>>> require(msg.value <= maxDepositAmount, \"Deposit amount exceeds maximum threshold\");\n\n    IRocketTokenRETH rocketETHToken = _getRethContract();\n\n    uint256 originalBalance = rocketETHToken.balanceOf(address(this));\n    rocketDepositPool.deposit{value: msg.value}();\n    uint256 netBalance = rocketETHToken.balanceOf(address(this)) -\n        originalBalance;\n    if (netBalance == 0) revert NetBalanceZero();\n\n    return rocketETHToken.getEthValue(netBalance);\n}\n```\n\n### ```BridgeSteth.sol```\nUpdate ```BridgeSteth.sol::depositEth()``` to include:\n - A maximum check, using ```Lido.sol::getCurrentStakeLimit()``` (linked), that ```msg.value``` does not breach current \n   allowed maximum.\n\n```\nfunction depositEth() external payable onlyDiamond returns (uint256) {\n    // Check the current stake limit\n>>> uint256 currentStakeLimit = steth.getCurrentStakeLimit();\n>>> require(msg.value <= currentStakeLimit, \"Deposit exceeds current stake limit\");\n\n    uint256 originalBalance = steth.balanceOf(address(this));\n    steth.submit{value: msg.value}(address(0));\n    uint256 netBalance = steth.balanceOf(address(this)) - originalBalance;\n    if (netBalance == 0) revert NetBalanceZero();\n    return netBalance;\n}\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/contract/deposit/RocketDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/RocketVaultInterface.sol\";\nimport \"../../interface/RocketVaultWithdrawerInterface.sol\";\nimport \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolQueueInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\nimport \"../../interface/token/RocketTokenRETHInterface.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\n\n/// @notice Accepts user deposits and mints rETH; handles assignment of deposited ETH to minipools\ncontract RocketDepositPool is RocketBase, RocketDepositPoolInterface, RocketVaultWithdrawerInterface {\n\n    // Libs\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using SafeCast for uint256;\n\n    // Immutables\n    RocketVaultInterface immutable rocketVault;\n    RocketTokenRETHInterface immutable rocketTokenRETH;\n\n    // Events\n    event DepositReceived(address indexed from, uint256 amount, uint256 time);\n    event DepositRecycled(address indexed from, uint256 amount, uint256 time);\n    event DepositAssigned(address indexed minipool, uint256 amount, uint256 time);\n    event ExcessWithdrawn(address indexed to, uint256 amount, uint256 time);\n\n    // Structs\n    struct MinipoolAssignment {\n        address minipoolAddress;\n        uint256 etherAssigned;\n    }\n\n    // Modifiers\n    modifier onlyThisLatestContract() {\n        // Compiler can optimise out this keccak at compile time\n        require(address(this) == getAddress(keccak256(\"contract.addressrocketDepositPool\")), \"Invalid or outdated contract\");\n        _;\n    }\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 3;\n\n        // Pre-retrieve non-upgradable contract addresses to save gas\n        rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketTokenRETH = RocketTokenRETHInterface(getContractAddress(\"rocketTokenRETH\"));\n    }\n\n    /// @notice Returns the current deposit pool balance\n    function getBalance() override public view returns (uint256) {\n        return rocketVault.balanceOf(\"rocketDepositPool\");\n    }\n\n    /// @notice Returns the amount of ETH contributed to the deposit pool by node operators waiting in the queue\n    function getNodeBalance() override public view returns (uint256) {\n        return getUint(\"deposit.pool.node.balance\");\n    }\n\n    /// @notice Returns the user owned portion of the deposit pool (negative indicates more ETH has been \"lent\" to the\n    ///         deposit pool by node operators in the queue than is available from user deposits)\n    function getUserBalance() override public view returns (int256) {\n        return getBalance().toInt256().sub(getNodeBalance().toInt256());\n    }\n\n    /// @notice Excess deposit pool balance (in excess of minipool queue capacity)\n    function getExcessBalance() override public view returns (uint256) {\n        // Get minipool queue capacity\n        RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n        uint256 minipoolCapacity = rocketMinipoolQueue.getEffectiveCapacity();\n        uint256 balance = getBalance();\n        // Calculate and return\n        if (minipoolCapacity >= balance) { return 0; }\n        else { return balance.sub(minipoolCapacity); }\n    }\n\n    /// @dev Callback required to receive ETH withdrawal from the vault\n    function receiveVaultWithdrawalETH() override external payable onlyThisLatestContract onlyLatestContract(\"rocketVault\", msg.sender) {}\n\n    /// @notice Deposits ETH into Rocket Pool and mints the corresponding amount of rETH to the caller\n    function deposit() override external payable onlyThisLatestContract {\n        // Check deposit settings\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        require(rocketDAOProtocolSettingsDeposit.getDepositEnabled(), \"Deposits into Rocket Pool are currently disabled\");\n        require(msg.value >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit(), \"The deposited amount is less than the minimum deposit size\");\n        /*\n            Check if deposit exceeds limit based on current deposit size and minipool queue capacity.\n\n            The deposit pool can, at most, accept a deposit that, after assignments, matches ETH to every minipool in\n            the queue and leaves the deposit pool with maximumDepositPoolSize ETH.\n\n            capacityNeeded = depositPoolBalance + msg.value\n            maxCapacity = maximumDepositPoolSize + queueEffectiveCapacity\n            assert(capacityNeeded <= maxCapacity)\n        */\n        uint256 capacityNeeded = getBalance().add(msg.value);\n        uint256 maxDepositPoolSize = rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize();\n        if (capacityNeeded > maxDepositPoolSize) {\n            // Doing a conditional require() instead of a single one optimises for the common\n            // case where capacityNeeded fits in the deposit pool without looking at the queue\n            if (rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n                RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n                require(capacityNeeded <= maxDepositPoolSize.add(rocketMinipoolQueue.getEffectiveCapacity()),\n                    \"The deposit pool size after depositing (and matching with minipools) exceeds the maximum size\");\n            } else {\n                revert(\"The deposit pool size after depositing exceeds the maximum size\");\n            }\n        }\n        // Calculate deposit fee\n        uint256 depositFee = msg.value.mul(rocketDAOProtocolSettingsDeposit.getDepositFee()).div(calcBase);\n        uint256 depositNet = msg.value.sub(depositFee);\n        // Mint rETH to user account\n        rocketTokenRETH.mint(depositNet, msg.sender);\n        // Emit deposit received event\n        emit DepositReceived(msg.sender, msg.value, block.timestamp);\n        // Process deposit\n        processDeposit(rocketDAOProtocolSettingsDeposit);\n    }\n\n    /// @notice Returns the maximum amount that can be accepted into the deposit pool at this time in wei\n    function getMaximumDepositAmount() override external view returns (uint256) {\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // If deposits are enabled max deposit is 0\n        if (!rocketDAOProtocolSettingsDeposit.getDepositEnabled()) {\n            return 0;\n        }\n        uint256 depositPoolBalance = getBalance();\n        uint256 maxCapacity = rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize();\n        // When assignments are enabled, we can accept the max amount plus whatever space is available in the minipool queue\n        if (rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n            RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n            maxCapacity = maxCapacity.add(rocketMinipoolQueue.getEffectiveCapacity());\n        }\n        // Check we aren't already over\n        if (depositPoolBalance >= maxCapacity) {\n            return 0;\n        }\n        return maxCapacity.sub(depositPoolBalance);\n    }\n\n    /// @dev Accepts ETH deposit from the node deposit contract (does not mint rETH)\n    /// @param _totalAmount The total node deposit amount including any credit balance used\n    function nodeDeposit(uint256 _totalAmount) override external payable onlyThisLatestContract onlyLatestContract(\"rocketNodeDeposit\", msg.sender) {\n        // Deposit ETH into the vault\n        if (msg.value > 0) {\n            rocketVault.depositEther{value: msg.value}();\n        }\n        // Increase recorded node balance\n        addUint(\"deposit.pool.node.balance\", _totalAmount);\n    }\n\n    /// @dev Withdraws ETH from the deposit pool to RocketNodeDeposit contract to be used for a new minipool\n    /// @param _amount The amount of ETH to withdraw\n    function nodeCreditWithdrawal(uint256 _amount) override external onlyThisLatestContract onlyLatestContract(\"rocketNodeDeposit\", msg.sender) {\n        // Withdraw ETH from the vault\n        rocketVault.withdrawEther(_amount);\n        // Send it to msg.sender (function modifier verifies msg.sender is RocketNodeDeposit)\n        (bool success, ) = address(msg.sender).call{value: _amount}(\"\");\n        require(success, \"Failed to send ETH\");\n    }\n\n    /// @dev Recycle a deposit from a dissolved minipool\n    function recycleDissolvedDeposit() override external payable onlyThisLatestContract onlyRegisteredMinipool(msg.sender) {\n        // Load contracts\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // Recycle ETH\n        emit DepositRecycled(msg.sender, msg.value, block.timestamp);\n        processDeposit(rocketDAOProtocolSettingsDeposit);\n    }\n\n    /// @dev Recycle excess ETH from the rETH token contract\n    function recycleExcessCollateral() override external payable onlyThisLatestContract onlyLatestContract(\"rocketTokenRETH\", msg.sender) {\n        // Load contracts\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // Recycle ETH\n        emit DepositRecycled(msg.sender, msg.value, block.timestamp);\n        processDeposit(rocketDAOProtocolSettingsDeposit);\n    }\n\n    /// @dev Recycle a liquidated RPL stake from a slashed minipool\n    function recycleLiquidatedStake() override external payable onlyThisLatestContract onlyLatestContract(\"rocketAuctionManager\", msg.sender) {\n        // Load contracts\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // Recycle ETH\n        emit DepositRecycled(msg.sender, msg.value, block.timestamp);\n        processDeposit(rocketDAOProtocolSettingsDeposit);\n    }\n\n    /// @dev Process a deposit\n    function processDeposit(RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) private {\n        // Transfer ETH to vault\n        rocketVault.depositEther{value: msg.value}();\n        // Assign deposits if enabled\n        _assignDeposits(_rocketDAOProtocolSettingsDeposit);\n    }\n\n    /// @notice Assign deposits to available minipools. Reverts if assigning deposits is disabled.\n    function assignDeposits() override external onlyThisLatestContract {\n        // Load contracts\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // Revert if assigning is disabled\n        require(_assignDeposits(rocketDAOProtocolSettingsDeposit), \"Deposit assignments are currently disabled\");\n    }\n\n    /// @dev Assign deposits to available minipools. Does nothing if assigning deposits is disabled.\n    function maybeAssignDeposits() override external onlyThisLatestContract returns (bool) {\n        // Load contracts\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        // Revert if assigning is disabled\n        return _assignDeposits(rocketDAOProtocolSettingsDeposit);\n    }\n\n    /// @dev Assigns deposits to available minipools, returns false if assignment is currently disabled\n    function _assignDeposits(RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) private returns (bool) {\n        // Check if assigning deposits is enabled\n        if (!_rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n            return false;\n        }\n        // Load contracts\n        RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n        // Decide which queue processing implementation to use based on queue contents\n        if (rocketMinipoolQueue.getContainsLegacy()) {\n            return _assignDepositsLegacy(rocketMinipoolQueue, _rocketDAOProtocolSettingsDeposit);\n        } else {\n            return _assignDepositsNew(rocketMinipoolQueue, _rocketDAOProtocolSettingsDeposit);\n        }\n    }\n\n    /// @dev Assigns deposits using the new minipool queue\n    function _assignDepositsNew(RocketMinipoolQueueInterface _rocketMinipoolQueue, RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) private returns (bool) {\n        // Load contracts\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        // Calculate the number of minipools to assign\n        uint256 maxAssignments = _rocketDAOProtocolSettingsDeposit.getMaximumDepositAssignments();\n        uint256 variableDepositAmount = rocketDAOProtocolSettingsMinipool.getVariableDepositAmount();\n        uint256 scalingCount = msg.value.div(variableDepositAmount);\n        uint256 totalEthCount = getBalance().div(variableDepositAmount);\n        uint256 assignments = _rocketDAOProtocolSettingsDeposit.getMaximumDepositSocialisedAssignments().add(scalingCount);\n        if (assignments > totalEthCount) {\n            assignments = totalEthCount;\n        }\n        if (assignments > maxAssignments) {\n            assignments = maxAssignments;\n        }\n        address[] memory minipools = _rocketMinipoolQueue.dequeueMinipools(assignments);\n        if (minipools.length > 0){\n            // Withdraw ETH from vault\n            uint256 totalEther = minipools.length.mul(variableDepositAmount);\n            rocketVault.withdrawEther(totalEther);\n            uint256 nodeBalanceUsed = 0;\n            // Loop over minipools and deposit the amount required to reach launch balance\n            for (uint256 i = 0; i < minipools.length; i++) {\n                RocketMinipoolInterface minipool = RocketMinipoolInterface(minipools[i]);\n                // Assign deposit to minipool\n                minipool.deposit{value: variableDepositAmount}();\n                nodeBalanceUsed = nodeBalanceUsed.add(minipool.getNodeTopUpValue());\n                // Emit deposit assigned event\n                emit DepositAssigned(minipools[i], variableDepositAmount, block.timestamp);\n            }\n            // Decrease node balance\n            subUint(\"deposit.pool.node.balance\", nodeBalanceUsed);\n        }\n        return true;\n    }\n\n    /// @dev Assigns deposits using the legacy minipool queue\n    function _assignDepositsLegacy(RocketMinipoolQueueInterface _rocketMinipoolQueue, RocketDAOProtocolSettingsDepositInterface _rocketDAOProtocolSettingsDeposit) private returns (bool) {\n        // Load contracts\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        // Setup initial variable values\n        uint256 balance = getBalance();\n        uint256 totalEther = 0;\n        // Calculate minipool assignments\n        uint256 maxAssignments = _rocketDAOProtocolSettingsDeposit.getMaximumDepositAssignments();\n        MinipoolAssignment[] memory assignments = new MinipoolAssignment[](maxAssignments);\n        MinipoolDeposit depositType = MinipoolDeposit.None;\n        uint256 count = 0;\n        uint256 minipoolCapacity = 0;\n        for (uint256 i = 0; i < maxAssignments; ++i) {\n            // Optimised for multiple of the same deposit type\n            if (count == 0) {\n                (depositType, count) = _rocketMinipoolQueue.getNextDepositLegacy();\n                if (depositType == MinipoolDeposit.None) { break; }\n                minipoolCapacity = rocketDAOProtocolSettingsMinipool.getDepositUserAmount(depositType);\n            }\n            count--;\n            if (minipoolCapacity == 0 || balance.sub(totalEther) < minipoolCapacity) { break; }\n            // Dequeue the minipool\n            address minipoolAddress = _rocketMinipoolQueue.dequeueMinipoolByDepositLegacy(depositType);\n            // Update running total\n            totalEther = totalEther.add(minipoolCapacity);\n            // Add assignment\n            assignments[i].etherAssigned = minipoolCapacity;\n            assignments[i].minipoolAddress = minipoolAddress;\n        }\n        if (totalEther > 0) {\n            // Withdraw ETH from vault\n            rocketVault.withdrawEther(totalEther);\n            // Perform assignments\n            for (uint256 i = 0; i < maxAssignments; ++i) {\n                if (assignments[i].etherAssigned == 0) { break; }\n                RocketMinipoolInterface minipool = RocketMinipoolInterface(assignments[i].minipoolAddress);\n                // Assign deposit to minipool\n                minipool.userDeposit{value: assignments[i].etherAssigned}();\n                // Emit deposit assigned event\n                emit DepositAssigned(assignments[i].minipoolAddress, assignments[i].etherAssigned, block.timestamp);\n            }\n        }\n        return true;\n    }\n\n    /// @dev Withdraw excess deposit pool balance for rETH collateral\n    /// @param _amount The amount of excess ETH to withdraw\n    function withdrawExcessBalance(uint256 _amount) override external onlyThisLatestContract onlyLatestContract(\"rocketTokenRETH\", msg.sender) {\n        // Check amount\n        require(_amount <= getExcessBalance(), \"Insufficient excess balance for withdrawal\");\n        // Withdraw ETH from vault\n        rocketVault.withdrawEther(_amount);\n        // Transfer to rETH contract\n        rocketTokenRETH.depositExcess{value: _amount}();\n        // Emit excess withdrawn event\n        emit ExcessWithdrawn(msg.sender, _amount, block.timestamp);\n    }\n\n}"
    },
    {
      "filename": "contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsDeposit.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\n\nimport \"./RocketDAOProtocolSettings.sol\";\nimport \"../../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsDepositInterface.sol\";\n \n/// @notice Network deposit settings\ncontract RocketDAOProtocolSettingsDeposit is RocketDAOProtocolSettings, RocketDAOProtocolSettingsDepositInterface {\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketDAOProtocolSettings(_rocketStorageAddress, \"deposit\") {\n        // Set version\n        version = 3;\n        // Initialize settings on deployment\n        if(!getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")))) {\n            // Apply settings\n            setSettingBool(\"deposit.enabled\", false);\n            setSettingBool(\"deposit.assign.enabled\", true);\n            setSettingUint(\"deposit.minimum\", 0.01 ether);\n            setSettingUint(\"deposit.pool.maximum\", 160 ether);\n            setSettingUint(\"deposit.assign.maximum\", 90);\n            setSettingUint(\"deposit.assign.socialised.maximum\", 2);\n            setSettingUint(\"deposit.fee\", 0.0005 ether);    // Set to approx. 1 day of rewards at 18.25% APR\n            // Settings initialised\n            setBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")), true);\n        }\n    }\n\n    /// @notice Returns true if deposits are currently enabled\n    function getDepositEnabled() override external view returns (bool) {\n        return getSettingBool(\"deposit.enabled\");\n    }\n\n    /// @notice Returns true if deposit assignments are currently enabled\n    function getAssignDepositsEnabled() override external view returns (bool) {\n        return getSettingBool(\"deposit.assign.enabled\");\n    }\n\n    /// @notice Returns the minimum deposit size\n    function getMinimumDeposit() override external view returns (uint256) {\n        return getSettingUint(\"deposit.minimum\");\n    }\n\n    /// @notice Returns the maximum size of the deposit pool\n    function getMaximumDepositPoolSize() override external view returns (uint256) {\n        return getSettingUint(\"deposit.pool.maximum\");\n    }\n\n    /// @notice Returns the maximum number of deposit assignments to perform at once\n    function getMaximumDepositAssignments() override external view returns (uint256) {\n        return getSettingUint(\"deposit.assign.maximum\");\n    }\n\n    /// @notice Returns the maximum number of socialised (ie, not related to deposit size) assignments to perform\n    function getMaximumDepositSocialisedAssignments() override external view returns (uint256) {\n        return getSettingUint(\"deposit.assign.socialised.maximum\");\n    }\n\n    /// @notice Returns the current fee paid on user deposits\n    function getDepositFee() override external view returns (uint256) {\n        return getSettingUint(\"deposit.fee\");\n    }\n\n}"
    },
    {
      "filename": "contracts/bridges/BridgeReth.sol",
      "content": "// https://docs.rocketpool.net/developers/usage/contracts/contracts.html#implementation\n// https://github.com/rocket-pool/rocketpool/blob/master/contracts/contract/token/RocketTokenRETH.sol\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IRocketStorage} from \"interfaces/IRocketStorage.sol\";\nimport {IRocketTokenRETH} from \"interfaces/IRocketTokenRETH.sol\";\nimport {IRocketDepositPool} from \"interfaces/IRocketDepositPool.sol\";\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeReth is IBridge {\n    bytes32 private immutable RETH_TYPEHASH;\n    bytes32 private immutable ROCKET_DEPOSIT_POOL_TYPEHASH;\n    IRocketStorage private immutable rocketStorage;\n    address private immutable diamond;\n\n    constructor(IRocketStorage rocketStorageAddress, address diamondAddr) {\n        rocketStorage = IRocketStorage(rocketStorageAddress);\n        diamond = diamondAddr;\n        // @dev (gas) use immutable instead of constant\n        // See https://github.com/ethereum/solidity/issues/9232#issuecomment-646131646\n        RETH_TYPEHASH = keccak256(abi.encodePacked(\"contract.address\", \"rocketTokenRETH\"));\n        ROCKET_DEPOSIT_POOL_TYPEHASH =\n            keccak256(abi.encodePacked(\"contract.address\", \"rocketDepositPool\"));\n    }\n\n    modifier onlyDiamond() {\n        if (msg.sender != diamond) {\n            revert NotDiamond();\n        }\n        _;\n    }\n\n    receive() external payable {}\n\n    function _getRethContract() private view returns (IRocketTokenRETH) {\n        return IRocketTokenRETH(rocketStorage.getAddress(RETH_TYPEHASH));\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBaseCollateral() external view returns (address) {\n        return rocketStorage.getAddress(RETH_TYPEHASH);\n    }\n\n    //@dev does not need read only re-entrancy\n    function getZethValue() external view returns (uint256) {\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n        return rocketETHToken.getEthValue(rocketETHToken.balanceOf(address(this)));\n    }\n\n    // @dev ERC20 success https://ethereum.stackexchange.com/questions/148216/when-would-an-erc20-return-false\n    // Bring rETH to system and credit zETH to user\n    function deposit(address from, uint256 amount)\n        external\n        onlyDiamond\n        returns (uint256)\n    {\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n        // Transfer rETH to this bridge contract\n        // @dev RETH uses OZ ERC-20, don't need to check success bool\n        rocketETHToken.transferFrom(from, address(this), amount);\n        // Calculate rETH equivalent value in ETH\n        return rocketETHToken.getEthValue(amount);\n    }\n\n    // Deposit ETH and mint rETH (to system) and credit zETH to user\n    function depositEth() external payable onlyDiamond returns (uint256) {\n        IRocketDepositPool rocketDepositPool =\n            IRocketDepositPool(rocketStorage.getAddress(ROCKET_DEPOSIT_POOL_TYPEHASH));\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n\n        uint256 originalBalance = rocketETHToken.balanceOf(address(this));\n        rocketDepositPool.deposit{value: msg.value}();\n        uint256 netBalance = rocketETHToken.balanceOf(address(this)) - originalBalance;\n        if (netBalance == 0) revert NetBalanceZero();\n\n        return rocketETHToken.getEthValue(netBalance);\n    }\n\n    // Exchange system rETH to fulfill zETH obligation to user\n    function withdraw(address to, uint256 amount)\n        external\n        onlyDiamond\n        returns (uint256)\n    {\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n        // Calculate zETH equivalent value in rETH\n        uint256 rethValue = rocketETHToken.getRethValue(amount);\n        // Transfer rETH from this bridge contract\n        // @dev RETH uses OZ ERC-20, don't need to check success bool\n        rocketETHToken.transfer(to, rethValue);\n        return rethValue;\n    }\n\n    function unstake(address to, uint256 amount) external onlyDiamond {\n        IRocketTokenRETH rocketETHToken = _getRethContract();\n        uint256 rethValue = rocketETHToken.getRethValue(amount);\n        uint256 originalBalance = address(this).balance;\n        rocketETHToken.burn(rethValue);\n        uint256 netBalance = address(this).balance - originalBalance;\n        if (netBalance == 0) revert NetBalanceZero();\n        (bool sent,) = to.call{value: netBalance}(\"\");\n        assert(sent);\n    }\n}"
    },
    {
      "filename": "contracts/contract/deposit/RocketDepositPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/RocketVaultInterface.sol\";\nimport \"../../interface/RocketVaultWithdrawerInterface.sol\";\nimport \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolQueueInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\nimport \"../../interface/token/RocketTokenRETHInterface.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\n\n/// @notice Accepts user deposits and mints rETH; handles assignment of deposited ETH to minipools\ncontract RocketDepositPool is RocketBase, RocketDepositPoolInterface, RocketVaultWithdrawerInterface {\n\n    // Libs\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n    using SafeCast for uint256;\n\n    // Immutables\n    RocketVaultInterface immutable rocketVault;\n    RocketTokenRETHInterface immutable rocketTokenRETH;\n\n    // Events\n    event DepositReceived(address indexed from, uint256 amount, uint256 time);\n    event DepositRecycled(address indexed from, uint256 amount, uint256 time);\n    event DepositAssigned(address indexed minipool, uint256 amount, uint256 time);\n    event ExcessWithdrawn(address indexed to, uint256 amount, uint256 time);\n\n    // Structs\n    struct MinipoolAssignment {\n        address minipoolAddress;\n        uint256 etherAssigned;\n    }\n\n    // Modifiers\n    modifier onlyThisLatestContract() {\n        // Compiler can optimise out this keccak at compile time\n        require(address(this) == getAddress(keccak256(\"contract.addressrocketDepositPool\")), \"Invalid or outdated contract\");\n        _;\n    }\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 3;\n\n        // Pre-retrieve non-upgradable contract addresses to save gas\n        rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketTokenRETH = RocketTokenRETHInterface(getContractAddress(\"rocketTokenRETH\"));\n    }\n\n    /// @notice Returns the current deposit pool balance\n    function getBalance() override public view returns (uint256) {\n        return rocketVault.balanceOf(\"rocketDepositPool\");\n    }\n\n    /// @notice Returns the amount of ETH contributed to the deposit pool by node operators waiting in the queue\n    function getNodeBalance() override public view returns (uint256) {\n        return getUint(\"deposit.pool.node.balance\");\n    }\n\n    /// @notice Returns the user owned portion of the deposit pool (negative indicates more ETH has been \"lent\" to the\n    ///         deposit pool by node operators in the queue than is available from user deposits)\n    function getUserBalance() override public view returns (int256) {\n        return getBalance().toInt256().sub(getNodeBalance().toInt256());\n    }\n\n    /// @notice Excess deposit pool balance (in excess of minipool queue capacity)\n    function getExcessBalance() override public view returns (uint256) {\n        // Get minipool queue capacity\n        RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n        uint256 minipoolCapacity = rocketMinipoolQueue.getEffectiveCapacity();\n        uint256 balance = getBalance();\n        // Calculate and return\n        if (minipoolCapacity >= balance) { return 0; }\n        else { return balance.sub(minipoolCapacity); }\n    }\n\n    /// @dev Callback required to receive ETH withdrawal from the vault\n    function receiveVaultWithdrawalETH() override external payable onlyThisLatestContract onlyLatestContract(\"rocketVault\", msg.sender) {}\n\n    /// @notice Deposits ETH into Rocket Pool and mints the corresponding amount of rETH to the caller\n    function deposit() override external payable onlyThisLatestContract {\n        // Check deposit settings\n        RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(getContractAddress(\"rocketDAOProtocolSettingsDeposit\"));\n        require(rocketDAOProtocolSettingsDeposit.getDepositEnabled(), \"Deposits into Rocket Pool are currently disabled\");\n        require(msg.value >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit(), \"The deposited amount is less than the minimum deposit size\");\n        /*\n            Check if deposit exceeds limit based on current deposit size and minipool queue capacity.\n\n            The deposit pool can, at most, accept a deposit that, after assignments, matches ETH to every minipool in\n            the queue and leaves the deposit pool with maximumDepositPoolSize ETH.\n\n            capacityNeeded = depositPoolBalance + msg.value\n            maxCapacity = maximumDepositPoolSize + queueEffectiveCapacity\n            assert(capacityNeeded <= maxCapacity)\n        */\n        uint256 capacityNeeded = getBalance().add(msg.value);\n        uint256 maxDepositPoolSize = rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize();\n        if (capacityNeeded > maxDepositPoolSize) {\n            // Doing a conditional require() instead of a single one optimises for the common\n            // case where capacityNeeded fits in the deposit pool without looking at the queue\n            if (rocketDAOProtocolSettingsDeposit.getAssignDepositsEnabled()) {\n                RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n                require(capacityNeeded <= maxDepositPoolSize.add(rocketMinipoolQueue.getEffectiveCapacity()),\n                    \"The deposit pool size after depositing (and matching with minipools) exceeds the maximum size\");\n            } else {\n                revert(\"The deposit pool size after depositing exceeds the maximum size\");\n            }\n        }\n        // Calculate deposit fee\n        uint256 depositFee = msg.value.mul(rocketDAOProtocolSettingsDeposit.getDepositFee()).div(calcBase);\n        uint256 depositNet = msg.value.sub(depositFee);\n        // Mint rETH to user account\n        rocketTokenRETH."
    }
  ]
}