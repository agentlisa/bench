{
  "Title": "[M-22] Maia Governance token balance dilution in `vMaia` vault is breaking the conversion rate mechanism",
  "Content": "\nOnce a user deposits `Maia` ERC-20 tokens into the `vMaia` ERC-4626 vault, they are eligible to claim 3 kinds of utility tokens: `bHermes Weight` and `Governance` and `Maia Governance `(`pbHermes`, partner governance). On each deposit, new Maia Governance tokens (`pbHermes`) are [minted to the vault in proportion to the deposited amount](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L235-L246), but those tokens are [never burned on withdrawal](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L248-L256). This naturally dilutes the vault's `pbHermes` token balance during the course of users depositing & withdrawing `Maia` tokens. Furthermore, a malicious user can dramatically accelerate this dilution by repeatedly depositing & withdrawing within a single transaction.\n\n*Note that the vault's `bHermes Weight` and `Governance` token balances are not diluted during this process.*\n\nHowever, the [ERC4626PartnerManager.increaseConversionRate(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L215-L229) method (which `ERC4626PartnerManager` is the base of the `vMaia` contract) relies on the vault's `pbHermes` token balance and therefore, imposes a lower limit on an increased `pbHermes<>bHermes` conversion rate to avoid underflow, see [L226](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L226): `min. rate = vault balance of pbHermes / Maia tokens in the vault`. Meanwhile, the upper limit for a new conversion rate is given by [L219](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L219): `max. rate = vault balance of bHermes / Maia tokens in vault`.\n\nAs a consequence, the `vMaia` vault owner's ability to increase the conversion rate is successively constrained by user deposits & withdrawals, up until the point where the dilution of `pbHermes` reaches the `vault balance of pbHermes > vault balance of bHermes`, which leads to complete DoS of the [ERC4626PartnerManager.increaseConversionRate(...)](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/maia/tokens/ERC4626PartnerManager.sol#L215-L229) method.\n\n### Proof of Concept\n\nThe following PoC verifies the above claims about `pbHermes` dilution and `increaseConversionRate(...)` DoS. Just apply the *diff* below and run the new in-line documented test case with `forge test -vv --match-test testDepositMaiaDilutionUntilConversionRateFailure`:\n\n```diff\ndiff --git a/test/maia/vMaiaTest.t.sol b/test/maia/vMaiaTest.t.sol\nindex 6efabc5..2af982e 100644\n--- a/test/maia/vMaiaTest.t.sol\n+++ b/test/maia/vMaiaTest.t.sol\n@@ -7,6 +7,7 @@ import {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\n import {vMaia, PartnerManagerFactory, ERC20} from \"@maia/vMaia.sol\";\n import {IBaseVault} from \"@maia/interfaces/IBaseVault.sol\";\n+import {IERC4626PartnerManager} from \"@maia/interfaces/IERC4626PartnerManager.sol\";\n import {MockVault} from \"./mock/MockVault.t.sol\";\n\n import {bHermes} from \"@hermes/bHermes.sol\";\n@@ -47,7 +48,7 @@ contract vMaiaTest is DSTestPlus {\n             \"vMAIA\",\n             address(bhermes),\n             address(vault),\n-            address(0)\n+            address(this) // set owner to allow call to 'increaseConversionRate'\n         );\n     }\n\n@@ -86,6 +87,39 @@ contract vMaiaTest is DSTestPlus {\n         assertEq(vmaia.balanceOf(address(this)), amount);\n     }\n\n+    function testDepositMaiaDilutionUntilConversionRateFailure() public {\n+        testDepositMaia();\n+        uint256 amount = vmaia.balanceOf(address(this));\n+\n+        // fast-forward to withdrawal Tuesday\n+        hevm.warp(getFirstDayOfNextMonthUnix());\n+\n+        for(uint256 i = 0; i < 10; i++) {\n+            // get & print bHermes & pbHermes vault balances\n+            uint256 bHermesBal = bhermes.balanceOf(address(vmaia));\n+            uint256 pbHermesBal = vmaia.partnerGovernance().balanceOf(address(vmaia));\n+            console2.log(\"vault balance of bHermes: \", bHermesBal);\n+            console2.log(\"vault balance of pbHermes:\", pbHermesBal);\n+\n+            // dilute pbHermes by withdraw & deposit cycle\n+            vmaia.withdraw(amount, address(this), address(this));\n+            maia.approve(address(vmaia), amount);\n+            vmaia.deposit(amount, address(this));\n+\n+            // get diluted pbHermes balance and compute min. conversion rate accordingly\n+            pbHermesBal = vmaia.partnerGovernance().balanceOf(address(vmaia));\n+            uint256 minNewConversionRate = pbHermesBal / vmaia.totalSupply();\n+            // check if dilution caused constraints are so bad that we get DoS\n+            if (pbHermesBal > bHermesBal)\n+            {\n+                hevm.expectRevert(IERC4626PartnerManager.InsufficientBacking.selector);\n+            }\n+            vmaia.increaseConversionRate(minNewConversionRate);\n+        }\n+\n+\n+    }\n+\n     function testDepositMaiaAmountFail() public {\n         assertEq(vmaia.bHermesRate(), bHermesRate);\n\n```\n\nWe can clearly see the increasing dilution after each withdrawal-deposit cycle and get the expected **revert**. See the `if-condition`, after reaching critical dilution:\n\n\n    [PASS] testDepositMaiaDilutionUntilConversionRateFailure() (gas: 1759462)\n    Logs:\n      2023 2\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 200000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 400000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 800000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 1600000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 2400000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 3200000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 4000000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 4800000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 5600000000000000000000\n\n### Tools Used\n\nVS Code, Foundry\n\n### Recommended Mitigation Steps\n\nBurn the excess `pbHermes` tokens on withdrawal from `vMaia` vault:\n\n```diff\ndiff --git a/src/maia/tokens/ERC4626PartnerManager.sol b/src/maia/tokens/ERC4626PartnerManager.sol\nindex b912bab..31cfef7 100644\n--- a/src/maia/tokens/ERC4626PartnerManager.sol\n+++ b/src/maia/tokens/ERC4626PartnerManager.sol\n@@ -252,6 +252,7 @@ abstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC46\n      * @param amount amounts of vMaia to burn\n      */\n     function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) {\n+        ERC20MultiVotes(partnerGovernance).burn(address(this), amount * bHermesRate);\n         super._burn(from, amount);\n     }\n\n```\n\nWe can see that this fixes the dilution issue:\n\n    [PASS] testDepositMaiaDilutionUntilConversionRateFailure() (gas: 2150656)\n    Logs:\n      2023 2\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n      vault balance of bHermes:  1000000000000000000000\n      vault balance of pbHermes: 100000000000000000000\n\n### Assessed type\n\nERC20\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/473#issuecomment-1631705084)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/473#issuecomment-1709166255):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/473).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of assets.\n     * @param assets amount of assets to convert to shares\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Computes and returns the amount of assets from a given amount of shares.\n     * @param shares amount of shares to convert to assets\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Simulates the amount of shares that the assets deposited are worth.\n     * @param assets amount of assets to simulate the deposit.\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Calculates the amount of shares that the assets deposited are worth.\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be withdrawn from a given amount of shares.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be redeemed from a given amount of shares.\n     * @param shares amount of shares to convert to assets.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ER4626 DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxMint(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be withdrawn by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxWithdraw(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxRedeem(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function migratePartnerVault(address newPartnerVault) external onlyOwner {\n        if (factory.vaultIds(IBaseVault(newPartnerVault)) == 0) revert UnrecognizedVault();\n\n        address oldPartnerVault = partnerVault;\n        if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();\n        bHermesToken.claimOutstanding();\n\n        address(gaugeWeight).safeApprove(oldPartnerVault, 0);\n        address(gaugeBoost).safeApprove(oldPartnerVault, 0);\n        address(governance).safeApprove(oldPartnerVault, 0);\n        address(partnerGovernance).safeApprove(oldPartnerVault, 0);\n\n        address(gaugeWeight).safeApprove(newPartnerVault, type(uint256).max);\n        address(gaugeBoost).safeApprove(newPartnerVault, type(uint256).max);\n        address(governance).safeApprove(newPartnerVault, type(uint256).max);\n        address(partnerGovernance).safeApprove(newPartnerVault, type(uint256).max);\n\n        partnerVault = newPartnerVault;\n        if (newPartnerVault != address(0)) IBaseVault(newPartnerVault).applyAll();\n\n        emit MigratePartnerVault(address(this), newPartnerVault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function increaseConversionRate(uint256 newRate) external onlyOwner {\n        if (newRate < bHermesRate) revert InvalidRate();\n\n        if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {\n            revert InsufficientBacking();\n        }\n\n        bHermesRate = newRate;\n\n        partnerGovernance.mint(\n            address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))\n        );\n        bHermesToken.claimOutstanding();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new partner bhermes tokens to a specific address.\n     * @param to address to mints tokens to.\n     * @param amount amount of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) internal virtual override {\n        if (amount > maxMint(to)) revert ExceedsMaxDeposit();\n        bHermesToken.claimOutstanding();\n\n        ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n        super._mint(to, amount);\n    }\n\n    /**\n     * @notice Burns (or unstakes) the vMaia token in exchange for the underlying\n     *         Partner tokens, performing changes around bHermes tokens.\n     * @param from account to burn the partner manager from\n     * @param amount amounts of vMaia to burn\n     */\n    function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfer partner manager to a specific address.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(msg.sender, amount)\n        returns (bool)\n    {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer tokens from a given address.\n     * @param from address to transfer the tokens from.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available boost allows for call.\n    modifier checkBoost(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedBoost[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    modifier checkTransfer(address from, uint256 amount) virtual {\n        uint256 userBalance = balanceOf[from] * bHermesRate;\n\n        if (\n            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n                || userBalance - userClaimedGovernance[from] < amount\n                || userBalance - userClaimedPartnerGovernance[from] < amount\n        ) revert InsufficientUnderlying();\n\n        _;\n    }\n}"
    },
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of assets.\n     * @param assets amount of assets to convert to shares\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Computes and returns the amount of assets from a given amount of shares.\n     * @param shares amount of shares to convert to assets\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Simulates the amount of shares that the assets deposited are worth.\n     * @param assets amount of assets to simulate the deposit.\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Calculates the amount of shares that the assets deposited are worth.\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be withdrawn from a given amount of shares.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be redeemed from a given amount of shares.\n     * @param shares amount of shares to convert to assets.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ER4626 DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxMint(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be withdrawn by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxWithdraw(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /// @notice Returns the maximum amount of assets that can be redeemed by a user.\n    /// @dev Assumes that the user has already forfeited all utility tokens.\n    function maxRedeem(address user) public view virtual override returns (uint256) {\n        return balanceOf[user];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function migratePartnerVault(address newPartnerVault) external onlyOwner {\n        if (factory.vaultIds(IBaseVault(newPartnerVault)) == 0) revert UnrecognizedVault();\n\n        address oldPartnerVault = partnerVault;\n        if (oldPartnerVault != address(0)) IBaseVault(oldPartnerVault).clearAll();\n        bHermesToken.claimOutstanding();\n\n        address(gaugeWeight).safeApprove(oldPartnerVault, 0);\n        address(gaugeBoost).safeApprove(oldPartnerVault, 0);\n        address(governance).safeApprove(oldPartnerVault, 0);\n        address(partnerGovernance).safeApprove(oldPartnerVault, 0);\n\n        address(gaugeWeight).safeApprove(newPartnerVault, type(uint256).max);\n        address(gaugeBoost).safeApprove(newPartnerVault, type(uint256).max);\n        address(governance).safeApprove(newPartnerVault, type(uint256).max);\n        address(partnerGovernance).safeApprove(newPartnerVault, type(uint256).max);\n\n        partnerVault = newPartnerVault;\n        if (newPartnerVault != address(0)) IBaseVault(newPartnerVault).applyAll();\n\n        emit MigratePartnerVault(address(this), newPartnerVault);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function increaseConversionRate(uint256 newRate) external onlyOwner {\n        if (newRate < bHermesRate) revert InvalidRate();\n\n        if (newRate > (address(bHermesToken).balanceOf(address(this)) / totalSupply)) {\n            revert InsufficientBacking();\n        }\n\n        bHermesRate = newRate;\n\n        partnerGovernance.mint(\n            address(this), totalSupply * newRate - address(partnerGovernance).balanceOf(address(this))\n        );\n        bHermesToken.claimOutstanding();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Mints new partner bhermes tokens to a specific address.\n     * @param to address to mints tokens to.\n     * @param amount amount of tokens to mint.\n     */\n    function _mint(address to, uint256 amount) internal virtual override {\n        if (amount > maxMint(to)) revert ExceedsMaxDeposit();\n        bHermesToken.claimOutstanding();\n\n        ERC20MultiVotes(partnerGovernance).mint(address(this), amount * bHermesRate);\n        super._mint(to, amount);\n    }\n\n    /**\n     * @notice Burns (or unstakes) the vMaia token in exchange for the underlying\n     *         Partner tokens, performing changes around bHermes tokens.\n     * @param from account to burn the partner manager from\n     * @param amount amounts of vMaia to burn\n     */\n    function _burn(address from, uint256 amount) internal virtual override checkTransfer(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfer partner manager to a specific address.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(msg.sender, amount)\n        returns (bool)\n    {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfer tokens from a given address.\n     * @param from address to transfer the tokens from.\n     * @param to address to transfer the tokens to.\n     * @param amount amounts of tokens to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        virtual\n        override\n        checkTransfer(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks available weight allows for call.\n    modifier checkWeight(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedWeight[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available boost allows for call.\n    modifier checkBoost(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedBoost[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available governance allows for call.\n    modifier checkGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    /// @dev Checks available partner governance allows for call.\n    modifier checkPartnerGovernance(uint256 amount) virtual override {\n        if (balanceOf[msg.sender] * bHermesRate < amount + userClaimedPartnerGovernance[msg.sender]) {\n            revert InsufficientShares();\n        }\n        _;\n    }\n\n    modifier checkTransfer(address from, uint256 amount) virtual {\n        uint256 userBalance = balanceOf[from] * bHermesRate;\n\n        if (\n            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n                || userBalance - userClaimedGovernance[from] < amount\n                || userBalance - userClaimedPartnerGovernance[from] < amount\n        ) revert InsufficientUnderlying();\n\n        _;\n    }\n}"
    },
    {
      "filename": "src/maia/tokens/ERC4626PartnerManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {ERC4626} from \"@ERC4626/ERC4626.sol\";\n\nimport {bHermes} from \"@hermes/bHermes.sol\";\nimport {bHermesVotes as ERC20MultiVotes} from \"@hermes/tokens/bHermesVotes.sol\";\n\nimport {PartnerManagerFactory} from \"../factories/PartnerManagerFactory.sol\";\nimport {IBaseVault} from \"../interfaces/IBaseVault.sol\";\nimport {PartnerUtilityManager} from \"../PartnerUtilityManager.sol\";\n\nimport {IERC4626PartnerManager} from \"../interfaces/IERC4626PartnerManager.sol\";\n\n/// @title Yield bearing, boosting, voting, and gauge enabled Partner Token\nabstract contract ERC4626PartnerManager is PartnerUtilityManager, Ownable, ERC4626, IERC4626PartnerManager {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                         PARTNER MANAGER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    PartnerManagerFactory public immutable override factory;\n\n    /// @inheritdoc IERC4626PartnerManager\n    bHermes public immutable override bHermesToken;\n\n    /// @inheritdoc IERC4626PartnerManager\n    uint256 public override bHermesRate;\n\n    /**\n     * @notice Initializes the ERC4626PartnerManager token.\n     * @param _factory The partner manager factory.\n     * @param _bHermesRate The rate at which bHermes underlying's can be claimed.\n     * @param _partnerAsset The asset that will be used to deposit to get partner tokens.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _bhermes The address of the bHermes token.\n     * @param _partnerVault The address of the partner vault.\n     * @param _owner The owner of this contract.\n     */\n    constructor(\n        PartnerManagerFactory _factory,\n        uint256 _bHermesRate,\n        ERC20 _partnerAsset,\n        string memory _name,\n        string memory _symbol,\n        address _bhermes,\n        address _partnerVault,\n        address _owner\n    )\n        PartnerUtilityManager(\n            address(bHermes(_bhermes).gaugeWeight()),\n            address(bHermes(_bhermes).gaugeBoost()),\n            address(bHermes(_bhermes).governance()),\n            address(new ERC20MultiVotes(_owner)),\n            partnerVault\n        )\n        ERC4626(\n            _partnerAsset,\n            string.concat(_name, \" - Burned Hermes: Aggregated Gov + Yield + Boost\"),\n            string.concat(_symbol, \"-bHermes\")\n        )\n    {\n        _initializeOwner(_owner);\n        partnerVault = _partnerVault;\n        factory = _factory;\n        bHermesRate = _bHermesRate;\n        bHermesToken = bHermes(_bhermes);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            UTILITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626PartnerManager\n    function updateUnderlyingBalance() public virtual {\n        bHermesToken.claimOutstanding();\n    }\n\n    /// @inheritdoc IERC4626PartnerManager\n    function claimOutstanding() public virtual {\n        uint256 balance = balanceOf[msg.sender] * bHermesRate;\n        /// @dev Never overflows since balandeOf >= userClaimed.\n        claimWeight(balance - userClaimedWeight[msg.sender]);\n        claimBoost(balance - userClaimedBoost[msg.sender]);\n        claimGovernance(balance - userClaimedGovernance[msg.sender]);\n        claimPartnerGovernance(balance - userClaimedPartnerGovernance[msg.sender]);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ERC4626 ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Compute the amount of tokens available in contract.\n    /// @dev 1:1 with underlying asset.\n    function totalAssets() public view override returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Computes and returns the amount of shares from a given amount of assets.\n     * @param assets amount of assets to convert to shares\n     */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Computes and returns the amount of assets from a given amount of shares.\n     * @param shares amount of shares to convert to assets\n     */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Simulates the amount of shares that the assets deposited are worth.\n     * @param assets amount of assets to simulate the deposit.\n     */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Calculates the amount of shares that the assets deposited are worth.\n     */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be withdrawn from a given amount of shares.\n     */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return assets;\n    }\n\n    /**\n     * @notice Previews the amount of assets to be redeemed from a given amount of shares.\n     * @param shares amount of shares to convert to assets.\n     */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return shares;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ER4626 DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    /// @dev Returns the remaining balance of the bHermes divided by the bHermesRate.\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return (address(bHermesToken).balanceOf(address(this))) / bHermesRate - totalSupply;\n    }\n\n    /// @notice Returns the maximum amount of assets that can be deposited by a user.\n    //"
    }
  ]
}