{
  "Title": "[M-05] Possible DOS (out-of-gas) on loops.",
  "Content": "_Submitted by 0x29A, also found by minhquanym_\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/BatchRequests.sol#L16>\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/BatchRequests.sol#L36>\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/BatchRequests.sol#L91>\n\n### Impact\n\nIt is possible to get an out-of-gas issue while iterating the for loop.\n\nPlease take a look at [this link](https://github.com/wissalHaji/solidity-coding-advices/blob/master/best-practices/be-careful-with-loops.md).\n\n### Proof of Concept\n\nLet's say I want to run the function on [`BatchRequests.sol#L14`](https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/BatchRequests.sol#L14) and I got a lot of [`contracts`](https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/BatchRequests.sol#L9) pending for withdrawal.\n\n### Recommended Mitigation Steps\n\nUse this pattern;\n\n```solidity\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests(uint256 from, uint256 to) external {\n        uint256 contractsLength = contracts.length;\n        require(from < contractsLength, \"Invalid from\");\n        require(to <= contractsLength, \"Invalid to\");\n        for (uint256 i = from; i < to; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n**[0xean (Yieldy) acknowledged](https://github.com/code-423n4/2022-06-yieldy-findings/issues/94)** \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-yieldy-contest",
  "Code": [
    {
      "filename": "src/contracts/BatchRequests.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../structs/Batch.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchRequests is Ownable {\n    address[] public contracts;\n\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests() external {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n        @notice shows which contracts can batch\n        @return (address, bool)[]\n     */\n    function canBatchContracts() external view returns (Batch[] memory) {\n        uint256 contractsLength = contracts.length;\n        Batch[] memory batch = new Batch[](contractsLength);\n        for (uint256 i; i < contractsLength; ) {\n            bool canBatch = IStaking(contracts[i]).canBatchTransactions();\n            batch[i] = Batch(contracts[i], canBatch);\n            unchecked {\n                ++i;\n            }\n        }\n        return batch;\n    }\n\n    /**\n        @notice shows if contracts can batch by index\n        @return (address, bool)\n     */\n    function canBatchContractByIndex(uint256 _index)\n        external\n        view\n        returns (address, bool)\n    {\n        return (\n            contracts[_index],\n            IStaking(contracts[_index]).canBatchTransactions()\n        );\n    }\n\n    /**\n        @notice get address in contracts by index\n        @return address\n     */\n    function getAddressByIndex(uint256 _index) external view returns (address) {\n        return contracts[_index];\n    }\n\n    /**\n        @notice get addresses in contracts\n        @return address[]\n     */\n    function getAddresses() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n        @notice add address to contracts array\n        @param _address - address to add\n     */\n    function addAddress(address _address) external onlyOwner {\n        contracts.push(_address);\n    }\n\n    /**\n        @notice remove address to contracts array\n        @param _address - address to remove\n     */\n    function removeAddress(address _address) external onlyOwner {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (contracts[i] == _address) {\n                delete contracts[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/contracts/BatchRequests.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../structs/Batch.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchRequests is Ownable {\n    address[] public contracts;\n\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests() external {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n        @notice shows which contracts can batch\n        @return (address, bool)[]\n     */\n    function canBatchContracts() external view returns (Batch[] memory) {\n        uint256 contractsLength = contracts.length;\n        Batch[] memory batch = new Batch[](contractsLength);\n        for (uint256 i; i < contractsLength; ) {\n            bool canBatch = IStaking(contracts[i]).canBatchTransactions();\n            batch[i] = Batch(contracts[i], canBatch);\n            unchecked {\n                ++i;\n            }\n        }\n        return batch;\n    }\n\n    /**\n        @notice shows if contracts can batch by index\n        @return (address, bool)\n     */\n    function canBatchContractByIndex(uint256 _index)\n        external\n        view\n        returns (address, bool)\n    {\n        return (\n            contracts[_index],\n            IStaking(contracts[_index]).canBatchTransactions()\n        );\n    }\n\n    /**\n        @notice get address in contracts by index\n        @return address\n     */\n    function getAddressByIndex(uint256 _index) external view returns (address) {\n        return contracts[_index];\n    }\n\n    /**\n        @notice get addresses in contracts\n        @return address[]\n     */\n    function getAddresses() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n        @notice add address to contracts array\n        @param _address - address to add\n     */\n    function addAddress(address _address) external onlyOwner {\n        contracts.push(_address);\n    }\n\n    /**\n        @notice remove address to contracts array\n        @param _address - address to remove\n     */\n    function removeAddress(address _address) external onlyOwner {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (contracts[i] == _address) {\n                delete contracts[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/contracts/BatchRequests.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../structs/Batch.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchRequests is Ownable {\n    address[] public contracts;\n\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests() external {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n        @notice shows which contracts can batch\n        @return (address, bool)[]\n     */\n    function canBatchContracts() external view returns (Batch[] memory) {\n        uint256 contractsLength = contracts.length;\n        Batch[] memory batch = new Batch[](contractsLength);\n        for (uint256 i; i < contractsLength; ) {\n            bool canBatch = IStaking(contracts[i]).canBatchTransactions();\n            batch[i] = Batch(contracts[i], canBatch);\n            unchecked {\n                ++i;\n            }\n        }\n        return batch;\n    }\n\n    /**\n        @notice shows if contracts can batch by index\n        @return (address, bool)\n     */\n    function canBatchContractByIndex(uint256 _index)\n        external\n        view\n        returns (address, bool)\n    {\n        return (\n            contracts[_index],\n            IStaking(contracts[_index]).canBatchTransactions()\n        );\n    }\n\n    /**\n        @notice get address in contracts by index\n        @return address\n     */\n    function getAddressByIndex(uint256 _index) external view returns (address) {\n        return contracts[_index];\n    }\n\n    /**\n        @notice get addresses in contracts\n        @return address[]\n     */\n    function getAddresses() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n        @notice add address to contracts array\n        @param _address - address to add\n     */\n    function addAddress(address _address) external onlyOwner {\n        contracts.push(_address);\n    }\n\n    /**\n        @notice remove address to contracts array\n        @param _address - address to remove\n     */\n    function removeAddress(address _address) external onlyOwner {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (contracts[i] == _address) {\n                delete contracts[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/contracts/BatchRequests.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../interfaces/IStaking.sol\";\nimport \"../structs/Batch.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BatchRequests is Ownable {\n    address[] public contracts;\n\n    /**\n        @notice sendWithdrawalRequests on all addresses in contracts\n     */\n    function sendWithdrawalRequests() external {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (\n                contracts[i] != address(0) &&\n                IStaking(contracts[i]).canBatchTransactions()\n            ) {\n                IStaking(contracts[i]).sendWithdrawalRequests();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n        @notice shows which contracts can batch\n        @return (address, bool)[]\n     */\n    function canBatchContracts() external view returns (Batch[] memory) {\n        uint256 contractsLength = contracts.length;\n        Batch[] memory batch = new Batch[](contractsLength);\n        for (uint256 i; i < contractsLength; ) {\n            bool canBatch = IStaking(contracts[i]).canBatchTransactions();\n            batch[i] = Batch(contracts[i], canBatch);\n            unchecked {\n                ++i;\n            }\n        }\n        return batch;\n    }\n\n    /**\n        @notice shows if contracts can batch by index\n        @return (address, bool)\n     */\n    function canBatchContractByIndex(uint256 _index)\n        external\n        view\n        returns (address, bool)\n    {\n        return (\n            contracts[_index],\n            IStaking(contracts[_index]).canBatchTransactions()\n        );\n    }\n\n    /**\n        @notice get address in contracts by index\n        @return address\n     */\n    function getAddressByIndex(uint256 _index) external view returns (address) {\n        return contracts[_index];\n    }\n\n    /**\n        @notice get addresses in contracts\n        @return address[]\n     */\n    function getAddresses() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n        @notice add address to contracts array\n        @param _address - address to add\n     */\n    function addAddress(address _address) external onlyOwner {\n        contracts.push(_address);\n    }\n\n    /**\n        @notice remove address to contracts array\n        @param _address - address to remove\n     */\n    function removeAddress(address _address) external onlyOwner {\n        uint256 contractsLength = contracts.length;\n        for (uint256 i; i < contractsLength; ) {\n            if (contracts[i] == _address) {\n                delete contracts[i];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}