{
  "Title": "[L-01]",
  "Content": "<h2 id=\"l-01-jbtiered721delegatetokenuri-should-throw-an-error-if-_tokenid-is-not-a-valid-nft\" style=\"position:relative;\"><a href=\"#l-01-jbtiered721delegatetokenuri-should-throw-an-error-if-_tokenid-is-not-a-valid-nft\" aria-label=\"l 01 jbtiered721delegatetokenuri should throw an error if _tokenid is not a valid nft permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] <code>JBTiered721Delegate.tokenURI</code> should throw an error if <code>_tokenId</code> is not a valid NFT</h2>\n<p>According to <a href=\"https://eips.ethereum.org/EIPS/eip-721\"><code>EIP-721</code></a> and specifically, the metadata extension, the <code>tokenURI</code> function should throw an error if <code>_tokenId</code> is not a valid NFT. Contrary, the current implementation returns an empty string.</p>\n<h3 id=\"findings\" style=\"position:relative;\"><a href=\"#findings\" aria-label=\"findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Findings</h3>\n<p><a href=\"https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L140\">JBTiered721Delegate.sol#L140</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"32\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">tokenURI</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// A token without an owner doesn't have a URI.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">_owners</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">] == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)) </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk8\">''</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// @audit-info Should throw instead of returning an empty string</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// Get a reference to the URI resolver.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">IJBTokenUriResolver</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_resolver</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">store</span><span class=\"mtk1\">.</span><span class=\"mtk11\">tokenUriResolverOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// If a token URI resolver is provided, use it to resolve the token URI.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_resolver</span><span class=\"mtk1\">) != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)) </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_resolver</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getUri</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// Return the token URI for the token's tier.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">return</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">JBIpfsDecoder</span><span class=\"mtk1\">.</span><span class=\"mtk11\">decode</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">store</span><span class=\"mtk1\">.</span><span class=\"mtk11\">baseUriOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">store</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encodedTierIPFSUriOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h3 id=\"recommended-mitigation-steps-13\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-13\" aria-label=\"recommended mitigation steps 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended mitigation steps</h3>\n<p>Consider throwing an error if <code>_tokenId</code> is not a valid NFT.</p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-10-juicebox-contest",
  "Code": [
    {
      "filename": "contracts/JBTiered721Delegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@jbx-protocol/juice-contracts-v3/contracts/libraries/JBFundingCycleMetadataResolver.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './abstract/JB721Delegate.sol';\nimport './interfaces/IJBTiered721Delegate.sol';\nimport './libraries/JBIpfsDecoder.sol';\nimport './libraries/JBTiered721FundingCycleMetadataResolver.sol';\nimport './structs/JBTiered721Flags.sol';\n\n/**\n  @title\n  JBTiered721Delegate\n\n  @notice\n  Delegate that offers project contributors NFTs with tiered price floors upon payment and the ability to redeem NFTs for treasury assets based based on price floor.\n\n  @dev\n  Adheres to -\n  IJBTiered721Delegate: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JB721Delegate: A generic NFT delegate.\n  Votes: A helper for voting balance snapshots.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n*/\ncontract JBTiered721Delegate is IJBTiered721Delegate, JB721Delegate, Ownable {\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n\n  error NOT_AVAILABLE();\n  error OVERSPENDING();\n  error PRICING_RESOLVER_CHANGES_PAUSED();\n  error RESERVED_TOKEN_MINTING_PAUSED();\n  error TRANSFERS_PAUSED();\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The address of the origin 'JBTiered721Delegate', used to check in the init if the contract is the original or not\n  */\n  address public override codeOrigin;\n\n  /**\n    @notice\n    The contract that stores and manages the NFT's data.\n  */\n  IJBTiered721DelegateStore public override store;\n\n  /**\n    @notice\n    The contract storing all funding cycle configurations.\n  */\n  IJBFundingCycleStore public override fundingCycleStore;\n\n  /**\n    @notice\n    The contract that exposes price feeds.\n  */\n  IJBPrices public override prices;\n\n  /** \n    @notice\n    The currency that is accepted when minting tier NFTs. \n  */\n  uint256 public override pricingCurrency;\n\n  /** \n    @notice\n    The currency that is accepted when minting tier NFTs. \n  */\n  uint256 public override pricingDecimals;\n\n  /** \n    @notice\n    The amount that each address has paid that has not yet contribute to the minting of an NFT. \n\n    _address The address to which the credits belong.\n  */\n  mapping(address => uint256) public override creditsOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The first owner of each token ID, which corresponds to the address that originally contributed to the project to receive the NFT.\n\n    @param _tokenId The ID of the token to get the first owner of.\n\n    @return The first owner of the token.\n  */\n  function firstOwnerOf(uint256 _tokenId) external view override returns (address) {\n    // Get a reference to the first owner.\n    address _storedFirstOwner = store.firstOwnerOf(address(this), _tokenId);\n\n    // If the stored first owner is set, return it.\n    if (_storedFirstOwner != address(0)) return _storedFirstOwner;\n\n    // Otherwise, the first owner must be the current owner.\n    return _owners[_tokenId];\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    The total number of tokens owned by the given owner across all tiers. \n\n    @param _owner The address to check the balance of.\n\n    @return balance The number of tokens owners by the owner accross all tiers.\n  */\n  function balanceOf(address _owner) public view override returns (uint256 balance) {\n    return store.balanceOf(address(this), _owner);\n  }\n\n  /** \n    @notice\n    The metadata URI of the provided token ID.\n\n    @dev\n    Defer to the tokenUriResolver if set, otherwise, use the tokenUri set with the token's tier.\n\n    @param _tokenId The ID of the token to get the tier URI for. \n\n    @return The token URI corresponding with the tier or the tokenUriResolver URI.\n  */\n  function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n    // A token without an owner doesn't have a URI.\n    if (_owners[_tokenId] == address(0)) return '';\n\n    // Get a reference to the URI resolver.\n    IJBTokenUriResolver _resolver = store.tokenUriResolverOf(address(this));\n\n    // If a token URI resolver is provided, use it to resolve the token URI.\n    if (address(_resolver) != address(0)) return _resolver.getUri(_tokenId);\n\n    // Return the token URI for the token's tier.\n    return\n      JBIpfsDecoder.decode(\n        store.baseUriOf(address(this)),\n        store.encodedTierIPFSUriOf(address(this), _tokenId)\n      );\n  }\n\n  /** \n    @notice\n    Returns the URI where contract metadata can be found. \n\n    @return The contract's metadata URI.\n  */\n  function contractURI() external view override returns (string memory) {\n    return store.contractUriOf(address(this));\n  }\n\n  /**\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev\n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  */\n  function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n    return\n      _interfaceId == type(IJBTiered721Delegate).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  constructor() {\n    codeOrigin = address(this);\n  }\n\n  /**\n    @param _projectId The ID of the project this contract's functionality applies to.\n    @param _directory The directory of terminals and controllers for projects.\n    @param _name The name of the token.\n    @param _symbol The symbol that the token should be represented by.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _baseUri A URI to use as a base for full token URIs.\n    @param _tokenUriResolver A contract responsible for resolving the token URI for each token ID.\n    @param _contractUri A URI where contract metadata can be found. \n    @param _pricing The tier pricing according to which token distribution will be made. Must be passed in order of contribution floor, with implied increasing value.\n    @param _store A contract that stores the NFT's data.\n    @param _flags A set of flags that help define how this contract works.\n  */\n  function initialize(\n    uint256 _projectId,\n    IJBDirectory _directory,\n    string memory _name,\n    string memory _symbol,\n    IJBFundingCycleStore _fundingCycleStore,\n    string memory _baseUri,\n    IJBTokenUriResolver _tokenUriResolver,\n    string memory _contractUri,\n    JB721PricingParams memory _pricing,\n    IJBTiered721DelegateStore _store,\n    JBTiered721Flags memory _flags\n  ) public override {\n    // Make the original un-initializable.\n    require(address(this) != codeOrigin);\n    // Stop re-initialization.\n    require(address(store) == address(0));\n\n    // Initialize the sub class.\n    JB721Delegate._initialize(_projectId, _directory, _name, _symbol);\n\n    fundingCycleStore = _fundingCycleStore;\n    store = _store;\n    pricingCurrency = _pricing.currency;\n    pricingDecimals = _pricing.decimals;\n    prices = _pricing.prices;\n\n    // Store the base URI if provided.\n    if (bytes(_baseUri).length != 0) _store.recordSetBaseUri(_baseUri);\n\n    // Set the contract URI if provided.\n    if (bytes(_contractUri).length != 0) _store.recordSetContractUri(_contractUri);\n\n    // Set the token URI resolver if provided.\n    if (_tokenUriResolver != IJBTokenUriResolver(address(0)))\n      _store.recordSetTokenUriResolver(_tokenUriResolver);\n\n    // Record adding the provided tiers.\n    if (_pricing.tiers.length > 0) _store.recordAddTiers(_pricing.tiers);\n\n    // Set the flags if needed.\n    if (\n      _flags.lockReservedTokenChanges ||\n      _flags.lockVotingUnitChanges ||\n      _flags.lockManualMintingChanges ||\n      _flags.pausable\n    ) _store.recordFlags(_flags);\n\n    // Transfer ownership to the initializer.\n    _transferOwnership(msg.sender);\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Mint reserved tokens within the tier for the provided value.\n\n    @param _mintReservesForTiersData Contains information about how many reserved tokens to mint for each tier.\n  */\n  function mintReservesFor(JBTiered721MintReservesForTiersData[] memory _mintReservesForTiersData)\n    external\n    override\n  {\n    // Keep a reference to the number of tiers there are to mint reserved for.\n    uint256 _numberOfTiers = _mintReservesForTiersData.length;\n\n    for (uint256 _i; _i < _numberOfTiers; ) {\n      // Get a reference to the data being iterated on.\n      JBTiered721MintReservesForTiersData memory _data = _mintReservesForTiersData[_i];\n\n      // Mint for the tier.\n      mintReservesFor(_data.tierId, _data.count);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Mint tokens within the tier for the provided beneficiaries.\n\n    @param _mintForTiersData Contains information about how who to mint tokens for from each tier.\n  */\n  function mintFor(JBTiered721MintForTiersData[] memory _mintForTiersData)\n    external\n    override\n    onlyOwner\n  {\n    // Keep a reference to the number of beneficiaries there are to mint for.\n    uint256 _numberOfBeneficiaries = _mintForTiersData.length;\n\n    for (uint256 _i; _i < _numberOfBeneficiaries; ) {\n      // Get a reference to the data being iterated on.\n      JBTiered721MintForTiersData memory _data = _mintForTiersData[_i];\n\n      // Mint for the tier.\n      mintFor(_data.tierIds, _data.beneficiary);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Adjust the tiers mintable through this contract, adhering to any locked tier constraints. \n\n    @dev\n    Only the contract's owner can adjust the tiers.\n\n    @param _tiersToAdd An array of tier data to add.\n    @param _tierIdsToRemove An array of tier IDs to remove.\n  */\n  function adjustTiers(JB721TierParams[] calldata _tiersToAdd, uint256[] calldata _tierIdsToRemove)\n    external\n    override\n    onlyOwner\n  {\n    // Get a reference to the number of tiers being added.\n    uint256 _numberOfTiersToAdd = _tiersToAdd.length;\n\n    // Get a reference to the number of tiers being removed.\n    uint256 _numberOfTiersToRemove = _tierIdsToRemove.length;\n\n    // Remove the tiers.\n    if (_numberOfTiersToRemove != 0) {\n      // Record the removed tiers.\n      store.recordRemoveTierIds(_tierIdsToRemove);\n\n      // Emit events for each removed tier.\n      for (uint256 _i; _i < _numberOfTiersToRemove; ) {\n        emit RemoveTier(_tierIdsToRemove[_i], msg.sender);\n        unchecked {\n          ++_i;\n        }\n      }\n    }\n\n    // Add the tiers.\n    if (_numberOfTiersToAdd != 0) {\n      // Record the added tiers in the store.\n      uint256[] memory _tierIdsAdded = store.recordAddTiers(_tiersToAdd);\n\n      // Emit events for each added tier.\n      for (uint256 _i; _i < _numberOfTiersToAdd; ) {\n        emit AddTier(_tierIdsAdded[_i], _tiersToAdd[_i], msg.sender);\n        unchecked {\n          ++_i;\n        }\n      }\n    }\n  }\n\n  /** \n    @notice\n    Sets the beneificiary of the reserved tokens for tiers where a specific beneficiary isn't set. \n\n    @dev\n    Only the contract's owner can set the default reserved token beneficiary.\n\n    @param _beneficiary The default beneificiary of the reserved tokens.\n  */\n  function setDefaultReservedTokenBeneficiary(address _beneficiary) external override onlyOwner {\n    // Set the beneficiary.\n    store.recordSetDefaultReservedTokenBeneficiary(_beneficiary);\n\n    emit SetDefaultReservedTokenBeneficiary(_beneficiary, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a base token URI.\n\n    @dev\n    Only the contract's owner can set the base URI.\n\n    @param _baseUri The new base URI.\n  */\n  function setBaseUri(string memory _baseUri) external override onlyOwner {\n    // Store the new value.\n    store.recordSetBaseUri(_baseUri);\n\n    emit SetBaseUri(_baseUri, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a contract metadata URI to contain opensea-style metadata.\n\n    @dev\n    Only the contract's owner can set the contract URI.\n\n    @param _contractUri The new contract URI.\n  */\n  function setContractUri(string calldata _contractUri) external override onlyOwner {\n    // Store the new value.\n    store.recordSetContractUri(_contractUri);\n\n    emit SetContractUri(_contractUri, msg.sender);\n  }\n\n  /**\n    @notice\n    Set a token URI resolver.\n\n    @dev\n    Only the contract's owner can set the token URI resolver.\n\n    @param _tokenUriResolver The new URI resolver.\n  */\n  function setTokenUriResolver(IJBTokenUriResolver _tokenUriResolver) external override onlyOwner {\n    // Store the new value.\n    store.recordSetTokenUriResolver(_tokenUriResolver);\n\n    emit SetTokenUriResolver(_tokenUriResolver, msg.sender);\n  }\n\n  //*********************************************************************//\n  // ----------------------- public transactions ----------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Mint reserved tokens within the tier for the provided value.\n\n    @param _tierId The ID of the tier to mint within.\n    @param _count The number of reserved tokens to mint. \n  */\n  function mintReservesFor(uint256 _tierId, uint256 _count) public override {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(projectId);\n\n    // Minting reserves must not be paused.\n    if (\n      JBTiered721FundingCycleMetadataResolver.mintingReservesPaused(\n        (JBFundingCycleMetadataResolver.metadata(_fundingCycle))\n      )\n    ) revert RESERVED_TOKEN_MINTING_PAUSED();\n\n    // Record the minted reserves for the tier.\n    uint256[] memory _tokenIds = store.recordMintReservesFor(_tierId, _count);\n\n    // Keep a reference to the reserved token beneficiary.\n    address _reservedTokenBeneficiary = store.reservedTokenBeneficiaryOf(address(this), _tierId);\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    for (uint256 _i; _i < _count; ) {\n      // Set the token ID.\n      _tokenId = _tokenIds[_i];\n\n      // Mint the token.\n      _mint(_reservedTokenBeneficiary, _tokenId);\n\n      emit MintReservedToken(_tokenId, _tierId, _reservedTokenBeneficiary, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Manually mint NFTs from tiers.\n\n    @param _tierIds The IDs of the tiers to mint from.\n    @param _beneficiary The address to mint to. \n\n    @return tokenIds The IDs of the newly minted tokens.\n  */\n  function mintFor(uint16[] memory _tierIds, address _beneficiary)\n    public\n    override\n    onlyOwner\n    returns (uint256[] memory tokenIds)\n  {\n    // Record the mint. The returned token IDs correspond to the tiers passed in.\n    (tokenIds, ) = store.recordMint(\n      type(uint256).max, // force the mint.\n      _tierIds,\n      true // manual mint\n    );\n\n    // Keep a reference to the number of tokens being minted.\n    uint256 _numberOfTokens = _tierIds.length;\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    for (uint256 _i; _i < _numberOfTokens; ) {\n      // Set the token ID.\n      _tokenId = tokenIds[_i];\n\n      // Mint the token.\n      _mint(_beneficiary, _tokenId);\n\n      emit Mint(_tokenId, _tierIds[_i], _beneficiary, 0, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  //*********************************************************************//\n  // ------------------------ internal functions ----------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Mints for a given contribution to the beneficiary.\n\n    @param _data The Juicebox standard project contribution data.\n  */\n  function _processPayment(JBDidPayData calldata _data) internal override {\n    // Normalize the currency.\n    uint256 _value;\n    if (_data.amount.currency == pricingCurrency) _value = _data.amount.value;\n    else if (prices != IJBPrices(address(0)))\n      _value = PRBMath.mulDiv(\n        _data.amount.value,\n        10**pricingDecimals,\n        prices.priceFor(_data.amount.currency, pricingCurrency, _data.amount.decimals)\n      );\n    else return;\n\n    // Keep a reference to the amount of credits the beneficiary already has.\n    uint256 _credits = creditsOf[_data.beneficiary];\n\n    // Set the leftover amount as the initial value, including any credits the beneficiary might already have.\n    uint256 _leftoverAmount = _value + _credits;\n\n    // Keep a reference to a flag indicating if a mint is expected from discretionary funds. Defaults to false, meaning to mint is not expected.\n    bool _expectMintFromExtraFunds;\n\n    // Keep a reference to the flag indicating if the transaction should revert if all provded funds aren't spent. Defaults to false, meaning only a minimum payment is enforced.\n    bool _dontOverspend;\n\n    // Skip the first 32 bytes which are used by the JB protocol to pass the paying project's ID when paying from a JBSplit.\n    // Check the 4 bytes interfaceId to verify the metadata is intended for this contract.\n    if (\n      _data.metadata.length > 36 &&\n      bytes4(_data.metadata[32:36]) == type(IJB721Delegate).interfaceId\n    ) {\n      // Keep a reference to the flag indicating if the transaction should not mint anything.\n      bool _dontMint;\n\n      // Keep a reference to the the specific tier IDs to mint.\n      uint16[] memory _tierIdsToMint;\n\n      // Decode the metadata.\n      (, , _dontMint, _expectMintFromExtraFunds, _dontOverspend, _tierIdsToMint) = abi.decode(\n        _data.metadata,\n        (bytes32, bytes4, bool, bool, bool, uint16[])\n      );\n\n      // Don't mint if not desired.\n      if (_dontMint) return;\n\n      // Mint rewards if they were specified.\n      if (_tierIdsToMint.length != 0)\n        _leftoverAmount = _mintAll(_leftoverAmount, _tierIdsToMint, _data.beneficiary);\n    }\n\n    // If there are funds leftover, mint the best available with it.\n    if (_leftoverAmount != 0) {\n      _leftoverAmount = _mintBestAvailableTier(\n        _leftoverAmount,\n        _data.beneficiary,\n        _expectMintFromExtraFunds\n      );\n\n      if (_leftoverAmount != 0) {\n        // Make sure there are no leftover funds after minting if not expected.\n        if (_dontOverspend) revert OVERSPENDING();\n\n        // Increment the leftover amount.\n        creditsOf[_data.beneficiary] = _leftoverAmount;\n      } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n    } else if (_credits != 0) creditsOf[_data.beneficiary] = 0;\n  }\n\n  /** \n    @notice\n    A function that will run when a tokens are burned via redemption.\n\n    @param _tokenIds The IDs of the tokens that were burned.\n  */\n  function _didBurn(uint256[] memory _tokenIds) internal override {\n    // Add to burned counter.\n    store.recordBurn(_tokenIds);\n  }\n\n  /** \n    @notice\n    Mints a token in the best available tier.\n\n    @param _amount The amount to base the mint on.\n    @param _beneficiary The address to mint for.\n    @param _expectMint A flag indicating if a mint was expected.\n\n    @return  leftoverAmount The amount leftover after the mint.\n  */\n  function _mintBestAvailableTier(\n    uint256 _amount,\n    address _beneficiary,\n    bool _expectMint\n  ) internal returns (uint256 leftoverAmount) {\n    // Keep a reference to the token ID.\n    uint256 _tokenId;\n\n    // Keep a reference to the tier ID.\n    uint256 _tierId;\n\n    // Record the mint.\n    (_tokenId, _tierId, leftoverAmount) = store.recordMintBestAvailableTier(_amount);\n\n    // If there's no best tier, return or revert.\n    if (_tokenId == 0) {\n      // Make sure a mint was not expected.\n      if (_expectMint) revert NOT_AVAILABLE();\n      return leftoverAmount;\n    }\n\n    // Mint the tokens.\n    _mint(_beneficiary, _tokenId);\n\n    emit Mint(_tokenId, _tierId, _beneficiary, _amount - leftoverAmount, msg.sender);\n  }\n\n  /** \n    @notice\n    Mints a token in all provided tiers.\n\n    @param _amount The amount to base the mints on. All mints' price floors must fit in this amount.\n    @param _mintTierIds An array of tier IDs that are intended to be minted.\n    @param _beneficiary The address to mint for.\n\n    @return leftoverAmount The amount leftover after the mint.\n  */\n  function _mintAll(\n    uint256 _amount,\n    uint16[] memory _mintTierIds,\n    address _beneficiary\n  ) internal returns (uint256 leftoverAmount) {\n    // Keep a reference to the token ID.\n    uint256[] memory _tokenIds;\n\n    // Record the mint. The returned token IDs correspond to the tiers passed in.\n    (_tokenIds, leftoverAmount) = store.recordMint(\n      _amount,\n      _mintTierIds,\n      false // Not a manual mint\n    );\n\n    // Get a reference to the number of mints.\n    uint256 _mintsLength = _tokenIds.length;\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    // Loop through each token ID and mint.\n    for (uint256 _i; _i < _mintsLength; ) {\n      // Get a reference to the tier being iterated on.\n      _tokenId = _tokenIds[_i];\n\n      // Mint the tokens.\n      _mint(_beneficiary, _tokenId);\n\n      emit Mint(_tokenId, _mintTierIds[_i], _beneficiary, _amount, msg.sender);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    The cumulative weight the given token IDs have in redemptions compared to the `_totalRedemptionWeight`. \n\n    @param _tokenIds The IDs of the tokens to get the cumulative redemption weight of.\n\n    @return The weight.\n  */\n  function _redemptionWeightOf(uint256[] memory _tokenIds)\n    internal\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return store.redemptionWeightOf(address(this), _tokenIds);\n  }\n\n  /** \n    @notice\n    The cumulative weight that all token IDs have in redemptions. \n\n    @return The total weight.\n  */\n  function _totalRedemptionWeight() internal view virtual override returns (uint256) {\n    return store.totalRedemptionWeight(address(this));\n  }\n\n  /**\n    @notice\n    User the hook to register the first owner if it's not yet regitered.\n\n    @param _from The address where the transfer is originating.\n    @param _to The address to which the transfer is being made.\n    @param _tokenId The ID of the token being transfered.\n  */\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal virtual override {\n    // Transfered must not be paused when not minting or burning.\n    if (_from != address(0)) {\n      // Transfers must not be paused.\n      if (store.flagsOf(address(this)).pausable) {\n        // Get a reference to the project's current funding cycle.\n        JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(projectId);\n\n        if (\n          _to != address(0) &&\n          JBTiered721FundingCycleMetadataResolver.transfersPaused(\n            (JBFundingCycleMetadataResolver.metadata(_fundingCycle))\n          )\n        ) revert TRANSFERS_PAUSED();\n      }\n\n      // If there's no stored first owner, and the transfer isn't originating from the zero address as expected for mints, store the first owner.\n      if (store.firstOwnerOf(address(this), _tokenId) == address(0))\n        store.recordSetFirstOwnerOf(_tokenId, _from);\n    }\n\n    super._beforeTokenTransfer(_from, _to, _tokenId);\n  }\n\n  /**\n    @notice\n    Transfer voting units after the transfer of a token.\n\n    @param _from The address where the transfer is originating.\n    @param _to The address to which the transfer is being made.\n    @param _tokenId The ID of the token being transfered.\n   */\n  function _afterTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal virtual override {\n    // Get a reference to the tier.\n    JB721Tier memory _tier = store.tierOfTokenId(address(this), _tokenId);\n\n    // Record the transfer.\n    store.recordTransferForTier(_tier.id, _from, _to);\n\n    // Handle any other accounting (ex. account for governance voting units)\n    _afterTokenTransferAccounting(_from, _to, _tokenId, _tier);\n\n    super._afterTokenTransfer(_from, _to, _tokenId);\n  }\n\n  /**\n    @notice \n    Custom hook to handle token/tier accounting, this way we can reuse the '_tier' instead of fetching it again.\n\n    @param _from The account to transfer voting units from.\n    @param _to The account to transfer voting units to.\n    @param _tokenId The ID of the token for which voting units are being transfered.\n    @param _tier The tier the token ID is part of.\n  */\n  function _afterTokenTransferAccounting(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    JB721Tier memory _tier\n  ) internal virtual {\n    _from; // Prevents unused var compiler and natspec complaints.\n    _to;\n    _tokenId;\n    _tier;\n  }\n}"
    }
  ]
}