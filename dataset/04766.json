{
  "Title": "[M-11] `MagicLpAggregator` can be incompatible with potential integrators due to incorrect `latestRoundData` function",
  "Content": "\n`MagicLpAggregator` does not update the `roundId`, `startAt`, `updatedAt` and `answeredInRound` to correct values.\n\n[MagicLpAggregator.sol#L48-L50](https://github.com/code-423n4/2024-03-abracadabra-money/blob/main/src/oracles/aggregators/MagicLpAggregator.sol#L48-L50)\n\n```solidity\n    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n        return (0, latestAnswer(), 0, 0, 0);\n    }\n```\n\nA common code is to check `updatedAt` for staleness issue (although it isn't required to do so anymore.\n\n```solidity\n(, int256 price, , uint256 updatedAt, ) = priceFeed.latestRoundData();\n\nif (updatedAt < block.timestamp - 60 * 60 /* 1 hour */) {\n   revert(\"stale price feed\");\n}\n```\n\nTherefore any integrator that uses the above code will not be able to integrate\n`MagicLpAggregator` oracles as it will always revert due to the incorrect `updatedAt` being provided.\n\n### Recommended Mitigation Steps\n\nUse the values `roundId`, `startAt`, `updatedAt` and `answeredInRound` from whichever oracle, `baseOracle` or `quoteOracle` was used.\n\n**[rexjoseph (Warden) commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/93#issuecomment-2034370525):**\n> I think we should reiterate the issue here as the submission has tried its best to point out:\n> \n> 1. The `MagicLpAggregator` gets the price from Chainlink's Feed\n> 2. Integrators (for example protocol A) query the `MagicLPAggregator` Oracle for price specifically the `latestRoundData()` function it exposes in their implementation\n> 3. They make sure the prices returned are fresh and so do well to check the time specifically `updatedAt` so they can be sure the feed is fresh to proceed with utilizing the returned data\n> 4. Since the `updatedAt` as well as other returned data are hardcoded to 0 in `MagicLpAggregator` oracle implementation, the call reverts. 0 will always be less than `block.timestamp - 60 * 60`\n> \n> \n> The step by step description of the issue above I believe is sufficient but here's a provided POC to elaborate on this in code:\n> \n> Test file in the abracadabra codebase is:  MagicLPAggregator.t.sol\n> \n> ```js\n> function testProtocolAIntegrationOfMagicLPAggReverts() public {\n> \n>         // return values of `MagicLpAggregator` latestRoundData()\n>         (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = aggregator.latestRoundData();\n> \n>         // protocol A tries to make sure the prices returned is fresh by checking the time\n> \n>         // keep in mind the time aka updatedAt is hardcoded to 0. So 0 will always be less than `block.timestamp - 60 * 60` hence a revert\n> \n>         if (updatedAt < block.timestamp - 60 * 60 /* 1 hour */) {\n>          revert(\"stale price feed\");\n>         }\n>     }\n> ```\n> \n> ```js\n> Ran 1 test for test/MagicLpAggregator.t.sol:MagicLpAggregatorTest\n> [FAIL. Reason: revert: stale price feed] testProtocolAIntegrationOfMagicLPAggReverts() (gas: 57187)\n> Suite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 2.56s (2.88ms CPU time)\n> ```\n\n**[cccz (Judge) commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/93#issuecomment-2037525115):**\n > latestRoundData() is different from the standard and may cause integration issues. \n> Will consider it a valid M.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/oracles/aggregators/MagicLpAggregator.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport {IAggregator} from \"interfaces/IAggregator.sol\";\nimport {IMagicLP} from \"/mimswap/interfaces/IMagicLP.sol\";\n\ncontract MagicLpAggregator is IAggregator {\n    IMagicLP public immutable pair;\n    IAggregator public immutable baseOracle;\n    IAggregator public immutable quoteOracle;\n    uint8 public immutable baseDecimals;\n    uint8 public immutable quoteDecimals;\n\n    uint256 public constant WAD = 18;\n\n    /// @param pair_ The MagicLP pair address\n    /// @param baseOracle_ The base oracle\n    /// @param quoteOracle_ The quote oracle\n    constructor(IMagicLP pair_, IAggregator baseOracle_, IAggregator quoteOracle_) {\n        pair = pair_;\n        baseOracle = baseOracle_;\n        quoteOracle = quoteOracle_;\n        baseDecimals = IERC20Metadata(pair_._BASE_TOKEN_()).decimals();\n        quoteDecimals = IERC20Metadata(pair_._QUOTE_TOKEN_()).decimals();\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function _getReserves() internal view virtual returns (uint256, uint256) {\n        (uint256 baseReserve, uint256 quoteReserve) = pair.getReserves();\n    }\n\n    function latestAnswer() public view override returns (int256) {\n        uint256 baseAnswerNomalized = uint256(baseOracle.latestAnswer()) * (10 ** (WAD - baseOracle.decimals()));\n        uint256 quoteAnswerNormalized = uint256(quoteOracle.latestAnswer()) * (10 ** (WAD - quoteOracle.decimals()));\n        uint256 minAnswer = baseAnswerNomalized < quoteAnswerNormalized ? baseAnswerNomalized : quoteAnswerNormalized;\n\n        (uint256 baseReserve, uint256 quoteReserve) = _getReserves();\n        baseReserve = baseReserve * (10 ** (WAD - baseDecimals));\n        quoteReserve = quoteReserve * (10 ** (WAD - quoteDecimals));\n        return int256(minAnswer * (baseReserve + quoteReserve) / pair.totalSupply());\n    }\n\n    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n        return (0, latestAnswer(), 0, 0, 0);\n    }\n}"
    }
  ]
}