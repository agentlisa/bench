{
  "Title": "The `afterWithdrawChecks` applies only if user wants to withdraw in tokenA/B",
  "Content": "# The `afterWithdrawChecks` applies only if user wants to withdraw in tokenA/B\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXProcessWithdraw.sol#L104\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXProcessWithdraw.sol#L104</a>\n\n\n## Summary\nThe `afterWithdrawChecks` check is very important to be sure that important health parameters are in the proper ranges. But the check is inside brackets of the `if user wants to withdraw in tokenA/B` statement. So if the user wants to withdraw LP-token the check is not provided. This can cause unexpected financial losses.\n\n## Vulnerability Details\nThe  `afterWithdrawChecks` check is placed inside the brackets of the [if-statement](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXProcessWithdraw.sol#L71-L105) of the `GMXProcessWithdraw.processWithdraw` function. This statement checks `if user wants to withdraw in tokenA/B`. In other cases the `afterWithdrawChecks` check is not provided but should.\n\n```solidity\n 69    // Else if user wants to withdraw in LP token, the tokensToUser is already previously\n 70    // set in GMXWithdraw.withdraw()\n 71    if (\n 72      self.withdrawCache.withdrawParams.token == address(self.tokenA) ||\n 73      self.withdrawCache.withdrawParams.token == address(self.tokenB)\n 74    ) {\n\n104      GMXChecks.afterWithdrawChecks(self);\n105    }\n106  }  \n```\n\n## Impact\nThe issue can cause unexpected financial losses.\n\n## Tools used\nManual Review\n\n## Recommendations\nI suppose that the check should be placed after the if statement brackets.",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXProcessWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXProcessWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for process withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXProcessWithdraw {\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    // Check if swap between assets are needed for repayment\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, self.withdrawCache.repayParams);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Repay debt\n    GMXManager.repay(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // At this point, the LP has been removed for assets for repayment hence\n    // equityValue should be less than before. Note that if user wants to withdraw\n    // in LP token, the equityValue here should still be less than before as a portion\n    // of LP will still have been withdrawn for assets for debt repayment\n    self.withdrawCache.healthParams.equityAfter = GMXReader.equityValue(self);\n\n    // If user wants to withdraw in tokenA/B, swap tokens accordingly and update tokensToUser\n    // Else if user wants to withdraw in LP token, the tokensToUser is already previously\n    // set in GMXWithdraw.withdraw()\n    if (\n      self.withdrawCache.withdrawParams.token == address(self.tokenA) ||\n      self.withdrawCache.withdrawParams.token == address(self.tokenB)\n    ) {\n      ISwap.SwapParams memory _sp;\n\n      if (self.withdrawCache.withdrawParams.token == address(self.tokenA)) {\n        _sp.tokenIn = address(self.tokenB);\n        _sp.tokenOut = address(self.tokenA);\n        _sp.amountIn = self.tokenB.balanceOf(address(this));\n      }\n\n      if (self.withdrawCache.withdrawParams.token == address(self.tokenB)) {\n        _sp.tokenIn = address(self.tokenA);\n        _sp.tokenOut = address(self.tokenB);\n        _sp.amountIn = self.tokenA.balanceOf(address(this));\n      }\n\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      self.withdrawCache.tokensToUser =\n        IERC20(self.withdrawCache.withdrawParams.token).balanceOf(address(this));\n\n      GMXChecks.afterWithdrawChecks(self);\n    }\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXProcessWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXProcessWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for process withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXProcessWithdraw {\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    // Check if swap between assets are needed for repayment\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, self.withdrawCache.repayParams);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Repay debt\n    GMXManager.repay(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // At this point, the LP has been removed for assets for repayment hence\n    // equityValue should be less than before. Note that if user wants to withdraw\n    // in LP token, the equityValue here should still be less than before as a portion\n    // of LP will still have been withdrawn for assets for debt repayment\n    self.withdrawCache.healthParams.equityAfter = GMXReader.equityValue(self);\n\n    // If user wants to withdraw in tokenA/B, swap tokens accordingly and update tokensToUser\n    // Else if user wants to withdraw in LP token, the tokensToUser is already previously\n    // set in GMXWithdraw.withdraw()\n    if (\n      self.withdrawCache.withdrawParams.token == address(self.tokenA) ||\n      self.withdrawCache.withdrawParams.token == address(self.tokenB)\n    ) {\n      ISwap.SwapParams memory _sp;\n\n      if (self.withdrawCache.withdrawParams.token == address(self.tokenA)) {\n        _sp.tokenIn = address(self.tokenB);\n        _sp.tokenOut = address(self.tokenA);\n        _sp.amountIn = self.tokenB.balanceOf(address(this));\n      }\n\n      if (self.withdrawCache.withdrawParams.token == address(self.tokenB)) {\n        _sp.tokenIn = address(self.tokenA);\n        _sp.tokenOut = address(self.tokenB);\n        _sp.amountIn = self.tokenA.balanceOf(address(this));\n      }\n\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      self.withdrawCache.tokensToUser =\n        IERC20(self.withdrawCache.withdrawParams.token).balanceOf(address(this));\n\n      GMXChecks.afterWithdrawChecks(self);\n    }\n  }\n}"
    }
  ]
}