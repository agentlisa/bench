{
  "Title": "[R-01] Use `VETO_VALUE` for clarity",
  "Content": "https://github.com/code-423n4/2023-05-party/blob/main/contracts/party/PartyGovernance.sol#L1024-L1027\n\nReplace `type(uint96).max` in the above code with `VETO_VALUE` for clarity and easier refactoring in the future.\n\n**[0xble (Party) acknowledged](https://github.com/code-423n4/2023-05-party-findings/issues/5#issuecomment-1572304200)**\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-05-party-findings/issues/5#issuecomment-1573187891):**\n > L-2 is more like a GAS.<br>\n> The warden's QA submission has the highest score, selected as the best.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-party",
  "Code": [
    {
      "filename": "contracts/party/PartyGovernance.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../distribution/ITokenDistributorParty.sol\";\nimport \"../distribution/ITokenDistributor.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../tokens/IERC1155.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../proposals/IProposalExecutionEngine.sol\";\nimport \"../proposals/LibProposal.sol\";\nimport \"../proposals/ProposalStorage.sol\";\n\nimport \"./IPartyFactory.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ITokenDistributorParty,\n    ERC721Receiver,\n    ERC1155Receiver,\n    ProposalStorage,\n    Implementation,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but has further steps to\n        // complete so it needs to be executed again. No other proposals may be\n        // executed while a proposal is in the `InProgress` state. No voting or\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\n        InProgress,\n        // The proposal was executed and completed all its steps. No voting or\n        // vetoing can occur and it cannot be cancelled nor executed again.\n        Complete,\n        // The proposal was executed at least once but did not complete before\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\n        Cancelled\n    }\n\n    struct GovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Total voting power of governance NFTs.\n        uint96 totalVotingPower;\n        // Fee bps for distributions.\n        uint16 feeBps;\n        // Fee recipeint for distributions.\n        address payable feeRecipient;\n    }\n\n    // Subset of `GovernanceOpts` that are commonly read together for\n    // efficiency.\n    struct GovernanceValues {\n        uint40 voteDuration;\n        uint40 executionDelay;\n        uint16 passThresholdBps;\n        uint96 totalVotingPower;\n    }\n\n    // A snapshot of voting power for a member.\n    struct VotingPowerSnapshot {\n        // The timestamp when the snapshot was taken.\n        uint40 timestamp;\n        // Voting power that was delegated to this user by others.\n        uint96 delegatedVotingPower;\n        // The intrinsic (not delegated from someone else) voting power of this user.\n        uint96 intrinsicVotingPower;\n        // Whether the user was delegated to another at this snapshot.\n        bool isDelegated;\n    }\n\n    // Proposal details chosen by proposer.\n    struct Proposal {\n        // Time beyond which the proposal can no longer be executed.\n        // If the proposal has already been executed, and is still InProgress,\n        // this value is ignored.\n        uint40 maxExecutableTime;\n        // The minimum seconds this proposal can remain in the InProgress status\n        // before it can be cancelled.\n        uint40 cancelDelay;\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\n        // by encoded proposal args specific to the proposal type. See\n        // ProposalExecutionEngine for details.\n        bytes proposalData;\n    }\n\n    // Accounting and state tracking values for a proposal.\n    struct ProposalStateValues {\n        // When the proposal was proposed.\n        uint40 proposedTime;\n        // When the proposal passed the vote.\n        uint40 passedTime;\n        // When the proposal was first executed.\n        uint40 executedTime;\n        // When the proposal completed.\n        uint40 completedTime;\n        // Number of accept votes.\n        uint96 votes; // -1 == vetoed\n        // Number of total voting power at time proposal created.\n        uint96 totalVotingPower;\n    }\n\n    // Storage states for a proposal.\n    struct ProposalState {\n        // Accounting and state tracking values.\n        ProposalStateValues values;\n        // Hash of the proposal.\n        bytes32 hash;\n        // Whether a member has voted for (accepted) this proposal already.\n        mapping(address => bool) hasVoted;\n    }\n\n    event Proposed(uint256 proposalId, address proposer, Proposal proposal);\n    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\n\n    event ProposalPassed(uint256 indexed proposalId);\n    event ProposalVetoed(uint256 indexed proposalId, address host);\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event DistributionCreated(\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    );\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\n    event HostStatusTransferred(address oldHost, address newHost);\n    event EmergencyExecuteDisabled();\n\n    error MismatchedPreciousListLengths();\n    error BadProposalStatusError(ProposalStatus status);\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\n    error OnlyPartyHostError();\n    error OnlyActiveMemberError();\n    error InvalidDelegateError();\n    error BadPreciousListError();\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error OnlyWhenEnabledError();\n    error AlreadyVotedError(address voter);\n    error InvalidNewHostError();\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\n    error InvalidBpsError(uint16 bps);\n    error DistributionsRequireVoteError();\n    error PartyNotStartedError();\n    error CannotRageQuitAndAcceptError();\n\n    uint256 private constant UINT40_HIGH_BIT = 1 << 39;\n    uint96 private constant VETO_VALUE = type(uint96).max;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Whether the DAO has emergency powers for this party.\n    bool public emergencyExecuteDisabled;\n    /// @notice Distribution fee bps.\n    uint16 public feeBps;\n    /// @notice Distribution fee recipient.\n    address payable public feeRecipient;\n    /// @notice The timestamp of the last time `burn()` was called.\n    uint40 public lastBurnTimestamp;\n    /// @notice The hash of the list of precious NFTs guarded by the party.\n    bytes32 public preciousListHash;\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\n    uint256 public lastProposalId;\n    /// @notice Whether an address is a party host.\n    mapping(address => bool) public isHost;\n    /// @notice The last person a voter delegated its voting power to.\n    mapping(address => address) public delegationsByVoter;\n    // Governance parameters for this party.\n    GovernanceValues internal _governanceValues;\n    // ProposalState by proposal ID.\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\n    // Snapshots of voting power per user, each sorted by increasing time.\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\n\n    modifier onlyHost() {\n        if (!isHost[msg.sender]) {\n            revert OnlyPartyHostError();\n        }\n        _;\n    }\n\n    // Caller must have voting power at the current time.\n    modifier onlyActiveMember() {\n        {\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\n            // Must have either delegated voting power or intrinsic voting power.\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig can call.\n    modifier onlyPartyDao() {\n        {\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig or a party host can call.\n    modifier onlyPartyDaoOrHost() {\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\n        }\n        _;\n    }\n\n    // Only if `emergencyExecuteDisabled` is not true.\n    modifier onlyWhenEmergencyExecuteAllowed() {\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        _;\n    }\n\n    modifier onlyWhenNotGloballyDisabled() {\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\n            revert OnlyWhenEnabledError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\n    function _initialize(\n        GovernanceOpts memory govOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    ) internal virtual {\n        // Check BPS are valid.\n        if (govOpts.feeBps > 1e4) {\n            revert InvalidBpsError(govOpts.feeBps);\n        }\n        if (govOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(govOpts.passThresholdBps);\n        }\n        // Initialize the proposal execution engine.\n        _initProposalImpl(\n            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),\n            abi.encode(proposalEngineOpts)\n        );\n        // Set the governance parameters.\n        _governanceValues = GovernanceValues({\n            voteDuration: govOpts.voteDuration,\n            executionDelay: govOpts.executionDelay,\n            passThresholdBps: govOpts.passThresholdBps,\n            totalVotingPower: govOpts.totalVotingPower\n        });\n        // Set fees.\n        feeBps = govOpts.feeBps;\n        feeRecipient = govOpts.feeRecipient;\n        // Set the precious list.\n        _setPreciousList(preciousTokens, preciousTokenIds);\n        // Set the party hosts.\n        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {\n            isHost[govOpts.hosts[i]] = true;\n        }\n    }\n\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\n    ///      Initial use case is to facilitate eip-1271 signatures.\n    fallback() external {\n        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);\n    }\n\n    /// @inheritdoc EIP165\n    /// @dev Combined logic for `ERC721Receiver` and `ERC1155Receiver`.\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure virtual override(ERC721Receiver, ERC1155Receiver) returns (bool) {\n        return\n            ERC721Receiver.supportsInterface(interfaceId) ||\n            ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    /// @notice Get the current `ProposalExecutionEngine` instance.\n    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {\n        return _getSharedProposalStorage().engineImpl;\n    }\n\n    /// @notice Get the current `ProposalEngineOpts` options.\n    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {\n        return _getSharedProposalStorage().opts;\n    }\n\n    /// @notice Get the total voting power of `voter` at a `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(\n        address voter,\n        uint40 timestamp\n    ) external view returns (uint96 votingPower) {\n        return getVotingPowerAt(voter, timestamp, type(uint256).max);\n    }\n\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @param snapIndex The index of the snapshot to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(\n        address voter,\n        uint40 timestamp,\n        uint256 snapIndex\n    ) public view returns (uint96 votingPower) {\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\n    }\n\n    /// @notice Get the state of a proposal.\n    /// @param proposalId The ID of the proposal.\n    /// @return status The status of the proposal.\n    /// @return values The state of the proposal.\n    function getProposalStateInfo(\n        uint256 proposalId\n    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {\n        values = _proposalStateByProposalId[proposalId].values;\n        status = _getProposalStatus(values);\n    }\n\n    /// @notice Retrieve fixed governance parameters.\n    /// @return gv The governance parameters of this party.\n    function getGovernanceValues() external view returns (GovernanceValues memory gv) {\n        return _governanceValues;\n    }\n\n    /// @notice Get the hash of a proposal.\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\n    ///      consistency between calls.\n    /// @param proposal The proposal to hash.\n    /// @return proposalHash The hash of the proposal.\n    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {\n        // Hash the proposal in-place. Equivalent to:\n        // keccak256(abi.encode(\n        //   proposal.maxExecutableTime,\n        //   proposal.cancelDelay,\n        //   keccak256(proposal.proposalData)\n        // ))\n        bytes32 dataHash = keccak256(proposal.proposalData);\n        assembly {\n            // Overwrite the data field with the hash of its contents and then\n            // hash the struct.\n            let dataPos := add(proposal, 0x40)\n            let t := mload(dataPos)\n            mstore(dataPos, dataHash)\n            proposalHash := keccak256(proposal, 0x60)\n            // Restore the data field.\n            mstore(dataPos, t)\n        }\n    }\n\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the snapshot index at.\n    /// @return index The index of the snapshot.\n    function findVotingPowerSnapshotIndex(\n        address voter,\n        uint40 timestamp\n    ) public view returns (uint256 index) {\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\n\n        // Derived from Open Zeppelin binary search\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\n        uint256 high = snaps.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = (low + high) / 2;\n            if (snaps[mid].timestamp > timestamp) {\n                // Entry is too recent.\n                high = mid;\n            } else {\n                // Entry is older. This is our best guess for now.\n                low = mid + 1;\n            }\n        }\n\n        // Return `type(uint256).max` if no valid voting snapshots found.\n        return high == 0 ? type(uint256).max : high - 1;\n    }\n\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\n    ///         the old one (if any).\n    /// @param delegate The address to delegating voting power to.\n    function delegateVotingPower(address delegate) external onlyDelegateCall {\n        _adjustVotingPower(msg.sender, 0, delegate);\n        emit VotingPowerDelegated(msg.sender, delegate);\n    }\n\n    /// @notice Transfer party host status to another.\n    /// @param newPartyHost The address of the new host.\n    function abdicateHost(address newPartyHost) external onlyHost onlyDelegateCall {\n        // 0 is a special case burn address.\n        if (newPartyHost != address(0)) {\n            // Cannot transfer host status to an existing host.\n            if (isHost[newPartyHost]) {\n                revert InvalidNewHostError();\n            }\n            isHost[newPartyHost] = true;\n        }\n        isHost[msg.sender] = false;\n        emit HostStatusTransferred(msg.sender, newPartyHost);\n    }\n\n    /// @notice Create a token distribution by moving the party's entire balance\n    ///         to the `TokenDistributor` contract and immediately creating a\n    ///         distribution governed by this party.\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\n    ///      propagated to the distribution. Party members are entitled to a\n    ///      share of the distribution's tokens proportionate to their relative\n    ///      voting power in this party (less the fee).\n    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.\n    /// @param tokenType The type of token to distribute.\n    /// @param token The address of the token to distribute.\n    /// @param tokenId The ID of the token to distribute. Currently unused but\n    ///                may be used in the future to support other distribution types.\n    /// @return distInfo The information about the created distribution.\n    function distribute(\n        uint256 amount,\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    )\n        external\n        onlyWhenNotGloballyDisabled\n        onlyDelegateCall\n        returns (ITokenDistributor.DistributionInfo memory distInfo)\n    {\n        // Ignore if the party is calling functions on itself, like with\n        // `FractionalizeProposal` and `DistributionProposal`.\n        if (msg.sender != address(this)) {\n            // Must not require a vote to create a distribution, otherwise\n            // distributions can only be created through a distribution\n            // proposal.\n            if (_getSharedProposalStorage().opts.distributionsRequireVote) {\n                revert DistributionsRequireVoteError();\n            }\n            // Must be an active member.\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        // Prevent creating a distribution if the party has not started.\n        if (_governanceValues.totalVotingPower == 0) {\n            revert PartyNotStartedError();\n        }\n        // Get the address of the token distributor.\n        ITokenDistributor distributor = ITokenDistributor(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)\n        );\n        emit DistributionCreated(tokenType, token, tokenId);\n        // Create a native token distribution.\n        address payable feeRecipient_ = feeRecipient;\n        uint16 feeBps_ = feeBps;\n        if (tokenType == ITokenDistributor.TokenType.Native) {\n            return\n                distributor.createNativeDistribution{ value: amount }(this, feeRecipient_, feeBps_);\n        }\n        // Otherwise must be an ERC20 token distribution.\n        assert(tokenType == ITokenDistributor.TokenType.Erc20);\n        IERC20(token).compatTransfer(address(distributor), amount);\n        return distributor.createErc20Distribution(IERC20(token), this, feeRecipient_, feeBps_);\n    }\n\n    /// @notice Make a proposal for members to vote on and cast a vote to accept it\n    ///         as well.\n    /// @dev Only an active member (has voting power) can call this.\n    ///      Afterwards, members can vote to support it with `accept()` or a party\n    ///      host can unilaterally reject the proposal with `veto()`.\n    /// @param proposal The details of the proposal.\n    /// @param latestSnapIndex The index of the caller's most recent voting power\n    ///                        snapshot before the proposal was created. Should\n    ///                        be retrieved off-chain and passed in.\n    function propose(\n        Proposal memory proposal,\n        uint256 latestSnapIndex\n    ) external onlyActiveMember onlyDelegateCall returns (uint256 proposalId) {\n        proposalId = ++lastProposalId;\n        // Store the time the proposal was created and the proposal hash.\n        (\n            _proposalStateByProposalId[proposalId].values,\n            _proposalStateByProposalId[proposalId].hash\n        ) = (\n            ProposalStateValues({\n                proposedTime: uint40(block.timestamp),\n                passedTime: 0,\n                executedTime: 0,\n                completedTime: 0,\n                votes: 0,\n                totalVotingPower: _governanceValues.totalVotingPower\n            }),\n            getProposalHash(proposal)\n        );\n        emit Proposed(proposalId, msg.sender, proposal);\n        accept(proposalId, latestSnapIndex);\n    }\n\n    /// @notice Vote to support a proposed proposal.\n    /// @dev The voting power cast will be the effective voting power of the caller\n    ///      just before `propose()` was called (see `getVotingPowerAt()`).\n    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the\n    ///      proposal will be in the `Passed` state and will be executable after\n    ///      the `executionDelay` has passed, putting it in the `Ready` state.\n    /// @param proposalId The ID of the proposal to accept.\n    /// @param snapIndex The index of the caller's last voting power snapshot\n    ///                  before the proposal was created. Should be retrieved\n    ///                  off-chain and passed in.\n    /// @return totalVotes The total votes cast on the proposal.\n    function accept(\n        uint256 proposalId,\n        uint256 snapIndex\n    ) public onlyDelegateCall returns (uint256 totalVotes) {\n        // Get the information about the proposal.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        // Can only vote in certain proposal statuses.\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Allow voting even if the proposal is passed/ready so it can\n            // potentially reach 100% consensus, which unlocks special\n            // behaviors for certain proposal types.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // Prevent voting in the same block as the last burn timestamp.\n        // This is to prevent an exploit where a member can burn their card to\n        // reduce the total voting power of the party, then propose and vote in\n        // the same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.\n        // This would allow them to use the voting power snapshot just before\n        // their card was burned to vote, potentially passing a proposal that\n        // would have otherwise not passed.\n        if (lastBurnTimestamp == block.timestamp) {\n            revert CannotRageQuitAndAcceptError();\n        }\n\n        // Cannot vote twice.\n        if (info.hasVoted[msg.sender]) {\n            revert AlreadyVotedError(msg.sender);\n        }\n        // Mark the caller as having voted.\n        info.hasVoted[msg.sender] = true;\n\n        // Increase the total votes that have been cast on this proposal.\n        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\n        values.votes += votingPower;\n        info.values = values;\n        emit ProposalAccepted(proposalId, msg.sender, votingPower);\n\n        // Update the proposal status if it has reached the pass threshold.\n        if (\n            values.passedTime == 0 &&\n            _areVotesPassing(\n                values.votes,\n                values.totalVotingPower,\n                _governanceValues.passThresholdBps\n            )\n        ) {\n            info.values.passedTime = uint40(block.timestamp);\n            emit ProposalPassed(proposalId);\n        }\n        return values.votes;\n    }\n\n    /// @notice As a party host, veto a proposal, unilaterally rejecting it.\n    /// @dev The proposal will never be executable and cannot be voted on anymore.\n    ///      A proposal that has been already executed at least once (in the `InProgress` status)\n    ///      cannot be vetoed.\n    /// @param proposalId The ID of the proposal to veto.\n    function veto(uint256 proposalId) external onlyHost onlyDelegateCall {\n        // Setting `votes` to -1 indicates a veto.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Proposal must be in one of the following states.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // -1 indicates veto.\n        info.values.votes = VETO_VALUE;\n        emit ProposalVetoed(proposalId, msg.sender);\n    }\n\n    /// @notice Executes a proposal that has passed governance.\n    /// @dev The proposal must be in the `Ready` or `InProgress` status.\n    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`\n    ///      if the proposal has extra steps (must be executed again) to carry out,\n    ///      in which case `nextProgressData` should be passed into the next `execute()` call.\n    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal\n    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`\n    ///      in order to execute a different proposal.\n    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.\n    /// @param proposalId The ID of the proposal to execute.\n    /// @param proposal The details of the proposal.\n    /// @param preciousTokens The tokens that the party considers precious.\n    /// @param preciousTokenIds The token IDs associated with each precious token.\n    /// @param progressData The data returned from the last `execute()` call, if any.\n    /// @param extraData Off-chain data a proposal might need to execute a step.\n    function execute(\n        uint256 proposalId,\n        Proposal memory proposal,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bytes calldata progressData,\n        bytes calldata extraData\n    ) external payable onlyActiveMember onlyWhenNotGloballyDisabled onlyDelegateCall {\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        ProposalStatus status = _getProposalStatus(values);\n        // The proposal must be executable or have already been executed but still\n        // has more steps to go.\n        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {\n            revert BadProposalStatusError(status);\n        }\n        if (status == ProposalStatus.Ready) {\n            // If the proposal has not been executed yet, make sure it hasn't\n            // expired. Note that proposals that have been executed\n            // (but still have more steps) ignore `maxExecutableTime`.\n            if (proposal.maxExecutableTime < block.timestamp) {\n                revert ExecutionTimeExceededError(\n                    proposal.maxExecutableTime,\n                    uint40(block.timestamp)\n                );\n            }\n            proposalState.values.executedTime = uint40(block.timestamp);\n        }\n        // Check that the precious list is valid.\n        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {\n            revert BadPreciousListError();\n        }\n        // Preemptively set the proposal to completed to avoid it being executed\n        // again in a deeper call.\n        proposalState.values.completedTime = uint40(block.timestamp);\n        // Execute the proposal.\n        bool completed = _executeProposal(\n            proposalId,\n            proposal,\n            preciousTokens,\n            preciousTokenIds,\n            _getProposalFlags(values),\n            progressData,\n            extraData\n        );\n        if (!completed) {\n            // Proposal did not complete.\n            proposalState.values.completedTime = 0;\n        }\n    }\n\n    /// @notice Cancel a (probably stuck) InProgress proposal.\n    /// @dev `proposal.cancelDelay` seconds must have passed since it was first\n    ///      executed for this to be valid. The currently active proposal will\n    ///      simply be yeeted out of existence so another proposal can execute.\n    ///      This is intended to be a last resort and can leave the party in a\n    ///      broken state. Whenever possible, active proposals should be\n    ///      allowed to complete their lifecycle.\n    /// @param proposalId The ID of the proposal to cancel.\n    /// @param proposal The details of the proposal to cancel.\n    function cancel(\n        uint256 proposalId,\n        Proposal calldata proposal\n    ) external onlyActiveMember onlyDelegateCall {\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        {\n            // Must be `InProgress`.\n            ProposalStatus status = _getProposalStatus(values);\n            if (status != ProposalStatus.InProgress) {\n                revert BadProposalStatusError(status);\n            }\n        }\n        {\n            // Limit the `cancelDelay` to the global max and min cancel delay\n            // to mitigate parties accidentally getting"
    }
  ]
}