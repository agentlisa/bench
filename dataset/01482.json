{
  "Title": "M-1: `_unwrap` in `MultiInvoker.sol` can revert every time in some cases which will make the users not being able to `_liquidate` or `_withdraw` with `warp` to true",
  "Content": "# Issue M-1: `_unwrap` in `MultiInvoker.sol` can revert every time in some cases which will make the users not being able to `_liquidate` or `_withdraw` with `warp` to true \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/22 \n\n## Found by \nVagner\n`_withdraw` makes some wrong assumptions which could lead to reverts all the time if `DSU` protocol will be in debt.\n## Vulnerability Detail\nThe function `_withdraw` is called in `_liquidate`, `_vaultUpdate` and  `_update`, and if the `wrap` is set to true, which will be all the time in the case of `_liquidate`, it will try to call `_unwrap` https://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L262\nAfter that `_unwrap` will check if the address of `batcher` is 0, which can be the case if it is not set up in the constructor, or if the `balanceOf`  USDC of `batcher` is less than the amount intended to withdraw \nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L287\nand if any of that will be true it will try to call the `redeem` function on `reserve` with the intended amount \nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L288\nand then transfers the `amount` to the `receiver`\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L289\nThe problem relies in the fact that the protocol assumes that the `amount` that is used in `redeem` function will always be equal to the `amount` of USDC returned, which is not the case.\nAs can be seen in the code of the `reserve` here the `redeemAmount` is a calculation that depends on the `redeemPrice` which depends on the debt of the protocol \nhttps://github.com/emptysetsquad/emptyset/blob/c5d876fbd8ff1fac988898b77ef5461971f9fdd2/protocol/contracts/src/reserve/ReserveComptroller.sol#L125\nThe whole calculation of `redeemPrice` is done depending of the `reserveRatio` of the Protocol \nhttps://github.com/emptysetsquad/emptyset/blob/c5d876fbd8ff1fac988898b77ef5461971f9fdd2/protocol/contracts/src/reserve/ReserveComptroller.sol#L81-L84\n so in the case where DSU will make some bad decisions and it will be in debt the `redeemAmount` calculated will be less than the actual amount inserted into `redeem` function, and that `redeemAmount` will be the one actual transferred to the `MultiInvoker.sol`\nhttps://github.com/emptysetsquad/emptyset/blob/c5d876fbd8ff1fac988898b77ef5461971f9fdd2/protocol/contracts/src/reserve/ReserveComptroller.sol#L130\nSo when `_unwrap` will try to transfers the same amount of USDC \nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L289\nthe transaction would revert because the contract would not have enough USDC in the contract, making `_vaultUpdate`, `_update` with `warp` to true on `_withdraw` reverting all the time and `_liquidate` reverting 100% of the time. Since the protocol stated that they want to be aware of any issue that might arise with the integration of DSU\n![image](https://github.com/sherlock-audit/2023-07-perennial-VagnerAndrei26/assets/111457602/e177a5ee-082c-472c-9ace-d623d0f22887)\nI decided to specify this issue which could happen can cause a lot of damage to the users.\n## Impact\nImpact is a high one since it will cause the liquidation process to fail and also withdrawing funds to fail.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L285-L289\n## Tool used\n\nManual Review\n\n## Recommendation\nSince the contract doesn't store any USDC, you could transfer the whole balance of the contract every time after you call `redeem` or do balance before and balance after, and transfer the difference. It is important to take special care when you implement other protocols since any failures will also break your protocol.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n3 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> l\n\n**n33k** commented:\n> low\n\n**panprog** commented:\n> medium because the situation is very unlikely\n\n\n\n**VagnerAndrei26**\n\nEscalate : \nI believe this issue to be valid and at least a valid medium under the considerations of Sherlock rules which states \n![image](https://github.com/sherlock-audit/2023-07-perennial-judging/assets/111457602/a587a728-aeee-4713-947a-574a0aa024b8)\nsince the external protocol the Perennial team is working, DSU,  is not controlled by the them and since they specified in the ReadMe that they want to know any issues that might arise because of DSU integration, \n![image](https://github.com/sherlock-audit/2023-07-perennial-judging/assets/111457602/78fde759-cde2-4ca5-ab76-9f8c561ebb55)\nwhich I provided in the report. The way the code is written right now might arise problems in case where DSU fails/ becomes insolvent and it can be solved pretty easily in the solution I provided, so considering all of this, this issue should be evaluated at least as a Medium since the impact is a high one, by blocking the whole liquidation process and withdrawing with wrap, and probability of happening can be low.\n\n**sherlock-admin2**\n\n > Escalate : \n> I believe this issue to be valid and at least a valid medium under the considerations of Sherlock rules which states \n> ![image](https://github.com/sherlock-audit/2023-07-perennial-judging/assets/111457602/a587a728-aeee-4713-947a-574a0aa024b8)\n> since the external protocol the Perennial team is working, DSU,  is not controlled by the them and since they specified in the ReadMe that they want to know any issues that might arise because of DSU integration, \n> ![image](https://github.com/sherlock-audit/2023-07-perennial-judging/assets/111457602/78fde759-cde2-4ca5-ab76-9f8c561ebb55)\n> which I provided in the report. The way the code is written right now might arise problems in case where DSU fails/ becomes insolvent and it can be solved pretty easily in the solution I provided, so considering all of this, this issue should be evaluated at least as a Medium since the impact is a high one, by blocking the whole liquidation process and withdrawing with wrap, and probability of happening can be low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**141345**\n\nThe condition is \n> if it is not set up in the constructor, or if the balanceOf USDC of batcher is less than the amount intended to withdraw\n\nBut at first place, USDC is wrapped into DSU by batcher.\n```solidity\nFile: perennial-v2\\packages\\perennial-extensions\\contracts\\MultiInvoker.sol\n271:     function _wrap(address receiver, UFixed18 amount) internal {\n\n277:             // Wrap the USDC into DSU and return to the receiver\n278:             batcher.wrap(amount, receiver);\n```\n\nSo the USDC in batcher is expected to be fully backed.\n\nHence low/info severity is more appropriate.\n\n**VagnerAndrei26**\n\n> The condition is\n> \n> > if it is not set up in the constructor, or if the balanceOf USDC of batcher is less than the amount intended to withdraw\n> \n> But at first place, USDC is wrapped into DSU by batcher.\n> \n> ```solidity\n> File: perennial-v2\\packages\\perennial-extensions\\contracts\\MultiInvoker.sol\n> 271:     function _wrap(address receiver, UFixed18 amount) internal {\n> \n> 277:             // Wrap the USDC into DSU and return to the receiver\n> 278:             batcher.wrap(amount, receiver);\n> ```\n> \n> So the USDC in batcher is expected to be fully backed.\n> \n> Hence low/info severity is more appropriate.\n\nYes that is true, but that is not the issue that I'm talking about here, I'm not saying that there will not be enough funds in the batcher to be paid back. The issue that I've talked here is the fact that DSU protocol can borrow DSU, which will increase the debt of the protocol, as can be seen here \nhttps://github.com/emptysetsquad/emptyset/blob/c5d876fbd8ff1fac988898b77ef5461971f9fdd2/protocol/contracts/src/reserve/ReserveComptroller.sol#L143-L150\nin that case, when the `redeem` will be called and the redeem amount is calculated `redeemPrice` which is used in the calculation can be less than one \nhttps://github.com/emptysetsquad/emptyset/blob/c5d876fbd8ff1fac988898b77ef5461971f9fdd2/protocol/contracts/src/reserve/ReserveComptroller.sol#L93-L95\n, since the DSU protocol is in debt and redeeming will not be done 1-1, less USDC will be transferred to the `MultiInvoker.sol` than the `amount` specified in redeem. Because of that trying to push exactly the specific `amount` used in redeem, will fail and revert, because the contract will not have enough funds. That's why I specified that transferring the whole `balanceOf(address(this))` would solve this issue of blocking liquidation and withdrawing, since the contract doesn't hold any funds and just act as a middle man. So this is a risk associated with the DSU integration that can mess important functionalities of Perennial and also block funds.\n\n**141345**\n\nSorry I misunderstood the report.\n\nThe DSU reserve has borrow function result in debt, and the redeem amount will not be enough. Or we can say it is when DSU depeg from USDC.\n\nSeems an edge case issue.\n\n**VagnerAndrei26**\n\n> Sorry I misunderstood the report.\n> \n> The DSU reserve has borrow function result in debt, and the redeem amount will not be enough. Or we can say it is when DSU depeg from USDC.\n> \n> Seems an edge case issue.\n\nYep, it is an edge case, that's why in my escalation I specify that should be treated at least as a medium, since the damage exist and can be quite high and as for probability, it depends a lot on how DSU maintain their balance sheets, since the function can be called anytime by the owners, and since it was specify that Perennial team wants to know integration issue that could occur with DSU, it is in their advantage to protect their protocol against this case.\n\n**hrishibhat**\n\n@arjun-io \n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this issue a valid medium given the edge case\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [VagnerAndrei26](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/22/#issuecomment-1695623816): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { IPythOracle } from \"@equilibria/perennial-v2-oracle/contracts/interfaces/IPythOracle.sol\";\nimport { IVault } from \"@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol\";\nimport \"./interfaces/IMultiInvoker.sol\";\nimport \"./types/TriggerOrder.sol\";\nimport \"@equilibria/root/attribute/Kept.sol\";\n\n\n/// @title MultiInvoker\n/// @notice Extension to handle batched calls to the Perennial protocol\ncontract MultiInvoker is IMultiInvoker, Kept {\n    /// @dev Gas buffer estimating remaining execution gas to include in fee to cover further instructions\n    uint256 public constant GAS_BUFFER = 100000; // solhint-disable-line var-name-mixedcase\n\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Protocol factory to validate market approvals\n    IFactory public immutable marketFactory;\n\n    /// @dev Vault factory to validate vault approvals\n    IFactory public immutable vaultFactory;\n\n    /// @dev Batcher address\n    IBatcher public immutable batcher;\n\n    /// @dev Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev multiplier to charge accounts on top of gas cost for keeper executions\n    UFixed6 public immutable keeperMultiplier;\n\n    /// @dev UID for an order\n    uint256 public latestNonce;\n\n    /// @dev State for the order data\n    mapping(address => mapping(IMarket => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @notice Constructs the MultiInvoker contract\n    /// @param usdc_ USDC stablecoin address\n    /// @param dsu_ DSU address\n    /// @param marketFactory_ Protocol factory to validate market approvals\n    /// @param vaultFactory_ Protocol factory to validate vault approvals\n    /// @param batcher_ Batcher address\n    /// @param reserve_ Reserve address\n    /// @param keeperMultiplier_ multiplier to charge accounts on top of gas cost for keeper executions\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        UFixed6 keeperMultiplier_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        marketFactory = marketFactory_;\n        vaultFactory = vaultFactory_;\n        batcher = batcher_;\n        reserve = reserve_;\n        keeperMultiplier = keeperMultiplier_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle address\n    function initialize(AggregatorV3Interface ethOracle_) external initializer(1) {\n        __UKept__initialize(ethOracle_, DSU);\n\n        if (address(batcher) != address(0)) {\n            DSU.approve(address(batcher));\n            USDC.approve(address(batcher));\n        }\n\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @notice View function to get order state\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    function orders(address account, IMarket market, uint256 nonce) public view returns (TriggerOrder memory) {\n        return _orders[account][market][nonce].read();\n    }\n\n    /// @notice Returns whether an order can be executed\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    /// @return canFill Whether the order can be executed\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n        return order.fillable(_getMarketPrice(market, account));\n    }\n\n    /// @notice entry to perform invocations\n    /// @param invocations List of actions to execute in order\n    function invoke(Invocation[] calldata invocations) external payable {\n        for(uint i = 0; i < invocations.length; ++i) {\n            Invocation memory invocation = invocations[i];\n\n            if (invocation.action == PerennialAction.UPDATE_POSITION) {\n                (\n                    IMarket market,\n                    UFixed6 newMaker,\n                    UFixed6 newLong,\n                    UFixed6 newShort,\n                    Fixed6 collateral,\n                    bool wrap\n                ) = abi.decode(invocation.args, (IMarket, UFixed6, UFixed6, UFixed6, Fixed6, bool));\n\n                _update(market, newMaker, newLong, newShort, collateral, wrap);\n            } else if (invocation.action == PerennialAction.UPDATE_VAULT) {\n                (IVault vault, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets, bool wrap)\n                    = abi.decode(invocation.args, (IVault, UFixed6, UFixed6, UFixed6, bool));\n\n                _vaultUpdate(vault, depositAssets, redeemShares, claimAssets, wrap);\n            } else if (invocation.action == PerennialAction.PLACE_ORDER) {\n                (IMarket market, TriggerOrder memory order) = abi.decode(invocation.args, (IMarket, TriggerOrder));\n\n                _placeOrder(msg.sender, market, order);\n            } else if (invocation.action == PerennialAction.CANCEL_ORDER) {\n                (IMarket market, uint256 nonce) = abi.decode(invocation.args, (IMarket, uint256));\n\n                _cancelOrder(msg.sender, market, nonce);\n            } else if (invocation.action == PerennialAction.EXEC_ORDER) {\n                (address account, IMarket market, uint256 nonce) =\n                    abi.decode(invocation.args, (address, IMarket, uint256));\n\n                _executeOrder(account, market, nonce);\n            } else if (invocation.action == PerennialAction.COMMIT_PRICE) {\n                (address oracleProvider, uint256 version, bytes memory data) =\n                    abi.decode(invocation.args, (address, uint256, bytes));\n\n                _commitPrice(oracleProvider, version, data);\n            } else if (invocation.action == PerennialAction.LIQUIDATE) {\n                (IMarket market, address account) = abi.decode(invocation.args, (IMarket, address));\n\n                _liquidate(IMarket(market), account);\n            } else if (invocation.action == PerennialAction.APPROVE) {\n                (address target) = abi.decode(invocation.args, (address));\n\n                _approve(target);\n            } else if (invocation.action == PerennialAction.CHARGE_FEE) {\n                (address to, UFixed6 amount) = abi.decode(invocation.args, (address, UFixed6));\n\n                USDC.pullTo(msg.sender, to, amount);\n            }\n        }\n    }\n\n    /// @notice Updates market on behalf of msg.sender\n    /// @param market Address of market up update\n    /// @param newMaker New maker position for msg.sender in `market`\n    /// @param newLong New long position for msg.sender in `market`\n    /// @param newShort New short position for msg.sender in `market`\n    /// @param collateral Net change in collateral for msg.sender in `market`\n    function _update(\n        IMarket market,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool wrap\n    ) internal {\n        // collateral is transferred from this address to the market, transfer from msg.sender to here\n        if (collateral.sign() == 1) _deposit(collateral.abs(), wrap);\n\n        market.update(msg.sender, newMaker, newLong, newShort, collateral, false);\n\n        // collateral is transferred from the market to this address, transfer to msg.sender from here\n        if (collateral.sign() == -1) _withdraw(msg.sender, collateral.abs(), wrap);\n    }\n\n    /// @notice Update vault on behalf of msg.sender\n    /// @param vault Address of vault to update\n    /// @param depositAssets Amount of assets to deposit into vault\n    /// @param redeemShares Amount of shares to redeem from vault\n    /// @param claimAssets Amount of assets to claim from vault\n    /// @param wrap Whether to wrap assets before depositing\n    function _vaultUpdate(\n        IVault vault,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets,\n        bool wrap\n    ) internal {\n        if (!depositAssets.isZero()) {\n            _deposit(depositAssets, wrap);\n        }\n\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        vault.update(msg.sender, depositAssets, redeemShares, claimAssets);\n\n        // handle socialization, settlement fees, and magic values\n        UFixed6 claimAmount = claimAssets.isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(DSU.balanceOf().sub(balanceBefore));\n\n        if (!claimAmount.isZero()) {\n            _withdraw(msg.sender, claimAmount, wrap);\n        }\n    }\n\n    /// @notice Liquidates an account for a specific market\n    /// @param market Market to liquidate account in\n    /// @param account Address of market to liquidate\n    function _liquidate(IMarket market, address account) internal {\n        UFixed6 liquidationFee = _liquidationFee(market, account);\n\n        market.update(\n            account,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            Fixed6Lib.from(-1, liquidationFee),\n            true\n        );\n\n        _withdraw(msg.sender, liquidationFee, true);\n    }\n\n    /// @notice Helper to max approve DSU for usage in a market or vault deployed by the registered factories\n    /// @param target Market or Vault to approve\n    function _approve(address target) internal {\n        if(!marketFactory.instances(IInstance(target)) && !vaultFactory.instances(IInstance(target)))\n            revert MultiInvokerInvalidApprovalError();\n        DSU.approve(target);\n    }\n\n    /// @notice Pull DSU or wrap and deposit USDC from msg.sender to this address for market usage\n    /// @param amount Amount to transfer\n    /// @param wrap Flag to wrap USDC to DSU\n    function _deposit(UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            USDC.pull(msg.sender, amount);\n            _wrap(address(this), UFixed18Lib.from(amount));\n        } else {\n            DSU.pull(msg.sender, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Push DSU or unwrap DSU to push USDC from this address to `account`\n    /// @param account Account to push DSU or USDC to\n    /// @param amount Amount to transfer\n    /// @param wrap flag to unwrap DSU to USDC\n    function _withdraw(address account, UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            _unwrap(account, UFixed18Lib.from(amount));\n        } else {\n            DSU.push(account, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Helper function to wrap `amount` USDC from `msg.sender` into DSU using the batcher or reserve\n    /// @param receiver Address to receive the DSU\n    /// @param amount Amount of USDC to wrap\n    function _wrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or  doesn't have enough for this wrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(DSU.balanceOf(address(batcher)))) {\n            reserve.mint(amount);\n            if (receiver != address(this)) DSU.push(receiver, amount);\n        } else {\n            // Wrap the USDC into DSU and return to the receiver\n            batcher.wrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to unwrap `amount` DSU into USDC and send to `receiver`\n    /// @param receiver Address to receive the USDC\n    /// @param amount Amount of DSU to unwrap\n    function _unwrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or doesn't have enough for this unwrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(UFixed18Lib.from(USDC.balanceOf(address(batcher))))) {\n            reserve.redeem(amount);\n            if (receiver != address(this)) USDC.push(receiver, UFixed6Lib.from(amount));\n        } else {\n            // Unwrap the DSU into USDC and return to the receiver\n            batcher.unwrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to commit a price to an oracle\n    /// @param oracleProvider Address of oracle provider\n    /// @param version Version of oracle to commit to\n    /// @param data Data to commit to oracle\n    function _commitPrice(address oracleProvider, uint256 version, bytes memory data) internal {\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        IPythOracle(oracleProvider).commit{value: msg.value}(version, data);\n\n        // Return through keeper reward if any\n        DSU.push(msg.sender, DSU.balanceOf().sub(balanceBefore));\n    }\n\n    /// @notice Helper function to compute the liquidation fee for an account\n    /// @param market Market to compute liquidation fee for\n    /// @param account Account to compute liquidation fee for\n    /// @return liquidationFee Liquidation fee for the account\n    function _liquidationFee(IMarket market, address account) internal view returns (UFixed6) {\n        RiskParameter memory riskParameter = market.riskParameter();\n        (Position memory latestPosition, OracleVersion memory latestVersion) = _latest(market, account);\n\n        return latestPosition\n            .liquidationFee(latestVersion, riskParameter)\n            .min(UFixed6Lib.from(market.token().balanceOf(address(market))));\n    }\n\n    /// @notice Helper function to compute the latest position and oracle version without a settlement\n    /// @param market Market to compute latest position and oracle version for\n    /// @param account Account to compute latest position and oracle version for\n    /// @return latestPosition Latest position for the account\n    /// @return latestVersion Latest oracle version for the account\n    function _latest(\n        IMarket market,\n        address account\n    ) internal view returns (Position memory latestPosition, OracleVersion memory latestVersion) {\n        // load latest settled position and price\n        uint256 latestTimestamp = market.oracle().latest().timestamp;\n        latestPosition = market.positions(account);\n        latestVersion = OracleVersion(latestPosition.timestamp, market.global().latestPrice, true);\n\n        // scan pending position for any ready-to-be-settled positions\n        Local memory local = market.locals(account);\n        for (uint256 id = local.latestId; id <= local.currentId; id++) {\n            Position memory pendingPosition = market.pendingPositions(account, id);\n            OracleVersion memory oracleVersion = market.oracle().at(pendingPosition.timestamp);\n\n            IPayoffProvider payoff = market.payoff();\n            if (address(payoff) != address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n\n            // if versions are valid, update latest\n            if (latestTimestamp >= pendingPosition.timestamp && oracleVersion.valid) {\n                latestPosition = pendingPosition;\n                latestVersion = oracleVersion;\n            }\n        }\n    }\n\n    /**\n     * @notice executes an `account's` open order for a `market` and pays a fee to `msg.sender`\n     * @param account Account to execute order of\n     * @param market Market to execute order for\n     * @param nonce Id of open order to index\n     */\n    function _executeOrder(\n        address account,\n        IMarket market,\n        uint256 nonce\n    ) internal keep (\n        UFixed18Lib.from(keeperMultiplier),\n        GAS_BUFFER,\n        abi.encode(account, market, orders(account, market, nonce).fee)\n    ) {\n        if (!canExecuteOrder(account, market, nonce)) revert MultiInvokerCantExecuteError();\n\n        Position memory currentPosition = market.pendingPositions(account, market.locals(account).currentId);\n        orders(account, market, nonce).execute(currentPosition);\n\n        market.update(\n            account,\n            currentPosition.maker,\n            currentPosition.long,\n            currentPosition.short,\n            Fixed6Lib.ZERO,\n            false\n        );\n\n        delete _orders[account][market][nonce];\n        emit OrderExecuted(account, market, nonce, market.locals(account).currentId);\n    }\n\n    /// @notice Helper function to raise keeper fee\n    /// @param keeperFee Keeper fee to raise\n    /// @param data Data to raise keeper fee with\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory data) internal override {\n        (address account, address market, UFixed6 fee) = abi.decode(data, (address, address, UFixed6));\n        if (keeperFee.gt(UFixed18Lib.from(fee))) revert MultiInvokerMaxFeeExceededError();\n\n        IMarket(market).update(\n            account,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            UFixed6Lib.MAX,\n            Fixed6Lib.from(Fixed18Lib.from(-1, keeperFee), true),\n            false\n        );\n\n    }\n\n    /// @notice Places order on behalf of msg.sender from the invoker\n    /// @param account Account to place order for\n    /// @param market Market to place order in\n    /// @param order Order state to place\n    function _placeOrder(address account, IMarket market, TriggerOrder memory order) internal {\n        if (order.fee.isZero()) revert MultiInvokerInvalidOrderError();\n        if (order.comparison != -1 && order.comparison != 1) revert MultiInvokerInvalidOrderError();\n        if (order.side != 1 && order.side != 2) revert MultiInvokerInvalidOrderError();\n\n        _orders[account][market][++latestNonce].store(order);\n        emit OrderPlaced(account, market, latestNonce, order);\n    }\n\n    /// @notice Cancels an open order for msg.sender\n    /// @param account Account to cancel order for\n    /// @param market Market order is open in\n    /// @param nonce UID of order\n    function _cancelOrder(address account, IMarket market, uint256 nonce) internal {\n        delete _orders[account][market][nonce];\n        emit OrderCancelled(account, market, nonce);\n    }\n\n    /// @notice Helper function to get price of `market`\n    /// @param market Market to get price of\n    /// @return price 6-decimal price of market\n    function _getMarketPrice(IMarket market, address account) internal view returns (Fixed6 price) {\n        (, OracleVersion memory latestVersion) = _latest(market, account);\n        return latestVersion.price;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { IPythOracle } from \"@equilibria/perennial-v2-oracle/contracts/interfaces/IPythOracle.sol\";\nimport { IVault } from \"@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol\";\nimport \"./interfaces/IMultiInvoker.sol\";\nimport \"./types/TriggerOrder.sol\";\nimport \"@equilibria/root/attribute/Kept.sol\";\n\n\n/// @title MultiInvoker\n/// @notice Extension to handle batched calls to the Perennial protocol\ncontract MultiInvoker is IMultiInvoker, Kept {\n    /// @dev Gas buffer estimating remaining execution gas to include in fee to cover further instructions\n    uint256 public constant GAS_BUFFER = 100000; // solhint-disable-line var-name-mixedcase\n\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Protocol factory to validate market approvals\n    IFactory public immutable marketFactory;\n\n    /// @dev Vault factory to validate vault approvals\n    IFactory public immutable vaultFactory;\n\n    /// @dev Batcher address\n    IBatcher public immutable batcher;\n\n    /// @dev Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev multiplier to charge accounts on top of gas cost for keeper executions\n    UFixed6 public immutable keeperMultiplier;\n\n    /// @dev UID for an order\n    uint256 public latestNonce;\n\n    /// @dev State for the order data\n    mapping(address => mapping(IMarket => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @notice Constructs the MultiInvoker contract\n    /// @param usdc_ USDC stablecoin address\n    /// @param dsu_ DSU address\n    /// @param marketFactory_ Protocol factory to validate market approvals\n    /// @param vaultFactory_ Protocol factory to validate vault approvals\n    /// @param batcher_ Batcher address\n    /// @param reserve_ Reserve address\n    /// @param keeperMultiplier_ multiplier to charge accounts on top of gas cost for keeper executions\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        UFixed6 keeperMultiplier_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        marketFactory = marketFactory_;\n        vaultFactory = vaultFactory_;\n        batcher = batcher_;\n        reserve = reserve_;\n        keeperMultiplier = keeperMultiplier_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle address\n    function initialize(AggregatorV3Interface ethOracle_) external initializer(1) {\n        __UKept__initialize(ethOracle_, DSU);\n\n        if (address(batcher) != address(0)) {\n            DSU.approve(address(batcher));\n            USDC.approve(address(batcher));\n        }\n\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @notice View function to get order state\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    function orders(address account, IMarket market, uint256 nonce) public view returns (TriggerOrder memory) {\n        return _orders[account][market][nonce].read();\n    }\n\n    /// @notice Returns whether an order can be executed\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    /// @return canFill Whether the order can be executed\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n        return order.fillable(_getMarketPrice(market, account));\n    }\n\n    /// @notice entry to perform invocations\n    /// @param invocations List of actions to execute in order\n    function invoke(Invocation[] calldata invocations) external payable {\n        for(uint i = 0; i < invocations.length; ++i) {\n            Invocation memory invocation = invocations[i];\n\n            if (invocation.action == PerennialAction.UPDATE_POSITION) {\n                (\n                    IMarket market,\n                    UFixed6 newMaker,\n                    UFixed6 newLong,\n                    UFixed6 newShort,\n                    Fixed6 collateral,\n                    bool wrap\n                ) = abi.decode(invocation.args, (IMarket, UFixed6, UFixed6, UFixed6, Fixed6, bool));\n\n                _update(market, newMaker, newLong, newShort, collateral, wrap);\n            } else if (invocation.action == PerennialAction.UPDATE_VAULT) {\n                (IVault vault, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets, bool wrap)\n                    = abi.decode(invocation.args, (IVault, UFixed6, UFixed6, UFixed6, bool));\n\n                _vaultUpdate(vault, depositAssets, redeemShares, claimAssets, wrap);\n            } else if (invocation.action == PerennialAction.PLACE_ORDER) {\n                (IMarket market, TriggerOrder memory order) = abi.decode(invocation.args, (IMarket, TriggerOrder));\n\n                _placeOrder(msg.sender, market, order);\n            } else if (invocation.action == PerennialAction.CANCEL_ORDER) {\n                (IMarket market, uint256 nonce) = abi.decode(invocation.args, (IMarket, uint256));\n\n                _cancelOrder(msg.sender, market, nonce);\n            } else if (invocation.action == PerennialAction.EXEC_ORDER) {\n                (address account, IMarket market, uint256 nonce) =\n                    abi.decode(invocation.args, (address, IMarket, uint256));\n\n                _executeOrder(account, market, nonce);\n            } else if (invocation.action == PerennialAction.COMMIT_PRICE) {\n                (address oracleProvider, uint256 version, bytes memory data) =\n                    abi.decode(invocation.args, (address, uint256, bytes));\n\n                _commitPrice(oracleProvider, version, data);\n            } else if (invocation.action == PerennialAction.LIQUIDATE) {\n                (IMarket market, address account) = abi.decode(invocation.args, (IMarket, address));\n\n                _liquidate(IMarket(market), account);\n            } else if (invocation.action == PerennialAction.APPROVE) {\n                (address target) = abi.decode(invocation.args, (address));\n\n                _approve(target);\n            } else if (invocation.action == PerennialAction.CHARGE_FEE) {\n                (address to, UFixed6 amount) = abi.decode(invocation.args, (address, UFixed6));\n\n                USDC.pullTo(msg.sender, to, amount);\n            }\n        }\n    }\n\n    /// @notice Updates market on behalf of msg.sender\n    /// @param market Address of market up update\n    /// @param newMaker New maker position for msg.sender in `market`\n    /// @param newLong New long position for msg.sender in `market`\n    /// @param newShort New short position for msg.sender in `market`\n    /// @param collateral Net change in collateral for msg.sender in `market`\n    function _update(\n        IMarket market,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool wrap\n    ) internal {\n        // collateral is transferred from this address to the market, transfer from msg.sender to here\n        if (collateral.sign() == 1) _deposit(collateral.abs(), wrap);\n\n        market.update(msg.sender, newMaker, newLong, newShort, collateral, false);\n\n        // collateral is transferred from the market to this address, transfer to msg.sender from here\n        if (collateral.sign() == -1) _withdraw(msg.sender, collateral.abs(), wrap);\n    }\n\n    /// @notice Update vault on behalf of msg.sender\n    /// @param vault Address of vault to update\n    /// @param depositAssets Amount of assets to deposit into vault\n    /// @param redeemShares Amount of shares to redeem from vault\n    /// @param claimAssets Amount of assets to claim from vault\n    /// @param wrap Whether to wrap assets before depositing\n    function _vaultUpdate(\n        IVault vault,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets,\n        bool wrap\n    ) internal {\n        if (!depositAssets.isZero()) {\n            _deposit(depositAssets, wrap);\n        }\n\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        vault.update(msg.sender, depositAssets, redeemShares, claimAssets);\n\n        // handle socialization, settlement fees, and magic values\n        UFixed6 claimAmount = claimAssets.isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(DSU.balanceOf().sub(balanceBefore));\n\n        if (!claimAmount.isZero()) {\n            _withdraw(msg.sender, claimAmount, wrap);\n        }\n    }\n\n    /// @notice Liquidates an account for a specific market\n    /// @param market Market to liquidate account in\n    /// @param account Address of market to liquidate\n    function _liquidate(IMarket market, address account) internal {\n        UFixed6 liquidationFee = _liquidationFee(market, account);\n\n        market.update(\n            account,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            Fixed6Lib.from(-1, liquidationFee),\n            true\n        );\n\n        _withdraw(msg.sender, liquidationFee, true);\n    }\n\n    /// @notice Helper to max approve DSU for usage in a market or vault deployed by the registered factories\n    /// @param target Market or Vault to approve\n    function _approve(address target) internal {\n        if(!marketFactory.instances(IInstance(target)) && !vaultFactory.instances(IInstance(target)))\n            revert MultiInvokerInvalidApprovalError();\n        DSU.approve(target);\n    }\n\n    /// @notice Pull DSU or wrap and deposit USDC from msg.sender to this address for market usage\n    /// @param amount Amount to transfer\n    /// @param wrap Flag to wrap USDC to DSU\n    function _deposit(UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            USDC.pull(msg.sender, amount);\n            _wrap(address(this), UFixed18Lib.from(amount));\n        } else {\n            DSU.pull(msg.sender, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Push DSU or unwrap DSU to push USDC from this address to `account`\n    /// @param account Account to push DSU or USDC to\n    /// @param amount Amount to transfer\n    /// @param wrap flag to unwrap DSU to USDC\n    function _withdraw(address account, UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            _unwrap(account, UFixed18Lib.from(amount));\n        } else {\n            DSU.push(account, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Helper function to wrap `amount` USDC from `msg.sender` into DSU using the batcher or reserve\n    /// @param receiver Address to receive the DSU\n    /// @param amount Amount of USDC to wrap\n    function _wrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or  doesn't have enough for this wrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(DSU.balanceOf(address(batcher)))) {\n            reserve.mint(amount);\n            if (receiver != address(this)) DSU.push(receiver, amount);\n        } else {\n            // Wrap the USDC into DSU and return to the receiver\n            batcher.wrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to unwrap `amount` DSU into USDC and send to `receiver`\n    /// @param receiver Address to receive the USDC\n    /// @param amount Amount of DSU to unwrap\n    function _unwrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or doesn't have enough for this unwrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(UFixed18Lib.from(USDC.balanceOf(address(batcher))))) {\n            reserve.redeem(amount);\n            if (receiver != address(this)) USDC.push(receiver, UFixed6Lib.from(amount));\n        } else {\n            // Unwrap the DSU into USDC and return to the receiver\n            batcher.unwrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to commit a price to an oracle\n    /// @param oracleProvider Address of oracle provider\n    /// @param version Version of oracle to commit to\n    /// @param data Data to commit to oracle\n    function _commitPrice(address oracleProvider, uint256 version, bytes memory data) internal {\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        IPythOracle(oracleProvider).commit{value: msg.value}(version, data);\n\n        // Return through keeper reward if any\n        DSU.push(msg.sender, DSU.balanceOf().sub(balanceBefore));\n    }\n\n    /// @notice Helper function to compute the liquidation fee for an account\n    /// @param market Market to compute liquidation fee for\n    /// @param account Account to compute liquidation fee for\n    /// @return liquidationFee Liquidation fee for the account\n    function _liquidationFee(IMarket market, address account) internal view returns (UFixed6) {\n        RiskParameter memory riskParameter = market.riskParameter();\n        (Position memory latestPosition, OracleVersion memory latestVersion) = _latest(market, account);"
    }
  ]
}