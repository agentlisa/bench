{
  "Title": "[M-07] Locking rewards tokens in Staking contract when there are no stakes",
  "Content": "\n<https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/Lottery.sol#L151> \n\n<https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/staking/Staking.sol#L48>\n\n### Impact\n\nBlocking rewards assigned to stakes from the sale of lottery tickets when stakes are absent in the `Staking` contract.\n\n*So, the situation is unlikely, but it can happen.*\n\n### Proof of Concept\n\nIn order to confirm the problem, we need to prove 2 things:\n\n1.  That there may be no staked tokens -> #Total supply == 0\n2.  That the reward that will be transferred to the contract will be blocked -> #Locked tokens\n\n**Total supply == 0:**\n\nFlow 1:\n\n1.  Deploy protocol\n2.  Anyone buys tickets\n3.  Anyone calls [claimRewards()](https://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/Lottery.sol#L151) for `LotteryRewardType.STAKING`\n4.  Since no one has managed to stake the tokens yet, the reward for the first sold tickets will be transferred to the staking contract and blocked\n5.  First user stakes tokens and we can see the Staking contract will have rewards but for first user `rewardPerToken` will start from `0` and  `lastUpdateTicketId` will update to actually\n\n```solidity\nsrc/staking/Staking.sol\n\n50: if (_totalSupply == 0) { // totalSupply == 0\n51:     return rewardPerTokenStored;\n\n120: rewardPerTokenStored = currentRewardPerToken; // will set 0\n121: lastUpdateTicketId = lottery.nextTicketId(); // set actually\n```\n\n6.  Tokens before the first stake will be blocked forever\n\nFlow 2:\n\n1.  Everything is going well. The first bets are made before the sale of the first tokens\n2.  But there will moments when all the stakers withdraw their bets\n3.  Get time periods when `totalSupply == 0`\n4.  During these periods, all the rewards that will come will be blocked on the contract by analogy with the first flow.\n\n**Locked tokens**\n\n*   Tokens are blocked because `rewardPerTokenStored` is not updated when `totalSupply == 0`\n\nLet's just write a test:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./LotteryTestBase.sol\";\nimport \"../src/Lottery.sol\";\nimport \"./TestToken.sol\";\nimport \"forge-std/console2.sol\";\nimport \"../src/interfaces/ILottery.sol\";\n\ncontract StakingTest is LotteryTestBase {\n    IStaking public staking;\n    address public constant STAKER = address(69);\n\n    ILotteryToken public stakingToken;\n\n    function setUp() public override {\n        super.setUp();\n        staking = IStaking(lottery.stakingRewardRecipient());\n        stakingToken = ILotteryToken(address(lottery.nativeToken()));\n    }\n\n    function testDelayFirstStake() public {\n        console.log(\n            \"Init state totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        buySameTickets(lottery.currentDraw(), uint120(0x0F), address(0), 4);\n        lottery.claimRewards(LotteryRewardType.STAKING);\n        console.log(\n            \"After buy tickets totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        vm.prank(address(lottery));\n        stakingToken.mint(STAKER, 1e18);\n        vm.startPrank(STAKER);\n        stakingToken.approve(address(staking), 1e18);\n        staking.stake(1e18);\n        console.log(\n            \"After user stake, totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        // buy one ticket and get rewards\n        buySameTickets(lottery.currentDraw(), uint120(0x0F), address(0), 1);\n        lottery.claimRewards(LotteryRewardType.STAKING);\n        console.log(\n            \"After buy tickets, totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        staking.exit();\n        console.log(\n            \"After user exit, totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n        buySameTickets(lottery.currentDraw(), uint120(0x0F), address(0), 1);\n        lottery.claimRewards(LotteryRewardType.STAKING);\n        console.log(\n            \"After buy ticket again, totalSupply: %d, rewards: %d, rewardPerTokenStored: %d\",\n            staking.totalSupply(),\n            rewardToken.balanceOf(address(staking)),\n            staking.rewardPerTokenStored()\n        );\n    }\n}\n\n```\n\nResult:\n\n```text\nLogs:\n  Init state totalSupply: 0, rewards: 0, rewardPerTokenStored: 0\n  After buy tickets totalSupply: 0, rewards: 4000000000000000000, rewardPerTokenStored: 0\n  After user stake, totalSupply: 1000000000000000000, rewards: 4000000000000000000, rewardPerTokenStored: 0\n  After buy tickets, totalSupply: 1000000000000000000, rewards: 5000000000000000000, rewardPerTokenStored: 0\n  After user exit, totalSupply: 0, rewards: 4000000000000000000, rewardPerTokenStored: 1000000000000000000\n  After buy ticket again, totalSupply: 0, rewards: 5000000000000000000, rewardPerTokenStored: 1000000000000000000\n```\n\n### Recommended Mitigation Steps\n\nOne of:\n\n1.  Develop a flow where funds should go in case of lack of stakers\n2.  Develop a method of withdrawing blocked coins (which will not be distributed among stakers)\n\n**[cccz (judge) decreased severity to Medium](https://github.com/code-423n4/2023-03-wenwin-findings/issues/76)** \n\n**[rand0c0des (Wenwin) acknowledged](https://github.com/code-423n4/2023-03-wenwin-findings/issues/322)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-wenwin-contest",
  "Code": [
    {
      "filename": "src/Lottery.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"src/ReferralSystem.sol\";\nimport \"src/RNSourceController.sol\";\nimport \"src/staking/Staking.sol\";\nimport \"src/LotterySetup.sol\";\nimport \"src/TicketUtils.sol\";\n\n/// @dev Lottery contract\n/// It runs `selectionSize` / `selectionMax` type of lottery.\n/// User buys the ticket by selecting total of `selectionSize` numbers from [1, selectionMax] range.\n/// Ticket price is paid each time user buys a ticket.\n/// Part of the price is staking reward, which is claimable to `stakingRewardRecipient`.\n/// Part of the price is frontend reward which is claimable by frontend operators selling the ticket.\n/// All fees, as well as rewards are paid in `rewardToken`.\n/// All prizes are dynamic and dependant on the actual ticket sales.\ncontract Lottery is ILottery, Ticket, LotterySetup, ReferralSystem, RNSourceController {\n    using SafeERC20 for IERC20;\n    using TicketUtils for uint256;\n\n    uint256 private claimedStakingRewardAtTicketId;\n    mapping(address => uint256) private frontendDueTicketSales;\n    mapping(uint128 => mapping(uint120 => uint256)) private unclaimedCount;\n\n    address public immutable override stakingRewardRecipient;\n\n    uint256 public override lastDrawFinalTicketId;\n\n    bool public override drawExecutionInProgress;\n    uint128 public override currentDraw;\n\n    mapping(uint128 => uint120) public override winningTicket;\n    mapping(uint128 => mapping(uint8 => uint256)) public override winAmount;\n\n    mapping(uint128 => uint256) public override ticketsSold;\n    int256 public override currentNetProfit;\n\n    /// @dev Checks if ticket is a valid ticket, and reverts if invalid\n    /// @param ticket Ticket being checked\n    modifier requireValidTicket(uint256 ticket) {\n        if (!ticket.isValidTicket(selectionSize, selectionMax)) {\n            revert InvalidTicket();\n        }\n        _;\n    }\n\n    /// @dev Checks if we are not executing draw already.\n    modifier whenNotExecutingDraw() {\n        if (drawExecutionInProgress) {\n            revert DrawAlreadyInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks if draw is being executed right now.\n    modifier onlyWhenExecutingDraw() {\n        if (!drawExecutionInProgress) {\n            revert DrawNotInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks that ticket owner is caller of the function. Reverts if not called by ticket owner.\n    /// @param ticketId Ticket id we are checking owner for.\n    modifier onlyTicketOwner(uint256 ticketId) {\n        if (ownerOf(ticketId) != msg.sender) {\n            revert UnauthorizedClaim(ticketId, msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Constructs a new lottery contract.\n    /// @param lotterySetupParams Setup parameter for the lottery.\n    /// @param playerRewardFirstDraw Rewards for players in native token for first draw.\n    /// @param playerRewardDecreasePerDraw Decrease of rewards for players per each draw.\n    /// @param rewardsToReferrersPerDraw Percentage of native token rewards going to players.\n    /// @param maxRNFailedAttempts Maximum number of consecutive failed attempts for random number source.\n    /// @param maxRNRequestDelay Time considered as maximum delay for RN request.\n    // solhint-disable-next-line code-complexity\n    constructor(\n        LotterySetupParams memory lotterySetupParams,\n        uint256 playerRewardFirstDraw,\n        uint256 playerRewardDecreasePerDraw,\n        uint256[] memory rewardsToReferrersPerDraw,\n        uint256 maxRNFailedAttempts,\n        uint256 maxRNRequestDelay\n    )\n        Ticket()\n        LotterySetup(lotterySetupParams)\n        ReferralSystem(playerRewardFirstDraw, playerRewardDecreasePerDraw, rewardsToReferrersPerDraw)\n        RNSourceController(maxRNFailedAttempts, maxRNRequestDelay)\n    {\n        stakingRewardRecipient = address(\n            new Staking(\n            this,\n            lotterySetupParams.token,\n            nativeToken,\n            \"Staked LOT\",\n            \"stLOT\"\n            )\n        );\n\n        nativeToken.safeTransfer(msg.sender, ILotteryToken(address(nativeToken)).INITIAL_SUPPLY());\n    }\n\n    function buyTickets(\n        uint128[] calldata drawIds,\n        uint120[] calldata tickets,\n        address frontend,\n        address referrer\n    )\n        external\n        override\n        requireJackpotInitialized\n        returns (uint256[] memory ticketIds)\n    {\n        if (drawIds.length != tickets.length) {\n            revert DrawsAndTicketsLenMismatch(drawIds.length, tickets.length);\n        }\n        ticketIds = new uint256[](tickets.length);\n        for (uint256 i = 0; i < drawIds.length; ++i) {\n            ticketIds[i] = registerTicket(drawIds[i], tickets[i], frontend, referrer);\n        }\n        referralRegisterTickets(currentDraw, referrer, msg.sender, tickets.length);\n        frontendDueTicketSales[frontend] += tickets.length;\n        rewardToken.safeTransferFrom(msg.sender, address(this), ticketPrice * tickets.length);\n    }\n\n    function executeDraw() external override whenNotExecutingDraw {\n        // slither-disable-next-line timestamp\n        if (block.timestamp < drawScheduledAt(currentDraw)) {\n            revert ExecutingDrawTooEarly();\n        }\n        returnUnclaimedJackpotToThePot();\n        drawExecutionInProgress = true;\n        requestRandomNumber();\n        emit StartedExecutingDraw(currentDraw);\n    }\n\n    function unclaimedRewards(LotteryRewardType rewardType) external view override returns (uint256 rewards) {\n        uint256 dueTicketsSold = (rewardType == LotteryRewardType.FRONTEND)\n            ? frontendDueTicketSales[msg.sender]\n            : nextTicketId - claimedStakingRewardAtTicketId;\n        rewards = LotteryMath.calculateRewards(ticketPrice, dueTicketsSold, rewardType);\n    }\n\n    function claimRewards(LotteryRewardType rewardType) external override returns (uint256 claimedAmount) {\n        address beneficiary = (rewardType == LotteryRewardType.FRONTEND) ? msg.sender : stakingRewardRecipient;\n        claimedAmount = LotteryMath.calculateRewards(ticketPrice, dueTicketsSoldAndReset(beneficiary), rewardType);\n\n        emit ClaimedRewards(beneficiary, claimedAmount, rewardType);\n        rewardToken.safeTransfer(beneficiary, claimedAmount);\n    }\n\n    function claimable(uint256 ticketId) external view override returns (uint256 claimableAmount, uint8 winTier) {\n        TicketInfo memory ticketInfo = ticketsInfo[ticketId];\n        if (!ticketInfo.claimed) {\n            uint120 _winningTicket = winningTicket[ticketInfo.drawId];\n            winTier = TicketUtils.ticketWinTier(ticketInfo.combination, _winningTicket, selectionSize, selectionMax);\n            if (block.timestamp <= ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)) {\n                claimableAmount = winAmount[ticketInfo.drawId][winTier];\n            }\n        }\n    }\n\n    function claimWinningTickets(uint256[] calldata ticketIds) external override returns (uint256 claimedAmount) {\n        uint256 totalTickets = ticketIds.length;\n        for (uint256 i = 0; i < totalTickets; ++i) {\n            claimedAmount += claimWinningTicket(ticketIds[i]);\n        }\n        rewardToken.safeTransfer(msg.sender, claimedAmount);\n    }\n\n    /// @dev Registers the ticket in the system. To be called when user is buying the ticket.\n    /// @param drawId Draw identifier ticket is bought for.\n    /// @param ticket Combination packed as uint120.\n    function registerTicket(\n        uint128 drawId,\n        uint120 ticket,\n        address frontend,\n        address referrer\n    )\n        private\n        beforeTicketRegistrationDeadline(drawId)\n        requireValidTicket(ticket)\n        returns (uint256 ticketId)\n    {\n        ticketId = mint(msg.sender, drawId, ticket);\n        unclaimedCount[drawId][ticket]++;\n        ticketsSold[drawId]++;\n        emit NewTicket(currentDraw, ticketId, drawId, msg.sender, ticket, frontend, referrer);\n    }\n\n    /// @dev Finalizes the draw after getting random number from source.\n    /// Calculates the winning ticket. Splits jackpot rewards if there are matching tickets.\n    /// Stores claimable amounts for each win tier and calculates net profit.\n    /// Triggers referral system's mint for current draw to split the incentives.\n    /// @param randomNumber The number that is received from source.\n    function receiveRandomNumber(uint256 randomNumber) internal override onlyWhenExecutingDraw {\n        uint120 _winningTicket = TicketUtils.reconstructTicket(randomNumber, selectionSize, selectionMax);\n        uint128 drawFinalized = currentDraw++;\n        uint256 jackpotWinners = unclaimedCount[drawFinalized][_winningTicket];\n\n        if (jackpotWinners > 0) {\n            winAmount[drawFinalized][selectionSize] = drawRewardSize(drawFinalized, selectionSize) / jackpotWinners;\n        } else {\n            for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n                winAmount[drawFinalized][winTier] = drawRewardSize(drawFinalized, winTier);\n            }\n        }\n\n        currentNetProfit = LotteryMath.calculateNewProfit(\n            currentNetProfit,\n            ticketsSold[drawFinalized],\n            ticketPrice,\n            jackpotWinners > 0,\n            fixedReward(selectionSize),\n            expectedPayout\n        );\n        winningTicket[drawFinalized] = _winningTicket;\n        drawExecutionInProgress = false;\n\n        uint256 ticketsSoldDuringDraw = nextTicketId - lastDrawFinalTicketId;\n        lastDrawFinalTicketId = nextTicketId;\n        referralDrawFinalize(drawFinalized, ticketsSoldDuringDraw);\n\n        emit FinishedExecutingDraw(drawFinalized, randomNumber, _winningTicket);\n    }\n\n    function currentRewardSize(uint8 winTier) public view override returns (uint256 rewardSize) {\n        return drawRewardSize(currentDraw, winTier);\n    }\n\n    function drawRewardSize(uint128 drawId, uint8 winTier) private view returns (uint256 rewardSize) {\n        return LotteryMath.calculateReward(\n            currentNetProfit,\n            fixedReward(winTier),\n            fixedReward(selectionSize),\n            ticketsSold[drawId],\n            winTier == selectionSize,\n            expectedPayout\n        );\n    }\n\n    function dueTicketsSoldAndReset(address beneficiary) private returns (uint256 dueTickets) {\n        if (beneficiary == stakingRewardRecipient) {\n            dueTickets = nextTicketId - claimedStakingRewardAtTicketId;\n            claimedStakingRewardAtTicketId = nextTicketId;\n        } else {\n            dueTickets = frontendDueTicketSales[beneficiary];\n            frontendDueTicketSales[beneficiary] = 0;\n        }\n    }\n\n    function claimWinningTicket(uint256 ticketId) private onlyTicketOwner(ticketId) returns (uint256 claimedAmount) {\n        uint256 winTier;\n        (claimedAmount, winTier) = this.claimable(ticketId);\n        if (claimedAmount == 0) {\n            revert NothingToClaim(ticketId);\n        }\n\n        unclaimedCount[ticketsInfo[ticketId].drawId][ticketsInfo[ticketId].combination]--;\n        markAsClaimed(ticketId);\n        emit ClaimedTicket(msg.sender, ticketId, claimedAmount);\n    }\n\n    function returnUnclaimedJackpotToThePot() private {\n        if (currentDraw >= LotteryMath.DRAWS_PER_YEAR) {\n            uint128 drawId = currentDraw - LotteryMath.DRAWS_PER_YEAR;\n            uint256 unclaimedJackpotTickets = unclaimedCount[drawId][winningTicket[drawId]];\n            currentNetProfit += int256(unclaimedJackpotTickets * winAmount[drawId][selectionSize]);\n        }\n    }\n\n    function requireFinishedDraw(uint128 drawId) internal view override {\n        if (drawId >= currentDraw) {\n            revert DrawNotFinished(drawId);\n        }\n    }\n\n    function mintNativeTokens(address mintTo, uint256 amount) internal override {\n        ILotteryToken(address(nativeToken)).mint(mintTo, amount);\n    }\n}"
    },
    {
      "filename": "src/staking/Staking.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"src/interfaces/ILottery.sol\";\nimport \"src/LotteryMath.sol\";\nimport \"src/staking/interfaces/IStaking.sol\";\n\ncontract Staking is IStaking, ERC20 {\n    using SafeERC20 for IERC20;\n\n    ILottery public immutable override lottery;\n    IERC20 public immutable override rewardsToken;\n    IERC20 public immutable override stakingToken;\n    uint256 public override rewardPerTokenStored;\n    uint256 public override lastUpdateTicketId;\n    mapping(address => uint256) public override userRewardPerTokenPaid;\n    mapping(address => uint256) public override rewards;\n\n    constructor(\n        ILottery _lottery,\n        IERC20 _rewardsToken,\n        IERC20 _stakingToken,\n        string memory name,\n        string memory symbol\n    )\n        ERC20(name, symbol)\n    {\n        if (address(_lottery) == address(0)) {\n            revert ZeroAddressInput();\n        }\n        if (address(_rewardsToken) == address(0)) {\n            revert ZeroAddressInput();\n        }\n        if (address(_stakingToken) == address(0)) {\n            revert ZeroAddressInput();\n        }\n\n        lottery = _lottery;\n        rewardsToken = _rewardsToken;\n        stakingToken = _stakingToken;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function rewardPerToken() public view override returns (uint256 _rewardPerToken) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        uint256 ticketsSoldSinceUpdate = lottery.nextTicketId() - lastUpdateTicketId;\n        uint256 unclaimedRewards =\n            LotteryMath.calculateRewards(lottery.ticketPrice(), ticketsSoldSinceUpdate, LotteryRewardType.STAKING);\n\n        return rewardPerTokenStored + (unclaimedRewards * 1e18 / _totalSupply);\n    }\n\n    function earned(address account) public view override returns (uint256 _earned) {\n        return balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18 + rewards[account];\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount) external override {\n        // _updateReward is not needed here as it's handled by _beforeTokenTransfer\n        if (amount == 0) {\n            revert ZeroAmountInput();\n        }\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        _mint(msg.sender, amount);\n\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override {\n        // _updateReward is not needed here as it's handled by _beforeTokenTransfer\n        if (amount == 0) {\n            revert ZeroAmountInput();\n        }\n\n        _burn(msg.sender, amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public override {\n        _updateReward(msg.sender);\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            // slither-disable-next-line unused-return\n            lottery.claimRewards(LotteryRewardType.STAKING);\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external override {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256) internal override {\n        if (from != address(0)) {\n            _updateReward(from);\n        }\n\n        if (to != address(0)) {\n            _updateReward(to);\n        }\n    }\n\n    function _updateReward(address account) internal {\n        uint256 currentRewardPerToken = rewardPerToken();\n        rewardPerTokenStored = currentRewardPerToken;\n        lastUpdateTicketId = lottery.nextTicketId();\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = currentRewardPerToken;\n    }\n}"
    },
    {
      "filename": "src/Lottery.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"src/ReferralSystem.sol\";\nimport \"src/RNSourceController.sol\";\nimport \"src/staking/Staking.sol\";\nimport \"src/LotterySetup.sol\";\nimport \"src/TicketUtils.sol\";\n\n/// @dev Lottery contract\n/// It runs `selectionSize` / `selectionMax` type of lottery.\n/// User buys the ticket by selecting total of `selectionSize` numbers from [1, selectionMax] range.\n/// Ticket price is paid each time user buys a ticket.\n/// Part of the price is staking reward, which is claimable to `stakingRewardRecipient`.\n/// Part of the price is frontend reward which is claimable by frontend operators selling the ticket.\n/// All fees, as well as rewards are paid in `rewardToken`.\n/// All prizes are dynamic and dependant on the actual ticket sales.\ncontract Lottery is ILottery, Ticket, LotterySetup, ReferralSystem, RNSourceController {\n    using SafeERC20 for IERC20;\n    using TicketUtils for uint256;\n\n    uint256 private claimedStakingRewardAtTicketId;\n    mapping(address => uint256) private frontendDueTicketSales;\n    mapping(uint128 => mapping(uint120 => uint256)) private unclaimedCount;\n\n    address public immutable override stakingRewardRecipient;\n\n    uint256 public override lastDrawFinalTicketId;\n\n    bool public override drawExecutionInProgress;\n    uint128 public override currentDraw;\n\n    mapping(uint128 => uint120) public override winningTicket;\n    mapping(uint128 => mapping(uint8 => uint256)) public override winAmount;\n\n    mapping(uint128 => uint256) public override ticketsSold;\n    int256 public override currentNetProfit;\n\n    /// @dev Checks if ticket is a valid ticket, and reverts if invalid\n    /// @param ticket Ticket being checked\n    modifier requireValidTicket(uint256 ticket) {\n        if (!ticket.isValidTicket(selectionSize, selectionMax)) {\n            revert InvalidTicket();\n        }\n        _;\n    }\n\n    /// @dev Checks if we are not executing draw already.\n    modifier whenNotExecutingDraw() {\n        if (drawExecutionInProgress) {\n            revert DrawAlreadyInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks if draw is being executed right now.\n    modifier onlyWhenExecutingDraw() {\n        if (!drawExecutionInProgress) {\n            revert DrawNotInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks that ticket owner is caller of the function. Reverts if not called by ticket owner.\n    /// @param ticketId Ticket id we are checking owner for.\n    modifier onlyTicketOwner(uint256 ticketId) {\n        if (ownerOf(ticketId) != msg.sender) {\n            revert UnauthorizedClaim(ticketId, msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Constructs a new lottery contract.\n    /// @param lotterySetupParams Setup parameter for the lottery.\n    /// @param playerRewardFirstDraw Rewards for players in native token for first draw.\n    /// @param playerRewardDecreasePerDraw Decrease of rewards for players per each draw.\n    /// @param rewardsToReferrersPerDraw Percentage of native token rewards going to players.\n    /// @param maxRNFailedAttempts Maximum number of consecutive failed attempts for random number source.\n    /// @param maxRNRequestDelay Time considered as maximum delay for RN request.\n    // solhint-disable-next-line code-complexity\n    constructor(\n        LotterySetupParams memory lotterySetupParams,\n        uint256 playerRewardFirstDraw,\n        uint256 playerRewardDecreasePerDraw,\n        uint256[] memory rewardsToReferrersPerDraw,\n        uint256 maxRNFailedAttempts,\n        uint256 maxRNRequestDelay\n    )\n        Ticket()\n        LotterySetup(lotterySetupParams)\n        ReferralSystem(playerRewardFirstDraw, playerRewardDecreasePerDraw, rewardsToReferrersPerDraw)\n        RNSourceController(maxRNFailedAttempts, maxRNRequestDelay)\n    {\n        stakingRewardRecipient = address(\n            new Staking(\n            this,\n            lotterySetupParams.token,\n            nativeToken,\n            \"Staked LOT\",\n            \"stLOT\"\n            )\n        );\n\n        nativeToken.safeTransfer(msg.sender, ILotteryToken(address(nativeToken)).INITIAL_SUPPLY());\n    }\n\n    function buyTickets(\n        uint128[] calldata drawIds,\n        uint120[] calldata tickets,\n        address frontend,\n        address referrer\n    )\n        external\n        override\n        requireJackpotInitialized\n        returns (uint256[] memory ticketIds)\n    {\n        if (drawIds.length != tickets.length) {\n            revert DrawsAndTicketsLenMismatch(drawIds.length, tickets.length);\n        }\n        ticketIds = new uint256[](tickets.length);\n        for (uint256 i = 0; i < drawIds.length; ++i) {\n            ticketIds[i] = registerTicket(drawIds[i], tickets[i], frontend, referrer);\n        }\n        referralRegisterTickets(currentDraw, referrer, msg.sender, tickets.length);\n        frontendDueTicketSales[frontend] += tickets.length;\n        rewardToken.safeTransferFrom(msg.sender, address(this), ticketPrice * tickets.length);\n    }\n\n    function executeDraw() external override whenNotExecutingDraw {\n        // slither-disable-next-line timestamp\n        if (block.timestamp < drawScheduledAt(currentDraw)) {\n            revert ExecutingDrawTooEarly();\n        }\n        returnUnclaimedJackpotToThePot();\n        drawExecutionInProgress = true;\n        requestRandomNumber();\n        emit StartedExecutingDraw(currentDraw);\n    }\n\n    function unclaimedRewards(LotteryRewardType rewardType) external view override returns (uint256 rewards) {\n        uint256 dueTicketsSold = (rewardType == LotteryRewardType.FRONTEND)\n            ? frontendDueTicketSales[msg.sender]\n            : nextTicketId - claimedStakingRewardAtTicketId;\n        rewards = LotteryMath.calculateRewards(ticketPrice, dueTicketsSold, rewardType);\n    }\n\n    function claimRewards(LotteryRewardType rewardType) external override returns (uint256 claimedAmount) {\n        address beneficiary = (rewardType == LotteryRewardType.FRONTEND) ? msg.sender : stakingRewardRecipient;\n        claimedAmount = LotteryMath.calculateRewards(ticketPrice, dueTicketsSoldAndReset(beneficiary), rewardType);\n\n        emit ClaimedRewards(beneficiary, claimedAmount, rewardType);\n        rewardToken.safeTransfer(beneficiary, claimedAmount);\n    }\n\n    function claimable(uint256 ticketId) external view override returns (uint256 claimableAmount, uint8 winTier) {\n        TicketInfo memory ticketInfo = ticketsInfo[ticketId];\n        if (!ticketInfo.claimed) {\n            uint120 _winningTicket = winningTicket[ticketInfo.drawId];\n            winTier = TicketUtils.ticketWinTier(ticketInfo.combination, _winningTicket, selectionSize, selectionMax);\n            if (block.timestamp <= ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)) {\n                claimableAmount = winAmount[ticketInfo.drawId][winTier];\n            }\n        }\n    }\n\n    function claimWinningTickets(uint256[] calldata ticketIds) external override returns (uint256 claimedAmount) {\n        uint256 totalTickets = ticketIds.length;\n        for (uint256 i = 0; i < totalTickets; ++i) {\n            claimedAmount += claimWinningTicket(ticketIds[i]);\n        }\n        rewardToken.safeTransfer(msg.sender, claimedAmount);\n    }\n\n    /// @dev Registers the ticket in the system. To be called when user is buying the ticket.\n    /// @param drawId Draw identifier ticket is bought for.\n    /// @param ticket Combination packed as uint120.\n    function registerTicket(\n        uint128 drawId,\n        uint120 ticket,\n        address frontend,\n        address referrer\n    )\n        private\n        beforeTicketRegistrationDeadline(drawId)\n        requireValidTicket(ticket)\n        returns (uint256 ticketId)\n    {\n        ticketId = mint(msg.sender, drawId, ticket);\n        unclaimedCount[drawId][ticket]++;\n        ticketsSold[drawId]++;\n        emit NewTicket(currentDraw, ticketId, drawId, msg.sender, ticket, frontend, referrer);\n    }\n\n    /// @dev Finalizes the draw after getting random number from source.\n    /// Calculates the winning ticket. Splits jackpot rewards if there are matching tickets.\n    /// Stores claimable amounts for each win tier and calculates net profit.\n    /// Triggers referral system's mint for current draw to split the incentives.\n    /// @param randomNumber The number that is received from source.\n    function receiveRandomNumber(uint256 randomNumber) internal override onlyWhenExecutingDraw {\n        uint120 _winningTicket = TicketUtils.reconstructTicket(randomNumber, selectionSize, selectionMax);\n        uint128 drawFinalized = currentDraw++;\n        uint256 jackpotWinners = unclaimedCount[drawFinalized][_winningTicket];\n\n        if (jackpotWinners > 0) {\n            winAmount[drawFinalized][selectionSize] = drawRewardSize(drawFinalized, selectionSize) / jackpotWinners;\n        } else {\n            for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n                winAmount[drawFinalized][winTier] = drawRewardSize(drawFinalized, winTier);\n            }\n        }\n\n        currentNetProfit = LotteryMath.calculateNewProfit(\n            currentNetProfit,\n            ticketsSold[drawFinalized],\n            ticketPrice,\n            jackpotWinners > 0,\n            fixedReward(selectionSize),\n            expectedPayout\n        );\n        winningTicket[drawFinalized] = _winningTicket;\n        drawExecutionInProgress = false;\n\n        uint256 ticketsSoldDuringDraw = nextTicketId - lastDrawFinalTicketId;\n        lastDrawFinalTicketId = nextTicketId;\n        referralDrawFinalize(drawFinalized, ticketsSoldDuringDraw);\n\n        emit FinishedExecutingDraw(drawFinalized, randomNumber, _winningTicket);\n    }\n\n    function currentRewardSize(uint8 winTier) public view override returns (uint256 rewardSize) {\n        return drawRewardSize(currentDraw, winTier);\n    }\n\n    function drawRewardSize(uint128 drawId, uint8 winTier) private view returns (uint256 rewardSize) {\n        return LotteryMath.calculateReward(\n            currentNetProfit,\n            fixedReward(winTier),\n            fixedReward(selectionSize),\n            ticketsSold[drawId],\n            winTier == selectionSize,\n            expectedPayout\n        );\n    }\n\n    function dueTicketsSoldAndReset(address beneficiary) private returns (uint256 dueTickets) {\n        if (beneficiary == stakingRewardRecipient) {\n            dueTickets = nextTicketId - claimedStakingRewardAtTicketId;\n            claimedStakingRewardAtTicketId = nextTicketId;\n        } else {\n            dueTickets = frontendDueTicketSales[beneficiary];\n            frontendDueTicketSales[beneficiary] = 0;\n        }\n    }\n\n    function claimWinningTicket(uint256 ticketId) private onlyTicketOwner(ticketId) returns (uint256 claimedAmount) {\n        uint256 winTier;\n        (claimedAmount, winTier) = this.claimable(ticketId);\n        if (claimedAmount == 0) {\n            revert NothingToClaim(ticketId);\n        }\n\n        unclaimedCount[ticketsInfo[ticketId].drawId][ticketsInfo[ticketId].combination]--;\n        markAsClaimed(ticketId);\n        emit ClaimedTicket(msg.sender, ticketId, claimedAmount);\n    }\n\n    function returnUnclaimedJackpotToThePot() private {\n        if (currentDraw >= LotteryMath.DRAWS_PER_YEAR) {\n            uint128 drawId = currentDraw - LotteryMath.DRAWS_PER_YEAR;\n            uint256 unclaimedJackpotTickets = unclaimedCount[drawId][winningTicket[drawId]];\n            currentNetProfit += int256(unclaimedJackpotTickets * winAmount[drawId][selectionSize]);\n        }\n    }\n\n    function requireFinishedDraw(uint128 drawId) internal view override {\n        if (drawId >= currentDraw) {\n            revert DrawNotFinished(drawId);\n        }\n    }\n\n    function mintNativeTokens(address mintTo, uint256 amount) internal override {\n        ILotteryToken(address(nativeToken)).mint(mintTo, amount);\n    }\n}"
    }
  ]
}