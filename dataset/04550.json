{
  "Title": "Possible overflow in loop index variable",
  "Content": "The [`airdropTokens`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol#L117) function of the [`PolyDistribution`](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol) contract takes an array of addresses as a parameter in order to “airdrop” tokens to each of them. To do so, a `for` [loop](https://github.com/PolymathNetwork/polymath-token-distribution/blob/672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol#L120) is used, with an index variable of type `uint8`. This will result in an overflow for arrays which have more than 255 addresses. The loop will indefinitely iterate over the first 255 addresses, eventually failing with an out of gas error, wasting gas.  \n\nConsider using a `uint256` variable for the index.  \n\n***Update**: Fixed in commit [`0b47ae4`](https://github.com/PolymathNetwork/polymath-token-distribution/commit/0b47ae467f95a02c6b71421e5816b5d50b698158#diff-894d6a69e0d58851828ece9513b36f5fR119).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/PolyDistribution.sol",
      "content": "pragma solidity ^0.4.18;\n\nimport './interfaces/IERC20.sol';\nimport './PolyToken.sol';\nimport './SafeMath.sol';\nimport './Ownable.sol';\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}"
    }
  ]
}