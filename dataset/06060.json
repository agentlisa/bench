{
  "Title": "[G-09] `+=` and `-=` cost more gas",
  "Content": "`+=` and `-=` generally cost 22 more gas than writing out the assigned equation explicitly. The amount of gas wasted can be quite sizable when repeatedly operated in a loop.\n\nFor instance, the `+=` instance below may be refactored as follows:\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol#L307\n\n```diff\n-            baseSupplyIndex_ += safe64(mulFactor(baseSupplyIndex_, supplyRate * timeDelta));\n+            baseSupplyIndex_ = baseSupplyIndex_ + safe64(mulFactor(baseSupplyIndex_, supplyRate * timeDelta));\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/assets/compoundv3/CusdcV3Wrapper.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./vendor/CometInterface.sol\";\nimport \"./WrappedERC20.sol\";\nimport \"./vendor/ICometRewards.sol\";\nimport \"./ICusdcV3Wrapper.sol\";\nimport \"./CometHelpers.sol\";\n\n/**\n * @title CusdcV3Wrapper\n * @notice Wrapper for cUSDCV3 / COMET that acts as a stable-balance ERC20, instead of rebasing\n * token. {comet} will be used as the unit for the underlying token, and {wComet} will be used\n * as the unit for wrapped tokens.\n */\ncontract CusdcV3Wrapper is ICusdcV3Wrapper, WrappedERC20, CometHelpers {\n    using SafeERC20 for IERC20;\n\n    /// From cUSDCv3, used in principal <> present calculations\n    uint256 public constant TRACKING_INDEX_SCALE = 1e15;\n    /// From cUSDCv3, scaling factor for USDC rewards\n    uint64 public constant RESCALE_FACTOR = 1e12;\n\n    CometInterface public immutable underlyingComet;\n    ICometRewards public immutable rewardsAddr;\n    IERC20 public immutable rewardERC20;\n\n    mapping(address => uint64) public baseTrackingIndex;\n    mapping(address => uint64) public baseTrackingAccrued;\n    mapping(address => uint256) public rewardsClaimed;\n\n    constructor(\n        address cusdcv3,\n        address rewardsAddr_,\n        address rewardERC20_\n    ) WrappedERC20(\"Wrapped cUSDCv3\", \"wcUSDCv3\") {\n        if (cusdcv3 == address(0)) revert ZeroAddress();\n\n        rewardsAddr = ICometRewards(rewardsAddr_);\n        rewardERC20 = IERC20(rewardERC20_);\n        underlyingComet = CometInterface(cusdcv3);\n    }\n\n    /// @return number of decimals\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    /// @param amount {Comet} The amount of cUSDCv3 to deposit\n    function deposit(uint256 amount) external {\n        _deposit(msg.sender, msg.sender, msg.sender, amount);\n    }\n\n    /// @param dst The dst to deposit into\n    /// @param amount {Comet} The amount of cUSDCv3 to deposit\n    function depositTo(address dst, uint256 amount) external {\n        _deposit(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @param src The address to deposit from\n    /// @param dst The address to deposit to\n    /// @param amount {Comet} The amount of cUSDCv3 to deposit\n    function depositFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external {\n        _deposit(msg.sender, src, dst, amount);\n    }\n\n    /// Only called internally to run the deposit logic\n    /// Takes `amount` fo cUSDCv3 from `src` and deposits to `dst` account in the wrapper.\n    /// @param operator The address calling the contract (msg.sender)\n    /// @param src The address to deposit from\n    /// @param dst The address to deposit to\n    /// @param amount {Comet} The amount of cUSDCv3 to deposit\n    function _deposit(\n        address operator,\n        address src,\n        address dst,\n        uint256 amount\n    ) internal {\n        if (!hasPermission(src, operator)) revert Unauthorized();\n        // {Comet}\n        uint256 srcBal = underlyingComet.balanceOf(src);\n        if (amount > srcBal) amount = srcBal;\n        if (amount == 0) revert BadAmount();\n\n        underlyingComet.accrueAccount(address(this));\n        underlyingComet.accrueAccount(src);\n\n        CometInterface.UserBasic memory wrappedBasic = underlyingComet.userBasic(address(this));\n        int104 wrapperPrePrinc = wrappedBasic.principal;\n\n        IERC20(address(underlyingComet)).safeTransferFrom(src, address(this), amount);\n\n        wrappedBasic = underlyingComet.userBasic(address(this));\n        int104 wrapperPostPrinc = wrappedBasic.principal;\n        accrueAccountRewards(dst);\n        // safe to cast because amount is positive\n        _mint(dst, uint104(wrapperPostPrinc - wrapperPrePrinc));\n    }\n\n    /// @param amount {Comet} The amount of cUSDCv3 to withdraw\n    function withdraw(uint256 amount) external {\n        _withdraw(msg.sender, msg.sender, msg.sender, amount);\n    }\n\n    /// @param dst The address to withdraw cUSDCv3 to\n    /// @param amount {Comet} The amount of cUSDCv3 to withdraw\n    function withdrawTo(address dst, uint256 amount) external {\n        _withdraw(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @param src The address to withdraw from\n    /// @param dst The address to withdraw cUSDCv3 to\n    /// @param amount {Comet} The amount of cUSDCv3 to withdraw\n    function withdrawFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external {\n        _withdraw(msg.sender, src, dst, amount);\n    }\n\n    /// Internally called to run the withdraw logic\n    /// Withdraws `amount` cUSDCv3 from `src` account in the wrapper and sends to `dst`\n    /// @dev Rounds conservatively so as not to over-withdraw from the wrapper\n    /// @param operator The address calling the contract (msg.sender)\n    /// @param src The address to withdraw from\n    /// @param dst The address to withdraw cUSDCv3 to\n    /// @param amount {Comet} The amount of cUSDCv3 to withdraw\n    function _withdraw(\n        address operator,\n        address src,\n        address dst,\n        uint256 amount\n    ) internal {\n        if (!hasPermission(src, operator)) revert Unauthorized();\n        // {Comet}\n        uint256 srcBalUnderlying = underlyingBalanceOf(src);\n        if (srcBalUnderlying < amount) amount = srcBalUnderlying;\n        if (amount == 0) revert BadAmount();\n\n        underlyingComet.accrueAccount(address(this));\n        underlyingComet.accrueAccount(src);\n\n        uint256 srcBalPre = balanceOf(src);\n        CometInterface.UserBasic memory wrappedBasic = underlyingComet.userBasic(address(this));\n        int104 wrapperPrePrinc = wrappedBasic.principal;\n\n        // conservative rounding in favor of the wrapper\n        IERC20(address(underlyingComet)).safeTransfer(dst, (amount / 10) * 10);\n\n        wrappedBasic = underlyingComet.userBasic(address(this));\n        int104 wrapperPostPrinc = wrappedBasic.principal;\n\n        // safe to cast because principal can't go negative, wrapper is not borrowing\n        uint256 burnAmt = uint256(uint104(wrapperPrePrinc - wrapperPostPrinc));\n        // occasionally comet will withdraw 1-10 wei more than we asked for.\n        // this is ok because 9 times out of 10 we are rounding in favor of the wrapper.\n        // safe because we have already capped the comet withdraw amount to src underlying bal.\n        // untested:\n        //      difficult to trigger, depends on comet rules regarding rounding\n        if (srcBalPre <= burnAmt) burnAmt = srcBalPre;\n\n        accrueAccountRewards(src);\n        _burn(src, safe104(burnAmt));\n    }\n\n    /// Internally called to run transfer logic.\n    /// Accrues rewards for `src` and `dst` before transferring value.\n    function _beforeTokenTransfer(\n        address src,\n        address dst,\n        uint256 amount\n    ) internal virtual override {\n        underlyingComet.accrueAccount(address(this));\n\n        super._beforeTokenTransfer(src, dst, amount);\n\n        accrueAccountRewards(src);\n        accrueAccountRewards(dst);\n    }\n\n    function claimRewards() external {\n        claimTo(msg.sender, msg.sender);\n    }\n\n    /// @param src The account to claim from\n    /// @param dst The address to send claimed rewards to\n    function claimTo(address src, address dst) public {\n        address sender = msg.sender;\n        if (!hasPermission(src, sender)) revert Unauthorized();\n\n        accrueAccount(src);\n        uint256 claimed = rewardsClaimed[src];\n        uint256 accrued = baseTrackingAccrued[src] * RESCALE_FACTOR;\n        uint256 owed;\n        if (accrued > claimed) {\n            owed = accrued - claimed;\n            rewardsClaimed[src] = accrued;\n\n            rewardsAddr.claimTo(address(underlyingComet), address(this), address(this), true);\n            IERC20(rewardERC20).safeTransfer(dst, owed);\n        }\n        emit RewardsClaimed(rewardERC20, owed);\n    }\n\n    /// Accure the cUSDCv3 account of the wrapper\n    function accrue() public {\n        underlyingComet.accrueAccount(address(this));\n    }\n\n    /// @param account The address to accrue, first in cUSDCv3, then locally\n    function accrueAccount(address account) public {\n        underlyingComet.accrueAccount(address(this));\n        accrueAccountRewards(account);\n    }\n\n    /// Get the balance of cUSDCv3 that is represented by the `accounts` wrapper value.\n    /// @param account The address to calculate the cUSDCv3 balance of\n    /// @return {Comet} The cUSDCv3 balance that `account` holds in the wrapper\n    function underlyingBalanceOf(address account) public view returns (uint256) {\n        uint256 balance = balanceOf(account);\n        if (balance == 0) {\n            return 0;\n        }\n        return convertStaticToDynamic(safe104(balance));\n    }\n\n    /// @return The exchange rate {comet/wComet}\n    function exchangeRate() public view returns (uint256) {\n        (uint64 baseSupplyIndex, ) = getUpdatedSupplyIndicies();\n        return presentValueSupply(baseSupplyIndex, safe104(10**underlyingComet.decimals()));\n    }\n\n    /// @param amount The value of {wComet} to convert to {Comet}\n    /// @return {Comet} The amount of cUSDCv3 represented by `amount of {wComet}\n    function convertStaticToDynamic(uint104 amount) public view returns (uint256) {\n        (uint64 baseSupplyIndex, ) = getUpdatedSupplyIndicies();\n        return presentValueSupply(baseSupplyIndex, amount);\n    }\n\n    /// @param amount The value of {Comet} to convert to {wComet}\n    /// @return {wComet} The amount of wrapped token represented by `amount` of {Comet}\n    function convertDynamicToStatic(uint256 amount) public view returns (uint104) {\n        (uint64 baseSupplyIndex, ) = getUpdatedSupplyIndicies();\n        return principalValueSupply(baseSupplyIndex, amount);\n    }\n\n    /// @param account The address to view the owed rewards of\n    /// @return {reward} The amount of reward tokens owed to `account`\n    function getRewardOwed(address account) external view returns (uint256) {\n        (, uint64 trackingSupplyIndex) = getUpdatedSupplyIndicies();\n\n        uint256 indexDelta = uint256(trackingSupplyIndex - baseTrackingIndex[account]);\n        uint256 newBaseTrackingAccrued = baseTrackingAccrued[account] +\n            safe64((safe104(balanceOf(account)) * indexDelta) / TRACKING_INDEX_SCALE);\n\n        uint256 claimed = rewardsClaimed[account];\n        uint256 accrued = newBaseTrackingAccrued * RESCALE_FACTOR;\n        uint256 owed = accrued > claimed ? accrued - claimed : 0;\n\n        return owed;\n    }\n\n    /// Internally called to get saved indicies\n    /// @return baseSupplyIndex_ {1} The saved baseSupplyIndex\n    /// @return trackingSupplyIndex_ {1} The saved trackingSupplyIndex\n    function getSupplyIndices()\n        internal\n        view\n        returns (uint64 baseSupplyIndex_, uint64 trackingSupplyIndex_)\n    {\n        TotalsBasic memory totals = underlyingComet.totalsBasic();\n        baseSupplyIndex_ = totals.baseSupplyIndex;\n        trackingSupplyIndex_ = totals.trackingSupplyIndex;\n    }\n\n    /// Internally called to update the account indicies and accrued rewards for a given address\n    /// @param account The UserBasic struct for a target address\n    function accrueAccountRewards(address account) internal {\n        uint256 accountBal = balanceOf(account);\n        (, uint64 trackingSupplyIndex) = getSupplyIndices();\n        uint256 indexDelta = uint256(trackingSupplyIndex - baseTrackingIndex[account]);\n\n        baseTrackingAccrued[account] += safe64(\n            (safe104(accountBal) * indexDelta) / TRACKING_INDEX_SCALE\n        );\n        baseTrackingIndex[account] = trackingSupplyIndex;\n    }\n\n    /// Internally called to get the updated supply indicies\n    /// @return {1} The current baseSupplyIndex\n    /// @return {1} The current trackingSupplyIndex\n    function getUpdatedSupplyIndicies() internal view returns (uint64, uint64) {\n        TotalsBasic memory totals = underlyingComet.totalsBasic();\n        uint40 timeDelta = uint40(block.timestamp) - totals.lastAccrualTime;\n        uint64 baseSupplyIndex_ = totals.baseSupplyIndex;\n        uint64 trackingSupplyIndex_ = totals.trackingSupplyIndex;\n        if (timeDelta > 0) {\n            uint256 baseTrackingSupplySpeed = underlyingComet.baseTrackingSupplySpeed();\n            uint256 utilization = underlyingComet.getUtilization();\n            uint256 supplyRate = underlyingComet.getSupplyRate(utilization);\n            baseSupplyIndex_ += safe64(mulFactor(baseSupplyIndex_, supplyRate * timeDelta));\n            trackingSupplyIndex_ += safe64(\n                divBaseWei(baseTrackingSupplySpeed * timeDelta, totals.totalSupplyBase)\n            );\n        }\n        return (baseSupplyIndex_, trackingSupplyIndex_);\n    }\n}"
    }
  ]
}