{
  "Title": "[M-08] Inflation attack in VotiumStrategy",
  "Content": "\nThe VotiumStrategy contract is susceptible to the [Inflation Attack](https://mixbytes.io/blog/overview-of-the-inflation-attack), in which the first depositor can be front-runned by an attacker to steal their deposit.\n\n### Impact\n\nBoth AfEth and VotiumStrategy acts as vaults: accounts deposit some tokens and get back another token (share) that represents their participation in the vault.\n\nThese types of contracts are potentially vulnerable to the inflation attack: an attacker can front-run the initial deposit to the vault to inflate the value of a share and render the front-runned deposit worthless.\n\nIn AfEth, this is successfully mitigated by the slippage control. Any attack that inflates the value of a share to decrease the number of minted shares is rejected due to the validation of minimum output:\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L166-L167>\n\n```solidity\n166:         uint256 amountToMint = totalValue / priceBeforeDeposit;\n167:         if (amountToMint < _minout) revert BelowMinOut();\n```\n\nHowever, this is not the case of VotiumStrategy. In this contract, no validation is done in the number of minted tokens. This means that an attacker can execute the attack by front-running the initial deposit, which may be from AfEth or from any other account that interacts with the contract. See *Proof of Concept* for a detailed walkthrough of the issue.\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L39-L46>\n\n```solidity\n39:     function deposit() public payable override returns (uint256 mintAmount) {\n40:         uint256 priceBefore = cvxPerVotium();\n41:         uint256 cvxAmount = buyCvx(msg.value);\n42:         IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n43:         ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n44:         mintAmount = ((cvxAmount * 1e18) / priceBefore);\n45:         _mint(msg.sender, mintAmount);\n46:     }\n```\n\n### Proof of Concept\n\nLet's say a user wants to deposit in VotiumStrategy and calls `deposit()` sending an ETH amount such as it is expected to buy `X` tokens of CVX. Attacker will front-run the transaction and execute the following:\n\n1.  Initial state is empty contract, `assets = 0` and `supply = 0`.\n2.  Attacker calls deposit with an amount of ETH such as to buy `1e18` CVX tokens, this makes `assets = 1e18` and `supply = 1e18`.\n3.  Attacker calls `requestWithdraw(1e18 - 1)` so that `supply = 1`, assume also `1e18 - 1` CVX tokens are withdrawn so that `cvxUnlockObligations = 1e18 - 1`.\n4.  Attacker transfers (donates) X amount of CVX to VotiumStrategy contract.\n5.  At this point, `priceBefore = cvxPerVotium() = (totalCvx - cvxUnlockObligations) * 1e18 / supply = (X + 1e18 - (1e18 - 1)) * 1e18 / 1 = (X + 1) * 1e18`\n6.  User transaction gets through and `deposit()` buys X amount of CVX. Minted tokens will be `mintAmount = X * 1e18 / priceBefore = X * 1e18 / (X + 1) * 1e18 = X / (X + 1) = 0`.\n7.  User is then minted zero VotiumStrategy tokens.\n8.  Attacker calls `requestWithdraw()` again to queue withdrawal to remove all CVX balance from the contract, including the tokens deposited by the user.\n\n### Recommendation\n\nThere are multiple ways of solving the issue:\n\n1.  Similar to AfEth, add a minimum output check to ensure the amount of minted shares.\n2.  Track asset balances internally so an attacker cannot donate assets to inflate shares.\n3.  Mint an initial number of \"dead shares\", similar to how UniswapV2 does.\n\nA very good discussion of these can be found [here](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706).\n\n**[0xleastwood (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35#issuecomment-1746303423):**\n > Downgrading this to medium severity because the `_minOut` parameter should actually prevent this attack as long as it's non-zero, but I agree this is of concern if users do not set this parameter. This is a stated assumption.\n>\n > Upon further investigation, `AfEth.deposit()` is not vulnerable to the deposit front-running. This is only an issue if we are interacting with the votium strategy contract directly which is atypical behaviour. However, funds are still at risk even with these stated assumptions so I believe medium severity to be more correct.\n\n**[MiloTruck (Warden) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35#issuecomment-1752132516):**\n > @0xleastwood - Apologies for commenting after post-judging QA, but isn't the inflation attack still a problem even if users only interact with the `AfEth` contract?\n> \n> `AfEth.deposit()` calls VotiumStrategy's `deposit()` function, so if a user calls `AfEth.deposit()` after VotiumStrategy's state has been manipulated, `vMinted` will be 0, causing him to lose the portion of his ETH that was deposited into VotiumStrategy.\n> \n> Unless I'm missing something here...\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35#issuecomment-1752133924):**\n> @MiloTruck - Ultimately, I do believe `_minOut` to be sufficient in detecting such an attack.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35#issuecomment-1753975944)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > Track balances instead of using `balanceOf`.\n\n**Status**: Mitigation confirmed. Full details in reports from [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/41) and [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/24).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-asymmetry",
  "Code": [
    {
      "filename": "contracts/AfEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/strategies/votium/VotiumStrategy.sol\";\nimport \"contracts/external_interfaces/IVotiumStrategy.sol\";\nimport \"contracts/strategies/AbstractStrategy.sol\";\n\n// AfEth is the strategy manager for safEth and votium strategies\ncontract AfEth is Initializable, OwnableUpgradeable, ERC20Upgradeable {\n    uint256 public ratio;\n    uint256 public protocolFee;\n    address public feeAddress;\n    address public constant SAF_ETH_ADDRESS =\n        0x6732Efaf6f39926346BeF8b821a04B6361C4F3e5;\n    address public vEthAddress; // Votium Strategy Address\n    uint256 public latestWithdrawId;\n\n    struct WithdrawInfo {\n        address owner;\n        uint256 amount;\n        uint256 safEthWithdrawAmount;\n        uint256 vEthWithdrawId;\n        uint256 withdrawTime;\n    }\n\n    mapping(uint256 => WithdrawInfo) public withdrawIdInfo;\n    bool public pauseDeposit;\n    bool public pauseWithdraw;\n\n    error StrategyAlreadyAdded();\n    error StrategyNotFound();\n    error InsufficientBalance();\n    error InvalidStrategy();\n    error InvalidFee();\n    error CanNotWithdraw();\n    error NotOwner();\n    error FailedToSend();\n    error FailedToDeposit();\n    error Paused();\n    error BelowMinOut();\n\n    event WithdrawRequest(\n        address indexed account,\n        uint256 amount,\n        uint256 withdrawId,\n        uint256 withdrawTime\n    );\n\n    address private constant CVX_ADDRESS =\n        0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address private constant VLCVX_ADDRESS =\n        0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    uint256 public pendingSafEthWithdraws;\n\n    modifier onlyWithdrawIdOwner(uint256 withdrawId) {\n        if (withdrawIdInfo[withdrawId].owner != msg.sender) revert NotOwner();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n    */\n    function initialize() external initializer {\n        _transferOwnership(msg.sender);\n        ratio = 5e17;\n    }\n\n    /**\n     * @notice - Sets the strategy addresses for safEth and votium\n     * @param _vEthAddress - vEth strategy address\n     */\n    function setStrategyAddress(address _vEthAddress) external onlyOwner {\n        vEthAddress = _vEthAddress;\n    }\n\n    /**\n        @notice - Sets the target ratio of safEth to votium. \n        @notice target ratio is maintained by directing rewards into either safEth or votium strategy\n        @param _newRatio - New ratio of safEth to votium\n    */\n    function setRatio(uint256 _newRatio) public onlyOwner {\n        ratio = _newRatio;\n    }\n\n    /**\n        @notice - Sets the protocol fee address which takes a percentage of the rewards.\n        @param _newFeeAddress - New protocol fee address to collect rewards\n    */\n    function setFeeAddress(address _newFeeAddress) public onlyOwner {\n        feeAddress = _newFeeAddress;\n    }\n\n    /**\n        @notice - Sets the protocol fee which takes a percentage of the rewards.\n        @param _newFee - New protocol fee\n    */\n    function setProtocolFee(uint256 _newFee) public onlyOwner {\n        if (_newFee > 1e18) revert InvalidFee();\n        protocolFee = _newFee;\n    }\n\n    /**\n        @notice - Enables/Disables depositing\n        @param _pauseDeposit - Bool to set pauseDeposit\n\n    */\n    function setPauseDeposit(bool _pauseDeposit) external onlyOwner {\n        pauseDeposit = _pauseDeposit;\n    }\n\n    /**\n        @notice - Enables/Disables withdrawing & requesting to withdraw\n        @param _pauseWithdraw - Bool to set pauseWithdraw\n    */\n    function setPauseWithdraw(bool _pauseWithdraw) external onlyOwner {\n        pauseWithdraw = _pauseWithdraw;\n    }\n\n    /**\n        @notice - Get's the price of afEth\n        @dev - Checks each strategy and calculates the total value in ETH divided by supply of afETH tokens\n        @return - Price of afEth\n    */\n    function price() public view returns (uint256) {\n        if (totalSupply() == 0) return 1e18;\n        AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n        uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 vEthValueInEth = (vEthStrategy.price() *\n            vEthStrategy.balanceOf(address(this))) / 1e18;\n        return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n    }\n\n    /**\n        @notice - Deposits into each strategy\n        @dev - This is the entry into the protocol\n        @param _minout - Minimum amount of afEth to mint\n    */\n    function deposit(uint256 _minout) external payable virtual {\n        if (pauseDeposit) revert Paused();\n        uint256 amount = msg.value;\n        uint256 priceBeforeDeposit = price();\n        uint256 totalValue;\n\n        AbstractStrategy vStrategy = AbstractStrategy(vEthAddress);\n\n        uint256 sValue = (amount * ratio) / 1e18;\n        uint256 sMinted = sValue > 0\n            ? ISafEth(SAF_ETH_ADDRESS).stake{value: sValue}(0)\n            : 0;\n        uint256 vValue = (amount * (1e18 - ratio)) / 1e18;\n        uint256 vMinted = vValue > 0 ? vStrategy.deposit{value: vValue}() : 0;\n        totalValue +=\n            (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n            (vMinted * vStrategy.price());\n        if (totalValue == 0) revert FailedToDeposit();\n        uint256 amountToMint = totalValue / priceBeforeDeposit;\n        if (amountToMint < _minout) revert BelowMinOut();\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice - Request to close position\n        @param _amount - Amount of afEth to withdraw\n    */\n    function requestWithdraw(uint256 _amount) external virtual {\n        uint256 withdrawTimeBefore = withdrawTime(_amount);\n        if (pauseWithdraw) revert Paused();\n        latestWithdrawId++;\n\n        // ratio of afEth being withdrawn to totalSupply\n        // we are transfering the afEth to the contract when we requestWithdraw\n        // we shouldn't include that in the withdrawRatio\n        uint256 afEthBalance = balanceOf(address(this));\n        uint256 withdrawRatio = (_amount * 1e18) /\n            (totalSupply() - afEthBalance);\n\n        _transfer(msg.sender, address(this), _amount);\n\n        uint256 votiumBalance = IERC20(vEthAddress).balanceOf(address(this));\n        uint256 votiumWithdrawAmount = (withdrawRatio * votiumBalance) / 1e18;\n        uint256 vEthWithdrawId = AbstractStrategy(vEthAddress).requestWithdraw(\n            votiumWithdrawAmount\n        );\n\n        uint256 safEthBalance = safEthBalanceMinusPending();\n\n        uint256 safEthWithdrawAmount = (withdrawRatio * safEthBalance) / 1e18;\n\n        pendingSafEthWithdraws += safEthWithdrawAmount;\n\n        withdrawIdInfo[latestWithdrawId]\n            .safEthWithdrawAmount = safEthWithdrawAmount;\n        withdrawIdInfo[latestWithdrawId].vEthWithdrawId = vEthWithdrawId;\n\n        withdrawIdInfo[latestWithdrawId].owner = msg.sender;\n        withdrawIdInfo[latestWithdrawId].amount = _amount;\n        withdrawIdInfo[latestWithdrawId].withdrawTime = withdrawTimeBefore;\n\n        emit WithdrawRequest(\n            msg.sender,\n            _amount,\n            latestWithdrawId,\n            withdrawTimeBefore\n        );\n    }\n\n    /**\n        @notice - Checks if withdraw can be executed from withdrawId\n        @param _withdrawId - Id of the withdraw request for SafEth\n        @return - Bool if withdraw can be executed\n    */\n    function canWithdraw(uint256 _withdrawId) public view returns (bool) {\n        return\n            AbstractStrategy(vEthAddress).canWithdraw(\n                withdrawIdInfo[_withdrawId].vEthWithdrawId\n            );\n    }\n\n    /**\n        @notice - Get's the withdraw time for an amount of AfEth\n        @param _amount - Amount of afETH to withdraw\n        @return - Highest withdraw time of the strategies\n    */\n    function withdrawTime(uint256 _amount) public view returns (uint256) {\n        return AbstractStrategy(vEthAddress).withdrawTime(_amount);\n    }\n\n    /**\n        @notice - Withdraw from each strategy\n        @param _withdrawId - Id of the withdraw request\n        @param _minout - Minimum amount of ETH to receive\n    */\n    function withdraw(\n        uint256 _withdrawId,\n        uint256 _minout\n    ) external virtual onlyWithdrawIdOwner(_withdrawId) {\n        if (pauseWithdraw) revert Paused();\n        uint256 ethBalanceBefore = address(this).balance;\n        WithdrawInfo memory withdrawInfo = withdrawIdInfo[_withdrawId];\n        if (!canWithdraw(_withdrawId)) revert CanNotWithdraw();\n\n        ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n        AbstractStrategy(vEthAddress).withdraw(withdrawInfo.vEthWithdrawId);\n\n        _burn(address(this), withdrawIdInfo[_withdrawId].amount);\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        pendingSafEthWithdraws -= withdrawInfo.safEthWithdrawAmount;\n\n        if (ethReceived < _minout) revert BelowMinOut();\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice - sells _amount of eth from votium contract\n     * @dev - puts it into safEthStrategy or votiumStrategy, whichever is underweight.\\\n     * @param _amount - amount of eth to sell\n     */\n    function depositRewards(uint256 _amount) public payable {\n        IVotiumStrategy votiumStrategy = IVotiumStrategy(vEthAddress);\n        uint256 feeAmount = (_amount * protocolFee) / 1e18;\n        if (feeAmount > 0) {\n            // solhint-disable-next-line\n            (bool sent, ) = feeAddress.call{value: feeAmount}(\"\");\n            if (!sent) revert FailedToSend();\n        }\n        uint256 amount = _amount - feeAmount;\n        uint256 safEthTvl = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 votiumTvl = ((votiumStrategy.cvxPerVotium() *\n            votiumStrategy.ethPerCvx(true)) *\n            IERC20(vEthAddress).balanceOf(address(this))) / 1e36;\n        uint256 totalTvl = (safEthTvl + votiumTvl);\n        uint256 safEthRatio = (safEthTvl * 1e18) / totalTvl;\n        if (safEthRatio < ratio) {\n            ISafEth(SAF_ETH_ADDRESS).stake{value: amount}(0);\n        } else {\n            votiumStrategy.depositRewards{value: amount}(amount);\n        }\n    }\n\n    function safEthBalanceMinusPending() public view returns (uint256) {\n        return\n            IERC20(SAF_ETH_ADDRESS).balanceOf(address(this)) -\n            pendingSafEthWithdraws;\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/strategies/votium/VotiumStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./VotiumStrategyCore.sol\";\n\n/// @title Votium Strategy Token\n/// @author Asymmetry Finance\ncontract VotiumStrategy is VotiumStrategyCore, AbstractStrategy {\n    event WithdrawRequest(\n        address indexed user,\n        uint256 amount,\n        uint256 withdrawId\n    );\n\n    struct WithdrawRequestInfo {\n        uint256 cvxOwed;\n        bool withdrawn;\n        uint256 epoch;\n        address owner;\n    }\n\n    mapping(uint256 => WithdrawRequestInfo)\n        public withdrawIdToWithdrawRequestInfo;\n\n    /**\n     * @notice Gets price in eth\n     * @return Price of token in eth\n     */\n    function price() external view override returns (uint256) {\n        return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n    }\n\n    /**\n     * @notice Deposit eth to mint this token at current price\n     * @return mintAmount Amount of tokens minted\n     */\n    function deposit() public payable override returns (uint256 mintAmount) {\n        uint256 priceBefore = cvxPerVotium();\n        uint256 cvxAmount = buyCvx(msg.value);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        mintAmount = ((cvxAmount * 1e18) / priceBefore);\n        _mint(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Request to withdraw from strategy emits event with eligible withdraw epoch\n     * @notice Burns afEth tokens and determines equivilent amount of cvx to start unlocking\n     * @param _amount Amount to request withdraw\n     * @return withdrawId Id of withdraw request\n     */\n    function requestWithdraw(\n        uint256 _amount\n    ) public override returns (uint256 withdrawId) {\n        latestWithdrawId++;\n        uint256 _priceInCvx = cvxPerVotium();\n\n        _burn(msg.sender, _amount);\n\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        cvxUnlockObligations += cvxAmount;\n\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n                (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n                    .epochs(currentEpoch);\n                uint256 timeDifference = lockedBalances[i].unlockTime -\n                    currentEpochStartingTime;\n                uint256 epochOffset = timeDifference /\n                    ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n                uint256 withdrawEpoch = currentEpoch + epochOffset;\n                withdrawIdToWithdrawRequestInfo[\n                    latestWithdrawId\n                ] = WithdrawRequestInfo({\n                    cvxOwed: cvxAmount,\n                    withdrawn: false,\n                    epoch: withdrawEpoch,\n                    owner: msg.sender\n                });\n\n                emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n                return latestWithdrawId;\n            }\n        }\n        // should never get here\n        revert InvalidLockedAmount();\n    }\n\n    /**\n     * @notice Withdraws from requested withdraw if eligible epoch has passed\n     * @param _withdrawId Id of withdraw request\n     */\n    function withdraw(uint256 _withdrawId) external override {\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].owner != msg.sender)\n            revert NotOwner();\n        if (!this.canWithdraw(_withdrawId)) revert WithdrawNotReady();\n\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn)\n            revert AlreadyWithdrawn();\n\n        relock();\n\n        uint256 cvxWithdrawAmount = withdrawIdToWithdrawRequestInfo[_withdrawId]\n            .cvxOwed;\n\n        uint256 ethReceived = sellCvx(cvxWithdrawAmount);\n        cvxUnlockObligations -= cvxWithdrawAmount;\n        withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn = true;\n\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice Relocks cvx while ensuring there is enough to cover all withdraw requests\n     * @dev This happens automatically on withdraw but will need to be manually called if no withdraws happen in an epoch where locks are expiring\n     */\n    function relock() public {\n        (, uint256 unlockable, , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        if (unlockable > 0)\n            ILockedCvx(VLCVX_ADDRESS).processExpiredLocks(false);\n        uint256 cvxBalance = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        uint256 cvxAmountToRelock = cvxBalance > cvxUnlockObligations\n            ? cvxBalance - cvxUnlockObligations\n            : 0;\n        if (cvxAmountToRelock > 0) {\n            IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmountToRelock);\n            ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmountToRelock, 0);\n        }\n    }\n\n    /**\n     * @notice Checks if withdraw request is eligible to be withdrawn\n     * @param _withdrawId Id of withdraw request\n     */\n    function canWithdraw(\n        uint256 _withdrawId\n    ) external view virtual override returns (bool) {\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        return\n            withdrawIdToWithdrawRequestInfo[_withdrawId].epoch <= currentEpoch;\n    }\n\n    /**\n     * @notice Checks how long it will take to withdraw a given amount\n     * @param _amount Amount of afEth to check how long it will take to withdraw\n     * @return When it would be withdrawable based on the amount\n     */\n    function withdrawTime(\n        uint256 _amount\n    ) external view virtual override returns (uint256) {\n        uint256 _priceInCvx = cvxPerVotium();\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (\n                totalLockedBalancePlusUnlockable >=\n                cvxUnlockObligations + cvxAmount\n            ) {\n                return lockedBalances[i].unlockTime;\n            }\n        }\n        revert InvalidLockedAmount();\n    }\n}"
    }
  ]
}