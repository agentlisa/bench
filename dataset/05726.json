{
  "Title": "[41] Missing support for certain precompiles",
  "Content": "\nThe Shanghai protocol release has nine precompiled contracts, namely `ecrecover`, `sha256`, `ripemd160`, `identity`, `modexp`, `ecadd`, `ecmul` and `blake2f`. However, within the current version of zkSync Era, the only precompiles supported are `ecrecover` and `sha256` (plus `keccak256`) and the ones being developed by [lambdaclass](https://github.com/lambdaclass/zksync_era_precompiles#current-status), namely `ecAdd`, `ecMul` and `modexp` (plus `ecPairing`). Consider implementing the other ones too, although they are rarely used, for full equivalence with Ethereum at the precompile level (`ripemd160`, `blake2f` and `identity`).\n\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832399070):**\n > Regarding [19], the following test highlights the issue:\n> \n> ```rust\n> // Put this test inside ecrecover/secp256k1/mod.rs and run from the \n> // era-zkevm_circuits folder the next command\n> //\n> //              cargo test POC -- --nocapture\n> //\n> #[test]\n> fn POC() {\n>     let false_zero = PointAffine::zero();\n>     let real_zero = PointAffine::from_xy_checked(Fq::zero(), Fq::zero()).unwrap();\n> \n>     println!(\"Is (0, 1) the null elememt (should not) -> {}\", false_zero.is_zero());\n>     println!(\"Is (0, 0) the null elememt -> {}\\n\", real_zero.is_zero());\n>     println!(\"Is (0, 1) on curve (should NOT) -> {}\", false_zero.is_on_curve());\n>     println!(\"Is (0, 0) on curve -> {}\", real_zero.is_on_curve());\n> }\n> ```\n> \n> The point at infinity is defined as `(0, 0)`, not both `(0, 0)` and `(0, 1)`. As it is right now, you could craft valid signatures with an invalid point or corrupt the result of other operations like [PointProjective::add_assign_mixed](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L455) due to:\n> \n> - `(0, 1)` not being the null element (from the mathematical proof above) **AND**\n> - `(0, 1)` not being on the curve as it does not comply with `y² = x³ + b -> 1², not = 0³ + 7`\n> \n> Therefore (0, 1) not in F`\n> \n> On top of that, we have that all operations defined under `F` apply **ONLY** to the elements of `F` (by definition). Therefore, you cannot use elements outside of `F` with functions and elements defined under `F`, as it is the case right now (it's mathematically wrong and bug prone).\n> \n> ```rust\n> // Put this test inside ecrecover/secp256k1/mod.rs and run from the \n> // era-zkevm_circuits folder the next command\n> //\n> //              cargo test POC_MIXED -- --nocapture\n> //\n> #[test]\n> fn POC_MIXED() {\n>     let false_zero = PointAffine::zero();\n>     let real_zero = PointAffine::from_xy_checked(Fq::zero(), Fq::zero()).unwrap();\n>     let projective = PointProjective::one();\n>     println!(\"Point projective -> {}\", &projective);\n>     println!(\"False zero -> {:?}\", &false_zero);\n>     println!(\"Real zero -> {:?}\\n\", &real_zero);\n>     \n> \n>     let mut projective1 = projective.clone() as PointProjective;\n>     projective1.add_assign_mixed(&false_zero);\n>     println!(\"Added (0, 1) -> {}\", projective1);\n> \n>     let mut projective2 = projective.clone() as PointProjective;\n>     projective2.add_assign_mixed(&real_zero);\n>     println!(\"Added (0, 0) -> {}\\n\", projective2);\n> }\n> ```\n> \n> Moreover, the implementation of this curve is widely used in many cryptographic projects, so if anyone forks this crate and uses it on his own project (for example, due to a recommendation from the own devs), they would be building something fundamentally flawed (and can damage zkSync Era's reputation if such a project gets rekt because of that).\n>\n>The fix is [ecrecover/secp256k1/mod.rs, line 150](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L150):\n> \n> ```diff\n>     fn zero() -> Self {\n>         PointAffine {\n>             x: Fq::zero(),\n> -           y: Fq::one(),\n> +           y: Fq::zero(),\n>             infinity: true,\n>         }\n>     }\n> ```\n> \n> As seen in [ecrecover/secp256k1/mod.rs, line 199](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L199):\n> \n> ```rust\n>     fn from_xy_checked(x: Self::Base, y: Self::Base) -> Result<Self, GroupDecodingError> {\n>         let infinity = x.is_zero() && y.is_zero();\n>         let affine = Self {\n>             x: x,\n>             y: y,\n>             infinity,\n>         };\n> \n>         if !affine.is_on_curve() {\n>             Err(GroupDecodingError::NotOnCurve)\n>         } else {\n>             Ok(affine)\n>         }\n>     }\n> ```\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832401079):**\n > Regarding [38], I have been testing and it is indeed a bug, as you would be returning a corrupted value. Although it would be defined as the point at infinity due to `Z = 0`, the other coordinates remain non-zero/one leading to corrupted results if it is used again. Here is the POC:\n> \n> ```rust\n> // Put this test inside ecrecover/secp256k1/mod.rs and run from the \n> // era-zkevm_circuits folder the next command\n> //\n> //              cargo test POC -- --nocapture\n> //\n> #[test]\n> fn POC() {\n>     let mut projective = PointProjective::one();\n>     let mut projective_into_affine_negated = projective.clone().into_affine();\n>     projective_into_affine_negated.negate();\n>     println!(\"Point projective -> {}\", &projective);\n>     println!(\"Point projective into affine negated -> {}\\n\", &projective_into_affine_negated);\n>     \n>     projective.add_assign_mixed(&projective_into_affine_negated);\n>     println!(\"Added A + (-A) (should be zero by definition) -> {:?}\", &projective);\n>     println!(\"Zero is defined as -> {:?}\", PointProjective::zero());\n> }\n> ```\n> \n> The fix is the one I have written in the QA [here](https://github.com/code-423n4/2023-10-zksync-findings/blob/main/data/erebus-Q.md#nc-18-pointprojectiveadd_assign_mixed-missing-code). However, it had a typo so the next one is the correct one:\n> \n> [secp256k1/mod.rs, line 486](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L486)\n> \n> ```diff\n>             ...\n> \n>         } else {\n>             // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n> \n> +           if self.x == u2 {\n> +               (*self) = Self::zero();\n> +               return;\n> +           }\n> \n>             // H = U2-X1\n>             let mut h = u2;\n> \n>             ...\n> ```\n>\n> As seen here (even the comments are the same)\n> \n> [secp256k1/mod.rs, function `add_assign`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L403)\n> \n> ```rust\n>             ...\n> \n>         } else {\n>             // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n> \n>             if u1 == u2 {\n>                 // The two points are equal, so we double. // @audit wrong comment, the one I'm referring is the previous one\n>                 (*self) = Self::zero();\n>                 return;\n>             }\n> \n>             // H = U2-U1\n>             let mut h = u2;\n> \n>             ...\n> ```\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832403440):**\n > Regarding [12], after re-reading the docs provided in the audit repo, it seems I was wrong and the correct implementation is the one in [line 1456](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1450C1-L1456C90). The flawed one is in [line 918](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L913C1-L921C57).\n> \n> When bootloader calls `askOperatorForRefund` it will be provided with the leftover gas **PLUS** the reserved gas calculated by the operator off-chain (not the one in `getGasLimitForTx`).\n> \n> [bootloader, line 918](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L918C1-L918C96)\n> \n> ```solidity\n>                     refundGas := max(getOperatorRefundForTx(transactionIndex), potentialRefund)\n> ```\n> \n> This will always pick the one provided by the operator and adding such a value with `reservedGas` in [bootloader, line 921](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L921C1-L921C57):\n> \n> ```solidity\n>                 refundGas := add(refundGas, reservedGas)\n> ```\n> \n> This will output `refundGas + reservedGasByOperator + reservedGasByBootloader`, giving users a higher gas refund than the correct one. It seems for high `reservedGas` values, such a transaction would always revert due to the [check in line 923](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L923), so it can be seen as a DOS in those situations and a theft of gas in the others. Nevertheless, consider changing the code to:\n> \n> ```diff\n>                     ...\n> \n>                     // In case the operator provided smaller refund than the one calculated\n>                     // by the bootloader, we return the refund calculated by the bootloader.\n> -                   refundGas := max(getOperatorRefundForTx(transactionIndex), potentialRefund)\n> +                   refundGas := max(getOperatorRefundForTx(transactionIndex), safeAdd(potentialRefund, reservedGas, \"whatever\"))\n>                 }\n> \n> -              refundGas := add(refundGas, reservedGas)\n> \n>                 if gt(refundGas, gasLimit) {\n>                     assertionError(\"L1: refundGas > gasLimit\")\n>                 }\n> \n>                 ...\n> ```\n> \n> Taking into account my submission [Operator can steal all gas provided by ANY user for L1 → L2 transactions](https://github.com/code-423n4/2023-10-zksync-findings/issues/255) and mixing the fixes.\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832408672):**\n> Although [40] can be seen as a little increase of gas (doing the maths with the Ethereum ones, note that the gas cost of the same opcodes in zkSync Era is far more due to ZK processing) and you can argue that this is a QA refactoring. Take into account that the goal of zkSync Era is to increase its TPS much more than what it is right now, which is currently `7.13` according to [l2beat](https://l2beat.com/scaling/projects/zksync-era). \n> \n> For example, let's say `3.565` are from L1 and `3.565` are from L2. That means, the increased gas cost per second  right now is:\n> \n> `3.565 * 160 + 3.565 * 240 = 1426` gas/second.\n> \n> In a whole year, the gas taken from users would be `1426 * 60 \\ seconds * 60 \\ minutes * 24 \\ hours * 365 \\ days = 44970336000 gas` (around `44` US billion gas). That's a lot of gas going straight into the operators pockets *\"for free\"* as users are paying for the execution of their transaction, not for debugging functionalities. Moreover, in many other gas calculations blocks like [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L985), [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1240), [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1427) and [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1269) they are totally excluded, which shows the developers intentions to avoid overcharging users.\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832416928):**\n > Regarding [39], to show a different example from the classic swap issue, imagine a protocol that is deployed in both zkSync Era and Ethereum, is going to initiate a multi-chain airdrop from Ethereum to both its zkSync and Ethereum users. A malicious or a set of malicious operators on Ethereum can delay the transaction to initiate the airdrop on zkSync Era and sell their tokens to a higher price, as the total supply between chains would be fewer. Once the price spikes, they pass the airdrop transaction to zkSync to dilute the price and harm users who were holding those tokens, as the supply increases, so the price decreases instantly like a [market crash](https://en.wikipedia.org/wiki/Stock_market_crash).\n >\n >The deadline would stop such an attack, as the protocol could set the airdrop to last a few minutes, otherwise the zkSync airdrop wouldn't take place. This attack can be seen as a real world inflation attack, in which one country holds foreign currency for a long time and dumps all the money to the target country to flood its market and skyrocket its local monetary inflation (making an analogy between layers and countries)\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835640487):**\n > For [19], this is a valid code quality issue, but there is no impact.\n>\n> Summary of the issue:<br>\n> In affine coordinates, we use both (`0,1`, `infinity=true`) and (`0,0`, `infinity=true`) to store the point at infinity. As the warden explained, mathematically there should only be one point at infinity. However, throughout the codebase, we check if a point is infinity only by checking the boolean is true (ignoring the `x,y` coordinates). The warden's own test cases confirm that the code handles both points correctly, so there is no impact.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835642929):**\n > > For [38], this is basically the exact same \"bug\" as L-19. Valid code quality but no impact.\n> As long as the `z` coordinate of a Projective Point is zero, it will be treated as the point at infinity, regardless of the `x` and `y` coordinates.\n\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835691963):**\n > > For [12], the original report was wrong, but this comment is correct. However, it does not have any impact, so it should be considered as QA. The reason why it lacks any impact is:\n> \n> `reservedGas = totalGasLimit - max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex))`\n>\n> https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L1145\n> \n> and\n> \n> `refundGas = max(getOperatorRefundForTx(transactionIndex), potentialRefund) + reservedGas`\n>\n> https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L918\n> \n> In order to have `refundGas > gasLimit` (to have DoS as mentioned by the warden) the following condition should be met:\n>\n> ```\n> max(getOperatorRefundForTx(transactionIndex), potentialRefund) + totalGasLimit - max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex)) > gasLimit\n> ```\n>\n> Since `totalGasLimit` is the same as `gasLimit`, we will have:\n>\n> ```\n> max(getOperatorRefundForTx(transactionIndex), potentialRefund) > max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex))\n> ```\n>\n> This is possible if the operator provides refund higher than `max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex))`. Moreover, if the operator provides such large refund amount, the bootloader will be reverted at line 924, so nothing happens, it is kind of self-rekt for the operator. It is as if the operator provides very low gas at the beginning to run the bootloader, so the bootloader will revert, and he should run it again.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835695581):**\n > [40] is QA at most. Yes, it is an additional cost for users. So, it is the fact that we have written `DefaultAccount` in Solidity & not in Yul. This is the price everyone pays for better support.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835704171):**\n > > For [39], `expirationTimestamp` is not used anywhere. It is set, but it is not responsible for any logic currently. It will be used in the future implementations. This report can be used in Analysis report. \n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835853346):**\n > @miladpiri - Regarding [19]: You can just check the boolean, that's true, but it will return true for both of them, as the tests and the mathematical proof highlight. All signatures and some ZK things rely on the correctness of this curve and the **UNIQUENESS** of the points in there. If you can craft two different points that are gonna be treated as the same one, even if one of them is not on the curve, then you can replay the original one with the wrong one. When you say\n> \n> >  The warden's own test cases confirm that the code handles both points correctly, so there is no impact.\n> \n> The code must not accept `(0, 1)`. The result is wrong. `(0, 1)` is not on the curve and it is not the zero element. They must revert like in `from_xy_checked`. Moreover, it is the purpose of `is_on_curve` function to return false for those points and prevent the parent function from going on with an invalid point. Math structures like this curve and all the operations defined under it must be correctly implemented for a reason. Right now, from a formal POV, this is not the real secp256k1 curve. It mimics how it works, but it is not the same.\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835866806):**\n > @miladpiri - Regarding [38]: In fact, it is worse, as every point added with its negated will be treated as the zero element. That means you can have infinite zero elements (up to the prime field) who all are **DIFFERENT** from each other and from `(0, 1, 0)` floating around.\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835896481):**\n > @miladpiri - Regarding [12], You said\n> \n> > This is possible if the operator provides refund higher than `max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex))`.\n> \n> This is correct and I did not take into account, so the DOS part is invalid. However, the theft of gas from the operator by users is correct as the bootloader is checking what is higher; the calculated refund for the execution of the transaction or the value provided by the operator, which is returning **HIS** reserved gas plus the leftover gas he has found for such a transaction. That means the operator's value will always be picked and being added with reserved gas will output more gas than intended.\n>\n> The code responsible for that in the zkSync Era node is in [refunds.rs, line 253](https://github.com/matter-labs/zksync-era/blob/0cd2c6b5ada568ffe01bce6d2dd8951457369141/core/lib/multivm/src/versions/vm_latest/tracers/refunds.rs#L253):\n> \n> ```rust\n>             ...\n> \n>             let tx_gas_limit = state\n>                 .memory\n>                 .read_slot(\n>                     BOOTLOADER_HEAP_PAGE as usize,\n>                     tx_description_offset + TX_GAS_LIMIT_OFFSET,\n>                 )\n>                 .value\n>                 .as_u32();\n> \n>             ...\n> \n>             let tx_body_refund = self.tx_body_refund(\n>                 bootloader_refund,\n>                 gas_spent_on_pubdata,\n>                 tx_gas_limit,\n>                 current_ergs_per_pubdata_byte,\n>                 pubdata_published,\n>             );\n> \n>             ...\n> ```\n> \n> If we go to `tx_body_refund` we see that the refund provided by the operator is, roughly, `gasLimitFromUser - gasSpentInComputation - gasSpentInPubdata`, that is, the excess of gas provided by the user, or, in other terms, the refund of gas after the execution step plus the reserved gas:\n> \n> [refunds.rs, function `tx_body_refund`](https://github.com/matter-labs/zksync-era/blob/0cd2c6b5ada568ffe01bce6d2dd8951457369141/core/lib/multivm/src/versions/vm_latest/tracers/refunds.rs#L95)\n> \n> ```rust\n>     pub(crate) fn tx_body_refund(\n>         &self,\n>         bootloader_refund: u32,\n>         gas_spent_on_pubdata: u32,\n>         tx_gas_limit: u32,\n>         current_ergs_per_pubdata_byte: u32,\n>         pubdata_published: u32,\n>     ) -> u32 {\n>         let total_gas_spent = tx_gas_limit - bootloader_refund;\n> \n>         let gas_spent_on_computation = total_gas_spent\n>             .checked_sub(gas_spent_on_pubdata)\n>             .unwrap_or_else(|| {\n>                 tracing::error!(\n>                     \"Gas spent on pubdata is greater than total gas spent. On pubdata: {}, total: {}\",\n>                     gas_spent_on_pubdata,\n>                     total_gas_spent\n>                 );\n>                 0\n>             });\n> \n>         // For now, bootloader charges only for base fee.\n>         let effective_gas_price = self.l1_batch.base_fee();\n> \n>         let bootloader_eth_price_per_pubdata_byte =\n>             U256::from(effective_gas_price) * U256::from(current_ergs_per_pubdata_byte);\n> \n>         let fair_eth_price_per_pubdata_byte =\n>             U256::from(eth_price_per_pubdata_byte(self.l1_batch.l1_gas_price));\n> \n>         // For now, L1 originated transactions are allowed to pay less than fair fee per pubdata,\n>         // so we should take it into account.\n>         let eth_price_per_pubdata_byte_for_calculation = std::cmp::min(\n>             bootloader_eth_price_per_pubdata_byte,\n>             fair_eth_price_per_pubdata_byte,\n>         );\n> \n>         let fair_fee_eth = U256::from(gas_spent_on_computation)\n>             * U256::from(self.l1_batch.fair_l2_gas_price)\n>             + U256::from(pubdata_published) * eth_price_per_pubdata_byte_for_calculation;\n>         let pre_paid_eth = U256::from(tx_gas_limit) * U256::from(effective_gas_price);\n>         let refund_eth = pre_paid_eth.checked_sub(fair_fee_eth).unwrap_or_else(|| {\n>             tracing::error!(\n>                 \"Fair fee is greater than pre paid. Fair fee: {} wei, pre paid: {} wei\",\n>                 fair_fee_eth,\n>                 pre_paid_eth\n>             );\n>             U256::zero()\n>         });\n> \n>         ceil_div_u256(refund_eth, effective_gas_price.into()).as_u32()\n>     }\n> ```\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1836025283):**\n > @miladpiri - Regarding [39], I understand; however, I'm not talking about deposits staying idle or not being executed in zkSync Era due to high congestion in Ethereum for days. I am referencing time-sensitive  `L1->L2` transactions via `requestL2Transaction`.\n> \n> The issue is that it's fine to put that *\"hard-coded\"*  deadline for deposits, as the *\"environment changes\"* they suffer from are minimal, but there is no way for a contract in Ethereum to set a deadline of, say, a few minutes, for the execution of his transaction on zkSync Era, leading to the impacts I mentioned above. Neither it is possible now nor when you actually implement the logic regarding the withdrawals without operator's help. \n> \n> I focused on `expirationTimestamp`, as it is wrong to assume that `msg.timestamp` equals the time the user submitted the transaction to the network and when the transaction is actually picked and executed on-chain, which affects **ALL** `L1->L2` transactions, whether they are simple deposits or not, and the fact it will be used for all types of transactions, whether the caller wants that deadline or not.\n> \n> As the intention as well as the *\"Ethereum counterpart\"* is implemented in the code in-scope for this audit, plus the real threat rogue nodes in Ethereum are for the network as stated in the real-world [examples](https://news.bitcoin.com/rogue-validator-exploits-mev-bots-on-ethereum-resulting-in-25-3m-in-crypto-losses). Please reconsider, as users must be able to put the deadline they want/need for their transactions. Otherwise, transactions going to zkSync Era from Ethereum will become prime target of MEV bots and rogue nodes, due to the \"sequential determinism\" of your `L1->L2` communication channel.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1848941661):**\n> [01] - TODO<br>\n> [02] - Refactor<br>\n> [03] - Ignored<br>\n> [04] - Refactor<br>\n> [05] - Low<br>\n> [06] - TODO<br>\n> [07] - Non-Critical<br>\n> [08] - Ignored<br>\n> [09] - Non-Critical<br>\n> [10] - TODO<br>\n> [11] - Low<br>\n> [12] - Refactor<br>\n> [13] - Non-Critical<br>\n> [14] - Ignored<br>\n> [15] - Low<br>\n> [16] - Low<br>\n> [17] - TODO<br>\n> [18] - Low<br>\n> [19] - Ignored<br>\n> [20] - Low<br>\n> [21] - Refactor<br>\n> [22] - Non-Critical<br>\n> [23] - Non-Critical<br>\n> [24] - Non-Critical<br>\n> [25] - Low<br>\n> [26] - Non-Critical<br>\n> [27] - Non-Critical<br>\n> [28] - Low<br>\n> [29] - Non-Critical<br>\n> [30] - Refactor<br>\n> [31] - Low<br>\n> [32] - Refactor<br>\n> [33] - Refactor<br>\n> [34] - Low<br>\n> [35] - Low<br>\n> [36] - Ignored<br>\n> [37] - Non-Critical<br>\n> [38] - Non-Critical<br>\n> [39] - Low<br>\n> [40] - Non-Critical<br>\n> [41] - Ignored<br>\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/548).*\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs",
      "content": "use boojum::pairing::ff::BitIterator;\nuse boojum::pairing::ff::*;\nuse boojum::pairing::{\n    EncodingBytes, GenericCompressedEncodable, GenericCurveAffine, GenericCurveProjective,\n    GenericUncompressedEncodable, GroupDecodingError,\n};\n\npub mod fq;\npub mod fr;\n\nuse fq::*;\nuse fr::*;\n\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub struct PointAffine {\n    pub(crate) x: Fq,\n    pub(crate) y: Fq,\n    pub(crate) infinity: bool,\n}\n\nstatic NAME_STR: &'static str = \"Secp256k1\";\n\nimpl ::std::fmt::Display for PointAffine {\n    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        if self.infinity {\n            write!(f, \"{}(Infinity)\", NAME_STR)\n        } else {\n            write!(f, \"{}(x={}, y={})\", NAME_STR, self.x, self.y)\n        }\n    }\n}\n\n#[derive(Copy, Clone, Debug, Eq)]\npub struct PointProjective {\n    pub(crate) x: Fq,\n    pub(crate) y: Fq,\n    pub(crate) z: Fq,\n}\n\nimpl ::std::fmt::Display for PointProjective {\n    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        write!(f, \"{}\", self.into_affine())\n    }\n}\n\nimpl PartialEq for PointProjective {\n    fn eq(&self, other: &PointProjective) -> bool {\n        if self.is_zero() {\n            return other.is_zero();\n        }\n\n        if other.is_zero() {\n            return false;\n        }\n\n        // The points (X, Y, Z) and (X', Y', Z')\n        // are equal when (X * Z^2) = (X' * Z'^2)\n        // and (Y * Z^3) = (Y' * Z'^3).\n\n        let mut z1 = self.z;\n        z1.square();\n        let mut z2 = other.z;\n        z2.square();\n\n        let mut tmp1 = self.x;\n        tmp1.mul_assign(&z2);\n\n        let mut tmp2 = other.x;\n        tmp2.mul_assign(&z1);\n\n        if tmp1 != tmp2 {\n            return false;\n        }\n\n        z1.mul_assign(&self.z);\n        z2.mul_assign(&other.z);\n        z2.mul_assign(&self.y);\n        z1.mul_assign(&other.y);\n\n        if z1 != z2 {\n            return false;\n        }\n\n        true\n    }\n}\n\nimpl PointAffine {\n    fn mul_bits<S: AsRef<[u64]>>(&self, bits: BitIterator<S>) -> PointProjective {\n        let mut res = PointProjective::zero();\n        for i in bits {\n            res.double();\n            if i {\n                res.add_assign_mixed(self)\n            }\n        }\n        res\n    }\n\n    /// Attempts to construct an affine point given an x-coordinate. The\n    /// point is not guaranteed to be in the prime order subgroup.\n    ///\n    /// If and only if `greatest` is set will the lexicographically\n    /// largest y-coordinate be selected.\n    fn get_point_from_x(x: Fq, greatest: bool) -> Option<PointAffine> {\n        // Compute x^3 + b\n        let mut x3b = x;\n        x3b.square();\n        x3b.mul_assign(&x);\n        x3b.add_assign(&PointAffine::get_coeff_b());\n\n        x3b.sqrt().map(|y| {\n            let mut negy = y;\n            negy.negate();\n\n            PointAffine {\n                x: x,\n                y: if (y < negy) ^ greatest { y } else { negy },\n                infinity: false,\n            }\n        })\n    }\n\n    fn is_on_curve(&self) -> bool {\n        if self.is_zero() {\n            true\n        } else {\n            // Check that the point is on the curve\n            let mut y2 = self.y;\n            y2.square();\n\n            let mut x3b = self.x;\n            x3b.square();\n            x3b.mul_assign(&self.x);\n            x3b.add_assign(&Self::get_coeff_b());\n\n            y2 == x3b\n        }\n    }\n}\n\nimpl GenericCurveAffine for PointAffine {\n    type Scalar = Fr;\n    type Base = Fq;\n    type Projective = PointProjective;\n\n    fn zero() -> Self {\n        PointAffine {\n            x: Fq::zero(),\n            y: Fq::one(),\n            infinity: true,\n        }\n    }\n\n    fn one() -> Self {\n        Self::get_generator()\n    }\n\n    fn is_zero(&self) -> bool {\n        self.infinity\n    }\n\n    fn mul<S: Into<<Self::Scalar as PrimeField>::Repr>>(&self, by: S) -> PointProjective {\n        let bits = BitIterator::new(by.into());\n        self.mul_bits(bits)\n    }\n\n    fn negate(&mut self) {\n        if !self.is_zero() {\n            self.y.negate();\n        }\n    }\n\n    fn into_projective(&self) -> PointProjective {\n        (*self).into()\n    }\n\n    #[inline(always)]\n    fn as_xy(&self) -> (&Self::Base, &Self::Base) {\n        (&self.x, &self.y)\n    }\n\n    #[inline(always)]\n    fn into_xy_unchecked(self) -> (Self::Base, Self::Base) {\n        (self.x, self.y)\n    }\n\n    #[inline(always)]\n    fn from_xy_unchecked(x: Self::Base, y: Self::Base) -> Self {\n        let infinity = x.is_zero() && y.is_zero();\n        Self {\n            x: x,\n            y: y,\n            infinity,\n        }\n    }\n\n    fn from_xy_checked(x: Self::Base, y: Self::Base) -> Result<Self, GroupDecodingError> {\n        let infinity = x.is_zero() && y.is_zero();\n        let affine = Self {\n            x: x,\n            y: y,\n            infinity,\n        };\n\n        if !affine.is_on_curve() {\n            Err(GroupDecodingError::NotOnCurve)\n        } else {\n            Ok(affine)\n        }\n    }\n\n    fn a_coeff() -> Self::Base {\n        Self::Base::zero()\n    }\n\n    fn b_coeff() -> Self::Base {\n        Self::get_coeff_b()\n    }\n}\n\nimpl GenericCurveProjective for PointProjective {\n    type Scalar = Fr;\n    type Base = Fq;\n    type Affine = PointAffine;\n\n    // The point at infinity is always represented by\n    // Z = 0.\n    fn zero() -> Self {\n        PointProjective {\n            x: Fq::zero(),\n            y: Fq::one(),\n            z: Fq::zero(),\n        }\n    }\n\n    fn one() -> Self {\n        PointAffine::one().into()\n    }\n\n    // The point at infinity is always represented by\n    // Z = 0.\n    fn is_zero(&self) -> bool {\n        self.z.is_zero()\n    }\n\n    fn is_normalized(&self) -> bool {\n        self.is_zero() || self.z == Fq::one()\n    }\n\n    fn batch_normalization(v: &mut [Self]) {\n        // Montgomery’s Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        // First pass: compute [a, ab, abc, ...]\n        let mut prod = Vec::with_capacity(v.len());\n        let mut tmp = Fq::one();\n        for g in v\n            .iter_mut()\n            // Ignore normalized elements\n            .filter(|g| !g.is_normalized())\n        {\n            tmp.mul_assign(&g.z);\n            prod.push(tmp);\n        }\n\n        // Invert `tmp`.\n        tmp = tmp.inverse().unwrap(); // Guaranteed to be nonzero.\n\n        // Second pass: iterate backwards to compute inverses\n        for (g, s) in v\n            .iter_mut()\n            // Backwards\n            .rev()\n            // Ignore normalized elements\n            .filter(|g| !g.is_normalized())\n            // Backwards, skip last element, fill in one for last term.\n            .zip(prod.into_iter().rev().skip(1).chain(Some(Fq::one())))\n        {\n            // tmp := tmp * g.z; g.z := tmp * s = 1/z\n            let mut newtmp = tmp;\n            newtmp.mul_assign(&g.z);\n            g.z = tmp;\n            g.z.mul_assign(&s);\n            tmp = newtmp;\n        }\n\n        // Perform affine transformations\n        for g in v.iter_mut().filter(|g| !g.is_normalized()) {\n            let mut z = g.z; // 1/z\n            z.square(); // 1/z^2\n            g.x.mul_assign(&z); // x/z^2\n            z.mul_assign(&g.z); // 1/z^3\n            g.y.mul_assign(&z); // y/z^3\n            g.z = Fq::one(); // z = 1\n        }\n    }\n\n    fn double(&mut self) {\n        if self.is_zero() {\n            return;\n        }\n\n        // Other than the point at infinity, no points on E or E'\n        // can double to equal the point at infinity, as y=0 is\n        // never true for points on the curve.\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n\n        // A = X1^2\n        let mut a = self.x;\n        a.square();\n\n        // B = Y1^2\n        let mut b = self.y;\n        b.square();\n\n        // C = B^2\n        let mut c = b;\n        c.square();\n\n        // D = 2*((X1+B)2-A-C)\n        let mut d = self.x;\n        d.add_assign(&b);\n        d.square();\n        d.sub_assign(&a);\n        d.sub_assign(&c);\n        d.double();\n\n        // E = 3*A\n        let mut e = a;\n        e.double();\n        e.add_assign(&a);\n\n        // F = E^2\n        let mut f = e;\n        f.square();\n\n        // Z3 = 2*Y1*Z1\n        self.z.mul_assign(&self.y);\n        self.z.double();\n\n        // X3 = F-2*D\n        self.x = f;\n        self.x.sub_assign(&d);\n        self.x.sub_assign(&d);\n\n        // Y3 = E*(D-X3)-8*C\n        self.y = d;\n        self.y.sub_assign(&self.x);\n        self.y.mul_assign(&e);\n        c.double();\n        c.double();\n        c.double();\n        self.y.sub_assign(&c);\n    }\n\n    fn add_assign(&mut self, other: &Self) {\n        if self.is_zero() {\n            *self = *other;\n            return;\n        }\n\n        if other.is_zero() {\n            return;\n        }\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl\n\n        // Z1Z1 = Z1^2\n        let mut z1z1 = self.z;\n        z1z1.square();\n\n        // Z2Z2 = Z2^2\n        let mut z2z2 = other.z;\n        z2z2.square();\n\n        // U1 = X1*Z2Z2\n        let mut u1 = self.x;\n        u1.mul_assign(&z2z2);\n\n        // U2 = X2*Z1Z1\n        let mut u2 = other.x;\n        u2.mul_assign(&z1z1);\n\n        // S1 = Y1*Z2*Z2Z2\n        let mut s1 = self.y;\n        s1.mul_assign(&other.z);\n        s1.mul_assign(&z2z2);\n\n        // S2 = Y2*Z1*Z1Z1\n        let mut s2 = other.y;\n        s2.mul_assign(&self.z);\n        s2.mul_assign(&z1z1);\n\n        if u1 == u2 && s1 == s2 {\n            // The two points are equal, so we double.\n            self.double();\n        } else {\n            // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n\n            if u1 == u2 {\n                // The two points are equal, so we double.\n                (*self) = Self::zero();\n                return;\n            }\n\n            // H = U2-U1\n            let mut h = u2;\n            h.sub_assign(&u1);\n\n            // I = (2*H)^2\n            let mut i = h;\n            i.double();\n            i.square();\n\n            // J = H*I\n            let mut j = h;\n            j.mul_assign(&i);\n\n            // r = 2*(S2-S1)\n            let mut r = s2;\n            r.sub_assign(&s1);\n            r.double();\n\n            // V = U1*I\n            let mut v = u1;\n            v.mul_assign(&i);\n\n            // X3 = r^2 - J - 2*V\n            self.x = r;\n            self.x.square();\n            self.x.sub_assign(&j);\n            self.x.sub_assign(&v);\n            self.x.sub_assign(&v);\n\n            // Y3 = r*(V - X3) - 2*S1*J\n            self.y = v;\n            self.y.sub_assign(&self.x);\n            self.y.mul_assign(&r);\n            s1.mul_assign(&j); // S1 = S1 * J * 2\n            s1.double();\n            self.y.sub_assign(&s1);\n\n            // Z3 = ((Z1+Z2)^2 - Z1Z1 - Z2Z2)*H\n            self.z.add_assign(&other.z);\n            self.z.square();\n            self.z.sub_assign(&z1z1);\n            self.z.sub_assign(&z2z2);\n            self.z.mul_assign(&h);\n        }\n    }\n\n    fn add_assign_mixed(&mut self, other: &Self::Affine) {\n        if other.is_zero() {\n            return;\n        }\n\n        if self.is_zero() {\n            self.x = other.x;\n            self.y = other.y;\n            self.z = Fq::one();\n            return;\n        }\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-madd-2007-bl\n\n        // Z1Z1 = Z1^2\n        let mut z1z1 = self.z;\n        z1z1.square();\n\n        // U2 = X2*Z1Z1\n        let mut u2 = other.x;\n        u2.mul_assign(&z1z1);\n\n        // S2 = Y2*Z1*Z1Z1\n        let mut s2 = other.y;\n        s2.mul_assign(&self.z);\n        s2.mul_assign(&z1z1);\n\n        if self.x == u2 && self.y == s2 {\n            // The two points are equal, so we double.\n            self.double();\n        } else {\n            // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n\n            // H = U2-X1\n            let mut h = u2;\n            h.sub_assign(&self.x);\n\n            // HH = H^2\n            let mut hh = h;\n            hh.square();\n\n            // I = 4*HH\n            let mut i = hh;\n            i.double();\n            i.double();\n\n            // J = H*I\n            let mut j = h;\n            j.mul_assign(&i);\n\n            // r = 2*(S2-Y1)\n            let mut r = s2;\n            r.sub_assign(&self.y);\n            r.double();\n\n            // V = X1*I\n            let mut v = self.x;\n            v.mul_assign(&i);\n\n            // X3 = r^2 - J - 2*V\n            self.x = r;\n            self.x.square();\n            self.x.sub_assign(&j);\n            self.x.sub_assign(&v);\n            self.x.sub_assign(&v);\n\n            // Y3 = r*(V-X3)-2*Y1*J\n            j.mul_assign(&self.y); // J = 2*Y1*J\n            j.double();\n            self.y = v;\n            self.y.sub_assign(&self.x);\n            self.y.mul_assign(&r);\n            self.y.sub_assign(&j);\n\n            // Z3 = (Z1+H)^2-Z1Z1-HH\n            self.z.add_assign(&h);\n            self.z.square();\n            self.z.sub_assign(&z1z1);\n            self.z.sub_assign(&hh);\n        }\n    }\n\n    fn negate(&mut self) {\n        if !self.is_zero() {\n            self.y.negate()\n        }\n    }\n\n    fn mul_assign<S: Into<<Self::Scalar as PrimeField>::Repr>>(&mut self, other: S) {\n        let mut res = Self::zero();\n\n        let mut found_one = false;\n\n        for i in BitIterator::new(other.into()) {\n            if found_one {\n                res.double();\n            } else {\n                found_one = i;\n            }\n\n            if i {\n                res.add_assign(self);\n            }\n        }\n\n        *self = res;\n    }\n\n    fn into_affine(&self) -> PointAffine {\n        (*self).into()\n    }\n\n    fn recommended_wnaf_for_scalar(scalar: <Self::Scalar as PrimeField>::Repr) -> usize {\n        Self::empirical_recommended_wnaf_for_scalar(scalar)\n    }\n\n    fn recommended_wnaf_for_num_scalars(num_scalars: usize) -> usize {\n        Self::empirical_recommended_wnaf_for_num_scalars(num_scalars)\n    }\n\n    fn as_xyz(&self) -> (&Self::Base, &Self::Base, &Self::Base) {\n        (&self.x, &self.y, &self.z)\n    }\n\n    fn into_xyz_unchecked(self) -> (Self::Base, Self::Base, Self::Base) {\n        (self.x, self.y, self.z)\n    }\n\n    fn from_xyz_unchecked(x: Self::Base, y: Self::Base, z: Self::Base) -> Self {\n        Self { x, y, z }\n    }\n\n    fn from_xyz_checked(\n        _x: Self::Base,\n        _y: Self::Base,\n        _z: Self::Base,\n    ) -> Result<Self, GroupDecodingError> {\n        unimplemented!()\n    }\n}\n\n// The affine point X, Y is represented in the jacobian\n// coordinates with Z = 1.\nimpl From<PointAffine> for PointProjective {\n    fn from(p: PointAffine) -> PointProjective {\n        if p.is_zero() {\n            PointProjective::zero()\n        } else {\n            PointProjective {\n                x: p.x,\n                y: p.y,\n                z: Fq::one(),\n            }\n        }\n    }\n}\n\n// The projective point X, Y, Z is represented in the affine\n// coordinates as X/Z^2, Y/Z^3.\nimpl From<PointProjective> for PointAffine {\n    fn from(p: PointProjective) -> PointAffine {\n        if p.is_zero() {\n            PointAffine::zero()\n        } else if p.z == Fq::one() {\n            // If Z is one, the point is already normalized.\n            PointAffine {\n                x: p.x,\n                y: p.y,\n                infinity: false,\n            }\n        } else {\n            // Z is nonzero, so it must have an inverse in a field.\n            let zinv = p.z.inverse().unwrap();\n            let mut zinv_powered = zinv;\n            zinv_powered.square();\n\n            // X/Z^2\n            let mut x = p.x;\n            x.mul_assign(&zinv_powered);\n\n            // Y/Z^3\n            let mut y = p.y;\n            zinv_powered.mul_assign(&zinv);\n            y.mul_assign(&zinv_powered);\n\n            PointAffine {\n                x: x,\n                y: y,\n                infinity: false,\n            }\n        }\n    }\n}\n\nimpl rand::Rand for PointProjective {\n    fn rand<R: rand::Rng>(rng: &mut R) -> Self {\n        loop {\n            let x = rng.gen();\n            let greatest = rng.gen();\n\n            if let Some(p) = PointAffine::get_point_from_x(x, greatest) {\n                if !p.is_zero() {\n                    if p.is_on_curve() {\n                        return p.into_projective();\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl rand::Rand for PointAffine {\n    fn rand<R: rand::Rng>(rng: &mut R) -> Self {\n        loop {\n            let x = rng.gen();\n            let greatest = rng.gen();\n\n            if let Some(p) = PointAffine::get_point_from_x(x, greatest) {\n                if !p.is_zero() {\n                    if p.is_on_curve() {\n                        return p;\n                    }\n                }\n            }\n        }\n    }\n}\n\nimpl PointAffine {\n    fn get_coeff_b() -> <Self as GenericCurveAffine>::Base {\n        Fq::from_str(\"7\").unwrap()\n    }\n\n    fn get_generator() -> Self {\n        Self {\n            x: crate::ff::from_hex::<Fq>(\n                \"0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\",\n            )\n            .unwrap(),\n            y: crate::ff::from_hex::<Fq>(\n                \"0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\",\n            )\n            .unwrap(),\n            infinity: false,\n        }\n    }\n}\n\nimpl PointProjective {\n    fn empirical_recommended_wnaf_for_scalar(scalar: FrRepr) -> usize {\n        let num_bits = scalar.num_bits() as usize;\n\n        if num_bits >= 130 {\n            4\n        } else if num_bits >= 34 {\n            3\n        } else {\n            2\n        }\n    }\n\n    fn empirical_recommended_wnaf_for_num_scalars(num_scalars: usize) -> usize {\n        const RECOMMENDATIONS: [usize; 12] =\n            [1, 3, 7, 20, 43, 120, 273, 563, 1630, 3128, 7933, 62569];\n\n        let mut ret = 4;\n        for r in &RECOMMENDATIONS {\n            if num_scalars > *r {\n                ret += 1;\n            } else {\n                break;\n            }\n        }\n\n        ret\n    }\n}\n\nimpl GenericUncompressedEncodable<64> for PointAffine {\n    /// Converts this element into its uncompressed encoding, so long as it's not\n    /// the point at infinity.\n    fn into_uncompressed(&self) -> EncodingBytes<Self, 64> {\n        todo!()\n    }\n\n    /// Converts an uncompressed encoding into the curve point\n    fn from_uncompressed(_encoding: EncodingBytes<Self, 64>) -> Result<Self, GroupDecodingError> {\n        todo!()\n    }\n}\n\nimpl GenericCompressedEncodable<32> for PointAffine {\n    /// Converts this element into its uncompressed encoding, so long as it's not\n    /// the point at infinity.\n    fn into_compressed(&self) -> (EncodingBytes<Self, 32>, bool) {\n        todo!();\n    }\n\n    /// Converts an uncompressed encoding into the curve point\n    fn from_compressed(\n        _encoding: EncodingBytes<Self, 32>,\n        _parity: bool,\n    ) -> Result<Self, GroupDecodingError> {\n        todo!()\n    }\n}"
    },
    {
      "filename": "code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs",
      "content": "use boojum::pairing::ff::BitIterator;\nuse boojum::pairing::ff::*;\nuse boojum::pairing::{\n    EncodingBytes, GenericCompressedEncodable, GenericCurveAffine, GenericCurveProjective,\n    GenericUncompressedEncodable, GroupDecodingError,\n};\n\npub mod fq;\npub mod fr;\n\nuse fq::*;\nuse fr::*;\n\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub struct PointAffine {\n    pub(crate) x: Fq,\n    pub(crate) y: Fq,\n    pub(crate) infinity: bool,\n}\n\nstatic NAME_STR: &'static str = \"Secp256k1\";\n\nimpl ::std::fmt::Display for PointAffine {\n    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        if self.infinity {\n            write!(f, \"{}(Infinity)\", NAME_STR)\n        } else {\n            write!(f, \"{}(x={}, y={})\", NAME_STR, self.x, self.y)\n        }\n    }\n}\n\n#[derive(Copy, Clone, Debug, Eq)]\npub struct PointProjective {\n    pub(crate) x: Fq,\n    pub(crate) y: Fq,\n    pub(crate) z: Fq,\n}\n\nimpl ::std::fmt::Display for PointProjective {\n    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n        write!(f, \"{}\", self.into_affine())\n    }\n}\n\nimpl PartialEq for PointProjective {\n    fn eq(&self, other: &PointProjective) -> bool {\n        if self.is_zero() {\n            return other.is_zero();\n        }\n\n        if other.is_zero() {\n            return false;\n        }\n\n        // The points (X, Y, Z) and (X', Y', Z')\n        // are equal when (X * Z^2) = (X' * Z'^2)\n        // and (Y * Z^3) = (Y' * Z'^3).\n\n        let mut z1 = self.z;\n        z1.square();\n        let mut z2 = other.z;\n        z2.square();\n\n        let mut tmp1 = self.x;\n        tmp1.mul_assign(&z2);\n\n        let mut tmp2 = other.x;\n        tmp2.mul_assign(&z1);\n\n        if tmp1 != tmp2 {\n            return false;\n        }\n\n        z1.mul_assign(&self.z);\n        z2.mul_assign(&other.z);\n        z2.mul_assign(&self.y);\n        z1.mul_assign(&other.y);\n\n        if z1 != z2 {\n            return false;\n        }\n\n        true\n    }\n}\n\nimpl PointAffine {\n    fn mul_bits<S: AsRef<[u64]>>(&self, bits: BitIterator<S>) -> PointProjective {\n        let mut res = PointProjective::zero();\n        for i in bits {\n            res.double();\n            if i {\n                res.add_assign_mixed(self)\n            }\n        }\n        res\n    }\n\n    /// Attempts to construct an affine point given an x-coordinate. The\n    /// point is not guaranteed to be in the prime order subgroup.\n    ///\n    /// If and only if `greatest` is set will the lexicographically\n    /// largest y-coordinate be selected.\n    fn get_point_from_x(x: Fq, greatest: bool) -> Option<PointAffine> {\n        // Compute x^3 + b\n        let mut x3b = x;\n        x3b.square();\n        x3b.mul_assign(&x);\n        x3b.add_assign(&PointAffine::get_coeff_b());\n\n        x3b.sqrt().map(|y| {\n            let mut negy = y;\n            negy.negate();\n\n            PointAffine {\n                x: x,\n                y: if (y < negy) ^ greatest { y } else { negy },\n                infinity: false,\n            }\n        })\n    }\n\n    fn is_on_curve(&self) -> bool {\n        if self.is_zero() {\n            true\n        } else {\n            // Check that the point is on the curve\n            let mut y2 = self.y;\n            y2.square();\n\n            let mut x3b = self.x;\n            x3b.square();\n            x3b.mul_assign(&self.x);\n            x3b.add_assign(&Self::get_coeff_b());\n\n            y2 == x3b\n        }\n    }\n}\n\nimpl GenericCurveAffine for PointAffine {\n    type Scalar = Fr;\n    type Base = Fq;\n    type Projective = PointProjective;\n\n    fn zero() -> Self {\n        PointAffine {\n            x: Fq::zero(),\n            y: Fq::one(),\n            infinity: true,\n        }\n    }\n\n    fn one() -> Self {\n        Self::get_generator()\n    }\n\n    fn is_zero(&self) -> bool {\n        self.infinity\n    }\n\n    fn mul<S: Into<<Self::Scalar as PrimeField>::Repr>>(&self, by: S) -> PointProjective {\n        let bits = BitIterator::new(by.into());\n        self.mul_bits(bits)\n    }\n\n    fn negate(&mut self) {\n        if !self.is_zero() {\n            self.y.negate();\n        }\n    }\n\n    fn into_projective(&self) -> PointProjective {\n        (*self).into()\n    }\n\n    #[inline(always)]\n    fn as_xy(&self) -> (&Self::Base, &Self::Base) {\n        (&self.x, &self.y)\n    }\n\n    #[inline(always)]\n    fn into_xy_unchecked(self) -> (Self::Base, Self::Base) {\n        (self.x, self.y)\n    }\n\n    #[inline(always)]\n    fn from_xy_unchecked(x: Self::Base, y: Self::Base) -> Self {\n        let infinity = x.is_zero() && y.is_zero();\n        Self {\n            x: x,\n            y: y,\n            infinity,\n        }\n    }\n\n    fn from_xy_checked(x: Self::Base, y: Self::Base) -> Result<Self, GroupDecodingError> {\n        let infinity = x.is_zero() && y.is_zero();\n        let affine = Self {\n            x: x,\n            y: y,\n            infinity,\n        };\n\n        if !affine.is_on_curve() {\n            Err(GroupDecodingError::NotOnCurve)\n        } else {\n            Ok(affine)\n        }\n    }\n\n    fn a_coeff() -> Self::Base {\n        Self::Base::zero()\n    }\n\n    fn b_coeff() -> Self::Base {\n        Self::get_coeff_b()\n    }\n}\n\nimpl GenericCurveProjective for PointProjective {\n    type Scalar = Fr;\n    type Base = Fq;\n    type Affine = PointAffine;\n\n    // The point at infinity is always represented by\n    // Z = 0.\n    fn zero() -> Self {\n        PointProjective {\n            x: Fq::zero(),\n            y: Fq::one(),\n            z: Fq::zero(),\n        }\n    }\n\n    fn one() -> Self {\n        PointAffine::one().into()\n    }\n\n    // The point at infinity is always represented by\n    // Z = 0.\n    fn is_zero(&self) -> bool {\n        self.z.is_zero()\n    }\n\n    fn is_normalized(&self) -> bool {\n        self.is_zero() || self.z == Fq::one()\n    }\n\n    fn batch_normalization(v: &mut [Self]) {\n        // Montgomery’s Trick and Fast Implementation of Masked AES\n        // Genelle, Prouff and Quisquater\n        // Section 3.2\n\n        // First pass: compute [a, ab, abc, ...]\n        let mut prod = Vec::with_capacity(v.len());\n        let mut tmp = Fq::one();\n        for g in v\n            .iter_mut()\n            // Ignore normalized elements\n            .filter(|g| !g.is_normalized())\n        {\n            tmp.mul_assign(&g.z);\n            prod.push(tmp);\n        }\n\n        // Invert `tmp`.\n        tmp = tmp.inverse().unwrap(); // Guaranteed to be nonzero.\n\n        // Second pass: iterate backwards to compute inverses\n        for (g, s) in v\n            .iter_mut()\n            // Backwards\n            .rev()\n            // Ignore normalized elements\n            .filter(|g| !g.is_normalized())\n            // Backwards, skip last element, fill in one for last term.\n            .zip(prod.into_iter().rev().skip(1).chain(Some(Fq::one())))\n        {\n            // tmp := tmp * g.z; g.z := tmp * s = 1/z\n            let mut newtmp = tmp;\n            newtmp.mul_assign(&g.z);\n            g.z = tmp;\n            g.z.mul_assign(&s);\n            tmp = newtmp;\n        }\n\n        // Perform affine transformations\n        for g in v.iter_mut().filter(|g| !g.is_normalized()) {\n            let mut z = g.z; // 1/z\n            z.square(); // 1/z^2\n            g.x.mul_assign(&z); // x/z^2\n            z.mul_assign(&g.z); // 1/z^3\n            g.y.mul_assign(&z); // y/z^3\n            g.z = Fq::one(); // z = 1\n        }\n    }\n\n    fn double(&mut self) {\n        if self.is_zero() {\n            return;\n        }\n\n        // Other than the point at infinity, no points on E or E'\n        // can double to equal the point at infinity, as y=0 is\n        // never true for points on the curve.\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n\n        // A = X1^2\n        let mut a = self.x;\n        a.square();\n\n        // B = Y1^2\n        let mut b = self.y;\n        b.square();\n\n        // C = B^2\n        let mut c = b;\n        c.square();\n\n        // D = 2*((X1+B)2-A-C)\n        let mut d = self.x;\n        d.add_assign(&b);\n        d.square();\n        d.sub_assign(&a);\n        d.sub_assign(&c);\n        d.double();\n\n        // E = 3*A\n        let mut e = a;\n        e.double();\n        e.add_assign(&a);\n\n        // F = E^2\n        let mut f = e;\n        f.square();\n\n        // Z3 = 2*Y1*Z1\n        self.z.mul_assign(&self.y);\n        self.z.double();\n\n        // X3 = F-2*D\n        self.x = f;\n        self.x.sub_assign(&d);\n        self.x.sub_assign(&d);\n\n        // Y3 = E*(D-X3)-8*C\n        self.y = d;\n        self.y.sub_assign(&self.x);\n        self.y.mul_assign(&e);\n        c.double();\n        c.double();\n        c.double();\n        self.y.sub_assign(&c);\n    }\n\n    fn add_assign(&mut self, other: &Self) {\n        if self.is_zero() {\n            *self = *other;\n            return;\n        }\n\n        if other.is_zero() {\n            return;\n        }\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-2007-bl\n\n        // Z1Z1 = Z1^2\n        let mut z1z1 = self.z;\n        z1z1.square();\n\n        // Z2Z2 = Z2^2\n        let mut z2z2 = other.z;\n        z2z2.square();\n\n        // U1 = X1*Z2Z2\n        let mut u1 = self.x;\n        u1.mul_assign(&z2z2);\n\n        // U2 = X2*Z1Z1\n        let mut u2 = other.x;\n        u2.mul_assign(&z1z1);\n\n        // S1 = Y1*Z2*Z2Z2\n        let mut s1 = self.y;\n        s1.mul_assign(&other.z);\n        s1.mul_assign(&z2z2);\n\n        // S2 = Y2*Z1*Z1Z1\n        let mut s2 = other.y;\n        s2.mul_assign(&self.z);\n        s2.mul_assign(&z1z1);\n\n        if u1 == u2 && s1 == s2 {\n            // The two points are equal, so we double.\n            self.double();\n        } else {\n            // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n\n            if u1 == u2 {\n                // The two points are equal, so we double.\n                (*self) = Self::zero();\n                return;\n            }\n\n            // H = U2-U1\n            let mut h = u2;\n            h.sub_assign(&u1);\n\n            // I = (2*H)^2\n            let mut i = h;\n            i.double();\n            i.square();\n\n            // J = H*I\n            let mut j = h;\n            j.mul_assign(&i);\n\n            // r = 2*(S2-S1)\n            let mut r = s2;\n            r.sub_assign(&s1);\n            r.double();\n\n            // V = U1*I\n            let mut v = u1;\n            v.mul_assign(&i);\n\n            // X3 = r^2 - J - 2*V\n            self.x = r;\n            self.x.square();\n            self.x.sub_assign(&j);\n            self.x.sub_assign(&v);\n            self.x.sub_assign(&v);\n\n            // Y3 = r*(V - X3) - 2*S1*J\n            self.y = v;\n            self.y.sub_assign(&self.x);\n            self.y.mul_assign(&r);\n            s1.mul_assign(&j); // S1 = S1 * J * 2\n            s1.double();\n            self.y.sub_assign(&s1);\n\n            // Z3 = ((Z1+Z2)^2 - Z1Z1 - Z2Z2)*H\n            self.z.add_assign(&other.z);\n            self.z.square();\n            self.z.sub_assign(&z1z1);\n            self.z.sub_assign(&z2z2);\n            self.z.mul_assign(&h);\n        }\n    }\n\n    fn add_assign_mixed(&mut self, other: &Self::Affine) {\n        if other.is_zero() {\n            return;\n        }\n\n        if self.is_zero() {\n            self.x = other.x;\n            self.y = other.y;\n            self.z = Fq::one();\n            return;\n        }\n\n        // http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-madd-2007-bl\n\n        // Z1Z1 = Z1^2\n        let mut z1z1 = self.z;\n        z1z1.square();\n\n        // U2 = X2*Z1Z1\n        let mut u2 = other.x;\n        u2.mul_assign(&z1z1);\n\n        // S2 = Y2*Z1*Z1Z1\n        let mut s2 = other.y;\n        s2.mul_assign(&self.z);\n        s2.mul_assign(&z1z1);\n\n        if self.x == u2 && self.y == s2 {\n            // The two points are equal, so we double.\n            self.double();\n        } else {\n            // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n\n            // H = U2-X1\n            let mut h = u2;\n            h.sub_assign(&self.x);\n\n            // HH = H^2\n            let mut hh = h;\n            hh.square();\n\n            // I = 4*HH\n            let mut i = hh;\n            i.double();\n            i.double();\n\n            // J = H*I\n            let mut j = h;\n            j.mul_assign(&i);\n\n            // r = 2*(S2-Y1)\n            let mut r = s2;\n            r.sub_assign(&self.y);\n            r.double();\n\n            // V = X1*I\n            let mut v = self.x;\n            v.mul_assign(&i);\n\n            // X3 = r^2 - J - 2*V\n            self.x = r;\n            self.x.square();\n            self.x.sub_assign(&j);\n            self.x.sub_assign(&v);\n            self.x.sub_assign(&v);\n\n            // Y3 = r*(V-X3)-2*Y1*J\n            j.mul_assign(&self.y); // J = 2*Y1*J\n            j.double();\n            self.y = v;\n            self.y.sub_assign(&self.x);\n            self.y.mul_assign(&r);\n            self.y.sub_assign(&j);\n\n            // Z3 = (Z1+H)^2-Z1Z1-HH\n            self.z.add_assign(&h);\n            self.z.square();\n            self.z.sub_assign(&z1z1);\n            self.z.sub_assign(&hh);\n        }\n    }\n\n    fn negate(&mut self) {\n        if !self.is_zero() {\n            self.y.negate()\n        }\n    }\n\n    fn mul_assign<S: Into<<Self::Scalar as PrimeField>::Repr>>(&mut self, other: S) {\n        let mut res = Self::zero();\n\n        let mut found_one = false;\n\n        for i in BitIterator::new(other.into()) {\n            if found_one {\n                res.double();\n            } else {\n                found_one = i;\n            }\n\n            if i {\n                res.add_assign(self);\n            }\n        }\n\n        *self = res;\n    }\n\n    fn into_affine(&self) -> P"
    }
  ]
}