{
  "Title": "[M-12] Basket NFT have no name and symbol",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13\nhttps://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L6\n\n\n# Vulnerability details\n\n## Impact\nThe `Basket` contract is intended to be used behind a proxy. But the `ERC721` implementation used is not upgradeable, and its constructor is called at deployment time on the implementation. So all proxies will have a void name and symbol, breaking all potential integrations and listings.\n\n## Proof of Concept\n`ERC721(\"NFT Basket\", \"NFTB\")` is called at deployment time, and sets private variable at the implementation level. Therefore when loading the code during `delegateCall`, these variables will not be initialized.\n\n## Recommended Mitigation Steps\nThe easiest mitigation would be to pass this variable as immutable so they are hardcoded in the implementation byte code.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-nibbl-contest",
  "Code": [
    {
      "filename": "contracts/Basket.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/Basket.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}"
    }
  ]
}