{
  "Title": "[H-03] denial of service",
  "Content": "_Submitted by certora_\n\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/Pool.sol#L645>\nif the borrow token is address(0) (ether), and someone calls withdrawLiquidity, it calls SavingsAccountUtil.transferTokens which will transfer to msg.sender, msg.value (of withdrawLiquidity, because it's an internal function). In other words, the liquidity provided will pay to themselves and their liquidity tokens will still be burned. therefore they will never be able to get their funds back.\n\n#### Recommended Mitigation Steps\n\nthe bug is in\n<https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/SavingsAccount/SavingsAccountUtil.sol>\nIt is wrong to use msg.value in transferTokens because it'll be the msg.value of the calling function.\ntherefore every transfer of ether using this function is wrong and dangerous, the solution is to remove all msg.value from this function and just transfer \\_amount regularly.\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/154) **\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2021-12-sublime-contest",
  "Code": [
    {
      "filename": "contracts/Pool/Pool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IVerification.sol';\n\n/**\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    address poolFactory;\n\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n\n    /**\n     * @notice used to keep track of lenders' details\n     */\n    mapping(address => LendingDetails) public lenders;\n\n    /**\n     * @notice object of type PoolConstants\n     */\n    PoolConstants public poolConstants;\n\n    /**\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n\n    /**\n     * @notice checks if the _user is pool's valid borrower\n     * @param _user address of the borrower\n     */\n    modifier onlyBorrower(address _user) {\n        require(_user == poolConstants.borrower, 'OB1');\n        _;\n    }\n\n    /**\n     * @notice checks if the _lender is pool's valid lender\n     * @param _lender address of the lender\n     */\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, 'IL1');\n        _;\n    }\n\n    /**\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');\n        _;\n    }\n\n    /**\n     * @notice checks if the msg.sender is pool's latest repayment implementation\n     */\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');\n        _;\n    }\n\n    /**\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     */\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init('Pool Tokens', 'PT');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n\n    /**\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, 'DC1');\n        require(balanceOf(msg.sender) == 0, 'DC2');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n\n    /**\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n\n    /**\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     */\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n\n    /**\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n\n    /**\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet\n     */\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');\n        require(balanceOf(msg.sender) == 0, 'ACMC2');\n        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');\n\n        require(_amount != 0, 'ACMC4');\n\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n\n        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n\n    /**\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     */\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &&\n                poolConstants.loanStartTime < block.timestamp &&\n                block.timestamp < poolConstants.loanWithdrawalDeadline,\n            'WBA1'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');\n\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');\n\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);\n        delete poolConstants.loanWithdrawalDeadline;\n\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n\n    /**\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n\n    /**\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     */\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower && _borrower != msg.sender, 'L1');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n\n    /**\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), 'TT1');\n        }\n        require(_to != poolConstants.borrower, 'TT2');\n\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');\n        }\n        require(getMarginCallEndTime(_from) == 0, 'TT3');\n        require(getMarginCallEndTime(_to) == 0, 'TT4');\n\n        //Withdraw repayments for user\n\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp > _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp > _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n\n    /**\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n\n        if (\n            _loanStartTime < block.timestamp &&\n            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)\n        ) {\n            return _cancelPool(0);\n        }\n\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n\n        if (_loanWithdrawalDeadline > block.timestamp) {\n            require(msg.sender == poolConstants.borrower, 'CP2');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(10**30)\n            .mul(_collateralLiquidityShare)\n            .div(10**30)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n\n    /**\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n\n    /**\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     */\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');\n        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n\n    /**\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     */\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n\n    /**\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');\n\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n\n        emit PoolClosed();\n    }\n\n    /**\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     */\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            'WL1'\n        );\n\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n\n    /**\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     */\n\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');\n        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');\n\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n\n        emit MarginCalled(msg.sender);\n    }\n\n    /**\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(10**30);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));\n        if (_loanDurationTillNow <= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);\n\n        return _interestAccrued;\n    }\n\n    /**\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));\n    }\n\n    /**\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n\n    /**\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     */\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n\n    /**\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     */\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables."
    }
  ]
}