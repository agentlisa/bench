{
  "Title": "H-5: LUP is not recalculated after adding kicking penalty to pool's debt, so kick() updates the pool state with an outdated LUP",
  "Content": "# Issue H-5: LUP is not recalculated after adding kicking penalty to pool's debt, so kick() updates the pool state with an outdated LUP \n\nSource: https://github.com/sherlock-audit/2023-04-ajna-judging/issues/107 \n\n## Found by \nChinmay, hyh\n## Summary\n\n_kick() first calculates LUP, then adds kicking penalty, so the LUP returned without recalculation doesn't include the penalty and this way is outdated whenever it is not zero.\n\n## Vulnerability Detail\n\nkick() and kickWithDeposit() (when deposit doesn't have any excess over the needed bond) returns _kick() calculated LUP, which is generally higher then real one being calculated before kicking penalty was added to the total debt.\n\n## Impact\n\nkick() is one of the base frequently used operations, so the state of the pool will be frequently enough updated with incorrect LUP and `EMA of LUP * t0 debt` internal accounting variable be systematically biased, which leads to incorrect interest rate dynamics of the pool.\n\nThere is no low-probability prerequisites and the impact is a bias in interest rate calculations, so setting the severity to be high.\n\n## Code Snippet\n\nkick() updates the `poolState` with _kick() returned `result.lup`:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/base/Pool.sol#L277-L313\n\n```solidity\n    function kick(\n        address borrower_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n>>      KickResult memory result = KickerActions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrower_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.debt            =  Maths.wmul(result.t0PoolDebt, poolState.inflator);\n        poolState.t0Debt          =  result.t0PoolDebt;\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.debtPreAction,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0  // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          = poolState.t0Debt;\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n        // update pool interest rate state\n>>      _updateInterestState(poolState, result.lup);\n\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/KickerActions.sol#L115-L134\n\n```solidity\n    function kick(\n        ...\n    ) external returns (\n        KickResult memory\n    ) {\n>>      return _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrowerAddress_,\n            limitIndex_,\n            0\n        );\n    }\n```\n\nIn _kick() kicking penalty is added to the total debt of the pool:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/KickerActions.sol#L438-L446\n\n```solidity\n        // when loan is kicked, penalty of three months of interest is added\n>>      vars.t0KickPenalty = Maths.wdiv(Maths.wmul(kickResult_.t0KickedDebt, poolState_.rate), 4 * 1e18);\n        vars.kickPenalty   = Maths.wmul(vars.t0KickPenalty, poolState_.inflator);\n\n>>      kickResult_.t0PoolDebt   = poolState_.t0Debt + vars.t0KickPenalty;\n        kickResult_.t0KickedDebt += vars.t0KickPenalty;\n\n        // update borrower debt with kicked debt penalty\n        borrower.t0Debt = kickResult_.t0KickedDebt;\n```\n\nWhile the function calculates LUP before that (for _isCollateralized() check) and does not recalculate it after the penalty was added:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/KickerActions.sol#L364-L442\n\n```solidity\n    function _kick(\n        ...\n    ) internal returns (\n        KickResult memory kickResult_\n    ) {\n        ...\n        // add amount to remove to pool debt in order to calculate proposed LUP\n>>      kickResult_.lup          = Deposits.getLup(deposits_, poolState_.debt + additionalDebt_);\n\n        ...\n\n        // when loan is kicked, penalty of three months of interest is added\n        vars.t0KickPenalty = Maths.wdiv(Maths.wmul(kickResult_.t0KickedDebt, poolState_.rate), 4 * 1e18);\n        vars.kickPenalty   = Maths.wmul(vars.t0KickPenalty, poolState_.inflator);\n\n>>      kickResult_.t0PoolDebt   = poolState_.t0Debt + vars.t0KickPenalty;\n```\n\nkickWithDeposit() returns _kick() calculated `kickResult_.lup` (i.e. before kick penalty) whenever `vars.amountToDebitFromDeposit <= kickResult_.amountToCoverBond`:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/KickerActions.sol#L190-L216\n\n```solidity\n        // kick top borrower\n>>      kickResult_ = _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            Loans.getMax(loans_).borrower,\n            limitIndex_,\n            vars.amountToDebitFromDeposit\n        );\n\n        // amount to remove from deposit covers entire bond amount\n        if (vars.amountToDebitFromDeposit > kickResult_.amountToCoverBond) {\n            // cap amount to remove from deposit at amount to cover bond\n            vars.amountToDebitFromDeposit = kickResult_.amountToCoverBond;\n\n            // recalculate the LUP with the amount to cover bond\n            kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit);\n            // entire bond is covered from deposit, no additional amount to be send by lender\n            kickResult_.amountToCoverBond = 0;\n>>      } else {\n            // lender should send additional amount to cover bond\n            kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;\n        }\n\n        // revert if the bucket price used to kick and remove is below new LUP\n        if (vars.bucketPrice < kickResult_.lup) revert PriceBelowLUP();\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using initial LUP for _isCollateralized() check in _kick() as `additionalDebt_` is zero in plain kick() case, and calculating the final LUP at the end of _kick().\n\nConsider refactoring kickWithDeposit(): for example, calculating the LUP therein with the corresponding `additionalDebt_` after _kick() call, and adding the flag to _kick() call to indicate that LUP calculation isn't needed.\n\n\n\n## Discussion\n\n**grandizzy**\n\npart of PR https://github.com/ajna-finance/contracts/pull/894 that change `kickWithDeposit` functionality\nhttps://github.com/ajna-finance/contracts/pull/894/files#diff-54056532b4b7aac8940fbec13725e98ceceb358bef02e1285edad2741dff83bdR363\n\n\n**dmitriia**\n\n> part of PR [ajna-finance/contracts#894](https://github.com/ajna-finance/contracts/pull/894) that change `kickWithDeposit` functionality https://github.com/ajna-finance/contracts/pull/894/files#diff-54056532b4b7aac8940fbec13725e98ceceb358bef02e1285edad2741dff83bdR363\n\nFix looks good, `_kick()` is the last operation in `kick()` and `lenderKick()` (which is the new version of `kickWithDeposit()`), and LUP is calculated in `_kick()` after all the changes off final structures.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/75",
  "Code": [
    {
      "filename": "ajna-core/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolBorrowerActions,\n    IPoolLPActions,\n    IPoolLenderActions,\n    IPoolKickerActions,\n    IPoolTakerActions,\n    IPoolSettlerActions,\n    IPoolState,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    LoansState,\n    InflatorState,\n    EmaState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    BurnEvent,\n    Liquidation\n}                                   from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    SettleResult,\n    TakeResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams,\n    KickReserveAuctionParams\n}                                   from '../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable,\n    _revertAfterExpiry\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { LPActions }       from '../libraries/external/LPActions.sol';\nimport { KickerActions }   from '../libraries/external/KickerActions.sol';\nimport { TakerActions }    from '../libraries/external/TakerActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both `ERC20` and `ERC721` pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /// @dev Immutable pool type arg offset.\n    uint256 internal constant POOL_TYPE          = 0;\n    /// @dev Immutable `Ajna` token address arg offset.\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    /// @dev Immutable collateral token address arg offset.\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    /// @dev Immutable quote token address arg offset.\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    /// @dev Immutable quote token scale arg offset.\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    EmaState            internal emaState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    /// @dev deposit index -> bucket mapping\n    mapping(uint256 => Bucket) internal buckets;\n\n    bool internal isPoolInitialized;\n\n    /// @dev owner address -> new owner address -> deposit index -> allowed amount mapping\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpAllowances;\n\n    /// @dev owner address -> transferor address -> approved flag mapping\n    mapping(address => mapping(address => bool)) public override approvedTransferors;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 amount_,\n        uint256 index_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 bucketLP_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        amount_ = _roundToScale(amount_, poolState.quoteTokenScale);\n\n        uint256 newLup;\n        (bucketLP_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: amount_,\n                index:  index_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmount_,\n        uint256 fromIndex_,\n        uint256 toIndex_,\n        uint256 expiry_\n    ) external override nonReentrant returns (uint256 fromBucketLP_, uint256 toBucketLP_, uint256 movedAmount_) {\n        _revertAfterExpiry(expiry_);\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, fromIndex_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            fromBucketLP_,\n            toBucketLP_,\n            movedAmount_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            MoveQuoteParams({\n                maxAmountToMove: maxAmount_,\n                fromIndex:       fromIndex_,\n                toIndex:         toIndex_,\n                thresholdPrice:  Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLP_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolState.t0DebtInAuction, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLP_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      Maths.min(maxAmount_, _availableQuoteToken()),\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function updateInterest() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n        _updateInterestState(poolState, Deposits.getLup(deposits, poolState.debt));\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /// @inheritdoc IPoolBorrowerActions\n    function stampLoan() external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 newLup = BorrowerActions.stampLoan(\n            auctions,\n            deposits,\n            loans,\n            poolState\n        );\n\n        _updateInterestState(poolState, newLup);\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `poolBalances.t0DebtInAuction` and `poolBalances.t0Debt` accumulators\n     *  @dev    update `t0Debt2ToCollateral` ratio, debt and collateral post action are considered 0\n     */\n    function kick(\n        address borrower_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = KickerActions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrower_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.debt            =  Maths.wmul(result.t0PoolDebt, poolState.inflator);\n        poolState.t0Debt          =  result.t0PoolDebt;\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.debtPreAction,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0  // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          = poolState.t0Debt;\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `poolBalances.t0DebtInAuction` and `poolBalances.t0Debt` accumulators\n     *  @dev    update `t0Debt2ToCollateral` ratio, debt and collateral post action are considered 0\n     */\n    function kickWithDeposit(\n        uint256 index_,\n        uint256 npLimitIndex_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = KickerActions.kickWithDeposit(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_,\n            npLimitIndex_\n        );\n\n        // update in memory pool state struct\n        poolState.debt            =  Maths.wmul(result.t0PoolDebt, poolState.inflator);\n        poolState.t0Debt          =  result.t0PoolDebt;\n        poolState.t0DebtInAuction += result.t0KickedDebt;\n\n        // adjust t0Debt2ToCollateral ratio\n        _updateT0Debt2ToCollateral(\n            result.debtPreAction,\n            0, // debt post kick (for loan in auction) not taken into account\n            result.collateralPreAction,\n            0 // collateral post kick (for loan in auction) not taken into account\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          = poolState.t0Debt;\n        poolBalances.t0DebtInAuction = poolState.t0DebtInAuction;\n\n        // update pool interest rate state\n        _updateInterestState(poolState, result.lup);\n\n        // transfer from kicker to pool the difference to cover bond\n        if (result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    decrease kicker's `claimable` accumulator\n     *  @dev    decrease auctions `totalBondEscrowed` accumulator\n     */\n    function withdrawBonds(\n        address recipient_,\n        uint256 maxAmount_\n    ) external override nonReentrant {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n\n        // the amount to claim is constrained by the claimable balance of sender\n        // claiming escrowed bonds is not constraiend by the pool balance\n        maxAmount_ = Maths.min(maxAmount_, claimable);\n\n        // revert if no amount to claim\n        if (maxAmount_ == 0) revert InsufficientLiquidity();\n\n        // decrement total bond escrowed\n        auctions.totalBondEscrowed             -= maxAmount_;\n        auctions.kickers[msg.sender].claimable -= maxAmount_;\n\n        emit BondWithdrawn(msg.sender, recipient_, maxAmount_);\n\n        _transferQuoteToken(recipient_, maxAmount_);\n    }\n\n    /*********************************/\n    /*** Reserve Auction Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IPoolKickerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `latestBurnEpoch` counter\n     *  @dev    update `reserveAuction.latestBurnEventEpoch` and burn event `timestamp` state\n     *  @dev    === Reverts on ===\n     *  @dev    2 weeks not passed `ReserveAuctionTooSoon()`\n     *  @dev    === Emit events ===\n     *  @dev    - `KickReserveAuction`\n     */\n    function kickReserveAuction() external override nonReentrant {\n        // start a new claimable reserve auction, passing in relevant parameters such as the current pool size, debt, balance, and inflator value\n        uint256 kickerAward = KickerActions.kickReserveAuction(\n            auctions,\n            reserveAuction,\n            KickReserveAuctionParams({\n                poolSize:    Deposits.treeSum(deposits),\n                t0PoolDebt:  poolBalances.t0Debt,\n                poolBalance: _getNormalizedPoolQuoteTokenBalance(),\n                inflator:    inflatorState.inflator\n            })\n        );\n\n        // transfer kicker award to msg.sender\n        _transferQuoteToken(msg.sender, kickerAward);\n    }\n\n    /**\n     *  @inheritdoc IPoolTakerActions\n     *  @dev    === Write state ===\n     *  @dev    increment `reserveAuction.totalAjnaBurned` accumulator\n     *  @dev    update burn event `totalInterest` and `totalBurned` accumulators\n     */\n    function takeReserves(\n        uint256 maxAmount_\n    ) external override nonReentrant returns (uint256 amount_) {\n        uint256 ajnaRequired;\n        (amount_, ajnaRequired) = TakerActions.takeReserves(\n            reserveAuction,\n            maxAmount_\n        );\n\n        // burn required number of ajna tokens to take quote from reserves\n        IERC20(_getArgAddress(AJNA_ADDRESS)).safeTransferFrom(msg.sender, address(this), ajnaRequired);\n\n        IERC20Token(_getArgAddress(AJNA_ADDRESS)).burn(ajnaRequired);\n\n        // transfer quote token to caller\n        _transferQuoteToken(msg.sender, amount_);\n    }\n\n    /*****************************/\n    /*** Transfer LP Functions ***/\n    /*****************************/\n\n    /// @inheritdoc IPoolLPActions\n    function increaseLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_,\n        uint256[] calldata amounts_\n    ) external override nonReentrant {\n        LPActions.increaseLPAllowance(\n            _lpAllowances[msg.sender][spender_],\n            spender_,\n            indexes_,\n            amounts_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function decreaseLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_,\n        uint256[] calldata amounts_\n    ) external override nonReentrant {\n        LPActions.decreaseLPAllowance(\n            _lpAllowances[msg.sender][spender_],\n            spender_,\n            indexes_,\n            amounts_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function revokeLPAllowance(\n        address spender_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LPActions.revokeLPAllowance(\n            _lpAllowances[msg.sender][spender_],\n            spender_,\n            indexes_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function approveLPTransferors(\n        address[] calldata transferors_\n    ) external override {\n        LPActions.approveLPTransferors(\n            approvedTransferors[msg.sender],\n            transferors_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function revokeLPTransferors(\n        address[] calldata transferors_\n    ) external override {\n        LPActions.revokeLPTransferors(\n            approvedTransferors[msg.sender],\n            transferors_\n        );\n    }\n\n    /// @inheritdoc IPoolLPActions\n    function transferLP(\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LPActions.transferLP(\n            buckets,\n            _lpAllowances,\n            approvedTransferors,\n            owner_,\n            newOwner_,\n            indexes_\n        );\n    }\n\n    /*****************************/\n    /*** Pool Helper Functions ***/\n    /*****************************/\n\n    /**\n     *  @notice Accrues pool interest in current block and returns pool details.\n     *  @dev    external libraries call: `PoolCommons.accrueInterest`\n     *  @dev    === Write state ===\n     *  @dev    - `PoolCommons.accrueInterest` - `Deposits.mult` (scale `Fenwick` tree with new interest accrued):\n     *  @dev      update scaling array state \n     *  @dev    - increment `reserveAuction.totalInterestEarned` accumulator\n     *  @return poolState_ Struct containing pool details.\n     */\n    function _accruePoolInterest() internal returns (PoolState memory poolState_) {\n        poolState_.t0Debt          = poolBalances.t0Debt;\n        poolState_.t0DebtInAuction = poolBalances.t0DebtInAuction;\n        poolState_.collateral      = poolBalances.pledgedCollateral;\n        poolState_.inflator        = inflatorState.inflator;\n        poolState_.rate            = interestState.interestRate;\n        poolState_.poolType        = _getArgUint8(POOL_TYPE);\n        poolState_.quoteTokenScale = _getArgUint256(QUOTE_SCALE);\n\n\t    // check if t0Debt is not equal to 0, indicating that there is debt to be tracked for the pool\n        if (poolState_.t0Debt != 0) {\n            // Calculate prior pool debt\n            poolState_.debt = Maths.wmul(poolState_.t0Debt, poolState_.inflator);\n\n\t        // calculate elapsed time since inflator was last updated\n            uint256 elapsed = block.timestamp - inflatorState.inflatorUpdate;\n\n\t        // set isNewInterestAccrued field to true if elapsed time is not 0, indicating that new interest may have accrued\n            poolState_.isNewInterestAccrued = elapsed != 0;\n\n            // if new interest may have accrued, call accrueInterest function and update inflator and debt fields of poolState_ struct\n            if (poolState_.isNewInterestAccrued) {\n                (uint256 newInflator, uint256 newInterest) = PoolCommons.accrueInterest(\n                    emaState,\n                    deposits,\n                    poolState_,\n                    Loans.getMax(loans).thresholdPrice,\n                    elapsed\n                );\n                poolState_.inflator = newInflator;\n                // After debt owed to lenders has accrued, calculate current debt owed by borrowers\n                poolState_.debt = Maths.wmul(poolState_.t0Debt, poolState_.inflator);\n\n                // update total interest earned accumulator with the newly accrued interest\n                reserveAuction.totalInterestEarned += newInterest;\n            }\n        }\n    }\n\n    /**\n     *  @notice Helper function to update pool state post take and bucket take actions.\n     *  @param result_    Struct containing details of take result.\n     *  @param poolState_ Struct containing pool details.\n     */\n    function _updatePostTakeState(\n        TakeResult memory result_,\n        PoolState memory poolState_\n    ) internal {\n        // update in memory pool state struct\n        poolState_.debt            =  result_.poolDebt;\n        poolState_.t0Debt          =  result_.t0PoolDebt;\n        poolState_.t0DebtInAuction += result_.t0DebtPenalty;\n        poolState_.t0DebtInAuction -= result_.t0DebtInAuctionChange;\n        poolState_.collateral      -= (result_.collateralAmount + result_.compensatedCollateral); // deduct collateral taken plus collateral compensated if NFT auction settled\n\n        // adjust t0Debt2ToCollateral ratio if auction settled by take action\n        if (result_.settledAuction) {\n            _updateT0Debt2ToCollateral(\n                0, // debt pre take (for loan in auction) not taken into account\n                result_.debtPostAction,\n                0, // collateral pre take (for loan in auction) not taken into account\n                result_.collateralPostAction\n            );\n        }\n\n        // update pool balances state\n        poolBalances.t0Debt            = poolState_.t0Debt;\n        poolBalances.t0DebtInAuction   = poolState_.t0DebtInAuction;\n        poolBalances.pledgedCollateral = poolState_.collateral;\n        // update pool interest rate state\n        _updateInterestState(poolState_, result_.newLup);\n    }\n\n    /**\n     *  @notice Helper function to update pool state post settle action.\n     *  @param result_    Struct containing details of settle result.\n     *  @param poolState_ Struct containing pool details.\n     */\n    function _updatePostSettleState(\n        SettleResult memory result_,\n        PoolState memory poolState_\n    ) internal {\n        // update in memory pool state struct\n        poolState_.debt            -= Maths.wmul(result_.t0DebtSettled, poolState_.inflator);\n        poolState_.t0Debt          -= result_.t0DebtSettled;\n        poolState_.t0DebtInAuction -= result_.t0DebtSettled;\n        poolState_.collateral      -= result_.collateralSettled;\n\n        // update pool balances state\n        poolBalances.t0Debt            = poolState_.t0Debt;\n        poolBalances.t0DebtInAuction   = poolState_.t0DebtInAuction;\n        poolBalances.pledgedCollateral = poolState_.collateral;\n        // update pool interest rate state\n        _updateInterestState(poolState_, Deposits.getLup(deposits, poolState_.debt));\n    }\n\n    /**\n     *  @notice Adjusts the `t0` debt 2 to collateral ratio, `interestState.t0Debt2ToCollateral`.\n     *  @dev    Anytime a borrower's debt or collateral changes, the `interestState.t0Debt2ToCollateral` must be updated.\n     *  @dev    === Write state ===\n     *  @dev    update `interestState.t0Debt2ToCollateral` accumulator\n     *  @param debtPreAction_  Borrower's debt before the action\n     *  @param debtPostAction_ Borrower's debt after the action\n     *  @param colPreAction_   Borrower's collateral before the action\n     *  @param colPostAction_  Borrower's collateral after the action\n     */\n    function _updateT0Debt2ToCollateral(\n        uint256 debtPreAction_,\n        uint256 debtPostAction_,\n        uint256 colPreAction_,\n        uint256 colPostAction_\n    ) internal {\n        uint256 debt2ColAccumPreAction  = colPreAction_  != 0 ? debtPreAction_  ** 2 / colPreAction_  : 0;\n        uint256 debt2ColAccumPostAction = colPostAction_ != 0 ? debtPostAction_ ** 2 / colPostAction_ : 0;\n\n        if (debt2ColAccumPreAction != 0 || debt2ColAccumPostAction != 0) {\n            uint256 curT0Debt2ToCollateral = interestState.t0Debt2ToCollateral;\n            curT0Debt2ToCollateral += debt2ColAccumPostAction;\n            curT0Debt2ToCollateral -= debt2ColAccumPreAction;\n\n            interestState.t0Debt2ToCollateral = curT0Debt2ToCollateral;\n        }\n    }\n\n    /**\n     *  @notice Update interest rate and inflator of the pool.\n     *  @dev    external libraries call: `PoolCommons.updateInterestState`\n     *  @dev    === Write state ===\n     *  @dev    - `PoolCommons.updateInterestState`\n     *  @dev      `EMA`s accumulators\n     *  @dev      interest rate accumulator and `interestRateUpdate` state\n     *  @dev      pool inflator and `inflatorUpdate` state\n     *  @dev    === Emit events ===\n     *  @dev    `PoolCommons.updateInterestState`: `UpdateInterestRate`\n     *  @param  poolState_ Struct containing pool details.\n     *  @param  lup_       Current `LUP` in pool.\n     */\n    function _updateInterestState(\n        PoolState memory poolState_,\n        uint256 lup_\n    ) internal {\n\n        PoolCommons.updateInterestState(interestState, emaState, deposits, poolState_, lup_);\n\n        // update pool inflator\n        if (poolState_.isNewInterestAccrued) {\n            inflatorState.inflator       = uint208(poolState_.inflator);\n            inflatorState.inflatorUpdate = uint48(block.timestamp);\n        // if the debt in the current pool state is 0, also update the inflator and inflatorUpdate fields in inflatorState\n        // slither-disable-next-line incorrect-equality\n        } else if (poolState_.debt == 0) {\n            inflatorState.inflator       = uint208(Maths.WAD);\n            inflatorState.inflatorUpdate = uint48(block.timestamp);\n        }\n    }\n\n    /**\n     *  @notice Helper function to transfer amount of quote tokens from sender to pool contract.\n     *  @param  from_    Sender address.\n     *  @param  amount_  Amount to transfer from sender (`WAD` precision). Scaled to quote token precision before transfer.\n     */\n    function _transferQuoteTokenFrom(address from_, uint256 amount_) internal {\n        // Transfer amount in favour of the pool\n        uint256 transferAmount = Maths.ceilDiv(amount_, _getArgUint256(QUOTE_SCALE));\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransferFrom(from_, address(this), transferAmount);\n    }\n\n    /**\n     *  @notice Helper function to transfer amount of quote tokens from pool contract.\n     *  @param  to_     Receiver address.\n     *  @param  amount_ Amount to transfer to receiver (`WAD` precision). Scaled to quote token precision before transfer.\n     */\n    function _transferQuoteToken(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(QUOTE_SCALE));\n    }\n\n    /**\n     *  @notice Returns the quote token amount available to take loans or to be removed from pool.\n     *          Ensures claimable reserves and auction bonds are not used when taking loans.\n     */\n    function _availableQuoteToken() internal view returns (uint256 quoteAvailable_) {\n        uint256 poolBalance     = _getNormalizedPoolQuoteTokenBalance();\n        uint256 escrowedAmounts = auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        if (poolBalance > escrowedAmounts) quoteAvailable_ = poolBalance - escrowedAmounts;\n    }\n\n    /**\n     *  @notice Returns the pool quote token balance normalized to `WAD` to be used for calculating pool reserves.\n     */\n    function _getNormalizedPoolQuoteTokenBalance() internal view returns (uint256) {\n        return IERC20(_getArgAddress(QUOTE_ADDRESS)).balanceOf(address(this)) * _getArgUint256(QUOTE_SCALE);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /*******************************/\n\n    /// @inheritdoc IPoolState\n    function auctionInfo(\n        address borrower_\n    ) external\n    view override returns (\n        address kicker_,\n        uint256 bondFactor_,\n        uint256 bondSize_,\n        uint256 kickTime_,\n        uint256 kickMomp_,\n        uint256 neutralPrice_,\n        address head_,\n        address next_,\n        address prev_,\n        bool alreadyTaken_\n    ) {\n        Liquidation memory liquidation = auctions.liquidations[borrower_];\n        return (\n            liquidation.kicker,\n            liquidation.bondFactor,\n            liquidation.bondSize,\n            liquidation.kickTime,\n            liquidation.kickMomp,\n            liquidation.neutralPrice,\n            auctions.head,\n            liquidation.next,\n            liquidation.prev,\n            liquidation.alreadyTaken\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function borrowerInfo(\n        address borrower_\n    ) external view override returns (uint256, uint256, uint256) {\n        return (\n            loans.borrowers[borrower_].t0Debt,\n            loans.borrowers[borrower_].collateral,\n            loans.borrowers[borrower_].t0Np\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function bucketInfo(\n        uint256 index_\n    ) external view override returns (uint256, uint256, uint256, uint256, uint256) {\n        uint256 scale = Deposits.scale(deposits, index_);\n        return (\n            buckets[index_].lps,\n            buckets[index_].collateral,\n            buckets[index_].bankruptcyTime,\n            Maths.wmul(scale, Deposits.unscaledValueAt(deposits, index_)),\n            scale\n        );\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function bucketExchangeRate(\n        uint256 index_\n    ) external view returns (uint256 exchangeRate_) {\n        Bucket storage bucket = buckets[index_];\n\n        exchangeRate_ = Buckets.getExchangeRate(\n            bucket.collateral,\n            bucket.lps,\n            Deposits.valueAt(deposits, index_),\n            _priceAt(index_)\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function currentBurnEpoch() external view returns (uint256) {\n        return reserveAuction.latestBurnEventEpoch;\n    }\n\n    /// @inheritdoc IPoolState\n    function burnInfo(uint256 burnEventEpoch_) external view returns (uint256, uint256, uint256) {\n        BurnEvent memory burnEvent = reserveAuction.burnEvents[burnEventEpoch_];\n\n        return (\n            burnEvent.timestamp,\n            burnEvent.totalInterest,\n            burnEvent.totalBurned\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function debtInfo() external view returns (uint256, uint256, uint256, uint256) {\n        uint256 pendingInflator = PoolCommons.pendingInflator(\n            inflatorState.inflator,\n            inflatorState.inflatorUpdate,\n            interestState.interestRate\n        );\n        return (\n            Maths.ceilWmul(poolBalances.t0Debt, pendingInflator),\n            Maths.ceilWmul(poolBalances.t0Debt, inflatorState.inflator),\n            Maths.ceilWmul(poolBalances.t0DebtInAuction, inflatorState.inflator),\n            interestState.t0Debt2ToCollateral\n        );\n    }\n\n\n    /// @inheritdoc IPoolDerivedState\n    function depositUpToIndex(uint256 index_) external view override returns (uint256) {\n        return Deposits.prefixSum(deposits, index_);\n    }\n    \n    /// @inheritdoc IPoolDerivedState\n    function depositIndex(uint256 debt_) external view override returns (uint256) {\n        return Deposits.findIndexOfSum(deposits, debt_);\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositSize() external view override returns (uint256) {\n        return Deposits.treeSum(deposits);\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositUtilization() external view override returns (uint256) {\n        return PoolCommons.utilization(emaState);\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function depositScale(uint256 index_) external view override returns (uint256) {\n        return deposits.scaling[index_];\n    }\n\n    /// @inheritdoc IPoolState\n    function emasInfo() external view override returns (uint256, uint256, uint256, uint256) {\n        return (\n            emaState.debtColEma,\n            emaState.lupt0DebtEma,\n            emaState.debtEma,\n            emaState.depositEma\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function inflatorInfo() external view override returns (uint256, uint256) {\n        return (\n            inflatorState.inflator,\n            inflatorState.inflatorUpdate\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function interestRateInfo() external view returns (uint256, uint256) {\n        return (\n            interestState.interestRate,\n            interestState.interestRateUpdate\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function kickerInfo(\n        address kicker_\n    ) external view override returns (uint256, uint256) {\n        return(\n            auctions.kickers[kicker_].claimable,\n            auctions.kickers[kicker_].locked\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function lenderInfo(\n        uint256 index_,\n        address lender_\n    )"
    }
  ]
}