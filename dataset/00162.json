{
  "Title": "M-16: The cycle payment due may span over approx. 2 cycles and block the borrower from paying",
  "Content": "# Issue M-16: The cycle payment due may span over approx. 2 cycles and block the borrower from paying \n\nSource: https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/285 \n\n## Found by \nCodeWasp\n## Summary\n\nIf a borrower makes the expected cycle payment early in the first payment cycle and then tries to make the cycle payment in the second cycle, the payment reverts, due to insufficient amount.\n\n## Vulnerability Detail\n\nConsider the following bid parameters:\n\n - Principal amount: `30000`\n - acceptedTimestamp: `100`\n - lastRepaidTimestamp: `100 + 1 * 24 * 3600` (1 day after the bid was accepted)\n - loanDuration: `3 * 30 * 24 * 3600` ( 3 months)\n - totalRepaid: `Payment({ principal: 10000, interest: 200 })`\n - Terms:\n    paymentCycleAmount: `10000` (pay `10000` each month)\n    paymentCycle: `30 * 24 * 3600` (1 month)\n    APR: `1200` (12%)\n - State: `BidState.PENDING`\n - paymentType: `PaymentType.EMI`\n\nIn our example, the borrower has already paid the minimum amount for the first month, 1 day after the bid was accepted, by calling `repayLoan(bidId, 10000)`. Now, the borrower calls `TellerV2::repayLoanMinimum` to make their regular payment on the day 58, that is, `block.timestamp == 100 + 58 * 24 * 3600`. Since the borrower has paid for the first month already, they would expect the minimum amount to be `10000` plus interest, that is, the payment for the second cycle. However, the call to `TellerV2::repayLoanMinimum` reverts, if the borrower approves only `10000` plus interest (below `300`).\n\nThe call reverts, as the minimum expected payment is now `19000`, which is close to the total owed amount (`20000` + interest). This can be clearly seen, when the borrower calls `repayLoan(bidId, 10000 + 300)`:\n\n```\n  [Revert] PaymentNotMinimum(1, 10300 [1.03e4], 19000 [1.9e4])\n```\n\nThe root cause of this issue is the computation in `V2Calculations::calculateAmountOwed`:\n\n```js\n>> uint256 owedTime = _timestamp - uint256(_lastRepaidTimestamp);\n   ...\n   if (_bid.paymentType == PaymentType.Bullet) {\n     ...\n   } else {\n        // Default to PaymentType.EMI\n        // Max payable amount in a cycle\n        // NOTE: the last cycle could have less than the calculated payment amount\n        uint256 owedAmount = isLastPaymentCycle\n            ? owedPrincipal_ + interest_\n>>          : (_bid.terms.paymentCycleAmount * owedTime) /\n                _paymentCycleDuration;\n\n        duePrincipal_ = Math.min(owedAmount - interest_, owedPrincipal_);\n   }\n```\n\nBasically, when the difference between two payments in `owedTime` is closer to two cycles, the borrower has to make two payment, notwithstanding the actual payment schedule.\n\nA detailed unit test using `TellerV2_Override`:\n\n<details>\n  <summary>See the complete unit test</summary>\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { StdStorage, stdStorage } from \"forge-std/StdStorage.sol\";\nimport { Testable } from \"../Testable.sol\";\nimport { TellerV2_Override } from \"./TellerV2_Override.sol\";\n\nimport { Bid, BidState, Collateral, Payment, LoanDetails, Terms, ActionNotAllowed } from \"../../contracts/TellerV2.sol\";\nimport { PaymentType, PaymentCycleType } from \"../../contracts/libraries/V2Calculations.sol\";\n\nimport { ReputationManagerMock } from \"../../contracts/mock/ReputationManagerMock.sol\";\nimport { CollateralManagerMock } from \"../../contracts/mock/CollateralManagerMock.sol\";\nimport { LenderManagerMock } from \"../../contracts/mock/LenderManagerMock.sol\";\nimport { MarketRegistryMock } from \"../../contracts/mock/MarketRegistryMock.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../tokens/TestERC20Token.sol\";\n\nimport \"lib/forge-std/src/console.sol\";\n\ncontract audit_TellerV2_bids_test is Testable {\n    using stdStorage for StdStorage;\n\n    TellerV2_Override tellerV2;\n\n    TestERC20Token lendingToken;\n\n    TestERC20Token lendingTokenZeroDecimals;\n\n    User borrower;\n    User lender;\n    User receiver;\n\n    User marketOwner;\n\n    User feeRecipient;\n\n    MarketRegistryMock marketRegistryMock;\n\n    ReputationManagerMock reputationManagerMock;\n    CollateralManagerMock collateralManagerMock;\n    LenderManagerMock lenderManagerMock;\n\n    uint256 marketplaceId = 100;\n\n    //have to copy and paste events in here to expectEmit\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    function setUp() public {\n        tellerV2 = new TellerV2_Override();\n\n        marketRegistryMock = new MarketRegistryMock();\n        reputationManagerMock = new ReputationManagerMock();\n        collateralManagerMock = new CollateralManagerMock();\n        lenderManagerMock = new LenderManagerMock();\n\n        borrower = new User();\n        lender = new User();\n        receiver = new User();\n\n        marketOwner = new User();\n        feeRecipient = new User();\n\n        lendingToken = new TestERC20Token(\"Wrapped Ether\", \"WETH\", 1e30, 18);\n        lendingTokenZeroDecimals = new TestERC20Token(\n            \"Wrapped Ether\",\n            \"WETH\",\n            1e16,\n            0\n        );\n    }\n\n    function setMockBid(uint256 bidId) public {\n        tellerV2.mock_setBid(\n            bidId,\n            Bid({\n                borrower: address(borrower),\n                lender: address(lender),\n                receiver: address(receiver),\n                marketplaceId: marketplaceId,\n                _metadataURI: \"0x1234\",\n                loanDetails: LoanDetails({\n                    lendingToken: lendingToken,\n                    principal: 30000,\n                    timestamp: 100,\n                    acceptedTimestamp: 100,\n                    lastRepaidTimestamp: 100 + 1 * 24 * 3600, // 1 day after\n                    loanDuration: 3 * 30 * 24 * 3600, // 3 months\n                    totalRepaid: Payment({ principal: 10000, interest: 200 })\n                }),\n                terms: Terms({\n                    paymentCycleAmount: 10000,      // pay 10000\n                    paymentCycle: 30 * 24 * 3600,   // each month\n                    APR: 1200                       // 12%\n                }),\n                state: BidState.PENDING,\n                paymentType: PaymentType.EMI\n            })\n        );\n    }\n\n    function test_repay_loan_close_to_two_months() public {\n        uint256 bidId = 1;\n        setMockBid(bidId);\n\n        tellerV2.mock_setBidState(bidId, BidState.ACCEPTED);\n        // warp by 58 days since the bid was accepted\n        vm.warp(100 + 58 * 24 * 3600);\n\n        assertEq(block.timestamp, 100 + 58 * 24 * 3600);\n\n        //set the account that will be paying the loan off\n        tellerV2.setMockMsgSenderForMarket(address(this));\n\n        // approve the next payment + interest\n\n        lendingToken.approve(address(tellerV2), 10000 + 300);\n\n        // this call reverts\n        tellerV2.repayLoan(bidId, 10000 + 300);\n        assertTrue(tellerV2.repayLoanWasCalled(), \"repay loan was not called\");\n    }\n\n}\n\ncontract User {}\n```  \n</details>\n\n## Impact\n\nThe borrower is unable to make the payment for the current payment cycle, even though they have sufficient funds to do so. Unless the user makes the payment of approximately two payment cycles (instead of one), their loan would be liquidated, and they would lose the collateral.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol#L639-L644\n\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol#L600-L620\n\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/libraries/V2Calculations.sol#L70-L131\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the payment schedule as computed by `V2Calculations::calculateNextDueDate` in `V2Calculations::calculateAmountOwed`. I would expect that if the borrower owes a payment for the current cycle, this should be their minimum due amount (plus interest).\n\n\n\n## Discussion\n\n**ethereumdegen**\n\nI think this is actually something we would like to fix related to the   style of cycle as it is odd.  \n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/teller-protocol/teller-protocol-v2-audit-2024/pull/42\n\n\n**0x73696d616f**\n\n@nevillehuang is this in scope? It is out of scope according to the files in the readme. This was the response of the watson.\n> The issue manifests itself via external calls of TellerV2, e.g., repayLoanMinimum. As a result, the borrower cannot  pay their loan and loses the collateral. The root cause is in V2Calculations but the issue is in how TellerV2 is using V2Calculations.\n\nI understand what it means but I would like some clarity. Some people like me did not even look at this file due to this fact. I would like to know the standard/rule here so I can take this into consideration going forward.\n\n**nevillehuang**\n\n@0x73696d616f \n\npotential issues in the libraries won't automatically be out of scope based on [sherlock scoping details](https://docs.sherlock.xyz/audits/judging/judging#iii.-sherlocks-standards). Just letting you know for your future contests.\n\n> 2. In case the vulnerability exists in a library and an in-scope contract uses it and is affected by this bug this is a valid issue.\n\n**0x73696d616f**\n\nThank you! Thought so that is why I did not escalate.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/295",
  "Code": [
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport { Collateral } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/IEscrowVault.sol\";\n\nimport { ILoanRepaymentCallbacks } from \"./interfaces/ILoanRepaymentCallbacks.sol\";\nimport \"./interfaces/ILoanRepaymentListener.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/NumbersLib.sol\";\n\nimport { V2Calculations, PaymentCycleType } from \"./libraries/V2Calculations.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    ILoanRepaymentCallbacks,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    //the first 20 bytes of keccak256(\"lender manager\")\n    address constant USING_LENDER_MANAGER =\n        0x84D409EeD89F6558fE3646397146232665788bF8;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when market owner has cancelled a pending bid in their market.\n     * @param bidId The id of the bid funded.\n     *\n     * Note: The `CancelledBid` event will also be emitted.\n     */\n    event MarketOwnerCancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been closed by a lender to claim collateral.\n     * @param bidId The id of the bid accepted.\n     */\n    event LoanClosed(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constant Variables **/\n\n    uint8 public constant CURRENT_CODE_VERSION = 10;\n\n    uint32 public constant LIQUIDATION_DELAY = 86400; //ONE DAY IN SECONDS\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _marketRegistry The address of the market registry contract for the protocol.\n     * @param _reputationManager The address of the reputation manager contract.\n     * @param _lenderCommitmentForwarder The address of the lender commitment forwarder contract.\n     * @param _collateralManager The address of the collateral manager contracts.\n     * @param _lenderManager The address of the lender manager contract for loans on the protocol.\n     */\n    function initialize(\n        uint16 _protocolFee,\n        address _marketRegistry,\n        address _reputationManager,\n        address _lenderCommitmentForwarder,\n        address _collateralManager,\n        address _lenderManager,\n        address _escrowVault\n    ) external initializer {\n        __ProtocolFee_init(_protocolFee);\n\n        __Pausable_init();\n\n        require(\n            _lenderCommitmentForwarder.isContract(),\n            \"LenderCommitmentForwarder must be a contract\"\n        );\n        lenderCommitmentForwarder = _lenderCommitmentForwarder;\n\n        require(\n            _marketRegistry.isContract(),\n            \"MarketRegistry must be a contract\"\n        );\n        marketRegistry = IMarketRegistry(_marketRegistry);\n\n        require(\n            _reputationManager.isContract(),\n            \"ReputationManager must be a contract\"\n        );\n        reputationManager = IReputationManager(_reputationManager);\n\n        require(\n            _collateralManager.isContract(),\n            \"CollateralManager must be a contract\"\n        );\n        collateralManager = ICollateralManager(_collateralManager);\n\n        _setLenderManager(_lenderManager);\n        _setEscrowVault(_escrowVault);\n    }\n\n    /* function setEscrowVault(address _escrowVault) external reinitializer(9) {\n        _setEscrowVault(_escrowVault);\n    }\n    */\n\n    function _setLenderManager(address _lenderManager)\n        internal\n        onlyInitializing\n    {\n        require(\n            _lenderManager.isContract(),\n            \"LenderManager must be a contract\"\n        );\n        lenderManager = ILenderManager(_lenderManager);\n    }\n\n    function _setEscrowVault(address _escrowVault) internal onlyInitializing {\n        require(_escrowVault.isContract(), \"EscrowVault must be a contract\");\n        escrowVault = IEscrowVault(_escrowVault);\n    }\n\n    /**\n     * @notice Gets the metadataURI for a bidId.\n     * @param _bidId The id of the bid to return the metadataURI for\n     * @return metadataURI_ The metadataURI for the bid, as a string.\n     */\n    function getMetadataURI(uint256 _bidId)\n        public\n        view\n        returns (string memory metadataURI_)\n    {\n        // Check uri mapping first\n        metadataURI_ = uris[_bidId];\n        // If the URI is not present in the mapping\n        if (\n            keccak256(abi.encodePacked(metadataURI_)) ==\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 // hardcoded constant of keccak256('')\n        ) {\n            // Return deprecated bytes32 uri as a string\n            uint256 convertedURI = uint256(bids[_bidId]._metadataURI);\n            metadataURI_ = StringsUpgradeable.toHexString(convertedURI, 32);\n        }\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan without Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan with Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver,\n        Collateral[] calldata _collateralInfo\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n\n        bool validation = collateralManager.commitCollateral(\n            bidId_,\n            _collateralInfo\n        );\n\n        require(\n            validation == true,\n            \"Collateral balance could not be validated\"\n        );\n    }\n\n    function _submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) internal virtual returns (uint256 bidId_) {\n        address sender = _msgSenderForMarket(_marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedBorrower(\n            _marketplaceId,\n            sender\n        );\n\n        require(isVerified, \"Not verified borrower\");\n\n        require(\n            marketRegistry.isMarketOpen(_marketplaceId),\n            \"Market is not open\"\n        );\n\n        // Set response bid ID.\n        bidId_ = bidId;\n\n        // Create and store our bid into the mapping\n        Bid storage bid = bids[bidId];\n        bid.borrower = sender;\n        bid.receiver = _receiver != address(0) ? _receiver : bid.borrower;\n        bid.marketplaceId = _marketplaceId;\n        bid.loanDetails.lendingToken = IERC20(_lendingToken);\n        bid.loanDetails.principal = _principal;\n        bid.loanDetails.loanDuration = _duration;\n        bid.loanDetails.timestamp = uint32(block.timestamp);\n\n        // Set payment cycle type based on market setting (custom or monthly)\n        (bid.terms.paymentCycle, bidPaymentCycleType[bidId]) = marketRegistry\n            .getPaymentCycle(_marketplaceId);\n\n        bid.terms.APR = _APR;\n\n        bidDefaultDuration[bidId] = marketRegistry.getPaymentDefaultDuration(\n            _marketplaceId\n        );\n\n        bidExpirationTime[bidId] = marketRegistry.getBidExpirationTime(\n            _marketplaceId\n        );\n\n        bid.paymentType = marketRegistry.getPaymentType(_marketplaceId);\n\n        bid.terms.paymentCycleAmount = V2Calculations\n            .calculatePaymentCycleAmount(\n                bid.paymentType,\n                bidPaymentCycleType[bidId],\n                _principal,\n                _duration,\n                bid.terms.paymentCycle,\n                _APR\n            );\n\n        uris[bidId] = _metadataURI;\n        bid.state = BidState.PENDING;\n\n        emit SubmittedBid(\n            bidId,\n            bid.borrower,\n            bid.receiver,\n            keccak256(abi.encodePacked(_metadataURI))\n        );\n\n        // Store bid inside borrower bids mapping\n        borrowerBids[bid.borrower].push(bidId);\n\n        // Increment bid id counter\n        bidId++;\n    }\n\n    /**\n     * @notice Function for a borrower to cancel their pending bid.\n     * @param _bidId The id of the bid to cancel.\n     */\n    function cancelBid(uint256 _bidId) external {\n        if (\n            _msgSenderForMarket(bids[_bidId].marketplaceId) !=\n            bids[_bidId].borrower\n        ) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"cancelBid\",\n                message: \"Only the bid owner can cancel!\"\n            });\n        }\n        _cancelBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a market owner to cancel a bid in the market.\n     * @param _bidId The id of the bid to cancel.\n     */\n    function marketOwnerCancelBid(uint256 _bidId) external {\n        if (\n            _msgSender() !=\n            marketRegistry.getMarketOwner(bids[_bidId].marketplaceId)\n        ) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"marketOwnerCancelBid\",\n                message: \"Only the market owner can cancel!\"\n            });\n        }\n        _cancelBid(_bidId);\n        emit MarketOwnerCancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for users to cancel a bid.\n     * @param _bidId The id of the bid to be cancelled.\n     */\n    function _cancelBid(uint256 _bidId)\n        internal\n        virtual\n        pendingBid(_bidId, \"cancelBid\")\n    {\n        // Set the bid state to CANCELLED\n        bids[_bidId].state = BidState.CANCELLED;\n\n        // Emit CancelledBid event\n        emit CancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a lender to accept a proposed loan bid.\n     * @param _bidId The id of the loan bid to accept.\n     */\n    function lenderAcceptBid(uint256 _bidId)\n        external\n        override\n        pendingBid(_bidId, \"lenderAcceptBid\")\n        whenNotPaused\n        returns (\n            uint256 amountToProtocol,\n            uint256 amountToMarketplace,\n            uint256 amountToBorrower\n        )\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedLender(\n            bid.marketplaceId,\n            sender\n        );\n        require(isVerified, \"Not verified lender\");\n\n        require(\n            !marketRegistry.isMarketClosed(bid.marketplaceId),\n            \"Market is closed\"\n        );\n\n        require(!isLoanExpired(_bidId), \"Bid has expired\");\n\n        // Set timestamp\n        bid.loanDetails.acceptedTimestamp = uint32(block.timestamp);\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // Mark borrower's request as accepted\n        bid.state = BidState.ACCEPTED;\n\n        // Declare the bid acceptor as the lender of the bid\n        bid.lender = sender;\n\n        // Tell the collateral manager to deploy the escrow and pull funds from the borrower if applicable\n        collateralManager.deployAndDeposit(_bidId);\n\n        // Transfer funds to borrower from the lender\n        amountToProtocol = bid.loanDetails.principal.percent(protocolFee());\n        amountToMarketplace = bid.loanDetails.principal.percent(\n            marketRegistry.getMarketplaceFee(bid.marketplaceId)\n        );\n        amountToBorrower =\n            bid.loanDetails.principal -\n            amountToProtocol -\n            amountToMarketplace;\n\n        //transfer fee to protocol\n        if (amountToProtocol > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                owner(),\n                amountToProtocol\n            );\n        }\n\n        //transfer fee to marketplace\n        if (amountToMarketplace > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                marketRegistry.getMarketFeeRecipient(bid.marketplaceId),\n                amountToMarketplace\n            );\n        }\n\n        //transfer funds to borrower\n        if (amountToBorrower > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                bid.receiver,\n                amountToBorrower\n            );\n        }\n\n        // Record volume filled by lenders\n        lenderVolumeFilled[address(bid.loanDetails.lendingToken)][sender] += bid\n            .loanDetails\n            .principal;\n        totalVolumeFilled[address(bid.loanDetails.lendingToken)] += bid\n            .loanDetails\n            .principal;\n\n        // Add borrower's active bid\n        _borrowerBidsActive[bid.borrower].add(_bidId);\n\n        // Emit AcceptedBid\n        emit AcceptedBid(_bidId, sender);\n\n        emit FeePaid(_bidId, \"protocol\", amountToProtocol);\n        emit FeePaid(_bidId, \"marketplace\", amountToMarketplace);\n    }\n\n    function claimLoanNFT(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"claimLoanNFT\")\n        whenNotPaused\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n        require(sender == bid.lender, \"only lender can claim NFT\");\n\n        // set lender address to the lender manager so we know to check the owner of the NFT for the true lender\n        bid.lender = address(USING_LENDER_MANAGER);\n\n        // mint an NFT with the lender manager\n        lenderManager.registerLoan(_bidId, sender);\n    }\n\n    /**\n     * @notice Function for users to make the minimum amount due for an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanMinimum(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: duePrincipal, interest: interest }),\n            owedPrincipal + interest,\n            true\n        );\n    }\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanFull(_bidId, true);\n    }\n\n    // function that the borrower (ideally) sends to repay the loan\n    /**\n     * @notice Function for users to make a payment towards an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _amount The amount of the payment.\n     */\n    function repayLoan(uint256 _bidId, uint256 _amount)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanAtleastMinimum(_bidId, _amount, true);\n    }\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFullWithoutCollateralWithdraw(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanFull(_bidId, false);\n    }\n\n    function repayLoanWithoutCollateralWithdraw(uint256 _bidId, uint256 _amount)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanAtleastMinimum(_bidId, _amount, false);\n    }\n\n    function _repayLoanFull(uint256 _bidId, bool withdrawCollateral) internal {\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest,\n            withdrawCollateral\n        );\n    }\n\n    function _repayLoanAtleastMinimum(\n        uint256 _bidId,\n        uint256 _amount,\n        bool withdrawCollateral\n    ) internal {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        uint256 minimumOwed = duePrincipal + interest;\n\n        // If amount is less than minimumOwed, we revert\n        if (_amount < minimumOwed) {\n            revert PaymentNotMinimum(_bidId, _amount, minimumOwed);\n        }\n\n        _repayLoan(\n            _bidId,\n            Payment({ principal: _amount - interest, interest: interest }),\n            owedPrincipal + interest,\n            withdrawCollateral\n        );\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol implement an emergency stop mechanism.\n     */\n    function pauseProtocol() public virtual onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol undo a previously implemented emergency stop.\n     */\n    function unpauseProtocol() public virtual onlyOwner whenPaused {\n        _unpause();\n    }\n\n    function lenderCloseLoan(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"lenderClaimCollateral\")\n    {\n        Bid storage bid = bids[_bidId];\n        address _collateralRecipient = bid.lender;\n\n        _lenderCloseLoanWithRecipient(_bidId, _collateralRecipient);\n    }\n\n    /**\n     * @notice Function for lender to claim collateral for a defaulted loan. The only purpose of a CLOSED loan is to make collateral claimable by lender.\n     * @param _bidId The id of the loan to set to CLOSED status.\n     */\n    function lenderCloseLoanWithRecipient(\n        uint256 _bidId,\n        address _collateralRecipient\n    ) external {\n        _lenderCloseLoanWithRecipient(_bidId, _collateralRecipient);\n    }\n\n    function _lenderCloseLoanWithRecipient(\n        uint256 _bidId,\n        address _collateralRecipient\n    ) internal acceptedLoan(_bidId, \"lenderClaimCollateral\") {\n        require(isLoanDefaulted(_bidId), \"Loan must be defaulted.\");\n\n        Bid storage bid = bids[_bidId];\n        bid.state = BidState.CLOSED;\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n        require(sender == bid.lender, \"only lender can close loan\");\n\n        /*\n\n\n          address collateralManagerForBid = address(_getCollateralManagerForBid(_bidId)); \n\n          if( collateralManagerForBid == address(collateralManagerV2) ){\n             ICollateralManagerV2(collateralManagerForBid).lenderClaimCollateral(_bidId,_collateralRecipient);\n          }else{\n             require( _collateralRecipient == address(bid.lender));\n             ICollateralManager(collateralManagerForBid).lenderClaimCollateral(_bidId );\n          }\n          \n          */\n\n        collateralManager.lenderClaimCollateral(_bidId);\n\n        emit LoanClosed(_bidId);\n    }\n\n    /**\n     * @notice Function for users to liquidate a defaulted loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function liquidateLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        Bid storage bid = bids[_bidId];\n\n        // If loan is backed by collateral, withdraw and send to the liquidator\n        address recipient = _msgSenderForMarket(bid.marketplaceId);\n\n        _liquidateLoanFull(_bidId, recipient);\n    }\n\n    function liquidateLoanFullWithRecipient(uint256 _bidId, address _recipient)\n        external\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        _liquidateLoanFull(_bidId, _recipient);\n    }\n\n    /**\n     * @notice Function for users to liquidate a defaulted loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function _liquidateLoanFull(uint256 _bidId, address _recipient)\n        internal\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        require(isLoanLiquidateable(_bidId), \"Loan must be liquidateable.\");\n\n        Bid storage bid = bids[_bidId];\n\n        // change state here to prevent re-entrancy\n        bid.state = BidState.LIQUIDATED;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bid,\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n\n        //this sets the state to 'repaid'\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest,\n            false\n        );\n\n        /*\n         _getCollateralManagerForBid(_bidId).liquidateCollateral(\n            _bidId,\n            _recipient\n        ); \n      */\n\n        collateralManager.liquidateCollateral(_bidId, _recipient);\n\n        address liquidator = _msgSenderForMarket(bid.marketplaceId);\n\n        emit LoanLiquidated(_bidId, liquidator);\n    }\n\n    /**\n     * @notice Internal function to make a loan payment.\n     * @dev Updates the bid's `status` to `PAID` only if it is not already marked as `LIQUIDATED`\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _payment The Payment struct with payments amounts towards principal and interest respectively.\n     * @param _owedAmount The total amount owed on the loan.\n     */\n    function _repayLoan(\n        uint256 _bidId,\n        Payment memory _payment,\n        uint256 _owedAmount,\n        bool _shouldWithdrawCollateral\n    ) internal virtual {\n        Bid storage bid = bids[_bidId];\n        uint256 paymentAmount = _payment.principal + _payment.interest;\n\n        RepMark mark = reputationManager.updateAccountReputation(\n            bid.borrower,\n            _bidId\n        );\n\n        // Check if we are sending a payment or amount remaining\n        if (paymentAmount >= _owedAmount) {\n            paymentAmount = _owedAmount;\n\n            if (bid.state != BidState.LIQUIDATED) {\n                bid.state = BidState.PAID;\n            }\n\n            // Remove borrower's active bid\n            _borrowerBidsActive[bid.borrower].remove(_bidId);\n\n            // If loan is is being liquidated and backed by collateral, withdraw and send to borrower\n            if (_shouldWithdrawCollateral) {\n                //   _getCollateralManagerForBid(_bidId).withdraw(_bidId);\n                collateralManager.withdraw(_bidId);\n            }\n\n            emit LoanRepaid(_bidId);\n        } else {\n            emit LoanRepayment(_bidId);\n        }\n\n        _sendOrEscrowFunds(_bidId, _payment); //send or escrow the funds\n\n        // update our mappings\n        bid.loanDetails.totalRepaid.principal += _payment.principal;\n        bid.loanDetails.totalRepaid.interest += _payment.interest;\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // If the loan is paid in full and has a mark, we should update the current reputation\n        if (mark != RepMark.Good) {\n            reputationManager.updateAccountReputation(bid.borrower, _bidId);\n        }\n    }\n\n\n    function _sendOrEscrowFunds(uint256 _bidId, Payment memory _payment)\n        internal\n    {\n        Bid storage bid = bids[_bidId];\n        address lender = getLoanLender(_bidId);\n\n        uint256 _paymentAmount = _payment.principal + _payment.interest;\n\n        try \n\n            bid.loanDetails.lendingToken.transferFrom{ gas: 100000 }(\n                _msgSenderForMarket(bid.marketplaceId),\n                lender,\n                _paymentAmount\n            )\n        {} catch {\n            address sender = _msgSenderForMarket(bid.marketplaceId);\n\n            uint256 balanceBefore = bid.loanDetails.lendingToken.balanceOf(\n                address(this)\n            ); \n\n            //if unable, pay to escrow\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                address(this),\n                _paymentAmount\n            );\n\n            uint256 balanceAfter = bid.loanDetails.lendingToken.balanceOf(\n                address(this)\n            );\n\n            //used for fee-on-send tokens\n            uint256 paymentAmountReceived = balanceAfter - balanceBefore;\n\n            bid.loanDetails.lendingToken.approve(\n                address(escrowVault),\n                paymentAmountReceived\n            );\n\n            IEscrowVault(escrowVault).deposit(\n                lender,\n                address(bid.loanDetails.lendingToken),\n                paymentAmountReceived\n            );\n        }\n\n        address loanRepaymentListener = repaymentListenerForBid[_bidId];\n\n        if (loanRepaymentListener != address(0)) {\n            try\n                ILoanRepaymentListener(loanRepaymentListener).repayLoanCallback{\n                    gas: 80000\n                }( //limit gas costs to prevent lender griefing repayments\n                    _bidId,\n                    _msgSenderForMarket(bid.marketplaceId),\n                    _payment.principal,\n                    _payment.interest\n                )\n            {} catch {}\n        }\n    }\n\n\n\n\n    /**\n     * @notice Calculates the total amount owed for a loan bid at a specific timestamp.\n     * @param _bidId The id of the loan bid to calculate the owed amount for.\n     * @param _timestamp The timestamp at which to calculate the loan owed amount at.\n     */\n    function calculateAmountOwed(uint256 _bidId, uint256 _timestamp)\n        public\n        view\n        returns (Payment memory owed)\n    {\n        Bid storage bid = bids[_bidId];\n        if (\n            bid.state != BidState.ACCEPTED ||\n            bid.loanDetails.acceptedTimestamp >= _timestamp\n        ) return owed;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bid,\n                _timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n\n        owed.principal = owedPrincipal;\n        owed.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the minimum payment amount due"
    }
  ]
}