{
  "Title": "H-3: RageTrade senior vault USDC deposits are subject to utilization caps which can lock deposits for long periods of time leading to UXD instability",
  "Content": "# Issue H-3: RageTrade senior vault USDC deposits are subject to utilization caps which can lock deposits for long periods of time leading to UXD instability \n\nSource: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/253 \n\n## Found by \nclems4ever, ctf\\_sec, 0x52, 0xNazgul\n\n## Summary\n\nRageTrade senior vault requires that it maintains deposits above and beyond the current amount loaned to the junior vault. Currently this is set at 90%, that is the vault must maintain at least 10% more deposits than loans. Currently the junior vault is in high demand and very little can be withdrawn from the senior vault. A situation like this is far from ideal because in the even that there is a strong depeg of UXD a large portion of the collateral could be locked in the vault unable to be withdrawn.\n\n## Vulnerability Detail\n\n[DnGmxSeniorVault.sol](https://arbiscan.io/address/0x66aca71a2e62022f9f23a50ab737ded372ad00cf#code#F31#L288)\n\n    function beforeWithdraw(\n        uint256 assets,\n        uint256,\n        address\n    ) internal override {\n        /// @dev withdrawal will fail if the utilization goes above maxUtilization value due to a withdrawal\n        // totalUsdcBorrowed will reduce when borrower (junior vault) repays\n        if (totalUsdcBorrowed() > ((totalAssets() - assets) * maxUtilizationBps) / MAX_BPS)\n            revert MaxUtilizationBreached();\n\n        // take out required assets from aave lending pool\n        pool.withdraw(address(asset), assets, address(this));\n    }\n\nDnGmxSeniorVault.sol#beforeWithdraw is called before each withdraw and will revert if the withdraw lowers the utilization of the vault below a certain threshold. This is problematic in the event that large deposits are required to maintain the stability of UXD.\n\n## Impact\n\nUXD may become destabilized in the event that the senior vault has high utilization and the collateral is inaccessible\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/rage-trade/RageDnDepository.sol#L99-L115\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend three safeguards against this:\n1) Monitor the current utilization of the senior vault and limit deposits if utilization is close to locking positions\n2) Maintain a portion of the USDC deposits outside the vault (i.e. 10%) to avoid sudden potential liquidity crunches\n3) Create functions to balance the proportions of USDC in and out of the vault to withdraw USDC from the vault in the event that utilization threatens to lock collateral\n\n## Discussion\n\n**WarTech9**\n\nPossible usecase for insurance fund.\n\n**acamill**\n\nThis is the main downside of using not fully liquid strategies for the ALM model, upside being higher yield. \nWe can mitigate this issue with buffers but that's always an issue, and adding buffers with either protocol funds or insurance fund is equivalent to using lower yield strategies, as such not an ideal solution either. (and it add complexity)\n\nMy personal opinion is to keep the cap on the illiquid strategy to be low enough relative to the total circulating UXD, that way keeping the high yield but reducing the liquidity crunch issue.\nThat's what we are currently doing on Solana, working on smarter rebalancing and better risk management to keep these cap relevant.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/33",
  "Code": [
    {
      "filename": "contracts/integrations/rage-trade/RageDnDepository.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20, IERC20Metadata, ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IDnGmxSeniorVault} from \"../../external/rage-trade/IDnGmxSeniorVault.sol\";\nimport {IDepository} from \"../IDepository.sol\";\nimport {IUXDController} from \"../../core/IUXDController.sol\";\nimport {MathLib} from \"../../libraries/MathLib.sol\";\nimport {RageDnDepositoryStorage} from \"./RageDnDepositoryStorage.sol\";\n\n/// @title RageDnDepository\n/// @notice Manages interactions with Rage Trade.\ncontract RageDnDepository is\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    RageDnDepositoryStorage\n{\n    using MathLib for uint256;\n    using AddressUpgradeable for address;\n    using SafeERC20Upgradeable for IERC20;\n    using SafeERC20Upgradeable for ERC20;\n\n    error NoProfits(int256 pnl);\n    error NotApproved(uint256 allowance, uint256 amount);\n    error NotController(address caller);\n    error NotContractAddress(address addr);\n    error UnsupportedAsset(address asset);\n    error RedeemableSoftCapHit(uint256 softcap, uint256 totalRedeemable);\n    error TokenTransferFail(address token, address from, address to);\n\n    ///////////////////////////////////////////////////////////////////\n    ///                         Events\n    ///////////////////////////////////////////////////////////////////\n    event Deposited(\n        address indexed caller,\n        uint256 assets,\n        uint256 redeemable,\n        uint256 shares\n    );\n    event Withdrawn(\n        address indexed caller,\n        uint256 assets,\n        uint256 redeemable,\n        uint256 shares\n    );\n    event Redeemed(\n        address indexed caller,\n        uint256 assets,\n        uint256 redeemable,\n        uint256 shares\n    );\n    event RedeemableSoftCapUpdated(address indexed caller, uint256 newSoftCap);\n\n    /// @notice Constructor\n    /// @param _vault the address of the Rage Senior vault\n    /// @param _controller the address of the UXDController\n    function initialize(address _vault, address _controller) external virtual initializer {\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        if (!_vault.isContract()) {\n            revert NotContractAddress(_vault);\n        }\n        if (!_controller.isContract()) {\n            revert NotContractAddress(_controller);\n        }\n        vault = IDnGmxSeniorVault(_vault);\n        controller = IUXDController(_controller);\n        assetToken = vault.asset();\n        redeemable = address(controller.redeemable());\n    }\n\n    /// @dev restirct access to controller\n    modifier onlyController() {\n        if (msg.sender != address(controller)) {\n            revert NotController(msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Sets the redeemable soft cap\n    /// @dev Can only be called by owner\n    /// @param softCap The new redeemable soft cap\n    function setRedeemableSoftCap(uint256 softCap) external onlyOwner {\n        redeemableSoftCap = softCap;\n        emit RedeemableSoftCapUpdated(msg.sender, softCap);\n    }\n\n    /// @notice Deposits assets\n    /// @param assetAmount The amount of assets to deposit in assetToken.decimals()\n    /// @return redeemableAmount the corresponding amount of redeemable for asset deposited\n    function deposit(address asset, uint256 assetAmount)\n        external\n        onlyController\n        returns (uint256)\n    {\n        if (asset != assetToken) {\n            revert UnsupportedAsset(asset);\n        }\n        netAssetDeposits += assetAmount;\n        IERC20(assetToken).approve(address(vault), assetAmount);\n        uint256 shares = vault.deposit(assetAmount, address(this));\n        uint256 redeemableAmount = _assetsToRedeemable(assetAmount);\n        redeemableUnderManagement += redeemableAmount;\n        _checkSoftCap();\n        emit Deposited(msg.sender, assetAmount, redeemableAmount, shares);\n        return redeemableAmount;\n    }\n\n    /// @notice Redeem a given amount.\n    /// @param redeemableAmount The amount to redeem in redeemable.decimals()\n    /// @return assetAmount The asset amount withdrawn by this redemption\n    function redeem(address asset, uint256 redeemableAmount)\n        external\n        onlyController\n        returns (uint256)\n    {\n        if (asset != assetToken) {\n            revert UnsupportedAsset(asset);\n        }\n        uint256 assetAmount = _redeemableToAssets(redeemableAmount);\n        redeemableUnderManagement -= redeemableAmount;\n        netAssetDeposits -= assetAmount;\n        uint256 shares = vault.withdraw(\n            assetAmount,\n            address(controller),\n            address(this)\n        );\n        emit Withdrawn(msg.sender, assetAmount, redeemableAmount, shares);\n        return assetAmount;\n    }\n\n    /// @dev returns assets deposited. IDepository required.\n    function assetsDeposited() external view returns (uint256) {\n        return netAssetDeposits;\n    }\n\n    /// @dev returns the shares currently owned by this depository\n    function getDepositoryShares() external view returns (uint256) {\n        return vault.balanceOf(address(this));\n    }\n\n    /// @dev returns the assets currently owned by this depository.\n    function getDepositoryAssets() public view returns (uint256) {\n        return vault.convertToAssets(vault.balanceOf(address(this)));\n    }\n\n    /// @dev the difference between curent vault assets and amount deposited\n    function getUnrealizedPnl() public view returns (int256) {\n        return int256(getDepositoryAssets()) - int256(netAssetDeposits);\n    }\n\n    /// @dev Withdraw profits. Ensure redeemable is still fully backed by asset balance after this is run.\n    /// TODO: Remove this function. Code profit access and use in contracts\n    function withdrawProfits(address receiver) external onlyOwner nonReentrant {\n        int256 pnl = getUnrealizedPnl();\n        if (pnl <= 0) {\n            revert NoProfits(pnl);\n        }\n        uint256 profits = uint256(pnl);\n        vault.withdraw(profits, receiver, address(this));\n        realizedPnl += profits;\n    }\n\n    function _assetsToRedeemable(uint256 assetAmount)\n        private\n        view\n        returns (uint256)\n    {\n        return\n            assetAmount.fromDecimalToDecimal(\n                IERC20Metadata(assetToken).decimals(),\n                IERC20Metadata(redeemable).decimals()\n            );\n    }\n\n    function _redeemableToAssets(uint256 redeemableAmount)\n        private\n        view\n        returns (uint256)\n    {\n        return\n            redeemableAmount.fromDecimalToDecimal(\n                IERC20Metadata(redeemable).decimals(),\n                IERC20Metadata(assetToken).decimals()\n            );\n    }\n\n    function _checkSoftCap() private view {\n        if (redeemableUnderManagement > redeemableSoftCap) {\n            revert RedeemableSoftCapHit(\n                redeemableSoftCap,\n                redeemableUnderManagement\n            );\n        }\n    }\n\n    /// @notice Transfers contract ownership to a new address\n    /// @dev This can only be called by the current owner.\n    /// @param newOwner The address of the new owner.\n    function transferOwnership(address newOwner)\n        public\n        override(IDepository, OwnableUpgradeable)\n        onlyOwner\n    {\n        super.transferOwnership(newOwner);\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                         Upgrades\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @dev Returns the current version of this contract\n    // solhint-disable-next-line func-name-mixedcase\n    function VERSION() external pure virtual returns (uint8) {\n        return 1;\n    }\n\n    /// @dev called on upgrade. only owner can call upgrade function\n    function _authorizeUpgrade(address)\n        internal\n        virtual\n        override\n        onlyOwner\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n}"
    }
  ]
}