{
  "Title": "[M-11] The preimage DB (i.e., `NameWrapper.names`) can be maliciously manipulated/corrupted",
  "Content": "\n[NameWrapper.sol#L520](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L520)<br>\n\nBy design, the `NameWrapper.names` is used as a preimage DB so that the client can query the domain name by providing the token ID. The name should be correctly stored. To do so, the `NameWrapper` record the domain's name every time it gets wrapped. And as long as all the parent nodes are recorded in the DB, wrapping a child node will be very efficient by simply querying the parent node's name.\n\nHowever, within a malicious scenario, it is possible that a subdomain can be wrapped without recording its info in the preimage DB.\n\nSpecifically, when `NameWrappper.setSubnodeOwner` / `NameWrappper.setSubnodeRecord` on a given subdomain, the following code is used to check whether the subdomain is wrapped or not. The preimage DB is only updated when the subdomain is not wrapped (to save gas I beieve).\n\n```solidity\nfunction setSubnodeOwner(\n    bytes32 parentNode,\n    string calldata label,\n    address newOwner,\n    uint32 fuses,\n    uint64 expiry\n)\n    public\n    onlyTokenOwner(parentNode)\n    canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    returns (bytes32 node)\n{\n    bytes32 labelhash = keccak256(bytes(label));\n    node = _makeNode(parentNode, labelhash);\n    (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n    if (ens.owner(node) != address(this)) {\n        ens.setSubnodeOwner(parentNode, labelhash, address(this));\n        _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n    } else {\n        _transferAndBurnFuses(node, newOwner, fuses, expiry);\n    }\n}\n```\n\nHowever, the problem is that `ens.owner(node) != address(this)` is not sufficient to check whether the node is alreay wrapped. The hacker can manipulate this check by simply invoking `EnsRegistry.setSubnodeOwner` to set the owner as the `NameWrapper` contract without wrapping the node.\n\nConsider the following attack scenario.\n\n*   the hacker registers a 2LD domain, e.g., `base.eth`\n*   he assigns a subdomain for himself, e.g., `sub1.base.eth`\n    *   the expiry of `sub1.base.eth` should be set as expired shortly\n    *   note that the expiry is for `sub1.base.eth` instead of `base.eth`, so it is safe to make it soonly expired\n*   the hacker waits for expiration and unwraps his `sub1.base.eth`\n*   the hacker invokes `ens.setSubnodeOwner` to set the owner of `sub2.sub1.base.eth` as NameWrapper contract\n*   the hacker re-wraps his `sub1.base.eth`\n*   the hacker invokes `nameWrapper.setSubnodeOwner` for `sub2.sub1.base.eth`\n    *   as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty\n*   the hacker invokes `nameWrapper.setSubnodeOwner` for `eth.sub2.sub1.base.eth`.\n    *   as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes `\\x03eth`\n\nIt is not rated as a High issue since the forged name is not valid, i.e., without the tailed `\\x00` (note that a valid name should be like `\\x03eth\\x00`). However, the preimage BD can still be corrupted due to this issue.\n\n### Suggested Fix\n\nWhen wrapping node `X`, check whether `NameWrapper.names[X]` is empty directly, and update the preimage DB if it is empty.\n\n### Proof of Concept / Attack Scenario\n\nFor full details, please see [original warden submission](https://github.com/code-423n4/2022-07-ens-findings/issues/197).\n\n**[jefflau (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/197)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-ens-contest",
  "Code": [
    {
      "filename": "contracts/wrapper/NameWrapper.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC1155Fuse.sol\";\nimport \"./Controllable.sol\";\nimport \"./INameWrapper.sol\";\nimport \"./INameWrapperUpgrade.sol\";\nimport \"./IMetadataService.sol\";\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BytesUtil.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     */\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /**\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     */\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 && expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !isApprovedForAll(registrant, msg.sender) &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &&\n            !isApprovedForAll(owner, msg.sender) &&\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses & PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, \"\");\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses & CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses & ~PARENT_CANNOT_CONTROL != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}"
    }
  ]
}