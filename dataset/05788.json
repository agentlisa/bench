{
  "Title": "[L-03] Do not hardcode `_zroPaymentAddress` field to `address(0)` to allow future ZRO fee payments and prevent Bridge Agents from falling apart in case LayerZero makes breaking changes",
  "Content": "\nHardcoding the [_zroPaymentAddress](https://github.com/LayerZero-Labs/LayerZero/blob/43ab0aed0fbcd123bcac3d089e74898e25b86c0a/contracts/interfaces/ILayerZeroEndpoint.sol#L13) field to `address(0)` disallows the protocol from using ZRO token as a fee payment option in the future (ZRO might be launching in the coming year). Consider passing the `_zroPaymentAddress` field as an input parameter to allow flexibility of future fee payments using ZRO tokens.\n\nWe can also see point 5 in this [integration checklist](https://layerzero.gitbook.io/docs/evm-guides/layerzero-integration-checklist) provided by the LayerZero team to ensure maximum flexibility in fee payment options is achieved. \n\nHere is the point:\n\n```\nDo not hardcode address zero (address(0)) as zroPaymentAddress when estimating fees and sending messages. Pass it as a parameter instead.\n```\n\nCheck out this recent discussion between the 10xKelly and I on hardcoding `_zroPaymentAddress` (Note: In our case, the **contracts that would be difficult to handle changes or updates are the BridgeAgent contracts**):\n\nCheck out [this transcript](https://tickettool.xyz/direct?url=https://cdn.discordapp.com/attachments/1155911737397223496/1155911741725757531/transcript-tx-mrpotatomagic.html) in case image fails to render.\n\n![Imgur](https://user-images.githubusercontent.com/135237830/284733874-f5c17888-fed9-46df-bdda-842801a945a0.png)\n\n*There are 2 instances of this issue:*\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootBridgeAgent.sol#L828\n\nThis is even more important in our contracts since function [_performCall()](https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootBridgeAgent.sol#L808) is the exit point for most cross-chain calls being made from the RootBridgeAgent.sol. Thus, if any updates are made from the LayerZero team, there are chances of the protocol core functionality breaking down.\n\n```solidity\nFile: src/RootBridgeAgent.sol\n823:             ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n824:                 _dstChainId,\n825:                 getBranchBridgeAgentPath[_dstChainId],\n826:                 _payload,\n827:                 _refundee,\n828:                 address(0),\n829:                 abi.encodePacked(uint16(2), _gParams.gasLimit, _gParams.remoteBranchExecutionGas, callee)\n830:             );\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L775\n\nCheck Line 778:\n\n```solidity\nFile: BranchBridgeAgent.sol\n768:     function _performCall(address payable _refundee, bytes memory _payload, GasParams calldata _gParams)\n769:         internal\n770:         virtual\n771:     {\n772:         //Sends message to LayerZero messaging layer\n773:         ILayerZeroEndpoint(lzEndpointAddress).send{value: msg.value}(\n774:             rootChainId,\n775:             rootBridgeAgentPath,\n776:             _payload,\n777:             payable(_refundee),\n778:             address(0),//@audit Integration issue - Do not hardcode address 0 as it may cause future upgrades difficulty\n779:             abi.encodePacked(uint16(2), _gParams.gasLimit, _gParams.remoteBranchExecutionGas, rootBridgeAgentAddress)\n780:         );\n781:     }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "contracts/interfaces/ILayerZeroEndpoint.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}"
    },
    {
      "filename": "src/RootBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ExcessivelySafeCall} from \"lib/ExcessivelySafeCall.sol\";\n\nimport {ILayerZeroEndpoint} from \"./interfaces/ILayerZeroEndpoint.sol\";\n\nimport {IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IERC20hTokenRoot} from \"./interfaces/IERC20hTokenRoot.sol\";\n\nimport {BridgeAgentConstants} from \"./interfaces/BridgeAgentConstants.sol\";\nimport {\n    GasParams,\n    DepositParams,\n    DepositMultipleParams,\n    ILayerZeroReceiver,\n    IRootBridgeAgent,\n    Settlement,\n    SettlementInput,\n    SettlementMultipleInput\n} from \"./interfaces/IRootBridgeAgent.sol\";\n\nimport {IRootPort as IPort} from \"./interfaces/IRootPort.sol\";\n\nimport {VirtualAccount} from \"./VirtualAccount.sol\";\nimport {DeployRootBridgeAgentExecutor, RootBridgeAgentExecutor} from \"./RootBridgeAgentExecutor.sol\";\n\n/// @title Root Bridge Agent Contract\n/// @author MaiaDAO\ncontract RootBridgeAgent is IRootBridgeAgent, BridgeAgentConstants {\n    using SafeTransferLib for address;\n    using ExcessivelySafeCall for address;\n    /*///////////////////////////////////////////////////////////////\n                        ROOT BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Chain Id\n    uint16 public immutable localChainId;\n\n    /// @notice Bridge Agent Factory Address.\n    address public immutable factoryAddress;\n\n    /// @notice Local Core Root Router Address\n    address public immutable localRouterAddress;\n\n    /// @notice Local Port Address where funds deposited from this chain are stored.\n    address public immutable localPortAddress;\n\n    /// @notice Local Layer Zero Endpoint Address for cross-chain communication.\n    address public immutable lzEndpointAddress;\n\n    /// @notice Address of Root Bridge Agent Executor.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRANCH BRIDGE AGENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain -> Branch Bridge Agent Address. For N chains, each Root Bridge Agent Address has M =< N Branch Bridge Agent Address.\n    mapping(uint256 chainId => address branchBridgeAgent) public getBranchBridgeAgent;\n\n    /// @notice Message Path for each connected Branch Bridge Agent as bytes for Layzer Zero interaction = localAddress + destinationAddress abi.encodePacked()\n    mapping(uint256 chainId => bytes branchBridgeAgentPath) public getBranchBridgeAgentPath;\n\n    /// @notice If true, bridge agent manager has allowed for a new given branch bridge agent to be synced/added.\n    mapping(uint256 chainId => bool allowed) public isBranchBridgeAgentAllowed;\n\n    /*///////////////////////////////////////////////////////////////\n                            SETTLEMENTS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public settlementNonce;\n\n    /// @notice Mapping from Settlement nonce to Settlement Struct.\n    mapping(uint256 nonce => Settlement settlementInfo) public getSettlement;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint256 chainId => mapping(uint256 nonce => uint256 state)) public executionState;\n\n    /*///////////////////////////////////////////////////////////////\n                            REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Bridge Agent.\n     *     @param _localChainId Local Chain Id.\n     *     @param _lzEndpointAddress Local Layerzero Endpoint Address.\n     *     @param _localPortAddress Local Port Address.\n     *     @param _localRouterAddress Local Port Address.\n     */\n    constructor(\n        uint16 _localChainId,\n        address _lzEndpointAddress,\n        address _localPortAddress,\n        address _localRouterAddress\n    ) {\n        require(_lzEndpointAddress != address(0), \"Layerzero Enpoint Address cannot be zero address\");\n        require(_localPortAddress != address(0), \"Port Address cannot be zero address\");\n        require(_localRouterAddress != address(0), \"Router Address cannot be zero address\");\n\n        factoryAddress = msg.sender;\n        localChainId = _localChainId;\n        lzEndpointAddress = _lzEndpointAddress;\n        localPortAddress = _localPortAddress;\n        localRouterAddress = _localRouterAddress;\n        bridgeAgentExecutorAddress = DeployRootBridgeAgentExecutor.deploy(address(this));\n        settlementNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function getSettlementEntry(uint32 _settlementNonce) external view override returns (Settlement memory) {\n        return getSettlement[_settlementNonce];\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function getFeeEstimate(\n        uint256 _gasLimit,\n        uint256 _remoteBranchExecutionGas,\n        bytes calldata _payload,\n        uint16 _dstChainId\n    ) external view returns (uint256 _fee) {\n        (_fee,) = ILayerZeroEndpoint(lzEndpointAddress).estimateFees(\n            _dstChainId,\n            address(this),\n            _payload,\n            false,\n            abi.encodePacked(uint16(2), _gasLimit, _remoteBranchExecutionGas, getBranchBridgeAgent[_dstChainId])\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    ROOT ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOut(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        GasParams calldata _gParams\n    ) external payable override lock requiresRouter {\n        //Encode Data for call.\n        bytes memory payload = abi.encodePacked(bytes1(0x00), _recipient, settlementNonce++, _params);\n\n        //Perform Call to clear hToken balance on destination branch chain.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridge(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock requiresRouter {\n        // Create Settlement and Perform call\n        bytes memory payload = _createSettlement(\n            settlementNonce,\n            _refundee,\n            _recipient,\n            _dstChainId,\n            _params,\n            _sParams.globalAddress,\n            _sParams.amount,\n            _sParams.deposit,\n            _hasFallbackToggled\n        );\n\n        //Perform Call.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function callOutAndBridgeMultiple(\n        address payable _refundee,\n        address _recipient,\n        uint16 _dstChainId,\n        bytes calldata _params,\n        SettlementMultipleInput calldata _sParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock requiresRouter {\n        // Create Settlement and Perform call\n        bytes memory payload = _createSettlementMultiple(\n            settlementNonce,\n            _refundee,\n            _recipient,\n            _dstChainId,\n            _sParams.globalAddresses,\n            _sParams.amounts,\n            _sParams.deposits,\n            _params,\n            _hasFallbackToggled\n        );\n\n        // Perform Call to destination Branch Chain.\n        _performCall(_dstChainId, _refundee, payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    SETTLEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrySettlement(\n        uint32 _settlementNonce,\n        address _recipient,\n        bytes calldata _params,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Get storage reference\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        // Check if Settlement hasn't been redeemed.\n        if (settlementReference.owner == address(0)) revert SettlementRetryUnavailable();\n\n        // Check if caller is Settlement owner\n        if (msg.sender != settlementReference.owner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementReference.owner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        // Update Settlement Status\n        settlementReference.status = STATUS_SUCCESS;\n\n        // Perform Settlement Retry\n        _performRetrySettlementCall(\n            _hasFallbackToggled,\n            settlementReference.hTokens,\n            settlementReference.tokens,\n            settlementReference.amounts,\n            settlementReference.deposits,\n            _params,\n            _settlementNonce,\n            payable(settlementReference.owner),\n            _recipient,\n            settlementReference.dstChainId,\n            _gParams,\n            msg.value\n        );\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function retrieveSettlement(uint32 _settlementNonce, GasParams calldata _gParams) external payable lock {\n        //Get settlement storage reference\n        Settlement storage settlementReference = getSettlement[_settlementNonce];\n\n        // Get Settlement owner.\n        address settlementOwner = settlementReference.owner;\n\n        // Check if Settlement is Retrieve.\n        if (settlementOwner == address(0)) revert SettlementRetrieveUnavailable();\n\n        // Check Settlement Owner\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x03), settlementOwner, _settlementNonce);\n\n        //Retrieve Deposit\n        _performCall(settlementReference.dstChainId, payable(settlementOwner), payload, _gParams);\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function redeemSettlement(uint32 _settlementNonce) external override lock {\n        // Get setttlement storage reference\n        Settlement storage settlement = getSettlement[_settlementNonce];\n\n        // Get deposit owner.\n        address settlementOwner = settlement.owner;\n\n        // Check if Settlement is redeemable.\n        if (settlement.status == STATUS_SUCCESS) revert SettlementRedeemUnavailable();\n        if (settlementOwner == address(0)) revert SettlementRedeemUnavailable();\n\n        // Check if Settlement Owner is msg.sender or msg.sender is the virtual account of the settlement owner.\n        if (msg.sender != settlementOwner) {\n            if (msg.sender != address(IPort(localPortAddress).getUserAccount(settlementOwner))) {\n                revert NotSettlementOwner();\n            }\n        }\n\n        // Clear Global hTokens To Recipient on Root Chain cancelling Settlement to Branch\n        for (uint256 i = 0; i < settlement.hTokens.length;) {\n            // Save to memory\n            address _hToken = settlement.hTokens[i];\n\n            // Check if asset\n            if (_hToken != address(0)) {\n                // Save to memory\n                uint24 _dstChainId = settlement.dstChainId;\n\n                // Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n                IPort(localPortAddress).bridgeToRoot(\n                    msg.sender,\n                    IPort(localPortAddress).getGlobalTokenFromLocal(_hToken, _dstChainId),\n                    settlement.amounts[i],\n                    settlement.deposits[i],\n                    _dstChainId\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Settlement\n        delete getSettlement[_settlementNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeIn(address _recipient, DepositParams memory _dParams, uint256 _srcChainId)\n        public\n        override\n        requiresAgentExecutor\n    {\n        // Deposit can't be greater than amount.\n        if (_dParams.amount < _dParams.deposit) revert InvalidInputParams();\n\n        // Cache local port address\n        address _localPortAddress = localPortAddress;\n\n        // Check local exists.\n        if (_dParams.amount > 0) {\n            if (!IPort(_localPortAddress).isLocalToken(_dParams.hToken, _srcChainId)) {\n                revert InvalidInputParams();\n            }\n        }\n\n        // Check underlying exists.\n        if (_dParams.deposit > 0) {\n            if (IPort(_localPortAddress).getLocalTokenFromUnderlying(_dParams.token, _srcChainId) != _dParams.hToken) {\n                revert InvalidInputParams();\n            }\n        }\n\n        // Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit\n        IPort(_localPortAddress).bridgeToRoot(\n            _recipient,\n            IPort(_localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _srcChainId),\n            _dParams.amount,\n            _dParams.deposit,\n            _srcChainId\n        );\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function bridgeInMultiple(address _recipient, DepositMultipleParams calldata _dParams, uint256 _srcChainId)\n        external\n        override\n        requiresAgentExecutor\n    {\n        // Cache length\n        uint256 length = _dParams.hTokens.length;\n\n        // Check MAX_LENGTH\n        if (length > MAX_TOKENS_LENGTH) revert InvalidInputParams();\n\n        // Bridge in assets\n        for (uint256 i = 0; i < length;) {\n            bridgeIn(\n                _recipient,\n                DepositParams({\n                    hToken: _dParams.hTokens[i],\n                    token: _dParams.tokens[i],\n                    amount: _dParams.amounts[i],\n                    deposit: _dParams.deposits[i],\n                    depositNonce: 0\n                }),\n                _srcChainId\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LAYER ZERO EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ILayerZeroReceiver\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64, bytes calldata _payload) public {\n        (bool success,) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.lzReceiveNonBlocking.selector, msg.sender, _srcChainId, _srcAddress, _payload)\n        );\n\n        if (!success) if (msg.sender == getBranchBridgeAgent[localChainId]) revert ExecutionFailure();\n    }\n\n    /// @inheritdoc IRootBridgeAgent\n    function lzReceiveNonBlocking(\n        address _endpoint,\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) public override requiresEndpoint(_endpoint, _srcChainId, _srcAddress) {\n        // Deposit Nonce\n        uint32 nonce;\n\n        // DEPOSIT FLAG: 0 (System request / response)\n        if (_payload[0] == 0x00) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 0 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSystemRequest(_localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSystemRequest.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 1 (Call without Deposit)\n        } else if (_payload[0] == 0x01) {\n            // Parse Deposit Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 1 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeNoDeposit(localRouterAddress, payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeNoDeposit.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 2 (Call with Deposit)\n        } else if (_payload[0] == 0x02) {\n            //Parse Deposit Nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START:PARAMS_TKN_START]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 2 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithDeposit(localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeWithDeposit.selector, localRouterAddress, _payload, srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 3 (Call with multiple asset Deposit)\n        } else if (_payload[0] == 0x03) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[2:6]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 3 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeWithDepositMultiple(localRouterAddress, _payload, _srcChainId)\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeWithDepositMultiple.selector,\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // DEPOSIT FLAG: 4 (Call without Deposit + msg.sender)\n        } else if (_payload[0] == 0x04) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 4 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedNoDeposit(address(userAccount), localRouterAddress, data, _srcChainId\n            _execute(\n                nonce,\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedNoDeposit.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            //DEPOSIT FLAG: 5 (Call with Deposit + msg.sender)\n        } else if (_payload[0] & 0x7F == 0x05) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));\n\n            //Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 5 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDeposit(address(userAccount), localRouterAddress, data, _srcChainId)\n            _execute(\n                _payload[0] == 0x85,\n                nonce,\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))),\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedWithDeposit.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // DEPOSIT FLAG: 6 (Call with multiple asset Deposit + msg.sender)\n        } else if (_payload[0] & 0x7F == 0x06) {\n            // Parse deposit nonce\n            nonce = uint32(bytes4(_payload[PARAMS_START_SIGNED + PARAMS_START:PARAMS_START_SIGNED + PARAMS_TKN_START]));\n\n            // Check if tx has already been executed\n            if (executionState[_srcChainId][nonce] != STATUS_READY) {\n                revert AlreadyExecutedTransaction();\n            }\n\n            // Get User Virtual Account\n            VirtualAccount userAccount = IPort(localPortAddress).fetchVirtualAccount(\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED])))\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            // Avoid stack too deep\n            uint16 srcChainId = _srcChainId;\n\n            // Try to execute remote request\n            // Flag 6 - RootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDepositMultiple(address(userAccount), localRouterAddress, data, _srcChainId)\n            _execute(\n                _payload[0] == 0x86,\n                nonce,\n                address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))),\n                abi.encodeWithSelector(\n                    RootBridgeAgentExecutor.executeSignedWithDepositMultiple.selector,\n                    address(userAccount),\n                    localRouterAddress,\n                    _payload,\n                    srcChainId\n                ),\n                srcChainId\n            );\n\n            // Toggle Router Virtual Account use for tx execution\n            IPort(localPortAddress).toggleVirtualAccountApproved(userAccount, localRouterAddress);\n\n            /// DEPOSIT FLAG: 7 (retrySettlement)\n        } else if (_payload[0] & 0x7F == 0x07) {\n            // Prepare Variables for decoding\n            address owner;\n            bytes memory params;\n            GasParams memory gParams;\n\n            // Decode Input\n            (nonce, owner, params, gParams) = abi.decode(_payload[PARAMS_START:], (uint32, address, bytes, GasParams));\n\n            // Get storage reference\n            Settlement storage settlementReference = getSettlement[nonce];\n\n            // Check if Settlement hasn't been redeemed.\n            if (settlementReference.owner == address(0)) revert SettlementRetryUnavailable();\n\n            // Check settlement owner\n            if (owner != settlementReference.owner) {\n                if (owner != address(IPort(localPortAddress).getUserAccount(settlementReference.owner))) {\n                    revert NotSettlementOwner();\n                }\n            }\n\n            //Update Settlement Staus\n            settlementReference.status = STATUS_SUCCESS;\n\n            //Retry settlement call with new params and gas\n            _performRetrySettlementCall(\n                _payload[0] == 0x87,\n                settlementReference.hTokens,\n                settlementReference.tokens,\n                settlementReference.amounts,\n                settlementReference.deposits,"
    }
  ]
}