{
  "Title": "[M-11] `StandardFunding.fundingVote` should not allow users who didn't vote in screening stage to vote",
  "Content": "\n<https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L519-L569><br>\n<https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L519>\n\nUsers who did not vote in the screening stage but voted in the funding stage are not allowed to claim rewards via `claimDelegateReward`. **Voting in the funding stage will occupy the distribution ratio of rewards**. Since these rewards cannot be claimed, in the long run, the ajnaToken balance of the GrantFund contract is inconsistent with `treasury`.\n\n### Proof of Concept\n\nAt the beginning of the `StandardFunding.claimDelegateReward` function, check whether the caller voted in the screening stage.\n\n```solidity\nfunction claimDelegateReward(\n        uint24 distributionId_\n    ) external override returns(uint256 rewardClaimed_) {\n        // Revert if delegatee didn't vote in screening stage\n->      if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n        ...\n    }\n```\n\n`StandardFunding.fundingVote` is used to vote in the funding stage. This function does not check whether the caller voted in the screening stage. `fundingVote` subcalls [\\_fundingVote](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L612), which affects the allocation of rewards. `_getDelegateReward` is used by `claimDelegateReward` to calculate the reward distributed to the caller.\n\n```solidity\nfunction _getDelegateReward(\n        QuarterlyDistribution memory currentDistribution_,\n        QuadraticVoter memory voter_\n    ) internal pure returns (uint256 rewards_) {\n        // calculate the total voting power available to the voter that was allocated in the funding stage\n        uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;\n\n        // if none of the voter's voting power was allocated, they receive no rewards\n        if (votingPowerAllocatedByDelegatee == 0) return 0;\n\n        // calculate reward\n        // delegateeReward = 10 % of GBC distributed as per delegatee Voting power allocated\n->      rewards_ = Maths.wdiv(\n            Maths.wmul(\n                currentDistribution_.fundsAvailable,\t//total funds in current distribution\n                votingPowerAllocatedByDelegatee\t\t//voter's vote power\n            ),\n            currentDistribution_.fundingVotePowerCast\t//total vote power in current distribution\n        ) / 10;\t\t\t\t\t\t// 10% fundsAvailable\n    }\n```\n\nAs long as `fundingVote` is successfully called, it means that **the reward is locked to the caller**. However, the caller cannot claim these rewards. **There is no code to calculate the amount of these rewards that can never be claimed**.\n\n### Recommended Mitigation Steps\n\nTwo ways to fix this problem:\n\n1.  `FundingVote` does not allow users who didn't vote in screening stage.\n2.  Delete the code on line [L240](https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L240).\n\n**[MikeHathaway (Ajna) confirmed](https://github.com/code-423n4/2023-05-ajna-findings/issues/224#issuecomment-1555111296)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-grants/src/grants/base/StandardFunding.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IERC20 }    from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast }  from \"@oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@oz/token/ERC20/utils/SafeERC20.sol\";\n\nimport { Funding } from \"./Funding.sol\";\n\nimport { IStandardFunding } from \"../interfaces/IStandardFunding.sol\";\n\nimport { Maths } from \"../libraries/Maths.sol\";\n\nabstract contract StandardFunding is Funding, IStandardFunding {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens that can be distributed by the treasury in a quarter.\n     * @dev Stored as a Wad percentage.\n     */\n    uint256 internal constant GLOBAL_BUDGET_CONSTRAINT = 0.03 * 1e18;\n\n    /**\n     * @notice Length of the challengephase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 7 days.\n     * @dev    The period in which funded proposal slates can be checked in updateSlate.\n     */\n    uint256 internal constant CHALLENGE_PERIOD_LENGTH = 50400;\n\n    /**\n     * @notice Length of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 90 days.\n     */\n    uint48 internal constant DISTRIBUTION_PERIOD_LENGTH = 648000;\n\n    /**\n     * @notice Length of the funding phase of the distribution period in blocks.\n     * @dev    Roughly equivalent to the number of blocks in 10 days.\n     */\n    uint256 internal constant FUNDING_PERIOD_LENGTH = 72000;\n\n    /**\n     * @notice Keccak hash of a prefix string for standard funding mechanism\n     */\n    bytes32 internal constant DESCRIPTION_PREFIX_HASH_STANDARD = keccak256(bytes(\"Standard Funding: \"));\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     * @notice ID of the current distribution period.\n     * @dev Used to access information on the status of an ongoing distribution.\n     * @dev Updated at the start of each quarter.\n     * @dev Monotonically increases by one per period.\n     */\n    uint24 internal _currentDistributionId = 0;\n\n    /**\n     * @notice Mapping of quarterly distributions from the grant fund.\n     * @dev distributionId => QuarterlyDistribution\n     */\n    mapping(uint24 => QuarterlyDistribution) internal _distributions;\n\n    /**\n     * @dev Mapping of all proposals that have ever been submitted to the grant fund for screening.\n     * @dev proposalId => Proposal\n     */\n    mapping(uint256 => Proposal) internal _standardFundingProposals;\n\n    /**\n     * @dev Mapping of distributionId to a sorted array of 10 proposalIds with the most votes in the screening period.\n     * @dev distribution.id => proposalId[]\n     * @dev A new array is created for each distribution period\n     */\n    mapping(uint256 => uint256[]) internal _topTenProposals;\n\n    /**\n     * @notice Mapping of a hash of a proposal slate to a list of funded proposals.\n     * @dev slate hash => proposalId[]\n     */\n    mapping(bytes32 => uint256[]) internal _fundedProposalSlates;\n\n    /**\n     * @notice Mapping of quarterly distributions to voters to a Quadratic Voter info struct.\n     * @dev distributionId => voter address => QuadraticVoter \n     */\n    mapping(uint256 => mapping(address => QuadraticVoter)) internal _quadraticVoters;\n\n    /**\n     * @notice Mapping of distributionId to whether surplus funds from distribution updated into treasury\n     * @dev distributionId => bool\n    */\n    mapping(uint256 => bool) internal _isSurplusFundsUpdated;\n\n    /**\n     * @notice Mapping of distributionId to user address to whether user has claimed his delegate reward\n     * @dev distributionId => address => bool\n    */\n    mapping(uint256 => mapping(address => bool)) public hasClaimedReward;\n\n    /**\n     * @notice Mapping of distributionId to user address to total votes cast on screening stage proposals.\n     * @dev distributionId => address => uint256\n    */\n    mapping(uint256 => mapping(address => uint256)) public screeningVotesCast;\n\n    /**************************************************/\n    /*** Distribution Management Functions External ***/\n    /**************************************************/\n\n    /// @inheritdoc IStandardFunding\n    function startNewDistributionPeriod() external override returns (uint24 newDistributionId_) {\n        uint24  currentDistributionId       = _currentDistributionId;\n        uint256 currentDistributionEndBlock = _distributions[currentDistributionId].endBlock;\n\n        // check that there isn't currently an active distribution period\n        if (block.number <= currentDistributionEndBlock) revert DistributionPeriodStillActive();\n\n        // update Treasury with unused funds from last two distributions\n        {\n            // Check if any last distribution exists and its challenge stage is over\n            if (currentDistributionId > 0 && (block.number > _getChallengeStageEndBlock(currentDistributionEndBlock))) {\n                // Add unused funds from last distribution to treasury\n                _updateTreasury(currentDistributionId);\n            }\n\n            // checks if any second last distribution exist and its unused funds are not added into treasury\n            if (currentDistributionId > 1 && !_isSurplusFundsUpdated[currentDistributionId - 1]) {\n                // Add unused funds from second last distribution to treasury\n                _updateTreasury(currentDistributionId - 1);\n            }\n        }\n\n        // set the distribution period to start at the current block\n        uint48 startBlock = SafeCast.toUint48(block.number);\n        uint48 endBlock = startBlock + DISTRIBUTION_PERIOD_LENGTH;\n\n        // set new value for currentDistributionId\n        newDistributionId_ = _setNewDistributionId();\n\n        // create QuarterlyDistribution struct\n        QuarterlyDistribution storage newDistributionPeriod = _distributions[newDistributionId_];\n        newDistributionPeriod.id              = newDistributionId_;\n        newDistributionPeriod.startBlock      = startBlock;\n        newDistributionPeriod.endBlock        = endBlock;\n        uint256 gbc                           = Maths.wmul(treasury, GLOBAL_BUDGET_CONSTRAINT);\n        newDistributionPeriod.fundsAvailable  = SafeCast.toUint128(gbc);\n\n        // decrease the treasury by the amount that is held for allocation in the new distribution period\n        treasury -= gbc;\n\n        emit QuarterlyDistributionStarted(\n            newDistributionId_,\n            startBlock,\n            endBlock\n        );\n    }\n\n    /**************************************************/\n    /*** Distribution Management Functions Internal ***/\n    /**************************************************/\n\n    /**\n     * @notice Get the block number at which this distribution period's challenge stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the challenge stage end block for.\n     * @return The block number at which this distribution period's challenge stage ends.\n    */\n    function _getChallengeStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ + CHALLENGE_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Get the block number at which this distribution period's screening stage ends.\n     * @param  endBlock_ The end block of quarterly distribution to get the screening stage end block for.\n     * @return The block number at which this distribution period's screening stage ends.\n    */\n    function _getScreeningStageEndBlock(\n        uint256 endBlock_\n    ) internal pure returns (uint256) {\n        return endBlock_ - FUNDING_PERIOD_LENGTH;\n    }\n\n    /**\n     * @notice Updates Treasury with surplus funds from distribution.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param distributionId_ distribution Id of updating distribution \n     */\n    function _updateTreasury(\n        uint24 distributionId_\n    ) private {\n        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;\n        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;\n\n        uint256[] memory fundingProposalIds = _fundedProposalSlates[fundedSlateHash];\n\n        uint256 totalTokensRequested;\n        uint256 numFundedProposals = fundingProposalIds.length;\n\n        for (uint i = 0; i < numFundedProposals; ) {\n            Proposal memory proposal = _standardFundingProposals[fundingProposalIds[i]];\n\n            totalTokensRequested += proposal.tokensRequested;\n\n            unchecked { ++i; }\n        }\n\n        // readd non distributed tokens to the treasury\n        treasury += (fundsAvailable - totalTokensRequested);\n\n        _isSurplusFundsUpdated[distributionId_] = true;\n    }\n\n    /**\n     * @notice Set a new DistributionPeriod Id.\n     * @dev    Increments the previous Id nonce by 1.\n     * @return newId_ The new distribution period Id.\n     */\n    function _setNewDistributionId() private returns (uint24 newId_) {\n        newId_ = _currentDistributionId += 1;\n    }\n\n    /************************************/\n    /*** Delegation Rewards Functions ***/\n    /************************************/\n\n    /// @inheritdoc IStandardFunding\n    function claimDelegateReward(\n        uint24 distributionId_\n    ) external override returns(uint256 rewardClaimed_) {\n        // Revert if delegatee didn't vote in screening stage\n        if(screeningVotesCast[distributionId_][msg.sender] == 0) revert DelegateRewardInvalid();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[distributionId_];\n\n        // Check if Challenge Period is still active\n        if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n\n        // check rewards haven't already been claimed\n        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n\n        QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n\n        // calculate rewards earned for voting\n        rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n\n        hasClaimedReward[distributionId_][msg.sender] = true;\n\n        emit DelegateRewardClaimed(\n            msg.sender,\n            distributionId_,\n            rewardClaimed_\n        );\n\n        // transfer rewards to delegatee\n        IERC20(ajnaTokenAddress).safeTransfer(msg.sender, rewardClaimed_);\n    }\n\n    /**\n     * @notice Calculate the delegate rewards that have accrued to a given voter, in a given distribution period.\n     * @dev    Voter must have voted in both the screening and funding stages, and is proportional to their share of votes across the stages.\n     * @param  currentDistribution_ Struct of the distribution period to calculat rewards for.\n     * @param  voter_               Struct of the funding stages voter.\n     * @return rewards_             The delegate rewards accrued to the voter.\n     */\n    function _getDelegateReward(\n        QuarterlyDistribution memory currentDistribution_,\n        QuadraticVoter memory voter_\n    ) internal pure returns (uint256 rewards_) {\n        // calculate the total voting power available to the voter that was allocated in the funding stage\n        uint256 votingPowerAllocatedByDelegatee = voter_.votingPower - voter_.remainingVotingPower;\n\n        // if none of the voter's voting power was allocated, they receive no rewards\n        if (votingPowerAllocatedByDelegatee == 0) return 0;\n\n        // calculate reward\n        // delegateeReward = 10 % of GBC distributed as per delegatee Voting power allocated\n        rewards_ = Maths.wdiv(\n            Maths.wmul(\n                currentDistribution_.fundsAvailable,\n                votingPowerAllocatedByDelegatee\n            ),\n            currentDistribution_.fundingVotePowerCast\n        ) / 10;\n    }\n\n    /***********************************/\n    /*** Proposal Functions External ***/\n    /***********************************/\n\n    /// @inheritdoc IStandardFunding\n    function updateSlate(\n        uint256[] calldata proposalIds_,\n        uint24 distributionId_\n    ) external override returns (bool newTopSlate_) {\n        QuarterlyDistribution storage currentDistribution = _distributions[distributionId_];\n\n        // store number of proposals for reduced gas cost of iterations\n        uint256 numProposalsInSlate = proposalIds_.length;\n\n        // check the each proposal in the slate is valid, and get the sum of the proposals fundingVotesReceived\n        uint256 sum = _validateSlate(distributionId_, currentDistribution.endBlock, currentDistribution.fundsAvailable, proposalIds_, numProposalsInSlate);\n\n        // get pointers for comparing proposal slates\n        bytes32 currentSlateHash = currentDistribution.fundedSlateHash;\n        bytes32 newSlateHash     = keccak256(abi.encode(proposalIds_));\n\n        // check if slate of proposals is better than the existing slate, and is thus the new top slate\n        newTopSlate_ = currentSlateHash == 0 ||\n            (currentSlateHash!= 0 && sum > _sumProposalFundingVotes(_fundedProposalSlates[currentSlateHash]));\n\n        // if slate of proposals is new top slate, update state\n        if (newTopSlate_) {\n            uint256[] storage existingSlate = _fundedProposalSlates[newSlateHash];\n\n            for (uint i = 0; i < numProposalsInSlate; ) {\n\n                // update list of proposals to fund\n                existingSlate.push(proposalIds_[i]);\n\n                unchecked { ++i; }\n            }\n\n            // update hash to point to the new leading slate of proposals\n            currentDistribution.fundedSlateHash = newSlateHash;\n\n            emit FundedSlateUpdated(\n                distributionId_,\n                newSlateHash\n            );\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function executeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        bytes32 descriptionHash_\n    ) external nonReentrant override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, descriptionHash_)));\n        Proposal storage proposal = _standardFundingProposals[proposalId_];\n\n        uint24 distributionId = proposal.distributionId;\n\n        // check that the distribution period has ended, and one week has passed to enable competing slates to be checked\n        if (block.number <= _getChallengeStageEndBlock(_distributions[distributionId].endBlock)) revert ExecuteProposalInvalid();\n\n        // check proposal is succesful and hasn't already been executed\n        if (!_standardFundingVoteSucceeded(proposalId_) || proposal.executed) revert ProposalNotSuccessful();\n\n        proposal.executed = true;\n\n        _execute(proposalId_, targets_, values_, calldatas_);\n    }\n\n    /// @inheritdoc IStandardFunding\n    function proposeStandard(\n        address[] memory targets_,\n        uint256[] memory values_,\n        bytes[] memory calldatas_,\n        string memory description_\n    ) external override returns (uint256 proposalId_) {\n        proposalId_ = _hashProposal(targets_, values_, calldatas_, keccak256(abi.encode(DESCRIPTION_PREFIX_HASH_STANDARD, keccak256(bytes(description_)))));\n\n        Proposal storage newProposal = _standardFundingProposals[proposalId_];\n\n        // check for duplicate proposals\n        if (newProposal.proposalId != 0) revert ProposalAlreadyExists();\n\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // cannot add new proposal after end of screening period\n        // screening period ends 72000 blocks before end of distribution period, ~ 80 days.\n        if (block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert ScreeningPeriodEnded();\n\n        // store new proposal information\n        newProposal.proposalId      = proposalId_;\n        newProposal.distributionId  = currentDistribution.id;\n        newProposal.tokensRequested = _validateCallDatas(targets_, values_, calldatas_); // check proposal parameters are valid and update tokensRequested\n\n        // revert if proposal requested more tokens than are available in the distribution period\n        if (newProposal.tokensRequested > (currentDistribution.fundsAvailable * 9 / 10)) revert InvalidProposal();\n\n        emit ProposalCreated(\n            proposalId_,\n            msg.sender,\n            targets_,\n            values_,\n            new string[](targets_.length),\n            calldatas_,\n            block.number,\n            currentDistribution.endBlock,\n            description_\n        );\n    }\n\n    /***********************************/\n    /*** Proposal Functions Internal ***/\n    /***********************************/\n\n    /**\n     * @notice Check the validity of a potential slate of proposals to execute, and sum the slate's fundingVotesReceived.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through both voting stages.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  distributionId_                   Id of the distribution period to check the slate for.\n     * @param  endBlock                          End block of the distribution period.\n     * @param  distributionPeriodFundsAvailable_ Funds available for distribution in the distribution period.\n     * @param  proposalIds_                      Array of proposal Ids to check.\n     * @param  numProposalsInSlate_              Number of proposals in the slate.\n     * @return sum_                              The total funding votes received by all proposals in the proposed slate.\n     */\n    function _validateSlate(uint24 distributionId_, uint256 endBlock, uint256 distributionPeriodFundsAvailable_, uint256[] calldata proposalIds_, uint256 numProposalsInSlate_) internal view returns (uint256 sum_) {\n        // check that the function is being called within the challenge period\n        if (block.number <= endBlock || block.number > _getChallengeStageEndBlock(endBlock)) {\n            revert InvalidProposalSlate();\n        }\n\n        // check that the slate has no duplicates\n        if (_hasDuplicates(proposalIds_)) revert InvalidProposalSlate();\n\n        uint256 gbc = distributionPeriodFundsAvailable_;\n        uint256 totalTokensRequested = 0;\n\n        // check each proposal in the slate is valid\n        for (uint i = 0; i < numProposalsInSlate_; ) {\n            Proposal memory proposal = _standardFundingProposals[proposalIds_[i]];\n\n            // check if Proposal is in the topTenProposals list\n            if (_findProposalIndex(proposalIds_[i], _topTenProposals[distributionId_]) == -1) revert InvalidProposalSlate();\n\n            // account for fundingVotesReceived possibly being negative\n            if (proposal.fundingVotesReceived < 0) revert InvalidProposalSlate();\n\n            // update counters\n            sum_ += uint128(proposal.fundingVotesReceived); // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            totalTokensRequested += proposal.tokensRequested;\n\n            // check if slate of proposals exceeded budget constraint ( 90% of GBC )\n            if (totalTokensRequested > (gbc * 9 / 10)) {\n                revert InvalidProposalSlate();\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Check an array of proposalIds for duplicate IDs.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length.\n     * @param  proposalIds_ Array of proposal Ids to check.\n     * @return Boolean indicating the presence of a duplicate. True if it has a duplicate; false if not.\n     */\n    function _hasDuplicates(\n        uint256[] calldata proposalIds_\n    ) internal pure returns (bool) {\n        uint256 numProposals = proposalIds_.length;\n\n        for (uint i = 0; i < numProposals; ) {\n            for (uint j = i + 1; j < numProposals; ) {\n                if (proposalIds_[i] == proposalIds_[j]) return true;\n\n                unchecked { ++j; }\n            }\n\n            unchecked { ++i; }\n\n        }\n        return false;\n    }\n\n    /**\n     * @notice Calculates the sum of funding votes allocated to a list of proposals.\n     * @dev    Only iterates through a maximum of 10 proposals that made it through the screening round.\n     * @dev    Counters incremented in an unchecked block due to being bounded by array length of at most 10.\n     * @param  proposalIdSubset_ Array of proposal Ids to sum.\n     * @return sum_ The sum of the funding votes across the given proposals.\n     */\n    function _sumProposalFundingVotes(\n        uint256[] memory proposalIdSubset_\n    ) internal view returns (uint128 sum_) {\n        for (uint i = 0; i < proposalIdSubset_.length;) {\n            // since we are converting from int128 to uint128, we can safely assume that the value will not overflow\n            sum_ += uint128(_standardFundingProposals[proposalIdSubset_[i]].fundingVotesReceived);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Get the current ProposalState of a given proposal.\n     * @dev    Used by GrantFund.state() for analytics compatability purposes.\n     * @param  proposalId_ The ID of the proposal being checked.\n     * @return The proposals status in the ProposalState enum.\n     */\n    function _standardProposalState(uint256 proposalId_) internal view returns (ProposalState) {\n        Proposal memory proposal = _standardFundingProposals[proposalId_];\n\n        if (proposal.executed)                                                     return ProposalState.Executed;\n        else if (_distributions[proposal.distributionId].endBlock >= block.number) return ProposalState.Active;\n        else if (_standardFundingVoteSucceeded(proposalId_))                      return ProposalState.Succeeded;\n        else                                                                       return ProposalState.Defeated;\n    }\n\n    /*********************************/\n    /*** Voting Functions External ***/\n    /*********************************/\n\n    /// @inheritdoc IStandardFunding\n    function fundingVote(\n        FundingVoteParams[] memory voteParams_\n    ) external override returns (uint256 votesCast_) {\n        uint24 currentDistributionId = _currentDistributionId;\n\n        QuarterlyDistribution storage currentDistribution = _distributions[currentDistributionId];\n        QuadraticVoter        storage voter               = _quadraticVoters[currentDistributionId][msg.sender];\n\n        uint256 endBlock = currentDistribution.endBlock;\n\n        uint256 screeningStageEndBlock = _getScreeningStageEndBlock(endBlock);\n\n        // check that the funding stage is active\n        if (block.number <= screeningStageEndBlock || block.number > endBlock) revert InvalidVote();\n\n        uint128 votingPower = voter.votingPower;\n\n        // if this is the first time a voter has attempted to vote this period,\n        // set initial voting power and remaining voting power\n        if (votingPower == 0) {\n\n            // calculate the voting power available to the voting power in this funding stage\n            uint128 newVotingPower = SafeCast.toUint128(_getVotesFunding(msg.sender, votingPower, voter.remainingVotingPower, screeningStageEndBlock));\n\n            voter.votingPower          = newVotingPower;\n            voter.remainingVotingPower = newVotingPower;\n        }\n\n        uint256 numVotesCast = voteParams_.length;\n\n        for (uint256 i = 0; i < numVotesCast; ) {\n            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n            // check that the proposal is part of the current distribution period\n            if (proposal.distributionId != currentDistributionId) revert InvalidVote();\n\n            // check that the proposal being voted on is in the top ten screened proposals\n            if (_findProposalIndex(voteParams_[i].proposalId, _topTenProposals[currentDistributionId]) == -1) revert InvalidVote();\n\n            // cast each successive vote\n            votesCast_ += _fundingVote(\n                currentDistribution,\n                proposal,\n                msg.sender,\n                voter,\n                voteParams_[i]\n            );\n\n            unchecked { ++i; }\n        }\n    }\n\n    /// @inheritdoc IStandardFunding\n    function screeningVote(\n        ScreeningVoteParams[] memory voteParams_\n    ) external override returns (uint256 votesCast_) {\n        QuarterlyDistribution memory currentDistribution = _distributions[_currentDistributionId];\n\n        // check screening stage is active\n        if (block.number < currentDistribution.startBlock || block.number > _getScreeningStageEndBlock(currentDistribution.endBlock)) revert InvalidVote();\n\n        uint256 numVotesCast = voteParams_.length;\n\n        for (uint256 i = 0; i < numVotesCast; ) {\n            Proposal storage proposal = _standardFundingProposals[voteParams_[i].proposalId];\n\n            // check that the proposal is part of the current distribution period\n            if (proposal.distributionId != currentDistribution.id) revert InvalidVote();\n\n            uint256 votes = voteParams_[i].votes;\n\n            // cast each successive vote\n            votesCast_ += votes;\n            _screeningVote(msg.sender, proposal, votes);\n\n            unchecked { ++i; }\n        }\n    }\n\n    /*********************************/\n    /*** Voting Functions Internal ***/\n    /*********************************/\n\n    /**\n     * @notice Vote on a proposal in the funding stage of the Distribution Period.\n     * @dev    Votes can be allocated to multiple proposals, quadratically, for or against.\n     * @param  currentDistribution_  The current distribution period.\n     * @param  proposal_             The current proposal being voted upon.\n     * @param  account_              The voting account.\n     * @param  voter_                The voter data struct tracking available votes.\n     * @param  voteParams_           The amount of votes being allocated to the proposal. Not squared. If less than 0, vote is against.\n     * @return incrementalVotesUsed_ The amount of funding stage votes allocated to the proposal.\n     */\n    function _fundingVote(\n        QuarterlyDistribution storage currentDistribution_,\n        Proposal storage proposal_,\n        address account_,\n        QuadraticVoter storage voter_,\n        FundingVoteParams memory voteParams_\n    ) internal returns (uint256 incrementalVotesUsed_) {\n        uint8  support = 1;\n        uint256 proposalId = proposal_.proposalId;\n\n        // determine if voter is voting for or against the proposal\n        voteParams_.votesUsed < 0 ? support = 0 : support = 1;\n\n        uint128 votingPower = voter_.votingPower;\n\n        // the total amount of voting power used by the voter before this vote executes\n        uint128 voterPowerUsedPreVote = votingPower - voter_.remainingVotingPower;\n\n        FundingVoteParams[] storage votesCast = voter_.votesCast;\n\n        // check that the voter hasn't already voted on a proposal by seeing if it's already in the votesCast array \n        int256 voteCastIndex = _findProposalIndexOfVotesCast(proposalId, votesCast);\n\n        // voter had already cast a funding vote on this proposal\n        if (voteCastIndex != -1) {\n            // since we are converting from int256 to uint256, we can safely assume that the value will not overflow\n            FundingVoteParams storage existingVote = votesCast[uint256(voteCastIndex)];\n\n            // can't change the direction of a previous vote\n            if (support == 0 && existingVote.votesUsed > 0 || support == 1 && existingVote.votesUsed < 0) {\n                // if the vote is in the opposite direction of a previous vote,\n                // and the proposal is already in the votesCast array, revert can't change direction\n                revert FundingVoteWrongDirection();\n            }\n            else {\n                // update the votes cast for the proposal\n                existingVote.votesUsed += voteParams_.votesUsed;\n            }\n        }\n        // first time voting on this proposal, add the newly cast vote to the voter's votesCast array\n        else {\n            votesCast.push(voteParams_);\n        }\n\n        // calculate the cumulative cost of all votes made by the voter\n        // and check that attempted votes cast doesn't overflow uint128\n        uint256 sumOfTheSquareOfVotesCast = _sumSquareOfVotesCast(votesCast);\n        if (sumOfTheSquareOfVotesCast > type(uint128).max) revert InsufficientVotingPower();\n        uint128 cumulativeVotePowerUsed = SafeCast.toUint128(sumOfTheSquareOfVotesCast);\n\n        // check that the voter has enough voting power remaining to cast the vote\n        if (cumulativeVotePowerUsed > votingPower) revert InsufficientVotingPower();\n\n        // update voter voting power accumulator\n        voter_.remainingVotingPower = votingPower - cumulativeVotePowerUsed;\n\n        // calculate the change in voting power used by the voter in this vote in order to accurately track the total voting power used in the funding stage\n        // since we are moving from uint128 to uint256, we can safely assume that the value will not overflow\n        uint256 incrementalVotingPowerUsed = uint256(cumulativeVotePowerUsed - voterPowerUsedPreVote);\n\n        // update accumulator for total voting power used in the funding stage in order to calculate delegate rewards\n        currentDistribution_.fundingVotePowerCast += incrementalVotingPowerUsed;\n\n        // update proposal vote tracking\n        proposal_.fundingVotesReceived += SafeCast.toInt128(voteParams_.votesUsed);\n\n        // the incremental additional votes cast on the proposal to be used as a return value and emit value\n        incrementalVotesUsed_ = SafeCast.toUint256(Maths.abs(voteParams_.votesUsed));\n\n        // emit VoteCast instead of VoteCastWithParams to maintain compatibility with Tally\n        // emits the amount of incremental votes cast for the proposal, not the voting power cost or total votes on a proposal\n        emit VoteCast(\n            account_,\n            proposalId,\n            support,\n            incrementalVotesUsed_,\n            \"\"\n        );\n    }\n\n    /**\n     * @notice Vote on a proposal in the screening stage of the Distribution Period.\n     * @param account_  The voting account.\n     * @param proposal_ The current proposal being voted upon.\n     * @param votes_    The amount of votes being cast.\n     */\n    function _screeningVote(\n        address account_,\n        Proposal storage proposal_,\n        uint256 votes_\n    ) internal {\n        uint24 distributionId = proposal_.distributionId;\n\n        // check that the voter has enough voting power to cast the vote\n        if (screeningVotesCast[distributionId][account_] + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n\n        uint256[] storage currentTopTenProposals = _topTenProposals[distributionId];\n        uint256 proposalId = proposal_.proposalId;\n\n        // update proposal votes counter\n        proposal_.votesReceived += SafeCast.toUint128(votes_);\n\n        // check if proposal was already screened\n        int indexInArray = _findProposalIndex(proposalId, currentTopTenProposals);\n        uint256 screenedProposalsLength = currentTopTenProposals.length;\n\n        // check if the proposal should be added to the top ten list for the first time\n        if (screenedProposalsLength < 10 && indexInArray == -1) {\n            currentTopTenProposals.push(proposalId);\n\n            // sort top ten proposals\n            _insertionSortProposalsByVotes(currentTopTenProposals, screenedProposalsLength);\n        }\n        else {\n            // proposal is already in the array\n            if (indexInArray != -1) {\n                // re-sort top ten proposals to account for new vote totals\n                _insertionSortProposalsByVotes(currentTopTenProposals, uint256(indexInArray));\n            }\n            // proposal isn't already in the array\n            else if(_standardFundingProposals[currentTopTenProposals[screenedProposalsLength - 1]].votesReceived < proposal_.votesReceived) {\n                // replace the least supported proposal with the new proposal\n                currentTopTenProposals.pop();\n                currentTopTenProposals.push(proposalId);\n\n                // sort top ten proposals"
    }
  ]
}