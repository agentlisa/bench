{
  "Title": "[L15] Missing error messages in require statements",
  "Content": "Some `require` statements are missing error messages, such as the following:\n\n\n* the [`transfer` calls](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/flipper/Flipper.sol#L38-L39) in the [`Flipper` contracts](https://github.com/OriginProtocol/origin-dollar/tree/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/flipper)\n* the require statements within the [`upgradeGlobals`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/token/OUSDResolutionUpgrade.sol#L9) and [`upgradeAccounts`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/token/OUSDResolutionUpgrade.sol#L20) functions of the [`OUSDResolutionUpgrade` contract](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/token/OUSDResolutionUpgrade.sol)\n\n\nTo improve the codeâ€™s readability and to help debugging issues that may arise, consider including specific and informative error messages in all `require` statements.\n\n\n**Update:** *Fixed in [PR#662](https://github.com/OriginProtocol/origin-dollar/pull/662).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/flipper/Flipper.sol",
      "content": "pragma solidity 0.5.11;\n\nimport \"../governance/Governable.sol\";\nimport \"../token/OUSD.sol\";\nimport \"../interfaces/Tether.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n// Contract to exchange usdt, usdc, dai from and to ousd.\n//   - 1 to 1. No slippage\n//   - Optimized for low gas usage\n//   - No guarantee of availability\n\ncontract Flipper is Governable {\n    using SafeERC20 for IERC20;\n\n    uint256 constant MAXIMUM_PER_TRADE = (25000 * 1e18);\n\n    // Saves approx 4K gas per swap by using hardcoded addresses.\n    IERC20 dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    OUSD constant ousd = OUSD(0x2A8e1E676Ec238d8A992307B495b45B3fEAa5e86);\n    IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    Tether constant usdt = Tether(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\n    // -----------\n    // Constructor\n    // -----------\n    constructor() public {}\n\n    // -----------------\n    // Trading functions\n    // -----------------\n\n    /// @notice Purchase OUSD with Dai\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithDai(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(dai.transferFrom(msg.sender, address(this), amount));\n        require(ousd.transfer(msg.sender, amount));\n    }\n\n    /// @notice Sell OUSD for Dai\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForDai(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(dai.transfer(msg.sender, amount));\n        require(ousd.transferFrom(msg.sender, address(this), amount));\n    }\n\n    /// @notice Purchase OUSD with USDC\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithUsdc(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // Potential rounding error is an intentional tradeoff\n        require(usdc.transferFrom(msg.sender, address(this), amount / 1e12));\n        require(ousd.transfer(msg.sender, amount));\n    }\n\n    /// @notice Sell OUSD for USDC\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForUsdc(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        require(usdc.transfer(msg.sender, amount / 1e12));\n        require(ousd.transferFrom(msg.sender, address(this), amount));\n    }\n\n    /// @notice Purchase OUSD with USDT\n    /// @param amount Amount of OUSD to purchase, in 18 fixed decimals.\n    function buyOusdWithUsdt(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // Potential rounding error is an intentional tradeoff\n        // USDT does not return a boolean and reverts,\n        // so no need for a require.\n        usdt.transferFrom(msg.sender, address(this), amount / 1e12);\n        require(ousd.transfer(msg.sender, amount));\n    }\n\n    /// @notice Sell OUSD for USDT\n    /// @param amount Amount of OUSD to sell, in 18 fixed decimals.\n    function sellOusdForUsdt(uint256 amount) external {\n        require(amount <= MAXIMUM_PER_TRADE, \"Amount too large\");\n        // USDT does not return a boolean and reverts,\n        // so no need for a require.\n        usdt.transfer(msg.sender, amount / 1e12);\n        require(ousd.transferFrom(msg.sender, address(this), amount));\n    }\n\n    // --------------------\n    // Governance functions\n    // --------------------\n\n    /// @dev Opting into yield reduces the gas cost per transfer by about 4K, since\n    /// ousd needs to do less accounting and one less storage write.\n    function rebaseOptIn() external onlyGovernor nonReentrant {\n        ousd.rebaseOptIn();\n    }\n\n    /// @notice Owner function to withdraw a specific amount of a token\n    function withdraw(address token, uint256 amount)\n        external\n        onlyGovernor\n        nonReentrant\n    {\n        IERC20(token).safeTransfer(_governor(), amount);\n    }\n\n    /// @notice Owner function to withdraw all tradable tokens\n    /// @dev Equivalent to \"pausing\" the contract.\n    function withdrawAll() external onlyGovernor nonReentrant {\n        IERC20(dai).safeTransfer(_governor(), dai.balanceOf(address(this)));\n        IERC20(ousd).safeTransfer(_governor(), ousd.balanceOf(address(this)));\n        IERC20(address(usdt)).safeTransfer(\n            _governor(),\n            usdt.balanceOf(address(this))\n        );\n        IERC20(usdc).safeTransfer(_governor(), usdc.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "contracts/contracts/token/OUSDResolutionUpgrade.sol",
      "content": "pragma solidity 0.5.11;\n\nimport { OUSDStorage } from \"./OUSDStorage.sol\";\n\ncontract OUSDResolutionUpgrade is OUSDStorage {\n    uint256 private constant RESOLUTION_INCREASE = 1e9;\n\n    function upgradeGlobals() external {\n        require(isUpgraded[address(0)] == 0);\n        isUpgraded[address(0)] = 1;\n        rebasingCredits = rebasingCredits.mul(RESOLUTION_INCREASE);\n        rebasingCreditsPerToken = rebasingCreditsPerToken.mul(\n            RESOLUTION_INCREASE\n        );\n    }\n\n    function upgradeAccounts(address[] calldata accounts) external {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(isUpgraded[account] == 0);\n            isUpgraded[account] = 1;\n\n            // Is the account non-rebasing\n            uint256 nrc = nonRebasingCreditsPerToken[account];\n            if (nrc > 1e19) {\n                // Account has already been created at high resolution\n                continue;\n            }\n\n            if (nrc > 0) {\n                nonRebasingCreditsPerToken[account] = nrc.mul(\n                    RESOLUTION_INCREASE\n                );\n            }\n            _creditBalances[account] = _creditBalances[account].mul(\n                RESOLUTION_INCREASE\n            );\n        }\n    }\n\n    // We have to fill the ERC20 interface in order to not be an abstract\n    // contract that cannot be deployed.\n\n    function totalSupply() external view returns (uint256) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256)\n    {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        revert(\"OUSD: Upgrading\");\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        revert(\"OUSD: Upgrading\");\n    }\n}"
    }
  ]
}