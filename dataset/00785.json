{
  "Title": "M-1: The `CouncilMember` contract DoS due to the `_retrieve` function revert",
  "Content": "# Issue M-1: The `CouncilMember` contract DoS due to the `_retrieve` function revert \n\nSource: https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/47 \n\n## Found by \n0xadrii, Arz, Ignite, Tricko, fibonacci\n## Summary\n\nThe `_retrieve`function is called before any significant state changes. This function executes the withdrawal from the `_target`, which might be a Sablier stream or another protocol. `SablierV2Lockup` reverts if withdrawable amount equals to `0`.\n\nhttps://github.com/sablier-labs/v2-core/blob/b0016437ef3cc8606e1100965dd911d7e658b40b/src/abstracts/SablierV2Lockup.sol#L297-L299\nhttps://github.com/sablier-labs/v2-core/blob/b0016437ef3cc8606e1100965dd911d7e658b40b/src/abstracts/SablierV2Lockup.sol#L270-L272\n\nFunds are distributed over time. And even if there are always funds in the protocol for distribution, after calling the `_retrieve` function, a new distribution will not be available until another period of time has passed.\n\nThis means that any interaction with the `CouncilMember` contract will be unavailable during this time.\n\n## Vulnerability Detail\n\n1\\. If the protocol for distributing funds employs a strategy that permits funds to be released once within a specific timeframe (for instance, 1 day, 1 week, or 1 month), this implies that the `CouncilMember` contract will execute its tasks error-free only once during this period.\n\n2\\. The `removeFromOffice` function calls the `_retrieve`function at the beginning to retrieve and distribute any pending TELCOIN for all council members, and transfer token ownership at the end.\n\nhttps://github.com/sherlock-audit/2024-01-telcoin/blob/main/telcoin-audit/contracts/sablier/core/CouncilMember.sol#L267-L295\n\nThe `_update` function, which is called before each transfer, is overridden and also calls the `_retrieve` function.\n\nhttps://github.com/sherlock-audit/2024-01-telcoin/blob/main/telcoin-audit/contracts/sablier/core/CouncilMember.sol#L321-L331\n\nThus, during the `removeFromOffice` function, the `_retrieve` function will be called twice, which will always result in revert, since after the first distribution of funds, when called again, the withdrawable amount will be `0`.\n\n3\\. Also, according to the sponsor's comment, the council members are semi-trusted. A malicious member can prevent others from interacting with the contract. For example:\n- Member A wants to claim their allocated amounts of TELCOIN\n- Member B fron-runs member's A transaction and call the `retrieve` function\n- Member's A transaction reverts because the `_retrieve` function is called again but there are no more withdrawable amount.\n\n## Impact\n\nDenial of Service of the `CouncilMember` contract over a period of time, depending on the fund distribution strategy. The `removeFromOffice` function always fails, leading to the necessity to use the `transferFrom` function, which does not call `_withdrawAll`, potentially breaking the state of the contract\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-telcoin/blob/main/telcoin-audit/contracts/sablier/core/CouncilMember.sol#L267-L295\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck amount before executing withdrawal or wrap call in a `try/catch` block. Also consider abandoning the `removeFromOffice` function, use  `transferFrom` instead and move `_withdrawAll` call to  `_update` function.\n\n\n\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/37\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { valid and a dupp of 051 with a non standard recommendation than 051}\n\n\n\n**nevillehuang**\n\n@amshirif I think this could possibly be medium severity, given there is no definite loss of funds other than when a malicious council member can be prevented from being removed. The difference between this and #139 is it doesn't affect withdrawals of council members. Also I think #141 and #98 are the most comprehensive report, with #118 highlighting a front-running issue. (but sherlock automated tool selected this)\n\n**amshirif**\n\n@nevillehuang Yes I agree\n\n**0xf1b0**\n\nEscalate\n\nI disagree with the severity. It shares the same impact as #139, as both are results of the `_retrieve` function reverting. However, the root cause of the revert is different.\n\nThis issue also affects the withdrawal, as the withdrawal process itself includes the `_retrieve` function call. The Vulnerability Detail section provides scenarios 1 and 3, which illustrate how withdrawals can potentially be halted.\n\n**sherlock-admin**\n\n> Escalate\n> \n> I disagree with the severity. It shares the same impact as #139, as both are results of the `_retrieve` function reverting. However, the root cause of the revert is different.\n> \n> This issue also affects the withdrawal, as the withdrawal process itself includes the `_retrieve` function call. The Vulnerability Detail section provides scenarios 1 and 3, which illustrate how withdrawals can potentially be halted.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@0xf1b0 Can you provide a coded PoC so that I can analyze the differences in root cause? I think this might be a duplicate of #139 \n\n**0xArz**\n\n@nevillehuang The root cause in https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/139 is that when calling `_retrieve()` it will always revert because we are calling a wrong address.\n\nThe root cause here is that `_retrieve()` reverts when withdrawing 0 amounts, in some functions like mint() it is called 2 times - first called in the function and then its called the second time in ERC721.update() which will fail the second time because we already withdrew the max. Or for example a stream is used where the withdrawable amount is 0 for some time - unlocking in steps etc.\n\nThe impact of this issue is that we call only mint 1 CouncilMember nft because the first time mint() is called,  `_retrieve()` is called only once, after that all calls to mint(),burn() and removeFromOffice() will revert because  `_retrieve()` is called 2 times. \n\nThe 1 council member can still claim the rewards but if a dynamic stream is used and the council member calls the public `retrieve()` he can then fail to claim his rewards for some time until more rewards are unlocked. Although because we will only have 1 council member this will lead to unfair distribution of the rewards\n\n**amshirif**\n\nThis is not a duplicate of #139, and it does not share the same impact. #139 is more serious as it essentially prevents the withdrawal ability from ever working. \n\n**nevillehuang**\n\nAgree with sponsor @amshirif, unless @0xArz @0xf1b0 can show a PoC  of the issue showing an impact that prevents withdrawals/affects rewards claiming.\n\n**0xArz**\n\n> Agree with sponsor @amshirif, unless @0xArz @0xf1b0 can show a PoC of the issue showing an impact that prevents withdrawals/affects rewards claiming.\n\nI agree, funds can be stuck but the DoS is only temporarily. However if we only have 1 council member then 100% of the funds are distributed to him which imo is quite a big problem as council members are semitrusted and other members that were supposed to receive funds will not receive anything but its up to you to decide whether this defines high severity or no. \n\n**nevillehuang**\n\n@0xArz I am abit confused by your statement. How can there be other council members that were supposed to receive funds when there is only 1 council member decided by the governance?\n\n**0xArz**\n\n@nevillehuang Yeah there will only be 1 council member but for example lets say the governance wanted to have 3 council members, they will fail to set the other members after the first one because the retrieve reverts. So instead of having 3 council members there will only be 1 and he will receive 100% of the funds while the other members that were supposed to be set will not receive anything because they were not set\n\n**0xf1b0**\n\n> Agree with sponsor @amshirif, unless @0xArz @0xf1b0 can show a PoC of the issue showing an impact that prevents withdrawals/affects rewards claiming.\n\nDoesn't case 3 from the Vulnerability Detail, where malicious actor can front-run every transaction with `retrieve` call, show this impact? No one will be able to withdraw funds.\n\n**nevillehuang**\n\n@0xArz Acknowledge this possibility given `mint()` and `burn()` can possibly be bricked too. However, since the first council member still get their intended rewards, admins can then choose to not topup rewards thereafter. So I believe this is just a DoS scenario.\n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state as is.\n\nThe provided context and discussion fail to make the case for high severity as the impact is limited to specific actors and scenarios. \n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xf1b0](https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/47/#issuecomment-1918575132): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/156",
  "Code": [
    {
      "filename": "src/abstracts/SablierV2Lockup.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport { IERC4906 } from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport { ISablierV2Comptroller } from \"../interfaces/ISablierV2Comptroller.sol\";\nimport { ISablierV2Lockup } from \"../interfaces/ISablierV2Lockup.sol\";\nimport { ISablierV2NFTDescriptor } from \"../interfaces/ISablierV2NFTDescriptor.sol\";\nimport { ISablierV2LockupRecipient } from \"../interfaces/hooks/ISablierV2LockupRecipient.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Lockup } from \"../types/DataTypes.sol\";\nimport { SablierV2Base } from \"./SablierV2Base.sol\";\n\n/// @title SablierV2Lockup\n/// @notice See the documentation in {ISablierV2Lockup}.\nabstract contract SablierV2Lockup is\n    IERC4906, // 2 inherited components\n    SablierV2Base, // 4 inherited components\n    ISablierV2Lockup, // 4 inherited components\n    ERC721 // 6 inherited components\n{\n    /*//////////////////////////////////////////////////////////////////////////\n                                USER-FACING STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    uint256 public override nextStreamId;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  INTERNAL STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Contract that generates the non-fungible token URI.\n    ISablierV2NFTDescriptor internal _nftDescriptor;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @param initialAdmin The address of the initial contract admin.\n    /// @param initialComptroller The address of the initial comptroller.\n    /// @param initialNFTDescriptor The address of the initial NFT descriptor.\n    constructor(\n        address initialAdmin,\n        ISablierV2Comptroller initialComptroller,\n        ISablierV2NFTDescriptor initialNFTDescriptor\n    )\n        SablierV2Base(initialAdmin, initialComptroller)\n    {\n        _nftDescriptor = initialNFTDescriptor;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks that `streamId` does not reference a null stream.\n    modifier notNull(uint256 streamId) {\n        if (!isStream(streamId)) {\n            revert Errors.SablierV2Lockup_Null(streamId);\n        }\n        _;\n    }\n\n    /// @dev Emits an ERC-4906 event to trigger an update of the NFT metadata.\n    modifier updateMetadata(uint256 streamId) {\n        _;\n        emit MetadataUpdate({ _tokenId: streamId });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRecipient(uint256 streamId) external view override returns (address recipient) {\n        // Checks: the stream NFT exists.\n        _requireMinted({ tokenId: streamId });\n\n        // The NFT owner is the stream's recipient.\n        recipient = _ownerOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCold(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.SETTLED || status == Lockup.Status.CANCELED || status == Lockup.Status.DEPLETED;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isDepleted(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function isStream(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function isWarm(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.PENDING || status == Lockup.Status.STREAMING;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256 streamId) public view override(IERC721Metadata, ERC721) returns (string memory uri) {\n        // Checks: the stream NFT exists.\n        _requireMinted({ tokenId: streamId });\n\n        // Generate the URI describing the stream NFT.\n        uri = _nftDescriptor.tokenURI({ sablier: this, streamId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function wasCanceled(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawableAmount)\n    {\n        withdrawableAmount = _withdrawableAmountOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isTransferable(uint256 streamId) public view virtual returns (bool);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function burn(uint256 streamId) external override noDelegateCall {\n        // Checks: only depleted streams can be burned. This also checks that the stream is not null.\n        if (!isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamNotDepleted(streamId);\n        }\n\n        // Checks:\n        // 1. NFT exists (see {IERC721.getApproved}).\n        // 2. `msg.sender` is either the owner of the NFT or an approved third party.\n        if (!_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Effects: burn the NFT.\n        _burn({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancel(uint256 streamId) public override noDelegateCall {\n        // Checks: the stream is neither depleted nor canceled. This also checks that the stream is not null.\n        if (isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (wasCanceled(streamId)) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        }\n\n        // Checks: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks, Effects and Interactions: cancel the stream.\n        _cancel(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancelMultiple(uint256[] calldata streamIds) external override noDelegateCall {\n        // Iterate over the provided array of stream ids and cancel each stream.\n        uint256 count = streamIds.length;\n        for (uint256 i = 0; i < count;) {\n            // Effects and Interactions: cancel the stream.\n            cancel(streamIds[i]);\n\n            // Increment the loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function renounce(uint256 streamId) external override noDelegateCall notNull(streamId) updateMetadata(streamId) {\n        // Checks: the stream is not cold.\n        Lockup.Status status = _statusOf(streamId);\n        if (status == Lockup.Status.DEPLETED) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (status == Lockup.Status.CANCELED) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        } else if (status == Lockup.Status.SETTLED) {\n            revert Errors.SablierV2Lockup_StreamSettled(streamId);\n        }\n\n        // Checks: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks and Effects: renounce the stream.\n        _renounce(streamId);\n\n        // Log the renouncement.\n        emit ISablierV2Lockup.RenounceLockupStream(streamId);\n\n        // Interactions: if the recipient is a contract, try to invoke the renounce hook on the recipient without\n        // reverting if the hook is not implemented, and also without bubbling up any potential revert.\n        address recipient = _ownerOf(streamId);\n        if (recipient.code.length > 0) {\n            try ISablierV2LockupRecipient(recipient).onStreamRenounced(streamId) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function setNFTDescriptor(ISablierV2NFTDescriptor newNFTDescriptor) external override onlyAdmin {\n        // Effects: set the NFT descriptor.\n        ISablierV2NFTDescriptor oldNftDescriptor = _nftDescriptor;\n        _nftDescriptor = newNFTDescriptor;\n\n        // Log the change of the NFT descriptor.\n        emit ISablierV2Lockup.SetNFTDescriptor({\n            admin: msg.sender,\n            oldNFTDescriptor: oldNftDescriptor,\n            newNFTDescriptor: newNFTDescriptor\n        });\n\n        // Refresh the NFT metadata for all streams.\n        emit BatchMetadataUpdate({ _fromTokenId: 1, _toTokenId: nextStreamId - 1 });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdraw(\n        uint256 streamId,\n        address to,\n        uint128 amount\n    )\n        public\n        override\n        noDelegateCall\n        updateMetadata(streamId)\n    {\n        // Checks: the stream is not depleted. This also checks that the stream is not null.\n        if (isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        }\n\n        bool isCallerStreamSender = _isCallerStreamSender(streamId);\n\n        // Checks: `msg.sender` is the stream's sender, the stream's recipient, or an approved third party.\n        if (!isCallerStreamSender && !_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Retrieve the recipient from storage.\n        address recipient = _ownerOf(streamId);\n\n        // Checks: if `msg.sender` is the stream's sender, the withdrawal address must be the recipient.\n        if (isCallerStreamSender && to != recipient) {\n            revert Errors.SablierV2Lockup_InvalidSenderWithdrawal(streamId, msg.sender, to);\n        }\n\n        // Checks: the withdrawal address is not zero.\n        if (to == address(0)) {\n            revert Errors.SablierV2Lockup_WithdrawToZeroAddress();\n        }\n\n        // Checks: the withdraw amount is not zero.\n        if (amount == 0) {\n            revert Errors.SablierV2Lockup_WithdrawAmountZero(streamId);\n        }\n\n        // Checks: the withdraw amount is not greater than the withdrawable amount.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (amount > withdrawableAmount) {\n            revert Errors.SablierV2Lockup_Overdraw(streamId, amount, withdrawableAmount);\n        }\n\n        // Effects and Interactions: make the withdrawal.\n        _withdraw(streamId, to, amount);\n\n        // Interactions: if `msg.sender` is not the recipient and the recipient is a contract, try to invoke the\n        // withdraw hook on it without reverting if the hook is not implemented, and also without bubbling up\n        // any potential revert.\n        if (msg.sender != recipient && recipient.code.length > 0) {\n            try ISablierV2LockupRecipient(recipient).onStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMax(uint256 streamId, address to) external override {\n        withdraw({ streamId: streamId, to: to, amount: _withdrawableAmountOf(streamId) });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMaxAndTransfer(\n        uint256 streamId,\n        address newRecipient\n    )\n        external\n        override\n        noDelegateCall\n        notNull(streamId)\n    {\n        // Checks: the caller is the current recipient. This also checks that the NFT was not burned.\n        address currentRecipient = _ownerOf(streamId);\n        if (msg.sender != currentRecipient) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Skip the withdrawal if the withdrawable amount is zero.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (withdrawableAmount > 0) {\n            withdraw({ streamId: streamId, to: currentRecipient, amount: withdrawableAmount });\n        }\n\n        // Checks and Effects: transfer the NFT.\n        _transfer({ from: currentRecipient, to: newRecipient, tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMultiple(\n        uint256[] calldata streamIds,\n        address to,\n        uint128[] calldata amounts\n    )\n        external\n        override\n        noDelegateCall\n    {\n        // Checks: there is an equal number of `streamIds` and `amounts`.\n        uint256 streamIdsCount = streamIds.length;\n        uint256 amountsCount = amounts.length;\n        if (streamIdsCount != amountsCount) {\n            revert Errors.SablierV2Lockup_WithdrawArrayCountsNotEqual(streamIdsCount, amountsCount);\n        }\n\n        // Iterate over the provided array of stream ids and withdraw from each stream.\n        for (uint256 i = 0; i < streamIdsCount;) {\n            // Checks, Effects and Interactions: check the parameters and make the withdrawal.\n            withdraw(streamIds[i], to, amounts[i]);\n\n            // Increment the loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                             INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Overrides the internal ERC-721 transfer function to emit an ERC-4906 event upon transfer. The goal is to\n    /// refresh the NFT metadata on external platforms.\n    /// @dev This event is also emitted when the NFT is minted or burned.\n    function _afterTokenTransfer(\n        address, /* from */\n        address, /* to */\n        uint256 streamId,\n        uint256 /* batchSize */\n    )\n        internal\n        override\n        updateMetadata(streamId)\n    { }\n\n    /// @notice Overrides the internal ERC-721 transfer function to check that the stream is transferable.\n    /// @dev There are two cases when the transferable flag is ignored:\n    /// - If `from` is 0, then the transfer is a mint and is allowed.\n    /// - If `to` is 0, then the transfer is a burn and is also allowed.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 streamId,\n        uint256 /* batchSize */\n    )\n        internal\n        view\n        override\n    {\n        if (!isTransferable(streamId) && to != address(0) && from != address(0)) {\n            revert Errors.SablierV2Lockup_NotTransferable(streamId);\n        }\n    }\n\n    /// @notice Checks whether `msg.sender` is the stream's recipient or an approved third party.\n    /// @param streamId The stream id for the query.\n    function _isCallerStreamRecipientOrApproved(uint256 streamId) internal view returns (bool) {\n        address recipient = _ownerOf(streamId);\n        return msg.sender == recipient || isApprovedForAll({ owner: recipient, operator: msg.sender })\n            || getApproved(streamId) == msg.sender;\n    }\n\n    /// @notice Checks whether `msg.sender` is the stream's sender.\n    /// @param streamId The stream id for the query.\n    function _isCallerStreamSender(uint256 streamId) internal view virtual returns (bool);\n\n    /// @dev Retrieves the stream's status without performing a null check.\n    function _statusOf(uint256 streamId) internal view virtual returns (Lockup.Status);\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _withdrawableAmountOf(uint256 streamId) internal view virtual returns (uint128);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           INTERNAL NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _cancel(uint256 tokenId) internal virtual;\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _renounce(uint256 streamId) internal virtual;\n\n    /// @dev See the documentation for the user-facing functions that call this internal function.\n    function _withdraw(uint256 streamId, address to, uint128 amount) internal virtual;\n}"
    },
    {
      "filename": "src/abstracts/SablierV2Lockup.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19;\n\nimport { IERC4906 } from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport { ISablierV2Comptroller } from \"../interfaces/ISablierV2Comptroller.sol\";\nimport { ISablierV2Lockup } from \"../interfaces/ISablierV2Lockup.sol\";\nimport { ISablierV2NFTDescriptor } from \"../interfaces/ISablierV2NFTDescriptor.sol\";\nimport { ISablierV2LockupRecipient } from \"../interfaces/hooks/ISablierV2LockupRecipient.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport { Lockup } from \"../types/DataTypes.sol\";\nimport { SablierV2Base } from \"./SablierV2Base.sol\";\n\n/// @title SablierV2Lockup\n/// @notice See the documentation in {ISablierV2Lockup}.\nabstract contract SablierV2Lockup is\n    IERC4906, // 2 inherited components\n    SablierV2Base, // 4 inherited components\n    ISablierV2Lockup, // 4 inherited components\n    ERC721 // 6 inherited components\n{\n    /*//////////////////////////////////////////////////////////////////////////\n                                USER-FACING STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    uint256 public override nextStreamId;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  INTERNAL STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Contract that generates the non-fungible token URI.\n    ISablierV2NFTDescriptor internal _nftDescriptor;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @param initialAdmin The address of the initial contract admin.\n    /// @param initialComptroller The address of the initial comptroller.\n    /// @param initialNFTDescriptor The address of the initial NFT descriptor.\n    constructor(\n        address initialAdmin,\n        ISablierV2Comptroller initialComptroller,\n        ISablierV2NFTDescriptor initialNFTDescriptor\n    )\n        SablierV2Base(initialAdmin, initialComptroller)\n    {\n        _nftDescriptor = initialNFTDescriptor;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks that `streamId` does not reference a null stream.\n    modifier notNull(uint256 streamId) {\n        if (!isStream(streamId)) {\n            revert Errors.SablierV2Lockup_Null(streamId);\n        }\n        _;\n    }\n\n    /// @dev Emits an ERC-4906 event to trigger an update of the NFT metadata.\n    modifier updateMetadata(uint256 streamId) {\n        _;\n        emit MetadataUpdate({ _tokenId: streamId });\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function getRecipient(uint256 streamId) external view override returns (address recipient) {\n        // Checks: the stream NFT exists.\n        _requireMinted({ tokenId: streamId });\n\n        // The NFT owner is the stream's recipient.\n        recipient = _ownerOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isCold(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.SETTLED || status == Lockup.Status.CANCELED || status == Lockup.Status.DEPLETED;\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isDepleted(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function isStream(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function isWarm(uint256 streamId) external view override notNull(streamId) returns (bool result) {\n        Lockup.Status status = _statusOf(streamId);\n        result = status == Lockup.Status.PENDING || status == Lockup.Status.STREAMING;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256 streamId) public view override(IERC721Metadata, ERC721) returns (string memory uri) {\n        // Checks: the stream NFT exists.\n        _requireMinted({ tokenId: streamId });\n\n        // Generate the URI describing the stream NFT.\n        uri = _nftDescriptor.tokenURI({ sablier: this, streamId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function wasCanceled(uint256 streamId) public view virtual override returns (bool result);\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawableAmountOf(uint256 streamId)\n        external\n        view\n        override\n        notNull(streamId)\n        returns (uint128 withdrawableAmount)\n    {\n        withdrawableAmount = _withdrawableAmountOf(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function isTransferable(uint256 streamId) public view virtual returns (bool);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2Lockup\n    function burn(uint256 streamId) external override noDelegateCall {\n        // Checks: only depleted streams can be burned. This also checks that the stream is not null.\n        if (!isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamNotDepleted(streamId);\n        }\n\n        // Checks:\n        // 1. NFT exists (see {IERC721.getApproved}).\n        // 2. `msg.sender` is either the owner of the NFT or an approved third party.\n        if (!_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Effects: burn the NFT.\n        _burn({ tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancel(uint256 streamId) public override noDelegateCall {\n        // Checks: the stream is neither depleted nor canceled. This also checks that the stream is not null.\n        if (isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (wasCanceled(streamId)) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        }\n\n        // Checks: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks, Effects and Interactions: cancel the stream.\n        _cancel(streamId);\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function cancelMultiple(uint256[] calldata streamIds) external override noDelegateCall {\n        // Iterate over the provided array of stream ids and cancel each stream.\n        uint256 count = streamIds.length;\n        for (uint256 i = 0; i < count;) {\n            // Effects and Interactions: cancel the stream.\n            cancel(streamIds[i]);\n\n            // Increment the loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function renounce(uint256 streamId) external override noDelegateCall notNull(streamId) updateMetadata(streamId) {\n        // Checks: the stream is not cold.\n        Lockup.Status status = _statusOf(streamId);\n        if (status == Lockup.Status.DEPLETED) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        } else if (status == Lockup.Status.CANCELED) {\n            revert Errors.SablierV2Lockup_StreamCanceled(streamId);\n        } else if (status == Lockup.Status.SETTLED) {\n            revert Errors.SablierV2Lockup_StreamSettled(streamId);\n        }\n\n        // Checks: `msg.sender` is the stream's sender.\n        if (!_isCallerStreamSender(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Checks and Effects: renounce the stream.\n        _renounce(streamId);\n\n        // Log the renouncement.\n        emit ISablierV2Lockup.RenounceLockupStream(streamId);\n\n        // Interactions: if the recipient is a contract, try to invoke the renounce hook on the recipient without\n        // reverting if the hook is not implemented, and also without bubbling up any potential revert.\n        address recipient = _ownerOf(streamId);\n        if (recipient.code.length > 0) {\n            try ISablierV2LockupRecipient(recipient).onStreamRenounced(streamId) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function setNFTDescriptor(ISablierV2NFTDescriptor newNFTDescriptor) external override onlyAdmin {\n        // Effects: set the NFT descriptor.\n        ISablierV2NFTDescriptor oldNftDescriptor = _nftDescriptor;\n        _nftDescriptor = newNFTDescriptor;\n\n        // Log the change of the NFT descriptor.\n        emit ISablierV2Lockup.SetNFTDescriptor({\n            admin: msg.sender,\n            oldNFTDescriptor: oldNftDescriptor,\n            newNFTDescriptor: newNFTDescriptor\n        });\n\n        // Refresh the NFT metadata for all streams.\n        emit BatchMetadataUpdate({ _fromTokenId: 1, _toTokenId: nextStreamId - 1 });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdraw(\n        uint256 streamId,\n        address to,\n        uint128 amount\n    )\n        public\n        override\n        noDelegateCall\n        updateMetadata(streamId)\n    {\n        // Checks: the stream is not depleted. This also checks that the stream is not null.\n        if (isDepleted(streamId)) {\n            revert Errors.SablierV2Lockup_StreamDepleted(streamId);\n        }\n\n        bool isCallerStreamSender = _isCallerStreamSender(streamId);\n\n        // Checks: `msg.sender` is the stream's sender, the stream's recipient, or an approved third party.\n        if (!isCallerStreamSender && !_isCallerStreamRecipientOrApproved(streamId)) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Retrieve the recipient from storage.\n        address recipient = _ownerOf(streamId);\n\n        // Checks: if `msg.sender` is the stream's sender, the withdrawal address must be the recipient.\n        if (isCallerStreamSender && to != recipient) {\n            revert Errors.SablierV2Lockup_InvalidSenderWithdrawal(streamId, msg.sender, to);\n        }\n\n        // Checks: the withdrawal address is not zero.\n        if (to == address(0)) {\n            revert Errors.SablierV2Lockup_WithdrawToZeroAddress();\n        }\n\n        // Checks: the withdraw amount is not zero.\n        if (amount == 0) {\n            revert Errors.SablierV2Lockup_WithdrawAmountZero(streamId);\n        }\n\n        // Checks: the withdraw amount is not greater than the withdrawable amount.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (amount > withdrawableAmount) {\n            revert Errors.SablierV2Lockup_Overdraw(streamId, amount, withdrawableAmount);\n        }\n\n        // Effects and Interactions: make the withdrawal.\n        _withdraw(streamId, to, amount);\n\n        // Interactions: if `msg.sender` is not the recipient and the recipient is a contract, try to invoke the\n        // withdraw hook on it without reverting if the hook is not implemented, and also without bubbling up\n        // any potential revert.\n        if (msg.sender != recipient && recipient.code.length > 0) {\n            try ISablierV2LockupRecipient(recipient).onStreamWithdrawn({\n                streamId: streamId,\n                caller: msg.sender,\n                to: to,\n                amount: amount\n            }) { } catch { }\n        }\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMax(uint256 streamId, address to) external override {\n        withdraw({ streamId: streamId, to: to, amount: _withdrawableAmountOf(streamId) });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMaxAndTransfer(\n        uint256 streamId,\n        address newRecipient\n    )\n        external\n        override\n        noDelegateCall\n        notNull(streamId)\n    {\n        // Checks: the caller is the current recipient. This also checks that the NFT was not burned.\n        address currentRecipient = _ownerOf(streamId);\n        if (msg.sender != currentRecipient) {\n            revert Errors.SablierV2Lockup_Unauthorized(streamId, msg.sender);\n        }\n\n        // Skip the withdrawal if the withdrawable amount is zero.\n        uint128 withdrawableAmount = _withdrawableAmountOf(streamId);\n        if (withdrawableAmount > 0) {\n            withdraw({ streamId: streamId, to: currentRecipient, amount: withdrawableAmount });\n        }\n\n        // Checks and Effects: transfer the NFT.\n        _transfer({ from: currentRecipient, to: newRecipient, tokenId: streamId });\n    }\n\n    /// @inheritdoc ISablierV2Lockup\n    function withdrawMultiple(\n        uint256[] calldata streamIds,\n        address to,\n        uint128[] calldata amounts\n    )\n        external\n        override\n        noDelegateCall\n    {\n        // Checks: there is an equal number of `streamIds` and `amounts`.\n        uint256 streamIdsCount = streamIds.length;\n        uint256 amountsCount = amounts.length;\n        if (streamIdsCount != amountsCount) {\n            revert Errors.SablierV2Lockup_WithdrawArrayCountsNotEqual(streamIdsCount, amountsCount);\n        }\n\n        // Iterate over the provided array of stream ids and withdraw from each stream.\n        for (uint256 i = 0; i < streamIdsCount;) {\n            // Checks, Effects and Interactions: check the parameters and make the withdrawal.\n            withdraw(streamIds[i], to, amounts[i]);\n\n            // Increment the loop iterator.\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                             INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Overrides the internal ERC-721 transfer function to emit an ERC-4906 event upon transfer. The goal is to\n    /// refresh the NFT metadata on external platforms.\n    /// @dev This event is also emitted when the NFT is minted or burned.\n    function _afterTokenTransfer(\n        address, /* from */\n        address, /* to */\n        uint256 streamId,\n        uint256 /* batchSize */\n    )\n        internal\n        override\n        updateMetadata(streamId)\n    { }\n\n    /// @notice Overrides the internal ERC-721 transfer function to check that the stream is transferable.\n    /// @dev There are two cases when the transferable flag is ignored:\n    /// - If `from` is 0, then the transfer is a mint and is allowed.\n    /// - If `to` is 0, then the transfer is a burn and is also allowed.\n    function _beforeTokenTransfer(\n        address from"
    }
  ]
}