{
  "Title": "M-5: getReservesByCategory() when useSubmodules =true and submoduleReservesSelector=bytes4(0) will revert",
  "Content": "# Issue M-5: getReservesByCategory() when useSubmodules =true and submoduleReservesSelector=bytes4(0) will revert \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/149 \n\n## Found by \nbin2chen, dany.armstrong90, lemonmon, rvierdiiev\n## Summary\nin `getReservesByCategory() `\nLack of check  `data.submoduleReservesSelector!=\"\"`\nwhen call `submodule.staticcall(abi.encodeWithSelector(data.submoduleReservesSelector));` will revert\n\n## Vulnerability Detail\n\nwhen `_addCategory()`\nif `useSubmodules==true`, `submoduleMetricSelector` must not empty\nand `submoduleReservesSelector` can empty (bytes4(0))\n\nlike \"protocol-owned-treasury\"\n```solidity\n        _addCategory(toCategory(\"protocol-owned-treasury\"), true, 0xb600c5e2, 0x00000000); // getProtocolOwnedTreasuryOhm()`\n```\nbut when call `getReservesByCategory()` , don't check `submoduleReservesSelector!=bytes4(0)` and direct call `submoduleReservesSelector`\n```solidity\n    function getReservesByCategory(\n        Category category_\n    ) external view override returns (Reserves[] memory) {\n...\n        // If category requires data from submodules, count all submodules and their sources.\n        len = (data.useSubmodules) ? submodules.length : 0;\n\n...\n\n        for (uint256 i; i < len; ) {\n            address submodule = address(_getSubmoduleIfInstalled(submodules[i]));\n            (bool success, bytes memory returnData) = submodule.staticcall(\n                abi.encodeWithSelector(data.submoduleReservesSelector)\n            );\n```\n\nthis way , when call like `getReservesByCategory(toCategory(\"protocol-owned-treasury\")` will revert\n\n## POC\nadd to `SUPPLY.v1.t.sol`\n```solidity\n    function test_getReservesByCategory_includesSubmodules_treasury() public {\n        _setUpSubmodules();\n\n        // Add OHM/gOHM in the treasury (which will not be included)\n        ohm.mint(address(treasuryAddress), 100e9);\n        gohm.mint(address(treasuryAddress), 1e18); // 1 gOHM\n\n        // Categories already defined\n\n        uint256 expectedBptDai = BPT_BALANCE.mulDiv(\n            BALANCER_POOL_DAI_BALANCE,\n            BALANCER_POOL_TOTAL_SUPPLY\n        );\n        uint256 expectedBptOhm = BPT_BALANCE.mulDiv(\n            BALANCER_POOL_OHM_BALANCE,\n            BALANCER_POOL_TOTAL_SUPPLY\n        );\n\n        // Check reserves\n        SPPLYv1.Reserves[] memory reserves = moduleSupply.getReservesByCategory(\n            toCategory(\"protocol-owned-treasury\")\n        );\n    }\n```\n\n```console\n forge test -vv --match-test test_getReservesByCategory_includesSubmodules_treasury\n\nRunning 1 test for src/test/modules/SPPLY/SPPLY.v1.t.sol:SupplyTest\n[FAIL. Reason: SPPLY_SubmoduleFailed(0xeb502B1d35e975321B21cCE0E8890d20a7Eb289d, 0x0000000000000000000000000000000000000000000000000000000000000000)] test_getReservesByCategory_includesSubmodules_treasury() (gas: 4774197\n```\n\n## Impact\nsome category can't get `Reserves`\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/SPPLY/OlympusSupply.sol#L541\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n    function getReservesByCategory(\n        Category category_\n    ) external view override returns (Reserves[] memory) {\n...\n\n\n        CategoryData memory data = categoryData[category_];\n        uint256 categorySubmodSources;\n        // If category requires data from submodules, count all submodules and their sources.\n-       len = (data.useSubmodules) ? submodules.length : 0;\n+       len = (data.useSubmodules && data.submoduleReservesSelector!=bytes4(0)) ? submodules.length : 0;\n```\n\n\n\n## Discussion\n\n**0xJem**\n\nGood catch! Thank you for the clear explanation and test case, too.\n\n**0xrusowsky**\n\nhttps://github.com/OlympusDAO/bophades/pull/262\n\n**IAm0x52**\n\nFix looks good, exactly as suggested\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "bophades/src/modules/SPPLY/OlympusSupply.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport \"modules/SPPLY/SPPLY.v1.sol\";\n\n// Requirements\n// [X] Track total OHM supply, including other chains\n// [X] Group supply into categories to provide standardized supply metrics\n// [X] Get correct protocol supply data from lending protocols that OHM is integrated with\n// [X] Handle OHM in liquidity pools (POL vs not)\n// [X] Allow caching supply metrics\n\n/// @notice     OlympusSupply implements the SPPLY interface to track the supply and categorization of OHM\n/// @author     Oighty\ncontract OlympusSupply is SPPLYv1 {\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice        Submodule selectors providing metrics\n    bytes4[4] internal SUPPLY_SUBMODULE_METRIC_SELECTORS = [\n        SupplySubmodule.getCollateralizedOhm.selector,\n        SupplySubmodule.getProtocolOwnedBorrowableOhm.selector,\n        SupplySubmodule.getProtocolOwnedLiquidityOhm.selector,\n        SupplySubmodule.getProtocolOwnedTreasuryOhm.selector\n    ];\n\n    /// @notice        Submodule selectors providing reserve records\n    bytes4[1] internal SUPPLY_SUBMODULE_RESERVES_SELECTORS = [\n        SupplySubmodule.getProtocolOwnedLiquidityReserves.selector\n    ];\n\n    //============================================================================================//\n    //                                        MODULE SETUP                                        //\n    //============================================================================================//\n\n    /// @notice                             Initialize the OlympusSupply module\n    /// @dev                                The following categories will also be added:\n    /// @dev                                - protocol-owned-treasury\n    /// @dev                                - dao\n    /// @dev                                - protocol-owned-liquidity\n    /// @dev                                - protocol-owned-borrowable\n    ///\n    /// @param kernel_                      The address of the Kernel contract\n    /// @param tokens_                      The addresses of the OHM and gOHM tokens (in that order)\n    /// @param initialCrossChainSupply_     The initial cross-chain supply of OHM\n    constructor(\n        Kernel kernel_,\n        address[2] memory tokens_, // [ohm, gOHM]\n        uint256 initialCrossChainSupply_\n    ) Module(kernel_) {\n        ohm = OHM(tokens_[0]);\n        gohm = IgOHM(tokens_[1]);\n        totalCrossChainSupply = initialCrossChainSupply_;\n\n        // Add categories that are required for the metrics functions\n        _addCategory(toCategory(\"protocol-owned-treasury\"), true, 0xb600c5e2, 0x00000000); // getProtocolOwnedTreasuryOhm()\n        _addCategory(toCategory(\"dao\"), false, 0x00000000, 0x00000000);\n        _addCategory(toCategory(\"protocol-owned-liquidity\"), true, 0x8ebf7278, 0x55bdad01); // getProtocolOwnedLiquidityOhm(), getProtocolOwnedLiquidityReserves()\n        _addCategory(toCategory(\"protocol-owned-borrowable\"), true, 0x117fb54a, 0x00000000); // getProtocolOwnedBorrowableOhm()\n    }\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"SPPLY\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    //============================================================================================//\n    //                                       CROSS-CHAIN SUPPLY                                   //\n    //============================================================================================//\n\n    /// @dev all cross-chain supply is circulating supply since it belongs to users or is in LP pools\n\n    /// @inheritdoc SPPLYv1\n    function increaseCrossChainSupply(uint256 amount_) external override permissioned {\n        totalCrossChainSupply += amount_;\n        emit CrossChainSupplyUpdated(totalCrossChainSupply);\n    }\n\n    /// @inheritdoc SPPLYv1\n    function decreaseCrossChainSupply(uint256 amount_) external override permissioned {\n        totalCrossChainSupply -= amount_;\n        emit CrossChainSupplyUpdated(totalCrossChainSupply);\n    }\n\n    //============================================================================================//\n    //                                       SUPPLY CATEGORIZATION                                //\n    //============================================================================================//\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        Will revert if:\n    /// @dev        - `_addCategory()` reverts\n    /// @dev        - The caller is not permissioned\n    ///\n    /// @dev        This function will emit the `CategoryAdded` event if successful\n    function addCategory(\n        Category category_,\n        bool useSubmodules_,\n        bytes4 submoduleMetricSelector_,\n        bytes4 submoduleReservesSelector_\n    ) external override permissioned {\n        _addCategory(\n            category_,\n            useSubmodules_,\n            submoduleMetricSelector_,\n            submoduleReservesSelector_\n        );\n    }\n\n    /// @notice                             Adds a category to the list of approved categories\n    /// @dev                                Will revert if:\n    /// @dev                                - category is empty\n    /// @dev                                - category is already approved\n    /// @dev                                - submodules are enabled and the metric selector is empty\n    /// @dev                                - submodules are not enabled and the metric or reserves selector is specified\n    /// @dev                                - an invalid metric or reserves selector is specified\n    ///\n    /// @param category_                    The category to add\n    /// @param useSubmodules_               Whether or not the category requires data from submodules\n    /// @param submoduleMetricSelector_     The selector to use to get the metric from the submodule\n    /// @param submoduleReservesSelector_   The selector to use to get the reserves from the submodule\n    function _addCategory(\n        Category category_,\n        bool useSubmodules_,\n        bytes4 submoduleMetricSelector_,\n        bytes4 submoduleReservesSelector_\n    ) internal {\n        // Check if category is 0, if so revert\n        if (fromCategory(category_) == bytes32(uint256(0))) revert SPPLY_InvalidParams();\n\n        // Check if category is already approved, if so revert\n        if (categoryData[category_].approved) revert SPPLY_CategoryAlreadyApproved(category_);\n\n        // If submodules are enabled and the metric selector is empty, revert\n        if (useSubmodules_ && submoduleMetricSelector_ == bytes4(0)) revert SPPLY_InvalidParams();\n\n        // If submodules are not enabled and the metric selector is specified, revert\n        if (!useSubmodules_ && submoduleMetricSelector_ != bytes4(0)) revert SPPLY_InvalidParams();\n\n        // If submodules are not enabled and the reserves selector is specified, revert\n        if (!useSubmodules_ && submoduleReservesSelector_ != bytes4(0))\n            revert SPPLY_InvalidParams();\n\n        // If submodules are enabled, check that the selector is valid\n        if (useSubmodules_) {\n            // Check if the metric selector is valid\n            {\n                bool validMetricSelector;\n                uint256 len = SUPPLY_SUBMODULE_METRIC_SELECTORS.length;\n                for (uint256 i; i < len; ) {\n                    if (SUPPLY_SUBMODULE_METRIC_SELECTORS[i] == submoduleMetricSelector_) {\n                        validMetricSelector = true;\n                        break;\n                    }\n                    unchecked {\n                        ++i;\n                    }\n                }\n                if (!validMetricSelector) revert SPPLY_InvalidParams();\n            }\n\n            // If specified (since it is optional), check if the reserves selector is valid\n            if (submoduleReservesSelector_ != bytes4(0)) {\n                bool validReservesSelector;\n                uint256 len = SUPPLY_SUBMODULE_RESERVES_SELECTORS.length;\n                for (uint256 i; i < len; ) {\n                    if (SUPPLY_SUBMODULE_RESERVES_SELECTORS[i] == submoduleReservesSelector_) {\n                        validReservesSelector = true;\n                        break;\n                    }\n                    unchecked {\n                        ++i;\n                    }\n                }\n                if (!validReservesSelector) revert SPPLY_InvalidParams();\n            }\n        }\n\n        // Add category to list of approved categories and store category data\n        categories.push(category_);\n        CategoryData storage data = categoryData[category_];\n        data.approved = true;\n        data.useSubmodules = useSubmodules_;\n        data.submoduleMetricSelector = submoduleMetricSelector_;\n        data.submoduleReservesSelector = submoduleReservesSelector_;\n        emit CategoryAdded(category_);\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        Will revert if:\n    /// @dev        - The caller is not permissioned\n    /// @dev        - category does not exist/is not approved\n    /// @dev        - category is still in use by a location\n    ///\n    /// @dev        This function will emit the `CategoryRemoved` event if successful\n    function removeCategory(Category category_) external override permissioned {\n        // Check if category is approved, if not revert\n        if (!categoryData[category_].approved) revert SPPLY_CategoryNotApproved(category_);\n\n        // Check if any locations still have this category, if so revert\n        address[] memory locations_ = getLocationsByCategory(category_);\n        if (locations_.length > 0) revert SPPLY_CategoryInUse(category_);\n\n        // Remove category from list of approved categories\n        delete categoryData[category_];\n        uint256 len = categories.length;\n        for (uint256 i; i < len; ) {\n            if (fromCategory(categories[i]) == fromCategory(category_)) {\n                categories[i] = categories[categories.length - 1];\n                categories.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        emit CategoryRemoved(category_);\n    }\n\n    /// @notice             Removes the categorization for `location_`\n    /// @dev                Will revert if:\n    /// @dev                - location is not categorized\n    ///\n    /// @param location_    The location to uncategorize\n    function _uncategorize(address location_) internal {\n        // Revert if the location is not categorized\n        if (fromCategory(categorization[location_]) == bytes32(uint256(0)))\n            revert SPPLY_LocationNotCategorized(location_);\n\n        // Remove location from list of locations\n        uint256 len = locations.length;\n        for (uint256 i; i < len; ) {\n            if (locations[i] == location_) {\n                locations[i] = locations[locations.length - 1];\n                locations.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Remove from location-category mapping\n        categorization[location_] = toCategory(\"\");\n\n        emit LocationCategorized(location_, toCategory(\"\"));\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        To add a location to a category, pass in the address and category\n    ///\n    /// @dev        To remove a location from all categories, pass in the address and an empty category\n    ///\n    /// @dev        This function will revert if:\n    /// @dev        - The caller is not permissioned\n    /// @dev        - The category is not approved\n    /// @dev        - The location is already in the same category\n    /// @dev        - The location is not in the specified category and the category is empty\n    ///\n    /// @dev        This function will emit the `LocationCategorized` event if successful\n    function categorize(address location_, Category category) external override permissioned {\n        bool toRemove = fromCategory(category) == bytes32(uint256(0));\n\n        // Removing\n        if (toRemove) {\n            _uncategorize(location_);\n            return;\n        }\n\n        // Check if category is approved, if not revert\n        if (!categoryData[category].approved) revert SPPLY_CategoryNotApproved(category);\n\n        // Check if the location is already in the category, if so revert\n        Category existingCategorization = categorization[location_];\n        if (fromCategory(existingCategorization) == fromCategory(category))\n            revert SPPLY_LocationAlreadyCategorized(location_, existingCategorization);\n\n        // Check if the location is already in a different category, if so revert\n        if (fromCategory(existingCategorization) != bytes32(uint256(0)))\n            revert SPPLY_LocationAlreadyCategorized(location_, existingCategorization);\n\n        // Add to the list of tracked locations\n        locations.push(location_);\n\n        // Add to the location-category mapping\n        categorization[location_] = category;\n\n        emit LocationCategorized(location_, category);\n    }\n\n    /// @inheritdoc SPPLYv1\n    function getLocations() external view override returns (address[] memory) {\n        return locations;\n    }\n\n    /// @inheritdoc SPPLYv1\n    function getCategories() external view override returns (Category[] memory) {\n        return categories;\n    }\n\n    /// @inheritdoc SPPLYv1\n    function getCategoryData(\n        Category category_\n    ) external view virtual override returns (CategoryData memory) {\n        // Check if category is approved\n        if (!categoryData[category_].approved) revert SPPLY_CategoryNotApproved(category_);\n\n        return categoryData[category_];\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        Will revert if:\n    /// @dev        - The category is not approved\n    function getLocationsByCategory(\n        Category category_\n    ) public view override returns (address[] memory) {\n        // Check if category is approved, if not revert\n        if (!categoryData[category_].approved) revert SPPLY_CategoryNotApproved(category_);\n\n        // Determine the number of locations in the category\n        uint256 len = locations.length;\n        uint256 count;\n        for (uint256 i; i < len; ) {\n            if (fromCategory(categorization[locations[i]]) == fromCategory(category_)) {\n                unchecked {\n                    ++count;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        // If count is zero, return an empty array\n        if (count == 0) return new address[](0);\n\n        // Create array of locations in the category\n        address[] memory locations_ = new address[](count);\n        count = 0;\n        for (uint256 i; i < len; ) {\n            if (fromCategory(categorization[locations[i]]) == fromCategory(category_)) {\n                locations_[count] = locations[i];\n                unchecked {\n                    ++count;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return locations_;\n    }\n\n    /// @inheritdoc SPPLYv1\n    function getCategoryByLocation(\n        address location_\n    ) external view virtual override returns (Category) {\n        return categorization[location_];\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        This function will first attempt to return the cached value for the current\n    /// @dev        timestamp, if available. Otherwise, it will re-calculate the value.\n    ///\n    /// @dev        Will revert if:\n    /// @dev        - The category is not approved\n    function getSupplyByCategory(Category category_) external view override returns (uint256) {\n        // Try to use the last value, must be updated on the current timestamp\n        // getSupplyByCategory checks if category is approved\n        (uint256 supply, uint48 timestamp) = getSupplyByCategory(category_, Variant.LAST);\n        if (timestamp == uint48(block.timestamp)) return supply;\n\n        // If last value is stale, calculate the current value\n        supply = _getSupplyByCategory(category_);\n        return supply;\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        This function will first check the validity of the last-cached value.\n    /// @dev        Otherwise, it will re-calculate the value.\n    ///\n    /// @dev        Will revert if:\n    /// @dev        - The category is not approved\n    function getSupplyByCategory(\n        Category category_,\n        uint48 maxAge_\n    ) external view override returns (uint256) {\n        // Try to use the last value, must be updated more recently than maxAge\n        // getSupplyByCategory checks if category is approved\n        (uint256 supply, uint48 timestamp) = getSupplyByCategory(category_, Variant.LAST);\n        if (timestamp >= uint48(block.timestamp) - maxAge_) return supply;\n\n        // If last value is stale, calculate the current value\n        supply = _getSupplyByCategory(category_);\n        return supply;\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        Will revert if:\n    /// @dev        - The category is not approved\n    function getSupplyByCategory(\n        Category category_,\n        Variant variant_\n    ) public view override returns (uint256, uint48) {\n        // Check if category is approved\n        if (!categoryData[category_].approved) revert SPPLY_CategoryNotApproved(category_);\n\n        // Route to correct price function based on requested variant\n        if (variant_ == Variant.CURRENT) {\n            return (_getSupplyByCategory(category_), uint48(block.timestamp));\n        } else if (variant_ == Variant.LAST) {\n            Cache memory cache = categoryData[category_].total;\n            return (cache.value, cache.timestamp);\n        } else {\n            revert SPPLY_InvalidParams();\n        }\n    }\n\n    /// @notice             Returns the balance of gOHM (in terms of OHM) for the provided location\n    ///\n    /// @param location_    The location to get the gOHM balance for\n    /// @return             The balance of gOHM (in terms of OHM) for the provided location\n    function _getOhmForGOhmBalance(address location_) internal view returns (uint256) {\n        // Get the gOHM balance of the location\n        uint256 gohmBalance = gohm.balanceOf(location_);\n\n        // Convert gOHM balance to OHM balance\n        return gohmBalance != 0 ? gohm.balanceFrom(gohmBalance) : 0;\n    }\n\n    /// @notice             Returns the supply of OHM for the provided category\n    /// @dev                This function first obtains the balance of OHM and gOHM (in terms of OHM)\n    /// @dev                for each location in the category, then sums them together.\n    ///\n    /// @dev                If submodules are enabled for the category, the function represented by `submoduleMetricSelector`\n    /// @dev                will be called on each submodule and the returned value will be added to the total.\n    ///\n    /// @param category_    The category to get the supply for\n    /// @return             The supply of OHM for the provided category\n    function _getSupplyByCategory(Category category_) internal view returns (uint256) {\n        // Total up the supply of OHM of all locations in the category. Also accounts for gOHM.\n        uint256 len = locations.length;\n        uint256 supply;\n        for (uint256 i; i < len; ) {\n            if (fromCategory(categorization[locations[i]]) == fromCategory(category_)) {\n                supply += ohm.balanceOf(locations[i]) + _getOhmForGOhmBalance(locations[i]);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Add cross-chain category supply\n        CategoryData memory data = categoryData[category_];\n\n        // If category requires data from submodules, it must be calculated and added\n        if (data.useSubmodules) {\n            // Iterate through submodules and add their value to the total\n            // Should not include any supply that is retrievable via a simple balance lookup, which is handled by locations above\n            len = submodules.length;\n            for (uint256 i; i < len; ) {\n                address submodule = address(_getSubmoduleIfInstalled(submodules[i]));\n                (bool success, bytes memory returnData) = submodule.staticcall(\n                    abi.encodeWithSelector(data.submoduleMetricSelector)\n                );\n\n                // Ensure call was successful\n                if (!success)\n                    revert SPPLY_SubmoduleFailed(address(submodule), data.submoduleMetricSelector);\n\n                // Decode supply returned by the submodule\n                supply += abi.decode(returnData, (uint256));\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        return supply;\n    }\n\n    /// @inheritdoc SPPLYv1\n    function getReservesByCategory(\n        Category category_\n    ) external view override returns (Reserves[] memory) {\n        // Check if category is approved\n        if (!categoryData[category_].approved) revert SPPLY_CategoryNotApproved(category_);\n\n        uint256 categoryLocations;\n        uint256 len = locations.length;\n        // Count all locations for given category.\n        for (uint256 i; i < len; ) {\n            if (fromCategory(categorization[locations[i]]) == fromCategory(category_)) {\n                unchecked {\n                    ++categoryLocations;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        CategoryData memory data = categoryData[category_];\n        uint256 categorySubmodSources;\n        // If category requires data from submodules, count all submodules and their sources.\n        len = (data.useSubmodules) ? submodules.length : 0;\n        for (uint256 i; i < len; ) {\n            address submodule = address(_getSubmoduleIfInstalled(submodules[i]));\n            (bool success, bytes memory returnData) = submodule.staticcall(\n                abi.encodeWithSelector(SupplySubmodule.getSourceCount.selector)\n            );\n\n            // Ensure call was successful\n            if (!success)\n                revert SPPLY_SubmoduleFailed(\n                    address(submodule),\n                    SupplySubmodule.getSourceCount.selector\n                );\n\n            // Decode number of sources returned by the submodule\n            unchecked {\n                categorySubmodSources = categorySubmodSources + abi.decode(returnData, (uint256));\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        Reserves[] memory reserves = new Reserves[](categoryLocations + categorySubmodSources);\n        // Iterate through submodules and add their reserves to the return array\n        // Should not include any supply that is retrievable via a simple balance lookup, which is handled by locations below\n        uint256 j;\n        for (uint256 i; i < len; ) {\n            address submodule = address(_getSubmoduleIfInstalled(submodules[i]));\n            (bool success, bytes memory returnData) = submodule.staticcall(\n                abi.encodeWithSelector(data.submoduleReservesSelector)\n            );\n\n            // Ensure call was successful\n            if (!success)\n                revert SPPLY_SubmoduleFailed(address(submodule), data.submoduleReservesSelector);\n\n            // Decode supply returned by the submodule\n            Reserves[] memory currentReserves = abi.decode(returnData, (Reserves[]));\n            uint256 current = currentReserves.length;\n            for (uint256 k; k < current; ) {\n                reserves[j] = currentReserves[k];\n                unchecked {\n                    ++j;\n                    ++k;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        address[] memory ohmTokens = new address[](1);\n        ohmTokens[0] = address(ohm);\n        len = locations.length;\n        // Get supply from all locations in the category. Also accounts for gOHM.\n        for (uint256 i; i < len; ) {\n            if (fromCategory(categorization[locations[i]]) == fromCategory(category_)) {\n                uint256[] memory ohmBalances = new uint256[](1);\n                ohmBalances[0] = ohm.balanceOf(locations[i]) + _getOhmForGOhmBalance(locations[i]);\n                reserves[j] = Reserves(locations[i], ohmTokens, ohmBalances);\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return reserves;\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        Will revert if:\n    /// @dev        - The caller is not permissioned\n    /// @dev        - The category is not approved\n    function storeCategorySupply(Category category_) external override permissioned {\n        (uint256 supply, uint48 timestamp) = getSupplyByCategory(category_, Variant.CURRENT);\n        categoryData[category_].total = Cache(supply, timestamp);\n    }\n\n    //============================================================================================//\n    //                                       SUPPLY METRICS                                       //\n    //============================================================================================//\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        Optimistically uses the cached value if it has been updated this block, otherwise calculates value dynamically\n    ///\n    /// @dev        Will revert if:\n    /// @dev        - The value for `metric_` is invalid\n    function getMetric(Metric metric_) external view override returns (uint256) {\n        // Get the cached value of the metric\n        (uint256 value, uint48 timestamp) = getMetric(metric_, Variant.LAST);\n\n        // Try to use the last value, must be updated on the current timestamp\n        if (timestamp == uint48(block.timestamp)) return value;\n\n        // If the last value is not on the current timestamp, calculate the current value\n        (value, ) = getMetric(metric_, Variant.CURRENT);\n\n        return value;\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        If the cached value is older than the provided age, then the value is calculated dynamically\n    ///\n    /// @dev        Will revert if:\n    /// @dev        - The value for `metric_` is invalid\n    function getMetric(Metric metric_, uint48 maxAge_) external view override returns (uint256) {\n        // Get the cached value of the metric\n        (uint256 value, uint48 timestamp) = getMetric(metric_, Variant.LAST);\n\n        // Try to use the last value, must be no older than maxAge_\n        if (timestamp >= uint48(block.timestamp) - maxAge_) return value;\n\n        // If the last value is not on the current timestamp, calculate the current value\n        (value, ) = getMetric(metric_, Variant.CURRENT);\n\n        return value;\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        If the `Variant.LAST` variant is requested and it has not yet been stored, then (0, 0) will be returned.\n    ///\n    /// @dev        Will revert if:\n    /// @dev        - The value for `metric_` is invalid\n    /// @dev        - The value for `variant_` is invalid\n    function getMetric(\n        Metric metric_,\n        Variant variant_\n    ) public view override returns (uint256, uint48) {\n        if (variant_ == Variant.LAST) {\n            return (metricCache[metric_].value, metricCache[metric_].timestamp);\n        } else if (variant_ == Variant.CURRENT) {\n            if (metric_ == Metric.TOTAL_SUPPLY) {\n                return (_totalSupply(), uint48(block.timestamp));\n            } else if (metric_ == Metric.CIRCULATING_SUPPLY) {\n                return (_circulatingSupply(), uint48(block.timestamp));\n            } else if (metric_ == Metric.FLOATING_SUPPLY) {\n                return (_floatingSupply(), uint48(block.timestamp));\n            } else if (metric_ == Metric.COLLATERALIZED_SUPPLY) {\n                return (_collateralizedSupply(), uint48(block.timestamp));\n            } else if (metric_ == Metric.BACKED_SUPPLY) {\n                return (_backedSupply(), uint48(block.timestamp));\n            } else {\n                revert SPPLY_InvalidParams();\n            }\n        } else {\n            revert SPPLY_InvalidParams();\n        }\n    }\n\n    /// @inheritdoc SPPLYv1\n    /// @dev        Will revert if:\n    /// @dev        - The caller is not permissioned\n    /// @dev        - The value for `metric_` is invalid\n    function storeMetric(Metric metric_) external override permissioned {\n        (uint256 result, uint48 timestamp) = getMetric(metric_, Variant.CURRENT);\n        metricCache[metric_] = Cache(result, timestamp);\n    }\n\n    /// @notice         Calculates the total supply of OHM\n    /// @notice         Accounts for CrossChain supply\n    ///\n    /// @dev            Calculated as:\n    /// @dev            - the total supply of OHM on mainnet\n    /// @dev            - plus: the value of `totalCrossChainSupply`\n    ///\n    /// @return         The value of the total OHM supply\n    function _totalSupply() internal view returns (uint256) {\n        return ohm.totalSupply() + totalCrossChainSupply;\n    }\n\n    /// @notice         Calculates the circulating supply of OHM\n    /// @notice         Circulating supply is defined as:\n    /// @notice         - Total supply\n    /// @notice         - Minus: OHM in Treasury\n    /// @notice         - Minus: DAO OHM\n    ///\n    /// @return         The value of the circulating OHM supply\n    function _circulatingSupply() internal view returns (uint256) {\n        uint256 treasuryOhm = _getSupplyByCategory(toCategory(\"protocol-owned-treasury\"));\n        uint256 daoOhm = _getSupplyByCategory(toCategory(\"dao\"));\n        uint256 totalOhm = _totalSupply();\n\n        return totalOhm - treasuryOhm - daoOhm;\n    }\n\n    /// @notice         Calculates the floating supply of OHM\n    /// @notice         Floating is defined as:\n    /// @notice         - Circulating supply\n    /// @notice         - Minus: OHM in Protocol Owned Liquidity\n    /// @notice         - Minus: Borrowable OHM\n    ///\n    /// @return         The value of the floating OHM supply\n    function _floatingSupply() internal view returns (uint256) {\n        uint256 polOhm = _getSupplyByCategory(toCategory(\"protocol-owned-liquidity\"));\n        uint256 borrowableOhm = _getSupplyByCategory(toCategory(\"protocol-owned-borrowable\"));\n        uint256 circulatingSupply = _circulatingSupply();\n\n        return circulatingSupply - polOhm - borrowableOhm;\n    }\n\n    /// @notice         Calculates the collateralized (non-backed) supply of OHM\n    /// @notice         Calculated as:\n    /// @notice         - The sum of the values returned by calling `getCollateralizedOhm()` on submodules\n    ///\n    /// @return         The value of the collateralized OHM supply\n    function _collateralizedSupply() internal view returns (uint256) {\n        // There isn't any collateralized supply from simple balance lookups, so we forgo the supply by category call\n        // Iterate through the submodules and get the collateralized supply from each lending facility\n        // In general, collateralized supply can't be measured by a balance lookup since it would not be in the contract\n        uint256 total;\n        uint256 len = submodules.length;\n        for (uint256 i; i < len; ) {\n            address submodule = address(_getSubmoduleIfInstalled(submodules[i]));\n\n            bytes4 selector = SupplySubmodule.getCollateralizedOhm.selector;\n            (bool success, bytes memory returnData) = submodule.staticcall(\n                abi.encodeWithSelector(selector)\n            );\n\n            // Ensure call was successful\n            if (!success) revert SPPLY_SubmoduleFailed(address(submodule), selector);\n\n            total += abi.decode(returnData, (uint256));\n            unchecked {\n                ++i;\n            }\n        }\n\n        return total;\n    }\n\n    /// @notice         Calculates the backed supply of OHM\n    /// @notice         Backed supply is defined as:\n    /// @notice         - Floating supply\n    /// @notice         - Minus: Collateralized (non-backed) OHM\n    ///\n    /// @return         The value of the backed OHM supply\n    function _backedSupply() internal view returns (uint256) {\n        uint256 floatingSupply = _floatingSupply();\n        uint256 collateralizedSupply = _collateralizedSupply();\n\n        return floatingSupply - collateralizedSupply;\n    }\n}"
    }
  ]
}