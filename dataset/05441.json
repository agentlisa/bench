{
  "Title": "[M-25] `SurplusGuildMinter.getReward()` is susceptible to DoS due to unbounded loop",
  "Content": "\nThe `SurplusGuildMinter.getReward()` function [invokes](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L239) `ProfitManager.claimRewards()` that in a loop claims reward through all gauges/terms for `SurplusGuildMinter` as follows.\n\n    function claimRewards(\n        address user\n    ) external returns (uint256 creditEarned) {\n        address[] memory gauges = GuildToken(guild).userGauges(user);\n        for (uint256 i = 0; i < gauges.length; ) {\n            creditEarned += claimGaugeRewards(user, gauges[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\nWhereas `SurplusGuildMinter` works with all gauges, and there is no upper limit for the [`GuildToken.setMaxGauges(max)`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L444), the length of loop could be unbounded.\n\nEach call to `stake()`, `unstake()`, or `getReward()` of `SurplusGuildMinter` will either consume excessive amount of gas, or revert with Out-Of-Gas reason after certain number of gauges/terms were added.\n\n### Proof of Concept\n\n1. Alice stakes **Credit** tokens in `SurplusGuildMinter`.\n2. Some number of terms are added to the protocol.\n3. When further Alice tries to call `stake()`, `unstake()`, or `getReward()`, the call reverts due to Out-Of-Gas reason:\n\n```\n    // Put inside test/unit/loan/SurplusGuildMinter.t.sol\n    function test_dos() public {\n        address alice = address(789);\n\n        // Number of terms that triggers OOG for stake/unstake/getReward\n        uint256 numTerms = 6500;\n        address[] memory terms = new address[](numTerms);\n\n        guild.setMaxGauges(numTerms + 1);\n\n        credit.mint(alice, 10e18);\n\n        // Alice stakes Credit tokens\n        vm.startPrank(alice);\n        credit.approve(address(sgm), 10e18);\n        sgm.stake(term, 10e18);\n        vm.stopPrank();\n\n        // Create terms\n        credit.mint(address(this), 10e18 * numTerms);\n        credit.approve(address(sgm), 10e18 * numTerms);\n        for (uint256 i; i < numTerms; i++) {\n            address _term = address(new MockLendingTerm(address(core)));\n            terms[i] = _term;\n            guild.addGauge(1, _term); // gaugeType = 1\n            sgm.stake(_term, 10e18);\n        }\n\n        uint256 gasBefore =  gasleft();\n\n        // Alice tries to call getRewards()\n        sgm.getRewards(alice, term);\n\n        uint256 gasAfter =  gasleft();\n\n        uint256 BLOCK_GAS_LIMIT = 30e6;\n        \n        // getRewards() consumes more gas than block gas limit of 30Mil\n        // reverts with OOG\n        require(gasBefore - gasAfter > BLOCK_GAS_LIMIT);\n    }\n```\n\nRun Poc with the following command:\n`forge test --mp test/unit/loan/SurplusGuildMinter.t.sol --mt test_dos`\n\n### Recommended Mitigation Steps\n\nInside `SurplusGuildMinter.getReward(user, term)` call:\n\n    ProfitManager(profitManager).claimRewards(address(this), term)\n\nInstead of:\n\n    ProfitManager(profitManager).claimRewards(address(this))\n\nSince the purpose of `SurplusGuildMinter.getReward(user, term)` is to update the profit index only for a specific `term`, so there is no need to update profit indexes across all available terms.\n\n### Assessed type\n\nDoS\n\n**[eswak (Ethereum Credit Guild) confirmed via duplicate issue #1110](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1110#issuecomment-1896038636)**\n\n**[TrungOre (judge) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1921634900):**\n > I chose this issue to be the primary issue since it has a clear description and contains a PoC.\n\n**[btk (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1924460607):**\n > @TrungOre, this issue stems from an admin mistake making low based on c4 severity standardization: \n> \n> > Reckless admin mistakes are invalid.\n> \n> PS: It is very unlikely that the `GAUGE_PARAMETERS` role will set max gauges to 6500.\n\n**[serial-coder (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1924503669):**\n > @btk - You misunderstood. The configuration in the deployment script allows the `SurplusGuildMinter` contract to subscribe to terms over the maximum gauges setting (unlimited!).\n> \n>*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1924503669).*\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1924726941):**\n > @serial-coder - I would like to understand a little bit more about this. So, the configuration deployment script allows the SurplusGuildMinter to subscribe to an unlimited number of gauges, but, isn't the admin role the one who has the permissions to subscribe a SurplusGuildMinter to terms?\n> \n> I think @btk has a point here. If the admin is the only one who can subscribe the SurplusGuildMinter to terms, then, subscribing to such an excessing amount of terms would be an admin mistake, isn't it?\n\n**[serial-coder (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1925021232):**\n > @0xStalin - You might have an incorrect assumption. The protocol lets GUILD community voters vote for onboarding lending terms. Specifically, the GUILD holders can vote to onboard and register lending terms to the `SurplusGuildMinter` contract through the [`LendingTermOnboarding::proposeOnboard()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181). \n> \n> This is not specific to protocol admins. As long as the term receives a sufficient voting quorum, it will be registered to the `SurplusGuildMinter` contract.\n\n\n**[0xStalin (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1925022644):**\n > @serial-coder - But also, the GUILD community voters have the incentive to vote against onboarding a lending term that is not beneficial for them, right? So, what is the incentive for a \"malicious user\" or \"malicious voter\" to max out the number of terms that a SuplusGuildMinter can have? Considering they need to pay gas for all those transactions, plus, they need to put down PeggedTokens so they can earn CreditTokens to eventually earn GUILD tokens as rewards?\n\n**[carrotsmuggler (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1929005620):**\n > Looks quite unlikely, in my opinion. If we look at the uniswapV2 factory contract, we see there was only ever 1956 pair deployments on a permissionless free-for-all contract. Expecting a semi-permissioned system to hit 6k+ is extremely unrealistic. OOG errors should only be valid if there is a straightforward way to trigger them. While the impact is high, the likelihood is extremely low, and should be downgraded.\n\n**[TrungOre (judge) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/69#issuecomment-1934571315):**\n > I understand that the likelihood of this issue occurring is very low, but there is no evidence to prove that it cannot happen in the future. The PoC test used 6500 terms, but they didn't transfer any rewards. Therefore, the number of terms needed to exceed the block gas limit in a real case is much lower, as transferring tokens will consume a significant amount of gas. The protocol might have a large number of active lending terms across multiple markets in the future, so there is no guarantee that this number is always safe. This vulnerability has a significant impact, which will cause losses to mitigate, so I believe medium severity is appropriate. Additionally, the sponsor didn't dispute its severity.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"SurplusGuildMinter: remaining stake below min\"\n            );\n        }\n        _stakes[msg.sender][term] = userStake;\n\n        // withdraw & transfer CREDIT\n        ProfitManager(profitManager).withdrawFromTermSurplusBuffer(\n            term,\n            msg.sender,\n            amount\n        );\n\n        // burn GUILD\n        GuildToken(guild).decrementGauge(term, guildAmount);\n        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n        GuildToken(guild).burn(guildAmount);\n\n        // emit event\n        emit Unstake(block.timestamp, term, amount);\n    }\n\n    /// @notice get rewards from a staking position without unstaking.\n    /// This can be used to slash users that have an outstanding unapplied loss.\n    function getRewards(\n        address user,\n        address term\n    )\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n        bool updateState;\n        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n            slashed = true;\n        }\n\n        // if the user is not staking, do nothing\n        userStake = _stakes[user][term];\n        if (userStake.stakeTime == 0)\n            return (lastGaugeLoss, userStake, slashed);\n\n        // compute CREDIT rewards\n        ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes\n        uint256 _profitIndex = ProfitManager(profitManager)\n            .userGaugeProfitIndex(address(this), term);\n        uint256 _userProfitIndex = uint256(userStake.profitIndex);\n\n        if (_profitIndex == 0) _profitIndex = 1e18;\n        if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n        if (deltaIndex != 0) {\n            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /\n                1e18;\n            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n            if (slashed) {\n                guildReward = 0;\n            }\n\n            // forward rewards to user\n            if (guildReward != 0) {\n                RateLimitedMinter(rlgm).mint(user, guildReward);\n                emit GuildReward(block.timestamp, user, guildReward);\n            }\n            if (creditReward != 0) {\n                CreditToken(credit).transfer(user, creditReward);\n            }\n\n            // save the updated profitIndex\n            userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);\n            updateState = true;\n        }\n\n        // if a loss occurred while the user was staking, the GuildToken.applyGaugeLoss(address(this))\n        // can be called by anyone to slash address(this) and decrement gauge weight etc.\n        // The contribution to the surplus buffer is also forfeited.\n        if (slashed) {\n            emit Unstake(block.timestamp, term, uint256(userStake.credit));\n            userStake = UserStake({\n                stakeTime: uint48(0),\n                lastGaugeLoss: uint48(0),\n                profitIndex: uint160(0),\n                credit: uint128(0),\n                guild: uint128(0)\n            });\n            updateState = true;\n        }\n\n        // store the updated stake, if needed\n        if (updateState) {\n            _stakes[user][term] = userStake;\n        }\n    }\n\n    /// @notice update the mint ratio for a given user.\n    function updateMintRatio(address user, address term) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(user, term);\n\n        // if the user has been slashed or isnt staking, there is nothing to do\n        if (userStake.stakeTime == 0 || slashed) return;\n\n        // update amount of GUILD tokens staked\n        uint256 guildBefore = uint256(userStake.guild);\n        uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;\n        if (guildAfter > guildBefore) {\n            uint256 guildAmount = guildAfter - guildBefore;\n            RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n            GuildToken(guild).incrementGauge(term, guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        } else if (guildAfter < guildBefore) {\n            uint256 guildAmount = guildBefore - guildAfter;\n            GuildToken(guild).decrementGauge(term, guildAmount);\n            RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n            GuildToken(guild).burn(guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        }\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens minted\n    /// per CREDIT tokens contributed to the surplus buffer.\n    function setMintRatio(\n        uint256 _mintRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        mintRatio = _mintRatio;\n        emit MintRatioUpdate(block.timestamp, _mintRatio);\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens rewarded\n    /// per CREDIT tokens earned from GUILD staking.\n    function setRewardRatio(\n        uint256 _rewardRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        rewardRatio = _rewardRatio;\n        emit RewardRatioUpdate(block.timestamp, _rewardRatio);\n    }\n}"
    },
    {
      "filename": "src/tokens/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/** \n@title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\n@author joeysantoro, eswak\n@notice This contract is meant to be used to support gauge style votes with weights associated with resource allocation.\n        Holders can allocate weight in any proportion to supported gauges.\n        A \"gauge\" is represented by an address which would receive the resources periodically or continuously.\n        For example, gauges can be used to direct token emissions, similar to Curve or Tokemak.\n        Alternatively, gauges can be used to direct another quantity such as relative access to a line of credit.\n        This contract is abstract, and a parent shall implement public setter with adequate access control to manage\n        the gauge set and caps.\n        All gauges are in the set `_gauges` (live + deprecated).  \n        Users can only add weight to live gauges but can remove weight from live or deprecated gauges.\n        Gauges can be deprecated and reinstated, and will maintain any non-removed weight from before.\n@dev    SECURITY NOTES: `maxGauges` is a critical variable to protect against gas DOS attacks upon token transfer. \n        This must be low enough to allow complicated transactions to fit in a block.\n        Weight state is preserved on the gauge and user level even when a gauge is removed, in case it is re-added. \n        This maintains state efficiently, and global accounting is managed only on the `_totalWeight`\n@dev This contract was originally published as part of TribeDAO's flywheel-v2 repo, please see:\n    https://github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20Gauges.sol\n    The original version was included in 2 audits :\n    - https://code4rena.com/reports/2022-04-xtribe/\n    - https://consensys.net/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/\n    ECG made the following changes to the original flywheel-v2 version :\n    - Does not inherit Solmate's Auth (all requiresAuth functions are now internal, see below)\n        -> This contract is abstract, and permissioned public functions can be added in parent.\n        -> permissioned public functions to add in parent:\n            - function addGauge(address) external returns (uint112)\n            - function removeGauge(address) external\n            - function setMaxGauges(uint256) external\n            - function setCanExceedMaxGauges(address, bool) external\n    - Remove public addGauge(address) requiresAuth method \n    - Remove public removeGauge(address) requiresAuth method\n    - Remove public replaceGauge(address, address) requiresAuth method\n    - Remove public setMaxGauges(uint256) requiresAuth method\n        ... Add internal _setMaxGauges(uint256) method\n    - Remove public setContractExceedMaxGauges(address, bool) requiresAuth method\n        ... Add internal _setCanExceedMaxGauges(address, bool) method\n        ... Remove check of \"target address has nonzero code size\"\n        ... Rename to remove \"contract\" from name because we don't check if target is a contract\n    - Rename `calculateGaugeAllocation` to `calculateGaugeStoredAllocation` to make clear that it reads from stored weights.\n    - Add `calculateGaugeAllocation` helper function that reads from current weight.\n    - Add `isDeprecatedGauge(address)->bool` view function that returns true if gauge is deprecated.\n    - Consistency: make incrementGauges return a uint112 instead of uint256\n    - Import OpenZeppelin ERC20 & EnumerableSet instead of Solmate's\n    - Update error management style (use require + messages instead of Solidity errors)\n    - Implement C4 audit fixes for [M-03], [M-04], [M-07], [G-02], and [G-04].\n    - Remove cycle-based logic\n    - Add gauge types\n    - Prevent removal of gauges if they were not previously added\n    - Add liveGauges() and numLiveGauges() getters\n*/\nabstract contract ERC20Gauges is ERC20 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice a mapping from users to gauges to a user's allocated weight to that gauge\n    mapping(address => mapping(address => uint256)) public getUserGaugeWeight;\n\n    /// @notice a mapping from a user to their total allocated weight across all gauges\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint256) public getUserWeight;\n\n    /// @notice a mapping from a gauge to the total weight allocated to it\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint256) public getGaugeWeight;\n\n    /// @notice the total global allocated weight ONLY of live gauges\n    uint256 public totalWeight;\n\n    /// @notice the total allocated weight to gauges of a given type, ONLY of live gauges.\n    /// keys : totalTypeWeight[type] = total.\n    mapping(uint256 => uint256) public totalTypeWeight;\n\n    /// @notice the type of gauges.\n    mapping(address => uint256) public gaugeType;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead weight\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice returns the set of live + deprecated gauges\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @notice returns true if `gauge` is not in deprecated gauges\n    function isGauge(address gauge) public view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @notice returns true if `gauge` is in deprecated gauges\n    function isDeprecatedGauge(address gauge) public view returns (bool) {\n        return _deprecatedGauges.contains(gauge);\n    }\n\n    /// @notice returns the number of live + deprecated gauges\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @notice returns the set of previously live but now deprecated gauges\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @notice returns the number of deprecated gauges\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @notice returns the set of currently live gauges\n    function liveGauges() external view returns (address[] memory _liveGauges) {\n        _liveGauges = new address[](\n            _gauges.length() - _deprecatedGauges.length()\n        );\n        address[] memory allGauges = _gauges.values();\n        uint256 j;\n        for (uint256 i; i < allGauges.length && j < _liveGauges.length; ) {\n            if (!_deprecatedGauges.contains(allGauges[i])) {\n                _liveGauges[j] = allGauges[i];\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return _liveGauges;\n    }\n\n    /// @notice returns the number of currently live gauges\n    function numLiveGauges() external view returns (uint256) {\n        return _gauges.length() - _deprecatedGauges.length();\n    }\n\n    /// @notice returns the set of gauges the user has allocated to, may be live or deprecated.\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @notice returns true if `gauge` is in user gauges\n    function isUserGauge(\n        address user,\n        address gauge\n    ) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @notice returns the number of user gauges\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /// @notice helper function exposing the amount of weight available to allocate for a user\n    function userUnusedWeight(address user) external view returns (uint256) {\n        return balanceOf(user) - getUserWeight[user];\n    }\n\n    /** \n    @notice helper function for calculating the proportion of a `quantity` allocated to a gauge\n    @param gauge the gauge to calculate allocation of\n    @param quantity a representation of a resource to be shared among all gauges\n    @return the proportion of `quantity` allocated to `gauge`. Returns 0 if gauge is not live, even if it has weight.\n    */\n    function calculateGaugeAllocation(\n        address gauge,\n        uint256 quantity\n    ) external view returns (uint256) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n\n        uint256 total = totalTypeWeight[gaugeType[gauge]];\n        if (total == 0) return 0;\n        uint256 weight = getGaugeWeight[gauge];\n\n        return (quantity * weight) / total;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when incrementing a gauge\n    event IncrementGaugeWeight(\n        address indexed user,\n        address indexed gauge,\n        uint256 weight\n    );\n\n    /// @notice emitted when decrementing a gauge\n    event DecrementGaugeWeight(\n        address indexed user,\n        address indexed gauge,\n        uint256 weight\n    );\n\n    /** \n    @notice increment a gauge with some weight for the caller\n    @param gauge the gauge to increment\n    @param weight the amount of weight to increment on gauge\n    @return newUserWeight the new user weight\n    */\n    function incrementGauge(\n        address gauge,\n        uint256 weight\n    ) public virtual returns (uint256 newUserWeight) {\n        require(isGauge(gauge), \"ERC20Gauges: invalid gauge\");\n        _incrementGaugeWeight(msg.sender, gauge, weight);\n        return _incrementUserAndGlobalWeights(msg.sender, weight);\n    }\n\n    /// @dev this function does not check if the gauge exists, this is performed\n    /// in the calling function.\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal virtual {\n        bool added = _userGauges[user].add(gauge); // idempotent add\n        if (added && _userGauges[user].length() > maxGauges) {\n            require(canExceedMaxGauges[user], \"ERC20Gauges: exceed max gauges\");\n        }\n\n        getUserGaugeWeight[user][gauge] += weight;\n\n        getGaugeWeight[gauge] += weight;\n\n        totalTypeWeight[gaugeType[gauge]] += weight;\n\n        emit IncrementGaugeWeight(user, gauge, weight);\n    }\n\n    function _incrementUserAndGlobalWeights(\n        address user,\n        uint256 weight\n    ) internal returns (uint256 newUserWeight) {\n        newUserWeight = getUserWeight[user] + weight;\n        // Ensure under weight\n        require(newUserWeight <= balanceOf(user), \"ERC20Gauges: overweight\");\n\n        // Update gauge state\n        getUserWeight[user] = newUserWeight;\n\n        totalWeight += weight;\n    }\n\n    /** \n    @notice increment a list of gauges with some weights for the caller\n    @param gaugeList the gauges to increment\n    @param weights the weights to increment by\n    @return newUserWeight the new user weight\n    */\n    function incrementGauges(\n        address[] calldata gaugeList,\n        uint256[] calldata weights\n    ) public virtual returns (uint256 newUserWeight) {\n        uint256 size = gaugeList.length;\n        require(weights.length == size, \"ERC20Gauges: size mismatch\");\n\n        // store total in summary for batch update on user/global state\n        uint256 weightsSum;\n\n        // Update gauge specific state\n        for (uint256 i = 0; i < size; ) {\n            address gauge = gaugeList[i];\n            uint256 weight = weights[i];\n            weightsSum += weight;\n\n            require(isGauge(gauge), \"ERC20Gauges: invalid gauge\");\n\n            _incrementGaugeWeight(msg.sender, gauge, weight);\n            unchecked {\n                ++i;\n            }\n        }\n        return _incrementUserAndGlobalWeights(msg.sender, weightsSum);\n    }\n\n    /** \n     @notice decrement a gauge with some weight for the caller\n     @param gauge the gauge to decrement\n     @param weight the amount of weight to decrement on gauge\n     @return newUserWeight the new user weight\n    */\n    function decrementGauge(\n        address gauge,\n        uint256 weight\n    ) public virtual returns (uint256 newUserWeight) {\n        // All operations will revert on underflow, protecting against bad inputs\n        _decrementGaugeWeight(msg.sender, gauge, weight);\n        if (!_deprecatedGauges.contains(gauge)) {\n            totalTypeWeight[gaugeType[gauge]] -= weight;\n            totalWeight -= weight;\n        }\n        return getUserWeight[msg.sender];\n    }\n\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal virtual {\n        uint256 oldWeight = getUserGaugeWeight[user][gauge];\n\n        getUserGaugeWeight[user][gauge] = oldWeight - weight;\n        if (oldWeight == weight) {\n            // If removing all weight, remove gauge from user list.\n            require(_userGauges[user].remove(gauge));\n        }\n\n        getGaugeWeight[gauge] -= weight;\n\n        getUserWeight[user] -= weight;\n\n        emit DecrementGaugeWeight(user, gauge, weight);\n    }\n\n    /** \n     @notice decrement a list of gauges with some weights for the caller\n     @param gaugeList the gauges to decrement\n     @param weights the list of weights to decrement on the gauges\n     @return newUserWeight the new user weight\n    */\n    function decrementGauges(\n        address[] calldata gaugeList,\n        uint256[] calldata weights\n    ) public virtual returns (uint256 newUserWeight) {\n        uint256 size = gaugeList.length;\n        require(weights.length == size, \"ERC20Gauges: size mismatch\");\n\n        // store total in summary for batch update on user/global state\n        uint256 weightsSum;\n\n        // Update gauge specific state\n        // All operations will revert on underflow, protecting against bad inputs\n        for (uint256 i = 0; i < size; ) {\n            address gauge = gaugeList[i];\n            uint256 weight = weights[i];\n\n            _decrementGaugeWeight(msg.sender, gauge, weight);\n            if (!_deprecatedGauges.contains(gauge)) {\n                totalTypeWeight[gaugeType[gauge]] -= weight;\n                weightsSum += weight;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        totalWeight -= weightsSum;\n        return getUserWeight[msg.sender];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when adding a new gauge to the live set.\n    event AddGauge(address indexed gauge, uint256 indexed gaugeType);\n\n    /// @notice emitted when removing a gauge from the live set.\n    event RemoveGauge(address indexed gauge);\n\n    /// @notice emitted when updating the max number of gauges a user can delegate to.\n    event MaxGaugesUpdate(uint256 oldMaxGauges, uint256 newMaxGauges);\n\n    /// @notice emitted when changing a contract's approval to go over the max gauges.\n    event CanExceedMaxGaugesUpdate(\n        address indexed account,\n        bool canExceedMaxGauges\n    );\n\n    /// @notice the default maximum amount of gauges a user can allocate to.\n    /// @dev if this number is ever lowered, or a contract has an override, then existing addresses MAY have more gauges allocated to. Use `numUserGauges` to check this.\n    uint256 public maxGauges;\n\n    /// @notice an approve list for contracts to go above the max gauge limit.\n    mapping(address => bool) public canExceedMaxGauges;\n\n    function _addGauge(\n        uint256 _type,\n        address gauge\n    ) internal returns (uint256 weight) {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        require(\n            gauge != address(0) && (newAdd || previouslyDeprecated),\n            \"ERC20Gauges: invalid gauge\"\n        );\n\n        if (newAdd) {\n            // save gauge type on first add\n            gaugeType[gauge] = _type;\n        } else {\n            // cannot change gauge type on re-add of a previously deprecated gauge\n            require(gaugeType[gauge] == _type, \"ERC20Gauges: invalid type\");\n        }\n\n        // Check if some previous weight exists and re-add to total. Gauge and user weights are preserved.\n        weight = getGaugeWeight[gauge];\n        if (weight != 0) {\n            totalTypeWeight[_type] += weight;\n            totalWeight += weight;\n        }\n\n        emit AddGauge(gauge, _type);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        require(\n            _gauges.contains(gauge) && _deprecatedGauges.add(gauge),\n            \"ERC20Gauges: invalid gauge\"\n        );\n\n        // Remove weight from total but keep the gauge and user weights in storage in case gauge is re-added.\n        uint256 weight = getGaugeWeight[gauge];\n        if (weight != 0) {\n            totalTypeWeight[gaugeType[gauge]] -= weight;\n            totalWeight -= weight;\n        }\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @notice set the new max gauges. Requires auth by `authority`.\n    /// @dev if this is set to a lower number than the current max, users MAY have more gauges active than the max. Use `numUserGauges` to check this.\n    function _setMaxGauges(uint256 newMax) internal {\n        uint256 oldMax = maxGauges;\n        maxGauges = newMax;\n\n        emit MaxGaugesUpdate(oldMax, newMax);\n    }\n\n    /// @notice set the canExceedMaxGauges flag for an account.\n    function _setCanExceedMaxGauges(\n        address account,\n        bool canExceedMax\n    ) internal {\n        if (canExceedMax) {\n            require(\n                account.code.length != 0,\n                \"ERC20Gauges: not a smart contract\"\n            );\n        }\n\n        canExceedMaxGauges[account] = canExceedMax;\n\n        emit CanExceedMaxGaugesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires userUnusedWeight < amount.\n    /// _decrementWeightUntilFree is called as a greedy algorithm to free up weight.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementWeightUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _decrementWeightUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _decrementWeightUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /// a greedy algorithm for freeing weight before a token burn/transfer\n    /// frees up entire gauges, so likely will free more than `weight`\n    fun"
    }
  ]
}