{
  "Title": "M-13: `ZivoeYDL::earningsTrancheuse()` always assumes that `daysBetweenDistributions` have passed, which might not be the case",
  "Content": "# Issue M-13: `ZivoeYDL::earningsTrancheuse()` always assumes that `daysBetweenDistributions` have passed, which might not be the case \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/347 \n\n## Found by \n0x73696d616f\n## Summary\n\n`ZivoeYDL::earningsTrancheuse()` calculates the target yield, senior and junior proportions based on `daysBetweenDistributions`. However, it is not strictly enforced that `ZivoeYDL::distributeYield()` is called exactly at the `daysBetweenDistributions` mark, leading to less yield for tranches.\n\n## Vulnerability Detail\n\nThere is a yield target for senior and junior tranches over a [daysBetweenDistributions](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L459-L463) period that when exceeded, sends the rewards to [residuals](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L469-L471). However, the current code will not strictly follow the expected `APY` for senior tranches, as the earning of tranches are calculated based on `daysBetweenDistributions`, but `ZivoeYDL::distributeYield()` may be called significantly [after](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L215-L218) the `daysBetweenDistributions` mark.\n\nAdd the following test to `Test_ZivoeYDL.sol` to confirm that when the senior tranche yield reached the expected target for `30` days, if the time that `ZivoeYDL::distributeYield()` was called increased, the yield distributed to the senior tranch remains the same.\n```solidity\nfunction test_POC_ZivoeYDL_distributeYield_notEnforcingTranchesPeriod() public {    \n    uint256 amtSenior = 1500 ether; // Minimum amount $1,000 USD for each coin.\n    uint256 amount = 1000 ether;\n\n    // Simulating the ITO will \"unlock\" the YDL\n    simulateITO_byTranche_optionalStake(amtSenior, true);\n\n    // uncomment this line instead to confirm that it's the same value below\n    //hevm.warp(YDL.lastDistribution() + YDL.daysBetweenDistributions() * 86400);\n    hevm.warp(YDL.lastDistribution() + YDL.daysBetweenDistributions() * 86400 + 1 days);\n\n    // Deal DAI to the YDL\n    mint(\"DAI\", address(YDL), amount);\n\n    YDL.distributeYield();\n\n    console.log(IERC20(DAI).balanceOf(address(stSTT)));\n}\n```\n\n## Impact\n\nGuaranteed less `APY` for junior and senior tranches. The amount depends on how much time the call to `ZivoeYDL::distributeYield()` was delayed since `block.timestamp` reached `lastDistribution + daysBetweenDistributions * 86400`.\n\n## Code Snippet\n\n[distributeYield()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L215-L218)\n```solidity\nfunction distributeYield() external nonReentrant {\n    ...\n    require(\n        block.timestamp >= lastDistribution + daysBetweenDistributions * 86400, \n        \"ZivoeYDL::distributeYield() block.timestamp < lastDistribution + daysBetweenDistributions * 86400\"\n    );\n    ...\n```\n\n[ZivoeYDL::earningsTrancheuse()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L459-L463)\n```solidity\nfunction earningsTrancheuse(uint256 yP, uint256 yD) public view returns (\n    uint256[] memory protocol, uint256 senior, uint256 junior, uint256[] memory residual\n) {\n    ...\n    uint256 _seniorProportion = MATH.seniorProportion(\n        IZivoeGlobals_YDL(GBL).standardize(yD, distributedAsset),\n        MATH.yieldTarget(emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions),\n        emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions\n    );\n    ...\n}\n```\n\n## Tool used\n\nManual Review\n\nVscode\n\nFoundry\n\n## Recommendation\n\nModify the [ZivoeMath::seniorProportion()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeMath.sol#L68-L75) and [ZivoeMath::yieldTarget()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeMath.sol#L121-L123) implementations to use seconds instead of days for `T`. Then, in `Zivoe::YDL::earningsTrancheuse()`, instead of [daysBetweenDistributions](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L459-L463) when calculating the yield target and senior proportion, use `block.timestamp - lastDistribution`. Also, in `ZivoeYDL::distributeYield()`, `lastDistribution = block.timestamp;` must be moved after [earningsTrancheuse()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L227-L232) is called.\n\n\n\n## Discussion\n\n**pseudonaut**\n\nIt will called immediately when possible, so there may be few blocks of lag, acceptable\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> invalid, trusted keepers will call it as soon as possible, and even there is a slight delay due to network congestion or whatever else, this is acceptable and intended\n\n\n\n**0x73696d616f**\n\nEscalate\n\nThis should be valid as in the first distribution period, the duration is 60 instead of 30, calculating a much smaller APR than it should be. Half the APR is calculated instead of the intended, a substancial amount, which means this should be a valid medium according to the docs.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> This should be valid as in the first distribution period, the duration is 60 instead of 30, calculating a much smaller APR than it should be. Half the APR is calculated instead of the intended, a substancial amount, which means this should be a valid medium according to the docs.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nThis is still invalid/low. The 30-days yield for the first distribution which is after 60 days is also intended according to sponsor, see for example #531 which is about the same.\n\n**0x73696d616f**\n\nWhere did the sponsor state or are there any docs showing that the APR should also be half? The sponsor only mentioned the duration as intended.\n\n**panprog**\n\nThis was in a private discussion to confirm the intended behavior.\n\n**0x73696d616f**\n\nCan't argue with that.\nIn any case, just a small delay of 5 minutes, will lead to more than 1 BIPS of loss of rewards, as the duration of 30 days is relatively small.\n`(5 / (30*24*60))*10000 = 1.15`. The delay may be bigger in certain sporadic events, leading to even bigger losses.\n\n**0x73696d616f**\n\nAdditionally, the sponsor may say it's acceptable but it does not mean it is not a significant amount nor invalidates the issue.\n\n**0x73696d616f**\n\nThis [article](https://www.coindesk.com/tech/2023/05/12/ethereum-resumes-finalizing-blocks-after-second-performance-hiccup-in-24-hours/), for example, mentions an outage for 1 hour, which is `(1 / (30*24))*10000 = 14 BPS`. Much more significant than dust or precision, as the [docs](https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue) mention to be a valid medium issue.\n\n**WangSecurity**\n\nFirstly, I agree that there is no guarantee the keeper will make the call instantly, and there might be delay. But, for that I need to understand what are the losses. I see in [this comment](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/347#issuecomment-2105664946) you say that in 5 mins it will lose 1 BIPS in terms of rewards, which is 0.01% of the rewards lost, correct? And if it's less than 5 mins, then it'll be less than 1 BIPS. But, the longer the delay, the larger the loss, correct?\n\n**0x73696d616f**\n\n@WangSecurity exactly.\n\n**panprog**\n\n@WangSecurity \nExample:\n- Tranche has $3600 deposited. Target APR = 10%, meaning it's $30 per month.\n- The earnings for previous period = $35. $30 is deposited to tranche ZivoeReward and distributes at a rate of $1/day (the rest of it - $5 - goes to residual recepients)\n- The earnings for the next period = $32. However, the keeper failed to call it in time and called only after 1 day. Since the distribution was $1/day for 30 days, it stops after 30 days and it's $0 for the following day.\n- The keeper finally calls `distributeYield` after 1 day of delay, but it distributes $30 again (not $31 to account for extra day), $2 goes to residuals.\n\nThis means that due to 1 day of keeper delay, tranche stakers will receive $30 over 31 days instead of $31. This is 1/31 = 3.2% loss. However, perhaps a more correct way to calculate is to compare the target APR with actual APR. So target = 10%, actual = 30/31*356/3600 = 9.57%, a loss of 0.43% APR per day of delay or a loss of 0.0003% APR per minute of delay.\n\nSince such keeper delay is not very likely, it's better to estimate a total time of keeper delay over the year. In such case the APR loss is 1/3600 = 0.028% per day of delay. Again, this is only if distributed yield exceeds the target APR.\n\nOne more thing to consider is that the target rates can be changed by admin via `updateTargetAPYBIPS` and `updateTargetRatioBIPS`, so admin can compensate for these delays by increasing target rate if necessary.\n\n**CergyK**\n\nAdditional points to take into consideration when evaluating this issue:\n- `distributeYield` is an unpermissioned action, so if the impact of keeper downtime is deemed unacceptable by any actor, they can ensure it is called timely themselves.\n- A mainnet outage event of which 2 happened last year, would have to coincide exactly with the beginning of a `distributeYield` unlocking, which is quite unlikely (1 hour / 30 days = 0.01% chance of overlap)\n\n**0x73696d616f**\n\n@panprog your comment is highly misleading. Firstly, you make a logic error (I hope it's a mistake), which will be explained in detail. Then, replace the `3600` by `360_000`, and now the loss is 100 USD. Also, the previous and next periods are not required for this discussion, only the current distribution. There is no need to add extra complexity. Let's break it down.\n\nThe expected monthly APR is pro-rata to the time passed, which means the error % will be the same. So a 3.2% error in the number of days will lead to a 3.2% APR error during the 31 days. Check the math at the end of the comment for confirmation. This is the first mistake.\n\nNow, the second mistake, which is much more serious, is that @panprog is calculating the error in ABSOLUTE terms, not relative. This makes no sense. For example, if the target APR was `0.1%`, the actual APR would be `0.001 - 0.001*0.032 = 0.000968`, just a difference of `0.0032%`. This is obviously wrong and extremely misleading. The actual error is calculated in relative terms, similar to what is done when calculating the days error as 1/31, and not just 1.\nSo, if the target APR is 10%, but the actual is 9.68%, the error in % is (target - actual) / target = `(0.1 - 0.0968) / 0.1 = 0.032`, or 3.2%.\n\nAdditionally, it makes no sense to compare to the yearly APR because e would have to sum all the delays in the year to calculate it, not just use the delay of a single month.\n\nMath proof that the APR error is always the same as the number of days error:\nTarget USD for 31 days, USDt, is `USDt = 31 / 365 * 3600 * 0.1`. 31 is the number of days, 365 the number of days in a year, used in the [calculation](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeMath.sol#L122) and 0.1 is 10%.\nNow, the actual % in these 31 days, where USDa will be the actual USD in the 31 days:\n`USDa = 3600 * 0.1 * 30 / 365`. This is because during the 31 days, only 30 is distributed.\nTo get the corresponding %, we invert the formula above, where 0.1 is the target % (10%)\n`0.1 = USDt * 365 / 31 / 3600`, which is just the inverted formula above.\nNow, to get the actual %, just replace the right hand side of the expression before by the actual values\n`APR = USDa * 365 / 31 / 3600`, `USDa = 3600 * 0.1 * 30 / 365`, so\n`APR = 3600 * 0.1 * 30 / 365 * 365 / 31 / 3600 = 0.1*30/31`, which is 0.0968. Sounds familiar right? this is 0.1 - 0.0032, where 0.0032 is the 3.2% calculated before, but multiplied by 0.1 because it's in APR terms.\n\n\n\n**0x73696d616f**\n\nOther points to consider:\n1. If there is an outage it does not matter who is the actor calling distribute yield.\n2. The chance is small for a big outage, but smaller to medium delays are much more likely (where smaller delays are guaranteed).\n\n**WangSecurity**\n\nFirstly, as I understand all of us agree that the vulnerability is present in the code. The problem here is that there is firstly, high constraints:\n1. Keepers not calling distribute yield.\n2. Users not calling distribute yield as well.\n\nBut there is no guarantee that the keeper will cetainly make a call and not misbehave and there is no guarantee that the user will call it on time. So I believe, it's fair to say that the daly may indeed happen, but with very low probability. To better understand what are the losses, @0x73696d616f can you make these calculations if it's only 1 hr delay or 5 min delay? And @panprog and @CergyK would like to ask you check the calculations above to verify they're 100% correct.\n\n**0x73696d616f**\n\nThe calculations are very simple, the loss is delay / (30 days + delay) Ã— earnings. One hour is 1 / (30x24 + 1) = 0.13%. 5 minutes is 5 / (30x24x60 + 5) = 0.01%.\nIf the earnings are 360_000, the loss is 500 and 42 USD, respectively. \n\n**CergyK**\n\n> The calculations are very simple, the loss is delay / (30 days + delay) Ã— earnings. One hour is 1 / (30x24 + 1) = 0.13%. 5 minutes is 5 / (30x24x60 + 5) = 0.01%.\n> If the earnings are 360_000, the loss is 500 and 42 USD, respectively. \n\nAgree with these calculations\n\n**panprog**\n\n> The calculations are very simple, the loss is delay / (30 days + delay) Ã— earnings. One hour is 1 / (30x24 + 1) = 0.13%. 5 minutes is 5 / (30x24x60 + 5) = 0.01%. If the earnings are 360_000, the loss is 500 and 42 USD, respectively.\n\nYes, the calculations are correct.\n\n**WangSecurity**\n\nAs I understand, the admin relies on keeper bots to call `distributeYield`, but as we agree there can be a delay and it's not guaranteed that they will call on time every time. Or am I missing something here?\n\n**0x73696d616f**\n\n@WangSecurity yes, that's it. I think the previous comment ignored a good chunk of this conversation.\n\n**ZdravkoHr**\n\nIf this issue is deemed valid, #85 should also be validated, because:\n  - it has the same impact, but on a bigger scale - the delay is 30 days and it's certain.\n  - it does not rely on keeper being inactive - will happen for sure\n\n**0x73696d616f**\n\n@ZdravkoHr I don't think they should be grouped together, you'll notice I submitted a separate issue #345 which was exactly like #85 and was invalidated for the same reason (sponsor's intention for the first distribution to be 60 days). In #345 and #85, they both point at the fact that the initial distribution is 60 days, not 30. This issue goes a bit further and claims that beyond the initial period, there will be more delays as the keeper can not guarantee strictly calling it on time. This is further demonstrated by the recommendations given, using the one from #85, this issue (#347) would still exist. Thus, #85 does not identify the correct attack path.\n\n**ZdravkoHr**\n\n@0x73696d616f, I agree #85 doesn't talk about `daysBetweenDistributions` in more detail, but the root issue is still the same, as described \n\n```\nTherefore, the first distribution can be executed after at least 60 days since the unlocking have passed. However, the whole distribution process calculates its values for a single month, using daysBetweenDistributions.\n```\n\nIf `earningsTrancheuse` was not fixated to 30 days, but instead it calculated time correctly, there would have been no problem with initial distribution happening after 60 days. \n\n**0x73696d616f**\n\n@ZdravkoHr I know you were aware of the issue when you wrote the report (as you correctly identified the root cause), but the Sherlock rules are clear, if the identified attack path is incorrect (as is the case in #85 as your whole report only mentioned the initial 60 days period), the issue is at most low.\n\n**ZdravkoHr**\n\n```\nBoth B & C would not have been possible if error A did not exist in the first place. In this case, both B & C should be put together as duplicates.\n\nIn addition to this, there is a submission D which identifies the core issue but does not clearly describe the impact or an attack path. Then D is considered low.\n```\n\nI don't think #85 is `issue D` in this scenario. There isn't really an attack path in this situation. There is a root cause which causes loss in yield based on a given delay. The delay in #85 is caused by executing the initial distribution 30 days later, while the delay in this issue is caused by a keeper being inactive. \n\n**WangSecurity**\n\nAs we agree, the keeper might have a delay and not guaranteed to call on time. Secondly, despite it's being in the user interest to call it on time as well, it's not guaranteed as well. Thirdly, as was proven by the escalator the loss is equal or exceeds 0.01% which I believe exceeds small and finite amounts. Finally, as I understand, the sponsor said it's acceptable only after the contest and it wasn't known during the contest that this risk is known/acceptable.\n\nHence, planning to accept the escalation and validate the issue with medium severity.\n\n**ZdravkoHr**\n\n@WangSecurity, what do you think about #85?\n\n**0x73696d616f**\n\n#85 explicitly says the root cause is the initial period being 60 days. It mentions that the yield is calculated on 30 days, but does not see this part as the root cause.\n\n**RealLTDingZhen**\n\nHey @WangSecurity @panprog after a careful reading, I believe this issue is valid, and should be duplicated with #697 #692 #672 #657.\n\n\n\nZivoe didn't tell watsons whether they were going to run a keeper themselves or use an external keeper. Lets assume for this issue users will not calling distribute yield.\n\nIf protocol is going to run a keeper themselves, then this is not a issue because admin/owner is TRUSTED.\n\nIf the external Keeper does not follow the rules for calling the `distributeYield()` on time, this is a misbehave of external admin, so this issue should be duplicated with those where external admin's actions are leading to a harm of Zivoe with Medium severity.\n\n> Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n> \n> RESTRICTED\n\nAnd please refer to here:\n\nhttps://github.com/sherlock-audit/2024-03-zivoe-judging/issues/672#issuecomment-2115546327\n\n> according to README and external admins being restricted, these reports indeed should be valid. But, I believe the most fair option is to duplicate this report with other issues where external admin's actions are leading to a harm of Zivoe with Medium severity, due to extremely low likelihood.\n\n\n\n**0x73696d616f**\n\n> Lets assume for this issue users will not calling distribute yield.\n\nThis assumption makes no sense.\n\n> If protocol is going to run a keeper themselves, then this is not a issue because admin/owner is TRUSTED.\n\nThis is false as they can not control network congestion.\n\n\n**RealLTDingZhen**\n\nIf this assumption makes no sense, this issue should be invalidatedðŸ˜‚ If users will call distribute yield immediately, this is not a issue because sponsor confirms\n\n> It will called immediately when possible, so there may be few blocks of lag, acceptable\n\nPlease refer to https://docs.sherlock.xyz/audits/judging/judging#vii.-list-of-issue-categories-that-are-not-considered-valid\n\n> #20:\n> Chain re-org and network liveness related issues are not considered valid.\n> Exception: If an issue concerns any kind of a network admin (e.g. a sequencer), can be remedied by a smart contract modification, the protocol team considers external admins restricted and the considered network was explicitly mentioned in the contest README, it may be a valid medium. It should be assumed that any such network issues will be resolved within 7 days, if that may be possible.\n\nThis issue is not a vulnerability if **one of** keepers or protocol team or users is behave normally. In your words, it is a issue because of network congestion, which is not accepted by sherlock.\n\nThe only possible path for this issue is a external Keeper bot misbehave, which should be duped with those issues above.\n\n**0x73696d616f**\n\n> If this assumption makes no sense, this issue should be invalidatedðŸ˜‚ If users will call distribute yield immediately, this is not a issue because sponsor confirms\n\nnetwork congestion.\n\nA small delay is not considered 'network liveness', it's regular behaviour. And the issue may be fixed by a smart contract modification.\n\n**RealLTDingZhen**\n\nAs you agree there may be a small delay:\n\nhttps://github.com/sherlock-audit/2024-03-zivoe-judging/issues/347#issuecomment-2081539634\n\n> there may be few blocks of lag, acceptable\n\nSo, what kind of network congestion(not a issue with network liveness) can make this a issue? If this congestion occurs on the Keeper side, \n\nPer LSW:https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/347#issuecomment-2114623235\n\n> A mainnet outage event of which 2 happened last year, would have to coincide exactly with the beginning of a distributeYield unlocking, which is quite unlikely (1 hour / 30 days = 0.01% chance of overlap)\n\nThis is definitly low likelihood + low impact(keepers should call the function right after the congestion, so only a few blocks of lag)\n\n\n\n**0x73696d616f**\n\n@RealLTDingZhen the numbers are all above, please refer to them.\n\n**RealLTDingZhen**\n\nI see your calculations ser, but this did not counter my(and Cergyk) point.\n\n> the loss is delay / (30 days + delay) Ã— earnings\n\nI agree that the losses will increase in that proportion, but this do not counter my arguments.\n\nMy two main arguments are:\n\nIf we assume this issue do not require a malicious Keeper and protocol team/users are all not aware of this, then:\n\n1. the likelihood is still extremely low. The \"network congestion\" have to coincide exactly with the beginning of a distributeYield unlocking. (@CergyK can you please confirm how long the 2 mainnet outage event in last year last?)\n2. This issue relays on a long Ethereum mainnet downtime. As you have calculated, 1 hour lag = 0.13% loss of yield that month. However, an hour of downtime on Ethereum mainnet can definitely be seen as a network liveness issue. (Consider those lending/perpetual/oracle protocols, it would be disastrous for them.) If the lag is just some blocks, sponsor is fully acknowledged and can accept the risk, so this is a informational issue.\n\n\n\n\n\n**0x73696d616f**\n\nThe likelihood goes from very high to low as the duration of the delay goes up. You're picking on the upper bound and basing the argument on it, which is deceiving.\n\n**RealLTDingZhen**\n\nIf the network is congested for a long period of time, then this issue can be invalidated outright by reason \"network liveness\".\nIf the network is congested for a short period of time, then this issue can be invalidated outright because sponsor confirms there may be few blocks of lag, and that is acceptable. \n\nSo how long is the right delay to make this issue both probable and impactful? And my points above is still valid to invalidate this issue.\n\n\n**0x73696d616f**\n\nThere is no clear line as to where the delay stops being considered acceptable. It's up to the user deciding the escalations to decide, which has been done.\n> this issue can be invalidated outright because sponsor confirms there may be few blocks of lag, and that is acceptable.\n\nThis has also been answered.\n\n**RealLTDingZhen**\n\nThis is my final statement on this issue (Summary of above views):\n\n1. If we think this issue need a malicious/misbehave Keeper bot, then this should be duped with #697 #692 #672 #657.\n\n2. If we think this issue can be triggered by normal operation, then this issue should be invalidated for reasons below:\n  a. The likelihood is extremely low: A mainnet outage event of which 2 happened last year, would have to coincide exactly with the beginning of a distributeYield unlocking, which is quite unlikely. And even if such coincidence downtime exists, the issue becomes a network liveness issue because the loss is proportional to the downtime(5min -> 1BIPS, which is a network liveness issue.).\n  b. The impact is low: 5min downtime in Ethereum-> 1 BIPS loss itself is low impact. and sponsor confirms that \"there may be few blocks of lag, acceptable\".\n\n**RealLTDingZhen**\n\nLet's leave it up to the judge for now, it's ultimately up to him. Good discussion @0x73696d616f I always like a good debate ðŸ‘\n\n**0x73696d616f**\n\n> If we think this issue can be triggered by normal operation, then this issue should be invalidated for reasons below:\na. The likelihood is extremely low: A mainnet outage event of which 2 happened last year, would have to coincide exactly with the beginning of a distributeYield unlocking, which is quite unlikely. And even if such coincidence downtime exists, the issue becomes a network liveness issue.\nb. The impact is low: 5min downtime in Ethereum downtime -> 1 BIPS loss itself is low impact. and sponsor confirms that \"there may be few blocks of lag, acceptable\".\n\nYour message is incorrectly implicitly mixing the likelihood of the 1 hour event with the impact of a 5 minutes delay,\nAlso, please don't mention point 1. as this was never mentioned in this report, you're just adding confusion.\n\n**RealLTDingZhen**\n\n> Your message is incorrectly implicitly mixing the likelihood of the 1 hour event with the impact of a 5 minutes delay,\n> Also, please don't mention point 1. as this was never mentioned in this report, you're just adding confusion.\n\nThis is because your issue requires distribute yield function not be called for a period of time, and there are only two scenarios for this - Keeper misbehave or network downtime.\n\n**WangSecurity**\n\nI hope this will answer your questions:\n\nFirstly, there is no guarantee the keeper will work without a delay. Secondly, if we consider it external, I believe it's not a dup of #657 because 657 requires external admins executing certain actions to completely rug Zivoe (either block their functionality or steal funds), while this can happen at any time, cause it's not guaranteed to execute every call on time every time. Thirdly, I see the sponsor saying it's acceptable, but it's said only after the contest and wasn't known during it. Fourthly, I agree that the loss is very small, and the likelihood as well. But it still qualifies for medium severity: high external constraints and the loss of funds exceeds small and finita amounts. I believe 0.01% exceeds small and finite amounts. If any of my assupmtions is wrong, please correct me or ask questions.\n\nBut the decision remains the same, accept the escalation and validate the report with medium severity.\n\n**ZdravkoHr**\n\n@0x73696d616f,  I agree in my report I have described setting the lastDistributed as a root cause. But I do still think that #85 deserves revisiting, even if it's not judged as a duplicate of this issue because the impact is the same if not worse\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0x73696d616f](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/347/#issuecomment-2105655142): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeYDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./ZivoeMath.sol\";\n\nimport \"./libraries/FloorMath.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IZivoeGlobals_YDL {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n    \n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice This function will verify if a given stablecoin has been whitelisted for use throughout system.\n    /// @param  stablecoin address of the stablecoin to verify acceptance for.\n    function stablecoinWhitelist(address stablecoin) external view returns (bool);\n}\n\ninterface IZivoeRewards_YDL {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @param  reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice  This contract manages the accounting for distributing yield across multiple contracts.\n///          This contract has the following responsibilities:\n///            - Escrows yield in between distribution periods.\n///            - Manages accounting for yield distribution.\n///            - Supports modification of certain state variables for governance purposes.\n///            - Tracks historical values using EMA (exponential moving average) on 30-day basis.\ncontract ZivoeYDL is Context, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Recipients {\n        address[] recipients;\n        uint256[] proportion;\n    }\n\n    Recipients protocolRecipients;          /// @dev Tracks the distributions for protocol earnings.\n    Recipients residualRecipients;          /// @dev Tracks the distributions for residual earnings.\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    address public distributedAsset;        /// @dev The \"stablecoin\" that will be distributed via YDL.\n\n    // Weighted moving averages.\n    uint256 public emaSTT;          /// @dev Weighted moving average for senior tranche size, a.k.a. zSTT.totalSupply().\n    uint256 public emaJTT;          /// @dev Weighted moving average for junior tranche size, a.k.a. zJTT.totalSupply().\n\n    // Indexing.\n    uint256 public distributionCounter;     /// @dev Number of calls to distributeYield().\n    uint256 public lastDistribution;        /// @dev Used for timelock constraint to call distributeYield().\n\n    // Accounting vars (governable).\n    uint256 public targetAPYBIPS = 1000;                /// @dev The target annualized yield for senior tranche.\n    uint256 public targetRatioBIPS = 22000;             /// @dev The target ratio of junior to senior tranche.\n    uint256 public protocolEarningsRateBIPS = 2000;     /// @dev The protocol earnings rate.\n\n    // Accounting vars (constant).\n    uint256 public constant daysBetweenDistributions = 30;   /// @dev Number of days between yield distributions.\n    uint256 public constant retrospectiveDistributions = 6;  /// @dev Retrospective moving average period.\n    \n    bool public unlocked;                   /// @dev Prevents contract from supporting functionality until unlocked.\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n    ZivoeMath public MATH;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initialize the ZivoeYDL contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _distributedAsset The \"stablecoin\" that will be distributed via YDL.\n    constructor(address _GBL, address _distributedAsset) {\n        GBL = _GBL;\n        distributedAsset = _distributedAsset;\n        MATH = new ZivoeMath();\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during returnAsset().\n    /// @param  asset The asset returned.\n    /// @param  amount The amount of \"asset\" returned to DAO.\n    event AssetReturned(address indexed asset, uint256 amount);\n\n    /// @notice Emitted during updateDistributedAsset().\n    /// @param  oldAsset The old value of distributedAsset.\n    /// @param  newAsset The new value of distributedAsset.\n    event UpdatedDistributedAsset(address indexed oldAsset, address indexed newAsset);\n\n    /// @notice Emitted during updateProtocolEarningsRateBIPS().\n    /// @param  oldValue The old value of protocolEarningsRateBIPS.\n    /// @param  newValue The new value of protocolEarningsRateBIPS.\n    event UpdatedProtocolEarningsRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive protocol earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedProtocolRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive residual earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedResidualRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateTargetAPYBIPS().\n    /// @param  oldValue The old value of targetAPYBIPS.\n    /// @param  newValue The new value of targetAPYBIPS.\n    event UpdatedTargetAPYBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateTargetRatioBIPS().\n    /// @param  oldValue The old value of targetRatioBIPS.\n    /// @param  newValue The new value of targetRatioBIPS.\n    event UpdatedTargetRatioBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  protocol The amount of earnings distributed to protocol earnings recipients.\n    /// @param  senior The amount of earnings distributed to the senior tranche.\n    /// @param  junior The amount of earnings distributed to the junior tranche.\n    /// @param  residual The amount of earnings distributed to residual earnings recipients.\n    event YieldDistributed(uint256[] protocol, uint256 senior, uint256 junior, uint256[] residual);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  recipient The recipient of the distribution.\n    /// @param  amount The amount distributed.\n    event YieldDistributedSingle(address indexed asset, address indexed recipient, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice View distribution information for protocol and residual earnings recipients.\n    /// @return protocolEarningsRecipients The destinations for protocol earnings distributions.\n    /// @return protocolEarningsProportion The proportions for protocol earnings distributions.\n    /// @return residualEarningsRecipients The destinations for residual earnings distributions.\n    /// @return residualEarningsProportion The proportions for residual earnings distributions.\n    function viewDistributions() external view returns (\n        address[] memory protocolEarningsRecipients, uint256[] memory protocolEarningsProportion, \n        address[] memory residualEarningsRecipients, uint256[] memory residualEarningsProportion\n    ) {\n        return (\n            protocolRecipients.recipients, \n            protocolRecipients.proportion, \n            residualRecipients.recipients, \n            residualRecipients.proportion\n        );\n    }\n    \n    /// @notice Distributes available yield within this contract to appropriate entities.\n    function distributeYield() external nonReentrant {\n        require(unlocked, \"ZivoeYDL::distributeYield() !unlocked\"); \n        require(\n            block.timestamp >= lastDistribution + daysBetweenDistributions * 86400, \n            \"ZivoeYDL::distributeYield() block.timestamp < lastDistribution + daysBetweenDistributions * 86400\"\n        );\n\n        // Calculate protocol earnings.\n        uint256 earnings = IERC20(distributedAsset).balanceOf(address(this));\n        uint256 protocolEarnings = protocolEarningsRateBIPS * earnings / BIPS;\n        uint256 postFeeYield = earnings.floorSub(protocolEarnings);\n\n        // Update timeline.\n        distributionCounter += 1;\n        lastDistribution = block.timestamp;\n\n        // Calculate yield distribution (trancheuse = \"slicer\" in French).\n        (\n            uint256[] memory _protocol, uint256 _seniorTranche, uint256 _juniorTranche, uint256[] memory _residual\n        ) = earningsTrancheuse(protocolEarnings, postFeeYield); \n\n        emit YieldDistributed(_protocol, _seniorTranche, _juniorTranche, _residual);\n        \n        // Update ema-based supply values.\n        (uint256 aSTT, uint256 aJTT) = IZivoeGlobals_YDL(GBL).adjustedSupplies();\n        emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));\n        emaJTT = MATH.ema(emaJTT, aJTT, retrospectiveDistributions.min(distributionCounter));\n\n        // Distribute protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            address _recipient = protocolRecipients.recipients[i];\n            if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _protocol[i]);\n                IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n            else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                uint256 splitBIPS = (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                ) / (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                    IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                );\n                uint stZVEAllocation = _protocol[i] * splitBIPS / BIPS;\n                uint vestZVEAllocation = _protocol[i] * (BIPS - splitBIPS) / BIPS;\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(),vestZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n            }\n            else {\n                IERC20(distributedAsset).safeTransfer(_recipient, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n        }\n\n        // Distribute senior and junior tranche earnings.\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stSTT()).depositReward(distributedAsset, _seniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stJTT()).depositReward(distributedAsset, _juniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n\n        // Distribute residual earnings.\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            if (_residual[i] > 0) {\n                address _recipient = residualRecipients.recipients[i];\n                if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                    IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _residual[i]);\n                    IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n                }\n                else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                    uint256 splitBIPS = (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                    ) / (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                        IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                    );\n                    uint stZVEAllocation = _residual[i] * splitBIPS / BIPS;\n                    uint vestZVEAllocation = _residual[i] * (BIPS - splitBIPS) / BIPS;\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                }\n                else {\n                    IERC20(distributedAsset).safeTransfer(_recipient, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _residual[i]);\n                }\n            }\n        }\n    }\n\n    /// @notice Returns an asset to DAO if not distributedAsset().\n    /// @param asset The asset to return.\n    function returnAsset(address asset) external {\n        require(asset != distributedAsset, \"ZivoeYDL::returnAsset() asset == distributedAsset\");\n        emit AssetReturned(asset, IERC20(asset).balanceOf(address(this)));\n        IERC20(asset).safeTransfer(IZivoeGlobals_YDL(GBL).DAO(), IERC20(asset).balanceOf(address(this)));\n    }\n\n    /// @notice Unlocks this contract for distributions, initializes values.\n    function unlock() external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).ITO(), \n            \"ZivoeYDL::unlock() _msgSender() != IZivoeGlobals_YDL(GBL).ITO()\"\n        );\n\n        unlocked = true;\n        lastDistribution = block.timestamp + 30 days;\n\n        emaSTT = IERC20(IZivoeGlobals_YDL(GBL).zSTT()).totalSupply();\n        emaJTT = IERC20(IZivoeGlobals_YDL(GBL).zJTT()).totalSupply();\n\n        address[] memory protocolRecipientAcc = new address[](2);\n        uint256[] memory protocolRecipientAmt = new uint256[](2);\n\n        protocolRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        protocolRecipientAmt[0] = 6666;\n        protocolRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        protocolRecipientAmt[1] = 3334;\n\n        protocolRecipients = Recipients(protocolRecipientAcc, protocolRecipientAmt);\n\n        address[] memory residualRecipientAcc = new address[](2);\n        uint256[] memory residualRecipientAmt = new uint256[](2);\n\n        residualRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        residualRecipientAmt[0] = 6666;\n        residualRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        residualRecipientAmt[1] = 3334;\n\n        residualRecipients = Recipients(residualRecipientAcc, residualRecipientAmt);\n    }\n\n    /// @notice Updates the distributed asset for this particular contract.\n    /// @param  _distributedAsset The new value for distributedAsset.\n    function updateDistributedAsset(address _distributedAsset) external nonReentrant {\n        require(\n            _distributedAsset != distributedAsset, \n            \"ZivoeYDL::updateDistributedAsset() _distributedAsset == distributedAsset\"\n        );\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateDistributedAsset() _msgSender() != TLC()\"\n        );\n        require(\n            IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset),\n            \"ZivoeYDL::updateDistributedAsset() !IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset)\"\n        );\n        emit UpdatedDistributedAsset(distributedAsset, _distributedAsset);\n        distributedAsset = _distributedAsset;\n    }\n\n    /// @notice Updates the state variable \"protocolEarningsRateBIPS\".\n    /// @param  _protocolEarningsRateBIPS The new value for protocolEarningsRateBIPS.\n    function updateProtocolEarningsRateBIPS(uint256 _protocolEarningsRateBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _msgSender() != TLC()\"\n        );\n        require(\n            _protocolEarningsRateBIPS <= 9000, \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _protocolEarningsRateBIPS > 9000\"\n        );\n        emit UpdatedProtocolEarningsRateBIPS(protocolEarningsRateBIPS, _protocolEarningsRateBIPS);\n        protocolEarningsRateBIPS = _protocolEarningsRateBIPS;\n    }\n\n    /// @notice Updates the protocolRecipients or residualRecipients.\n    /// @param  recipients An array of addresses to which protocol earnings will be distributed.\n    /// @param  proportions An array of ratios relative to the recipients - in BIPS. Sum should equal to 10000.\n    /// @param  protocol Specify \"true\" to update protocol earnings, or \"false\" to update residual earnings.\n    function updateRecipients(address[] memory recipients, uint256[] memory proportions, bool protocol) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateRecipients() _msgSender() != TLC()\");\n        require(\n            recipients.length == proportions.length && recipients.length > 0, \n            \"ZivoeYDL::updateRecipients() recipients.length != proportions.length || recipients.length == 0\"\n        );\n        require(unlocked, \"ZivoeYDL::updateRecipients() !unlocked\");\n\n        uint256 proportionTotal;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            proportionTotal += proportions[i];\n            require(proportions[i] > 0, \"ZivoeYDL::updateRecipients() proportions[i] == 0\");\n            require(recipients[i] != address(0), \"ZivoeYDL::updateRecipients() recipients[i] == address(0)\");\n        }\n\n        require(proportionTotal == BIPS, \"ZivoeYDL::updateRecipients() proportionTotal != BIPS (10,000)\");\n        if (protocol) {\n            emit UpdatedProtocolRecipients(recipients, proportions);\n            protocolRecipients = Recipients(recipients, proportions);\n        }\n        else {\n            emit UpdatedResidualRecipients(recipients, proportions);\n            residualRecipients = Recipients(recipients, proportions);\n        }\n    }\n\n    /// @notice Updates the state variable \"targetAPYBIPS\".\n    /// @param  _targetAPYBIPS The new value for targetAPYBIPS.\n    function updateTargetAPYBIPS(uint256 _targetAPYBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetAPYBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetAPYBIPS(targetAPYBIPS, _targetAPYBIPS);\n        targetAPYBIPS = _targetAPYBIPS;\n    }\n\n    /// @notice Updates the state variable \"targetRatioBIPS\".\n    /// @param  _targetRatioBIPS The new value for targetRatioBIPS.\n    function updateTargetRatioBIPS(uint256 _targetRatioBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetRatioBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetRatioBIPS(targetRatioBIPS, _targetRatioBIPS);\n        targetRatioBIPS = _targetRatioBIPS;\n    }\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /// @notice Calculates the distribution of yield (\"earnings\") for the four primary groups.\n    /// @param  yP Yield for the protocol.\n    /// @param  yD Yield for the remaining three groups.\n    /// @return protocol Protocol earnings.\n    /// @return senior Senior tranche earnings.\n    /// @return junior Junior tranche earnings.\n    /// @return residual Residual earnings.\n    function earningsTrancheuse(uint256 yP, uint256 yD) public view returns (\n        uint256[] memory protocol, uint256 senior, uint256 junior, uint256[] memory residual\n    ) {\n        protocol = new uint256[](protocolRecipients.recipients.length);\n        residual = new uint256[](residualRecipients.recipients.length);\n        \n        // Accounting for protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            protocol[i] = protocolRecipients.proportion[i] * yP / BIPS;\n        }\n\n        // Accounting for senior and junior earnings.\n        uint256 _seniorProportion = MATH.seniorProportion(\n            IZivoeGlobals_YDL(GBL).standardize(yD, distributedAsset),\n            MATH.yieldTarget(emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions),\n            emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions\n        );\n        senior = (yD * _seniorProportion) / RAY;\n        junior = (yD * MATH.juniorProportion(emaSTT, emaJTT, _seniorProportion, targetRatioBIPS)) / RAY;\n        \n        // Handle accounting for residual earnings.\n        yD = yD.floorSub(senior + junior);\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            residual[i] = residualRecipients.proportion[i] * yD / BIPS;\n        }\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/ZivoeYDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./ZivoeMath.sol\";\n\nimport \"./libraries/FloorMath.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IZivoeGlobals_YDL {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n    \n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice This function will verify if a given stablecoin has been whitelisted for use throughout system.\n    /// @param  stablecoin address of the stablecoin to verify acceptance for.\n    function stablecoinWhitelist(address stablecoin) external view returns (bool);\n}\n\ninterface IZivoeRewards_YDL {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @param  reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice  This contract manages the accounting for distributing yield across multiple contracts.\n///          This contract has the following responsibilities:\n///            - Escrows yield in between distribution periods.\n///            - Manages accounting for yield distribution.\n///            - Supports modification of certain state variables for governance purposes.\n///            - Tracks historical values using EMA (exponential moving average) on 30-day basis.\ncontract ZivoeYDL is Context, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Recipients {\n        address[] recipients;\n        uint256[] proportion;\n    }\n\n    Recipients protocolRecipients;          /// @dev Tracks the distributions for protocol earnings.\n    Recipients residualRecipients;          /// @dev Tracks the distributions for residual earnings.\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    address public distributedAsset;        /// @dev The \"stablecoin\" that will be distributed via YDL.\n\n    // Weighted moving averages.\n    uint256 public emaSTT;          /// @dev Weighted moving average for senior tranche size, a.k.a. zSTT.totalSupply().\n    uint256 public emaJTT;          /// @dev Weighted moving average for junior tranche size, a.k.a. zJTT.totalSupply().\n\n    // Indexing.\n    uint256 public distributionCounter;     /// @dev Number of calls to distributeYield().\n    uint256 public lastDistribution;        /// @dev Used for timelock constraint to call distributeYield().\n\n    // Accounting vars (governable).\n    uint256 public targetAPYBIPS = 1000;                /// @dev The target annualized yield for senior tranche.\n    uint256 public targetRatioBIPS = 22000;             /// @dev The target ratio of junior to senior tranche.\n    uint256 public protocolEarningsRateBIPS = 2000;     /// @dev The protocol earnings rate.\n\n    // Accounting vars (constant).\n    uint256 public constant daysBetweenDistributions = 30;   /// @dev Number of days between yield distributions.\n    uint256 public constant retrospectiveDistributions = 6;  /// @dev Retrospective moving average period.\n    \n    bool public unlocked;                   /// @dev Prevents contract from supporting functionality until unlocked.\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n    ZivoeMath public MATH;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initialize the ZivoeYDL contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _distributedAsset The \"stablecoin\" that will be distributed via YDL.\n    constructor(address _GBL, address _distributedAsset) {\n        GBL = _GBL;\n        distributedAsset = _distributedAsset;\n        MATH = new ZivoeMath();\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during returnAsset().\n    /// @param  asset The asset returned.\n    /// @param  amount The amount of \"asset\" returned to DAO.\n    event AssetReturned(address indexed asset, uint256 amount);\n\n    /// @notice Emitted during updateDistributedAsset().\n    /// @param  oldAsset The old value of distributedAsset.\n    /// @param  newAsset The new value of distributedAsset.\n    event UpdatedDistributedAsset(address indexed oldAsset, address indexed newAsset);\n\n    /// @notice Emitted during updateProtocolEarningsRateBIPS().\n    /// @param  oldValue The old value of protocolEarningsRateBIPS.\n    /// @param  newValue The new value of protocolEarningsRateBIPS.\n    event UpdatedProtocolEarningsRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive protocol earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedProtocolRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive residual earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedResidualRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateTargetAPYBIPS().\n    /// @param  oldValue The old value of targetAPYBIPS.\n    /// @param  newValue The new value of targetAPYBIPS.\n    event UpdatedTargetAPYBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateTargetRatioBIPS().\n    /// @param  oldValue The old value of targetRatioBIPS.\n    /// @param  newValue The new value of targetRatioBIPS.\n    event UpdatedTargetRatioBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  protocol The amount of earnings distributed to protocol earnings recipients.\n    /// @param  senior The amount of earnings distributed to the senior tranche.\n    /// @param  junior The amount of earnings distributed to the junior tranche.\n    /// @param  residual The amount of earnings distributed to residual earnings recipients.\n    event YieldDistributed(uint256[] protocol, uint256 senior, uint256 junior, uint256[] residual);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  recipient The recipient of the distribution.\n    /// @param  amount The amount distributed.\n    event YieldDistributedSingle(address indexed asset, address indexed recipient, uint25"
    }
  ]
}