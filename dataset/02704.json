{
  "Title": "H-1: Attackers can use `reclaimContract()` to transfer assets in protocol to address(0)",
  "Content": "# Issue H-1: Attackers can use `reclaimContract()` to transfer assets in protocol to address(0) \n\nSource: https://github.com/sherlock-audit/2022-11-bullvbear-judging/issues/127 \n\n## Found by \nGimelSec, bin2chen, Ruhum, kirk-baird, \\_\\_141345\\_\\_, 0x52, carrot, hansfriese\n\n## Summary\n\n`reclaimContract()` would transfer payment tokens to `bulls[contractId]`. An attacker can make `reclaimContract()` transfer assets to address(0).\n\n## Vulnerability Detail\n\nAn attacker can use a fake order to trick `reclaimContract()`. The fake order needs to meet the following requirements:\n \n* `block.timestamp > order.expiry`. \n* `!settledContracts[contractId]`. \n* `!reclaimedContracts[contractId],`.\n\nThe first one is easy to fulfilled, an attacker can decide the content of the fake order. And the others are all satisfied since the fake order couldn’t be settled or reclaimed before.\n\nThus, `reclaimContract()` would run this line: `IERC20(order.asset).safeTransfer(bull, bullAssetAmount);`. `bull` is address(0) since `bulls[contractId]` hasn’t been filled. If `order.asset`’s implementation doesn’t make sure `to != address(0)`(e.g., https://github.com/ConsenSys/Tokens/blob/fdf687c69d998266a95f15216b1955a4965a0a6d/contracts/eip20/EIP20.sol). The asset would be sent to address(0).\n\n\n```solidity\n    function reclaimContract(Order calldata order) public nonReentrant {\n        bytes32 orderHash = hashOrder(order);\n\n        // ContractId\n        uint contractId = uint(orderHash);\n\n        address bull = bulls[contractId];\n\n        // Check that the contract is expired\n        require(block.timestamp > order.expiry, \"NOT_EXPIRED_CONTRACT\");\n\n        // Check that the contract is not settled\n        require(!settledContracts[contractId], \"SETTLED_CONTRACT\");\n\n        // Check that the contract is not reclaimed\n        require(!reclaimedContracts[contractId], \"RECLAIMED_CONTRACT\");\n\n        uint bullAssetAmount = order.premium + order.collateral;\n        if (bullAssetAmount > 0) {\n            // Transfer payment tokens to the Bull\n            IERC20(order.asset).safeTransfer(bull, bullAssetAmount);\n        }\n\n        reclaimedContracts[contractId] = true;\n\n        emit ReclaimedContract(orderHash, order);\n    }\n```\n\n## Impact\n\nAn attacker can use this vulnerability to transfer assets from BvB to address(0). It results in serious loss of funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bullvbear/blob/main/bvb-protocol/src/BvbProtocol.sol#L417-L443\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere are multiple solutions for this problem.\n\n1. check `bulls[contractId] != address(0)`\n2. check the order is matched `matchedOrders[contractId].maker != address(0)`\n\n## Discussion\n\n**datschill**\n\nPR fixing this issue : https://github.com/BullvBear/bvb-solidity/pull/4\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/23",
  "Code": [
    {
      "filename": "bvb-protocol/src/BvbProtocol.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nimport {ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\n\ncontract BvbProtocol is EIP712(\"BullvBear\", \"1\"), Ownable, ReentrancyGuard, ERC721TokenReceiver {\n    using SafeERC20 for IERC20;\n\n    /*    TYPES    */\n\n    /**\n     * @notice Order details\n     * @param premium The amount paid by the bear\n     * @param collateral The amount paid by the bull\n     * @param validity The timestamp after which this order is invalid\n     * @param expiry The timestamp after which this contract is expired\n     * @param nonce A number used to check order validity and to prevent order reuse\n     * @param fee Fees that should be applied\n     * @param maker The address of the user making the order\n     * @param asset The address of the ERC20 asset used to pay the contract\n     * @param collection The address of the ERC721 collection\n     * @param isBull Is the maker on the bull side (short put)\n     */\n    struct Order {\n        uint premium;\n        uint collateral;\n        uint validity;\n        uint expiry;\n        uint nonce;\n        uint16 fee;\n        address maker;\n        address asset;\n        address collection;\n        bool isBull;\n    }\n\n    /**\n     * @notice SellOrder details\n     * @param orderHash The EIP712 hash of the order/contract\n     * @param price The minimum amount to buy the position\n     * @param start The timestamp after which this sell order can be used, \n     * @param end The timestamp after which this order can't be used\n     * @param nonce A number used to check sell order validity\n     * @param maker The address of the user making the sell order\n     * @param asset The address of the ERC20 asset used to buy the position\n     * @param whitelist Addresses whitelisted to use this sell order, anyone if empty\n     * @param isBull Is it the Bull or Bear position to sell\n     */\n    struct SellOrder {\n        bytes32 orderHash;\n        uint price;\n        uint start;\n        uint end;\n        uint nonce;\n        address maker;\n        address asset;\n        address[] whitelist;\n        bool isBull;\n    }\n\n    /*    STATE    */\n\n    /**\n     * @notice Order type hash used for EIP712\n     */\n    bytes32 public constant ORDER_TYPE_HASH = keccak256(\n        \"Order(uint premium,uint collateral,uint validity,uint expiry,uint nonce,uint16 fee,address maker,address asset,address collection,bool isBull)\"\n    );\n\n     /**\n     * @notice Sell Order type hash used for EIP712\n     */\n    bytes32 public constant SELL_ORDER_TYPE_HASH = keccak256(\n        \"SellOrder(bytes32 orderHash,uint price,uint start,uint end,uint nonce,address maker,address asset,address[] whitelist,bool isBull)\"\n    );\n\n    /**\n     * @notice The address of WETH contract\n     */\n    address payable public immutable weth;\n\n    /**\n     * @notice Fee rate applied\n     * 1 = 0.1%\n     */\n    uint16 public fee;\n\n    /**\n     * @notice Amount of fees withdrawable by the owner\n     * assetAddress => amount\n     */\n    mapping(address => uint) public withdrawableFees;\n\n    /**\n     * @notice Is the asset supported as payment by the protocol\n     * assetAddress => isSupported\n     */\n    mapping(address => bool) public allowedAsset;\n\n    /**\n     * @notice Is the collection supported by the protocol\n     * collectionAddress => isSupported\n     */\n    mapping(address => bool) public allowedCollection;\n\n    /**\n     * @notice Order filled with this id\n     * contractId => Order\n     */\n    mapping(uint => Order) public matchedOrders;\n\n    /**\n     * @notice Sell Order bought with this id\n     * sellOrderHash => SellOrder\n     */\n    mapping(bytes32 => SellOrder) public boughtSellOrders;\n\n    /**\n     * @notice Address of the bull for a contract\n     * contractId => Bull address\n     */\n    mapping(uint => address) public bulls;\n\n    /**\n     * @notice Address of the bear for a contract\n     * contractId => Bear address\n     */\n    mapping(uint => address) public bears;\n\n    /**\n     * @notice Is the contract settled\n     * contractId => isSettled\n     */\n    mapping(uint => bool) public settledContracts;\n\n    /**\n     * @notice Is the contract reclaimed\n     * contractId => isReclaimed\n     */\n    mapping(uint => bool) public reclaimedContracts;\n\n    /**\n     * @notice Is the order canceled\n     * orderHash => isCanceled\n     */\n    mapping(bytes32 => bool) public canceledOrders;\n\n    /**\n     * @notice Is the sell order canceled\n     * sellOrderHash => isCanceled\n     */\n    mapping(bytes32 => bool) public canceledSellOrders;\n\n    /**\n     * @notice Recipient allowed to withdraw a collection token from BvbProtocol\n     * collection => tokenID => recipient\n     */\n    mapping(address => mapping(uint => address)) public withdrawableCollectionTokenId;\n\n    /**\n     * @notice Minimum valid nonce of a user\n     * userAddress => nonce\n     */\n    mapping(address => uint) public minimumValidNonce;\n\n    /**\n     * @notice Minimum valid nonce sell of a user\n     * userAddress => nonce\n     */\n    mapping(address => uint) public minimumValidNonceSell;\n\n    /*    EVENTS    */\n\n    /**\n     * @notice Emitted when a collection status has changed\n     * @param collection The ERC721 collection address\n     * @param allowed Is the collection supported or not\n     */\n    event AllowCollection(address collection, bool allowed);\n\n    /**\n     * @notice Emitted when an asset status has changed\n     * @param asset The ERC20 asset address\n     * @param allowed Is the collection supported or not\n     */\n    event AllowAsset(address asset, bool allowed);\n\n    /**\n     * @notice Emitted when fee rate is updated\n     * @param fee The new fee rate\n     */\n    event UpdatedFee(uint16 fee);\n\n    /**\n     * @notice Emitted when fees are withdrawn\n     * @param asset The address of the ERC20 asset\n     * @param amount Amount withdrawn\n     */\n    event WithdrawnFees(address asset, uint amount);\n\n    /**\n     * @notice Emitted when minimum valid nonce is updated\n     * @param user The user whom increased his minimum valid nonce\n     * @param minimumValidNonce The new minimum valid nonce of a user\n     */\n    event UpdatedMinimumValidNonce(address indexed user, uint minimumValidNonce);\n\n    /**\n     * @notice Emitted when sell minimum valid nonce is updated\n     * @param user The user whom increased his sell minimum valid nonce\n     * @param minimumValidNonceSell The new sell minimum valid nonce of a user\n     */\n    event UpdatedMinimumValidNonceSell(address indexed user, uint minimumValidNonceSell);\n\n    /**\n     * @notice Emitted when an order is canceled\n     * @param orderHash The EIP712 hash of the order canceled\n     * @param bull The Bull of this contract\n     * @param bear The Bear of this contract\n     * @param order The matched order\n     */\n    event MatchedOrder(bytes32 orderHash, address indexed bull, address indexed bear, Order order);\n\n    /**\n     * @notice Emitted when a contract (order matched) is settled\n     * @param orderHash The EIP712 hash of the order\n     * @param tokenId The id of the token used to settle the contract\n     * @param order The order\n     */\n    event SettledContract(bytes32 orderHash, uint tokenId, Order order);\n\n    /**\n     * @notice Emitted when a contract (order matched) is reclaimed\n     * @param orderHash The EIP712 hash of the order\n     * @param order The order\n     */\n    event ReclaimedContract(bytes32 orderHash, Order order);\n\n    /**\n     * @notice Emitted when a token is withdrawn\n     * @param orderHash The EIP712 hash of the order\n     * @param tokenId The ID of the token withdrawn\n     * @param recipient The recipient of the token\n     */\n    event WithdrawnToken(bytes32 orderHash, uint tokenId, address recipient);\n\n    /**\n     * @notice Emitted when a position is sold\n     * @param sellOrderHash The EIP712 hash of the sell order\n     * @param sellOrder The sell order\n     * @param orderHash The EIP712 hash of the order\n     * @param order The order\n     * @param buyer The buyer of the position\n     */\n    event SoldPosition(bytes32 sellOrderHash, SellOrder sellOrder, bytes32 orderHash, Order order, address indexed buyer);\n\n    /**\n     * @notice Emitted when a position is transfered\n     * @param orderHash The EIP712 hash of the order\n     * @param isBull Is it the Bull position\n     * @param recipient The new owner of this position\n     */\n    event TransferedPosition(bytes32 orderHash, bool isBull, address recipient);\n\n    /**\n     * @notice Emitted when an order is canceled\n     * @param orderHash The EIP712 hash of the order canceled\n     * @param order The canceled order\n     */\n    event CanceledOrder(bytes32 orderHash, Order order);\n\n    /**\n     * @notice Emitted when a sell order is canceled\n     * @param sellOrderHash The EIP712 hash of the sell order canceled\n     * @param sellOrder The canceled sell order\n     */\n    event CanceledSellOrder(bytes32 sellOrderHash, SellOrder sellOrder);\n\n    /**\n     * @param _fee The initial fee\n     * @param _weth Address of WETH contract\n     */\n    constructor(uint16 _fee, address _weth) {\n        weth = payable(_weth);\n\n        setFee(_fee);\n    }\n\n    /*    USER METHODS    */\n\n    /**\n     * @notice Take the opposite side of an order and launch a contract between maker and taker\n     * @param order The order to match with\n     * @param signature The signature of the order hashed\n     * @return contractId The ID of the contract, defined by the order hash \n     */\n    function matchOrder(Order calldata order, bytes calldata signature) public payable nonReentrant returns (uint) {\n        bytes32 orderHash = hashOrder(order);\n\n        // ContractId\n        uint contractId = uint(orderHash);\n\n        // Check that this order is valid\n        checkIsValidOrder(order, orderHash, signature);\n\n        // Fees\n        uint bullFees;\n        uint bearFees;\n        if (fee > 0) {\n            bullFees = (order.collateral * fee) / 1000;\n            bearFees = (order.premium * fee) / 1000;\n\n            withdrawableFees[order.asset] += bullFees + bearFees;\n        }\n\n        address bull;\n        address bear;\n        uint makerPrice;\n        uint takerPrice;\n\n        if (order.isBull) {\n            bull = order.maker;\n            bear = msg.sender;\n\n            makerPrice = order.collateral + bullFees;\n            takerPrice = order.premium + bearFees;\n        } else {\n            bull = msg.sender;\n            bear = order.maker;\n\n            makerPrice = order.premium + bearFees;\n            takerPrice = order.collateral + bullFees;\n        }\n\n        bulls[contractId] = bull;\n        bears[contractId] = bear;\n\n        // Retrieve Taker payment\n        if (msg.value > 0) {\n            require(msg.value == takerPrice, \"INVALID_ETH_VALUE\");\n            require(order.asset == weth, \"INCOMPATIBLE_ASSET_ETH_VALUE\");\n\n            WETH(weth).deposit{value: msg.value}();\n        } else if(takerPrice > 0) {\n            IERC20(order.asset).safeTransferFrom(msg.sender, address(this), takerPrice);\n        }\n        // Retrieve Maker payment\n        if (makerPrice > 0) {\n            IERC20(order.asset).safeTransferFrom(order.maker, address(this), makerPrice);\n        }\n\n        // Store the order\n        matchedOrders[contractId] = order;\n\n        emit MatchedOrder(orderHash, bull, bear, order);\n\n        return contractId;\n    }\n\n    /**\n     * @notice Settle the contract by sending a NFT to the bull\n     * @param order The order used to launch the contract\n     * @param tokenId The token used to settle the contract\n     */\n    function settleContract(Order calldata order, uint tokenId) public nonReentrant {\n        bytes32 orderHash = hashOrder(order);\n\n        // ContractId\n        uint contractId = uint(orderHash);\n\n        address bear = bears[contractId];\n\n        // Check that only the bear can settle the contract\n        require(msg.sender == bear, \"ONLY_BEAR\");\n\n        // Check that the contract is not expired\n        require(block.timestamp < order.expiry, \"EXPIRED_CONTRACT\");\n\n        // Check that the contract is not already settled\n        require(!settledContracts[contractId], \"SETTLED_CONTRACT\");\n\n        address bull = bulls[contractId];\n\n        // Try to transfer the NFT to the bull (needed in case of a malicious bull that block transfers)\n        try IERC721(order.collection).safeTransferFrom(bear, bull, tokenId) {}\n        catch (bytes memory) {\n            // Transfer NFT to BvbProtocol\n            IERC721(order.collection).safeTransferFrom(bear, address(this), tokenId);\n            // Store that the bull has to retrieve it\n            withdrawableCollectionTokenId[order.collection][tokenId] = bull;\n        }\n\n        uint bearAssetAmount = order.premium + order.collateral;\n        if (bearAssetAmount > 0) {\n            // Transfer payment tokens to the Bear\n            IERC20(order.asset).safeTransfer(bear, bearAssetAmount);\n        }\n\n        settledContracts[contractId] = true;\n\n        emit SettledContract(orderHash, tokenId, order);\n    }\n\n    /**\n     * @notice Reclaim the contract after it expired without settlement\n     * @param order The order used to launch the contract\n     */\n    function reclaimContract(Order calldata order) public nonReentrant {\n        bytes32 orderHash = hashOrder(order);\n\n        // ContractId\n        uint contractId = uint(orderHash);\n\n        address bull = bulls[contractId];\n\n        // Check that the contract is expired\n        require(block.timestamp > order.expiry, \"NOT_EXPIRED_CONTRACT\");\n\n        // Check that the contract is not settled\n        require(!settledContracts[contractId], \"SETTLED_CONTRACT\");\n\n        // Check that the contract is not reclaimed\n        require(!reclaimedContracts[contractId], \"RECLAIMED_CONTRACT\");\n\n        uint bullAssetAmount = order.premium + order.collateral;\n        if (bullAssetAmount > 0) {\n            // Transfer payment tokens to the Bull\n            IERC20(order.asset).safeTransfer(bull, bullAssetAmount);\n        }\n\n        reclaimedContracts[contractId] = true;\n\n        emit ReclaimedContract(orderHash, order);\n    }\n\n    /**\n     * @notice Withdraw a NFT from BvbProtocol\n     * @param orderHash The EIP712 hash of the order\n     * @param tokenId The ID of the token to withdraw\n     */\n    function withdrawToken(bytes32 orderHash, uint tokenId) public {\n        address collection = matchedOrders[uint(orderHash)].collection;\n\n        address recipient = withdrawableCollectionTokenId[collection][tokenId];\n\n        // Transfer NFT to recipient\n        IERC721(collection).safeTransferFrom(address(this), recipient, tokenId);\n\n        // This token is not withdrawable anymore\n        withdrawableCollectionTokenId[collection][tokenId] = address(0);\n\n        emit WithdrawnToken(orderHash, tokenId, recipient);\n    }\n\n    /**\n     * @notice Buy a Contract position from the Bull or Bear\n     * @param sellOrder The sell order of the position\n     * @param signature The signature of the sell order hashed\n     * @return sellOrderId The ID of the sell order, defined by the order hash \n     */\n    function buyPosition(SellOrder calldata sellOrder, bytes calldata signature) public payable nonReentrant returns (uint) {\n        bytes32 orderHash = sellOrder.orderHash;\n\n        bytes32 sellOrderHash = hashSellOrder(sellOrder);\n\n        // ContractId\n        uint contractId = uint(orderHash);\n\n        // SellOrderId\n        uint sellOrderId = uint(sellOrderHash);\n\n        // Contract order\n        Order memory order = matchedOrders[contractId];\n\n        // Check that this sell order is valid\n        checkIsValidSellOrder(sellOrder, sellOrderHash, order, orderHash, signature);\n\n        // Check that the buyer is allowed to buy\n        require(sellOrder.whitelist.length == 0 || isWhitelisted(sellOrder.whitelist, msg.sender), \"INVALID_BUYER\");\n\n        if (msg.value > 0) {\n            // Buyer could send more ETH than asked\n            require(msg.value >= sellOrder.price, \"INVALID_ETH_VALUE\");\n            require(sellOrder.asset == weth, \"INCOMPATIBLE_ASSET_ETH_VALUE\");\n\n            WETH(weth).deposit{value: msg.value}();\n            IERC20(weth).safeTransfer(sellOrder.maker, msg.value);\n        } else if (sellOrder.price > 0) {\n            IERC20(sellOrder.asset).safeTransferFrom(msg.sender, sellOrder.maker, sellOrder.price);\n        }\n\n        if (sellOrder.isBull) {\n            bulls[contractId] = msg.sender;\n        } else {\n            bears[contractId] = msg.sender;\n        }\n\n        // Save the Sell Order\n        boughtSellOrders[sellOrderHash] = sellOrder;\n\n        emit SoldPosition(sellOrderHash, sellOrder, orderHash, order, msg.sender);\n\n        return sellOrderId;\n    }\n\n    /**\n     * @notice Transfer a contract position\n     * @param orderHash The EIP712 hash of the order\n     * @param isBull Is it the Bull or Bear position to transfer\n     * @param recipient The address of the new owner of the position\n     */\n    function transferPosition(bytes32 orderHash, bool isBull, address recipient) public {\n        // ContractId\n        uint contractId = uint(orderHash);\n\n        if (isBull) {\n            // Check that the msg.sender is the Bull\n            require(msg.sender == bulls[contractId], \"SENDER_NOT_BULL\");\n\n            bulls[contractId] = recipient;\n        } else {\n            // Check that the msg.sender is the Bear\n            require(msg.sender == bears[contractId], \"SENDER_NOT_BEAR\");\n\n            bears[contractId] = recipient;\n        }\n\n        emit TransferedPosition(orderHash, isBull, recipient);\n    }\n\n    /**\n     * @notice Method allowing to match several order in one call\n     * @param orders Orders to match with\n     * @param signatures Signatures of orders' hashes\n     * @return contractIds IDs of contracts, defined by the order hashes \n     */\n    function batchMatchOrders(Order[] calldata orders, bytes[] calldata signatures) external returns (uint[] memory) {\n        require(orders.length == signatures.length, \"INVALID_ORDERS_COUNT\");\n\n        uint[] memory contractIds = new uint[](orders.length);\n\n        for (uint i; i<orders.length; i++) {\n            contractIds[i] = matchOrder(orders[i], signatures[i]);\n        }\n\n        return contractIds;\n    }\n\n    /**\n     * @notice Method allowing to reclaim several contracts in one call\n     * @param orders Orders used to launch contracts to settle\n     * @param tokenIds Tokens used to settle contracts\n     */\n    function batchSettleContracts(Order[] calldata orders, uint[] calldata tokenIds) external {\n        require(orders.length == tokenIds.length, \"INVALID_ORDERS_COUNT\");\n\n        for (uint i; i<orders.length; i++) {\n            settleContract(orders[i], tokenIds[i]);\n        }\n    }\n\n    /**\n     * @notice Method allowing to reclaim several contracts in one call\n     * @param orders Orders used to launch contracts to reclaim\n     */\n    function batchReclaimContracts(Order[] calldata orders) external {\n        for (uint i; i<orders.length; i++) {\n            reclaimContract(orders[i]);\n        }\n    }\n\n    /**\n     * @notice Cancel an order\n     * @param order The order to cancel\n     */\n    function cancelOrder(Order memory order) external {\n        require(order.maker == msg.sender, \"NOT_SIGNER\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        require(!canceledOrders[orderHash], \"ALREADY_CANCELED\");\n\n        require(matchedOrders[uint(orderHash)].maker == address(0), \"ORDER_MATCHED\");\n\n        canceledOrders[orderHash] = true;\n\n        emit CanceledOrder(orderHash, order);\n    }\n\n    /**\n     * @notice Cancel a sell order\n     * @param sellOrder The sell order to cancel\n     */\n    function cancelSellOrder(SellOrder memory sellOrder) external {\n        require(sellOrder.maker == msg.sender, \"NOT_SIGNER\");\n\n        bytes32 sellOrderHash = hashSellOrder(sellOrder);\n\n        require(!canceledSellOrders[sellOrderHash], \"ALREADY_CANCELED\");\n\n        require(boughtSellOrders[sellOrderHash].maker == address(0), \"POSITION_SOLD\");\n\n        canceledSellOrders[sellOrderHash] = true;\n\n        emit CanceledSellOrder(sellOrderHash, sellOrder);\n    }\n\n    /**\n     * @notice Sets a new minimal valid nonce\n     * @param _minimumValidNonce The new minimal valid nonce\n     */\n    function setMinimumValidNonce(uint _minimumValidNonce) external {\n        require(_minimumValidNonce > minimumValidNonce[msg.sender], \"NONCE_TOO_LOW\");\n\n        minimumValidNonce[msg.sender] = _minimumValidNonce;\n\n        emit UpdatedMinimumValidNonce(msg.sender, _minimumValidNonce);\n    }\n\n    /**\n     * @notice Sets a new sell minimal valid nonce\n     * @param _minimumValidNonceSell The new sell minimal valid nonce\n     */\n    function setMinimumValidNonceSell(uint _minimumValidNonceSell) external {\n        require(_minimumValidNonceSell > minimumValidNonceSell[msg.sender], \"NONCE_TOO_LOW\");\n\n        minimumValidNonceSell[msg.sender] = _minimumValidNonceSell;\n\n        emit UpdatedMinimumValidNonceSell(msg.sender, _minimumValidNonceSell);\n    }\n\n    /*    EIP712    */\n\n    /**\n     * @notice Hashes an order according to EIP712\n     * @param order The order to hash\n     * @return The EIP712 hash of the order\n     */\n    function hashOrder(Order memory order) public view returns (bytes32) {\n        bytes32 orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.premium,\n                order.collateral,\n                order.validity,\n                order.expiry,\n                order.nonce,\n                order.fee,\n                order.maker,\n                order.asset,\n                order.collection,\n                order.isBull\n            )\n        );\n\n        return _hashTypedDataV4(orderHash);\n    }\n\n    /**\n     * @notice Hashes a sell order according to EIP712\n     * @param sellOrder The sell order to hash\n     * @return The EIP712 hash of the sell order\n     */\n    function hashSellOrder(SellOrder memory sellOrder) public view returns (bytes32) {\n        bytes32 sellOrderHash = keccak256(\n            abi.encode(\n                SELL_ORDER_TYPE_HASH,\n                sellOrder.orderHash,\n                sellOrder.price,\n                sellOrder.start,\n                sellOrder.end,\n                sellOrder.nonce,\n                sellOrder.maker,\n                sellOrder.asset,\n                keccak256(abi.encodePacked(sellOrder.whitelist)),\n                sellOrder.isBull\n            )\n        );\n\n        return _hashTypedDataV4(sellOrderHash);\n    }\n\n    /**\n     * @notice Checks if a signature is valid for a given signer and an order hash\n     * @param signer The address used to sign\n     * @param orderHash The EIP712 hash of the order\n     * @param signature The signature of the order hash\n     * @return true if the signature was made by the signer\n     */\n    function isValidSignature(address signer, bytes32 orderHash, bytes calldata signature) public pure returns (bool) {\n        return ECDSA.recover(orderHash, signature) == signer;\n    }\n\n    /**\n     * @notice Return the domain separator of this contract used to calculte EIP712 order hash\n     * @return The domain separator\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /*    HELPERS METHODS    */\n\n    /**\n     * @notice Checks if a buyer is whitelisted\n     * @param whitelist The array of whitelisted address\n     * @param buyer The buyer address\n     * @return If the buyer is in the whitelist or not\n     */\n    function isWhitelisted(address[] memory whitelist, address buyer) public pure returns (bool) {\n        for (uint i; i<whitelist.length; i++) {\n            if (buyer == whitelist[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Checks if an order is valid\n     * @param order The order/contract\n     * @param orderHash The EIP712 hash of the order\n     * @param signature The signature of the order hashed\n     */\n    function checkIsValidOrder(Order calldata order, bytes32 orderHash, bytes calldata signature) public view {\n        // Check that the signature is valid\n        require(isValidSignature(order.maker, orderHash, signature), \"INVALID_SIGNATURE\");\n\n        // Check that this order is still valid\n        require(order.validity > block.timestamp, \"EXPIRED_VALIDITY_TIME\");\n\n        // Check that this order was not canceled\n        require(!canceledOrders[orderHash], \"ORDER_CANCELED\");\n\n        // Check that the nonce is valid\n        require(order.nonce >= minimumValidNonce[order.maker], \"INVALID_NONCE\");\n        \n        // Check that this contract will expire in the future\n        require(order.expiry > order.validity, \"INVALID_EXPIRY_TIME\");\n\n        // Check that fees match\n        require(order.fee >= fee, \"INVALID_FEE\");\n\n        // Check that this is an approved ERC20 token\n        require(allowedAsset[order.asset], \"INVALID_ASSET\");\n\n        // Check that this if an approved ERC721 collection\n        require(allowedCollection[order.collection], \"INVALID_COLLECTION\");\n\n        // Check that there is no bull set for this order -> not matched\n        require(bulls[uint(orderHash)] == address(0), \"ORDER_ALREADY_MATCHED\");\n    }\n\n    /**\n     * @notice Checks if a sell order is valid\n     * @param sellOrder The sell order of the position\n     * @param sellOrderHash The EIP712 hash of the sell order\n     * @param order The order/contract\n     * @param orderHash The EIP712 hash of the order\n     * @param signature The signature of the sell order hashed\n     */\n    function checkIsValidSellOrder(SellOrder calldata sellOrder, bytes32 sellOrderHash, Order memory order, bytes32 orderHash, bytes calldata signature) public view {\n        // ContractId\n        uint contractId = uint(orderHash);\n        \n        // Check that the signature is valid\n        require(isValidSignature(sellOrder.maker, sellOrderHash, signature), \"INVALID_SIGNATURE\");\n\n        if (sellOrder.isBull) {\n            // Check that the maker is the Bull\n            require(sellOrder.maker == bulls[contractId], \"MAKER_NOT_BULL\");\n\n            // Check that the contract is not reclaimed\n            require(!reclaimedContracts[contractId], \"RECLAIMED_CONTRACT\");\n        } else {\n            // Check that the maker is the Bear\n            require(sellOrder.maker == bears[contractId], \"MAKER_NOT_BEAR\");\n\n            // Check that the contract hasn't expired\n            require(block.timestamp < order.expiry, \"CONTRACT_EXPIRED\");\n        }\n\n        // Check that there is no maker set for this sell order -> not bought\n        require(boughtSellOrders[sellOrderHash].maker == address(0), \"SELL_ORDER_ALREADY_BOUGHT\");\n\n        // Check that this order was not canceled\n        require(!canceledSellOrders[sellOrderHash], \"SELL_ORDER_CANCELED\");\n\n        // Check that this sell order has started\n        require(block.timestamp >= sellOrder.start, \"INVALID_START_TIME\");\n\n        // Check that the sell order hasn't expired\n        require(block.timestamp <= sellOrder.end, \"SELL_ORDER_EXPIRED\");\n\n        // Check that the contract is not settled\n        require(!settledContracts[contractId], \"SETTLED_CONTRACT\");\n        \n        // Check that the nonce is valid\n        require(sellOrder.nonce >= minimumValidNonceSell[sellOrder.maker], \"INVALID_NONCE\");\n\n        // Check that this is an approved ERC20 token\n        require(allowedAsset[sellOrder.asset], \"INVALID_ASSET\");\n    }\n\n    /*    OWNER METHODS    */\n\n    /**\n     * @notice Sets the collection as supported or not by the protocol\n     * @param collection The collection\n     * @param allowed Is the collection supported or not\n     */\n    function setAllowedCollection(address collection, bool allowed) public onlyOwner {\n        allowedCollection[collection] = allowed;\n\n        emit AllowCollection(collection, allowed);\n    }\n\n    /**\n     * @notice Sets the asset as supported as payment or not by the protocol\n     * @param asset The collection\n     * @param allowed Is the collection supported or not\n     */\n    function setAllowedAsset(address asset, bool allowed) public onlyOwner {\n        allowedAsset[asset] = allowed;\n\n        emit AllowAsset(asset, allowed);\n    }\n\n    /**\n     * @notice Sets a new fee rate\n     * @param _fee The new fee rate\n     */\n    function setFee(uint16 _fee) public onlyOwner {\n        // Fee rate can't be greater than 5%\n        require(_fee <= 50, \"INVALID_FEE_RATE\");\n\n        fee = _fee;\n\n        emit UpdatedFee(_fee);\n    }\n\n    /**\n     * @notice Withdraw fees\n     * @param asset The ERC20 asset address\n     * @param recipient The recipient of the fees\n     */\n    function withdrawFees(address asset, address recipient) external onlyOwner {\n        uint amount = withdrawableFees[asset];\n\n        withdrawableFees[asset] = 0;\n\n        IERC20(asset).safeTransfer(recipient, amount);\n\n        emit WithdrawnFees(asset, amount);\n    }\n}"
    }
  ]
}