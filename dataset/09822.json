{
  "Title": "[L-05] FiatTokenV2: `whitelist()` should be unusable if contract is paused",
  "Content": "\n### Line References\n\n<https://github.com/code-423n4/2022-02-jpyc/blob/main/contracts/v2/FiatTokenV2.sol#L645>\n\n### Description\n\nShould the contract be paused, it would be safer to prevent additional addresses from being whitelisted.\n\n### Recommended Mitigation Steps\n\nAdd the `whenNotPaused` modifier for the `whitelist()` function.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-02-jpyc-contest",
  "Code": [
    {
      "filename": "contracts/v2/FiatTokenV2.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npragma solidity 0.8.11;\n\nimport \"../v1/Ownable.sol\";\nimport \"../v1/Pausable.sol\";\nimport \"../v1/Blocklistable.sol\";\nimport \"../util/EIP712.sol\";\nimport \"../v1/Rescuable.sol\";\nimport \"../v1/EIP3009.sol\";\nimport \"../v1/EIP2612.sol\";\nimport \"../upgradeability/UUPSUpgradeable.sol\";\n\n/**\n * @title FiatToken\n * @dev ERC20 Token backed by fiat reserves\n */\ncontract FiatTokenV2 is\n    Ownable,\n    Pausable,\n    Blocklistable,\n    Rescuable,\n    EIP3009,\n    EIP2612,\n    UUPSUpgradeable\n{\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    string public currency;\n    address public masterMinter;\n    bool internal initialized;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    uint256 internal totalSupply_ = 0;\n    mapping(address => bool) internal minters;\n    mapping(address => uint256) internal minterAllowed;\n    // whitelist test\n    mapping(address => bool) internal whitelisted;\n    address public whitelister;\n\n    event Mint(address indexed minter, address indexed to, uint256 amount);\n    event Burn(address indexed burner, uint256 amount);\n    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);\n    event MinterRemoved(address indexed oldMinter);\n    event MasterMinterChanged(address indexed newMasterMinter);\n    event Whitelisted(address indexed _account);\n    event UnWhitelisted(address indexed _account);\n    event WhitelisterChanged(address indexed newWhitelister);\n\n    function initialize(\n        string memory tokenName,\n        string memory tokenSymbol,\n        string memory tokenCurrency,\n        uint8 tokenDecimals,\n        address newMasterMinter,\n        address newPauser,\n        address newBlocklister,\n        address newOwner\n    ) public {\n        require(!initialized, \"FiatToken: contract is already initialized\");\n        require(\n            newMasterMinter != address(0),\n            \"FiatToken: new masterMinter is the zero address\"\n        );\n        require(\n            newPauser != address(0),\n            \"FiatToken: new pauser is the zero address\"\n        );\n        require(\n            newBlocklister != address(0),\n            \"FiatToken: new blocklister is the zero address\"\n        );\n        require(\n            newOwner != address(0),\n            \"FiatToken: new owner is the zero address\"\n        );\n\n        name = tokenName;\n        symbol = tokenSymbol;\n        currency = tokenCurrency;\n        decimals = tokenDecimals;\n        masterMinter = newMasterMinter;\n        pauser = newPauser;\n        blocklister = newBlocklister;\n        _transferOwnership(newOwner);\n        blocklisted[address(this)] = true;\n        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(name, \"1\");\n        CHAIN_ID = block.chainid;\n        NAME = name;\n        VERSION = \"1\";\n        initialized = true;\n    }\n    \n    /**\n     * @dev Throws if called by any account other than a minter\n     */\n    modifier onlyMinters() {\n        require(minters[msg.sender], \"FiatToken: caller is not a minter\");\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of the caller.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        whenNotPaused\n        onlyMinters\n        notBlocklisted(msg.sender)\n        notBlocklisted(_to)\n        checkWhitelist(msg.sender, _amount)\n        returns (bool)\n    {\n        require(_to != address(0), \"FiatToken: mint to the zero address\");\n        require(_amount > 0, \"FiatToken: mint amount not greater than 0\");\n\n        uint256 mintingAllowedAmount = minterAllowed[msg.sender];\n        require(\n            _amount <= mintingAllowedAmount,\n            \"FiatToken: mint amount exceeds minterAllowance\"\n        );\n\n        totalSupply_ = totalSupply_ + _amount;\n        balances[_to] = balances[_to] + _amount;\n        minterAllowed[msg.sender] = mintingAllowedAmount - _amount;\n        emit Mint(msg.sender, _to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the masterMinter\n     */\n    modifier onlyMasterMinter() {\n        require(\n            msg.sender == masterMinter,\n            \"FiatToken: caller is not the masterMinter\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Get minter allowance for an account\n     * @param minter The address of the minter\n     */\n    function minterAllowance(address minter) external view returns (uint256) {\n        return minterAllowed[minter];\n    }\n\n    /**\n     * @dev Checks if account is a minter\n     * @param account The address to check\n     */\n    function isMinter(address account) external view returns (bool) {\n        return minters[account];\n    }\n\n    /**\n     * @notice Amount of remaining tokens spender is allowed to transfer on\n     * behalf of the token owner\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @return Allowance amount\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return allowed[owner][spender];\n    }\n\n    /**\n     * @dev Get totalSupply of token\n     */\n    function totalSupply() external view override returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Get token balance of an account\n     * @param account address The account\n     */\n    function balanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balances[account];\n    }\n\n    /**\n     * @notice Set spender's allowance over the caller's tokens to be a given\n     * value.\n     * @param spender   Spender's address\n     * @param value     Allowance amount\n     * @return True if successful\n     */\n    function approve(address spender, uint256 value)\n        external\n        override\n        whenNotPaused\n        notBlocklisted(msg.sender)\n        notBlocklisted(spender)\n        checkWhitelist(msg.sender, value)\n        returns (bool)\n    {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Internal function to set allowance\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param value     Allowance amount\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal override {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @notice Transfer tokens by spending allowance\n     * @param from  Payer's address\n     * @param to    Payee's address\n     * @param value Transfer amount\n     * @return True if successful\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        override\n        whenNotPaused\n        notBlocklisted(msg.sender)\n        notBlocklisted(from)\n        notBlocklisted(to)\n        checkWhitelist(from, value)\n        returns (bool)\n    {\n        require(\n            value <= allowed[from][msg.sender],\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        _transfer(from, to, value);\n        allowed[from][msg.sender] = allowed[from][msg.sender] - value;\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from the caller\n     * @param to    Payee's address\n     * @param value Transfer amount\n     * @return True if successful\n     */\n    function transfer(address to, uint256 value)\n        external\n        override\n        whenNotPaused\n        notBlocklisted(msg.sender)\n        notBlocklisted(to)\n        checkWhitelist(msg.sender, value)\n        returns (bool)\n    {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @notice Internal function to process transfers\n     * @param from  Payer's address\n     * @param to    Payee's address\n     * @param value Transfer amount\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(\n            value <= balances[from],\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        balances[from] = balances[from] - value;\n        balances[to] = balances[to] + value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Function to add/update a new minter\n     * @param minter The address of the minter\n     * @param minterAllowedAmount The minting amount allowed for the minter\n     * @return True if the operation was successful.\n     */\n    function configureMinter(address minter, uint256 minterAllowedAmount)\n        external\n        whenNotPaused\n        onlyMasterMinter\n        returns (bool)\n    {\n        minters[minter] = true;\n        minterAllowed[minter] = minterAllowedAmount;\n        emit MinterConfigured(minter, minterAllowedAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function to remove a minter\n     * @param minter The address of the minter to remove\n     * @return True if the operation was successful.\n     */\n    function removeMinter(address minter)\n        external\n        onlyMasterMinter\n        returns (bool)\n    {\n        minters[minter] = false;\n        minterAllowed[minter] = 0;\n        emit MinterRemoved(minter);\n        return true;\n    }\n\n    /**\n     * @dev allows a minter to burn some of its own tokens\n     * Validates that caller is a minter and that sender is not blocklisted\n     * amount is less than or equal to the minter's account balance\n     * @param _amount uint256 the amount of tokens to be burned\n     */\n    function burn(uint256 _amount)\n        external\n        whenNotPaused\n        onlyMinters\n        notBlocklisted(msg.sender)\n    {\n        uint256 balance = balances[msg.sender];\n        require(_amount > 0, \"FiatToken: burn amount not greater than 0\");\n        require(balance >= _amount, \"FiatToken: burn amount exceeds balance\");\n\n        totalSupply_ = totalSupply_ - _amount;\n        balances[msg.sender] = balance - _amount;\n        emit Burn(msg.sender, _amount);\n        emit Transfer(msg.sender, address(0), _amount);\n    }\n\n    function updateMasterMinter(address _newMasterMinter) external onlyOwner {\n        require(\n            _newMasterMinter != address(0),\n            \"FiatToken: new masterMinter is the zero address\"\n        );\n        masterMinter = _newMasterMinter;\n        emit MasterMinterChanged(masterMinter);\n    }\n\n    /**\n     * @notice Increase the allowance by a given increment\n     * @param spender   Spender's address\n     * @param increment Amount of increase in allowance\n     * @return True if successful\n     */\n    function increaseAllowance(address spender, uint256 increment)\n        external\n        whenNotPaused\n        notBlocklisted(msg.sender)\n        notBlocklisted(spender)\n        checkWhitelist(msg.sender, allowed[msg.sender][spender] + increment)\n        returns (bool)\n    {\n        _increaseAllowance(msg.sender, spender, increment);\n        return true;\n    }\n\n    /**\n     * @notice Decrease the allowance by a given decrement\n     * @param spender   Spender's address\n     * @param decrement Amount of decrease in allowance\n     * @return True if successful\n     */\n    function decreaseAllowance(address spender, uint256 decrement)\n        external\n        whenNotPaused\n        notBlocklisted(msg.sender)\n        notBlocklisted(spender)\n        returns (bool)\n    {\n        _decreaseAllowance(msg.sender, spender, decrement);\n        return true;\n    }\n\n    /**\n     * @notice Internal function to increase the allowance by a given increment\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param increment Amount of increase\n     */\n    function _increaseAllowance(\n        address owner,\n        address spender,\n        uint256 increment\n    ) internal override {\n        _approve(owner, spender, allowed[owner][spender] + increment);\n    }\n\n    /**\n     * @notice Internal function to decrease the allowance by a given decrement\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param decrement Amount of decrease\n     */\n    function _decreaseAllowance(\n        address owner,\n        address spender,\n        uint256 decrement\n    ) internal override {\n        require(\n            decrement <= allowed[owner][spender],\n            \"ERC20: decreased allowance below zero\"\n        );\n        _approve(owner, spender, allowed[owner][spender] - decrement);\n    }\n\n    /**\n     * @notice Execute a transfer with a signed authorization\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n        whenNotPaused\n        notBlocklisted(from)\n        notBlocklisted(to)\n        checkWhitelist(from, value)\n    {\n        _transferWithAuthorization(\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    }\n\n    /**\n     * @notice Receive a transfer with a signed authorization from the payer\n     * @dev This has an additional check to ensure that the payee's address\n     * matches the caller of this function to prevent front-running attacks.\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function receiveWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n        whenNotPaused\n        notBlocklisted(from)\n        notBlocklisted(to)\n        checkWhitelist(from, value)\n    {\n        _receiveWithAuthorization(\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    }\n\n    /**\n     * @notice Attempt to cancel an authorization\n     * @dev Works only if the authorization is not yet used.\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function cancelAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused {\n        _cancelAuthorization(authorizer, nonce, v, r, s);\n    }\n\n    /**\n     * @notice Update allowance with a signed permit\n     * @param owner       Token owner's address (Authorizer)\n     * @param spender     Spender's address\n     * @param value       Amount of allowance\n     * @param deadline    Expiration time, seconds since the epoch\n     * @param v           v of the signature\n     * @param r           r of the signature\n     * @param s           s of the signature\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n        whenNotPaused\n        notBlocklisted(owner)\n        notBlocklisted(spender)\n        checkWhitelist(owner, value)\n    {\n        _permit(owner, spender, value, deadline, v, r, s);\n    }\n\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwner\n    {}\n\n    /**\n     * @title Whitelistable Token\n     * @dev Allows accounts to be whitelisted by a \"whitelister\" role\n     */\n\n    /**\n     * @dev Throws if called by any account other than the whitelister\n     */\n    modifier onlyWhitelister() {\n        require(\n            msg.sender == whitelister,\n            \"Whitelistable: caller is not the whitelister\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if argument account is not whitelilsted and want to send over 100000\n     * @param _account The address to check\n     * @param _value The amount of token to check\n     */\n    modifier checkWhitelist(address _account, uint256 _value) {\n        if (_value > 100000 * 10 ** 18) {\n            require(\n                whitelisted[_account],\n                \"Whitelistable: account is not whitelisted\"\n            );\n        }\n        _;\n    }\n\n    /**\n     * @dev Checks if account is whitelisted\n     * @param _account The address to check\n     */\n    function isWhitelisted(address _account) external view returns (bool) {\n        return whitelisted[_account];\n    }\n\n    /**\n     * @dev Adds account to whitelist\n     * @param _account The address to whitelist\n     */\n    function whitelist(address _account) external onlyWhitelister {\n        whitelisted[_account] = true;\n        emit Whitelisted(_account);\n    }\n\n    /**\n     * @dev Removes account from whitelist\n     * @param _account The address to remove from the whitelist\n     */\n    function unWhitelist(address _account) external onlyWhitelister {\n        whitelisted[_account] = false;\n        emit UnWhitelisted(_account);\n    }\n\n    function updateWhitelister(address _newWhitelister) external onlyOwner {\n        require(\n            _newWhitelister != address(0),\n            \"Whitelistable: new whitelister is the zero address\"\n        );\n        whitelister = _newWhitelister;\n        emit WhitelisterChanged(whitelister);\n    }\n\n    uint256[50] private __gap;\n}"
    }
  ]
}