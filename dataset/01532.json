{
  "Title": "Misleading Comments",
  "Content": "The following misleading comments were identified:\n\n\n* The [comment](https://github.com/mantlenetworkio/mantle-token-contracts/blob/b2016dfb932d85b8b33a9294e8280aa04ca46975/contracts/L1/L1MantleToken.sol#L117) describing the `setMintCapNumerator` references a `MintCapNumeratorSet` event, but it should be `MintCapNumeratorChanged`.\n* The [comment](https://github.com/mantlenetworkio/mantle-token-contracts/blob/b2016dfb932d85b8b33a9294e8280aa04ca46975/contracts/L1/L1MantleToken.sol#L100) describing the `mint` function says the mint time interval \"is initially set to 1 year\", which suggests it could be updated. It is actually a [constant](https://github.com/mantlenetworkio/mantle-token-contracts/blob/b2016dfb932d85b8b33a9294e8280aa04ca46975/contracts/L1/L1MantleToken.sol#LL28C30-L28C30) and can only be changed if the whole contract is upgraded.\n\n\nConsider updating the comments accordingly.\n\n\n***Update:** Resolved in [pull request #50](https://github.com/mantlenetworkio/mantle-token-contracts/pull/50) at commit [2a04393](https://github.com/mantlenetworkio/mantle-token-contracts/pull/50/commits/2a043939a748f91c0d29213b7f0a73a7a6a2c724).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/L1/L1MantleToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/// @title L1MantleToken\n/// @author 0xMantle\n/// @notice ERC20 token with minting, burning, and governance functionality\ncontract L1MantleToken is\n    Initializable,\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    OwnableUpgradeable,\n    ERC20PermitUpgradeable,\n    ERC20VotesUpgradeable\n{\n    /* ========== STATE VARIABLES ========== */\n\n    string private constant NAME = \"Mantle\";\n    string private constant SYMBOL = \"MNT\";\n\n    /// @dev The minimum amount of time that must elapse before a mint is allowed\n    uint256 public constant MIN_MINT_INTERVAL = 365 days;\n\n    /// @dev The denominator of the maximum fractional amount that can be minted\n    uint256 public constant MINT_CAP_DENOMINATOR = 10_000;\n\n    /// @dev The numerator of the maximum fractional amount that can be minted\n    uint256 public constant MINT_CAP_MAX_NUMERATOR = 200;\n\n    /// @dev The current numerator of the fractional amount that can be minted\n    uint256 public mintCapNumerator;\n\n    /// @dev The blockTimeStamp at which mint will be able to be called again\n    uint256 public nextMint;\n\n    /* ========== EVENTS ========== */\n\n    /// @dev Emitted when the mintCapNumerator is set\n    /// @param from The address which changed the mintCapNumerator\n    /// @param previousMintCapNumerator The previous mintCapNumerator\n    /// @param newMintCapNumerator The new mintCapNumerator\n    event MintCapNumeratorChanged(\n        address indexed from, uint256 previousMintCapNumerator, uint256 newMintCapNumerator\n    );\n\n    /* ========== ERRORS ========== */\n\n    /// @notice Thrown when at least one of the inputs passed into the constructor is a zero value\n    error MantleToken_ImproperlyInitialized();\n\n    /// @notice Thrown when mint is called before the nextMint timestamp has passed\n    error MantleToken_NextMintTimestampNotElapsed(uint256 currentTimestamp, uint256 nextMintTimestamp);\n\n    /// @notice Thrown when mint is called with a value greater than the maximum allowed\n    error MantleToken_MintAmountTooLarge(uint256 amount, uint256 maximumAmount);\n\n    /// @notice Thrown when the mintCapNumerator is set to a value greater than the maximum allowed\n    error MantleToken_MintCapNumeratorTooLarge(uint256 numerator, uint256 maximumNumerator);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    /// @notice Initializes the L1MantleToken contract, setting the inital total supply as {initialSupply} and the owner as {_owner}\n    /// @dev the mintCapNumerator should not be set as it is initialized as 0\n    /// @dev Requirements:\n    ///     - all parameters must be non-zero\n    /// @param _initialSupply The initial total supply of the token\n    /// @param _owner The owner of the token\n\n    function initialize(uint256 _initialSupply, address _owner) public initializer {\n        if (_initialSupply == 0 || _owner == address(0)) revert MantleToken_ImproperlyInitialized();\n\n        __ERC20_init(NAME, SYMBOL);\n        __ERC20Burnable_init();\n        __Ownable_init();\n        __ERC20Permit_init(NAME);\n        __ERC20Votes_init();\n\n        _mint(_owner, _initialSupply);\n        nextMint = block.timestamp + MIN_MINT_INTERVAL;\n\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Allows the owner to mint new tokens and increase this token's total supply\n    /// @dev Requirements:\n    ///     - Only allows minting below an inflation cap at a specified time interval\n    ///         - The max mint amount is computed as follows:\n    ///             - maxMintAmount = (mintCapNumerator * totalSupply()) / MINT_CAP_DENOMINATOR\n    ///              - The specified time interval at which mints can occur is initially set to 1 year\n    ///     - the parameter {amount} must be less than or equal to {maxMintAmount} as computed above\n    ///     - the {blockTimestamp} of the block in which this function is called must be greater than or equal to {nextMint}\n    /// @param _recipient The address to mint tokens to\n    /// @param _amount The amount of tokens to mint\n    function mint(address _recipient, uint256 _amount) public onlyOwner {\n        uint256 maximumMintAmount = (totalSupply() * mintCapNumerator) / MINT_CAP_DENOMINATOR;\n        if (_amount > maximumMintAmount) {\n            revert MantleToken_MintAmountTooLarge(_amount, maximumMintAmount);\n        }\n        if (block.timestamp < nextMint) revert MantleToken_NextMintTimestampNotElapsed(block.timestamp, nextMint);\n\n        nextMint = block.timestamp + MIN_MINT_INTERVAL;\n        _mint(_recipient, _amount);\n    }\n\n    /// @notice Allows the owner to set the mintCapNumerator\n    /// @dev emits a {MintCapNumeratorSet} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    ///     - parameter {_mintCapNumerator} must be less than or equal to {MINT_CAP_MAX_NUMERATOR}\n    function setMintCapNumerator(uint256 _mintCapNumerator) public onlyOwner {\n        if (_mintCapNumerator > MINT_CAP_MAX_NUMERATOR) {\n            revert MantleToken_MintCapNumeratorTooLarge(_mintCapNumerator, MINT_CAP_MAX_NUMERATOR);\n        }\n\n        uint256 previousMintCapNumerator = mintCapNumerator;\n        mintCapNumerator = _mintCapNumerator;\n\n        emit MintCapNumeratorChanged(msg.sender, previousMintCapNumerator, mintCapNumerator);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    /// @inheritdoc ERC20Upgradeable\n    function _afterTokenTransfer(address from, address to, uint256 amount)\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function _mint(address to, uint256 amount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._mint(to, amount);\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function _burn(address account, uint256 amount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._burn(account, amount);\n    }\n}"
    },
    {
      "filename": "contracts/L1/L1MantleToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/// @title L1MantleToken\n/// @author 0xMantle\n/// @notice ERC20 token with minting, burning, and governance functionality\ncontract L1MantleToken is\n    Initializable,\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    OwnableUpgradeable,\n    ERC20PermitUpgradeable,\n    ERC20VotesUpgradeable\n{\n    /* ========== STATE VARIABLES ========== */\n\n    string private constant NAME = \"Mantle\";\n    string private constant SYMBOL = \"MNT\";\n\n    /// @dev The minimum amount of time that must elapse before a mint is allowed\n    uint256 public constant MIN_MINT_INTERVAL = 365 days;\n\n    /// @dev The denominator of the maximum fractional amount that can be minted\n    uint256 public constant MINT_CAP_DENOMINATOR = 10_000;\n\n    /// @dev The numerator of the maximum fractional amount that can be minted\n    uint256 public constant MINT_CAP_MAX_NUMERATOR = 200;\n\n    /// @dev The current numerator of the fractional amount that can be minted\n    uint256 public mintCapNumerator;\n\n    /// @dev The blockTimeStamp at which mint will be able to be called again\n    uint256 public nextMint;\n\n    /* ========== EVENTS ========== */\n\n    /// @dev Emitted when the mintCapNumerator is set\n    /// @param from The address which changed the mintCapNumerator\n    /// @param previousMintCapNumerator The previous mintCapNumerator\n    /// @param newMintCapNumerator The new mintCapNumerator\n    event MintCapNumeratorChanged(\n        address indexed from, uint256 previousMintCapNumerator, uint256 newMintCapNumerator\n    );\n\n    /* ========== ERRORS ========== */\n\n    /// @notice Thrown when at least one of the inputs passed into the constructor is a zero value\n    error MantleToken_ImproperlyInitialized();\n\n    /// @notice Thrown when mint is called before the nextMint timestamp has passed\n    error MantleToken_NextMintTimestampNotElapsed(uint256 currentTimestamp, uint256 nextMintTimestamp);\n\n    /// @notice Thrown when mint is called with a value greater than the maximum allowed\n    error MantleToken_MintAmountTooLarge(uint256 amount, uint256 maximumAmount);\n\n    /// @notice Thrown when the mintCapNumerator is set to a value greater than the maximum allowed\n    error MantleToken_MintCapNumeratorTooLarge(uint256 numerator, uint256 maximumNumerator);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    /// @notice Initializes the L1MantleToken contract, setting the inital total supply as {initialSupply} and the owner as {_owner}\n    /// @dev the mintCapNumerator should not be set as it is initialized as 0\n    /// @dev Requirements:\n    ///     - all parameters must be non-zero\n    /// @param _initialSupply The initial total supply of the token\n    /// @param _owner The owner of the token\n\n    function initialize(uint256 _initialSupply, address _owner) public initializer {\n        if (_initialSupply == 0 || _owner == address(0)) revert MantleToken_ImproperlyInitialized();\n\n        __ERC20_init(NAME, SYMBOL);\n        __ERC20Burnable_init();\n        __Ownable_init();\n        __ERC20Permit_init(NAME);\n        __ERC20Votes_init();\n\n        _mint(_owner, _initialSupply);\n        nextMint = block.timestamp + MIN_MINT_INTERVAL;\n\n        _transferOwnership(_owner);\n    }\n\n    /// @notice Allows the owner to mint new tokens and increase this token's total supply\n    /// @dev Requirements:\n    ///     - Only allows minting below an inflation cap at a specified time interval\n    ///         - The max mint amount is computed as follows:\n    ///             - maxMintAmount = (mintCapNumerator * totalSupply()) / MINT_CAP_DENOMINATOR\n    ///              - The specified time interval at which mints can occur is initially set to 1 year\n    ///     - the parameter {amount} must be less than or equal to {maxMintAmount} as computed above\n    ///     - the {blockTimestamp} of the block in which this function is called must be greater than or equal to {nextMint}\n    /// @param _recipient The address to mint tokens to\n    /// @param _amount The amount of tokens to mint\n    function mint(address _recipient, uint256 _amount) public onlyOwner {\n        uint256 maximumMintAmount = (totalSupply() * mintCapNumerator) / MINT_CAP_DENOMINATOR;\n        if (_amount > maximumMintAmount) {\n            revert MantleToken_MintAmountTooLarge(_amount, maximumMintAmount);\n        }\n        if (block.timestamp < nextMint) revert MantleToken_NextMintTimestampNotElapsed(block.timestamp, nextMint);\n\n        nextMint = block.timestamp + MIN_MINT_INTERVAL;\n        _mint(_recipient, _amount);\n    }\n\n    /// @notice Allows the owner to set the mintCapNumerator\n    /// @dev emits a {MintCapNumeratorSet} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    ///     - parameter {_mintCapNumerator} must be less than or equal to {MINT_CAP_MAX_NUMERATOR}\n    function setMintCapNumerator(uint256 _mintCapNumerator) public onlyOwner {\n        if (_mintCapNumerator > MINT_CAP_MAX_NUMERATOR) {\n            revert MantleToken_MintCapNumeratorTooLarge(_mintCapNumerator, MINT_CAP_MAX_NUMERATOR);\n        }\n\n        uint256 previousMintCapNumerator = mintCapNumerator;\n        mintCapNumerator = _mintCapNumerator;\n\n        emit MintCapNumeratorChanged(msg.sender, previousMintCapNumerator, mintCapNumerator);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    /// @inheritdoc ERC20Upgradeable\n    function _afterTokenTransfer(address from, address to, uint256 amount)\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function _mint(address to, uint256 amount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._mint(to, amount);\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function _burn(address account, uint256 amount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._burn(account, amount);\n    }\n}"
    }
  ]
}