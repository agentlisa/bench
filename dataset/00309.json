{
  "Title": "M-1: When vault's market weight is set to 0 to remove the market from the vault, vault's leverage in this market is immediately set to max leverage risking position liquidation",
  "Content": "# Issue M-1: When vault's market weight is set to 0 to remove the market from the vault, vault's leverage in this market is immediately set to max leverage risking position liquidation \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/8 \n\nThe protocol has acknowledged this issue.\n\n## Found by \npanprog\n## Summary\n\nIf any market has to be removed from the vault, the only way to do this is via setting this market's weight to 0. The problem is that the first vault rebalance will immediately withdraw max possible collateral from this market, leaving vault's leverage at max possible leverage, risking the vault's position liquidation. This is especially dangerous if vault's position in this removed market can not be closed due to high skew, so min position is not 0, but the leverage will be at max possible value. As a result, vault depositors can lose funds due to liquidation of vault's position in this market.\n\n## Vulnerability Detail\n\nWhen vault is rebalanced, each market's collateral is calculated as following:\n```solidity\n    marketCollateral = marketContext.margin\n        .add(collateral.sub(totalMargin).mul(marketContext.registration.weight));\n\n    UFixed6 marketAssets = assets\n        .mul(marketContext.registration.weight)\n        .min(marketCollateral.mul(LEVERAGE_BUFFER));\n```\n\nFor removed markets (`weight = 0`), `marketCollateral` will be set to `marketContext.margin` (i.e. minimum valid collateral to have position at max leverage), `marketAssets` will be set to 0. But later the position will be adjusted in case minPosition is not 0:\n```solidity\n    target.position = marketAssets\n        .muldiv(marketContext.registration.leverage, marketContext.latestPrice.abs())\n        .max(marketContext.minPosition)\n        .min(marketContext.maxPosition);\n```\n\nThis means that vault's position in the market with weight 0 will be at max leverage until liquidated or position can be closed.\n\n## Impact\n\nMarket removed from the vault (weight set to 0) is put at max leverage and has a high risk of being liquidated, thus losing vault depositors funds.\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, change the following test in test/integration/vault/Vault.test.ts:\n```ts\n    it('simple deposits and redemptions', async () => {\n...\n      // Now we should have opened positions.\n      // The positions should be equal to (smallDeposit + largeDeposit) * leverage originalOraclePrice.\n      expect(await position()).to.equal(\n        smallDeposit.add(largeDeposit).mul(leverage).mul(4).div(5).div(originalOraclePrice),\n      )\n      expect(await btcPosition()).to.equal(\n        smallDeposit.add(largeDeposit).mul(leverage).div(5).div(btcOriginalOraclePrice),\n      )\n\n      /*** remove all lines after this and replace with the following code: ***/\n\n      console.log(\"pos1 = \" + (await position()) + \" pos2 = \" + (await btcPosition()) + \" col1 = \" + (await collateralInVault()) + \" col2 = \" + (await btcCollateralInVault()));\n\n      // update weight\n      await vault.connect(owner).updateWeights([parse6decimal('1.0'), parse6decimal('0')])\n\n      // do small withdrawal to trigger rebalance\n      await vault.connect(user).update(user.address, 0, smallDeposit, 0)\n      await updateOracle()\n\n      console.log(\"pos1 = \" + (await position()) + \" pos2 = \" + (await btcPosition()) + \" col1 = \" + (await collateralInVault()) + \" col2 = \" + (await btcCollateralInVault()));\n    })\n```\n\nConsole log:\n```solidity\npos1 = 12224846 pos2 = 206187 col1 = 8008000000 col2 = 2002000000\npos1 = 12224846 pos2 = 206187 col1 = 9209203452 col2 = 800796548\n```\n\nNotice, that after rebalance, position in the removed market (pos2) is still the same, but the collateral (col2) reduced to minimum allowed.\n\n## Code Snippet\n\nVault market allocation sets collateral to only the margin if `weight = 0`:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L152-L153\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the market's collateral is based on leverage even if `weight = 0`\n\n\n\n## Discussion\n\n**arjun-io**\n\nWe would likely consider this a low for two reason:\n1. The admin has control over when the vault is set to 0 weight, so as long as the limits don't prevent the vault from fully closing the position this is a safe operation to perform\n2. The liquidation fee would be an acceptable cost in the cases when the above doesn't apply (i.e. in an emergency)\n\n**nevillehuang**\n\n@panprog Do you agree with the above explanation by sponsor?\n\n**panprog**\n\n@nevillehuang @arjun-io \nThe issue is that it's not just a liquidation, it's that the vault will be bricked most of the time while that market's collateral is below margin and above maintenance (due to #23), i.e.:\n1. Market's min margin for position is $10. When the weight is 0, market collateral will be set to $10 exactly\n2. The following version's price is slightly against the maker, so market's collateral is now $9.999\n3. Any vault action will first try to settle (by calling market.update) and since it's below margin, it will revert.\n\nSo until the position is liquidated or back above margin - the vault is bricked. It happens both due to this issue and to #23, so this issue is different from #23, but their combination causes this impact.\n\nIf the position is back above margin, next vault action will put it back at exactly margin, so the probability of vault bricking is very high and it can be for extended time.\n\nSo for all these considerations I still think it's medium.\n\n**arjun-io**\n\nI see, the confluence with #23 does cause some further issues. Due to the admin's ability to control this weighting I think it's less of an issue but I will defer to the judge\n\n**panprog**\n\nI believe that sherlock's rules towards admin issues is that if admin does some valid action, but the consequences are unexpected and cause some bad impact (loss of funds / breaking core functionality), then the issue is valid. Here the admin sets weight to 0 in expectation that the market is removed from the vault. Ok, maybe he's aware that collateral will be at min margin and OK with the liquidation fee in such case. But I highly doubt that in such case admin is aware that the vault will be bricked temporarily (which is breaking the core functionality). Note, that in such case admin can not do anything to resume vault operation, because setting weight back to non-0 will revert since it tries to rebalance at the start of this function. That's why I think it's valid medium.\n\n**arjun-io**\n\nIn that case, I agree a medium is appropriate\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport {\n    MarketParameter,\n    RiskParameter,\n    Local,\n    Global,\n    Position,\n    PositionLib,\n    Order,\n    OracleVersion\n} from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Registration } from \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev Registration of the market\n    Registration registration;\n\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n\n    // @dev minimum position size before crossing the net position\n    UFixed6 minPosition;\n\n    // @dev maximum position size before crossing the maker limit\n    UFixed6 maxPosition;\n}\n\nstruct Strategy {\n    UFixed6 totalMargin;\n\n    Fixed6 totalCollateral;\n\n    UFixed6 minAssets;\n\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    error StrategyLibInsufficientCollateralError();\n    error StrategyLibInsufficientAssetsError();\n\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @notice Loads the strategy context of each of the underlying markets\n    /// @param registrations The registrations of the underlying markets\n    /// @return strategy The strategy contexts of the vault\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n            strategy.totalMargin = strategy.totalMargin.add(strategy.marketContexts[marketId].margin);\n            strategy.totalCollateral = strategy.totalCollateral.add(strategy.marketContexts[marketId].local.collateral);\n            strategy.minAssets = strategy.minAssets.max(\n                (registrations[marketId].leverage.isZero() || registrations[marketId].weight.isZero()) ?\n                    UFixed6Lib.ZERO : // skip if no leverage or weight\n                    strategy.marketContexts[marketId].minPosition\n                        .muldiv(strategy.marketContexts[marketId].latestPrice.abs(), registrations[marketId].leverage)\n                        .div(registrations[marketId].weight)\n            );\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets to make available for withdrawal\n    /// @param ineligable The amount of assets that are inapplicable for allocation\n    function allocate(\n        Strategy memory strategy,\n        UFixed6 deposit,\n        UFixed6 withdrawal,\n        UFixed6 ineligable\n    ) internal pure returns (MarketTarget[] memory targets) {\n        UFixed6 collateral = UFixed6Lib.unsafeFrom(strategy.totalCollateral).add(deposit).unsafeSub(withdrawal);\n        UFixed6 assets = collateral.unsafeSub(ineligable);\n\n        if (collateral.lt(strategy.totalMargin)) revert StrategyLibInsufficientCollateralError();\n        if (assets.lt(strategy.minAssets)) revert StrategyLibInsufficientAssetsError();\n\n        targets = new MarketTarget[](strategy.marketContexts.length);\n        UFixed6 totalMarketCollateral;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            UFixed6 marketCollateral;\n            (targets[marketId], marketCollateral) = _allocateMarket(\n                strategy.marketContexts[marketId],\n                strategy.totalMargin,\n                collateral,\n                assets\n            );\n            totalMarketCollateral = totalMarketCollateral.add(marketCollateral);\n        }\n\n        if (strategy.marketContexts.length != 0)\n            targets[0].collateral = targets[0].collateral.add(Fixed6Lib.from(collateral.sub(totalMarketCollateral)));\n    }\n\n    /// @notice Compute the target allocation for a market\n    /// @param marketContext The context of the market\n    /// @param totalMargin The total margin requirement of the vault\n    /// @param collateral The total amount of collateral of the vault\n    /// @param assets The total amount of collateral available for allocation\n    function _allocateMarket(\n        MarketStrategyContext memory marketContext,\n        UFixed6 totalMargin,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) private pure returns (MarketTarget memory target, UFixed6 marketCollateral) {\n        marketCollateral = marketContext.margin\n            .add(collateral.sub(totalMargin).mul(marketContext.registration.weight));\n\n        UFixed6 marketAssets = assets\n            .mul(marketContext.registration.weight)\n            .min(marketCollateral.mul(LEVERAGE_BUFFER));\n\n        target.collateral = Fixed6Lib.from(marketCollateral).sub(marketContext.local.collateral);\n\n        UFixed6 minAssets = marketContext.riskParameter.minMargin\n            .unsafeDiv(marketContext.registration.leverage.mul(marketContext.riskParameter.maintenance));\n\n        if (marketContext.marketParameter.closed || marketAssets.lt(minAssets)) marketAssets = UFixed6Lib.ZERO;\n\n        target.position = marketAssets\n            .muldiv(marketContext.registration.leverage, marketContext.latestPrice.abs())\n            .max(marketContext.minPosition)\n            .min(marketContext.maxPosition);\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(\n        Registration memory registration\n    ) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.registration = registration;\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        OracleVersion memory latestVersion = registration.market.oracle().latest();\n\n        marketContext.latestAccountPosition = registration.market.positions(address(this));\n        marketContext.currentAccountPosition = marketContext.latestAccountPosition.clone();\n\n        Order memory pendingLocal = registration.market.pendings(address(this));\n        marketContext.currentAccountPosition.update(pendingLocal);\n\n        marketContext.margin = PositionLib.margin(\n            marketContext.latestAccountPosition.magnitude().add(pendingLocal.pos()),\n            latestVersion,\n            marketContext.riskParameter\n        );\n        marketContext.latestPrice = latestVersion.price;\n\n        marketContext.closable = marketContext.latestAccountPosition.magnitude().sub(pendingLocal.neg());\n\n        // current position\n        Order memory pendingGlobal = registration.market.pendings(address(this));\n        marketContext.currentPosition = registration.market.position();\n        marketContext.currentPosition.update(pendingGlobal);\n        marketContext.minPosition = marketContext.currentAccountPosition.maker\n            .unsafeSub(marketContext.currentPosition.maker\n                .unsafeSub(marketContext.currentPosition.skew().abs()).min(marketContext.closable));\n        marketContext.maxPosition = marketContext.currentAccountPosition.maker\n            .add(marketContext.riskParameter.makerLimit.unsafeSub(marketContext.currentPosition.maker));\n    }\n}"
    }
  ]
}