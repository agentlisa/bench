{
  "Title": "M-5: The protocol can't receive rewards because of low gas limits on ETH transfers",
  "Content": "# Issue M-5: The protocol can't receive rewards because of low gas limits on ETH transfers \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/185 \n\n## Found by \n0xkaden, Anubis, MatricksDeCoder, Topmark, Tricko, boredpukar, cats, deth, fnanni, hash, klaus, popular, sakshamguruji, zzykxx\n## Summary\nThe hardcoded gas limit of the [Asset::transferETH()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/utils/Asset.sol#L41-L46) function, used to transfer ETH in the protocol, is too low and will result unwanted reverts.\n\n## Vulnerability Detail\nETH transfers in the protocol are always done via [Asset::transferETH()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/utils/Asset.sol#L41-L46), which performs a low-level call with an hardcoded gas limit of `10_000`:\n```solidity\n(bool success,) = recipient.call{value: amount, gas: 10_000}('');\nif (!success) {revert ETH_TRANSFER_FAILED();}\n```\n\nThe hardcoded `10_000` gas limit is not high enough for the protocol to be able receive and distribute rewards. Rewards are currently only available for native ETH, an are received by Rio via:\n- Partial withdrawals\n- ETH in excess of `32ETH` on full withdrawals\n\nThe flow to receive rewards requires two steps:\n1. An initial call to [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232), which queues a withdrawal to the Eigenpod owner: an `RioLRTOperatorDelegator` instance\n2. A call to [DelayedWithdrawalRouter::claimDelayedWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/DelayedWithdrawalRouter.sol#L99).\n\nThe call to [DelayedWithdrawalRouter::claimDelayedWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/DelayedWithdrawalRouter.sol#L99) triggers the following flow:\n1. ETH are transferred to the [RioLRTOperatorDelegator](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L244-L246) instance, where the `receive()` function is triggered.\n2. The `receive()` function of [RioLRTOperatorDelegator](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L244-L246) transfers ETH via [Asset::transferETH()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/utils/Asset.sol#L41-L46) to the [RioLRTRewardDistributor](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTRewardDistributor.sol#L82-L94), where another `receive()` function is triggered.\n3. The `receive()` function of [RioLRTRewardDistributor](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTRewardDistributor.sol#L82-L94) transfers ETH via [Asset::transferETH()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/utils/Asset.sol#L41-L46) to the `treasury`, the `operatorRewardPool` and the [`RioLRTDepositPool`](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTDepositPool.sol).\n\nThe gas is limited at `10_000` in step `2` and is not enough to perform step `3`, making it impossible for the protocol to receive rewards and leaving funds stuck.\n\n### POC\nAdd the following imports to `RioLRTOperatorDelegator.t.sol`:\n```solidity\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {RioLRTOperatorDelegator} from 'contracts/restaking/RioLRTOperatorDelegator.sol';\nimport {CredentialsProofs, BeaconWithdrawal} from 'test/utils/beacon-chain/MockBeaconChain.sol';\n```\n\nthen copy-paste:\n```solidity\nfunction test_outOfGasOnRewards() public {\n    address alice = makeAddr(\"alice\");\n    uint256 initialBalance = 40e18;\n    deal(alice, initialBalance);\n    vm.prank(alice);\n    reETH.token.approve(address(reETH.coordinator), type(uint256).max);\n\n    //->Operator delegator and validators are added to the protocol\n    uint8 operatorId = addOperatorDelegator(reETH.operatorRegistry, address(reETH.rewardDistributor));\n    RioLRTOperatorDelegator operatorDelegator =\n        RioLRTOperatorDelegator(payable(reETH.operatorRegistry.getOperatorDetails(operatorId).delegator));\n\n    //-> Alice deposits ETH in the protocol\n    vm.prank(alice);\n    reETH.coordinator.depositETH{value: initialBalance}();\n    \n    //-> Rebalance is called and the ETH deposited in a validator\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    //-> Create a new validator with a 40ETH balance and verify his credentials.\n    //-> This is to \"simulate\" rewards accumulation\n    uint40[] memory validatorIndices = new uint40[](1);\n    IRioLRTOperatorRegistry.OperatorPublicDetails memory details = reETH.operatorRegistry.getOperatorDetails(operatorId);\n    bytes32 withdrawalCredentials = operatorDelegator.withdrawalCredentials();\n    beaconChain.setNextTimestamp(block.timestamp);\n    CredentialsProofs memory proofs;\n    (validatorIndices[0], proofs) = beaconChain.newValidator({\n        balanceWei: 40 ether,\n        withdrawalCreds: abi.encodePacked(withdrawalCredentials)\n    });\n    \n    //-> Verify withdrawal crendetials\n    vm.prank(details.manager);\n    reETH.operatorRegistry.verifyWithdrawalCredentials(\n        operatorId,\n        proofs.oracleTimestamp,\n        proofs.stateRootProof,\n        proofs.validatorIndices,\n        proofs.validatorFieldsProofs,\n        proofs.validatorFields\n    );\n\n    //-> Process a full withdrawal, 8ETH (40ETH - 32ETH) will be queued withdrawal as \"rewards\"\n    verifyAndProcessWithdrawalsForValidatorIndexes(address(operatorDelegator), validatorIndices);\n\n    //-> Call `claimDelayedWithdrawals` to claim the withdrawal\n    delayedWithdrawalRouter.claimDelayedWithdrawals(address(operatorDelegator), 1); //âŒ Reverts for out-of-gas\n}\n```\n## Impact\nThe protocol is unable to receive rewards and the funds will be stucked.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nRemove the hardcoded `10_000` gas limit in [Asset::transferETH()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/utils/Asset.sol#L41-L46), at least on ETH transfers where the destination is a protocol controlled contract.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/4.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/utils/Asset.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {ETH_ADDRESS, GWEI_TO_WEI} from 'contracts/utils/Constants.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/// @title Asset utility functions.\nlibrary Asset {\n    using SafeERC20 for IERC20;\n    using Asset for address;\n\n    /// @notice Thrown when an ETH transfer fails.\n    error ETH_TRANSFER_FAILED();\n\n    /// @notice Returns the amount of the asset held by this contract.\n    /// @param asset The asset to check.\n    function getSelfBalance(address asset) internal view returns (uint256) {\n        if (asset == ETH_ADDRESS) {\n            return address(this).balance;\n        }\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /// @dev Sends `amount` of the given asset to `recipient`.\n    /// @param asset The asset to send.\n    /// @param recipient The asset recipient.\n    /// @param amount The amount of the asset to send.\n    function transferTo(address asset, address recipient, uint256 amount) internal {\n        if (asset == ETH_ADDRESS) {\n            return recipient.transferETH(amount);\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Sends `amount` of ETH to `recipient`.\n    /// @param recipient The asset recipient.\n    /// @param amount The amount of ETH to send.\n    /// @dev This function limits the gas passed with the call to 10,000.\n    function transferETH(address recipient, uint256 amount) internal {\n        (bool success,) = recipient.call{value: amount, gas: 10_000}('');\n        if (!success) {\n            revert ETH_TRANSFER_FAILED();\n        }\n    }\n\n    /// @dev Converts an amount of Gwei to Wei.\n    /// @param amountGwei The amount in Gwei to convert.\n    function toWei(uint256 amountGwei) internal pure returns (uint256) {\n        return amountGwei * GWEI_TO_WEI;\n    }\n\n    /// @dev Converts an amount of Wei to Gwei.\n    /// @param amountWei The amount in Wei to convert.\n    function toGwei(uint256 amountWei) internal pure returns (uint64) {\n        return SafeCast.toUint64(amountWei / GWEI_TO_WEI);\n    }\n\n    /// @notice Reduces the precision of the given amount to the nearest Gwei.\n    /// @param amountWei The amount whose precision is to be reduced.\n    function reducePrecisionToGwei(uint256 amountWei) internal pure returns (uint256) {\n        return amountWei - (amountWei % GWEI_TO_WEI);\n    }\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/utils/Asset.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {ETH_ADDRESS, GWEI_TO_WEI} from 'contracts/utils/Constants.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/// @title Asset utility functions.\nlibrary Asset {\n    using SafeERC20 for IERC20;\n    using Asset for address;\n\n    /// @notice Thrown when an ETH transfer fails.\n    error ETH_TRANSFER_FAILED();\n\n    /// @notice Returns the amount of the asset held by this contract.\n    /// @param asset The asset to check.\n    function getSelfBalance(address asset) internal view returns (uint256) {\n        if (asset == ETH_ADDRESS) {\n            return address(this).balance;\n        }\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /// @dev Sends `amount` of the given asset to `recipient`.\n    /// @param asset The asset to send.\n    /// @param recipient The asset recipient.\n    /// @param amount The amount of the asset to send.\n    function transferTo(address asset, address recipient, uint256 amount) internal {\n        if (asset == ETH_ADDRESS) {\n            return recipient.transferETH(amount);\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Sends `amount` of ETH to `recipient`.\n    /// @param recipient The asset recipient.\n    /// @param amount The amount of ETH to send.\n    /// @dev This function limits the gas passed with the call to 10,000.\n    function transferETH(address recipient, uint256 amount) internal {\n        (bool success,) = recipient.call{value: amount, gas: 10_000}('');\n        if (!success) {\n            revert ETH_TRANSFER_FAILED();\n        }\n    }\n\n    /// @dev Converts an amount of Gwei to Wei.\n    /// @param amountGwei The amount in Gwei to convert.\n    function toWei(uint256 amountGwei) internal pure returns (uint256) {\n        return amountGwei * GWEI_TO_WEI;\n    }\n\n    /// @dev Converts an amount of Wei to Gwei.\n    /// @param amountWei The amount in Wei to convert.\n    function toGwei(uint256 amountWei) internal pure returns (uint64) {\n        return SafeCast.toUint64(amountWei / GWEI_TO_WEI);\n    }\n\n    /// @notice Reduces the precision of the given amount to the nearest Gwei.\n    /// @param amountWei The amount whose precision is to be reduced.\n    function reducePrecisionToGwei(uint256 amountWei) internal pure returns (uint256) {\n        return amountWei - (amountWei % GWEI_TO_WEI);\n    }\n}"
    },
    {
      "filename": "src/contracts/pods/EigenPod.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/BeaconChainProofs.sol\";\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/Endian.sol\";\n\nimport \"../interfaces/IETHPOSDeposit.sol\";\nimport \"../interfaces/IEigenPodManager.sol\";\nimport \"../interfaces/IEigenPod.sol\";\nimport \"../interfaces/IDelayedWithdrawalRouter.sol\";\nimport \"../interfaces/IPausable.sol\";\n\nimport \"./EigenPodPausingConstants.sol\";\n\n/**\n * @title The implementation contract used for restaking beacon chain ETH on EigenLayer\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice The main functionalities are:\n * - creating new ETH validators with their withdrawal credentials pointed to this contract\n * - proving from beacon chain state roots that withdrawal credentials are pointed to this contract\n * - proving from beacon chain state roots the balances of ETH validators with their withdrawal credentials\n *   pointed to this contract\n * - updating aggregate balances in the EigenPodManager\n * - withdrawing eth when withdrawals are initiated\n * @notice This EigenPod Beacon Proxy implementation adheres to the current Capella consensus specs\n * @dev Note that all beacon chain balances are stored as gwei within the beacon chain datastructures. We choose\n *   to account balances in terms of gwei in the EigenPod contract and convert to wei when making calls to other contracts\n */\ncontract EigenPod is IEigenPod, Initializable, ReentrancyGuardUpgradeable, EigenPodPausingConstants {\n    using BytesLib for bytes;\n    using SafeERC20 for IERC20;\n    using BeaconChainProofs for *;\n\n    // CONSTANTS + IMMUTABLES\n    // @notice Internal constant used in calculations, since the beacon chain stores balances in Gwei rather than wei\n    uint256 internal constant GWEI_TO_WEI = 1e9;\n\n    /**\n     * @notice Maximum \"staleness\" of a Beacon Chain state root against which `verifyBalanceUpdate` or `verifyWithdrawalCredentials` may be proven.\n     * We can't allow \"stale\" roots to be used for restaking as the validator may have been slashed in a more updated beacon state root. \n     */\n    uint256 internal constant VERIFY_BALANCE_UPDATE_WINDOW_SECONDS = 4.5 hours;\n\n    /// @notice This is the beacon chain deposit contract\n    IETHPOSDeposit public immutable ethPOS;\n\n    /// @notice Contract used for withdrawal routing, to provide an extra \"safety net\" mechanism\n    IDelayedWithdrawalRouter public immutable delayedWithdrawalRouter;\n\n    /// @notice The single EigenPodManager for EigenLayer\n    IEigenPodManager public immutable eigenPodManager;\n\n    ///@notice The maximum amount of ETH, in gwei, a validator can have restaked in the eigenlayer\n    uint64 public immutable MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n\n    /// @notice This is the genesis time of the beacon state, to help us calculate conversions between slot and timestamp\n    uint64 public immutable GENESIS_TIME;\n\n    // STORAGE VARIABLES\n    /// @notice The owner of this EigenPod\n    address public podOwner;\n\n    /**\n     * @notice The latest timestamp at which the pod owner withdrew the balance of the pod, via calling `withdrawBeforeRestaking`.\n     * @dev This variable is only updated when the `withdrawBeforeRestaking` function is called, which can only occur before `hasRestaked` is set to true for this pod.\n     * Proofs for this pod are only valid against Beacon Chain state roots corresponding to timestamps after the stored `mostRecentWithdrawalTimestamp`.\n     */\n    uint64 public mostRecentWithdrawalTimestamp;\n\n    /// @notice the amount of execution layer ETH in this contract that is staked in EigenLayer (i.e. withdrawn from the Beacon Chain but not from EigenLayer),\n    uint64 public withdrawableRestakedExecutionLayerGwei;\n\n    /// @notice an indicator of whether or not the podOwner has ever \"fully restaked\" by successfully calling `verifyCorrectWithdrawalCredentials`.\n    bool public hasRestaked;\n\n    /// @notice This is a mapping of validatorPubkeyHash to timestamp to whether or not they have proven a withdrawal for that timestamp\n    mapping(bytes32 => mapping(uint64 => bool)) public provenWithdrawal;\n\n    /// @notice This is a mapping that tracks a validator's information by their pubkey hash\n    mapping(bytes32 => ValidatorInfo) internal _validatorPubkeyHashToInfo;\n\n    /// @notice This variable tracks any ETH deposited into this contract via the `receive` fallback function\n    uint256 public nonBeaconChainETHBalanceWei;\n\n     /// @notice This variable tracks the total amount of partial withdrawals claimed via merkle proofs prior to a switch to ZK proofs for claiming partial withdrawals\n    uint64 public sumOfPartialWithdrawalsClaimedGwei;\n\n    modifier onlyEigenPodManager() {\n        require(msg.sender == address(eigenPodManager), \"EigenPod.onlyEigenPodManager: not eigenPodManager\");\n        _;\n    }\n\n    modifier onlyEigenPodOwner() {\n        require(msg.sender == podOwner, \"EigenPod.onlyEigenPodOwner: not podOwner\");\n        _;\n    }\n\n    modifier hasNeverRestaked() {\n        require(!hasRestaked, \"EigenPod.hasNeverRestaked: restaking is enabled\");\n        _;\n    }\n\n    /// @notice checks that hasRestaked is set to true by calling activateRestaking()\n    modifier hasEnabledRestaking() {\n        require(hasRestaked, \"EigenPod.hasEnabledRestaking: restaking is not enabled\");\n        _;\n    }\n\n    /// @notice Checks that `timestamp` is strictly greater than the value stored in `mostRecentWithdrawalTimestamp`\n    modifier proofIsForValidTimestamp(uint64 timestamp) {\n        require(\n            timestamp > mostRecentWithdrawalTimestamp,\n            \"EigenPod.proofIsForValidTimestamp: beacon chain proof must be for timestamp after mostRecentWithdrawalTimestamp\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Based on 'Pausable' code, but uses the storage of the EigenPodManager instead of this contract. This construction\n     * is necessary for enabling pausing all EigenPods at the same time (due to EigenPods being Beacon Proxies).\n     * Modifier throws if the `indexed`th bit of `_paused` in the EigenPodManager is 1, i.e. if the `index`th pause switch is flipped.\n     */\n    modifier onlyWhenNotPaused(uint8 index) {\n        require(\n            !IPausable(address(eigenPodManager)).paused(index),\n            \"EigenPod.onlyWhenNotPaused: index is paused in EigenPodManager\"\n        );\n        _;\n    }\n\n    constructor(\n        IETHPOSDeposit _ethPOS,\n        IDelayedWithdrawalRouter _delayedWithdrawalRouter,\n        IEigenPodManager _eigenPodManager,\n        uint64 _MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR,\n        uint64 _GENESIS_TIME\n    ) {\n        ethPOS = _ethPOS;\n        delayedWithdrawalRouter = _delayedWithdrawalRouter;\n        eigenPodManager = _eigenPodManager;\n        MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR = _MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n        GENESIS_TIME = _GENESIS_TIME;\n        _disableInitializers();\n    }\n\n    /// @notice Used to initialize the pointers to addresses crucial to the pod's functionality. Called on construction by the EigenPodManager.\n    function initialize(address _podOwner) external initializer {\n        require(_podOwner != address(0), \"EigenPod.initialize: podOwner cannot be zero address\");\n        podOwner = _podOwner;\n        /**\n         * From the M2 deployment onwards, we are requiring that pods deployed are by default enabled with restaking\n         * In prior deployments without proofs, EigenPods could be deployed with restaking disabled so as to allow\n         * simple (proof-free) withdrawals.  However, this is no longer the case.  Thus going forward, all pods are\n         * initialized with hasRestaked set to true.\n         */\n        hasRestaked = true;\n        emit RestakingActivated(podOwner);\n    }\n\n    /// @notice payable fallback function that receives ether deposited to the eigenpods contract\n    receive() external payable {\n        nonBeaconChainETHBalanceWei += msg.value;\n        emit NonBeaconChainETHReceived(msg.value);\n    }\n\n    /**\n     * @notice This function records an update (either increase or decrease) in a validator's balance.\n     * @param oracleTimestamp The oracleTimestamp whose state root the proof will be proven against.\n     *        Must be within `VERIFY_BALANCE_UPDATE_WINDOW_SECONDS` of the current block.\n     * @param validatorIndices is the list of indices of the validators being proven, refer to consensus specs \n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param validatorFieldsProofs proofs against the `beaconStateRoot` for each validator in `validatorFields`\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     * @dev For more details on the Beacon Chain spec, see: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyBalanceUpdates(\n        uint64 oracleTimestamp,\n        uint40[] calldata validatorIndices,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    ) external onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_BALANCE_UPDATE) {\n        require(\n            (validatorIndices.length == validatorFieldsProofs.length) && (validatorFieldsProofs.length == validatorFields.length),\n            \"EigenPod.verifyBalanceUpdates: validatorIndices and proofs must be same length\"\n        );\n\n        // Balance updates should not be \"stale\" (older than VERIFY_BALANCE_UPDATE_WINDOW_SECONDS)\n        require(\n            oracleTimestamp + VERIFY_BALANCE_UPDATE_WINDOW_SECONDS >= block.timestamp,\n            \"EigenPod.verifyBalanceUpdates: specified timestamp is too far in past\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        int256 sharesDeltaGwei;\n        for (uint256 i = 0; i < validatorIndices.length; i++) {\n            sharesDeltaGwei += _verifyBalanceUpdate(\n                oracleTimestamp,\n                validatorIndices[i],\n                stateRootProof.beaconStateRoot,\n                validatorFieldsProofs[i], // Use validator fields proof because contains the effective balance\n                validatorFields[i]\n            );\n        }\n        eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, sharesDeltaGwei * int256(GWEI_TO_WEI));\n    }\n\n    /**\n     * @notice This function records full and partial withdrawals on behalf of one or more of this EigenPod's validators\n     * @param oracleTimestamp is the timestamp of the oracle slot that the withdrawal is being proven against\n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param withdrawalProofs proves several withdrawal-related values against the `beaconStateRoot`\n     * @param validatorFieldsProofs proves `validatorFields` against the `beaconStateRoot`\n     * @param withdrawalFields are the fields of the withdrawals being proven\n     * @param validatorFields are the fields of the validators being proven\n     */\n    function verifyAndProcessWithdrawals(\n        uint64 oracleTimestamp,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        BeaconChainProofs.WithdrawalProof[] calldata withdrawalProofs,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields,\n        bytes32[][] calldata withdrawalFields\n    ) external onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_WITHDRAWAL) {\n        require(\n            (validatorFields.length == validatorFieldsProofs.length) &&\n                (validatorFieldsProofs.length == withdrawalProofs.length) &&\n                (withdrawalProofs.length == withdrawalFields.length),\n            \"EigenPod.verifyAndProcessWithdrawals: inputs must be same length\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        VerifiedWithdrawal memory withdrawalSummary;\n        for (uint256 i = 0; i < withdrawalFields.length; i++) {\n            VerifiedWithdrawal memory verifiedWithdrawal = _verifyAndProcessWithdrawal(\n                stateRootProof.beaconStateRoot,\n                withdrawalProofs[i],\n                validatorFieldsProofs[i],\n                validatorFields[i],\n                withdrawalFields[i]\n            );\n\n            withdrawalSummary.amountToSendGwei += verifiedWithdrawal.amountToSendGwei;\n            withdrawalSummary.sharesDeltaGwei += verifiedWithdrawal.sharesDeltaGwei;\n        }\n\n        // If any withdrawals are eligible for immediate redemption, send to the pod owner via\n        // DelayedWithdrawalRouter\n        if (withdrawalSummary.amountToSendGwei != 0) {\n            _sendETH_AsDelayedWithdrawal(podOwner, withdrawalSummary.amountToSendGwei * GWEI_TO_WEI);\n        }\n        // If any withdrawals resulted in a change in the pod's shares, update the EigenPodManager\n        if (withdrawalSummary.sharesDeltaGwei != 0) {\n            eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, withdrawalSummary.sharesDeltaGwei * int256(GWEI_TO_WEI));\n        }\n    }\n\n    /*******************************************************************************\n                    EXTERNAL FUNCTIONS CALLABLE BY EIGENPOD OWNER\n    *******************************************************************************/\n\n    /**\n     * @notice This function verifies that the withdrawal credentials of validator(s) owned by the podOwner are pointed to\n     * this contract. It also verifies the effective balance  of the validator.  It verifies the provided proof of the ETH validator against the beacon chain state\n     * root, marks the validator as 'active' in EigenLayer, and credits the restaked ETH in Eigenlayer.\n     * @param oracleTimestamp is the Beacon Chain timestamp whose state root the `proof` will be proven against.\n     * @param stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\n     * @param validatorIndices is the list of indices of the validators being proven, refer to consensus specs\n     * @param validatorFieldsProofs proofs against the `beaconStateRoot` for each validator in `validatorFields`\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     * for details: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyWithdrawalCredentials(\n        uint64 oracleTimestamp,\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\n        uint40[] calldata validatorIndices,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    )\n        external\n        onlyEigenPodOwner\n        onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CREDENTIALS)\n        // check that the provided `oracleTimestamp` is after the `mostRecentWithdrawalTimestamp`\n        proofIsForValidTimestamp(oracleTimestamp)\n        // ensure that caller has previously enabled restaking by calling `activateRestaking()`\n        hasEnabledRestaking\n    {\n        require(\n            (validatorIndices.length == validatorFieldsProofs.length) &&\n                (validatorFieldsProofs.length == validatorFields.length),\n            \"EigenPod.verifyWithdrawalCredentials: validatorIndices and proofs must be same length\"\n        );\n\n        /**\n         * Withdrawal credential proof should not be \"stale\" (older than VERIFY_BALANCE_UPDATE_WINDOW_SECONDS) as we are doing a balance check here\n         * The validator container persists as the state evolves and even after the validator exits. So we can use a more \"fresh\" credential proof within\n         * the VERIFY_BALANCE_UPDATE_WINDOW_SECONDS window, not just the first proof where the validator container is registered in the state.\n         */\n        require(\n            oracleTimestamp + VERIFY_BALANCE_UPDATE_WINDOW_SECONDS >= block.timestamp,\n            \"EigenPod.verifyWithdrawalCredentials: specified timestamp is too far in past\"\n        );\n\n        // Verify passed-in beaconStateRoot against oracle-provided block root:\n        BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot({\n            latestBlockRoot: eigenPodManager.getBlockRootAtTimestamp(oracleTimestamp),\n            beaconStateRoot: stateRootProof.beaconStateRoot,\n            stateRootProof: stateRootProof.proof\n        });\n\n        uint256 totalAmountToBeRestakedWei;\n        for (uint256 i = 0; i < validatorIndices.length; i++) {\n            totalAmountToBeRestakedWei += _verifyWithdrawalCredentials(\n                oracleTimestamp,\n                stateRootProof.beaconStateRoot,\n                validatorIndices[i],\n                validatorFieldsProofs[i],\n                validatorFields[i]\n            );\n        }\n\n        // Update the EigenPodManager on this pod's new balance\n        eigenPodManager.recordBeaconChainETHBalanceUpdate(podOwner, int256(totalAmountToBeRestakedWei));\n    }\n\n    /// @notice Called by the pod owner to withdraw the nonBeaconChainETHBalanceWei\n    function withdrawNonBeaconChainETHBalanceWei(\n        address recipient,\n        uint256 amountToWithdraw\n    ) external onlyEigenPodOwner onlyWhenNotPaused(PAUSED_NON_PROOF_WITHDRAWALS) {\n        require(\n            amountToWithdraw <= nonBeaconChainETHBalanceWei,\n            \"EigenPod.withdrawnonBeaconChainETHBalanceWei: amountToWithdraw is greater than nonBeaconChainETHBalanceWei\"\n        );\n        nonBeaconChainETHBalanceWei -= amountToWithdraw;\n        emit NonBeaconChainETHWithdrawn(recipient, amountToWithdraw);\n        _sendETH_AsDelayedWithdrawal(recipient, amountToWithdraw);\n    }\n\n    /// @notice called by owner of a pod to remove any ERC20s deposited in the pod\n    function recoverTokens(\n        IERC20[] memory tokenList,\n        uint256[] memory amountsToWithdraw,\n        address recipient\n    ) external onlyEigenPodOwner onlyWhenNotPaused(PAUSED_NON_PROOF_WITHDRAWALS) {\n        require(\n            tokenList.length == amountsToWithdraw.length,\n            \"EigenPod.recoverTokens: tokenList and amountsToWithdraw must be same length\"\n        );\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            tokenList[i].safeTransfer(recipient, amountsToWithdraw[i]);\n        }\n    }\n\n    /**\n     * @notice Called by the pod owner to activate restaking by withdrawing\n     * all existing ETH from the pod and preventing further withdrawals via\n     * \"withdrawBeforeRestaking()\"\n     */\n    function activateRestaking()\n        external\n        onlyWhenNotPaused(PAUSED_EIGENPODS_VERIFY_CREDENTIALS)\n        onlyEigenPodOwner\n        hasNeverRestaked\n    {\n        hasRestaked = true;\n        _processWithdrawalBeforeRestaking(podOwner);\n\n        emit RestakingActivated(podOwner);\n    }\n\n    /// @notice Called by the pod owner to withdraw the balance of the pod when `hasRestaked` is set to false\n    function withdrawBeforeRestaking() external onlyEigenPodOwner hasNeverRestaked {\n        _processWithdrawalBeforeRestaking(podOwner);\n    }\n\n    /*******************************************************************************\n                    EXTERNAL FUNCTIONS CALLABLE BY EIGENPODMANAGER\n    *******************************************************************************/\n\n    /// @notice Called by EigenPodManager when the owner wants to create another ETH validator.\n    function stake(\n        bytes calldata pubkey,\n        bytes calldata signature,\n        bytes32 depositDataRoot\n    ) external payable onlyEigenPodManager {\n        // stake on ethpos\n        require(msg.value == 32 ether, \"EigenPod.stake: must initially stake for any validator with 32 ether\");\n        ethPOS.deposit{value: 32 ether}(pubkey, _podWithdrawalCredentials(), signature, depositDataRoot);\n        emit EigenPodStaked(pubkey);\n    }\n\n    /**\n     * @notice Transfers `amountWei` in ether from this contract to the specified `recipient` address\n     * @notice Called by EigenPodManager to withdrawBeaconChainETH that has been added to the EigenPod's balance due to a withdrawal from the beacon chain.\n     * @dev The podOwner must have already proved sufficient withdrawals, so that this pod's `withdrawableRestakedExecutionLayerGwei` exceeds the\n     * `amountWei` input (when converted to GWEI).\n     * @dev Reverts if `amountWei` is not a whole Gwei amount\n     */\n    function withdrawRestakedBeaconChainETH(address recipient, uint256 amountWei) external onlyEigenPodManager {\n        require(amountWei % GWEI_TO_WEI == 0, \"EigenPod.withdrawRestakedBeaconChainETH: amountWei must be a whole Gwei amount\");\n        uint64 amountGwei = uint64(amountWei / GWEI_TO_WEI);\n        require(amountGwei <= withdrawableRestakedExecutionLayerGwei, \"EigenPod.withdrawRestakedBeaconChainETH: amountGwei exceeds withdrawableRestakedExecutionLayerGwei\");\n        withdrawableRestakedExecutionLayerGwei -= amountGwei;\n        emit RestakedBeaconChainETHWithdrawn(recipient, amountWei);\n        // transfer ETH from pod to `recipient` directly\n        _sendETH(recipient, amountWei);\n    }\n\n    /*******************************************************************************\n                                INTERNAL FUNCTIONS\n    *******************************************************************************/\n    /**\n     * @notice internal function that proves an individual validator's withdrawal credentials\n     * @param oracleTimestamp is the timestamp whose state root the `proof` will be proven against.\n     * @param validatorIndex is the index of the validator being proven\n     * @param validatorFieldsProof is the bytes that prove the ETH validator's  withdrawal credentials against a beacon chain state root\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     */\n    function _verifyWithdrawalCredentials(\n        uint64 oracleTimestamp,\n        bytes32 beaconStateRoot,\n        uint40 validatorIndex,\n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields\n    ) internal returns (uint256) {\n        bytes32 validatorPubkeyHash = validatorFields.getPubkeyHash();\n        ValidatorInfo memory validatorInfo = _validatorPubkeyHashToInfo[validatorPubkeyHash];\n\n        // Withdrawal credential proofs should only be processed for \"INACTIVE\" validators\n        require(\n            validatorInfo.status == VALIDATOR_STATUS.INACTIVE,\n            \"EigenPod.verifyCorrectWithdrawalCredentials: Validator must be inactive to prove withdrawal credentials\"\n        );\n\n        // Ensure the `validatorFields` we're proving have the correct withdrawal credentials\n        require(\n            validatorFields.getWithdrawalCredentials() == bytes32(_podWithdrawalCredentials()),\n            \"EigenPod.verifyCorrectWithdrawalCredentials: Proof is not for this EigenPod\"\n        );\n\n        /**\n         * Deserialize the balance field from the Validator struct.  Note that this is the \"effective\" balance of the validator\n         * rather than the current balance.  Effective balance is generated via a hystersis function such that an effective\n         * balance, always a multiple of 1 ETH, will only lower to the next multiple of 1 ETH if the current balance is less\n         * than 0.25 ETH below their current effective balance.  For example, if the effective balance is 31ETH, it only falls to\n         * 30ETH when the true balance falls below 30.75ETH.  Thus in the worst case, the effective balance is overestimating the\n         * actual validator balance by 0.25 ETH. \n         */\n        uint64 validatorEffectiveBalanceGwei = validatorFields.getEffectiveBalanceGwei();\n\n        // Verify passed-in validatorFields against verified beaconStateRoot:\n        BeaconChainProofs.verifyValidatorFields({\n            beaconStateRoot: beaconStateRoot,\n            validatorFields: validatorFields,\n            validatorFieldsProof: validatorFieldsProof,\n            validatorIndex: validatorIndex\n        });\n\n        // Proofs complete - update this validator's status, record its proven balance, and save in state:\n        validatorInfo.status = VALIDATOR_STATUS.ACTIVE;\n        validatorInfo.validatorIndex = validatorIndex;\n        validatorInfo.mostRecentBalanceUpdateTimestamp = oracleTimestamp;\n\n        if (validatorEffectiveBalanceGwei > MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR) {\n            validatorInfo.restakedBalanceGwei = MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n        } else {\n            validatorInfo.restakedBalanceGwei = validatorEffectiveBalanceGwei;\n        }\n        _validatorPubkeyHashToInfo[validatorPubkeyHash] = validatorInfo;\n\n        emit ValidatorRestaked(validatorIndex);\n        emit ValidatorBalanceUpdated(validatorIndex, oracleTimestamp, validatorInfo.restakedBalanceGwei);\n\n        return validatorInfo.restakedBalanceGwei * GWEI_TO_WEI;\n    }\n\n    function _verifyBalanceUpdate(\n        uint64 oracleTimestamp,\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields\n    ) internal returns(int256 sharesDeltaGwei){\n        uint64 validatorEffectiveBalanceGwei = validatorFields.getEffectiveBalanceGwei();\n        bytes32 validatorPubkeyHash = validatorFields.getPubkeyHash();\n        ValidatorInfo memory validatorInfo = _validatorPubkeyHashToInfo[validatorPubkeyHash];\n\n        // 1. Balance updates should be more recent than the most recent update\n        require(\n            validatorInfo.mostRecentBalanceUpdateTimestamp < oracleTimestamp,\n            \"EigenPod.verifyBalanceUpdate: Validators balance has already been updated for this timestamp\"\n        );\n\n        // 2. Balance updates should only be performed on \"ACTIVE\" validators\n        require(\n            validatorInfo.status == VALIDATOR_STATUS.ACTIVE, \n            \"EigenPod.verifyBalanceUpdate: Validator not active\"\n        );\n\n        // 3. Balance updates should only be made before a validator is fully withdrawn. \n        // -- A withdrawable validator may not have withdrawn yet, so we require their balance is nonzero\n        // -- A fully withdrawn validator should withdraw via verifyAndProcessWithdrawals\n        if (validatorFields.getWithdrawableEpoch() <= _timestampToEpoch(oracleTimestamp)) {\n            require(\n                validatorEffectiveBalanceGwei > 0,\n                \"EigenPod.verifyBalanceUpdate: validator is withdrawable but"
    }
  ]
}