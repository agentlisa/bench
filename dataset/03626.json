{
  "Title": "Extra field in the structure",
  "Content": "##### Description\nAt the line https://github.com/aave/governance-crosschain-bridges/blob/763ef5da8befff3a129443a3ff4ef7ca4d3bb446/contracts/BridgeExecutorBase.sol#L206 is assigned to the variable `actionsSet.id` of type `uint256`.\nBut this variable is not used anywhere else. In addition, this variable is duplicated on line https://github.com/aave/governance-crosschain-bridges/blob/763ef5da8befff3a129443a3ff4ef7ca4d3bb446/contracts/BridgeExecutorBase.sol#L205.\nWe will not be able to get the value of the `_actionsSets` variable without knowing the value of `actionsSetId` and there is no need to additionally store the value of `actionsSetId` in a variable of the `ActionsSet` type.\n\n##### Recommendation\nIt is recommended to remove the `id` field on the https://github.com/aave/governance-crosschain-bridges/blob/763ef5da8befff3a129443a3ff4ef7ca4d3bb446/contracts/interfaces/IBridgeExecutor.sol#L9 line from the `ActionsSet` structure.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BridgeExecutorBase.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport './dependencies/SafeMath.sol';\nimport './interfaces/IBridgeExecutor.sol';\n\nabstract contract BridgeExecutorBase is IBridgeExecutor {\n  using SafeMath for uint256;\n\n  uint256 public immutable override GRACE_PERIOD;\n  uint256 public immutable override MINIMUM_DELAY;\n  uint256 public immutable override MAXIMUM_DELAY;\n\n  uint256 private _actionsSetCounter;\n  address private _guardian;\n  uint256 private _delay;\n\n  mapping(uint256 => ActionsSet) private _actionsSets;\n  mapping(bytes32 => bool) private _queuedActions;\n\n  modifier onlyGuardian() {\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\n    _;\n  }\n\n  constructor(\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) {\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\n    _delay = delay;\n    GRACE_PERIOD = gracePeriod;\n    MINIMUM_DELAY = minimumDelay;\n    MAXIMUM_DELAY = maximumDelay;\n\n    _guardian = guardian;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @dev Execute the ActionsSet\n   * @param actionsSetId id of the ActionsSet to execute\n   **/\n  function execute(uint256 actionsSetId) external payable override {\n    require(getCurrentState(actionsSetId) == ActionsSetState.Queued, 'ONLY_QUEUED_ACTIONS');\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    require(block.timestamp >= actionsSet.executionTime, 'TIMELOCK_NOT_FINISHED');\n\n    actionsSet.executed = true;\n    for (uint256 i = 0; i < actionsSet.targets.length; i++) {\n      _executeTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n    }\n    emit ActionsSetExecuted(actionsSetId, msg.sender);\n  }\n\n  /**\n   * @dev Cancel the ActionsSet\n   * @param actionsSetId id of the ActionsSet to cancel\n   **/\n  function cancel(uint256 actionsSetId) external override onlyGuardian {\n    ActionsSetState state = getCurrentState(actionsSetId);\n    require(state == ActionsSetState.Queued, 'ONLY_BEFORE_EXECUTED');\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.canceled = true;\n    for (uint256 i = 0; i < actionsSet.targets.length; i++) {\n      _cancelTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n    }\n\n    emit ActionsSetCanceled(actionsSetId);\n  }\n\n  /**\n   * @dev Set the delay\n   * @param delay delay between queue and execution of an ActionsSet\n   **/\n  function setDelay(uint256 delay) public override onlyGuardian {\n    _validateDelay(delay);\n    _delay = delay;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @dev Get the ActionsSet by Id\n   * @param actionsSetId id of the ActionsSet\n   * @return the ActionsSet requested\n   **/\n  function getActionsSetById(uint256 actionsSetId)\n    external\n    view\n    override\n    returns (ActionsSet memory)\n  {\n    return _actionsSets[actionsSetId];\n  }\n\n  /**\n   * @dev Get the current state of an ActionsSet\n   * @param actionsSetId id of the ActionsSet\n   * @return The current state if the ActionsSet\n   **/\n  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {\n    require(_actionsSetCounter >= actionsSetId, 'INVALID_ACTION_ID');\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    if (actionsSet.canceled) {\n      return ActionsSetState.Canceled;\n    } else if (actionsSet.executed) {\n      return ActionsSetState.Executed;\n    } else if (block.timestamp > actionsSet.executionTime.add(GRACE_PERIOD)) {\n      return ActionsSetState.Expired;\n    } else {\n      return ActionsSetState.Queued;\n    }\n  }\n\n  /**\n   * @dev Returns whether an action (via actionHash) is queued\n   * @param actionHash hash of the action to be checked\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n   * @return true if underlying action of actionHash is queued\n   **/\n  function isActionQueued(bytes32 actionHash) public view override returns (bool) {\n    return _queuedActions[actionHash];\n  }\n\n  /**\n   * @dev Receive Funds if necessary for delegate calls\n   **/\n  function receiveFunds() external payable {}\n\n  /**\n   * @dev Getter of the delay between queuing and execution\n   * @return The delay in seconds\n   **/\n  function getDelay() external view override returns (uint256) {\n    return _delay;\n  }\n\n  /**\n   * @dev Queue the ActionsSet - only callable by the BridgeMessageProvessor\n   * @param targets list of contracts called by each action's associated transaction\n   * @param values list of value in wei for each action's  associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n   **/\n  function _queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) internal {\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length &&\n        targets.length == withDelegatecalls.length,\n      'INCONSISTENT_PARAMS_LENGTH'\n    );\n\n    uint256 actionsSetId = _actionsSetCounter;\n    uint256 executionTime = block.timestamp.add(_delay);\n    _actionsSetCounter++;\n\n    for (uint256 i = 0; i < targets.length; i++) {\n      bytes32 actionHash =\n        keccak256(\n          abi.encode(\n            targets[i],\n            values[i],\n            signatures[i],\n            calldatas[i],\n            executionTime,\n            withDelegatecalls[i]\n          )\n        );\n      require(!isActionQueued(actionHash), 'DUPLICATED_ACTION');\n      _queuedActions[actionHash] = true;\n    }\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.id = actionsSetId;\n    actionsSet.targets = targets;\n    actionsSet.values = values;\n    actionsSet.signatures = signatures;\n    actionsSet.calldatas = calldatas;\n    actionsSet.withDelegatecalls = withDelegatecalls;\n    actionsSet.executionTime = executionTime;\n\n    emit ActionsSetQueued(\n      actionsSetId,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      withDelegatecalls,\n      executionTime\n    );\n  }\n\n  function _executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    bytes32 actionHash =\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\n    _queuedActions[actionHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    bool success;\n    bytes memory resultData;\n    if (withDelegatecall) {\n      require(msg.value >= value, 'NOT_ENOUGH_MSG_VALUE');\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.delegatecall(callData);\n    } else {\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.call{value: value}(callData);\n    }\n\n    require(success, 'FAILED_ACTION_EXECUTION');\n  }\n\n  function _cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    bytes32 actionHash =\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\n    _queuedActions[actionHash] = false;\n  }\n\n  function _validateDelay(uint256 delay) internal view {\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\n  }\n}"
    },
    {
      "filename": "contracts/BridgeExecutorBase.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport './dependencies/SafeMath.sol';\nimport './interfaces/IBridgeExecutor.sol';\n\nabstract contract BridgeExecutorBase is IBridgeExecutor {\n  using SafeMath for uint256;\n\n  uint256 public immutable override GRACE_PERIOD;\n  uint256 public immutable override MINIMUM_DELAY;\n  uint256 public immutable override MAXIMUM_DELAY;\n\n  uint256 private _actionsSetCounter;\n  address private _guardian;\n  uint256 private _delay;\n\n  mapping(uint256 => ActionsSet) private _actionsSets;\n  mapping(bytes32 => bool) private _queuedActions;\n\n  modifier onlyGuardian() {\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\n    _;\n  }\n\n  constructor(\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) {\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\n    _delay = delay;\n    GRACE_PERIOD = gracePeriod;\n    MINIMUM_DELAY = minimumDelay;\n    MAXIMUM_DELAY = maximumDelay;\n\n    _guardian = guardian;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @dev Execute the ActionsSet\n   * @param actionsSetId id of the ActionsSet to execute\n   **/\n  function execute(uint256 actionsSetId) external payable override {\n    require(getCurrentState(actionsSetId) == ActionsSetState.Queued, 'ONLY_QUEUED_ACTIONS');\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    require(block.timestamp >= actionsSet.executionTime, 'TIMELOCK_NOT_FINISHED');\n\n    actionsSet.executed = true;\n    for (uint256 i = 0; i < actionsSet.targets.length; i++) {\n      _executeTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n    }\n    emit ActionsSetExecuted(actionsSetId, msg.sender);\n  }\n\n  /**\n   * @dev Cancel the ActionsSet\n   * @param actionsSetId id of the ActionsSet to cancel\n   **/\n  function cancel(uint256 actionsSetId) external override onlyGuardian {\n    ActionsSetState state = getCurrentState(actionsSetId);\n    require(state == ActionsSetState.Queued, 'ONLY_BEFORE_EXECUTED');\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.canceled = true;\n    for (uint256 i = 0; i < actionsSet.targets.length; i++) {\n      _cancelTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n    }\n\n    emit ActionsSetCanceled(actionsSetId);\n  }\n\n  /**\n   * @dev Set the delay\n   * @param delay delay between queue and execution of an ActionsSet\n   **/\n  function setDelay(uint256 delay) public override onlyGuardian {\n    _validateDelay(delay);\n    _delay = delay;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @dev Get the ActionsSet by Id\n   * @param actionsSetId id of the ActionsSet\n   * @return the ActionsSet requested\n   **/\n  function getActionsSetById(uint256 actionsSetId)\n    external\n    view\n    override\n    returns (ActionsSet memory)\n  {\n    return _actionsSets[actionsSetId];\n  }\n\n  /**\n   * @dev Get the current state of an ActionsSet\n   * @param actionsSetId id of the ActionsSet\n   * @return The current state if the ActionsSet\n   **/\n  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {\n    require(_actionsSetCounter >= actionsSetId, 'INVALID_ACTION_ID');\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    if (actionsSet.canceled) {\n      return ActionsSetState.Canceled;\n    } else if (actionsSet.executed) {\n      return ActionsSetState.Executed;\n    } else if (block.timestamp > actionsSet.executionTime.add(GRACE_PERIOD)) {\n      return ActionsSetState.Expired;\n    } else {\n      return ActionsSetState.Queued;\n    }\n  }\n\n  /**\n   * @dev Returns whether an action (via actionHash) is queued\n   * @param actionHash hash of the action to be checked\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n   * @return true if underlying action of actionHash is queued\n   **/\n  function isActionQueued(bytes32 actionHash) public view override returns (bool) {\n    return _queuedActions[actionHash];\n  }\n\n  /**\n   * @dev Receive Funds if necessary for delegate calls\n   **/\n  function receiveFunds() external payable {}\n\n  /**\n   * @dev Getter of the delay between queuing and execution\n   * @return The delay in seconds\n   **/\n  function getDelay() external view override returns (uint256) {\n    return _delay;\n  }\n\n  /**\n   * @dev Queue the ActionsSet - only callable by the BridgeMessageProvessor\n   * @param targets list of contracts called by each action's associated transaction\n   * @param values list of value in wei for each action's  associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n   **/\n  function _queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) internal {\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length &&\n        targets.length == withDelegatecalls.length,\n      'INCONSISTENT_PARAMS_LENGTH'\n    );\n\n    uint256 actionsSetId = _actionsSetCounter;\n    uint256 executionTime = block.timestamp.add(_delay);\n    _actionsSetCounter++;\n\n    for (uint256 i = 0; i < targets.length; i++) {\n      bytes32 actionHash =\n        keccak256(\n          abi.encode(\n            targets[i],\n            values[i],\n            signatures[i],\n            calldatas[i],\n            executionTime,\n            withDelegatecalls[i]\n          )\n        );\n      require(!isActionQueued(actionHash), 'DUPLICATED_ACTION');\n      _queuedActions[actionHash] = true;\n    }\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.id = actionsSetId;\n    actionsSet.targets = targets;\n    actionsSet.values = values;\n    actionsSet.signatures = signatures;\n    actionsSet.calldatas = calldatas;\n    actionsSet.withDelegatecalls = withDelegatecalls;\n    actionsSet.executionTime = executionTime;\n\n    emit ActionsSetQueued(\n      actionsSetId,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      withDelegatecalls,\n      executionTime\n    );\n  }\n\n  function _executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    bytes32 actionHash =\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\n    _queuedActions[actionHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    bool success;\n    bytes memory resultData;\n    if (withDelegatecall) {\n      require(msg.value >= value, 'NOT_ENOUGH_MSG_VALUE');\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.delegatecall(callData);\n    } else {\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.call{value: value}(callData);\n    }\n\n    require(success, 'FAILED_ACTION_EXECUTION');\n  }\n\n  function _cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    bytes32 actionHash =\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\n    _queuedActions[actionHash] = false;\n  }\n\n  function _validateDelay(uint256 delay) internal view {\n    require(delay >= MINIMUM_DELAY, 'DELAY_SHORTER_THAN_MINIMUM');\n    require(delay <= MAXIMUM_DELAY, 'DELAY_LONGER_THAN_MAXIMUM');\n  }\n}"
    },
    {
      "filename": "contracts/interfaces/IBridgeExecutor.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.7.5;\npragma abicoder v2;\n\ninterface IBridgeExecutor {\n  enum ActionsSetState {Queued, Executed, Canceled, Expired}\n\n  struct ActionsSet {\n    uint256 id;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    bool[] withDelegatecalls;\n    uint256 executionTime;\n    bool executed;\n    bool canceled;\n  }\n\n  /**\n   * @dev emitted when an ActionsSet is received from the bridge message processor and queued\n   * @param id Id of the ActionsSet\n   * @param targets list of contracts called by each action's associated transaction\n   * @param values list of value in wei for each action's  associated transaction\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\n   * @param executionTime the time these actions can be executed\n   **/\n  event ActionsSetQueued(\n    uint256 id,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    bool[] withDelegatecalls,\n    uint256 executionTime\n  );\n\n  /**\n   * @dev emitted when an ActionsSet is executed successfully\n   * @param id Id of the ActionsSet\n   * @param initiatorExecution address that triggered the ActionsSet execution\n   **/\n  event ActionsSetExecuted(uint256 id, address indexed initiatorExecution);\n\n  /**\n   * @dev emitted when an ActionsSet is cancelled by the guardian\n   * @param id Id of the ActionsSet\n   **/\n  event ActionsSetCanceled(uint256 id);\n\n  /**\n   * @dev emitted when a new bridge is set\n   * @param bridge address of the new admin\n   * @param initiatorChange address of the creator of this change\n   **/\n  event NewBridge(address bridge, address indexed initiatorChange);\n\n  /**\n   * @dev emitted when a new admin is set\n   * @param newAdmin address of the new admin\n   **/\n  event NewAdmin(address newAdmin);\n\n  /**\n   * @dev emitted when a new delay (between queueing and execution) is set\n   * @param delay new delay\n   **/\n  event NewDelay(uint256 delay);\n\n  /**\n   * @dev Execute the ActionsSet\n   * @param actionsSetId id of the ActionsSet to execute\n   **/\n  function execute(uint256 actionsSetId) external payable;\n\n  /**\n   * @dev Cancel the ActionsSet\n   * @param actionsSetId id of the ActionsSet to cancel\n   **/\n  function cancel(uint256 actionsSetId) external;\n\n  /**\n   * @dev Set the delay\n   * @param delay delay between queue and execution of an ActionSet\n   **/\n  function setDelay(uint256 delay) external;\n\n  /**\n   * @dev Get the ActionsSet by Id\n   * @param actionsSetId id of the ActionsSet\n   * @return the ActionsSet requested\n   **/\n  function getActionsSetById(uint256 actionsSetId) external view returns (ActionsSet memory);\n\n  /**\n   * @dev Get the current state of an ActionsSet\n   * @param actionsSetId id of the ActionsSet\n   * @return The current state if the ActionsSet\n   **/\n  function getCurrentState(uint256 actionsSetId) external view returns (ActionsSetState);\n\n  /**\n   * @dev Returns whether an action (via actionHash) is queued\n   * @param actionHash hash of the action to be checked\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n   * @return true if underlying action of actionHash is queued\n   **/\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\n\n  /**\n   * @dev Getter of the delay between queuing and execution\n   * @return The delay in seconds\n   **/\n  function getDelay() external view returns (uint256);\n\n  /**\n   * @dev Getter of grace period constant\n   * @return grace period in seconds\n   **/\n  function GRACE_PERIOD() external view returns (uint256);\n\n  /**\n   * @dev Getter of minimum delay constant\n   * @return minimum delay in seconds\n   **/\n  function MINIMUM_DELAY() external view returns (uint256);\n\n  /**\n   * @dev Getter of maximum delay constant\n   * @return maximum delay in seconds\n   **/\n  function MAXIMUM_DELAY() external view returns (uint256);\n}"
    }
  ]
}