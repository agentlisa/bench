{
  "Title": "[M-04] MAX_SHORTFALL_WITHDRAW limit on BTP extraction is not enforced",
  "Content": "_Submitted by gellej, also found by gzeon_\n\nThe function `extractTokensForCollateralShortfall()` allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT.\n\nPresumably, this 50% limit is in place to prevent the owner from \"rug-pulling\" the sNote holders (or at least to give them a guarantee that their loss is limited to 50% of the underlying value).\n\nHowever, this limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.\n\nAs the contract does not enforce this limit, the bug requires stakers to trust the governance to not withdraw more than 50% of the underlying collateral. This represents a higher risk for the stakers, which may  also result in a larger discount on sNote wrt its BPT collateral (this is why I classified the bug as medium risk - users may lose value - not from an exploit, but from the lack of enforcing the 50% rule)\n\n### Proof of Concept\n\nSee above.\nThe code affected is here: <https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L100>\n\n#### Recommended Mitigation Steps\n\nRewrite the logic and enforce a limit during a time period - i.e. do not allow to withdraw over 50% *per week* (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2022-01-notional-findings/issues/209)**\n\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2022-01-notional-findings/issues/209#issuecomment-1040141667):**\n > Great find, 50% withdrawal limit can be bypassed by invoking the function multiple times.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-notional",
  "Code": [
    {
      "filename": "contracts/sNOTE.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {BoringOwnable} from \"./utils/BoringOwnable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport {IVault, IAsset} from \"interfaces/balancer/IVault.sol\";\nimport \"interfaces/balancer/IWeightedPool.sol\";\nimport \"interfaces/balancer/IPriceOracle.sol\";\n\ncontract sNOTE is ERC20Upgradeable, ERC20VotesUpgradeable, BoringOwnable, UUPSUpgradeable, ReentrancyGuard {\n    using SafeERC20 for ERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    ERC20 public immutable NOTE;\n    ERC20 public immutable BALANCER_POOL_TOKEN;\n    ERC20 public immutable WETH;\n    bytes32 public immutable NOTE_ETH_POOL_ID;\n\n    /// @notice Maximum shortfall withdraw of 50%\n    uint256 public constant MAX_SHORTFALL_WITHDRAW = 50;\n    uint256 public constant BPT_TOKEN_PRECISION = 1e18;\n\n    /// @notice Redemption window in seconds\n    uint256 public constant REDEEM_WINDOW_SECONDS = 3 days;\n\n    /// @notice Tracks an account's redemption window\n    struct AccountCoolDown {\n        uint32 redeemWindowBegin;\n        uint32 redeemWindowEnd;\n    }\n\n    /// @notice Number of seconds that need to pass before sNOTE can be redeemed\n    uint32 public coolDownTimeInSeconds;\n\n    /// @notice Mapping between sNOTE holders and their current cooldown status\n    mapping(address => AccountCoolDown) public accountCoolDown;\n\n    /// @notice Emitted when a cool down begins\n    event CoolDownStarted(address account, uint256 redeemWindowBegin, uint256 redeemWindowEnd);\n\n    /// @notice Emitted when a cool down ends\n    event CoolDownEnded(address account);\n\n    /// @notice Emitted when cool down time is updated\n    event GlobalCoolDownUpdated(uint256 newCoolDownTimeSeconds);\n\n    /// @notice Constructor sets immutable contract addresses\n    constructor(\n        IVault _balancerVault,\n        bytes32 _noteETHPoolId,\n        ERC20 _note,\n        ERC20 _weth\n    ) initializer { \n        // Validate that the pool exists\n        (address poolAddress, /* */) = _balancerVault.getPool(_noteETHPoolId);\n        require(poolAddress != address(0));\n\n        WETH = _weth;\n        NOTE = _note;\n        NOTE_ETH_POOL_ID = _noteETHPoolId;\n        BALANCER_VAULT = _balancerVault;\n        BALANCER_POOL_TOKEN = ERC20(poolAddress);\n    }\n\n    /// @notice Initializes sNOTE ERC20 metadata and owner\n    function initialize(\n        address _owner,\n        uint32 _coolDownTimeInSeconds\n    ) external initializer {\n        string memory _name = \"Staked NOTE\";\n        string memory _symbol = \"sNOTE\";\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n\n        coolDownTimeInSeconds = _coolDownTimeInSeconds;\n        owner = _owner;\n        NOTE.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /** Governance Methods **/\n\n    /// @notice Authorizes the DAO to upgrade this contract\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /// @notice Updates the required cooldown time to redeem\n    function setCoolDownTime(uint32 _coolDownTimeInSeconds) external onlyOwner {\n        coolDownTimeInSeconds = _coolDownTimeInSeconds;\n        emit GlobalCoolDownUpdated(_coolDownTimeInSeconds);\n    }\n\n    /// @notice Allows the DAO to extract up to 50% of the BPT tokens during a collateral shortfall event\n    function extractTokensForCollateralShortfall(uint256 requestedWithdraw) external nonReentrant onlyOwner {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 maxBPTWithdraw = (bptBalance * MAX_SHORTFALL_WITHDRAW) / 100;\n        // Do not allow a withdraw of more than the MAX_SHORTFALL_WITHDRAW percentage. Specifically don't\n        // revert here since there may be a delay between when governance issues the token amount and when\n        // the withdraw actually occurs.\n        uint256 bptExitAmount = requestedWithdraw > maxBPTWithdraw ? maxBPTWithdraw : requestedWithdraw;\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory minAmountsOut = new uint256[](2);\n        minAmountsOut[0] = 0;\n        minAmountsOut[1] = 0;\n\n        BALANCER_VAULT.exitPool(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            payable(owner), // Owner will receive the NOTE and WETH\n            IVault.ExitPoolRequest(\n                assets,\n                minAmountsOut,\n                abi.encode(\n                    IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                    bptExitAmount\n                ),\n                false // Don't use internal balances\n            )\n        );\n    }\n\n    /// @notice Allows the DAO to set the swap fee on the BPT\n    function setSwapFeePercentage(uint256 swapFeePercentage) external onlyOwner {\n        IWeightedPool(address(BALANCER_POOL_TOKEN)).setSwapFeePercentage(swapFeePercentage);\n    }\n\n    /** User Methods **/\n\n    /// @notice Mints sNOTE from the underlying BPT token.\n    /// @param bptAmount is the amount of BPT to transfer from the msg.sender.\n    function mintFromBPT(uint256 bptAmount) external nonReentrant {\n        // _mint logic requires that tokens are transferred first\n        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount);\n        _mint(msg.sender, bptAmount);\n    }\n\n    /// @notice Mints sNOTE from some amount of NOTE tokens.\n    /// @param noteAmount amount of NOTE to transfer into the sNOTE contract\n    function mintFromNOTE(uint256 noteAmount) external nonReentrant {\n        // Transfer the NOTE balance into sNOTE first\n        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(0));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = 0;\n        maxAmountsIn[1] = noteAmount;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    /// @notice Mints sNOTE from some amount of ETH\n    function mintFromETH() payable external nonReentrant {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(0));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = msg.value;\n        maxAmountsIn[1] = 0;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    /// @notice Mints sNOTE from some amount of WETH\n    /// @param wethAmount amount of WETH to transfer into the sNOTE contract\n    function mintFromWETH(uint256 wethAmount) external nonReentrant {\n        // Transfer the NOTE balance into sNOTE first\n        WETH.safeTransferFrom(msg.sender, address(this), wethAmount);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = wethAmount;\n        maxAmountsIn[1] = 0;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    function _mintFromAssets(IAsset[] memory assets, uint256[] memory maxAmountsIn) internal {\n        uint256 bptBefore = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        // Set msgValue when joining via ETH\n        uint256 msgValue = assets[0] == IAsset(address(0)) ? maxAmountsIn[0] : 0;\n\n        BALANCER_VAULT.joinPool{value: msgValue}(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            address(this), // sNOTE will receive the BPT\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(\n                    IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                    maxAmountsIn,\n                    0 // Accept however much BPT the pool will give us\n                ),\n                false // Don't use internal balances\n            )\n        );\n        uint256 bptAfter = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n        // Balancer pool token amounts must increase\n        _mint(msg.sender, bptAfter - bptBefore);\n    }\n\n    /// @notice Begins a cool down period for the sender, this is required to redeem tokens\n    function startCoolDown() external {\n        // Cannot start a cool down if there is already one in effect\n        _requireAccountNotInCoolDown(msg.sender);\n        uint256 redeemWindowBegin = block.timestamp + coolDownTimeInSeconds;\n        uint256 redeemWindowEnd = redeemWindowBegin + REDEEM_WINDOW_SECONDS;\n\n        accountCoolDown[msg.sender] = AccountCoolDown(_safe32(redeemWindowBegin), _safe32(redeemWindowEnd));\n\n        emit CoolDownStarted(msg.sender, redeemWindowBegin, redeemWindowEnd);\n    }\n\n    /// @notice Stops a cool down for the sender\n    function stopCoolDown() public {\n        // Reset the cool down back to zero so that the account must initiate it again to redeem\n        delete accountCoolDown[msg.sender];\n        emit CoolDownEnded(msg.sender);\n    }\n\n    /// @notice Redeems some amount of sNOTE to underlying BPT tokens (which can then be sold for\n    /// NOTE or ETH). An account must have passed its cool down expiration before they can redeem\n    /// @param sNOTEAmount amount of sNOTE to redeem\n    function redeem(uint256 sNOTEAmount) external nonReentrant {\n        AccountCoolDown memory coolDown = accountCoolDown[msg.sender];\n        require(sNOTEAmount <= balanceOf(msg.sender), \"Insufficient balance\");\n        require(\n            coolDown.redeemWindowBegin != 0 &&\n            coolDown.redeemWindowBegin < block.timestamp &&\n            block.timestamp < coolDown.redeemWindowEnd,\n            \"Not in Redemption Window\"\n        );\n\n        uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);\n        _burn(msg.sender, bptToRedeem);\n\n        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);\n    }\n\n    /** External View Methods **/\n\n    /// @notice Returns how many Balancer pool tokens an sNOTE token amount has a claim on\n    function getPoolTokenShare(uint256 sNOTEAmount) public view returns (uint256 bptClaim) {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        // BPT and sNOTE are both in 18 decimal precision so no conversion required\n        return (bptBalance * sNOTEAmount) / totalSupply();\n    }\n\n    /// @notice Returns the pool token share of a specific account\n    function poolTokenShareOf(address account) public view returns (uint256 bptClaim) {\n        return getPoolTokenShare(balanceOf(account));\n    }\n\n    /// @notice Calculates voting power for a given amount of sNOTE\n    /// @param sNOTEAmount amount of sNOTE to calculate voting power for\n    /// @return corresponding NOTE voting power\n    function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {\n        // Gets the BPT token price (in ETH)\n        uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);\n        // Gets the NOTE token price (in ETH)\n        uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);\n        \n        // Since both bptPrice and notePrice are denominated in ETH, we can use\n        // this formula to calculate noteAmount\n        // bptBalance * bptPrice = notePrice * noteAmount\n        // noteAmount = bptPrice/notePrice * bptBalance\n        uint256 priceRatio = bptPrice * 1e18 / notePrice;\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n        // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)\n        uint256 noteAmount = priceRatio * bptBalance * 80 / 100;\n\n        // Reduce precision down to 1e8 (NOTE token)\n        // priceRatio and bptBalance are both 1e18 (1e36 total)\n        // we divide by 1e28 to get to 1e8\n        noteAmount /= 1e28;\n\n        return (noteAmount * sNOTEAmount) / totalSupply();\n    }\n\n    /// @notice Calculates voting power for a given account\n    /// @param account a given sNOTE holding account\n    /// @return corresponding NOTE voting power\n    function votingPowerOf(address account) external view returns (uint256) {\n        return getVotingPower(balanceOf(account));\n    }\n\n    /** Internal Methods **/\n\n    function _requireAccountNotInCoolDown(address account) internal view {\n        AccountCoolDown memory coolDown = accountCoolDown[account];\n        // An account is in cool down if the redeem window has begun and the window end has not\n        // passed yet.\n        bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);\n        require(!isInCoolDown, \"Account in Cool Down\");\n    }\n\n    /// @notice Burns sNOTE tokens when they are redeemed\n    /// @param account account to burn tokens on\n    /// @param bptToRedeem the number of BPT tokens being redeemed by the account\n    function _burn(address account, uint256 bptToRedeem) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        uint256 poolTokenShare = poolTokenShareOf(account);\n        require(bptToRedeem <= poolTokenShare, \"Invalid Redeem Amount\");\n\n        // Burns the portion of the sNOTE corresponding to the bptToRedeem\n        uint256 sNOTEToBurn = balanceOf(account) * bptToRedeem / poolTokenShare;\n        // Handles event emission, balance update and total supply update\n        super._burn(account, sNOTEToBurn);\n    }\n\n    /// @notice Mints sNOTE tokens given a bptAmount\n    /// @param account account to mint tokens to\n    /// @param bptAmount the number of BPT tokens being minted by the account\n    function _mint(address account, uint256 bptAmount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        // Cannot mint if a cooldown is already in effect. If an account mints during a cool down period then they will\n        // be able to redeem the tokens immediately, bypassing the cool down.\n        _requireAccountNotInCoolDown(account);\n\n        // Immediately after minting, we need to satisfy the equality:\n        // (sNOTEToMint * bptBalance) / (totalSupply + sNOTEToMint) == bptAmount\n\n        // Rearranging to get sNOTEToMint on one side:\n        // (sNOTEToMint * bptBalance) = (totalSupply + sNOTEToMint) * bptAmount\n        // (sNOTEToMint * bptBalance) = totalSupply * bptAmount + sNOTEToMint * bptAmount\n        // (sNOTEToMint * bptBalance) - (sNOTEToMint * bptAmount) = totalSupply * bptAmount\n        // sNOTEToMint * (bptBalance - bptAmount) = totalSupply * bptAmount\n        // sNOTEToMint = (totalSupply * bptAmount) / (bptBalance - bptAmount)\n\n        // NOTE: at this point the BPT has already been transferred into the sNOTE contract, so this\n        // bptBalance amount includes bptAmount.\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 sNOTEToMint;\n        if (_totalSupply == 0) {\n            sNOTEToMint = bptAmount;\n        } else {\n            sNOTEToMint = (_totalSupply * bptAmount) / (bptBalance - bptAmount);\n        }\n\n        // Handles event emission, balance update and total supply update\n        super._mint(account, sNOTEToMint);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable) {\n        // Cannot send or receive tokens if a cool down is in effect or else accounts\n        // can bypass the cool down. It's not clear if sending tokens can be used to bypass\n        // the cool down but we restrict it here anyway, there's no clear use case for sending\n        // sNOTE tokens during a cool down.\n        if (to != address(0)) {\n            // Run these checks only when we are not burning tokens. (OZ ERC20 does not allow transfers\n            // to address(0), to == address(0) only when _burn is called).\n            _requireAccountNotInCoolDown(from);\n            _requireAccountNotInCoolDown(to);\n        }\n\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        // Moves sNOTE checkpoints\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _safe32(uint256 x) internal pure returns (uint32) {\n        require (x <= type(uint32).max);\n        return uint32(x);\n    }\n}"
    }
  ]
}