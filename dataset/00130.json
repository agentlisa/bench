{
  "Title": "Cache updated remaining amount to prevent extra storage read",
  "Content": "`FundraiserFacet::fund` should save the calculated [`remaining - amount`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/field/FundraiserFacet.sol#L124) then use it to set storage in [L125](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/field/FundraiserFacet.sol#L125) and to check for completion in [L128](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/field/FundraiserFacet.sol#L128); this prevents re-reading storage again in L128. One easy solution is to reuse the existing `remaining` stack variable:\n\n```solidity\nremaining = remaining - amount; // Note: SafeMath is redundant here.\ns.fundraisers[id].remaining = remaining;\nemit FundFundraiser(msg.sender, id, amount);\n\n// If completed, transfer tokens to payee and emit an event\nif (remaining == 0) {\n    _completeFundraiser(id);\n}\n```\n\nConsider this simplified example using Foundry:\n```solidity\nuint256 private s_remainingDebt = 10;\n\nfunction _onDebtRepayment() private {}\n\nfunction testRemaining1() public {\n    uint256 repaymentAmount = 10;\n\n    // update storage\n    s_remainingDebt -= repaymentAmount;\n\n    // use storage read for check\n    if(s_remainingDebt == 0) {\n        _onDebtRepayment();\n    }\n\n    assert(s_remainingDebt == 0);\n}\n\nfunction testRemaining2() public {\n    uint256 repaymentAmount = 10;\n\n    // cache remaining debt\n    uint256 remainingDebt = s_remainingDebt - repaymentAmount;\n    // update storage\n    s_remainingDebt = remainingDebt;\n\n    // use cache for check\n    if(remainingDebt == 0) {\n        _onDebtRepayment();\n    }\n\n    assert(s_remainingDebt == 0);\n}\n\n[PASS] testRemaining1() (gas: 621)\n[PASS] testRemaining2() (gas: 563)\n```",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/field/FundraiserFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../ReentrancyGuard.sol\";\nimport \"contracts/libraries/LibDiamond.sol\";\nimport \"contracts/libraries/LibDibbler.sol\";\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport {C} from \"contracts/C.sol\";\n\n/**\n * @title Fundraiser Facet\n * @author Publius\n * @notice Handles the creation, funding, and completion of a Fundraiser.\n */\ncontract FundraiserFacet is ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when a Fundraiser is created.\n     * @param id The Fundraiser ID\n     * @param payee The address to which funds are delivered\n     * @param token The address of the token that can be sent to the Fundraiser in exchange for Pods\n     * @param amount The amount of `token` that is being raised\n     */\n    event CreateFundraiser(\n        uint32 indexed id,\n        address payee,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @notice Emitted when a Farmer calls {fund}.\n     * @param account The address of the Farmer\n     * @param id The Fundraiser ID\n     * @param amount The amount of `token` that `account` provided\n     */\n    event FundFundraiser(\n        address indexed account,\n        uint32 indexed id,\n        uint256 amount\n    );\n    \n    /**\n     * @notice Emitted when a Fundraiser is fully funded.\n     * @param id The Fundraiser ID\n     */\n    event CompleteFundraiser(uint32 indexed id);\n\n    //////////////////// FUNDRAISE ////////////////////\n\n    /**\n     * @notice Create a Fundraiser.\n     * @param payee The address to which funds are delivered upon {completeFundraiser}\n     * @param token The address of the token that can be sent to the Fundraiser in exchange for Pods\n     * @param amount The amount of `token` that is being raised\n     */\n    function createFundraiser(\n        address payee,\n        address token,\n        uint256 amount\n    ) external payable {\n        LibDiamond.enforceIsOwnerOrContract();\n\n        // The {FundraiserFacet} was initially created to support USDC, which has the\n        // same number of decimals as Bean (6). Fundraisers created with tokens measured\n        // to a different number of decimals are not yet supported.\n        if (ERC20(token).decimals() != 6) {\n            revert(\"Fundraiser: Token decimals\");\n        }\n        \n        uint32 id = s.fundraiserIndex;\n        s.fundraisers[id].token = token;\n        s.fundraisers[id].remaining = amount;\n        s.fundraisers[id].total = amount;\n        s.fundraisers[id].payee = payee;\n        s.fundraisers[id].start = block.timestamp;\n        s.fundraiserIndex = id + 1;\n\n        // Mint Beans to pay for the Fundraiser. During {fund}, 1 Bean is burned\n        // for each `token` provided to the Fundraiser.\n        // Adjust `amount` based on `token` decimals to support tokens with different decimals.\n        C.bean().mint(address(this), amount);\n\n        emit CreateFundraiser(id, payee, token, amount);\n    }\n\n    /**\n     * @notice Fund a Fundraiser.\n     * @param id The Fundraiser ID\n     * @param amount Amount of `fundraisers[id].token` to provide\n     * @param mode Balance to spend tokens from\n     * @dev This assumes that `.token` is measured to the same number of\n     * decimals as Bean (1e6). A safeguard is applied during {createFundraiser}.\n     */\n    function fund(\n        uint32 id,\n        uint256 amount,\n        LibTransfer.From mode\n    ) external payable nonReentrant returns (uint256) {\n        uint256 remaining = s.fundraisers[id].remaining;\n        \n        // Check amount remaining and constrain\n        require(remaining > 0, \"Fundraiser: completed\");\n        if (amount > remaining) {\n            amount = remaining;\n        }\n\n        // Transfer tokens from msg.sender -> Beanstalk\n        amount = LibTransfer.receiveToken(\n            IERC20(s.fundraisers[id].token),\n            amount,\n            msg.sender,\n            mode\n        );\n        s.fundraisers[id].remaining = remaining - amount; // Note: SafeMath is redundant here.\n        emit FundFundraiser(msg.sender, id, amount);\n\n        // If completed, transfer tokens to payee and emit an event\n        if (s.fundraisers[id].remaining == 0) {\n            _completeFundraiser(id);\n        }\n\n        // When the Fundraiser was initialized, Beanstalk minted Beans. \n        C.bean().burn(amount);\n\n        // Calculate the number of Pods to Sow.\n        // Fundraisers bypass Morning Auction behavior and Soil requirements,\n        // calculating return only based on the current `s.w.t`.\n        uint256 pods = LibDibbler.beansToPods(\n            amount, \n            uint256(s.w.t).mul(LibDibbler.TEMPERATURE_PRECISION)\n        ); \n\n        // Sow for Pods and return the number of Pods received.\n        return LibDibbler.sowNoSoil(msg.sender, amount, pods);\n    }\n\n    /**\n     * @dev Transfer fundraised tokens from Beanstalk to the fundraiser payee.\n     */\n    function _completeFundraiser(uint32 id) internal {\n        // Prevent reentrancy during fundraiser; must last more than one block.\n        // Recommended by Omniscia @ FFE-01M.\n        require(\n            block.timestamp != s.fundraisers[id].start,\n            \"Fundraiser: start block\"\n        );\n\n        IERC20(s.fundraisers[id].token).safeTransfer(\n            s.fundraisers[id].payee,\n            s.fundraisers[id].total\n        );\n\n        emit CompleteFundraiser(id);\n    }\n\n    //////////////////// GETTERS ////////////////////\n\n    function remainingFunding(uint32 id) public view returns (uint256) {\n        return s.fundraisers[id].remaining;\n    }\n\n    function totalFunding(uint32 id) public view returns (uint256) {\n        return s.fundraisers[id].total;\n    }\n\n    function fundingToken(uint32 id) public view returns (address) {\n        return s.fundraisers[id].token;\n    }\n\n    function fundraiser(uint32 id)\n        public\n        view\n        returns (Storage.Fundraiser memory)\n    {\n        return s.fundraisers[id];\n    }\n\n    function numberOfFundraisers() public view returns (uint32) {\n        return s.fundraiserIndex;\n    }\n}"
    }
  ]
}