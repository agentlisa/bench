{
  "Title": "Magic numbers are used",
  "Content": "Although constants are generally used correctly throughout the codebase, there are a few occurrences of literal values being used with unexplained meaning inside of `ETHAdapter`. For example, the following blocks use hardcoded values:\n\n\n* In the constructor, the pool’s [`coins`](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L24) function is called with arguments `0` and `1`.\n* In the functions `convertToETH` and `convertToSTETH`, the pool’s [`get_dy`](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L28-L34) function is called with arguments `0` and `1` with no explanation.\n* In the `deposit` function, the pool’s [`exchange`](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L42) function is called with arguments `0` and `1` without explanation.\n\n\nTo improve the code’s readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. Consider adding an inline comment explaining how the magic numbers are calculated or why they are chosen for complex values.\n\n\n**Update:** *Resolved in [PR#103](https://github.com/pods-finance/yield-contracts/pull/103), with commit `87e7de33e0a7a699263624641305a8e06ec178b2` being the last one added.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/proxy/ETHAdapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ICurvePool } from \"../interfaces/ICurvePool.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ETHAdapter {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    ICurvePool public immutable pool;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant STETH_ADDRESS = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    error ETHAdapter__IncompatibleVault();\n    error ETHAdapter__IncompatiblePool();\n\n    constructor(ICurvePool _pool) {\n        if (_pool.coins(0) != ETH_ADDRESS || _pool.coins(1) != STETH_ADDRESS) revert ETHAdapter__IncompatiblePool();\n        pool = _pool;\n    }\n\n    function convertToSTETH(uint256 ethAmount) external view returns (uint256) {\n        return pool.get_dy(0, 1, ethAmount);\n    }\n\n    function convertToETH(uint256 stETHAmount) external view returns (uint256) {\n        return pool.get_dy(1, 0, stETHAmount);\n    }\n\n    function deposit(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) external payable returns (uint256 shares) {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        uint256 assets = pool.exchange{ value: msg.value }(0, 1, msg.value, minOutput);\n        IERC20(vault.asset()).safeApprove(address(vault), assets);\n        return vault.deposit(assets, receiver);\n    }\n\n    function redeem(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 assets) {\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function redeemWithPermit(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 assets) {\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdraw(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 shares) {\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdrawWithPermit(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        shares = vault.convertToShares(assets);\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    /* We need this default function because this contract will\n        receive ETH from the Curve pool\n    */\n    receive() external payable {}\n\n    function _returnETH(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) internal {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        IERC20 asset = IERC20(vault.asset());\n\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(pool), balance);\n        pool.exchange(1, 0, balance, minOutput);\n\n        payable(receiver).sendValue(address(this).balance);\n    }\n}"
    },
    {
      "filename": "contracts/proxy/ETHAdapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ICurvePool } from \"../interfaces/ICurvePool.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ETHAdapter {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    ICurvePool public immutable pool;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant STETH_ADDRESS = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    error ETHAdapter__IncompatibleVault();\n    error ETHAdapter__IncompatiblePool();\n\n    constructor(ICurvePool _pool) {\n        if (_pool.coins(0) != ETH_ADDRESS || _pool.coins(1) != STETH_ADDRESS) revert ETHAdapter__IncompatiblePool();\n        pool = _pool;\n    }\n\n    function convertToSTETH(uint256 ethAmount) external view returns (uint256) {\n        return pool.get_dy(0, 1, ethAmount);\n    }\n\n    function convertToETH(uint256 stETHAmount) external view returns (uint256) {\n        return pool.get_dy(1, 0, stETHAmount);\n    }\n\n    function deposit(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) external payable returns (uint256 shares) {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        uint256 assets = pool.exchange{ value: msg.value }(0, 1, msg.value, minOutput);\n        IERC20(vault.asset()).safeApprove(address(vault), assets);\n        return vault.deposit(assets, receiver);\n    }\n\n    function redeem(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 assets) {\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function redeemWithPermit(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 assets) {\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdraw(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 shares) {\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdrawWithPermit(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        shares = vault.convertToShares(assets);\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    /* We need this default function because this contract will\n        receive ETH from the Curve pool\n    */\n    receive() external payable {}\n\n    function _returnETH(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) internal {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        IERC20 asset = IERC20(vault.asset());\n\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(pool), balance);\n        pool.exchange(1, 0, balance, minOutput);\n\n        payable(receiver).sendValue(address(this).balance);\n    }\n}"
    },
    {
      "filename": "contracts/proxy/ETHAdapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ICurvePool } from \"../interfaces/ICurvePool.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ETHAdapter {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    ICurvePool public immutable pool;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant STETH_ADDRESS = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    error ETHAdapter__IncompatibleVault();\n    error ETHAdapter__IncompatiblePool();\n\n    constructor(ICurvePool _pool) {\n        if (_pool.coins(0) != ETH_ADDRESS || _pool.coins(1) != STETH_ADDRESS) revert ETHAdapter__IncompatiblePool();\n        pool = _pool;\n    }\n\n    function convertToSTETH(uint256 ethAmount) external view returns (uint256) {\n        return pool.get_dy(0, 1, ethAmount);\n    }\n\n    function convertToETH(uint256 stETHAmount) external view returns (uint256) {\n        return pool.get_dy(1, 0, stETHAmount);\n    }\n\n    function deposit(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) external payable returns (uint256 shares) {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        uint256 assets = pool.exchange{ value: msg.value }(0, 1, msg.value, minOutput);\n        IERC20(vault.asset()).safeApprove(address(vault), assets);\n        return vault.deposit(assets, receiver);\n    }\n\n    function redeem(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 assets) {\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function redeemWithPermit(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 assets) {\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdraw(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 shares) {\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdrawWithPermit(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        shares = vault.convertToShares(assets);\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    /* We need this default function because this contract will\n        receive ETH from the Curve pool\n    */\n    receive() external payable {}\n\n    function _returnETH(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) internal {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        IERC20 asset = IERC20(vault.asset());\n\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(pool), balance);\n        pool.exchange(1, 0, balance, minOutput);\n\n        payable(receiver).sendValue(address(this).balance);\n    }\n}"
    }
  ]
}