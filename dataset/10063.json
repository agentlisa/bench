{
  "Title": "[M-04] Unlinked address can link immediately again",
  "Content": "_Submitted by gpersoon_\n\n#### Impact\n\nAfter a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission.\nThe address that is just unlinked can call linkAddress(masterAddress) which will execute because pendingLinkAddresses is still set.\nAssuming the master has unlinked for a good reason it is unwanted to be able to be linked again without any permission from the master.\n\nNote: a master can prevent this by calling cancelAddressLinkingRequest(), but this doesn't seem logical to do\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Verification/Verification.sol#L129-L154>\n\n```solidity\n    function unlinkAddress(address _linkedAddress) external {\n        address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;\n        require(_linkedTo != address(0), 'V:UA-Address not linked');\n        require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');\n        delete linkedAddresses[_linkedAddress]; \n       ...\n}\n    function linkAddress(address _masterAddress) external {\n        require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)\n        require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)\n        _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset\n    }\n\nfunction cancelAddressLinkingRequest(address _linkedAddress) external {\n        ... \n        delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset\n```\n\n#### Recommended Mitigation Steps\n\nAdd something like to following at the end of linkAddress:\n\n```solidity\ndelete pendingLinkAddresses[msg.sender][_masterAddress]; \n```\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/54)**\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2021-12-sublime-contest",
  "Code": [
    {
      "filename": "contracts/Verification/Verification.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/cryptography/ECDSA.sol';\nimport '../interfaces/IVerification.sol';\n\n/// @title Contract that handles linking identity of user to address\ncontract Verification is Initializable, IVerification, OwnableUpgradeable {\n    struct LinkedAddress {\n        address masterAddress;\n        uint256 activatesAt;\n    }\n\n    /// @notice Delay in seconds after which addresses are activated once registered or linked\n    uint256 public activationDelay;\n\n    /// @notice Tells whether a given verifier is valid\n    /// @dev Mapping that stores valid verifiers as added by admin. verifier -> true/false\n    /// @return boolean that represents if the specified verifier is valid\n    mapping(address => bool) public verifiers;\n\n    /// @notice Maps masterAddress with the verifier that was used to verify it and the time when master address is active\n    /// @dev Mapping is from masterAddress -> verifier -> activationTime\n    /// @return Verifier used to verify the given master address\n    mapping(address => mapping(address => uint256)) public masterAddresses;\n\n    /// @notice Maps linkedAddresses with the master address and activation time\n    /// @dev Mapping is linkedAddress -> (MasterAddress, activationTimestamp)\n    /// @return Returns the master address and activation time for the linkedAddress\n    mapping(address => LinkedAddress) public linkedAddresses;\n\n    /// @notice Maps address to link with the master addres\n    /// @dev Mapping is linkedAddress -> MasterAddress -> isPending\n    /// @return Returns if linkedAddress has a pending request from master address\n    mapping(address => mapping(address => bool)) public pendingLinkAddresses;\n\n    /// @notice Prevents anyone other than a valid verifier from calling a function\n    modifier onlyVerifier() {\n        require(verifiers[msg.sender], 'Invalid verifier');\n        _;\n    }\n\n    /// @notice Initializes the variables of the contract\n    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy\n    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid\n    /// @param _activationDelay Delay in seconds after which addresses are registered or linked\n    function initialize(address _admin, uint256 _activationDelay) external initializer {\n        super.__Ownable_init();\n        super.transferOwnership(_admin);\n        _updateActivationDelay(_activationDelay);\n    }\n\n    /// @notice owner can update activation delay\n    /// @param _activationDelay updated value of activation delay for registered/linking addresses in seconds\n    function updateActivationDelay(uint256 _activationDelay) external onlyOwner {\n        _updateActivationDelay(_activationDelay);\n    }\n\n    function _updateActivationDelay(uint256 _activationDelay) internal {\n        activationDelay = _activationDelay;\n        emit ActivationDelayUpdated(_activationDelay);\n    }\n\n    /// @notice owner can add new verifier\n    /// @dev Verifier can add master address or remove addresses added by it\n    /// @param _verifier Address of the verifier contract\n    function addVerifier(address _verifier) external onlyOwner {\n        require(_verifier != address(0), 'V:AV-Verifier cant be 0 address');\n        require(!verifiers[_verifier], 'V:AV-Verifier exists');\n        verifiers[_verifier] = true;\n        emit VerifierAdded(_verifier);\n    }\n\n    /// @notice owner can remove exisiting verifier\n    /// @dev Verifier can add master address or remove addresses added by it\n    /// @param _verifier Address of the verifier contract\n    function removeVerifier(address _verifier) external onlyOwner {\n        require(verifiers[_verifier], 'V:AV-Verifier doesnt exist');\n        delete verifiers[_verifier];\n        emit VerifierRemoved(_verifier);\n    }\n\n    /// @notice Only verifier can add register master address\n    /// @dev Multiple accounts can be linked to master address to act on behalf. Master address can be registered by multiple verifiers\n    /// @param _masterAddress address which is registered as verified\n    /// @param _isMasterLinked boolean which specifies if the masterAddress has to be added as a linked address\n    ///                         _isMasterLinked is used to support users who want to keep the master address as a cold wallet for security\n    function registerMasterAddress(address _masterAddress, bool _isMasterLinked) external override onlyVerifier {\n        require(masterAddresses[_masterAddress][msg.sender] == 0, 'V:RMA-Already registered');\n        uint256 _masterAddressActivatesAt = block.timestamp + activationDelay;\n        masterAddresses[_masterAddress][msg.sender] = _masterAddressActivatesAt;\n        emit UserRegistered(_masterAddress, msg.sender, _masterAddressActivatesAt);\n\n        if (_isMasterLinked) {\n            _linkAddress(_masterAddress, _masterAddress);\n        }\n    }\n\n    /// @notice Master address can be unregistered by registered verifier or owner\n    /// @dev unregistering master address doesn't affect linked addreses mapping to master address, though they would not be verified by this verifier anymore\n    /// @param _masterAddress address which is being unregistered\n    /// @param _verifier verifier address from which master address is unregistered\n    function unregisterMasterAddress(address _masterAddress, address _verifier) external override {\n        if (msg.sender != super.owner()) {\n            require(masterAddresses[_masterAddress][msg.sender] != 0 && msg.sender == _verifier, 'V:UMA-Invalid verifier');\n        }\n        delete masterAddresses[_masterAddress][_verifier];\n        emit UserUnregistered(_masterAddress, _verifier, msg.sender);\n    }\n\n    function _linkAddress(address _linked, address _master) internal {\n        uint256 _linkedAddressActivatesAt = block.timestamp + activationDelay;\n        linkedAddresses[_linked] = LinkedAddress(_master, _linkedAddressActivatesAt);\n        emit AddressLinked(_linked, _master, _linkedAddressActivatesAt);\n    }\n\n    /// @notice Used by master address to request linking another address to it\n    /// @dev only master address can initiate linking of another address\n    /// @param _linkedAddress address which is to be linked\n    function requestAddressLinking(address _linkedAddress) external {\n        require(linkedAddresses[_linkedAddress].masterAddress == address(0), 'V:LA-Address already linked');\n        pendingLinkAddresses[_linkedAddress][msg.sender] = true;\n        emit AddressLinkingRequested(_linkedAddress, msg.sender);\n    }\n\n    /// @notice Used by master address to cancel request linking another address to it\n    /// @param _linkedAddress address which is to be linked\n    function cancelAddressLinkingRequest(address _linkedAddress) external {\n        require(pendingLinkAddresses[_linkedAddress][msg.sender], 'V:CALR-No pending request');\n        delete pendingLinkAddresses[_linkedAddress][msg.sender];\n        emit AddressLinkingRequestCancelled(_linkedAddress, msg.sender);\n    }\n\n    /// @notice Link an address with a master address\n    /// @dev Master address to which the address is being linked need not be verified\n    ///     link address can only accept the request made by a master address, but can't initiate a linking request\n    /// @param _masterAddress master address to link to\n    function linkAddress(address _masterAddress) external {\n        require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');\n        require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');\n        _linkAddress(msg.sender, _masterAddress);\n    }\n\n    /// @notice Unlink address with master address\n    /// @dev a single address can be linked to only one master address\n    /// @param _linkedAddress Address that is being unlinked\n    function unlinkAddress(address _linkedAddress) external {\n        address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;\n        require(_linkedTo != address(0), 'V:UA-Address not linked');\n        require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');\n        delete linkedAddresses[_linkedAddress];\n        emit AddressUnlinked(_linkedAddress, _linkedTo);\n    }\n\n    /// @notice User to verify if an address is linked to a master address that is registered with verifier\n    /// @dev view function\n    /// @param _user address which has to be checked if mapped against a verified master address\n    /// @param _verifier verifier with which master address has to be verified\n    /// @return if the user is linke dto a registered master address\n    function isUser(address _user, address _verifier) external view override returns (bool) {\n        LinkedAddress memory _linkedAddress = linkedAddresses[_user];\n        uint256 _masterActivatesAt = masterAddresses[_linkedAddress.masterAddress][_verifier];\n        if (\n            _linkedAddress.masterAddress == address(0) ||\n            _linkedAddress.activatesAt > block.timestamp ||\n            _masterActivatesAt == 0 ||\n            _masterActivatesAt > block.timestamp\n        ) {\n            return false;\n        }\n        return true;\n    }\n}"
    }
  ]
}