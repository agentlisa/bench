{
  "Title": "H-11: Vault's withdrawFromProtocol incorrectly scales amount to be withdrawn",
  "Content": "# Issue H-11: Vault's withdrawFromProtocol incorrectly scales amount to be withdrawn \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/132 \n\n## Found by \nhyh\n\n## Summary\n\nwithdrawFromProtocol() converts its `_amount` argument from `vaultCurrency` into `LP Token` decimals and use the resulting amount in a Provider calcShares() call, while all Providers expect input amount for calcShares() to have underlying token decimals.\n\n## Vulnerability Detail\n\nSuppose `vaultCurrency` and Provider's underlying currency is USDC, Provider is CompoundProvider (`compound_usdc_01`).\n\nwithdrawFromProtocol() being called with `10^12` amount is a request to withdraw `10^6 USDC`, while CompoundProvider's calcShares() will be called with `(_amount * protocol.uScale) / uScale = 10^12 * 10^8 / 10^6 = 10^14` (cUSDC is 8 decimals token), which it will treat as USDC amount. I.e. the 100x amount will be requested to be withdrawn.\n\n## Impact\n\nWithdrawal from a protocol is a base functionality of the Vault and it will malfunction whenever LP Token decimals and underlying decimals aren't equal, which is a frequent case. For example, Compound and Idle LP Tokens have own decimals not corresponding to underlying decimals (fixed at 8 and 18).\n\nNet impact is massive Vault misbalancing, which will alter the effective distribution and shift actual results far from expected, leading to losses for protocol depositors in a substantial enough number of cases.\n\n## Code Snippet\n\nwithdrawFromProtocol's input argument `_amount` is in vaultCurrency, and `_amount = (_amount * protocol.uScale) / uScale` reset decimals to be LP Token's decimals:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L303-L316\n\n```solidity\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n```\n\nAs `protocol.uScale` is `10**LP_Token.decimals`:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Interfaces/IController.sol#L6-L11\n\n```solidity\n  struct ProtocolInfoS {\n    address LPToken;\n    address provider;\n    address underlying; // address of underlying token of the protocol eg USDC\n    uint256 uScale; // uScale of protocol LP Token\n  }\n```\n\nBut all calcShares() methods expect amount in underlying token, not in LP token:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/AaveProvider.sol#L88-L96\n\n```solidity\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev Aave exchangeRate is 1\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _aToken Address of protocol LP Token eg aUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _aToken) external view override returns (uint256) {\n    uint256 shares = _amount / exchangeRate(_aToken);\n    return shares;\n  }\n```\n\n...\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L102-L111\n\n```solidity\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n```\n\nLP token decimals and underlying decimals can drastically differ.\n\nFor example, Compound's cDAI has 8 decimals:\n\nhttps://etherscan.io/token/0x5d3a536e4d6dbd6114cc1ead35777bab948e3643\n\nWhile DAI has 18:\n\nhttps://etherscan.io/token/0x6b175474e89094c44da98b954eedeac495271d0f\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAs LP token and underlying token differs in general, consider introducing underlying token decimals as an additional variable in `ProtocolInfoS` structure, populating and using it for decimals conversion to obtain the resulting Provider's underlying amount needed for a number of shares request.\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nduplicate with #202 \n\n**dmitriia**\n\nEscalate for 10 USDC\n202 and this aren't duplicates.\n\n202 deals with CompoundProvider's treatment of cToken exchange rate in balanceUnderlying() and calcShares().\n\nThis issue is about *calling* of all Providers' calcShares() with LP Token decimals scaled amount instead of underlying token decimals scaled amount in Vault's withdrawFromProtocol(). Notice that this requires another fix, i.e. correcting balanceUnderlying() and calcShares() will fix 202, but here IController's `ProtocolInfoS` needs to be extended and underlying token decimals be used in withdrawFromProtocol().\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> 202 and this aren't duplicates.\n> \n> 202 deals with CompoundProvider's treatment of cToken exchange rate in balanceUnderlying() and calcShares().\n> \n> This issue is about *calling* of all Providers' calcShares() with LP Token decimals scaled amount instead of underlying token decimals scaled amount in Vault's withdrawFromProtocol(). Notice that this requires another fix, i.e. correcting balanceUnderlying() and calcShares() will fix 202, but here IController's `ProtocolInfoS` needs to be extended and underlying token decimals be used in withdrawFromProtocol().\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nNot a duplicate of #202 \nConsidering this issue a valid separate issue\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Not a duplicate of #202 \n> Considering this issue a valid separate issue\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\ncontract Vault is ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // state 0 Rebalance done and ready for xController to rebalance again\n  // state 1 Allocation amount received and ready to send funds over to xController\n  // state 2 Allocation amount 0 received => will receive funds from xController\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\n  enum State {\n    Idle,\n    PushedUnderlying,\n    SendingFundsXChain,\n    WaitingForFunds,\n    RebalanceVault,\n    SendRewardsPerToken\n  }\n\n  IERC20 internal vaultCurrency;\n  IController internal controller;\n  State public state;\n\n  bool public deltaAllocationsReceived;\n\n  address private dao;\n  address private guardian;\n  address public vaultCurrencyAddr;\n  address public xController;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee;\n  uint256 public rebalancingPeriod;\n  uint256 public uScale;\n  uint256 public minimumPull;\n  int256 public marginScale;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal reservedFunds;\n\n  // total number of allocated Derby tokens currently\n  int256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  string internal stateError = \"Wrong state\";\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => int256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n\n  /// @notice Withdraw from protocols on shortage in Vault\n  /// @dev Keeps on withdrawing until the Vault balance > _value\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n\n  /// @notice Step 7 trigger, end; Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(state == State.RebalanceVault, stateError);\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n\n    rebalancingPeriod++;\n\n    claimTokens();\n    settleDeltaAllocation();\n\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n    setTotalUnderlying();\n\n    if (reservedFunds > vaultCurrency.balanceOf(address(this))) pullFunds(reservedFunds);\n\n    state = State.SendRewardsPerToken;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @return underlying totalUnderlying - liquidityVault\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying +\n      getVaultBalance() -\n      reservedFunds;\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\n    return totalUnderlyingInclVaultBalance - liquidityVault;\n  }\n\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\n  function settleDeltaAllocation() internal {\n    totalAllocatedTokens += deltaAllocatedTokens;\n    deltaAllocatedTokens = 0;\n  }\n\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\n  function rebalanceCheckProtocols(\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      storePriceAndRewards(_newTotalUnderlying, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n\n      int256 amountToDeposit = amountToProtocol - int(currentBalance);\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - uint(amountToProtocol) : 0;\n\n      if (amountToDeposit > marginScale) protocolToDeposit[i] = uint256(amountToDeposit);\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0)\n        withdrawFromProtocol(i, amountToWithdraw);\n    }\n\n    return protocolToDeposit;\n  }\n\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @param _protocol Protocol id number\n  /// @return amountToProtocol amount to deposit or withdraw to protocol\n  function calcAmountToProtocol(\n    uint256 _totalUnderlying,\n    uint256 _protocol\n  ) internal view returns (int256 amountToProtocol) {\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\n    else\n      amountToProtocol =\n        (int(_totalUnderlying) * currentAllocations[_protocol]) /\n        totalAllocatedTokens;\n  }\n\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault.\n  /// @param _protocolId Protocol id number.\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n  }\n\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\n\n    rewards = new int[](latestId);\n    for (uint256 i = 0; i < latestId; i++) {\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\n    }\n  }\n\n  /// @notice Helper function to set allocations\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\n  function setAllocation(uint256 _i) internal {\n    currentAllocations[_i] += deltaAllocations[_i];\n    deltaAllocations[_i] = 0;\n    require(currentAllocations[_i] >= 0, \"Allocation underflow\");\n  }\n\n  /// @notice Helper function so the rebalance will execute all withdrawals first\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      uint256 amount = protocolToDeposit[i];\n      if (amount == 0) continue;\n      depositInProtocol(i, amount);\n    }\n  }\n\n  /// @notice Deposit amount to underlying protocol\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to deposit\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\n        uScale,\n        controller.underlyingUScale(protocol.underlying),\n        controller.getCurveParams(address(vaultCurrency), protocol.underlying)\n      );\n    }\n\n    IERC20(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\n  }\n\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n\n    if (shares == 0) return;\n    if (balance < shares) shares = balance;\n\n    IERC20(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\n    uint256 amountReceived = IProvider(protocol.provider).withdraw(\n      shares,\n      protocol.LPToken,\n      protocol.underlying\n    );\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(amountReceived, protocol.underlying, address(vaultCurrency)),\n        controller.underlyingUScale(protocol.underlying),\n        uScale,\n        controller.getCurveParams(protocol.underlying, address(vaultCurrency))\n      );\n    }\n  }\n\n  /// @notice Set total balance in VaultCurrency in all underlying protocols\n  function setTotalUnderlying() public {\n    uint totalUnderlying;\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      totalUnderlying += balanceUnderlying(i);\n    }\n    savedTotalUnderlying = totalUnderlying;\n  }\n\n  /// @notice Get balance in VaultCurrency in underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return Balance in VaultCurrency e.g USDC\n  function balanceUnderlying(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 underlyingBalance = (IProvider(protocol.provider).balanceUnderlying(\n      address(this),\n      protocol.LPToken\n    ) * uScale) / protocol.uScale;\n    return underlyingBalance;\n  }\n\n  /// @notice Calculates how many shares are equal to the amount in vault currency\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _protocolNum, uint256 _amount) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 shares = IProvider(protocol.provider).calcShares(\n      (_amount * protocol.uScale) / uScale,\n      protocol.LPToken\n    );\n\n    return shares;\n  }\n\n  /// @notice Get price for underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return protocolPrice Price per lp token\n  function price(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    return IProvider(protocol.provider).exchangeRate(protocol.LPToken);\n  }\n\n  /// @notice Set the delta allocated tokens by game contract\n  /// @dev Allocation can be negative\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @param _allocation Delta allocation in tokens\n  function setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), \"Protocol on blacklist\");\n    deltaAllocations[_protocolNum] += _allocation;\n    deltaAllocatedTokens += _allocation;\n  }\n\n  /// @notice Harvest extra tokens from underlying protocols\n  /// @dev Loops over protocols in ETF and check if they are claimable in controller contract\n  function claimTokens() public {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      bool claim = controller.claim(vaultNumber, i);\n      if (claim) {\n        address govToken = controller.getGovToken(vaultNumber, i);\n        uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));\n        Swap.swapTokensMulti(\n          Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),\n          controller.getUniswapParams(),\n          false\n        );\n      }\n    }\n  }\n\n  function getVaultBalance() public view returns (uint256) {\n    return vaultCurrency.balanceOf(address(this));\n  }\n\n  /// @notice Checks if a rebalance is needed based on the set interval\n  /// @return bool True of rebalance is needed, false if not\n  function rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /// @notice Getter for guardian address\n  function getGuardian() public view returns (address) {\n    return guardian;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Set the performanceFee, the percentage of the yield that goes to the game players.\n  /// @dev The actual performanceFee could be a bit more or a bit less than the performanceFee set here due to approximations in the game.\n  /// @param _performanceFee Value at which to set the performanceFee.\n  function setPerformanceFee(uint256 _performanceFee) external onlyDao {\n    require(_performanceFee <= 100);\n    performanceFee = _performanceFee;\n  }\n\n  /// @notice Set the governance address\n  /// @param _dao New address of the governance / DAO\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Set minimum interval for the rebalance function\n  /// @param _timestampInternal UNIX timestamp\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyGuardian {\n    rebalanceInterval = _timestampInternal;\n  }\n\n  /// @notice The DAO should be able to blacklist protocols, the funds should be sent to the vault.\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  function blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\n    uint256 balanceProtocol = balanceUnderlying(_protocolNum);\n    currentAllocations[_protocolNum] = 0;\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\n    savedTotalUnderlying -= balanceProtocol;\n    withdrawFromProtocol(_protocolNum, balanceProtocol);\n  }\n\n  /// @notice Set the marginScale, the threshold used for deposits and withdrawals.\n  /// @notice If the threshold is not met the deposit/ withdrawal is not executed.\n  /// @dev Take into account the uScale (scale of the underlying).\n  /// @param _marginScale Value at which to set the marginScale.\n  function setMarginScale(int256 _marginScale) external onlyGuardian {\n    marginScale = _marginScale;\n  }\n\n  /// @notice Set the liquidityPerc, the amount of liquidity which should be held in the vault after rebalancing.\n  /// @dev The actual liquidityPerc could be a bit more or a bit less than the liquidityPerc set here.\n  /// @dev This is because some deposits or withdrawals might not execute because they don't meet the marginScale.\n  /// @param _liquidityPerc Value at which to set the liquidityPerc.\n  function setLiquidityPerc(uint256 _liquidityPerc) external onlyGuardian {\n    require(_liquidityPerc <= 100);\n    liquidityPerc = _liquidityPerc;\n  }\n\n  /// @notice callback to receive Ether from unwrapping WETH\n  receive() external payable {\n    require(msg.sender == Swap.WETH, \"Not WETH\");\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Interfaces/IController.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\ninterface IController {\n  struct ProtocolInfoS {\n    address LPToken;\n    address provider;\n    address underlying; // address of underlying token of the protocol eg USDC\n    uint256 uScale; // uScale of protocol LP Token\n  }\n\n  struct UniswapParams {\n    address router;\n    address quoter;\n    uint24 poolFee;\n  }\n\n  struct CurveParams {\n    int128 indexTokenIn;\n    int128 indexTokenOut;\n    address pool;\n    uint256 poolFee;\n  }\n\n  function claim(uint256 _ETFnumber, uint256 protocolNumber) external returns (bool);\n\n  function addProtocol(\n    string calldata name,\n    uint256 _ETFnumber,\n    address provider,\n    address protocolLPToken,\n    address underlying,\n    address govToken,\n    uint256 _uScale\n  ) external returns (uint256);\n\n  function curve3Pool() external view returns (address);\n\n  function curve3PoolFee() external view returns (uint256);\n\n  function curveIndex(address _token) external view returns (int128);\n\n  function getProtocolInfo(\n    uint256 _ETFnumber,\n    uint256 protocolNumber\n  ) external view returns (ProtocolInfoS memory);\n\n  function getUniswapParams() external view returns (UniswapParams memory);\n\n  function getCurveParams(address _in, address _out) external view returns (CurveParams memory);\n\n  function latestProtocolId(uint256 _ETFnumber) external view returns (uint256);\n\n  function addVault(address _vault) external;\n\n  function addCurveIndex(address _token, int128 _index) external;\n\n  function underlyingUScale(address _token) external view returns (uint256);\n\n  function setUniswapRouter(address _uniswapRouter) external;\n\n  function setUniswapQuoter(address _uniswapQuoter) external;\n\n  function setUniswapPoolFee(uint24 _poolFee) external;\n\n  function getUniswapPoolFee() external view returns (uint24);\n\n  function getUniswapQuoter() external view returns (address);\n\n  function getProtocolBlacklist(\n    uint256 _ETFnumber,\n    uint256 _protocolNum\n  ) external view returns (bool);\n\n  function setProtocolBlacklist(uint256 _ETFnumber, uint256 _protocolNum) external;\n\n  function getGovToken(uint256 _vaultNumber, uint256 _protocolNum) external view returns (address);\n\n  function getDao() external view returns (address);\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/AaveProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IAToken.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IALendingPool.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract AaveProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Aave\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Aave, send aTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(address(IAToken(_aToken).POOL()), _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    IALendingPool(IAToken(_aToken).POOL()).deposit(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender,\r\n      0\r\n    );\r\n\r\n    return _amount;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Aave\r\n  /// @dev Pulls cTokens from Vault, redeem them from Aave, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      IAToken(_aToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    uint256 uTokensReceived = IALendingPool(IAToken(_aToken).POOL()).withdraw(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in shares i.e LP tokens\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _aToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _aToken);\r\n    return balanceShares;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev Aave exchangeRate is 1\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _aToken) external view override returns (uint256) {\r\n    uint256 shares = _amount / exchangeRate(_aToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of aToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _aToken) public view override returns (uint256) {\r\n    uint256 _balanceShares = IAToken(_aToken).balanceOf(_address);\r\n    return _balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @dev Aave exchangeRate is always 1\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _aToken) public pure override returns (uint256) {\r\n    return 1;\r\n  }\r\n\r\n  function claim(address _aToken, address _claimer) public override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\nimport \"../Interfaces/IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n  using SafeERC20 for IERC20;\n\n  IComptroller public comptroller;\n\n  constructor(address _comptroller) {\n    comptroller = IComptroller(_comptroller);\n  }\n\n  /// @notice Deposit the underlying asset in Compound\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\n  /// @param _amount Amount to deposit\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Tokens received and sent to vault\n  function deposit(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\n\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\n\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\n\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\n\n    return cTokensReceived;\n  }\n\n  /// @notice Withdraw the underlying asset from Compound\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\n  /// @param _amount Amount to withdraw\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @param _uToken Address of underlying Token eg USDC\n  /// @return Underlying tokens received and sent to vault e.g USDC\n  function withdraw(\n    uint256 _amount,\n    address _cToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\n\n    require(\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error: transferFrom\"\n    );\n    // Compound redeem: 0 on success, otherwise an Error code\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\n\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\n\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uTokensReceived;\n  }\n\n  /// @notice Get balance from address in underlying token\n  /// @param _address Address to request balance from, most likely a Vault\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return balance in underlying token\n  function balanceUnderlying(\n    address _address,\n    address _cToken\n  ) public view override returns (uint256) {\n    uint256 balanceShares = balance(_address, _cToken);\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\n    uint256 price = exchangeRate(_cToken);\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n\n    return (balanceShares * price) / 10 ** (10 + decimals);\n  }\n\n  /// @notice Calculates how many shares are equal to the amount\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\n    uint256 shares = (_amount * (10 ** (10 + decimals))) / exchangeRate(_cToken);\n    return shares;\n  }\n\n  /// @notice Get balance of cToken from address\n  /// @param _address Address to request balance from\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return number of shares i.e LP tokens\n  function balance(address _address, address _cToken) public view override returns (uint256) {\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\n    return _balanceShares;\n  }\n\n  /// @notice Exchange rate of underyling protocol token\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  /// @return price of LP token\n  function exchangeRate(address _cToken) public view override returns (uint256) {\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\n    return _price;\n  }\n\n  /// @notice Claims/harvest COMP tokens from the Comptroller\n  /// @param _cToken Address of protocol LP Token eg cUSDC\n  function claim(address _cToken, address _claimer) external override returns (bool) {\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = _cToken;\n    comptr"
    }
  ]
}