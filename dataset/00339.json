{
  "Title": "H-6: Bidders' funds may become locked due to inconsistent price order checks in MaxPriorityQueue and the _claimBid function.",
  "Content": "# Issue H-6: Bidders' funds may become locked due to inconsistent price order checks in MaxPriorityQueue and the _claimBid function. \n\nSource: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/83 \n\n## Found by \nether\\_sky\n## Summary\nIn the `MaxPriorityQueue`, `bids` are ordered by decreasing `price`.\nWe calculate the `marginal price`, `marginal bid ID`, and determine the `auction winners`.\nWhen a `bidder` wants to claim, we verify that the `bid price` of this `bidder` exceeds the `marginal price`.\nHowever, there's minor inconsistency: certain `bids` may have `marginal price` and a smaller `bid ID` than `marginal bid ID` and they are not actually `winners`.\nAs a result, the `auction winners` and these `bidders` can receive `base` tokens.\nHowever, there is a finite supply of `base` tokens for `auction winners`.\nEarly `bidders` who claim can receive `base` tokens, but the last `bidders` can not.\n## Vulnerability Detail\nThe comparison for the order of `bids` in the `MaxPriorityQueue` is as follow:\nif `q1 * b2 < q2 * b1` then `bid (q2, b2)` takes precedence over `bid (q1, b1)`.\n```solidity\nfunction _isLess(Queue storage self, uint256 i, uint256 j) private view returns (bool) {\n    uint64 iId = self.bidIdList[i];\n    uint64 jId = self.bidIdList[j];\n    Bid memory bidI = self.idToBidMap[iId];\n    Bid memory bidJ = self.idToBidMap[jId];\n    uint256 relI = uint256(bidI.amountIn) * uint256(bidJ.minAmountOut);\n    uint256 relJ = uint256(bidJ.amountIn) * uint256(bidI.minAmountOut);\n    if (relI == relJ) {\n        return iId > jId;\n    }\n    return relI < relJ;\n}\n```\nAnd in the `_calimBid` function, the `price` is checked directly as follow:\nif `q * 10 ** baseDecimal / b >= marginal price`, then this `bid` can be claimed.\n```solidity\nfunction _claimBid(\n    uint96 lotId_,\n    uint64 bidId_\n) internal returns (BidClaim memory bidClaim, bytes memory auctionOutput_) {\n    uint96 price = uint96(\n        bidData.minAmountOut == 0\n            ? 0 // TODO technically minAmountOut == 0 should be an infinite price, but need to check that later. Need to be careful we don't introduce a way to claim a bid when we set marginalPrice to type(uint96).max when it cannot be settled.\n            : Math.mulDivUp(uint256(bidData.amount), baseScale, uint256(bidData.minAmountOut))\n    );\n    uint96 marginalPrice = auctionData[lotId_].marginalPrice;\n    if (\n        price > marginalPrice\n            || (price == marginalPrice && bidId_ <= auctionData[lotId_].marginalBidId)\n    ) { }\n}\n```\nThe issue is that a `bid` with the `marginal price` might being placed after `marginal bid` in the `MaxPriorityQueue` due to rounding.\n```solidity\nq1 * b2 < q2 * b1, but mulDivUp(q1, 10 ** baseDecimal, b1) = mulDivUp(q2, 10 ** baseDecimal, b2)\n```\n\nLet me take an example.\nThe `capacity` is `10e18` and there are `6 bids` (`(4e18 + 1, 2e18)` for first `bidder`, `(4e18 + 2, 2e18)` for the other `bidders`.\nThe order in the `MaxPriorityQueue` is `(2, 3, 4, 5, 6, 1)`.\nThe `marginal bid ID` is `6`.\nThe `marginal price` is `2e18 + 1`.\nThe `auction winners` are `(2, 3, 4, 5, 6)`.\nHowever, `bidder 1` can also claim because it's `price` matches the `marginal price` and it has the smallest `bid ID`.\nThere are only `10e18` `base` tokens, but all `6 bidders` require `2e18` `base` tokens.\nAs a result, at least one `bidder` won't be able to claim `base` tokens, and his `quote` tokens will remain locked in the `auction house`.\n\nThe Log is\n```solidity\nmarginal price     ==>   2000000000000000001\nmarginal bid id    ==>   6\n\npaid to bid  1       ==>   4000000000000000001\npayout to bid  1     ==>   1999999999999999999\n*****\npaid to bid  2       ==>   4000000000000000002\npayout to bid  2     ==>   2000000000000000000\n*****\npaid to bid  3       ==>   4000000000000000002\npayout to bid  3     ==>   2000000000000000000\n*****\npaid to bid  4       ==>   4000000000000000002\npayout to bid  4     ==>   2000000000000000000\n*****\npaid to bid  5       ==>   4000000000000000002\npayout to bid  5     ==>   2000000000000000000\n*****\npaid to bid  6       ==>   4000000000000000002\npayout to bid  6     ==>   2000000000000000000\n```\nPlease add below test to the `test/modules/auctions/EMPA/claimBids.t.sol`\n```solidity\nfunction test_claim_nonClaimable_bid()\n    external\n    givenLotIsCreated\n    givenLotHasStarted\n    givenBidIsCreated(4e18 + 1, 2e18)           // bidId = 1\n    givenBidIsCreated(4e18 + 2, 2e18)           // bidId = 2\n    givenBidIsCreated(4e18 + 2, 2e18)           // bidId = 3\n    givenBidIsCreated(4e18 + 2, 2e18)           // bidId = 4\n    givenBidIsCreated(4e18 + 2, 2e18)           // bidId = 5\n    givenBidIsCreated(4e18 + 2, 2e18)           // bidId = 6\n    givenLotHasConcluded\n    givenPrivateKeyIsSubmitted\n    givenLotIsDecrypted\n    givenLotIsSettled\n{\n    EncryptedMarginalPriceAuctionModule.AuctionData memory auctionData = _getAuctionData(_lotId);\n\n    console2.log('marginal price     ==>  ', auctionData.marginalPrice);\n    console2.log('marginal bid id    ==>  ', auctionData.marginalBidId);\n    console2.log('');\n\n    for (uint64 i; i < 6; i ++) {\n        uint64[] memory bidIds = new uint64[](1);\n        bidIds[0] = i + 1;\n        vm.prank(address(_auctionHouse));\n        (Auction.BidClaim[] memory bidClaims,) = _module.claimBids(_lotId, bidIds);\n        Auction.BidClaim memory bidClaim = bidClaims[0];\n        if (i > 0) {\n            console2.log('*****');\n        }\n        console2.log('paid to bid ', i + 1, '      ==>  ', bidClaim.paid);\n        console2.log('payout to bid ', i + 1, '    ==>  ', bidClaim.payout);\n    }\n}\n```\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/lib/MaxPriorityQueue.sol#L109-L120\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/modules/auctions/EMPAM.sol#L347-L350\n## Tool used\n\nManual Review\n\n## Recommendation\nIn the `MaxPriorityQueue`, we should check the `price`: `Math.mulDivUp(q, 10 ** baseDecimal, b)`.\n\n\n\n## Discussion\n\n**Oighty**\n\nBelieve this is valid due to bids below marginal price being able to claim, which would result in a winning bidder not receiving theirs. Need to think about the remediation a bit more. There are some other precision issues with the rounding up.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Axis-Fi/moonraker/pull/146\n\n\n**10xhash**\n\n> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#146](https://github.com/Axis-Fi/moonraker/pull/146)\n\nFixed\nNow same computation is used for queue and marginal price calculations\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/206",
  "Code": [
    {
      "filename": "moonraker/src/lib/MaxPriorityQueue.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nstruct Bid {\n    uint96 amountIn;\n    uint96 minAmountOut;\n}\n\nstruct Queue {\n    ///@notice array backing priority queue\n    uint64[] bidIdList;\n    ///@notice total number of bids in queue\n    uint64 numBids;\n    //@notice map bid ids to bids\n    mapping(uint64 => Bid) idToBidMap;\n}\n\n/// @notice a max priority queue implementation on a binary heap, based off https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n/// @notice adapted from FrankieIsLost's min priority queue implementation at https://github.com/FrankieIsLost/smart-batched-auction/blob/master/contracts/libraries/MinPriorityQueue.sol\n/// @author FrankieIsLost\n/// @author Oighty (edits)\n/// Bids in descending order\n/// @dev    Important assumptions:\n///         - The queue assumes that the bid ids are unique. Behaviour will be unexpected if this is not the case.\nlibrary MaxPriorityQueue {\n    ///@notice initialize must be called before using queue.\n    function initialize(Queue storage self) public {\n        self.bidIdList.push(0);\n    }\n\n    function isEmpty(Queue storage self) public view returns (bool) {\n        return self.numBids == 0;\n    }\n\n    function getNumBids(Queue storage self) public view returns (uint256) {\n        return self.numBids;\n    }\n\n    ///@notice view max bid\n    function getMax(Queue storage self) public view returns (Bid storage) {\n        require(!isEmpty(self), \"nothing to return\");\n        uint64 maxId = self.bidIdList[1];\n        return self.idToBidMap[maxId];\n    }\n\n    function getMaxId(Queue storage self) public view returns (uint64) {\n        require(!isEmpty(self), \"nothing to return\");\n        return self.bidIdList[1];\n    }\n\n    ///@notice move bid up heap\n    function _swim(Queue storage self, uint64 k) private {\n        while (k > 1 && _isLess(self, k / 2, k)) {\n            _exchange(self, k, k / 2);\n            k = k / 2;\n        }\n    }\n\n    ///@notice move bid down heap\n    function _sink(Queue storage self, uint64 k) private {\n        while (2 * k <= self.numBids) {\n            uint64 j = 2 * k;\n            if (j < self.numBids && _isLess(self, j, j + 1)) {\n                j++;\n            }\n            if (!_isLess(self, k, j)) {\n                break;\n            }\n            _exchange(self, k, j);\n            k = j;\n        }\n    }\n\n    ///@notice insert bid in heap\n    function insert(\n        Queue storage self,\n        uint64 bidId,\n        uint96 amountIn,\n        uint96 minAmountOut\n    ) public {\n        // Prevents infinite price\n        if (minAmountOut == 0) revert(\"minAmountOut cannot be 0\");\n\n        _insert(self, bidId, Bid(amountIn, minAmountOut));\n    }\n\n    ///@notice insert bid in heap\n    function _insert(Queue storage self, uint64 bidId, Bid memory bid) private {\n        self.bidIdList.push(bidId);\n        self.idToBidMap[bidId] = bid;\n        self.numBids += 1;\n        _swim(self, self.numBids);\n    }\n\n    ///@notice delete max bid from heap and return\n    function delMax(Queue storage self) public returns (Bid memory) {\n        require(!isEmpty(self), \"nothing to delete\");\n        uint64 bidId = self.bidIdList[1];\n        Bid memory max = self.idToBidMap[bidId];\n        _exchange(self, 1, self.numBids--);\n        self.bidIdList.pop();\n        delete self.idToBidMap[bidId];\n        _sink(self, 1);\n        return max;\n    }\n\n    ///@notice helper function to determine ordering. When two bids have the same price, give priority\n    ///to the lower bid ID (inserted earlier)\n    function _isLess(Queue storage self, uint256 i, uint256 j) private view returns (bool) {\n        uint64 iId = self.bidIdList[i];\n        uint64 jId = self.bidIdList[j];\n        Bid memory bidI = self.idToBidMap[iId];\n        Bid memory bidJ = self.idToBidMap[jId];\n        uint256 relI = uint256(bidI.amountIn) * uint256(bidJ.minAmountOut);\n        uint256 relJ = uint256(bidJ.amountIn) * uint256(bidI.minAmountOut);\n        if (relI == relJ) {\n            return iId > jId;\n        }\n        return relI < relJ;\n    }\n\n    ///@notice helper function to exchange to bids in the heap\n    function _exchange(Queue storage self, uint256 i, uint256 j) private {\n        uint64 tempId = self.bidIdList[i];\n        self.bidIdList[i] = self.bidIdList[j];\n        self.bidIdList[j] = tempId;\n    }\n}"
    },
    {
      "filename": "moonraker/src/modules/auctions/EMPAM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n/// Protocol dependencies\nimport {AuctionModule, Auction} from \"src/modules/Auction.sol\";\nimport {Veecode, toVeecode} from \"src/modules/Modules.sol\";\n\n// Libraries\nimport {FixedPointMathLib as Math} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {ECIES, Point} from \"src/lib/ECIES.sol\";\nimport {MaxPriorityQueue, Queue, Bid as QueueBid} from \"src/lib/MaxPriorityQueue.sol\";\n\ncontract EncryptedMarginalPriceAuctionModule is AuctionModule {\n    using MaxPriorityQueue for Queue;\n\n    // ========== ERRORS ========== //\n    error Auction_InvalidKey();\n    error Auction_WrongState(uint96 lotId); // TODO shift into Auction?\n    error Bid_WrongState(uint96 lotId, uint64 bidId);\n    error NotPermitted(address caller);\n\n    // ========== EVENTS ========== //\n    event BidDecrypted(\n        uint96 indexed lotId, uint64 indexed bidId, uint96 amountIn, uint96 amountOut\n    );\n\n    // ========== DATA STRUCTURES ========== //\n\n    enum BidStatus {\n        Submitted,\n        Decrypted,\n        // Bid status will also be set to claimed if the bid is cancelled/refunded\n        Claimed\n    }\n\n    /// @notice        Core data for a bid\n    ///\n    /// @param         status              The status of the bid\n    /// @param         bidder              The address of the bidder\n    /// @param         amount              The amount of the bid\n    /// @param         minAmountOut        The minimum amount out (not set until the bid is decrypted)\n    /// @param         referrer            The address of the referrer\n    struct Bid {\n        address bidder; // 20 +\n        uint96 amount; // 12 = 32 - end of slot 1\n        uint96 minAmountOut; // 12 +\n        address referrer; // 20 = 32 - end of slot 2\n        BidStatus status; // 1 - slot 3\n    }\n\n    /// @notice        Struct containing data for an encrypted bid\n    ///\n    /// @param         encryptedAmountOut  The encrypted amount out, the bid amount is encrypted with a symmetric key that can be derived from the bidPubKey using the private key for the provided auction public key on the alt_bn128 curve\n    /// @param         bidPubKey           The alt_bn128 public key used to encrypt the amount out (see bid() for more details)\n    struct EncryptedBid {\n        uint256 encryptedAmountOut;\n        Point bidPubKey;\n    }\n\n    /// @notice        Struct containing auction-specific data\n    ///\n    /// @param         status              The status of the auction\n    /// @param         nextBidId           The ID of the next bid to be submitted\n    /// @param         nextDecryptIndex    The index of the next bid to decrypt\n    /// @param         marginalPrice       The marginal price of the auction (determined at settlement, blank before)\n    /// @param         publicKey           The public key used to encrypt bids (a point on the alt_bn128 curve from the generator point (1,2))\n    /// @param         privateKey          The private key used to decrypt bids (not provided until after the auction ends)\n    /// @param         bidIds              The list of bid IDs to decrypt in order of submission, excluding cancelled bids\n    struct AuctionData {\n        uint64 nextBidId; // 8 +\n        uint96 marginalPrice; // 12 +\n        uint96 minPrice; // 12 = 32 - end of slot 1\n        uint64 nextDecryptIndex; // 8 +\n        uint96 minFilled; // 12 +\n        uint96 minBidSize; // 12 = 32 - end of slot 2\n        Auction.Status status; // 1 +\n        uint64 marginalBidId; // 8 = 9 - end of slot 3\n        Point publicKey; // 64 - slots 4 and 5\n        uint256 privateKey; // 32 - slot 6\n        uint64[] bidIds; // slots 7+\n    }\n\n    struct AuctionDataParams {\n        uint96 minPrice;\n        uint24 minFillPercent;\n        uint24 minBidPercent;\n        Point publicKey;\n    }\n\n    /// @dev    Memory only, no need to pack\n    struct MarginalPriceResult {\n        uint96 marginalPrice;\n        uint64 marginalBidId;\n        uint64 partialFillBidId;\n        uint256 totalAmountIn;\n        uint256 capacityExpended;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice Constant for percentages\n    /// @dev    1% = 1_000 or 1e3. 100% = 100_000 or 1e5.\n    uint24 internal constant _MIN_BID_PERCENT = 10; // 0.01%\n\n    /// @notice     Auction-specific data for a lot\n    mapping(uint96 lotId => AuctionData) public auctionData;\n\n    /// @notice     General information about bids on a lot\n    mapping(uint96 lotId => mapping(uint64 bidId => Bid)) public bids;\n\n    /// @notice     Data for encryption information for a specific bid\n    mapping(uint96 lotId => mapping(uint64 bidId => EncryptedBid)) public encryptedBids; // each encrypted amount is 5 slots (length + 4 slots) due to using 1024-bit RSA encryption\n\n    /// @notice     Queue of decrypted bids for a lot (populated on decryption)\n    mapping(uint96 lotId => Queue) public decryptedBids;\n\n    // ========== SETUP ========== //\n\n    constructor(address auctionHouse_) AuctionModule(auctionHouse_) {\n        // Set the minimum auction duration to 1 day initially\n        minAuctionDuration = 1 days;\n    }\n\n    function VEECODE() public pure override returns (Veecode) {\n        return toVeecode(\"01EMPAM\");\n    }\n\n    function TYPE() public pure override returns (Type) {\n        return Type.Auction;\n    }\n\n    // ========== MODIFIERS ========== //\n\n    // ========== AUCTION ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The start and duration of the lot have been validated\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The minimum price is zero\n    ///             - The minimum fill percent is greater than 100%\n    ///             - The minimum bid percent is less than the minimum or greater than 100%\n    ///             - The public key is not valid\n    function _auction(uint96 lotId_, Lot memory lot_, bytes memory params_) internal override {\n        // Decode implementation params\n        AuctionDataParams memory implParams = abi.decode(params_, (AuctionDataParams));\n\n        // Validate params\n\n        // minPrice must not be zero\n        if (implParams.minPrice == 0) revert Auction_InvalidParams();\n\n        // minFillPercent must be less than or equal to 100%\n        if (implParams.minFillPercent > _ONE_HUNDRED_PERCENT) revert Auction_InvalidParams();\n\n        // minBidPercent must be greater than or equal to the global min and less than or equal to 100%\n        if (\n            implParams.minBidPercent < _MIN_BID_PERCENT\n                || implParams.minBidPercent > _ONE_HUNDRED_PERCENT\n        ) {\n            revert Auction_InvalidParams();\n        }\n\n        // publicKey must be a valid point for the encryption library\n        if (!ECIES.isValid(implParams.publicKey)) revert Auction_InvalidParams();\n\n        // Set auction data\n        AuctionData storage data = auctionData[lotId_];\n        data.minPrice = implParams.minPrice;\n        // These calculations won't overflow if capacity doesn't overflow uint96 because the minFillPercent and minBidPercent are both less than or equal to 100%\n        // We round up to be conservative with the minimums\n        data.minFilled = uint96(\n            Math.mulDivUp(\n                uint256(lot_.capacity),\n                uint256(implParams.minFillPercent),\n                uint256(_ONE_HUNDRED_PERCENT)\n            )\n        );\n        data.minBidSize = uint96(\n            Math.mulDivUp(\n                uint256(lot_.capacity), implParams.minBidPercent, uint256(_ONE_HUNDRED_PERCENT)\n            )\n        );\n        data.publicKey = implParams.publicKey;\n        data.nextBidId = 1;\n\n        decryptedBids[lotId_].initialize();\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction has not concluded\n    ///\n    ///             This function reverts if:\n    ///             - The auction is active or has not concluded\n    function _cancelAuction(uint96 lotId_) internal override {\n        // Validation\n        // Batch auctions cannot be cancelled once started, otherwise the seller could cancel the auction after bids have been submitted\n        _revertIfLotActive(lotId_);\n\n        // Set auction status to claimed so that bids can be refunded\n        auctionData[lotId_].status = Auction.Status.Claimed;\n    }\n\n    // ========== BID ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Stores the encrypted bid\n    ///             - Adds the bid ID to the list of bids to decrypt (in `AuctionData.bidIds`)\n    ///             - Returns the bid ID\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The amount is less than the minimum bid size for the lot\n    ///             - The bid public key is not valid\n    function _bid(\n        uint96 lotId_,\n        address bidder_,\n        address referrer_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal override returns (uint64 bidId) {\n        // Decode auction data\n        (uint256 encryptedAmountOut, Point memory bidPubKey) =\n            abi.decode(auctionData_, (uint256, Point));\n\n        // Validate inputs\n\n        // Amount must be at least the minimum bid size at the minimum price\n        uint256 minAmount = Math.mulDivDown(\n            uint256(auctionData[lotId_].minBidSize),\n            uint256(auctionData[lotId_].minPrice),\n            10 ** lotData[lotId_].baseTokenDecimals\n        );\n        if (amount_ < minAmount) revert Auction_AmountLessThanMinimum();\n\n        // Check that the bid public key is a valid point for the encryption library\n        if (!ECIES.isValid(bidPubKey)) revert Auction_InvalidKey();\n\n        // Store bid data\n        bidId = auctionData[lotId_].nextBidId++;\n        Bid storage userBid = bids[lotId_][bidId];\n        userBid.bidder = bidder_;\n        userBid.amount = amount_;\n        userBid.referrer = referrer_;\n        userBid.status = BidStatus.Submitted;\n\n        // Store encrypted amount out and bid public key\n        encryptedBids[lotId_][bidId] = EncryptedBid(encryptedAmountOut, bidPubKey);\n\n        // Push bid ID to list of bids to decrypt\n        auctionData[lotId_].bidIds.push(bidId);\n\n        return bidId;\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as refunded\n    ///             - Removes the bid from the list of bids to decrypt\n    ///             - Returns the amount to be refunded\n    ///\n    ///             The encrypted bid is not deleted from storage, so that the details can be fetched later.\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The bid ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///             - The bid has already been refunded\n    function _refundBid(\n        uint96 lotId_,\n        uint64 bidId_,\n        address\n    ) internal override returns (uint96 refund) {\n        // Set bid status to claimed\n        bids[lotId_][bidId_].status = BidStatus.Claimed;\n\n        // Remove bid from list of bids to decrypt\n        uint64[] storage bidIds = auctionData[lotId_].bidIds;\n        uint256 len = bidIds.length;\n        for (uint256 i; i < len; i++) {\n            if (bidIds[i] == bidId_) {\n                bidIds[i] = bidIds[len - 1];\n                bidIds.pop();\n                break;\n            }\n        }\n\n        // Return the amount to be refunded\n        return bids[lotId_][bidId_].amount;\n    }\n\n    /// @notice     Claims a bid and calculates the paid and payout amounts\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as claimed\n    ///             - Calculates the paid and payout amounts\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The bid ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is not settled\n    ///             - The bid has not already been claimed\n    function _claimBid(\n        uint96 lotId_,\n        uint64 bidId_\n    ) internal returns (BidClaim memory bidClaim, bytes memory auctionOutput_) {\n        // Load bid data\n        Bid storage bidData = bids[lotId_][bidId_];\n\n        // Set the bid status to claimed\n        bidData.status = BidStatus.Claimed;\n\n        // Load the referrer and bidder\n        bidClaim.bidder = bidData.bidder;\n        bidClaim.referrer = bidData.referrer;\n\n        // Calculate the bid price\n        uint256 baseScale = 10 ** lotData[lotId_].baseTokenDecimals;\n        uint96 price = uint96(\n            bidData.minAmountOut == 0\n                ? 0 // TODO technically minAmountOut == 0 should be an infinite price, but need to check that later. Need to be careful we don't introduce a way to claim a bid when we set marginalPrice to type(uint96).max when it cannot be settled.\n                : Math.mulDivUp(uint256(bidData.amount), baseScale, uint256(bidData.minAmountOut))\n        );\n\n        // If the bid price is greater than the marginal price, the bid is filled.\n        // If the bid price is equal to the marginal price and the bid was submitted before or is the marginal bid, the bid is filled.\n        // Auctions that do not meet capacity or price thresholds to settle will have their marginal price set at the maximum uint96\n        // Therefore, all bids will be refunded.\n        // We handle the only potential marginal fill during settlement. All other bids are either completely filled or refunded.\n        uint96 marginalPrice = auctionData[lotId_].marginalPrice;\n        if (\n            price > marginalPrice\n                || (price == marginalPrice && bidId_ <= auctionData[lotId_].marginalBidId)\n        ) {\n            // Payout is calculated using the marginal price of the auction\n            bidClaim.paid = bidData.amount;\n            bidClaim.payout = uint96(Math.mulDivDown(bidClaim.paid, baseScale, marginalPrice));\n        } else {\n            // Bidder is refunded the paid amount and receives no payout\n            bidClaim.paid = bidData.amount;\n        }\n\n        return (bidClaim, auctionOutput_);\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as claimed\n    ///             - Calculates the paid and payout amounts\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is not settled\n    function _claimBids(\n        uint96 lotId_,\n        uint64[] calldata bidIds_\n    ) internal override returns (BidClaim[] memory bidClaims, bytes memory auctionOutput_) {\n        uint256 len = bidIds_.length;\n        bidClaims = new BidClaim[](len);\n        for (uint256 i; i < len; i++) {\n            // Validate\n            _revertIfBidInvalid(lotId_, bidIds_[i]);\n            _revertIfBidClaimed(lotId_, bidIds_[i]);\n\n            (bidClaims[i],) = _claimBid(lotId_, bidIds_[i]);\n        }\n\n        return (bidClaims, auctionOutput_);\n    }\n\n    // ========== DECRYPTION ========== //\n\n    /// @notice         Submits the private key for the auction lot and decrypts an initial number of bids\n    ///                 It does not require gating. If the seller wishes to limit who can call, they can simply not reveal the key to anyone else.\n    ///                 On the other hand, if a key management service is used, then anyone can call it once the key is revealed.\n    ///\n    /// @dev            This function reverts if:\n    ///                 - The lot ID is invalid\n    ///                 - The lot is not active\n    ///                 - The lot has not concluded\n    ///                 - The private key has already been submitted\n    function submitPrivateKey(uint96 lotId_, uint256 privateKey_, uint64 num_) external {\n        // Validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfLotActive(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n\n        // Revert if the private key has already been verified and set\n        if (auctionData[lotId_].privateKey != 0) revert Auction_WrongState(lotId_);\n\n        // Check that the private key is valid for the public key\n        // We assume that all public keys are derived from the same generator: (1, 2)\n        Point memory calcPubKey = ECIES.calcPubKey(Point(1, 2), privateKey_);\n        Point memory pubKey = auctionData[lotId_].publicKey;\n        if (calcPubKey.x != pubKey.x || calcPubKey.y != pubKey.y) revert Auction_InvalidKey();\n\n        // Store the private key\n        auctionData[lotId_].privateKey = privateKey_;\n\n        // Decrypt and sort bids\n        _decryptAndSortBids(lotId_, num_);\n    }\n\n    /// @notice         Decrypts a batch of bids and sorts them by price in descending order\n    /// @dev            This function handles the following:\n    ///                 - Performs state validation\n    ///                 - Iterates over the encrypted bids:\n    ///                     - Decrypts the bid\n    ///                     - Ignores if the bid is incorrectly encrypted\n    ///                     - Does not add to the sorted bid queue if the decrypted amount out is less than the minimum bid size or overflows\n    ///                     - Otherwise, adds to the sorted bid queue for use during settlement\n    ///                 - Determines the next decrypt index\n    ///                 - Sets the auction status to decrypted if all bids have been decrypted\n    ///\n    ///                 This function reverts if:\n    ///                 - The lot ID is invalid\n    ///                 - The lot has not concluded\n    ///                 - The lot has already been decrypted in full\n    ///                 - The private key has not been provided\n    ///\n    /// @param          lotId_          The lot ID of the auction to decrypt bids for\n    /// @param          num_            The number of bids to decrypt. Reduced to the number remaining if greater.\n    function decryptAndSortBids(uint96 lotId_, uint64 num_) external {\n        // Check that lotId is valid\n        _revertIfLotInvalid(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n        _revertIfLotActive(lotId_);\n\n        // Revert if already decrypted or if the private key has not been provided\n        if (\n            auctionData[lotId_].status != Auction.Status.Created\n                || auctionData[lotId_].privateKey == 0\n        ) {\n            revert Auction_WrongState(lotId_);\n        }\n\n        // Decrypt and sort bids\n        _decryptAndSortBids(lotId_, num_);\n    }\n\n    function _decryptAndSortBids(uint96 lotId_, uint64 num_) internal {\n        // Load next decrypt index and min bid size\n        AuctionData storage lotBidData = auctionData[lotId_];\n        uint64 nextDecryptIndex = lotBidData.nextDecryptIndex;\n        uint96 minBidSize = auctionData[lotId_].minBidSize;\n\n        // Check that the number of decrypts is less than or equal to the number of bids remaining to be decrypted\n        // If so, reduce to the number remaining\n        uint64[] storage bidIds = auctionData[lotId_].bidIds;\n        if (num_ > bidIds.length - nextDecryptIndex) {\n            num_ = uint64(bidIds.length) - nextDecryptIndex;\n        }\n\n        // Iterate over the provided number of bids, decrypt them, and then store them in the sorted bid queue\n        // All submitted bids will be marked as decrypted, but only those with valid values will have the minAmountOut set and be stored in the sorted bid queue\n        for (uint64 i; i < num_; i++) {\n            // Load encrypted bid\n            uint64 bidId = bidIds[nextDecryptIndex + i];\n\n            // Decrypt the bid\n            uint96 amountOut;\n            {\n                uint256 result = _decrypt(lotId_, bidId, lotBidData.privateKey);\n\n                // Only set the amount out if it is less than or equal to the maximum value of a uint96\n                if (result <= type(uint96).max) {\n                    amountOut = uint96(result);\n                }\n            }\n\n            // Set bid status to decrypted\n            Bid storage bidData = bids[lotId_][bidId];\n            bidData.status = BidStatus.Decrypted;\n\n            // Only store the decrypt if the amount out is greater than or equal to the minimum bid size\n            if (amountOut > 0 && amountOut >= minBidSize) {\n                // Only store the decrypt if the price does not overflow\n                // We don't need to check for a zero bid price, because the smallest possible bid price is 1, due to the use of mulDivUp\n                // 1 * 10^6 / type(uint96).max = 1\n                if (\n                    Math.mulDivUp(\n                        uint256(bidData.amount),\n                        10 ** lotData[lotId_].baseTokenDecimals,\n                        uint256(amountOut)\n                    ) < type(uint96).max\n                ) {\n                    // Store the decrypt in the sorted bid queue and set the min amount out on the bid\n                    decryptedBids[lotId_].insert(bidId, bidData.amount, amountOut);\n                    bidData.minAmountOut = amountOut;\n                }\n            }\n\n            // Emit event\n            emit BidDecrypted(lotId_, bidId, bidData.amount, amountOut);\n        }\n\n        // Increment next decrypt index\n        auctionData[lotId_].nextDecryptIndex += num_;\n\n        // If all bids have been decrypted, set auction status to decrypted\n        if (auctionData[lotId_].nextDecryptIndex == bidIds.length) {\n            auctionData[lotId_].status = Auction.Status.Decrypted;\n        }\n    }\n\n    function _decrypt(\n        uint96 lotId_,\n        uint64 bidId_,\n        uint256 privateKey_\n    ) internal view returns (uint256 amountOut) {\n        // Load the encrypted bid data\n        EncryptedBid memory encryptedBid = encryptedBids[lotId_][bidId_];\n\n        // Decrypt the message\n        // We expect a salt calculated as the keccak256 hash of lot id, bidder, and amount to provide some (not total) uniqueness to the encryption, even if the same shared secret is used\n        Bid storage bidData = bids[lotId_][bidId_];\n        uint256 message = ECIES.decrypt(\n            encryptedBid.encryptedAmountOut,\n            encryptedBid.bidPubKey,\n            privateKey_,\n            uint256(keccak256(abi.encodePacked(lotId_, bidData.bidder, bidData.amount)))\n        );\n\n        // Convert the message into the amount out\n        // We don't need larger than 16 bytes for a message\n        // To avoid attacks that check for leading zero values, encrypted bids should use a 128-bit random number\n        // as a seed to randomize the message. The seed should be the first 16 bytes.\n        // During encryption, we subtract the seed from the amount out to get a masked value.\n        // After decryption, we can combine them again (adding the seed to the masked value) and get the amount out\n        // This works due to the overflow/underflow properties of modular arithmetic\n        uint128 maskedValue = uint128(message);\n        uint128 seed = uint128(message >> 128);\n\n        // We want to allow underflow here\n        unchecked {\n            amountOut = uint256(maskedValue + seed);\n        }\n    }\n\n    // ========== SETTLEMENT ========== //\n\n    /// @notice         Helper function to get the next bid from the queue and calculate the price\n    /// @dev            This is split into a different function to avoid stack too deep errors\n    ///\n    /// @param          queue_          The queue to get the next bid from\n    /// @param          baseScale_      The scaling factor for the base token\n    /// @return         bidId           The ID of the bid\n    /// @return         amountIn        The amount in of the bid (in quote token units)\n    /// @return         price           The price of the bid (in quote token units), or 0 if it could not be determined\n    function _getNextBid(\n        Queue storage queue_,\n        uint256 baseScale_\n    ) internal returns (uint64 bidId, uint96 amountIn, uint96 price) {\n        bidId = queue_.getMaxId();\n\n        // Load bid info (in quote token units)\n        QueueBid memory qBid = queue_.delMax();\n        amountIn = qBid.amountIn;\n\n        // A zero minAmountOut value should be filtered out during decryption. However, cover the case here to avoid a potential division by zero error that would brick settlement.\n        if (qBid.minAmountOut == 0) {\n            // A zero price would be filtered out being below the minimum price\n            return (bidId, amountIn, 0);\n        }\n\n        // Calculate the price of the bid\n        // Cannot overflow on cast back to uint96. It was checked during decryption.\n        price = uint96(Math.mulDivUp(amountIn, baseScale_, qBid.minAmountOut));\n\n        return (bidId, amountIn, price);\n    }\n\n    /// @notice     Calculates the marginal price of a lot\n    ///\n    /// @param      lotId_          The lot ID of the auction to calculate the marginal price for\n    /// @return     result          The result of the marginal price calculation\n    function _getLotMarginalPrice(uint96 lotId_)\n        internal\n        returns (MarginalPriceResult memory result)\n    {\n        // Cache values used in the loop\n        // Capacity is always in base token units for this auction type\n        uint256 capacity = lotData[lotId_].capacity;\n        uint256 baseScale = 10 ** lotData[lotId_].baseTokenDecimals;\n        AuctionData memory lotAuctionData = auctionData[lotId_];\n\n        // Iterate over bid queue (sorted in descending price) to calculate the marginal clearing price of the auction\n        {\n            Queue storage queue = decryptedBids[lotId_];\n            uint96 lastPrice;\n            uint64 lastBidId;\n            uint256 numBids = queue.getNumBids();\n            for (uint256 i = 0; i < numBids; i++) {\n                // A bid can be considered if:\n                // - the bid price is greater than or equal to the minimum\n                // - previous bids did not fill the capacity\n                //\n                // There is no need to check if the bid is the minimum bid size, as this was checked during decryption\n\n                // Get bid info\n                (uint64 bidId, uint96 amountIn, uint96 price) = _getNextBid(queue, baseScale);\n\n                // If the price is below the minimum price, then determine a marginal price from the previous bids with the knowledge that no other bids will be considered\n                // This will also handle a zero price returned from `_getNextBid()`, since `minPrice` is always greater than zero\n                if (price < lotAuctionData.minPrice) {\n                    // We know that the lastPrice was not sufficient to fill capacity or the loop would have exited\n                    // We check if minimum price can result in a fill. If so, find the exact marginal price between last price and minimum price\n                    // If not, we set the marginal price to the minimum price. Whether the capacity filled meets the minimum filled will be checked later in the settlement process.\n                    if (\n                        lotAuctionData.minPrice == 0\n                            || Math.mulDivDown(result.totalAmountIn, baseScale, lotAuctionData.minPrice)\n                                >= capacity\n                    ) {\n                        result.marginalPrice ="
    }
  ]
}