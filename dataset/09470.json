{
  "Title": "[H-01] StakedCitadel doesn't use correct balance for internal accounting",
  "Content": "_Submitted by Ruhum, also found by cccz, wuwe1, VAD37, TrungOre, shenwilly, minhquanym, kyliek, danb, gs8nrv, and rayn_\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295>\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L772-L776>\n\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L881-L893>\n\n### Impact\n\nThe StakedCitadel contract's `balance()` function is supposed to return the balance of the vault + the balance of the strategy. But, it only returns the balance of the vault. The balance is used to determine the number of shares that should be minted when depositing funds into the vault and the number of shares that should be burned when withdrawing funds from it.\n\nSince most of the funds will be located in the strategy, the vault's balance will be very low. Some of the issues that arise from this:\n\n**You can't deposit to a vault that already minted shares but has no balance of the underlying token**:\n\n1.  fresh vault with 0 funds and 0 shares\n2.  Alice deposits 10 tokens. She receives 10 shares back (<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888>)\n3.  Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`)\n4.  Bob tries to deposit but the transaction fails because the contract tries to divide by zero: <https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890> (`pool == balance()`)\n\n**You get more shares than you should**\n\n1.  fresh vault with 0 funds and 0 shares\n2.  Alice deposits 10 tokens. She receives 10 shares back (<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L887-L888>)\n3.  Vault's tokens are deposited into the strategy (now `balance == 0` and `totalSupply == 10`)\n4.  Bob now first transfers 1 token to the vault so that the balance is now `1` instead of `0`.\n5.  Bob deposits 5 tokens. He receives `5 * 10 / 1 == 50` shares: <https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L890>\n\nNow, the vault received 15 tokens. 10 from Alice and 5 from Bob. But Alice only has 10 shares while Bob has 50. Thus, Bob can withdraw more tokens than he should be able to.\n\nIt simply breaks the whole accounting of the vault.\n\n### Proof of Concept\n\nThe comment says that it should be vault's + strategy's balance:\n<https://github.com/code-423n4/2022-04-badger-citadel/blob/main/src/StakedCitadel.sol#L291-L295>\n\nHere's another vault from the badger team where the function is implemented correctly: <https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262>\n\n### Recommended Mitigation Steps\n\nAdd the strategy's balance to the return value of the`balance()` function like [here](https://github.com/Badger-Finance/badger-vaults-1.5/blob/main/contracts/Vault.sol#L262).\n\n**[GalloDaSballo (BadgerDAO) confirmed and commented](https://github.com/code-423n4/2022-04-badger-citadel-findings/issues/74#issuecomment-1107163426):**\n > Agree balance must have been changed by mistake or perhaps earn should not transfer to a strategy either would work\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-04-badger-citadel-contest",
  "Code": [
    {
      "filename": "src/StakedCitadel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/SettAccessControl.sol\";\n\nimport {IVault} from \"./interfaces/badger/IVault.sol\";\nimport {IVesting} from \"./interfaces/citadel/IVesting.sol\";\nimport {IStrategy} from \"./interfaces/badger/IStrategy.sol\";\nimport {IERC20} from \"./interfaces/erc20/IERC20.sol\";\nimport {IBadgerGuestlist} from \"./interfaces/badger/IBadgerGuestlist.sol\";\n\n/*\n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n\n    V1.3\n    * Add guest list functionality\n    * All deposits can be optionally gated by external guestList approval logic on set guestList contract\n\n    V1.4\n    * Add depositFor() to deposit on the half of other users. That user will then be blockLocked.\n\n    V1.5\n    * Removed Controller\n        - Removed harvest from vault (only on strategy)\n    * Params added to track autocompounded rewards (lifeTimeEarned, lastHarvestedAt, lastHarvestAmount, assetsAtLastHarvest)\n      this would work in sync with autoCompoundRatio to help us track harvests better.\n    * Fees\n        - Strategy would report the autocompounded harvest amount to the vault\n        - Calculation performanceFeeGovernance, performanceFeeStrategist, withdrawalFee, managementFee moved to the vault.\n        - Vault mints shares for performanceFees and managementFee to the respective recipient (treasury, strategist)\n        - withdrawal fees is transferred to the rewards address set\n    * Permission:\n        - Strategist can now set performance, withdrawal and management fees\n        - Governance will determine maxPerformanceFee, maxWithdrawalFee, maxManagementFee that can be set to prevent rug of funds.\n    * Strategy would take the actors from the vault it is connected to\n    * All governance related fees goes to treasury\n*/\n\ncontract StakedCitadel is\n    ERC20Upgradeable,\n    SettAccessControl,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    uint256 constant ONE_ETH = 1e18;\n\n    /// ===== Storage Variables ====\n\n    IERC20Upgradeable public token; // Token used for deposits\n    IBadgerGuestlist public guestList; // guestlist when vault is in experiment/ guarded state\n\n    bool public pausedDeposit; // false by default Allows to only block deposits, use pause for the normal pause state\n\n    address public strategy; // address of the strategy connected to the vault\n    address public guardian; // guardian of vault and strategy\n    address public treasury; // set by governance ... any fees go there\n\n    address public badgerTree; // Address we send tokens too via reportAdditionalTokens\n    address public vesting; // Address of the vesting contract where after withdrawal we send CTDL to vest for 21 days\n\n    /// @dev name and symbol prefixes for lpcomponent token of vault\n    string internal constant _defaultNamePrefix = \"Staked \";\n    string internal constant _symbolSymbolPrefix = \"x\";\n\n    /// Params to track autocompounded rewards\n    uint256 public lifeTimeEarned; // keeps track of total earnings\n    uint256 public lastHarvestedAt; // timestamp of the last harvest\n    uint256 public lastHarvestAmount; // amount harvested during last harvest\n    uint256 public assetsAtLastHarvest; // assets for which the harvest took place.\n\n    mapping(address => uint256) public additionalTokensEarned;\n    mapping(address => uint256) public lastAdditionalTokenAmount;\n\n    /// Fees ///\n    /// @notice all fees will be in bps\n    uint256 public performanceFeeGovernance; // Perf fee sent to `treasury`\n    uint256 public performanceFeeStrategist; // Perf fee sent to `strategist`\n    uint256 public withdrawalFee; // fee issued to `treasury` on withdrawal\n    uint256 public managementFee; // fee issued to `treasury` on report (typically on harvest, but only if strat is autocompounding)\n\n    uint256 public maxPerformanceFee; // maximum allowed performance fees\n    uint256 public maxWithdrawalFee; // maximum allowed withdrawal fees\n    uint256 public maxManagementFee; // maximum allowed management fees\n\n    uint256 public toEarnBps; // NOTE: in BPS, minimum amount of token to deposit into strategy when earn is called\n\n    /// ===== Constants ====\n\n    uint256 public constant MAX_BPS = 10_000;\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    uint256 public constant WITHDRAWAL_FEE_HARD_CAP = 200; // Never higher than 2%\n    uint256 public constant PERFORMANCE_FEE_HARD_CAP = 3_000; // Never higher than 30% // 30% maximum performance fee // We usually do 20, so this is insanely high already\n    uint256 public constant MANAGEMENT_FEE_HARD_CAP = 200; // Never higher than 2%\n\n    /// ===== Events ====\n\n    // Emitted when a token is sent to the badgerTree for emissions\n    event TreeDistribution(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    // Emitted during a report, when there has been an increase in pricePerFullShare (ppfs)\n    event Harvested(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    event SetTreasury(address indexed newTreasury);\n    event SetStrategy(address indexed newStrategy);\n    event SetToEarnBps(uint256 newEarnToBps);\n    event SetMaxWithdrawalFee(uint256 newMaxWithdrawalFee);\n    event SetMaxPerformanceFee(uint256 newMaxPerformanceFee);\n    event SetMaxManagementFee(uint256 newMaxManagementFee);\n    event SetGuardian(address indexed newGuardian);\n    event SetVesting(address indexed newVesting);\n    event SetGuestList(address indexed newGuestList);\n    event SetWithdrawalFee(uint256 newWithdrawalFee);\n    event SetPerformanceFeeStrategist(uint256 newPerformanceFeeStrategist);\n    event SetPerformanceFeeGovernance(uint256 newPerformanceFeeGovernance);\n    event SetManagementFee(uint256 newManagementFee);\n\n    event PauseDeposits(address indexed pausedBy);\n    event UnpauseDeposits(address indexed pausedBy);\n\n    /// @notice Initializes the Sett. Can only be called once, ideally when the contract is deployed.\n    /// @param _token Address of the token that can be deposited into the sett.\n    /// @param _governance Address authorized as governance.\n    /// @param _keeper Address authorized as keeper.\n    /// @param _guardian Address authorized as guardian.\n    /// @param _treasury Address to distribute governance fees/rewards to.\n    /// @param _strategist Address authorized as strategist.\n    /// @param _badgerTree Address of badgerTree used for emissions.\n    /// @param _name Specify a custom sett name. Leave empty for default value.\n    /// @param _symbol Specify a custom sett symbol. Leave empty for default value.\n    /// @param _feeConfig Values for the 4 different types of fees charges by the sett\n    ///         [performanceFeeGovernance, performanceFeeStrategist, withdrawToVault, managementFee]\n    ///         Each fee should be less than the constant hard-caps defined above.\n    function initialize(\n        address _token,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        address _treasury,\n        address _strategist,\n        address _badgerTree,\n        address _vesting,\n        string memory _name,\n        string memory _symbol,\n        uint256[4] memory _feeConfig\n    ) public initializer whenNotPaused {\n        require(_token != address(0)); // dev: _token address should not be zero\n        require(_governance != address(0)); // dev: _governance address should not be zero\n        require(_keeper != address(0)); // dev: _keeper address should not be zero\n        require(_guardian != address(0)); // dev: _guardian address should not be zero\n        require(_treasury != address(0)); // dev: _treasury address should not be zero\n        require(_strategist != address(0)); // dev: _strategist address should not be zero\n        require(_badgerTree != address(0)); // dev: _badgerTree address should not be zero\n        require(_vesting != address(0)); // dev: _vesting address should not be zero\n\n        // Check for fees being reasonable (see below for interpretation)\n        require(\n            _feeConfig[0] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeGovernance too high\"\n        );\n        require(\n            _feeConfig[1] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n        require(\n            _feeConfig[2] <= WITHDRAWAL_FEE_HARD_CAP,\n            \"withdrawalFee too high\"\n        );\n        require(\n            _feeConfig[3] <= MANAGEMENT_FEE_HARD_CAP,\n            \"managementFee too high\"\n        );\n\n        string memory name;\n        string memory symbol;\n\n        // If they are non empty string we'll use the custom names\n        // Else just add the default prefix\n        IERC20 namedToken = IERC20(_token);\n\n        if (keccak256(abi.encodePacked(_name)) != keccak256(\"\")) {\n            name = _name;\n        } else {\n            name = string(\n                abi.encodePacked(_defaultNamePrefix, namedToken.name())\n            );\n        }\n\n        if (keccak256(abi.encodePacked(_symbol)) != keccak256(\"\")) {\n            symbol = _symbol;\n        } else {\n            symbol = string(\n                abi.encodePacked(_symbolSymbolPrefix, namedToken.symbol())\n            );\n        }\n\n        // Initializing the lpcomponent token\n        __ERC20_init(name, symbol);\n        // Initialize the other contracts\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        treasury = _treasury;\n        strategist = _strategist;\n        keeper = _keeper;\n        guardian = _guardian;\n        badgerTree = _badgerTree;\n        vesting = _vesting;\n\n        lastHarvestedAt = block.timestamp; // setting initial value to the time when the vault was deployed\n\n        performanceFeeGovernance = _feeConfig[0];\n        performanceFeeStrategist = _feeConfig[1];\n        withdrawalFee = _feeConfig[2];\n        managementFee = _feeConfig[3];\n        maxPerformanceFee = PERFORMANCE_FEE_HARD_CAP; // 30% max performance fee\n        maxWithdrawalFee = WITHDRAWAL_FEE_HARD_CAP; // 2% maximum withdrawal fee\n        maxManagementFee = MANAGEMENT_FEE_HARD_CAP; // 2% maximum management fee\n\n        toEarnBps = 9_500; // initial value of toEarnBps // 95% is invested to the strategy, 5% for cheap withdrawals\n    }\n\n    /// ===== Modifiers ====\n\n    /// @notice Checks whether a call is from guardian or governance.\n    function _onlyAuthorizedPausers() internal view {\n        require(\n            msg.sender == guardian || msg.sender == governance,\n            \"onlyPausers\"\n        );\n    }\n\n    /// @notice Checks whether a call is from the strategy.\n    function _onlyStrategy() internal view {\n        require(msg.sender == strategy, \"onlyStrategy\");\n    }\n\n    /// ===== View Functions =====\n\n    /// @notice Used to track the deployed version of the contract.\n    /// @return Current version of the contract.\n    function version() external pure returns (string memory) {\n        return \"1.5\";\n    }\n\n    /// @notice Gives the price for a single Sett share.\n    /// @dev Sett starts with a price per share of 1.\n    /// @return Value of a single share.\n    function getPricePerFullShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return ONE_ETH;\n        }\n        return (balance() * ONE_ETH) / totalSupply();\n    }\n\n    /// @notice Gives the total balance of the underlying token within the sett and strategy system.\n    /// @return Balance of token handled by the sett.\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Defines how much of the Setts' underlying is available for strategy to borrow.\n    /// @return Amount of tokens that the sett can provide to the strategy.\n    function available() public view returns (uint256) {\n        return (token.balanceOf(address(this)) * toEarnBps) / MAX_BPS;\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _amount Quantity of tokens to deposit.\n    function deposit(uint256 _amount) external whenNotPaused {\n        _depositWithAuthorization(_amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling account is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _amount Quantity of tokens to deposit.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function deposit(uint256 _amount, bytes32[] memory proof)\n        external\n        whenNotPaused\n    {\n        _depositWithAuthorization(_amount, proof);\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    function depositAll() external whenNotPaused {\n        _depositWithAuthorization(\n            token.balanceOf(msg.sender),\n            new bytes32[](0)\n        );\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling is authorized to make a full deposit.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function depositAll(bytes32[] memory proof) external whenNotPaused {\n        _depositWithAuthorization(token.balanceOf(msg.sender), proof);\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(address _recipient, uint256 _amount)\n        external\n        whenNotPaused\n    {\n        _depositForWithAuthorization(_recipient, _amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Checks the guestlist to verify that `recipient` is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _recipient Address to issue the Sett shares to.\n    /// @param _amount Quantity of tokens to deposit.\n    function depositFor(\n        address _recipient,\n        uint256 _amount,\n        bytes32[] memory proof\n    ) external whenNotPaused {\n        _depositForWithAuthorization(_recipient, _amount, proof);\n    }\n\n    /// @notice Redeems `_shares` for an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    /// @param _shares Quantity of shares to redeem.\n    function withdraw(uint256 _shares) external whenNotPaused {\n        _withdraw(_shares);\n    }\n\n    /// @notice Redeems all shares, issuing an appropriate amount of tokens.\n    ///         Note that withdrawals are not processed when the Sett is paused.\n    /// @dev See `_withdraw` for details on how withdrawals are processed.\n    function withdrawAll() external whenNotPaused {\n        _withdraw(balanceOf(msg.sender));\n    }\n\n    /// ===== Permissioned Actions: Strategy =====\n\n    /// @notice Used by the strategy to report a harvest to the sett.\n    ///         Issues shares for the strategist and treasury based on the performance fees and harvested amount.\n    ///         Issues shares for the treasury based on the management fee and the time elapsed since last harvest.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This implicitly trusts that the strategy reports the correct amount.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _harvestedAmount Amount of underlying token harvested by the strategy.\n    function reportHarvest(uint256 _harvestedAmount) external nonReentrant {\n        _onlyStrategy();\n\n        uint256 harvestTime = block.timestamp;\n        uint256 assetsAtHarvest = balance() - _harvestedAmount; // Must be less than or equal or revert\n\n        _handleFees(_harvestedAmount, harvestTime);\n\n        // Updated lastHarvestAmount\n        lastHarvestAmount = _harvestedAmount;\n\n        // if we withdrawAll\n        // we will have some yield left\n        // having 0 for assets will inflate APY\n        // Instead, have the last harvest report with the previous assets\n        // And if you end up harvesting again, that report will have both 0s\n        if (assetsAtHarvest != 0) {\n            assetsAtLastHarvest = assetsAtHarvest;\n        } else if (_harvestedAmount == 0) {\n            // If zero\n            assetsAtLastHarvest = 0;\n        }\n\n        lifeTimeEarned = lifeTimeEarned + _harvestedAmount;\n        // Update time either way\n        lastHarvestedAt = harvestTime;\n\n        emit Harvested(\n            address(token),\n            _harvestedAmount,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// @notice Used by the strategy to report harvest of additional tokens to the sett.\n    ///         Charges performance fees on the additional tokens and transfers fees to treasury and strategist.\n    ///         The remaining amount is sent to badgerTree for emissions.\n    ///         Updates harvest variables for on-chain APR tracking.\n    ///         This can only be called by the strategy.\n    /// @dev This function is called after the strategy sends the additional tokens to the sett.\n    ///      Pausing on this function happens at the strategy level.\n    /// @param _token Address of additional token harvested by the strategy.\n    function reportAdditionalToken(address _token) external nonReentrant {\n        _onlyStrategy();\n        require(address(token) != _token, \"No want\");\n        uint256 tokenBalance = IERC20Upgradeable(_token).balanceOf(\n            address(this)\n        );\n\n        additionalTokensEarned[_token] =\n            additionalTokensEarned[_token] +\n            tokenBalance;\n        lastAdditionalTokenAmount[_token] = tokenBalance;\n\n        // We may have more, but we still report only what the strat sent\n        uint256 governanceRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeGovernance\n        );\n        uint256 strategistRewardsFee = _calculateFee(\n            tokenBalance,\n            performanceFeeStrategist\n        );\n\n        IERC20Upgradeable(_token).safeTransfer(treasury, governanceRewardsFee);\n        IERC20Upgradeable(_token).safeTransfer(\n            strategist,\n            strategistRewardsFee\n        );\n\n        // Send rest to tree\n        uint256 newBalance = IERC20Upgradeable(_token).balanceOf(address(this));\n        IERC20Upgradeable(_token).safeTransfer(badgerTree, newBalance);\n        emit TreeDistribution(\n            _token,\n            newBalance,\n            block.number,\n            block.timestamp\n        );\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n\n    /// @notice Changes the treasury address.\n    ///         Treasury is recipient of management and governance performance fees.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @param _treasury Address of the new treasury.\n    function setTreasury(address _treasury) external whenNotPaused {\n        _onlyGovernance();\n        require(_treasury != address(0), \"Address 0\");\n\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n    /// @notice Changes the strategy address.\n    ///         This can only be called by governance.\n    ///         Note that this can only be called when sett is not paused.\n    /// @dev This is a rug vector, pay extremely close attention to the next strategy being set.\n    ///      Changing the strategy should happen only via timelock.\n    ///      This function must not be callable when the sett is paused as this would force depositors into a strategy they may not want to use.\n    /// @param _strategy Address of new strategy.\n    function setStrategy(address _strategy) external whenNotPaused {\n        _onlyGovernance();\n        require(_strategy != address(0), \"Address 0\");\n\n        /// NOTE: Migrate funds if settings strategy when already existing one\n        if (strategy != address(0)) {\n            require(\n                IStrategy(strategy).balanceOf() == 0,\n                \"Please withdrawToVault before changing strat\"\n            );\n        }\n        strategy = _strategy;\n        emit SetStrategy(_strategy);\n    }\n\n    // === Setters that can be called by governance even when paused ===\n\n    /// @notice Sets the max withdrawal fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `WITHDRAWAL_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for withdrawal fee.\n    function setMaxWithdrawalFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= WITHDRAWAL_FEE_HARD_CAP, \"withdrawalFee too high\");\n\n        maxWithdrawalFee = _fees;\n        emit SetMaxWithdrawalFee(_fees);\n    }\n\n    /// @notice Sets the max performance fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `PERFORMANCE_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for performance fee.\n    function setMaxPerformanceFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(\n            _fees <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n\n        maxPerformanceFee = _fees;\n        emit SetMaxPerformanceFee(_fees);\n    }\n\n    /// @notice Sets the max management fee that can be charged by the Sett.\n    ///         This can only be called by governance.\n    /// @dev The input `_fees` should be less than the `MANAGEMENT_FEE_HARD_CAP` hard-cap.\n    /// @param _fees The new maximum cap for management fee.\n    function setMaxManagementFee(uint256 _fees) external {\n        _onlyGovernance();\n        require(_fees <= MANAGEMENT_FEE_HARD_CAP, \"managementFee too high\");\n\n        maxManagementFee = _fees;\n        emit SetMaxManagementFee(_fees);\n    }\n\n    /// @notice Changes the guardian address.\n    ///         Guardian is an authorized actor that can pause the sett in case of an emergency.\n    ///         This can only be called by governance.\n    /// @param _guardian Address of the new guardian.\n    function setGuardian(address _guardian) external {\n        _onlyGovernance();\n        require(_guardian != address(0), \"Address cannot be 0x0\");\n\n        guardian = _guardian;\n        emit SetGuardian(_guardian);\n    }\n\n    /// @notice Changes the vesting contract address.\n    ///         Vesting contract is used to vest withdrawn tokens linearly over period of 21 days\n    ///         This can only be called by governance.\n    /// @param _vesting Address of the new guardian.\n    function setVesting(address _vesting) external {\n        _onlyGovernance();\n        require(_vesting != address(0), \"Address cannot be 0x0\");\n\n        vesting = _vesting;\n        emit SetVesting(_vesting);\n    }\n\n    /// ===== Permissioned Functions: Trusted Actors =====\n\n    /// @notice Sets the fraction of sett balance (in basis points) that the strategy can borrow.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _newToEarnBps The new maximum cap for management fee.\n    function setToEarnBps(uint256 _newToEarnBps) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_newToEarnBps <= MAX_BPS, \"toEarnBps should be <= MAX_BPS\");\n\n        toEarnBps = _newToEarnBps;\n        emit SetToEarnBps(_newToEarnBps);\n    }\n\n    /// @notice Changes the guestlist address.\n    ///         The guestList is used to gate or limit deposits. If no guestlist is set then anyone can deposit any amount.\n    ///         This can be called by either governance or strategist.\n    ///         Note that this can only be called when the sett is not paused.\n    /// @param _guestList Address of the new guestlist.\n    function setGuestList(address _guestList) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        guestList = IBadgerGuestlist(_guestList);\n        emit SetGuestList(_guestList);\n    }\n\n    /// @notice Sets the withdrawal fee charged by the Sett.\n    ///         The fee is taken at the time of withdrawals in the underlying token which is then used to issue new shares for the treasury.\n    ///         The new withdrawal fee should be less than `maxWithdrawalFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_withdraw` to see how withdrawal fee is charged.\n    /// @param _withdrawalFee The new withdrawal fee.\n    function setWithdrawalFee(uint256 _withdrawalFee) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_withdrawalFee <= maxWithdrawalFee, \"Excessive withdrawal fee\");\n        withdrawalFee = _withdrawalFee;\n        emit SetWithdrawalFee(_withdrawalFee);\n    }\n\n    /// @notice Sets the performance fee taken by the strategist on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the strategist.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeStrategist The new performance fee.\n    function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeStrategist <= maxPerformanceFee,\n            \"Excessive strategist performance fee\"\n        );\n        performanceFeeStrategist = _performanceFeeStrategist;\n        emit SetPerformanceFeeStrategist(_performanceFeeStrategist);\n    }\n\n    /// @notice Sets the performance fee taken by the treasury on the harvests.\n    ///         The fee is taken at the time of harvest reporting for both the underlying token and additional tokens.\n    ///         For the underlying token, the fee is used to issue new shares for the treasury.\n    ///         The new performance fee should be less than `maxPerformanceFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `reportHarvest` and `reportAdditionalToken` to see how performance fees are charged.\n    /// @param _performanceFeeGovernance The new performance fee.\n    function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance)\n        external\n        whenNotPaused\n    {\n        _onlyGovernanceOrStrategist();\n        require(\n            _performanceFeeGovernance <= maxPerformanceFee,\n            \"Excessive governance performance fee\"\n        );\n        performanceFeeGovernance = _performanceFeeGovernance;\n        emit SetPerformanceFeeGovernance(_performanceFeeGovernance);\n    }\n\n    /// @notice Sets the management fee taken by the treasury on the AUM in the sett.\n    ///         The fee is calculated at the time of `reportHarvest` and is used to issue new shares for the treasury.\n    ///         The new management fee should be less than `maxManagementFee`.\n    ///         This can be called by either governance or strategist.\n    /// @dev See `_handleFees` to see how the management fee is calculated.\n    /// @param _fees The new management fee.\n    function setManagementFee(uint256 _fees) external whenNotPaused {\n        _onlyGovernanceOrStrategist();\n        require(_fees <= maxManagementFee, \"Excessive management fee\");\n        managementFee = _fees;\n        emit SetManagementFee(_fees);\n    }\n\n    /// === Strategist level operations that can be done even when paused ==\n\n    /// @notice Withdraws all funds from the strategy back to the sett.\n    ///         This can be called by either governance or strategist.\n    /// @dev This calls `_withdrawAll` on the strategy and transfers the balance to the sett.\n    function withdrawToVault() external {\n        _onlyGovernanceOrStrategist();\n        IStrategy(strategy).withdrawToVault();\n    }\n\n    /// @notice Sends balance of any extra token earned by the strategy (from airdrops, donations etc.)\n    ///         to the badgerTree for emissions.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev See `BaseStrategy.emitNonProtectedToken` for details.\n    /// @param _token Address of the token to be emitted.\n    function emitNonProtectedToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n\n        IStrategy(strategy).emitNonProtectedToken(_token);\n    }\n\n    /// @notice Sweeps the balance of an extra token from the vault and strategy and sends it to governance.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by either strategist or governance.\n    /// @dev Sweeping doesn't take any fee.\n    /// @param _token Address of the token to be swept.\n    function sweepExtraToken(address _token) external {\n        _onlyGovernanceOrStrategist();\n        require(address(token) != _token, \"No want\");\n\n        IStrategy(strategy).withdrawOther(_token);\n        // Send all `_token` we have\n        // Safe because `withdrawOther` will revert on protected tokens\n        // Done this way works for both a donation to strategy or to vault\n        IERC20Upgradeable(_token).safeTransfer(\n            governance,\n            IERC20Upgradeable(_token).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Deposits the available balance of the underlying token into the strategy.\n    ///         The strategy then uses the amount for yield-generating activities.\n    ///         This can be called by either the keeper or governance.\n    ///         Note that earn cannot be called when deposits are paused.\n    /// @dev Pause is enforced at the Strategy level (this allows to still earn yield when the Vault is paused)"
    }
  ]
}