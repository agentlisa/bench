{
  "Title": "[N-02] Return values of `approve()` not checked",
  "Content": "Not all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything\n\n*There is 1 instance of this issue:*\n```solidity\nFile: protocol/contracts/tokenomics/VestedEscrow.sol   #1\n\n25:           IERC20(rewardToken_).approve(msg.sender, type(uint256).max);\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L25\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/tokenomics/VestedEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/*\nRewrite of Convex Finance's Vested Escrow\nfound at https://github.com/convex-eth/platform/blob/main/contracts/contracts/VestedEscrow.sol\nChanges:\n- remove safe math (default from Solidity >=0.8)\n- remove claim and stake logic\n- remove safeTransferFrom logic and add support for \"airdropped\" reward token\n*/\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../interfaces/tokenomics/IVestedEscrow.sol\";\n\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\ncontract EscrowTokenHolder {\n    constructor(address rewardToken_) {\n        IERC20(rewardToken_).approve(msg.sender, type(uint256).max);\n    }\n}\n\ncontract VestedEscrow is IVestedEscrow, ReentrancyGuard {\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    address public admin;\n    address public fundAdmin;\n\n    uint256 public immutable startTime;\n    uint256 public immutable endTime;\n    uint256 public totalTime;\n    uint256 public initialLockedSupply;\n    uint256 public unallocatedSupply;\n    bool public initializedSupply;\n\n    mapping(address => uint256) public initialLocked;\n    mapping(address => uint256) public totalClaimed;\n    mapping(address => address) public holdingContract;\n\n    event Fund(address indexed recipient, uint256 reward);\n    event Claim(address indexed user, uint256 amount);\n\n    constructor(\n        address rewardToken_,\n        uint256 starttime_,\n        uint256 endtime_,\n        address fundAdmin_\n    ) {\n        require(starttime_ >= block.timestamp, \"start must be future\");\n        require(endtime_ > starttime_, \"end must be greater\");\n\n        rewardToken = IERC20(rewardToken_);\n        startTime = starttime_;\n        endTime = endtime_;\n        totalTime = endtime_ - starttime_;\n        admin = msg.sender;\n        fundAdmin = fundAdmin_;\n    }\n\n    function setAdmin(address _admin) external override {\n        require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);\n        admin = _admin;\n    }\n\n    function setFundAdmin(address _fundadmin) external override {\n        require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);\n        fundAdmin = _fundadmin;\n    }\n\n    function initializeUnallocatedSupply() external override returns (bool) {\n        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);\n        require(!initializedSupply, \"Supply already initialized once\");\n        unallocatedSupply = rewardToken.balanceOf(address(this));\n        require(unallocatedSupply > 0, \"No reward tokens in contract\");\n        initializedSupply = true;\n        return true;\n    }\n\n    function fund(FundingAmount[] calldata amounts) external override nonReentrant returns (bool) {\n        require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS);\n        require(initializedSupply, \"Supply must be initialized\");\n\n        uint256 totalAmount;\n        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) {\n            uint256 amount = amounts[i].amount;\n            address recipient_ = amounts[i].recipient;\n            address holdingAddress = holdingContract[recipient_];\n            if (holdingAddress == address(0)) {\n                holdingAddress = address(new EscrowTokenHolder(address(rewardToken)));\n                holdingContract[recipient_] = holdingAddress;\n            }\n            rewardToken.safeTransfer(holdingAddress, amount);\n            initialLocked[recipient_] = initialLocked[recipient_] + amount;\n            totalAmount = totalAmount + amount;\n            emit Fund(recipient_, amount);\n        }\n\n        initialLockedSupply = initialLockedSupply + totalAmount;\n        unallocatedSupply = unallocatedSupply - totalAmount;\n        return true;\n    }\n\n    function claim() external virtual override {\n        _claimUntil(msg.sender, block.timestamp);\n    }\n\n    function vestedSupply() external view override returns (uint256) {\n        return _totalVested();\n    }\n\n    function lockedSupply() external view override returns (uint256) {\n        return initialLockedSupply - _totalVested();\n    }\n\n    function vestedOf(address _recipient) external view virtual override returns (uint256) {\n        return _totalVestedOf(_recipient, block.timestamp);\n    }\n\n    function balanceOf(address _recipient) external view virtual override returns (uint256) {\n        return _balanceOf(_recipient, block.timestamp);\n    }\n\n    function lockedOf(address _recipient) external view virtual override returns (uint256) {\n        uint256 vested = _totalVestedOf(_recipient, block.timestamp);\n        return initialLocked[_recipient] - vested;\n    }\n\n    function claim(address _recipient) public virtual override nonReentrant {\n        _claimUntil(_recipient, block.timestamp);\n    }\n\n    function _claimUntil(address _recipient, uint256 _time) internal {\n        uint256 claimable = _balanceOf(msg.sender, _time);\n        if (claimable == 0) return;\n        totalClaimed[msg.sender] = totalClaimed[msg.sender] + claimable;\n        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable);\n\n        emit Claim(msg.sender, claimable);\n    }\n\n    function _computeVestedAmount(uint256 locked, uint256 _time) internal view returns (uint256) {\n        if (_time < startTime) {\n            return 0;\n        }\n        uint256 elapsed = _time - startTime;\n        return Math.min((locked * elapsed) / totalTime, locked);\n    }\n\n    function _totalVestedOf(address _recipient, uint256 _time) internal view returns (uint256) {\n        return _computeVestedAmount(initialLocked[_recipient], _time);\n    }\n\n    function _totalVested() internal view returns (uint256) {\n        return _computeVestedAmount(initialLockedSupply, block.timestamp);\n    }\n\n    function _balanceOf(address _recipient, uint256 _time) internal view returns (uint256) {\n        uint256 vested = _totalVestedOf(_recipient, _time);\n        return vested - totalClaimed[_recipient];\n    }\n}"
    }
  ]
}