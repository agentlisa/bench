{
  "Title": "[H-29] Exercise option cross chain message in the (m)TapiocaOFT will always revert in the destination, losing debited funds in the source chain",
  "Content": "\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L539-L545>\n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L153-L159>\n\nExercise option cross chain message in the `(m)TapiocaOFT` will always revert in the destination, but works in the source chain, where it debits the funds from users. Thus, these funds will not be credited in the destination and are forever lost.\n\n### Proof of Concept\n\nIn the `BaseTOFT`, if the packet from the received cross chain message in `lzReceive()` is of type `PT_TAP_EXERCISE`, it delegate calls to the `BaseTOFTOptionsModule`:\n\n```solidity\nfunction _nonblockingLzReceive(\n    uint16 _srcChainId,\n    bytes memory _srcAddress,\n    uint64 _nonce,\n    bytes memory _payload\n) internal virtual override {\n    uint256 packetType = _payload.toUint256(0);\n    ...\n    } else if (packetType == PT_TAP_EXERCISE) {\n        _executeOnDestination(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exercise.selector,\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            ),\n            _srcChainId,\n            _srcAddress,\n            _nonce,\n            _payload\n        );\n    ...\n```\n\nIn the `BaseTOFTOptionsModule`, the `exercise()` function is declared as:\n\n```solidity\nfunction exercise(\n    address module,\n    uint16 _srcChainId,\n    bytes memory _srcAddress,\n    uint64 _nonce,\n    bytes memory _payload\n) public {\n    ...\n}\n```\n\nNotice that the `address module` argument is specified in the `exercise()` function declaration, but not in the `_nonBlockingLzReceive()` call to it. This will make the message always revert because it fails when decoding the arguments to the function call, due to the extra `address module` argument.\n\nThe following POC illustrates this behaviour. The `exerciseOption()` cross chain message fails on the destination:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport {Test, console} from \"forge-std/Test.sol\";\n\nimport {TapiocaOFT} from \"contracts/tOFT/TapiocaOFT.sol\";\nimport {BaseTOFTOptionsModule} from \"contracts/tOFT/modules/BaseTOFTOptionsModule.sol\";\n\nimport {IYieldBoxBase} from \"tapioca-periph/contracts/interfaces/IYieldBoxBase.sol\";\nimport {ISendFrom} from \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport {ICommonData} from \"tapioca-periph/contracts/interfaces/ICommonData.sol\";\nimport {ITapiocaOptionsBrokerCrossChain} from \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\n\ncontract TapiocaOFTPOC is Test {\n    address public constant LZ_ENDPOINT = 0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675;\n    uint16 internal constant PT_TAP_EXERCISE = 777;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n\n    function test_POC_ExerciseWrongArguments() public {\n        vm.createSelectFork(\"https://eth.llamarpc.com\");\n\n        address optionsModule_ = address(new BaseTOFTOptionsModule(address(LZ_ENDPOINT), address(0), IYieldBoxBase(address(2)), \"SomeName\", \"SomeSymbol\", 18, block.chainid));\n\n        TapiocaOFT tapiocaOft_ = new TapiocaOFT(\n            LZ_ENDPOINT,\n            address(0),\n            IYieldBoxBase(address(3)),\n            \"SomeName\",\n            \"SomeSymbol\",\n            18,\n            block.chainid,\n            payable(address(1)),\n            payable(address(2)),\n            payable(address(3)),\n            payable(optionsModule_)\n        );\n\n        address user_ = makeAddr(\"user\");\n        deal(user_, 2 ether);\n        vm.prank(user_);\n        tapiocaOft_.wrap{value: 1 ether}(user_, user_, 1 ether);\n\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData memory optionsData_; \n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData memory lzData_;\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData memory tapSendData_;\n        ICommonData.IApproval[] memory approvals_;\n\n        optionsData_.from = user_;\n        optionsData_.target = user_;\n        optionsData_.paymentTokenAmount = 1 ether;\n        optionsData_.oTAPTokenID = 1;\n        optionsData_.paymentToken = address(0);\n        optionsData_.tapAmount = 1 ether;\n\n        lzData_.lzDstChainId = 102;\n        lzData_.zroPaymentAddress = address(0);\n        lzData_.extraGas = 200_000;\n\n        tapSendData_.withdrawOnAnotherChain = false;\n        tapSendData_.tapOftAddress = address(0);\n        tapSendData_.lzDstChainId = 102;\n        tapSendData_.amount = 0;\n        tapSendData_.zroPaymentAddress = address(0);\n        tapSendData_.extraGas = 0;\n\n        tapiocaOft_.setTrustedRemoteAddress(102, abi.encodePacked(tapiocaOft_));\n\n        vm.prank(user_);\n        tapiocaOft_.exerciseOption{value: 1 ether}(\n            optionsData_,\n            lzData_,\n            tapSendData_,\n            approvals_\n        );\n\n        bytes memory lzPayload_ = abi.encode(\n            PT_TAP_EXERCISE,\n            optionsData_,\n            tapSendData_,\n            approvals_\n        );\n\n        vm.prank(LZ_ENDPOINT);\n        vm.expectEmit(true, true, true, true, address(tapiocaOft_));\n        emit MessageFailed(102, abi.encodePacked(tapiocaOft_, tapiocaOft_), 0, lzPayload_, vm.parseBytes(\"0x4e487b710000000000000000000000000000000000000000000000000000000000000041\"));\n        tapiocaOft_.lzReceive(102, abi.encodePacked(tapiocaOft_, tapiocaOft_), 0, lzPayload_);\n    }\n}\n```\n\n</details>\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nAdding the extra module parameter when encoding the function call in `_nonBlockingLzReceive()` would be vulnerable to someone calling the `BaseTOFTOptionsModule` directly on function `exercise()` with a malicious `module` argument. It's safer to remove the `module` argument and call `exerciseInternal()` directly, which should work since it's a `public` function.\n\n```solidity\nfunction _nonblockingLzReceive(\n    uint16 _srcChainId,\n    bytes memory _srcAddress,\n    uint64 _nonce,\n    bytes memory _payload\n) internal virtual override {\n    uint256 packetType = _payload.toUint256(0);\n    ...\n    } else if (packetType == PT_TAP_EXERCISE) {\n        _executeOnDestination(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exercise.selector,\n                address(optionsModule), // here\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            ),\n            _srcChainId,\n            _srcAddress,\n            _nonce,\n            _payload\n        );\n    ...\n```\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1069#issuecomment-1701975614)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.sendToYBAndBorrow.selector,\n                from,\n                to,\n                lzDstChainId,\n                airdropAdapterParams,\n                borrowParams,\n                withdrawParams,\n                options,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a leverage down operation\n    /// @param amount the amount to use\n    /// @param leverageFor the receiver address\n    /// @param lzData LZ specific data\n    /// @param swapData ISwapper specific data\n    /// @param externalData external contracts used for the flow\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.sendForLeverage.selector,\n                amount,\n                leverageFor,\n                lzData,\n                swapData,\n                externalData\n            ),\n            false\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n\n    //---internal-\n    function _wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual {\n        if (_fromAddress != msg.sender) {\n            require(\n                allowance(_fromAddress, msg.sender) >= _amount,\n                \"TOFT_allowed\"\n            );\n        }\n        IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);\n        _mint(_toAddress, _amount);\n    }\n\n    function _wrapNative(address _toAddress) internal virtual {\n        require(msg.value > 0, \"TOFT_0\");\n        _mint(_toAddress, msg.value);\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) internal virtual {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    //---private---\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        } else if (_module == Module.Strategy) {\n            module = address(strategyModule);\n        } else if (_module == Module.Market) {\n            module = address(marketModule);\n        } else if (_module == Module.Options) {\n            module = address(optionsModule);\n        }\n\n        if (module == address(0)) {\n            revert(\"TOFT_module\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data,\n        bool _forwardRevert\n    ) private returns (bool success, bytes memory returnData) {\n        success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success && !_forwardRevert) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeOnDestination(\n        Module _module,\n        bytes memory _data,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) private {\n        (bool success, bytes memory returnData) = _executeModule(\n            _module,\n            _data,\n            true\n        );\n        if (!success) {\n            _storeFailedMessage(\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload,\n                returnData\n            );\n        }\n    }\n\n    //---LZ---\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint256 packetType = _payload.toUint256(0);\n\n        if (packetType == PT_YB_SEND_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyDeposit.selector,\n                    strategyModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload,\n                    IERC20(address(this))\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_RETRIEVE_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyWithdraw.selector,\n                    _srcChainId,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_LEVERAGE_MARKET_DOWN) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.leverageDown.selector,\n                    leverageModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_SEND_SGL_BORROW) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.borrow.selector,\n                    marketModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_REMOVE_COLLATERAL) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.remove.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_MULTIHOP_SELL) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.multiHop.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_TAP_EXERCISE) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.exercise.selector,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_SEND_FROM) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.sendFromDestination.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else {\n            packetType = _payload.toUint8(0);\n            if (packetType == PT_SEND) {\n                _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else if (packetType == PT_SEND_AND_CALL) {\n                _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else {\n                revert(\"TOFT_packet\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTOptionsModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\n// import {ITapiocaOptionsBrokerCrossChain} from \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT options module\n/// @notice tOFT module for oTAP type actions\ncontract BaseTOFTOptionsModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes memory lzPayload = abi.encode(\n            PT_SEND_FROM,\n            msg.sender,\n            amount,\n            sendFromData,\n            lzEndpoint.getChainId(),\n            approvals\n        );\n\n        _lzSend(\n            lzDstChainId,\n            lzPayload,\n            payable(msg.sender),\n            zroPaymentAddress,\n            airdropAdapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzDstChainId,\n            msg.sender,\n            LzLib.addressToBytes32(msg.sender),\n            0\n        );\n    }\n\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 toAddress = LzLib.addressToBytes32(optionsData.from);\n\n        _debitFrom(\n            optionsData.from,\n            lzEndpoint.getChainId(),\n            toAddress,\n            optionsData.paymentTokenAmount\n        );\n\n        bytes memory lzPayload = abi.encode(\n            PT_TAP_EXERCISE,\n            optionsData,\n            tapSendData,\n            approvals\n        );\n\n        bytes memory adapterParams = LzLib.buildDefaultAdapterParams(\n            lzData.extraGas\n        );\n\n        _lzSend(\n            lzData.lzDstChainId,\n            lzPayload,\n            payable(optionsData.from),\n            lzData.zroPaymentAddress,\n            adapterParams,\n            msg.value\n        );\n\n        emit SendToChain(\n            lzData.lzDstChainId,\n            optionsData.from,\n            toAddress,\n            optionsData.paymentTokenAmount\n        );\n    }\n\n    function sendFromDestination(bytes memory _payload) public {\n        (\n            ,\n            address from,\n            uint256 amount,\n            ISendFrom.LzCallParams memory callParams,\n            uint16 lzDstChainId,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    address,\n                    uint256,\n                    ISendFrom.LzCallParams,\n                    uint16,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ISendFrom(address(this)).sendFrom{value: address(this).balance}(\n            from,\n            lzDstChainId,\n            LzLib.addressToBytes32(from),\n            amount,\n            callParams\n        );\n\n        emit ReceiveFromChain(lzDstChainId, from, 0);\n    }\n\n    function exercise(\n        address module,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) public {\n        (\n            ,\n            ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n                memory optionsData,\n            ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n                memory tapSendData,\n            ICommonData.IApproval[] memory approvals\n        ) = abi.decode(\n                _payload,\n                (\n                    uint16,\n                    ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData,\n                    ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData,\n                    ICommonData.IApproval[]\n                )\n            );\n\n        uint256 balanceBefore = balanceOf(address(this));\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        if (!credited) {\n            _creditTo(\n                _srcChainId,\n                address(this),\n                optionsData.paymentTokenAmount\n            );\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n        uint256 balanceAfter = balanceOf(address(this));\n\n        (bool success, bytes memory reason) = module.delegatecall(\n            abi.encodeWithSelector(\n                this.exerciseInternal.selector,\n                optionsData.from,\n                optionsData.oTAPTokenID,\n                optionsData.paymentToken,\n                optionsData.tapAmount,\n                optionsData.target,\n                tapSendData,\n                approvals\n            )\n        );\n\n        if (!success) {\n            if (\n                balanceAfter - balanceBefore >= optionsData.paymentTokenAmount\n            ) {\n                IERC20(address(this)).safeTransfer(\n                    optionsData.from,\n                    optionsData.paymentTokenAmount\n                );\n            }\n            revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor\n        }\n\n        emit ReceiveFromChain(\n            _srcChainId,\n            optionsData.from,\n            optionsData.paymentTokenAmount\n        );\n    }\n\n    function exerciseInternal(\n        address from,\n        uint256 oTAPTokenID,\n        address paymentToken,\n        uint256 tapAmount,\n        address target,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            memory tapSendData,\n        ICommonData.IApproval[] memory approvals\n    ) public {\n        if (approvals.length > 0) {\n            _callApproval(approvals);\n        }\n\n        ITapiocaOptionsBroker(target).exerciseOption(\n            oTAPTokenID,\n            paymentToken,\n            tapAmount\n        );\n        if (tapSendData.withdrawOnAnotherChain) {\n            ISendFrom(tapSendData.tapOftAddress).sendFrom(\n                address(this),\n                tapSendData.lzDstChainId,\n                LzLib.addressToBytes32(from),\n                tapAmount,\n                ISendFrom.LzCallParams({\n                    refundAddress: payable(from),\n                    zroPaymentAddress: tapSendData.zroPaymentAddress,\n                    adapterParams: LzLib.buildDefaultAdapterParams(\n                        tapSendData.extraGas\n                    )\n                })\n            );\n        } else {\n            IERC20(tapSendData.tapOftAddress).safeTransfer(from, tapAmount);\n        }\n    }\n\n    function _callApproval(ICommonData.IApproval[] memory approvals) private {\n        for (uint256 i = 0; i < approvals.length; ) {\n            if (approvals[i].permitBorrow) {\n                try\n                    IPermitBorrow(approvals[i].target).permitBorrow(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else if (approvals[i].permitAll) {\n                try\n                    IPermitAll(approvals[i].target).permitAll(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            } else {\n                try\n                    IERC20Permit(approvals[i].target).permit(\n                        approvals[i].owner,\n                        approvals[i].spender,\n                        approvals[i].value,\n                        approvals[i].deadline,\n                        approvals[i].v,\n                        approvals[i].r,\n                        approvals[i].s\n                    )\n                {} catch Error(string memory reason) {\n                    if (!approvals[i].allowFailure) {\n                        revert(reason);\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}