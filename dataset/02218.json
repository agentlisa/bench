{
  "Title": "H-7: Not all providers claim the rewards",
  "Content": "# Issue H-7: Not all providers claim the rewards \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/290 \n\n## Found by \nHonorLt, Jeiwan, hyh\n\n## Summary\n\nProviders wrongly assume that the protocols will no longer incentivize users with extra rewards.\n\n## Vulnerability Detail\n\nAmong the current providers only the `CompoundProvider` claims the `COMP` incentives, others leave the claim function empty:\n  ```solidity\n    function claim(address _aToken, address _claimer) public override returns (bool) {}\n  ```\n\nWhile many of the protocols currently do not offer extra incentives, it is not safe to assume it will not resume in the future, e.g. when bulls return to the town. For example, `Aave` supports multi rewards claim:\nhttps://docs.aave.com/developers/whats-new/multiple-rewards-and-claim\nWhen it was deployed on Optimism, it offered extra OP rewards for a limited time. There is no guarantee, but a similar thing might happen in the future with new chains and technology.\n\nWhile `Beta` currently does not have active rewards distribution but based on the schedule, it is likely to resume in the future:\nhttps://betafinance.gitbook.io/betafinance/beta-tokenomics#beta-token-distribution-schedule\n\n## Impact\n\nThe implementations of the providers are based on the current situation. They are not flexible enough to support the rewards in case the incentives are back.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/AaveProvider.sol#L115\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/BetaProvider.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust the providers to be ready to claim the rewards if necessary.\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nWhile true, we can easily replace the providers when new functionality for claiming tokens becomes available.\n\n**pauliax**\n\nEscalate for 10 USDC.\n\nWhile new providers can be added, old providers cannot be updated to accept these rewards, so users who were using old providers will get nothing and will be forced to migrate. Besides, deposits are not instantaneous, it takes time to rebalance them.\nAlso, not all rewards are liquidity mining, some are snapshot-based. Let's say an external entity decides to airdrop all the Aave lenders. Currently, there is no way to claim it and distribute it among real users. This will incur lost rewards for the end users, thus I believe it is a valid concern.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> \n> While new providers can be added, old providers cannot be updated to accept these rewards, so users who were using old providers will get nothing and will be forced to migrate. Besides, deposits are not instantaneous, it takes time to rebalance them.\n> Also, not all rewards are liquidity mining, some are snapshot-based. Let's say an external entity decides to airdrop all the Aave lenders. Currently, there is no way to claim it and distribute it among real users. This will incur lost rewards for the end users, thus I believe it is a valid concern.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nGiven that there are no implementations for claims in some of the providers considering these a valid high. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Given that there are no implementations for claims in some of the providers considering these a valid high. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Providers/AaveProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IAToken.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IALendingPool.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract AaveProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Aave\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Aave, send aTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(address(IAToken(_aToken).POOL()), _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    IALendingPool(IAToken(_aToken).POOL()).deposit(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender,\r\n      0\r\n    );\r\n\r\n    return _amount;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Aave\r\n  /// @dev Pulls cTokens from Vault, redeem them from Aave, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      IAToken(_aToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    uint256 uTokensReceived = IALendingPool(IAToken(_aToken).POOL()).withdraw(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in shares i.e LP tokens\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _aToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _aToken);\r\n    return balanceShares;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev Aave exchangeRate is 1\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _aToken) external view override returns (uint256) {\r\n    uint256 shares = _amount / exchangeRate(_aToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of aToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _aToken) public view override returns (uint256) {\r\n    uint256 _balanceShares = IAToken(_aToken).balanceOf(_address);\r\n    return _balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @dev Aave exchangeRate is always 1\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _aToken) public pure override returns (uint256) {\r\n    return 1;\r\n  }\r\n\r\n  function claim(address _aToken, address _claimer) public override returns (bool) {}\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Providers/BetaProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IBeta.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract BetaProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _bToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_bToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IBeta(_bToken).balanceOf(address(this));\r\n    IBeta(_bToken).mint(address(this), _amount);\r\n    uint256 tTokenAfter = IBeta(_bToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IBeta(_bToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _bToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IBeta(_bToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IBeta(_bToken).burn(address(this), _amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _bToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _bToken);\r\n    uint256 supply = IBeta(_bToken).totalSupply();\r\n    uint256 totalLoanable = IBeta(_bToken).totalLoanable();\r\n    uint256 totalLoan = IBeta(_bToken).totalLoan();\r\n\r\n    return (balanceShares * (totalLoanable + totalLoan)) / supply;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _bToken) external view override returns (uint256) {\r\n    uint256 supply = IBeta(_bToken).totalSupply();\r\n    uint256 totalLoanable = IBeta(_bToken).totalLoanable();\r\n    uint256 totalLoan = IBeta(_bToken).totalLoan();\r\n\r\n    return (_amount * supply) / (totalLoanable + totalLoan);\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _bToken) public view override returns (uint256) {\r\n    return IBeta(_bToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Not used for Beta\r\n  /// @param _bToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _bToken) public view override returns (uint256) {\r\n    // return IBeta(_bToken).tokenPrice();\r\n  }\r\n\r\n  function claim(address _bToken, address _claimer) external override returns (bool) {}\r\n}"
    }
  ]
}