{
  "Title": "Operator approval can cause unexpected behavior",
  "Content": "When an operator approval is set, the `_owners` data stores a flag at the 256th bit (this is done in both implementations, [Ethereum](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol#L83) and [Polygon](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/common/BaseWithStorage/ERC721BaseTokenV2.sol#L23)).\n\n\nThe `mintAndTransferQuad` function is used by `minters` to mint new quads or to transfer existing quads to a new address. When minting and transferring, the quad may be partially owned by the minter (can own some child quads) with the remainder of the quad being unowned (owned by the zero address). If the minter sets operator approval on any of the LAND tokens within the quad to be minted and transferred, the `mintAndTransferQuad` function will fail. Although the minter owns the token, the check performed on [line 357](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol#L357) in the Polygon implementation and on [line 264](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/LandBaseTokenV3.sol#L264) in the Ethereum implementation will fail since the 256th bit will never match `uint256(uint160(msg.sender))`. As a result, the function call will fail.\n\n\nFunction `_checkBatchReceiverAcceptQuadAndClearOwner` will fail to clear the owner of a quad with an operator approval set, as it also performs ownership checks following the pattern explained above, specifically, in lines [323](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/LandBaseTokenV3.sol#L323) and [343](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/Land/erc721/LandBaseTokenV3.sol#L343) in the Ethereum implementation and in lines [463](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol#L463) and [483](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol#L483) in the Polygon implementation.\n\n\nConsider disregarding the operator flag when checking ownership within the `_mintAndTransferQuad` and `_checkBatchReceiverAcceptQuadAndClearOwner` functions. Further, if an operator is set for any of the transferred tokens, the operator should be cleared from the operator mapping.\n\n\n***Update:** Resolved in [pull request #917](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/917) at commit [02f7bc8](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/917/commits/02f7bc8ea2cbfb371aee8ab0bb84d62be4d81c78).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/solc_0.5/Land/erc721/ERC721BaseTokenV2.sol",
      "content": "/* solhint-disable func-order, code-complexity */\npragma solidity 0.5.9;\n\nimport \"../../contracts_common/Libraries/AddressUtils.sol\";\nimport \"../../contracts_common/Interfaces/ERC721TokenReceiver.sol\";\nimport \"../../contracts_common/Interfaces/ERC721Events.sol\";\nimport \"../../contracts_common/BaseWithStorage/SuperOperatorsV2.sol\";\nimport \"../../contracts_common/BaseWithStorage/MetaTransactionReceiverV2.sol\";\nimport \"../../contracts_common/Interfaces/ERC721MandatoryTokenReceiver.sol\";\n\ncontract ERC721BaseTokenV2 is ERC721Events, SuperOperatorsV2, MetaTransactionReceiverV2 {\n    using AddressUtils for address;\n\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\n\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\n\n    mapping (address => uint256) public _numNFTPerAddress;\n    mapping (uint256 => uint256) public _owners;\n    mapping (address => mapping(address => bool)) public _operatorsForAll;\n    mapping (uint256 => address) public _operators;\n\n    bool internal _initialized;\n\n    modifier initializer() {\n        require(!_initialized, \"ERC721BaseToken: Contract already initialized\");\n        _;\n    }\n\n    function initialize (\n        address metaTransactionContract,\n        address admin\n    ) public initializer {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n        _initialized = true;\n    }\n\n    function _transferFrom(address from, address to, uint256 id) internal {\n        _numNFTPerAddress[from]--;\n        _numNFTPerAddress[to]++;\n        _owners[id] = uint256(to);\n        emit Transfer(from, to, id);\n    }\n\n    /**\n     * @notice Return the number of Land owned by an address\n     * @param owner The address to look for\n     * @return The number of Land token owned by the address\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }\n\n\n    function _ownerOf(uint256 id) internal view returns (address) {\n        return address(_owners[id]);\n    }\n\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\n        uint256 data = _owners[id];\n        owner = address(data);\n        operatorEnabled = (data / 2**255) == 1;\n    }\n\n    /**\n     * @notice Return the owner of a Land\n     * @param id The id of the Land\n     * @return The address of the owner\n     */\n    function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }\n\n    function _approveFor(address owner, address operator, uint256 id) internal {\n        if(operator == address(0)) {\n            _owners[id] = uint256(owner); // no need to resset the operator, it will be overriden next time\n        } else {\n            _owners[id] = uint256(owner) + 2**255;\n            _operators[id] = operator;\n        }\n        emit Approval(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _operatorsForAll[sender][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n    function approve(address operator, uint256 id) external {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(\n            owner == msg.sender ||\n            _operatorsForAll[owner][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve\"\n        );\n        _approveFor(owner, operator, id);\n    }\n\n    /**\n     * @notice Get the approved operator for a specific token\n     * @param id The id of the token\n     * @return The address of the operator\n     */\n    function getApproved(uint256 id) external view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }\n\n    function _checkTransfer(address from, address to, uint256 id) internal view returns (bool isMetaTx) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == from, \"not owner in _checkTransfer\");\n        require(to != address(0), \"can't send to zero address\");\n        isMetaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        if (msg.sender != from && !isMetaTx) {\n            require(\n                _operatorsForAll[from][msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender) ||\n                _superOperators[msg.sender],\n                \"not approved to transfer\"\n            );\n        }\n    }\n\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        bool success;\n        bool result;\n        bytes memory call_data = abi.encodeWithSelector(\n            ERC165ID,\n            interfaceId\n        );\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let call_ptr := add(0x20, call_data)\n            let call_size := mload(call_data)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(\n                10000,\n                _contract,\n                call_ptr,\n                call_size,\n                output,\n                0x20\n            ) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n    */\n    function transferFrom(address from, address to, uint256 id) external {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"),\n                \"erc721 transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data),\n                \"ERC721: transfer rejected by to\"\n            );\n        }\n    }\n\n    /**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n    function safeTransferFrom(address from, address to, uint256 id) external {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, false);\n    }\n\n    function _batchTransferFrom(address from, address to, uint256[] memory ids, bytes memory data, bool safe) internal {\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\n        bool authorized = msg.sender == from ||\n            metaTx ||\n            _operatorsForAll[from][msg.sender] ||\n            _superOperators[msg.sender];\n\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n\n        uint256 numTokens = ids.length;\n        for(uint256 i = 0; i < numTokens; i ++) {\n            uint256 id = ids[i];\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n            require(owner == from, \"not owner in batchTransferFrom\");\n            require(authorized || (operatorEnabled && _operators[id] == msg.sender), \"not authorized\");\n            _owners[id] = uint256(to);\n            emit Transfer(from, to, id);\n        }\n        if (from != to) {\n            _numNFTPerAddress[from] -= numTokens;\n            _numNFTPerAddress[to] += numTokens;\n        }\n\n        if (to.isContract()) {\n            if (_checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n                require(\n                    _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\n                    \"erc721 batch transfer rejected by to\"\n                );\n            } else if (safe) {\n                for (uint256 i = 0; i < numTokens; i ++) {\n                    require(\n                        _checkOnERC721Received(metaTx ? from : msg.sender, from, to, ids[i], \"\"),\n                        \"erc721 transfer rejected by to\"\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n    */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\n        _batchTransferFrom(from, to, ids, data, true);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) external pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        require(\n            msg.sender == sender ||\n            _metaTransactionContracts[msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to approve for all\"\n        );\n\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(\n            !_superOperators[operator],\n            \"super operator can't have their approvalForAll changed\"\n        );\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @notice Check if the sender approved the operator\n     * @param owner The address of the owner\n     * @param operator The address of the operator\n     * @return The status of the approval\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool isOperator)\n    {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function _burn(address from, address owner, uint256 id) internal {\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }\n\n    /// @notice Burns token `id`.\n    /// @param id token which will be burnt.\n    function burn(uint256 id) external {\n        _burn(msg.sender, _ownerOf(id), id);\n    }\n\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token which will be burnt.\n    function burnFrom(address from, uint256 id) external {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n            _metaTransactionContracts[msg.sender] ||\n            (operatorEnabled && _operators[id] == msg.sender) ||\n            _operatorsForAll[from][msg.sender] ||\n            _superOperators[msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }\n\n    function _checkOnERC721Received(address operator, address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _checkOnERC721BatchReceived(address operator, address from, address to, uint256[] memory ids, bytes memory _data)\n        internal returns (bool)\n    {\n        bytes4 retval = ERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\n        return (retval == _ERC721_BATCH_RECEIVED);\n    }\n\n    // Empty storage space in contracts for future enhancements\n    // ref: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/issues/13)\n    uint256[49] private __gap;\n}"
    },
    {
      "filename": "src/solc_0.8/polygon/child/land/PolygonLandBaseTokenV2.sol",
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\n\npragma solidity 0.8.2;\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"../../../common/BaseWithStorage/ERC721BaseTokenV2.sol\";\nimport \"../../../common/interfaces/IPolygonLand.sol\";\n\nabstract contract PolygonLandBaseTokenV2 is IPolygonLand, Initializable, ERC721BaseTokenV2 {\n    using AddressUpgradeable for address;\n\n    uint256 internal constant GRID_SIZE = 408;\n\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\n\n    mapping(address => bool) internal _minters;\n\n    event Minter(address minter, bool enabled);\n\n    struct Land {\n        uint256 x;\n        uint256 y;\n        uint256 size;\n    }\n\n    modifier validQuad(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) {\n        require(size == 1 || size == 3 || size == 6 || size == 12 || size == 24, \"Invalid size\");\n        require(x % size == 0 && y % size == 0, \"Invalid coordinates\");\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \"Out of bounds\");\n\n        _;\n    }\n\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param sizes list of sizes for each quad\n    /// @param xs list of top left x coordinates for each quad\n    /// @param ys list of top left y coordinates for each quad\n    /// @param data additional data\n    function batchTransferQuad(\n        address from,\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes calldata data\n    ) external override {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        require(sizes.length == xs.length && xs.length == ys.length, \"invalid data\");\n        if (_msgSender() != from) {\n            require(\n                _operatorsForAll[from][_msgSender()] || _superOperators[_msgSender()],\n                \"not authorized to transferMultiQuads\"\n            );\n        }\n        uint256 numTokensTransfered = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            uint256 size = sizes[i];\n            _transferQuad(from, to, size, xs[i], ys[i]);\n            numTokensTransfered += size * size;\n        }\n        _numNFTPerAddress[from] -= numTokensTransfered;\n        _numNFTPerAddress[to] += numTokensTransfered;\n\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](numTokensTransfered);\n            uint256 counter = 0;\n            for (uint256 j = 0; j < sizes.length; j++) {\n                uint256 size = sizes[j];\n                for (uint256 i = 0; i < size * size; i++) {\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\n                    counter++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(_msgSender(), from, to, ids, data),\n                \"erc721 batch transfer rejected by to\"\n            );\n        }\n    }\n\n    /// @notice Enable or disable the ability of `minter` to transfer tokens of all (minter rights).\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external {\n        require(_msgSender() == _admin, \"only admin is allowed to add minters\");\n        require(minter != address(0), \"PolygonLand: Invalid address\");\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\n    /// @param from current owner of the quad\n    /// @param to destination\n    /// @param size size of the quad\n    /// @param x The top left x coordinate of the quad\n    /// @param y The top left y coordinate of the quad\n    /// @param data additional data\n    function transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external override {\n        require(from != address(0), \"from is zero address\");\n        require(to != address(0), \"can't send to zero address\");\n        if (_msgSender() != from) {\n            require(\n                _operatorsForAll[from][_msgSender()] || _superOperators[_msgSender()],\n                \"not authorized to transferQuad\"\n            );\n        }\n        _transferQuad(from, to, size, x, y);\n        _numNFTPerAddress[from] -= size * size;\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(_msgSender(), from, to, size, x, y, data);\n    }\n\n    /**\n     * @notice Mint a new quad (aligned to a quad tree with size 1, 3, 6, 12 or 24 only)\n     * @param user The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintQuad(\n        address user,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) external virtual override validQuad(size, x, y) {\n        require(isMinter(_msgSender()), \"!AUTHORIZED\");\n        _mintQuad(user, size, x, y, data);\n    }\n\n    /**\n     * @notice Checks if a parent quad has child quads already minted.\n     *  Then mints the rest child quads and transfers the parent quad.\n     *  Should only be called by the tunnel.\n     * @param to The recipient of the new quad\n     * @param size The size of the new quad\n     * @param x The top left x coordinate of the new quad\n     * @param y The top left y coordinate of the new quad\n     * @param data extra data to pass to the transfer\n     */\n    function mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes calldata data\n    ) external virtual {\n        require(isMinter(msg.sender), \"!AUTHORIZED\");\n        require(to != address(0), \"to is zero address\");\n\n        if (exists(size, x, y) == true) {\n            _transferQuad(msg.sender, to, size, x, y);\n            _numNFTPerAddress[msg.sender] -= size * size;\n            _numNFTPerAddress[to] += size * size;\n            _checkBatchReceiverAcceptQuad(msg.sender, msg.sender, to, size, x, y, data);\n        } else {\n            _mintAndTransferQuad(to, size, x, y, data);\n        }\n    }\n\n    /// @notice x coordinate of Land token\n    /// @param id tokenId\n    /// @return the x coordinates\n    function getX(uint256 id) external pure returns (uint256) {\n        return _getX(id);\n    }\n\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) public virtual override(ILandToken, ERC721BaseTokenV2) {\n        super.batchTransferFrom(from, to, ids, data);\n    }\n\n    /// @notice y coordinate of Land token\n    /// @param id tokenId\n    /// @return the y coordinates\n    function getY(uint256 id) external pure returns (uint256) {\n        return _getY(id);\n    }\n\n    /**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * 0x5b5e139f is ERC-721 metadata\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n    function supportsInterface(bytes4 id) public pure override returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\n    }\n\n    /**\n     * @notice Return the name of the token contract\n     * @return The name of the token contract\n     */\n    function name() public pure returns (string memory) {\n        return \"Sandbox's LANDs\";\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    /// @notice checks if Land has been minted or not\n    /// @param size size of the\n    /// @param x x coordinate of the quad\n    /// @param y y coordinate of the quad\n    /// @return bool for if Land has been minted or not\n    function exists(\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) public view override validQuad(size, x, y) returns (bool) {\n        return _ownerOfQuad(size, x, y) != address(0);\n    }\n\n    /**\n     * @notice Return the symbol of the token contract\n     * @return The symbol of the token contract\n     */\n    function symbol() public pure returns (string memory) {\n        return \"LAND\";\n    }\n\n    /// @notice total width of the map\n    /// @return width\n    function width() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /// @notice total height of the map\n    /// @return height\n    function height() public pure returns (uint256) {\n        return GRID_SIZE;\n    }\n\n    /**\n     * @notice Return the URI of a specific token\n     * @param id The id of the token\n     * @return The URI of the token\n     */\n    function tokenURI(uint256 id) public view returns (string memory) {\n        require(_ownerOf(id) != address(0), \"Id does not exist\");\n        return\n            string(\n                abi.encodePacked(\"https://api.sandbox.game/lands/\", StringsUpgradeable.toString(id), \"/metadata.json\")\n            );\n    }\n\n    function _transferQuad(\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y\n    ) internal validQuad(size, x, y) {\n        if (size == 1) {\n            uint256 id1x1 = _getQuadId(LAYER_1x1, x, y);\n            address owner = _ownerOf(id1x1);\n            require(owner != address(0), \"token does not exist\");\n            require(owner == from, \"not owner in _transferQuad\");\n            _owners[id1x1] = uint256(uint160(address(to)));\n        } else {\n            _regroup(from, to, size, x, y);\n        }\n        for (uint256 i = 0; i < size * size; i++) {\n            emit Transfer(from, to, _idInPath(i, size, x, y));\n        }\n    }\n\n    function _mintQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        require(to != address(0), \"to is zero address\");\n\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        _checkOwner(size, x, y, 24);\n        for (uint256 i = 0; i < size * size; i++) {\n            uint256 _id = _idInPath(i, size, x, y);\n            require(_owners[_id] == 0, \"Already minted\");\n            emit Transfer(address(0), to, _id);\n        }\n\n        _owners[quadId] = uint256(uint160(to));\n        _numNFTPerAddress[to] += size * size;\n\n        _checkBatchReceiverAcceptQuad(msg.sender, address(0), to, size, x, y, data);\n    }\n\n    function _mintAndTransferQuad(\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        (uint256 layer, , ) = _getQuadLayer(size);\n        uint256 quadId = _getQuadId(layer, x, y);\n\n        // Length of array is equal to number of 3x3 child quad a 24x24 quad can have\n        Land[] memory quadMinted = new Land[](64);\n        uint256 index;\n        uint256 landMinted;\n\n        if (size > 3) {\n            (index, landMinted) = _checkAndClearOwner(\n                Land({x: x, y: y, size: size}),\n                quadMinted,\n                landMinted,\n                index,\n                size / 2\n            );\n        }\n\n        {\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 _id = _idInPath(i, size, x, y);\n                bool isAlreadyMinted = _isQuadMinted(quadMinted, Land({x: _getX(_id), y: _getY(_id), size: 1}), index);\n                if (isAlreadyMinted) {\n                    emit Transfer(msg.sender, to, _id);\n                } else {\n                    if (_owners[_id] == uint256(uint160(msg.sender))) {\n                        landMinted += 1;\n                        emit Transfer(msg.sender, to, _id);\n                    } else {\n                        require(_owners[_id] == 0, \"Already minted\");\n\n                        emit Transfer(address(0), to, _id);\n                    }\n                }\n            }\n        }\n\n        _checkBatchReceiverAcceptQuadAndClearOwner(quadMinted, index, landMinted, to, size, x, y, data);\n\n        _owners[quadId] = uint256(uint160(to));\n        _numNFTPerAddress[to] += size * size;\n        _numNFTPerAddress[msg.sender] -= landMinted;\n    }\n\n    function _checkAndClearOwner(\n        Land memory land,\n        Land[] memory quadMinted,\n        uint256 landMinted,\n        uint256 index,\n        uint256 quadCompareSize\n    ) internal returns (uint256, uint256) {\n        (uint256 layer, , ) = _getQuadLayer(quadCompareSize);\n        uint256 toX = land.x + land.size;\n        uint256 toY = land.y + land.size;\n\n        for (uint256 xi = land.x; xi < toX; xi += quadCompareSize) {\n            for (uint256 yi = land.y; yi < toY; yi += quadCompareSize) {\n                bool isQuadChecked = _isQuadMinted(quadMinted, Land({x: xi, y: yi, size: quadCompareSize}), index);\n                if (!isQuadChecked) {\n                    uint256 id = _getQuadId(layer, xi, yi);\n                    address owner = address(uint160(_owners[id]));\n\n                    if (owner == msg.sender) {\n                        quadMinted[index] = Land({x: xi, y: yi, size: quadCompareSize});\n                        index++;\n                        landMinted += quadCompareSize * quadCompareSize;\n                        _owners[id] = 0;\n                    } else {\n                        require(owner == address(0), \"Already minted\");\n                    }\n                }\n            }\n        }\n\n        quadCompareSize = quadCompareSize / 2;\n        if (quadCompareSize >= 3)\n            (index, landMinted) = _checkAndClearOwner(land, quadMinted, landMinted, index, quadCompareSize);\n        return (index, landMinted);\n    }\n\n    function _checkAndClear(address from, uint256 id) internal returns (bool) {\n        uint256 owner = _owners[id];\n        if (owner != 0) {\n            require((owner & BURNED_FLAG) != BURNED_FLAG, \"not owner\");\n            require(address(uint160(owner)) == from, \"not owner\");\n            _owners[id] = 0;\n            return true;\n        }\n        return false;\n    }\n\n    function _checkBatchReceiverAcceptQuad(\n        address operator,\n        address from,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory ids = new uint256[](size * size);\n            for (uint256 i = 0; i < size * size; i++) {\n                ids[i] = _idInPath(i, size, x, y);\n            }\n            require(_checkOnERC721BatchReceived(operator, from, to, ids, data), \"erc721 batch transfer rejected by to\");\n        }\n    }\n\n    function _checkBatchReceiverAcceptQuadAndClearOwner(\n        Land[] memory quadMinted,\n        uint256 index,\n        uint256 landMinted,\n        address to,\n        uint256 size,\n        uint256 x,\n        uint256 y,\n        bytes memory data\n    ) internal {\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            uint256[] memory idsToTransfer = new uint256[](landMinted);\n            uint256 transferIndex;\n            uint256[] memory idsToMint = new uint256[]((size * size) - landMinted);\n            uint256 mintIndex;\n\n            for (uint256 i = 0; i < size * size; i++) {\n                uint256 id = _idInPath(i, size, x, y);\n\n                if (_isQuadMinted(quadMinted, Land({x: _getX(id), y: _getY(id), size: 1}), index)) {\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else if (_owners[id] == uint256(uint160(msg.sender))) {\n                    _owners[id] = 0;\n                    idsToTransfer[transferIndex] = id;\n                    transferIndex++;\n                } else {\n                    idsToMint[mintIndex] = id;\n                    mintIndex++;\n                }\n            }\n            require(\n                _checkOnERC721BatchReceived(msg.sender, address(0), to, idsToMint, data),\n                \"erc721 batch transfer rejected by to\""
    }
  ]
}