{
  "Title": "M-4: WalletImpl cannot receive NFTs as intended",
  "Content": "# Issue M-4: WalletImpl cannot receive NFTs as intended \n\nSource: https://github.com/sherlock-audit/2023-04-splits-judging/issues/57 \n\n## Found by \nobront\n\n## Summary\n\nWalletImpl is intended to turn pass through wallets into generalizable wallets that can be used for any purpose, including receiving NFTs. However, because it does not implement the `onERC721Received()` and `onERC1155Received()` functions, it will not pass the checks for `safeTransferFrom()` and will not be able to be used for NFTs as intended.\n\n## Vulnerability Detail\n\n`WalletImpl.sol` is inherited by `PassThroughWalletImpl.sol` and `SwapperImpl.sol` to turn them into generalizable smart contract wallets. It implements an `execCalls()` function that allows the owner to perform any arbitrary action on behalf of the contract.\n\nThe purpose of this was explained by Will in the contest Discord channel: \n\n> we wanted it to have the full flexibility of a smart contract wallet for various situations which might arise when using it as a pay to address (eg if you use an address for primary proceeds on artblocks it also must be able to receive & handle NFTS)\n\nHowever, as it is currently implemented thee contracts will not be able to receive NFTs sent with `safeTransferFrom()`, because they do not implement the necessary functions to safely receive these tokens..\n\nWhile in many cases such a situation would be Medium severity, looking at Will's example above makes clear that the circumstances in which these wallets will be used could lead to more serious consequences. For example, having a wallet that is entitled to high value NFTs but is not able to receive them is clearly a loss of funds risk, and a High severity issue.\n\n## Impact\n\nAny time an ERC721 or ERC1155 is attempted to be transferred with `safeTransferFrom()` or minted with `safeMint()`, the call will fail.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-splits/blob/main/splits-utils/src/WalletImpl.sol#L9-L66\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInclude `onERC721Received()` and `onERC1155Received()` functions in `WalletImpl.sol`.\n\n\n\n## Discussion\n\n**ctf-sec**\n\n@wminshew Would love to hear your thought on this one.\n\nThe submission is true but because the issue is confirmed via DM and not in the context readme doc, I think the issue can be a valid low.\n\n**wminshew**\n\n@ctf-sec definitely a valid issue. I am not sure how loss-of-funds would be defined in my own artblocks example given -- I don't think the NFTs are lost, just that the txn would fail and the artist would have to use a different wallet/address? if the NFTs were indeed lost (vs txn reverting) that would feel like a High to me. if txn reverts, i can see arguments for a low or possibly medium (i suppose even if txn reverts for AB there is a chance this would result in total loss for other protocols?)\n\n**ctf-sec**\n\nThanks for your comment. I will add the \"low severity\" label for now. \n\nIn the project doc of the auditing contest.\n\n> Q: Which ERC721 tokens do you expect will interact with the smart contracts?\n> none\n\n**wminshew**\n\nyes that's a good point and my bad -- the diversifier (pass-through wallet) is expected to interact w arbitrary 721s & 1155s but I flubbed that FAQ sorry\n\n**wminshew**\n\n> Thanks for your comment. I will add the \"low severity\" label for now.\n\nthinking about this more i feel like this should be at least medium and possible high -- any nft flow that relied on a pull/claim would've resulted in lost funds\n\n**ctf-sec**\n\nComment from Sherlock:\n\nThe readme excluding usage of NFT's makes this one really difficult. \nHave pushed hard for Validating issues based on readme information in the past and not discord messages valid. Will need to stick to it, \nWe need to definitely consider updating contest information mid-contest if needed. Not sure yet how to do that. \n\nKeep it medium from the onERC1155Received() point of view. \n\nIn case there is an escalation we can look into it further. \n\n**zobront**\n\nFixed in https://github.com/0xSplits/splits-utils/pull/3/\n\n**jacksanford1**\n\nConfirming that Splits meant for this fix (3) to link to this issue (57):\nhttps://github.com/0xSplits/splits-utils/pull/3#issue-1693165292\n\n**wminshew**\n\nconfirmed\n\n**securitygrid**\n\nEscalate for 10 USDC.\nIt is clearly stated in README.md:\n***Q: Which ERC721 tokens do you expect will interact with the smart contracts?\n  none***\nso, this issue is not valid H/M.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> It is clearly stated in README.md:\n> ***Q: Which ERC721 tokens do you expect will interact with the smart contracts?\n>   none***\n> so, this issue is not valid H/M.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**z0ld**\n\nEscalate for 10 USDC\nI would like to bring attention to an issue that I believe deserves further consideration and escalation. As mentioned in the discussion above, the pass-through wallet is expected to interact with arbitrary ERC721s & ERC1155s. However, the rules for the auditing contest mention no expected interaction with ERC721 tokens in the Q&A, and it appears ERC1155 tokens follow the same situation.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I would like to bring attention to an issue that I believe deserves further consideration and escalation. As mentioned in the discussion above, the pass-through wallet is expected to interact with arbitrary ERC721s & ERC1155s. However, the rules for the auditing contest mention no expected interaction with ERC721 tokens in the Q&A, and it appears ERC1155 tokens follow the same situation.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nWhile the readme denies any interaction with ERC721 tokens, this issue still holds true for ERC1155 tokens, there is no explicit exclusion of these tokens and the issue raised clearly breaks an intended functionality of the Wallet implementations. \nThis is a valid medium. \n\n\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> While the readme denies any interaction with ERC721 tokens, this issue still holds true for ERC1155 tokens, there is no explicit exclusion of these tokens and the issue raised clearly breaks an intended functionality of the Wallet implementations. \n> This is a valid medium. \n> \n> \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/65",
  "Code": [
    {
      "filename": "splits-utils/src/WalletImpl.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {OwnableImpl} from \"./OwnableImpl.sol\";\n\n/// @title Wallet Implementation\n/// @author 0xSplits\n/// @notice Minimal smart wallet clone-implementation\nabstract contract WalletImpl is OwnableImpl {\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    event ExecCalls(Call[] calls);\n\n    /// -----------------------------------------------------------------------\n    /// storage - mutables\n    /// -----------------------------------------------------------------------\n\n    /// slot 0 - 12 bytes free\n\n    /// OwnableImpl storage\n    /// address internal $owner;\n    /// 20 bytes\n\n    /// -----------------------------------------------------------------------\n    /// constructor & initializer\n    /// -----------------------------------------------------------------------\n\n    constructor() {}\n\n    function __initWallet(address owner_) internal {\n        OwnableImpl.__initOwnable(owner_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - external & public - onlyOwner\n    /// -----------------------------------------------------------------------\n\n    /// allow owner to execute arbitrary calls\n    function execCalls(Call[] calldata calls_)\n        external\n        payable\n        onlyOwner\n        returns (uint256 blockNumber, bytes[] memory returnData)\n    {\n        blockNumber = block.number;\n        uint256 length = calls_.length;\n        returnData = new bytes[](length);\n\n        bool success;\n        for (uint256 i; i < length;) {\n            Call calldata calli = calls_[i];\n            (success, returnData[i]) = calli.to.call{value: calli.value}(calli.data);\n            require(success, string(returnData[i]));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ExecCalls(calls_);\n    }\n}"
    }
  ]
}