{
  "Title": "M-4: Forwarding yield in `OCL_ZVE` is possible a lot more often than the enforced 30 days",
  "Content": "# Issue M-4: Forwarding yield in `OCL_ZVE` is possible a lot more often than the enforced 30 days \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/55 \n\n## Found by \n0xpiken, Krace, cergyk, lemonmon, samuraii77\n## Summary\nCalling `OCL_ZVE::forwardYield()` is supposed to only be possible every 30 days however in reality, it is possible to call the function a lot more often.\n\n## Vulnerability Detail\nThe `require` statement in `OCL_ZVE::forwardYield()` enforces that the function should only be callable when `block.timestamp` is of larger value than the value of `nextYieldDistribution`\n```solidity\n    function forwardYield() external {\n        if (IZivoeGlobals_OCL_ZVE(GBL).isKeeper(_msgSender())) {\n            require(\n                block.timestamp > nextYieldDistribution - 12 hours, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution - 12 hours\"\n            );\n        }\n        else {\n            require(\n                block.timestamp > nextYieldDistribution, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution\"\n            );\n        }\n\n        (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n        (basis,) = fetchBasis();\n        nextYieldDistribution += 30 days;\n    }\n```\nThen, at the end of the function, `nextYieldDistribution` is incremented by 30 days making the function supposedly not callable for another 30 days. However, there is a vulnerability that allows `OCL_ZVE::forwardYield()` to be called a lot more times.\n\nUpon calling the `OCL_ZVE::pushToLockerMulti()`, the `nextYieldDistribution` gets set to `block.timestamp + 30 days` if its value is 0.\n```solidity\nif (nextYieldDistribution == 0) { nextYieldDistribution = block.timestamp + 30 days; }\n```\nIf this is the way `nextYieldDistribution` gets its first value, then there will not be an issue. However, if `OCL_ZVE::forwardYield()` is called beforehand, then `nextYieldDistribution` will be set to `0 += 30 days` which equals `30 days` making its value a lot less than the value of `block.timestamp` resulting in people being able to call `OCL_ZVE::forwardYield()` at will all the way until `nextYieldDistribution` gets incremented all the way to `block.timestamp`.\n\nCalling `OCL_ZVE::forwardYield()` before any other function is possible and requires just 1 simple circumstance to be a fact.\n\nImagine the following scenario:\n1. `OCL_ZVE::forwardYield()` is called\n2. The `if` statement passes as `block.timestamp` is larger than `nextYieldDistribution`, the value of which is the default value of 0\n3. `OCL_ZVE::fetchBasis()` gets called\n```solidity\nfunction fetchBasis() public view returns (uint256 amount, uint256 lp) {\n        address pool = IFactory_OCL_ZVE(factory).getPair(pairAsset, IZivoeGlobals_OCL_ZVE(GBL).ZVE());\n        uint256 pairAssetBalance = IERC20(pairAsset).balanceOf(pool);\n        uint256 poolTotalSupply = IERC20(pool).totalSupply();\n        lp = IERC20(pool).balanceOf(address(this));\n        amount = lp * pairAssetBalance / poolTotalSupply;\n    } \n```\n4. As long as there is a pool setup for `pairAsset` and `ZVE`, the vulnerability will take place\n5. Pool gets the value of the pool address\n6. The only thing which has to pass here is `poolTotalSupply` not being 0 as division by 0 is not possible\n7. That successfully passes as there is already a setup pool for `pairAsset` and `ZVE`\n8. Then, we get back to the `OCL_ZVE::forwardYield()` function\n9. `if(amount > basis)` does not pass as both values are 0\n10. On the last line, `nextYieldDistribution` gets set to `30 days` making the `OCL_ZVE::forwardYield()` function callable again and again\n\n## Impact\n`OCL_ZVE::forwardYield()` is callable over and over again even though it is only supposed to be called every 30 days\n\n## Proof Of Concept\nPaste the following test into `Test_OCL_ZVE.sol`:\n```solidity\nfunction testCanForwardYieldALot() public {\n        address UNIV2_ROUTER = OCL_ZVE_UNIV2_DAI.router();\n        deal(DAI, address(this), 10000);\n\n        IERC20(DAI).safeApprove(UNIV2_ROUTER, 10000);\n        IERC20(ZVE).safeApprove(UNIV2_ROUTER, 1001);\n\n        IUniswapV2Router01(UNIV2_ROUTER).addLiquidity(address(DAI), address(ZVE), 10000, 1001, 0, 0, address(this), block.timestamp);\n\n        uint256 count;\n        while (block.timestamp > OCL_ZVE_UNIV2_DAI.nextYieldDistribution()) {\n            OCL_ZVE_UNIV2_DAI.forwardYield();\n            count++;\n        }\n\n        console.log(count);\n    }\n```\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L186\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol#L287-L305\n\n## Tool used\n\nManual Review\n\n## Recommendation\nDo not allow `OCL_ZVE::forwardYield()` to be called whenever the value of `nextYieldDistribution` is equal to 0. \nAlso, another option is to set `nextYieldDistribution` to `block.timestamp + 30 days` instead of just incrementing it by `30 days`.\n\n\n\n## Discussion\n\n**coreggon11**\n\nIf `pushToLockerMulti` was not called, then nothing will be forwarded.\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium, if `forwardYield` is called just after contract creation, then `nextYieldDistribution` becomes incorrect and `forwardYield` can be called at any time by anyone. The impact is limited, but the protocol functionality is broken (no time limit for calling `forwardYield`)\n\n\n\n**pseudonaut**\n\nWouldn't `_forwardYield()` revert due to division by 0 if basis is 0 ?\n\n```solidity\nfunction forwardYield() external {\n        ...\n        (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n```\n\nOr rather `_forwardYield()` wouldn't even be called `if (amount > basis) { _forwardYield(amount, lp); }` ...\n\n```solidity\nfunction _forwardYield(uint256 amount, uint256 lp) private nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        uint256 lpBurnable = (amount - basis) * lp / amount * (BIPS - compoundingRateBIPS) / BIPS;\n```\n\n**panprog**\n\n@pseudonaut \nThis is correct, `_forwardYield` will not be called, the point is that the last line of `forwardYield`:\n```solidity\nnextYieldDistribution += 30 days;\n```\nwill make `nextYieldDistribution = 30 days`, thus all future `forwardYield` will ignore timestamp check because `block.timestamp` will always be greater than `nextYieldDistribution`.\n\nThe issue is valid, keeping it medium.\n\n**spacegliderrrr**\n\nEscalate\n\nIssues which can be mitigated by correct admin configuration upon deployment are not valid according to Sherlock rules. Issue should be low.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> Issues which can be mitigated by correct admin configuration upon deployment are not valid according to Sherlock rules. Issue should be low.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**samuraii77**\n\n> Escalate\n> \n> Issues which can be mitigated by correct admin configuration upon deployment are not valid according to Sherlock rules. Issue should be low.\n\nPushing into the locker upon deployment is in no way, shape or form, correct admin configuration. That is not even a configuration.\n\n**panprog**\n\nAgree with @samuraii77 , this can only be mitigated if admin pushes into locker in the same transaction as contract creation, which doesn't seem to be reasonable assumption as this should not be part of the deployment.\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/265\n\n\n**WangSecurity**\n\nAs I understand from Zivoe's [Deployment diagram on Figma](https://www.figma.com/board/qjuQ0uGQl9QD7KeBwyf73d/Zivoe-Visualization?node-id=0-1), they indeed will initially call `push` on lockers (phase three) and only then `forwardYield` (phase four). Hence, I believe this report requires an admin acting as not intended (i.e. calling `forwardYield` before `pushToLockerMulti`), therefore, should be invalid.\n\nPlanning to reject an escalation and leave the issue as it is.\n\n**samuraii77**\n\nThe issue does not rely on an admin acting not as intended. The `forwardYield()` function can be called by any user after the contract has been deployed which as visible by the diagram you provided happens at phase 1 and pushing happens all the way in phase 3. Basically, that means that a user has the time between phase 1 and phase 3 to just call `forwardYield()` in order for the vulnerability to happen. Issue should stay valid.\n\n\nAlso, I am not sure if I get you correctly but it seems like you are disputing my issue and agreeing with the escalation but then proceed to say that you will reject the escalation and keep the issue as it is, not sure if I interpreted your comment wrong.\n\n**WangSecurity**\n\nYep, sorry for that two confusions here and I agree that indeed the locker is deployed earlier than push is called. Therefore, this issue indeed may occur.\n\nPlanning to reject the escalation and leave the issue as it is.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [spacegliderrrr](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/55/#issuecomment-2105747094): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IFactory_OCL_ZVE {\n    /// @notice Returns the address of the pair for tokenA and tokenB, if it has been created, else address(0).\n    /// @param tokenA Address of one of pair's tokens.\n    /// @param tokenB Address of pair's other token.\n    /// @return pair The address of the pair.\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IRouter_OCL_ZVE {\n    /// @notice Adds liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param amountADesired Amount tokenA to add as liquidity if B/A <= amountBDesired/amountADesired (A depreciates).\n    /// @param amountBDesired Amount tokenB to add as liquidity if A/B <= amountADesired/amountBDesired (B depreciates).\n    /// @param amountAMin Bounds B/A price max before the transaction reverts. Must be <= amountADesired.\n    /// @param amountBMin Bounds A/B price max before the transaction reverts. Must be <= amountBDesired.\n    /// @param to Recipient of the liquidity tokens.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA sent to the pool.\n    /// @return amountB The amount of tokenB sent to the pool.\n    /// @return liquidity The amount of liquidity tokens minted.\n    function addLiquidity(\n        address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Removes liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param liquidity The amount of liquidity tokens to remove.\n    /// @param amountAMin The minimum amount of tokenA that must be received for the transaction not to revert.\n    /// @param amountBMin The minimum amount of tokenB that must be received for the transaction not to revert.\n    /// @param to Recipient of the underlying assets.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA received.\n    /// @return amountB The amount of tokenB received.\n    function removeLiquidity(\n        address tokenA, address tokenB, uint256 liquidity, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IZivoeGlobals_OCL_ZVE {\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    function isKeeper(address) external view returns (bool);\n}\n\ninterface IZivoeYDL_OCL_ZVE {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\n\n/// @notice This contract manages liquidity provisioning for a Uniswap v2 or Sushi pool.\n///         This contract has the following responsibilities:\n///           - Allocate capital to a $ZVE/pairAsset pool.\n///           - Remove capital from a $ZVE/pairAsset pool.\n///           - Forward yield (profits) every 30 days to the YDL with compounding mechanisms.\ncontract OCL_ZVE is ZivoeLocker, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n    address public immutable factory;           /// @dev Address for the Factory (Uniswap v2 or Sushi).\n    address public immutable pairAsset;         /// @dev ERC20 that will be paired with $ZVE for Sushi pool.\n    address public immutable router;            /// @dev Address for the Router (Uniswap v2 or Sushi).\n\n    address public OCT_YDL;                     /// @dev Facilitates swaps and forwards distributedAsset() to YDL.\n    \n    uint256 public basis;                       /// @dev The basis used for forwardYield() accounting.\n    uint256 public compoundingRateBIPS = 5000;  /// @dev The % of returns to retain, in BIPS.\n    uint256 public nextYieldDistribution;       /// @dev Determines next available forwardYield() call.\n\n    uint256 private constant BIPS = 10000;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCL_ZVE contract.\n    /// @param DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param _GBL The ZivoeGlobals contract.\n    /// @param _pairAsset ERC20 that will be paired with $ZVE for pool.\n    /// @param  _OCT_YDL The contract that facilitates swaps and forwards distributedAsset() to YDL.\n    constructor(address DAO, address _GBL, address _pairAsset, address _router, address _factory, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        pairAsset = _pairAsset;\n        router = _router;\n        factory = _factory;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events   \n    // ------------\n\n    /// @notice Emitted during pullFromLocker() and pullFromLockerPartial() and _forwardYield() [via forwardYield()].\n    /// @param  amountBurned Amount of liquidity tokens burned.\n    /// @param  claimedZVE Amount of ZVE claimed.\n    /// @param  claimedPairAsset Amount of pairAsset claimed.\n    event LiquidityTokensBurned(uint256 amountBurned, uint256 claimedZVE, uint256 claimedPairAsset);\n\n    /// @notice Emitted during pushToLockerMulti().\n    /// @param  amountMinted Amount of liquidity tokens minted.\n    /// @param  depositedZVE Amount of ZVE deposited.\n    /// @param  depositedPairAsset Amount of pairAsset deposited.\n    event LiquidityTokensMinted(uint256 amountMinted, uint256 depositedZVE, uint256 depositedPairAsset);\n\n    /// @notice Emitted during updateCompoundingRateBIPS().\n    /// @param  oldValue The old value of compoundingRateBIPS.\n    /// @param  newValue The new value of compoundingRateBIPS.\n    event UpdatedCompoundingRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n    /// @notice Emitted during forwardYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  amount The amount distributed.\n    event YieldForwarded(address indexed asset, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLockerMulti().\n    function canPushMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice This pulls capital from the DAO and adds liquidity into a $ZVE/pairAsset pool.\n    /// @param  assets The assets to pull from the DAO.\n    /// @param  amounts The amount to pull of each asset respectively.\n    /// @param  data Accompanying transaction data.\n    function pushToLockerMulti(\n        address[] calldata assets, uint256[] calldata amounts, bytes[] calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        require(\n            assets[0] == pairAsset && assets[1] == ZVE,\n            \"OCL_ZVE::pushToLockerMulti() assets[0] != pairAsset || assets[1] != ZVE\"\n        );\n\n        for (uint256 i = 0; i < 2; i++) {\n            require(amounts[i] >= 10 * 10**6, \"OCL_ZVE::pushToLockerMulti() amounts[i] < 10 * 10**6\");\n            IERC20(assets[i]).safeTransferFrom(owner(), address(this), amounts[i]);\n        }\n\n        if (nextYieldDistribution == 0) { nextYieldDistribution = block.timestamp + 30 days; }\n\n        uint256 preBasis;\n        if (basis != 0) { (preBasis,) = fetchBasis(); }\n\n        // Router addLiquidity() endpoint.\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        uint balZVE = IERC20(ZVE).balanceOf(address(this));\n        IERC20(pairAsset).safeIncreaseAllowance(router, balPairAsset);\n        IERC20(ZVE).safeIncreaseAllowance(router, balZVE);\n\n        // Prevent volatility of greater than 10% in pool relative to amounts present.\n        (uint256 depositedPairAsset, uint256 depositedZVE, uint256 minted) = IRouter_OCL_ZVE(router).addLiquidity(\n            pairAsset, \n            ZVE, \n            balPairAsset,\n            balZVE, \n            (balPairAsset * 9) / 10,\n            (balZVE * 9) / 10, \n            address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensMinted(minted, depositedZVE, depositedPairAsset);\n        assert(IERC20(pairAsset).allowance(address(this), router) == 0);\n        assert(IERC20(ZVE).allowance(address(this), router) == 0);\n\n        // Increase basis by difference.\n        (uint256 postBasis,) = fetchBasis();\n        require(postBasis > preBasis, \"OCL_ZVE::pushToLockerMulti() postBasis <= preBasis\");\n        basis += postBasis - preBasis;\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            uint256 preBalLPToken = IERC20(pair).balanceOf(address(this));\n            IERC20(pair).safeIncreaseAllowance(router, preBalLPToken);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, preBalLPToken, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(preBalLPToken, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n\n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            basis = 0;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), IERC20(asset).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  amount The amount of \"asset\" to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLockerPartial(\n        address asset, uint256 amount, bytes calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            (uint256 preBasis,) = fetchBasis();\n            IERC20(pair).safeIncreaseAllowance(router, amount);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, amount, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(amount, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n            \n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            (uint256 postBasis,) = fetchBasis();\n            require(postBasis < preBasis, \"OCL_ZVE::pullFromLockerPartial() postBasis >= preBasis\");\n            basis -= preBasis - postBasis;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), amount);\n        }\n    }\n\n    /// @notice This forwards yield in excess of the basis.\n    function forwardYield() external {\n        if (IZivoeGlobals_OCL_ZVE(GBL).isKeeper(_msgSender())) {\n            require(\n                block.timestamp > nextYieldDistribution - 12 hours, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution - 12 hours\"\n            );\n        }\n        else {\n            require(\n                block.timestamp > nextYieldDistribution, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution\"\n            );\n        }\n\n        (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n        (basis,) = fetchBasis();\n        nextYieldDistribution += 30 days;\n    }\n\n    /// @notice This forwards yield to the YDL in the form of pairAsset.\n    /// @dev    Private function, only callable via forwardYield().\n    /// @param  amount Current pairAsset harvestable.\n    /// @param  lp Current ZVE/pairAsset LP tokens.\n    function _forwardYield(uint256 amount, uint256 lp) private nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        uint256 lpBurnable = (amount - basis) * lp / amount * (BIPS - compoundingRateBIPS) / BIPS;\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        IERC20(pair).safeIncreaseAllowance(router, lpBurnable);\n        (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n            pairAsset, ZVE, lpBurnable, 0, 0, address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensBurned(lpBurnable, claimedZVE, claimedPairAsset);\n        assert(IERC20(pair).allowance(address(this), router) == 0);\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        emit YieldForwarded(pairAsset, balPairAsset);\n        if (pairAsset != IZivoeYDL_OCL_ZVE(IZivoeGlobals_OCL_ZVE(GBL).YDL()).distributedAsset()) {\n            IERC20(pairAsset).safeTransfer(OCT_YDL, balPairAsset);\n        }\n        else {\n            IERC20(pairAsset).safeTransfer(IZivoeGlobals_OCL_ZVE(GBL).YDL(), balPairAsset);\n        }\n        IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n    }\n\n    /// @notice Returns amount of pairAsset redeemable with current LP position.\n    /// @dev    The withdrawal mechanism is ZVE/pairAsset_LP => pairAsset.\n    /// @return amount Current pairAsset harvestable.\n    /// @return lp Current ZVE/pairAsset LP tokens.\n    function fetchBasis() public view returns (uint256 amount, uint256 lp) {\n        address pool = IFactory_OCL_ZVE(factory).getPair(pairAsset, IZivoeGlobals_OCL_ZVE(GBL).ZVE());\n        uint256 pairAssetBalance = IERC20(pairAsset).balanceOf(pool);\n        uint256 poolTotalSupply = IERC20(pool).totalSupply();\n        lp = IERC20(pool).balanceOf(address(this));\n        amount = lp * pairAssetBalance / poolTotalSupply;\n    }\n\n    /// @notice Updates the compounding rate of this contract.\n    /// @dev    A value of 2,000 represent 20% of the earnings stays in this contract, compounding.\n    /// @param  _compoundingRateBIPS The new compounding rate value.\n    function updateCompoundingRateBIPS(uint256 _compoundingRateBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCL_ZVE(GBL).TLC(), \n            \"OCL_ZVE::updateCompoundingRateBIPS() _msgSender() != IZivoeGlobals_OCL_ZVE(GBL).TLC()\"\n        );\n        require(_compoundingRateBIPS <= BIPS, \"OCL_ZVE::updateCompoundingRateBIPS() ratio > BIPS\");\n\n        emit UpdatedCompoundingRateBIPS(compoundingRateBIPS, _compoundingRateBIPS);\n        compoundingRateBIPS = _compoundingRateBIPS;\n    }\n\n    /// @notice Update the OCT_YDL endpoint.\n    /// @dev    This function MUST only be called by ZVL().\n    /// @param  _OCT_YDL The new address for OCT_YDL.\n    function updateOCTYDL(address _OCT_YDL) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCL_ZVE(GBL).ZVL(), \n            \"OCL_ZVE::updateOCTYDL() _msgSender() != IZivoeGlobals_OCL_ZVE(GBL).ZVL()\"\n        );\n        require(_OCT_YDL != address(0), \"OCL_ZVE::updateOCTYDL() _OCT_YDL == address(0)\");\n        emit UpdatedOCTYDL(_OCT_YDL, OCT_YDL);\n        OCT_YDL = _OCT_YDL;\n    }\n    \n}"
    },
    {
      "filename": "zivoe-core-foundry/src/lockers/OCL/OCL_ZVE.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IFactory_OCL_ZVE {\n    /// @notice Returns the address of the pair for tokenA and tokenB, if it has been created, else address(0).\n    /// @param tokenA Address of one of pair's tokens.\n    /// @param tokenB Address of pair's other token.\n    /// @return pair The address of the pair.\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IRouter_OCL_ZVE {\n    /// @notice Adds liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param amountADesired Amount tokenA to add as liquidity if B/A <= amountBDesired/amountADesired (A depreciates).\n    /// @param amountBDesired Amount tokenB to add as liquidity if A/B <= amountADesired/amountBDesired (B depreciates).\n    /// @param amountAMin Bounds B/A price max before the transaction reverts. Must be <= amountADesired.\n    /// @param amountBMin Bounds A/B price max before the transaction reverts. Must be <= amountBDesired.\n    /// @param to Recipient of the liquidity tokens.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA sent to the pool.\n    /// @return amountB The amount of tokenB sent to the pool.\n    /// @return liquidity The amount of liquidity tokens minted.\n    function addLiquidity(\n        address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Removes liquidity in a pool with both ERC20 tokens A and B.\n    /// @param tokenA A pool token.\n    /// @param tokenB A pool token.\n    /// @param liquidity The amount of liquidity tokens to remove.\n    /// @param amountAMin The minimum amount of tokenA that must be received for the transaction not to revert.\n    /// @param amountBMin The minimum amount of tokenB that must be received for the transaction not to revert.\n    /// @param to Recipient of the underlying assets.\n    /// @param deadline Unix timestamp after which the transaction will revert.\n    /// @return amountA The amount of tokenA received.\n    /// @return amountB The amount of tokenB received.\n    function removeLiquidity(\n        address tokenA, address tokenB, uint256 liquidity, \n        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n\ninterface IZivoeGlobals_OCL_ZVE {\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    function isKeeper(address) external view returns (bool);\n}\n\ninterface IZivoeYDL_OCL_ZVE {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\n\n/// @notice This contract manages liquidity provisioning for a Uniswap v2 or Sushi pool.\n///         This contract has the following responsibilities:\n///           - Allocate capital to a $ZVE/pairAsset pool.\n///           - Remove capital from a $ZVE/pairAsset pool.\n///           - Forward yield (profits) every 30 days to the YDL with compounding mechanisms.\ncontract OCL_ZVE is ZivoeLocker, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n    address public immutable factory;           /// @dev Address for the Factory (Uniswap v2 or Sushi).\n    address public immutable pairAsset;         /// @dev ERC20 that will be paired with $ZVE for Sushi pool.\n    address public immutable router;            /// @dev Address for the Router (Uniswap v2 or Sushi).\n\n    address public OCT_YDL;                     /// @dev Facilitates swaps and forwards distributedAsset() to YDL.\n    \n    uint256 public basis;                       /// @dev The basis used for forwardYield() accounting.\n    uint256 public compoundingRateBIPS = 5000;  /// @dev The % of returns to retain, in BIPS.\n    uint256 public nextYieldDistribution;       /// @dev Determines next available forwardYield() call.\n\n    uint256 private constant BIPS = 10000;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCL_ZVE contract.\n    /// @param DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param _GBL The ZivoeGlobals contract.\n    /// @param _pairAsset ERC20 that will be paired with $ZVE for pool.\n    /// @param  _OCT_YDL The contract that facilitates swaps and forwards distributedAsset() to YDL.\n    constructor(address DAO, address _GBL, address _pairAsset, address _router, address _factory, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        pairAsset = _pairAsset;\n        router = _router;\n        factory = _factory;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events   \n    // ------------\n\n    /// @notice Emitted during pullFromLocker() and pullFromLockerPartial() and _forwardYield() [via forwardYield()].\n    /// @param  amountBurned Amount of liquidity tokens burned.\n    /// @param  claimedZVE Amount of ZVE claimed.\n    /// @param  claimedPairAsset Amount of pairAsset claimed.\n    event LiquidityTokensBurned(uint256 amountBurned, uint256 claimedZVE, uint256 claimedPairAsset);\n\n    /// @notice Emitted during pushToLockerMulti().\n    /// @param  amountMinted Amount of liquidity tokens minted.\n    /// @param  depositedZVE Amount of ZVE deposited.\n    /// @param  depositedPairAsset Amount of pairAsset deposited.\n    event LiquidityTokensMinted(uint256 amountMinted, uint256 depositedZVE, uint256 depositedPairAsset);\n\n    /// @notice Emitted during updateCompoundingRateBIPS().\n    /// @param  oldValue The old value of compoundingRateBIPS.\n    /// @param  newValue The new value of compoundingRateBIPS.\n    event UpdatedCompoundingRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n    /// @notice Emitted during forwardYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  amount The amount distributed.\n    event YieldForwarded(address indexed asset, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLockerMulti().\n    function canPushMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice This pulls capital from the DAO and adds liquidity into a $ZVE/pairAsset pool.\n    /// @param  assets The assets to pull from the DAO.\n    /// @param  amounts The amount to pull of each asset respectively.\n    /// @param  data Accompanying transaction data.\n    function pushToLockerMulti(\n        address[] calldata assets, uint256[] calldata amounts, bytes[] calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        require(\n            assets[0] == pairAsset && assets[1] == ZVE,\n            \"OCL_ZVE::pushToLockerMulti() assets[0] != pairAsset || assets[1] != ZVE\"\n        );\n\n        for (uint256 i = 0; i < 2; i++) {\n            require(amounts[i] >= 10 * 10**6, \"OCL_ZVE::pushToLockerMulti() amounts[i] < 10 * 10**6\");\n            IERC20(assets[i]).safeTransferFrom(owner(), address(this), amounts[i]);\n        }\n\n        if (nextYieldDistribution == 0) { nextYieldDistribution = block.timestamp + 30 days; }\n\n        uint256 preBasis;\n        if (basis != 0) { (preBasis,) = fetchBasis(); }\n\n        // Router addLiquidity() endpoint.\n        uint balPairAsset = IERC20(pairAsset).balanceOf(address(this));\n        uint balZVE = IERC20(ZVE).balanceOf(address(this));\n        IERC20(pairAsset).safeIncreaseAllowance(router, balPairAsset);\n        IERC20(ZVE).safeIncreaseAllowance(router, balZVE);\n\n        // Prevent volatility of greater than 10% in pool relative to amounts present.\n        (uint256 depositedPairAsset, uint256 depositedZVE, uint256 minted) = IRouter_OCL_ZVE(router).addLiquidity(\n            pairAsset, \n            ZVE, \n            balPairAsset,\n            balZVE, \n            (balPairAsset * 9) / 10,\n            (balZVE * 9) / 10, \n            address(this), block.timestamp + 14 days\n        );\n        emit LiquidityTokensMinted(minted, depositedZVE, depositedPairAsset);\n        assert(IERC20(pairAsset).allowance(address(this), router) == 0);\n        assert(IERC20(ZVE).allowance(address(this), router) == 0);\n\n        // Increase basis by difference.\n        (uint256 postBasis,) = fetchBasis();\n        require(postBasis > preBasis, \"OCL_ZVE::pushToLockerMulti() postBasis <= preBasis\");\n        basis += postBasis - preBasis;\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            uint256 preBalLPToken = IERC20(pair).balanceOf(address(this));\n            IERC20(pair).safeIncreaseAllowance(router, preBalLPToken);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, preBalLPToken, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(preBalLPToken, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n\n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            basis = 0;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), IERC20(asset).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice This burns LP tokens from the $ZVE/pairAsset pool and returns them to the DAO.\n    /// @param  asset The asset to burn.\n    /// @param  amount The amount of \"asset\" to burn.\n    /// @param  data Accompanying transaction data.\n    function pullFromLockerPartial(\n        address asset, uint256 amount, bytes calldata data\n    ) external override onlyOwner nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        \n        (uint amountAMin, uint amountBMin) = abi.decode(data, (uint, uint));\n\n        // \"pair\" represents the liquidity pool token (minted, burned).\n        // \"pairAsset\" represents the stablecoin paired against $ZVE.\n        if (asset == pair) {\n            (uint256 preBasis,) = fetchBasis();\n            IERC20(pair).safeIncreaseAllowance(router, amount);\n\n            // Router removeLiquidity() endpoint.\n            (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n                pairAsset, ZVE, amount, \n                amountAMin, amountBMin, address(this), block.timestamp + 14 days\n            );\n            emit LiquidityTokensBurned(amount, claimedZVE, claimedPairAsset);\n            assert(IERC20(pair).allowance(address(this), router) == 0);\n            \n            IERC20(pairAsset).safeTransfer(owner(), IERC20(pairAsset).balanceOf(address(this)));\n            IERC20(ZVE).safeTransfer(owner(), IERC20(ZVE).balanceOf(address(this)));\n            (uint256 postBasis,) = fetchBasis();\n            require(postBasis < preBasis, \"OCL_ZVE::pullFromLockerPartial() postBasis >= preBasis\");\n            basis -= preBasis - postBasis;\n        }\n        else {\n            IERC20(asset).safeTransfer(owner(), amount);\n        }\n    }\n\n    /// @notice This forwards yield in excess of the basis.\n    function forwardYield() external {\n        if (IZivoeGlobals_OCL_ZVE(GBL).isKeeper(_msgSender())) {\n            require(\n                block.timestamp > nextYieldDistribution - 12 hours, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution - 12 hours\"\n            );\n        }\n        else {\n            require(\n                block.timestamp > nextYieldDistribution, \n                \"OCL_ZVE::forwardYield() block.timestamp <= nextYieldDistribution\"\n            );\n        }\n\n        (uint256 amount, uint256 lp) = fetchBasis();\n        if (amount > basis) { _forwardYield(amount, lp); }\n        (basis,) = fetchBasis();\n        nextYieldDistribution += 30 days;\n    }\n\n    /// @notice This forwards yield to the YDL in the form of pairAsset.\n    /// @dev    Private function, only callable via forwardYield().\n    /// @param  amount Current pairAsset harvestable.\n    /// @param  lp Current ZVE/pairAsset LP tokens.\n    function _forwardYield(uint256 amount, uint256 lp) private nonReentrant {\n        address ZVE = IZivoeGlobals_OCL_ZVE(GBL).ZVE();\n        uint256 lpBurnable = (amount - basis) * lp / amount * (BIPS - compoundingRateBIPS) / BIPS;\n        address pair = IFactory_OCL_ZVE(factory).getPair(pairAsset, ZVE);\n        IERC20(pair).safeIncreaseAllowance(router, lpBurnable);\n        (uint256 claimedPairAsset, uint256 claimedZVE) = IRouter_OCL_ZVE(router).removeLiquidity(\n            pairAsset, ZVE, lpBurnable, 0, 0, address(this), b"
    }
  ]
}