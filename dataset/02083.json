{
  "Title": "H-18: Incorrect parameter ordering in function call",
  "Content": "# Issue H-18: Incorrect parameter ordering in function call \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/97 \n\n## Found by \nfloat-audits\n\n## Summary\n\nThe ordering of parameters in function call made in `updateTotalBorrowing()` in `PositionUtils.sol` is incorrect.\n\n## Vulnerability Detail\n\nThe function call of `updateTotalBorrowing()` in `PositionUtils.sol` has a different parameter ordering to the one defined in the actual function being called in `MarketUtils.sol`.\n\nMore specifically, `params.position.borrowingFactor()` and `params.position.sizeInUsd()` are swapped around.\n\n## Impact\n\nUpdating the total borrowing function with incorrect parameter values would upset the internal accounting of the system and would result in loss of user funds.\n\n## Code Snippet\n\nLoc:\n- `PositionUtils.sol`: https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/PositionUtils.sol#L460-L474\n- `MarketUtils.sol`: https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L1773-L1793\n\n\nIn `PositionUtils.sol`\n```solidity\nfunction updateTotalBorrowing(\n    PositionUtils.UpdatePositionParams memory params,\n    uint256 nextPositionSizeInUsd,\n    uint256 nextPositionBorrowingFactor\n) internal {\n    MarketUtils.updateTotalBorrowing(\n        params.contracts.dataStore,\n        params.market.marketToken,\n        params.position.isLong(),\n        params.position.borrowingFactor(),\n        params.position.sizeInUsd(),\n        nextPositionSizeInUsd,\n        nextPositionBorrowingFactor\n    );\n}\n```\n\nIn `MarketUtils.sol`\n```solidity\nfunction updateTotalBorrowing(\n    DataStore dataStore,\n    address market,\n    bool isLong,\n    uint256 prevPositionSizeInUsd,\n    uint256 prevPositionBorrowingFactor,\n    uint256 nextPositionSizeInUsd,\n    uint256 nextPositionBorrowingFactor\n) external {\n    uint256 totalBorrowing = getNextTotalBorrowing(\n        dataStore,\n        market,\n        isLong,\n        prevPositionSizeInUsd,\n        prevPositionBorrowingFactor,\n        nextPositionSizeInUsd,\n        nextPositionBorrowingFactor\n    );\n\n    setTotalBorrowing(dataStore, market, isLong, totalBorrowing);\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCorrect the ordering of parameters in function call made in `PositionUtils.sol` so that it aligns to that defined in the function signature in `MarketUtils.sol`\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/3508caf10d1bda24f21e768e945494fd581c0986\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/PositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../utils/Precision.sol\";\n\nimport \"./Position.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"../pricing/PositionPricingUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../referral/ReferralEventUtils.sol\";\n\n// @title PositionUtils\n// @dev Library for position functions\nlibrary PositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n\n    // @dev UpdatePositionParams struct used in increasePosition to avoid\n    // stack too deep errors\n    //\n    // @param market the values of the trading market\n    // @param order the decrease position order\n    // @param position the order's position\n    // @param positionKey the key of the order's position\n    // @param collateral the collateralToken of the position\n    // @param collateralDeltaAmount the amount of collateralToken deposited\n    struct UpdatePositionParams {\n        BaseOrderUtils.ExecuteOrderParamsContracts contracts;\n        Market.Props market;\n        Order.Props order;\n        bytes32 orderKey;\n        Position.Props position;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param referralStorage IReferralStorage\n    struct UpdatePositionParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    struct WillPositionCollateralBeSufficientValues {\n        uint256 positionSizeInUsd;\n        uint256 positionCollateralAmount;\n        int256 positionPnlUsd;\n        int256 realizedPnlUsd;\n        int256 openInterestDelta;\n    }\n\n    struct DecreasePositionCollateralValuesOutput {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    // @dev ProcessCollateralValues struct used to contain the values in processCollateral\n    // @param executionPrice the order execution price\n    // @param remainingCollateralAmount the remaining collateral amount of the position\n    // @param outputAmount the output amount\n    // @param positionPnlUsd the pnl of the position in USD\n    // @param pnlAmountForPool the pnl for the pool in token amount\n    // @param pnlAmountForUser the pnl for the user in token amount\n    // @param sizeDeltaInTokens the change in position size in tokens\n    // @param priceImpactAmount the price impact in tokens\n    struct DecreasePositionCollateralValues {\n        address pnlTokenForPool;\n        uint256 executionPrice;\n        int256 remainingCollateralAmount;\n        int256 positionPnlUsd;\n        int256 pnlAmountForPool;\n        uint256 pnlAmountForUser;\n        uint256 sizeDeltaInTokens;\n        int256 priceImpactAmount;\n        uint256 priceImpactDiffUsd;\n        uint256 priceImpactDiffAmount;\n        DecreasePositionCollateralValuesOutput output;\n    }\n\n    // @dev DecreasePositionCache struct used in decreasePosition to\n    // avoid stack too deep errors\n    // @param prices the prices of the tokens in the market\n    // @param pnlToken the token that the pnl for the user is in, for long positions\n    // this is the market.longToken, for short positions this is the market.shortToken\n    // @param pnlTokenPrice the price of the pnlToken\n    // @param initialCollateralAmount the initial collateral amount\n    // @param nextPositionSizeInUsd the new position size in USD\n    // @param nextPositionBorrowingFactor the new position borrowing factor\n    struct DecreasePositionCache {\n        MarketUtils.MarketPrices prices;\n        int256 estimatedPositionPnlUsd;\n        int256 estimatedRealizedPnlUsd;\n        int256 estimatedRemainingPnlUsd;\n        address pnlToken;\n        Price.Props pnlTokenPrice;\n        uint256 initialCollateralAmount;\n        uint256 nextPositionSizeInUsd;\n        uint256 nextPositionBorrowingFactor;\n    }\n\n\n    struct GetPositionPnlUsdCache {\n        int256 positionValue;\n        int256 totalPositionPnl;\n        address pnlToken;\n        uint256 poolTokenAmount;\n        uint256 poolTokenPrice;\n        uint256 poolTokenUsd;\n        int256 poolPnl;\n        int256 cappedPoolPnl;\n        uint256 sizeDeltaInTokens;\n        int256 positionPnlUsd;\n    }\n\n    // @dev IsPositionLiquidatableCache struct used in isPositionLiquidatable\n    // to avoid stack too deep errors\n    // @param positionPnlUsd the position's pnl in USD\n    // @param minCollateralFactor the min collateral factor\n    // @param collateralUsd the position's collateral in USD\n    // @param priceImpactUsd the price impact of closing the position in USD\n    // @param minCollateralUsd the minimum allowed collateral in USD\n    // @param remainingCollateralUsd the remaining position collateral in USD\n    struct IsPositionLiquidatableCache {\n        int256 positionPnlUsd;\n        uint256 minCollateralFactor;\n        uint256 collateralUsd;\n        int256 priceImpactUsd;\n        int256 minCollateralUsd;\n        int256 minCollateralUsdForLeverage;\n        int256 remainingCollateralUsd;\n    }\n\n    error LiquidatablePosition();\n    error EmptyPosition(uint256 sizeInUsd, uint256 sizeInTokens, uint256 collateralAmount);\n\n    // @dev get the position pnl in USD\n    //\n    // for long positions, pnl is calculated as:\n    // (position.sizeInTokens * indexTokenPrice) - position.sizeInUsd\n    // if position.sizeInTokens is larger for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // for short positions, pnl is calculated as:\n    // position.sizeInUsd -  (position.sizeInTokens * indexTokenPrice)\n    // if position.sizeInTokens is smaller for long positions, the position will have\n    // larger profits and smaller losses for the same changes in token price\n    //\n    // @param position the position values\n    // @param sizeDeltaUsd the change in position size\n    // @param indexTokenPrice the price of the index token\n    //\n    // @return (positionPnlUsd, sizeDeltaInTokens)\n    function getPositionPnlUsd(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        Position.Props memory position,\n        uint256 indexTokenPrice,\n        uint256 sizeDeltaUsd\n    ) public view returns (int256, uint256) {\n        GetPositionPnlUsdCache memory cache;\n\n        // position.sizeInUsd is the cost of the tokens, positionValue is the current worth of the tokens\n        cache.positionValue = (position.sizeInTokens() * indexTokenPrice).toInt256();\n        cache.totalPositionPnl = position.isLong() ? cache.positionValue - position.sizeInUsd().toInt256() : position.sizeInUsd().toInt256() - cache.positionValue;\n\n        if (cache.totalPositionPnl > 0) {\n            cache.pnlToken = position.isLong() ? market.longToken : market.shortToken;\n            cache.poolTokenAmount = MarketUtils.getPoolAmount(dataStore, market.marketToken, cache.pnlToken);\n            cache.poolTokenPrice = position.isLong() ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n            cache.poolTokenUsd = cache.poolTokenAmount * cache.poolTokenPrice;\n            cache.poolPnl = MarketUtils.getPnl(\n                dataStore,\n                market.marketToken,\n                market.longToken,\n                market.shortToken,\n                indexTokenPrice,\n                position.isLong(),\n                true\n            );\n\n            cache.cappedPoolPnl = MarketUtils.getCappedPnl(\n                dataStore,\n                market.marketToken,\n                position.isLong(),\n                cache.poolPnl,\n                cache.poolTokenUsd,\n                Keys.MAX_PNL_FACTOR_FOR_TRADERS\n            );\n\n            if (cache.cappedPoolPnl != cache.poolPnl && cache.cappedPoolPnl > 0 && cache.poolPnl > 0) {\n                // divide by WEI_PRECISION to reduce the risk of overflow\n                cache.totalPositionPnl = cache.totalPositionPnl * (cache.cappedPoolPnl / Precision.WEI_PRECISION.toInt256()) / (cache.poolPnl / Precision.WEI_PRECISION.toInt256());\n            }\n        }\n\n        cache.sizeDeltaInTokens;\n\n        if (position.sizeInUsd() == sizeDeltaUsd) {\n            cache.sizeDeltaInTokens = position.sizeInTokens();\n        } else {\n            if (position.isLong()) {\n                cache.sizeDeltaInTokens = Calc.roundUpDivision(position.sizeInTokens() * sizeDeltaUsd, position.sizeInUsd());\n            } else {\n                cache.sizeDeltaInTokens = position.sizeInTokens() * sizeDeltaUsd / position.sizeInUsd();\n            }\n        }\n\n        cache.positionPnlUsd = cache.totalPositionPnl * cache.sizeDeltaInTokens.toInt256() / position.sizeInTokens().toInt256();\n\n        return (cache.positionPnlUsd, cache.sizeDeltaInTokens);\n    }\n\n    // @dev convert sizeDeltaUsd to sizeDeltaInTokens\n    // @param sizeInUsd the position size in USD\n    // @param sizeInTokens the position size in tokens\n    // @param sizeDeltaUsd the position size change in USD\n    // @return the size delta in tokens\n    function getSizeDeltaInTokens(uint256 sizeInUsd, uint256 sizeInTokens, uint256 sizeDeltaUsd) internal pure returns (uint256) {\n        return sizeInTokens * sizeDeltaUsd / sizeInUsd;\n    }\n\n    // @dev get the key for a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @return the position key\n    function getPositionKey(address account, address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        bytes32 key = keccak256(abi.encode(account, market, collateralToken, isLong));\n        return key;\n    }\n\n    // @dev validate that a position is not empty\n    // @param position the position values\n    function validateNonEmptyPosition(Position.Props memory position) internal pure {\n        if (position.sizeInUsd() == 0 || position.sizeInTokens() == 0 || position.collateralAmount() == 0) {\n            revert EmptyPosition(position.sizeInUsd(), position.sizeInTokens(), position.collateralAmount());\n        }\n    }\n\n    // @dev check if a position is valid\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param market the market values\n    // @param prices the prices of the tokens in the market\n    // @param shouldValidateMinCollateralUsd whether min collateral usd needs to be validated\n    // validation is skipped for decrease position to prevent reverts in case the order size\n    // is just slightly smaller than the position size\n    // in decrease position, the remaining collateral is estimated at the start, and the order\n    // size is updated to match the position size if the remaining collateral will be less than\n    // the min collateral usd\n    // since this is an estimate, there may be edge cases where there is a small remaining position size\n    // and small amount of collateral remaining\n    // validation is skipped for this case as it is preferred for the order to be executed\n    // since the small amount of collateral remaining only impacts the potential payment of liquidation\n    // keepers\n    function validatePosition(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        bool shouldValidateMinCollateralUsd\n    ) public view {\n        validateNonEmptyPosition(position);\n\n        if (isPositionLiquidatable(\n            dataStore,\n            referralStorage,\n            position,\n            market,\n            prices,\n            shouldValidateMinCollateralUsd\n        )) {\n            revert LiquidatablePosition();\n        }\n    }\n\n    // @dev check if a position is liquidatable\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param market the market values\n    // @param prices the prices of the tokens in the market\n    function isPositionLiquidatable(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        bool shouldValidateMinCollateralUsd\n    ) public view returns (bool) {\n        IsPositionLiquidatableCache memory cache;\n\n        (cache.positionPnlUsd, ) = getPositionPnlUsd(\n            dataStore,\n            market,\n            prices,\n            position,\n            prices.indexTokenPrice.pickPriceForPnl(position.isLong(), false),\n            position.sizeInUsd()\n        );\n\n        cache.minCollateralFactor = MarketUtils.getMinCollateralFactor(dataStore, market.marketToken);\n\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            position.collateralToken(),\n            market,\n            prices\n        );\n\n        cache.collateralUsd = position.collateralAmount() * collateralTokenPrice.min;\n\n        cache.priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                dataStore,\n                market.marketToken,\n                market.indexToken,\n                market.longToken,\n                market.shortToken,\n                -position.sizeInUsd().toInt256(),\n                position.isLong()\n            )\n        );\n\n        // even if there is a large positive price impact, positions that would be liquidated\n        // if the positive price impact is reduced should not be allowed to be created\n        // as they would be easily liquidated if the price impact changes\n        // cap the priceImpactUsd to zero to prevent these positions from being created\n        if (cache.priceImpactUsd > 0) {\n            cache.priceImpactUsd = 0;\n        } else {\n            uint256 maxPriceImpactFactor = MarketUtils.getMaxPositionImpactFactorForLiquidations(\n                dataStore,\n                market.marketToken\n            );\n\n            // if there is a large build up of open interest and a sudden large price movement\n            // it may result in a large imbalance between longs and shorts\n            // this could result in very large price impact temporarily\n            // cap the max negative price impact to prevent cascading liquidations\n            int256 maxNegativePriceImpactUsd = -Precision.applyFactor(position.sizeInUsd(), maxPriceImpactFactor).toInt256();\n            if (cache.priceImpactUsd < maxNegativePriceImpactUsd) {\n                cache.priceImpactUsd = maxNegativePriceImpactUsd;\n            }\n        }\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            dataStore,\n            referralStorage,\n            position,\n            collateralTokenPrice,\n            market.longToken,\n            market.shortToken,\n            position.sizeInUsd()\n        );\n\n        cache.remainingCollateralUsd = cache.collateralUsd.toInt256() + cache.positionPnlUsd + cache.priceImpactUsd - fees.totalNetCostUsd.toInt256();\n\n        if (shouldValidateMinCollateralUsd) {\n            cache.minCollateralUsd = dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256();\n            if (cache.remainingCollateralUsd < cache.minCollateralUsd) {\n                return true;\n            }\n        }\n\n        if (cache.remainingCollateralUsd <= 0) {\n            return true;\n        }\n\n        // validate if (remaining collateral) / position.size is less than the min collateral factor (max leverage exceeded)\n        cache.minCollateralUsdForLeverage = Precision.applyFactor(position.sizeInUsd(), cache.minCollateralFactor).toInt256();\n        if (cache.remainingCollateralUsd < cache.minCollateralUsdForLeverage) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function willPositionCollateralBeSufficient(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        address collateralToken,\n        bool isLong,\n        WillPositionCollateralBeSufficientValues memory values\n    ) public view returns (bool, int256) {\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            collateralToken,\n            market,\n            prices\n        );\n\n        uint256 minCollateralFactor = MarketUtils.getMinCollateralFactorForOpenInterest(\n            dataStore,\n            market.marketToken,\n            market.longToken,\n            market.shortToken,\n            values.openInterestDelta,\n            isLong\n        );\n\n        int256 remainingCollateralUsd = values.positionCollateralAmount.toInt256() * collateralTokenPrice.min.toInt256();\n\n        remainingCollateralUsd += values.positionPnlUsd;\n\n        if (values.realizedPnlUsd < 0) {\n            remainingCollateralUsd = remainingCollateralUsd + values.realizedPnlUsd;\n        }\n\n        if (remainingCollateralUsd < 0) {\n            return (false, remainingCollateralUsd);\n        }\n\n        int256 minCollateralUsdForLeverage = Precision.applyFactor(values.positionSizeInUsd, minCollateralFactor).toInt256();\n        bool willBeSufficient = remainingCollateralUsd >= minCollateralUsdForLeverage;\n\n        return (willBeSufficient, remainingCollateralUsd);\n    }\n\n    function updateFundingAndBorrowingState(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices\n    ) internal {\n        // update the funding amount per size for the market\n        MarketUtils.updateFundingAmountPerSize(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market,\n            prices\n        );\n\n        // update the cumulative borrowing factor for the market\n        MarketUtils.updateCumulativeBorrowingFactor(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market,\n            prices,\n            params.order.isLong()\n        );\n    }\n\n    function updateTotalBorrowing(\n        PositionUtils.UpdatePositionParams memory params,\n        uint256 nextPositionSizeInUsd,\n        uint256 nextPositionBorrowingFactor\n    ) internal {\n        MarketUtils.updateTotalBorrowing(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            params.position.isLong(),\n            params.position.borrowingFactor(),\n            params.position.sizeInUsd(),\n            nextPositionSizeInUsd,\n            nextPositionBorrowingFactor\n        );\n    }\n\n    function incrementClaimableFundingAmount(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal {\n        // if the position has negative funding fees, distribute it to allow it to be claimable\n        if (fees.funding.claimableLongTokenAmount > 0) {\n            MarketUtils.incrementClaimableFundingAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.longToken,\n                params.order.receiver(),\n                fees.funding.claimableLongTokenAmount\n            );\n        }\n\n        if (fees.funding.claimableShortTokenAmount > 0) {\n            MarketUtils.incrementClaimableFundingAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.shortToken,\n                params.order.receiver(),\n                fees.funding.claimableShortTokenAmount\n            );\n        }\n    }\n\n    function updateOpenInterest(\n        PositionUtils.UpdatePositionParams memory params,\n        int256 sizeDeltaUsd,\n        int256 sizeDeltaInTokens\n    ) internal {\n        if (sizeDeltaUsd != 0) {\n            MarketUtils.applyDeltaToOpenInterest(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.market.indexToken,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                sizeDeltaUsd\n            );\n\n            MarketUtils.applyDeltaToOpenInterestInTokens(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.position.market(),\n                params.position.collateralToken(),\n                params.position.isLong(),\n                sizeDeltaInTokens\n            );\n        }\n    }\n\n    function handleReferral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal {\n        ReferralUtils.incrementAffiliateReward(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.position.market(),\n            params.position.collateralToken(),\n            fees.referral.affiliate,\n            params.position.account(),\n            fees.referral.affiliateRewardAmount\n        );\n\n        if (fees.referral.traderDiscountAmount > 0) {\n            ReferralEventUtils.emitTraderReferralDiscountApplied(\n                params.contracts.eventEmitter,\n                params.position.market(),\n                params.position.collateralToken(),\n                params.position.account(),\n                fees.referral.traderDiscountAmount\n            );\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/market/MarketUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../bank/StrictBank.sol\";\n\nimport \"./Market.sol\";\nimport \"./MarketToken.sol\";\nimport \"./MarketEventUtils.sol\";\nimport \"./MarketStoreUtils.sol\";\n\nimport \"../position/Position.sol\";\nimport \"../order/Order.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../utils/Calc.sol\";\nimport \"../utils/Precision.sol\";\n\n// @title MarketUtils\n// @dev Library for market functions\nlibrary MarketUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Market for Market.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev struct to store the prices of tokens of a market\n    // @param indexTokenPrice price of the market's index token\n    // @param longTokenPrice price of the market's long token\n    // @param shortTokenPrice price of the market's short token\n    struct MarketPrices {\n        Price.Props indexTokenPrice;\n        Price.Props longTokenPrice;\n        Price.Props shortTokenPrice;\n    }\n\n    // @dev struct for the result of the getNextFundingAmountPerSize call\n    // @param longsPayShorts whether longs pay shorts or shorts pay longs\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding amount per\n    // size for users with a long position using long collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding amount per\n    // size for users with a short position using long collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding amount per\n    // size for users with a long position using short collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding amount per\n    // size for users with a short position using short collateral\n    struct GetNextFundingAmountPerSizeResult {\n        bool longsPayShorts;\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n    }\n\n    // @dev struct to avoid stack too deep errors for the getPoolValue call\n    // @param value the pool value\n    // @param longTokenAmount the amount of long token in the pool\n    // @param shortTokenAmount the amount of short token in the pool\n    // @param longTokenUsd the USD value of the long tokens in the pool\n    // @param shortTokenUsd the USD value of the short tokens in the pool\n    // @param totalBorrowingFees the total pending borrowing fees for the market\n    // @param borrowingFeeReceiverFactor the fee receiver factor for borrowing fees\n    // @param impactPoolAmount the amount of tokens in the impact pool\n    // @param longPnl the pending pnl of long positions\n    // @param shortPnl the pending pnl of short positions\n    // @param netPnl the net pnl of long and short positions\n    struct GetPoolValueCache {\n        uint256 value;\n\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n\n        uint256 totalBorrowingFees;\n        uint256 borrowingFeeReceiverFactor;\n\n        uint256 impactPoolAmount;\n        int256 longPnl;\n        int256 shortPnl;\n        int256 netPnl;\n    }\n\n    // @dev GetNextFundingAmountPerSizeCache struct used in getNextFundingAmountPerSize\n    // to avoid stack too deep errors\n    //\n    // @param durationInSeconds duration in seconds since the last funding update\n    //\n    // @param diffUsd the absolute difference in long and short open interest for the market\n    // @param totalOpenInterest the total long and short open interest for the market\n    // @param fundingUsd the funding amount in USD\n    //\n    // @param fundingUsdForLongCollateral the funding amount in USD for positions using the long token as collateral\n    // @param fundingUsdForShortCollateral the funding amount in USD for positions using the short token as collateral\n    struct GetNextFundingAmountPerSizeCache {\n        GetNextFundingAmountPerSizeOpenInterestCache oi;\n        GetNextFundingAmountPerSizeFundingPerSizeCache fps;\n\n        uint256 durationInSeconds;\n\n        uint256 diffUsd;\n        uint256 totalOpenInterest;\n        uint256 sizeOfLargerSide;\n        uint256 fundingFactorPerSecond;\n        uint256 fundingUsd;\n\n        uint256 fundingUsdForLongCollateral;\n        uint256 fundingUsdForShortCollateral;\n    }\n\n    // @param longOpenInterestWithLongCollateral amount of long open interest using the long token as collateral\n    // @param longOpenInterestWithShortCollateral amount of long open interest using the short token as collateral\n    // @param shortOpenInterestWithLongCollateral amount of short open interest using the long token as collateral\n    // @param shortOpenInterestWithShortCollateral amount of short open interest using the short token as collateral\n    //\n    // @param longOpenInterest total long open interest for the market\n    // @param shortOpenInterest total short open interest for the market\n    struct GetNextFundingAmountPerSizeOpenInterestCache {\n        uint256 longOpenInterestWithLongCollateral;\n        uint256 longOpenInterestWithShortCollateral;\n        uint256 shortOpenInterestWithLongCollateral;\n        uint256 shortOpenInterestWithShortCollateral;\n\n        uint256 longOpenInterest;\n        uint256 shortOpenInterest;\n    }\n\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding per size for longs using the long token as collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding per size for shorts using the long token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding per size for longs using the short token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding per size for shorts using the short token as collateral\n    //\n    // @param fundingAmountPerSizePortion_LongCollateral_LongPosition the next funding amount per size for longs using the long token as collateral\n    // @param fundingAmountPerSizePortion_LongCollateral_ShortPosition the next funding amount per size for longs using the short token as collateral\n    // @param fundingAmountPerSizePortion_ShortCollateral_LongPosition the next funding amount per size for shorts using the long token as collateral\n    // @param fundingAmountPerSizePortion_ShortCollateral_ShortPosition the next funding amount per size for shorts using the short token as collateral\n    struct GetNextFundingAmountPerSizeFundingPerSizeCache {\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n\n        uint256 fundingAmountPerSizePortion_LongCollateral_LongPosition;\n        uint256 fundingAmountPerSizePortion_ShortCollateral_LongPosition;\n        uint256 fundingAmountPerSizePortion_LongCollateral_ShortPosition;\n        uint256 fundingAmountPerSizePortion_ShortCollateral_ShortPosition;\n    }\n\n    error EmptyMarket();\n    error DisabledMarket(address market);\n    error InsufficientPoolAmount(uint256 poolAmount, uint256 amount);\n    error InsufficientReserve(uint256 reservedUsd, uint256 maxReservedUsd);\n    error UnexpectedPoolValueForTokenPriceCalculation(int256 poolValue);\n    error UnexpectedSupplyForTokenPriceCalculation();\n    error UnableToGetOppositeToken(address inputToken, address market);\n    error UnableToGetCachedTokenPrice(address token, address market);\n    error CollateralAlreadyClaimed(uint256 adjustedClaimableAmount, uint256 claimedAmount);\n    error OpenInterestCannotBeUpdatedForSwapOnlyMarket(address market);\n    error MaxOpenInterestExceeded(uint256 openInterest, uint256 maxOpenInterest);\n    error MaxPoolAmountExceeded(uint256 poolAmount, uint256 maxPoolAmount);\n    error UnexpectedBorrowingFactor(uint256 positionBorrowingFactor, uint256 cumulativeBorrowingFactor);\n    error UnableToGetBorrowingFactorEmptyPoolUsd();\n    error UnableToGetFundingFactorEmptyOpenInterest();\n    error InvalidPositionMarket(address market);\n    error InvalidCollateralTokenForMarket(address market, address token);\n    error PnlFactorExceededForLongs(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n    error PnlFactorExceededForShorts(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n\n    // @dev get the market token's price\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longTokenPrice the price of the long token\n    // @param shortTokenPrice the price of the short token\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the market token price\n    // @return returns the market token's price\n    function getMarketTokenPrice(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        Price.Props memory indexTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 poolValue = getPoolValue(\n            dataStore,\n            market,\n            longTokenPrice,\n            shortTokenPrice,\n            indexTokenPrice,\n            pnlFactorType,\n            maximize\n        );\n\n        if (poolValue == 0) { return 0; }\n\n        if (poolValue < 0) {\n            revert UnexpectedPoolValueForTokenPriceCalculation(poolValue);\n        }\n\n        uint256 supply = getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n\n        if (supply == 0) {\n            revert UnexpectedSupplyForTokenPriceCalculation();\n        }\n\n        return poolValue * Precision.WEI_PRECISION.toInt256() / supply.toInt256();\n    }\n\n    // @dev get the total supply of the marketToken\n    // @param marketToken the marketToken\n    // @return the total supply of the marketToken\n    function getMarketTokenSupply(MarketToken marketToken) internal view returns (uint256) {\n        return marketToken.totalSupply();\n    }\n\n    // @dev get the opposite token of the market\n    // if the inputToken is the longToken return the shortToken and vice versa\n    // @param inputToken the input token\n    // @param market the market values\n    // @return the opposite token\n    function getOppositeToken(address inputToken, Market.Props memory market) internal pure returns (address) {\n        if (inputToken == market.longToken) {\n            return market.shortToken;\n        }"
    }
  ]
}