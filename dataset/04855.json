{
  "Title": "[G-23] Use `delete` to clear data, instead of assigning data to `0`",
  "Content": "\n**File:** `L1Messenger.sol`\n\n[File: code/system-contracts/contracts/L1Messenger.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/L1Messenger.sol#L328)\n```solidity\n328:         /// Clear logs state\n329:         chainedLogsHash = bytes32(0);\n330:         numberOfLogsToProcess = 0;\n331:         chainedMessagesHash = bytes32(0);\n332:         chainedL1BytecodesRevealDataHash = bytes32(0);\n```\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/L1Messenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IL1Messenger, L2ToL1Log, L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH, L2_TO_L1_LOG_SERIALIZE_SIZE, STATE_DIFF_COMPRESSION_VERSION_NUMBER} from \"./interfaces/IL1Messenger.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {EfficientCall} from \"./libraries/EfficientCall.sol\";\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {SystemLogKey, SYSTEM_CONTEXT_CONTRACT, KNOWN_CODE_STORAGE_CONTRACT, COMPRESSOR_CONTRACT, STATE_DIFF_ENTRY_SIZE, MAX_ALLOWED_PUBDATA_PER_BATCH, L2_TO_L1_LOGS_MERKLE_TREE_LEAVES, PUBDATA_CHUNK_PUBLISHER, COMPUTATIONAL_PRICE_FOR_PUBDATA} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Smart contract for sending arbitrary length messages to L1\n * @dev by default ZkSync can send fixed length messages on L1.\n * A fixed length message has 4 parameters `senderAddress` `isService`, `key`, `value`,\n * the first one is taken from the context, the other three are chosen by the sender.\n * @dev To send a variable length message we use this trick:\n * - This system contract accepts a arbitrary length message and sends a fixed length message with\n * parameters `senderAddress == this`, `marker == true`, `key == msg.sender`, `value == keccak256(message)`.\n * - The contract on L1 accepts all sent messages and if the message came from this system contract\n * it requires that the preimage of `value` be provided.\n */\ncontract L1Messenger is IL1Messenger, ISystemContract {\n    /// @notice Sequential hash of logs sent in the current block.\n    /// @dev Will be reset at the end of the block to zero value.\n    bytes32 internal chainedLogsHash;\n\n    /// @notice Number of logs sent in the current block.\n    /// @dev Will be reset at the end of the block to zero value.\n    uint256 internal numberOfLogsToProcess;\n\n    /// @notice Sequential hash of hashes of the messages sent in the current block.\n    /// @dev Will be reset at the end of the block to zero value.\n    bytes32 internal chainedMessagesHash;\n\n    /// @notice Sequential hash of bytecode hashes that needs to published\n    /// according to the current block execution invariant.\n    /// @dev Will be reset at the end of the block to zero value.\n    bytes32 internal chainedL1BytecodesRevealDataHash;\n\n    /// The gas cost of processing one keccak256 round.\n    uint256 internal constant KECCAK_ROUND_GAS_COST = 40;\n\n    /// The number of bytes processed in one keccak256 round.\n    uint256 internal constant KECCAK_ROUND_NUMBER_OF_BYTES = 136;\n\n    /// The gas cost of calculation of keccak256 of bytes array of such length.\n    function keccakGasCost(uint256 _length) internal pure returns (uint256) {\n        return KECCAK_ROUND_GAS_COST * (_length / KECCAK_ROUND_NUMBER_OF_BYTES + 1);\n    }\n\n    /// The gas cost of processing one sha256 round.\n    uint256 internal constant SHA256_ROUND_GAS_COST = 7;\n\n    /// The number of bytes processed in one sha256 round.\n    uint256 internal constant SHA256_ROUND_NUMBER_OF_BYTES = 64;\n\n    /// The gas cost of calculation of sha256 of bytes array of such length.\n    function sha256GasCost(uint256 _length) internal pure returns (uint256) {\n        return SHA256_ROUND_GAS_COST * ((_length + 8) / SHA256_ROUND_NUMBER_OF_BYTES + 1);\n    }\n\n    /// @notice Sends L2ToL1Log.\n    /// @param _isService The `isService` flag.\n    /// @param _key The `key` part of the L2Log.\n    /// @param _value The `value` part of the L2Log.\n    /// @dev Can be called only by a system contract.\n    function sendL2ToL1Log(\n        bool _isService,\n        bytes32 _key,\n        bytes32 _value\n    ) external onlyCallFromSystemContract returns (uint256 logIdInMerkleTree) {\n        L2ToL1Log memory l2ToL1Log = L2ToL1Log({\n            l2ShardId: 0,\n            isService: _isService,\n            txNumberInBlock: SYSTEM_CONTEXT_CONTRACT.txNumberInBlock(),\n            sender: msg.sender,\n            key: _key,\n            value: _value\n        });\n        logIdInMerkleTree = _processL2ToL1Log(l2ToL1Log);\n\n        // We need to charge cost of hashing, as it will be used in `publishPubdataAndClearState`:\n        // - keccakGasCost(L2_TO_L1_LOG_SERIALIZE_SIZE) and keccakGasCost(64) when reconstructing L2ToL1Log\n        // - at most 1 time keccakGasCost(64) when building the Merkle tree (as merkle tree can contain\n        // ~2*N nodes, where the first N nodes are leaves the hash of which is calculated on the previous step).\n        uint256 gasToPay = keccakGasCost(L2_TO_L1_LOG_SERIALIZE_SIZE) + 2 * keccakGasCost(64);\n        SystemContractHelper.burnGas(Utils.safeCastToU32(gasToPay), 0);\n    }\n\n    /// @notice Internal function to send L2ToL1Log.\n    function _processL2ToL1Log(L2ToL1Log memory _l2ToL1Log) internal returns (uint256 logIdInMerkleTree) {\n        bytes32 hashedLog = keccak256(\n            abi.encodePacked(\n                _l2ToL1Log.l2ShardId,\n                _l2ToL1Log.isService,\n                _l2ToL1Log.txNumberInBlock,\n                _l2ToL1Log.sender,\n                _l2ToL1Log.key,\n                _l2ToL1Log.value\n            )\n        );\n\n        chainedLogsHash = keccak256(abi.encode(chainedLogsHash, hashedLog));\n\n        logIdInMerkleTree = numberOfLogsToProcess;\n        numberOfLogsToProcess++;\n\n        emit L2ToL1LogSent(_l2ToL1Log);\n    }\n\n    /// @notice Public functionality to send messages to L1.\n    /// @param _message The message intended to be sent to L1.\n    function sendToL1(bytes calldata _message) external override returns (bytes32 hash) {\n        uint256 gasBeforeMessageHashing = gasleft();\n        hash = EfficientCall.keccak(_message);\n        uint256 gasSpentOnMessageHashing = gasBeforeMessageHashing - gasleft();\n\n        /// Store message record\n        chainedMessagesHash = keccak256(abi.encode(chainedMessagesHash, hash));\n\n        /// Store log record\n        L2ToL1Log memory l2ToL1Log = L2ToL1Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBlock: SYSTEM_CONTEXT_CONTRACT.txNumberInBlock(),\n            sender: address(this),\n            key: bytes32(uint256(uint160(msg.sender))),\n            value: hash\n        });\n        _processL2ToL1Log(l2ToL1Log);\n\n        // Get cost of one byte pubdata in gas from context.\n        uint256 pubdataLen;\n        unchecked {\n            // 4 bytes used to encode the length of the message (see `publishPubdataAndClearState`)\n            // L2_TO_L1_LOG_SERIALIZE_SIZE bytes used to encode L2ToL1Log\n            pubdataLen = 4 + _message.length + L2_TO_L1_LOG_SERIALIZE_SIZE;\n        }\n\n        // We need to charge cost of hashing, as it will be used in `publishPubdataAndClearState`:\n        // - keccakGasCost(L2_TO_L1_LOG_SERIALIZE_SIZE) and keccakGasCost(64) when reconstructing L2ToL1Log\n        // - keccakGasCost(64) and gasSpentOnMessageHashing when reconstructing Messages\n        // - at most 1 time keccakGasCost(64) when building the Merkle tree (as merkle tree can contain\n        // ~2*N nodes, where the first N nodes are leaves the hash of which is calculated on the previous step).\n        uint256 gasToPay = keccakGasCost(L2_TO_L1_LOG_SERIALIZE_SIZE) +\n            3 *\n            keccakGasCost(64) +\n            gasSpentOnMessageHashing +\n            COMPUTATIONAL_PRICE_FOR_PUBDATA *\n            pubdataLen;\n        SystemContractHelper.burnGas(Utils.safeCastToU32(gasToPay), uint32(pubdataLen));\n\n        emit L1MessageSent(msg.sender, hash, _message);\n    }\n\n    /// @dev Can be called only by KnownCodesStorage system contract.\n    /// @param _bytecodeHash Hash of bytecode being published to L1.\n    function requestBytecodeL1Publication(\n        bytes32 _bytecodeHash\n    ) external override onlyCallFrom(address(KNOWN_CODE_STORAGE_CONTRACT)) {\n        chainedL1BytecodesRevealDataHash = keccak256(abi.encode(chainedL1BytecodesRevealDataHash, _bytecodeHash));\n\n        uint256 bytecodeLen = Utils.bytecodeLenInBytes(_bytecodeHash);\n\n        uint256 pubdataLen;\n        unchecked {\n            // 4 bytes used to encode the length of the bytecode (see `publishPubdataAndClearState`)\n            pubdataLen = 4 + bytecodeLen;\n        }\n\n        // We need to charge cost of hashing, as it will be used in `publishPubdataAndClearState`\n        uint256 gasToPay = sha256GasCost(bytecodeLen) +\n            keccakGasCost(64) +\n            COMPUTATIONAL_PRICE_FOR_PUBDATA *\n            pubdataLen;\n        SystemContractHelper.burnGas(Utils.safeCastToU32(gasToPay), uint32(pubdataLen));\n\n        emit BytecodeL1PublicationRequested(_bytecodeHash);\n    }\n\n    /// @notice Verifies that the {_totalL2ToL1PubdataAndStateDiffs} reflects what occurred within the L1Batch and that\n    ///         the compressed statediffs are equivalent to the full state diffs.\n    /// @param _totalL2ToL1PubdataAndStateDiffs The total pubdata and uncompressed state diffs of transactions that were\n    ///        processed in the current L1 Batch. Pubdata consists of L2 to L1 Logs, messages, deployed bytecode, and state diffs.\n    /// @dev Function that should be called exactly once per L1 Batch by the bootloader.\n    /// @dev Checks that totalL2ToL1Pubdata is strictly packed data that should to be published to L1.\n    /// @dev The data passed in also contains the encoded state diffs to be checked again, however this is aux data that is not\n    ///      part of the committed pubdata.\n    /// @dev Performs calculation of L2ToL1Logs merkle tree root, \"sends\" such root and keccak256(totalL2ToL1Pubdata)\n    /// to L1 using low-level (VM) L2Log.\n    function publishPubdataAndClearState(\n        bytes calldata _totalL2ToL1PubdataAndStateDiffs\n    ) external onlyCallFromBootloader {\n        uint256 calldataPtr = 0;\n\n        /// Check logs\n        uint32 numberOfL2ToL1Logs = uint32(bytes4(_totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + 4]));\n        require(numberOfL2ToL1Logs <= L2_TO_L1_LOGS_MERKLE_TREE_LEAVES, \"Too many L2->L1 logs\");\n        calldataPtr += 4;\n\n        bytes32[] memory l2ToL1LogsTreeArray = new bytes32[](L2_TO_L1_LOGS_MERKLE_TREE_LEAVES);\n        bytes32 reconstructedChainedLogsHash;\n        for (uint256 i = 0; i < numberOfL2ToL1Logs; ++i) {\n            bytes32 hashedLog = EfficientCall.keccak(\n                _totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + L2_TO_L1_LOG_SERIALIZE_SIZE]\n            );\n            calldataPtr += L2_TO_L1_LOG_SERIALIZE_SIZE;\n            l2ToL1LogsTreeArray[i] = hashedLog;\n            reconstructedChainedLogsHash = keccak256(abi.encode(reconstructedChainedLogsHash, hashedLog));\n        }\n        require(\n            reconstructedChainedLogsHash == chainedLogsHash,\n            \"reconstructedChainedLogsHash is not equal to chainedLogsHash\"\n        );\n        for (uint256 i = numberOfL2ToL1Logs; i < L2_TO_L1_LOGS_MERKLE_TREE_LEAVES; ++i) {\n            l2ToL1LogsTreeArray[i] = L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH;\n        }\n        uint256 nodesOnCurrentLevel = L2_TO_L1_LOGS_MERKLE_TREE_LEAVES;\n        while (nodesOnCurrentLevel > 1) {\n            nodesOnCurrentLevel /= 2;\n            for (uint256 i = 0; i < nodesOnCurrentLevel; ++i) {\n                l2ToL1LogsTreeArray[i] = keccak256(\n                    abi.encode(l2ToL1LogsTreeArray[2 * i], l2ToL1LogsTreeArray[2 * i + 1])\n                );\n            }\n        }\n        bytes32 l2ToL1LogsTreeRoot = l2ToL1LogsTreeArray[0];\n\n        /// Check messages\n        uint32 numberOfMessages = uint32(bytes4(_totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + 4]));\n        calldataPtr += 4;\n        bytes32 reconstructedChainedMessagesHash;\n        for (uint256 i = 0; i < numberOfMessages; ++i) {\n            uint32 currentMessageLength = uint32(bytes4(_totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + 4]));\n            calldataPtr += 4;\n            bytes32 hashedMessage = EfficientCall.keccak(\n                _totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + currentMessageLength]\n            );\n            calldataPtr += currentMessageLength;\n            reconstructedChainedMessagesHash = keccak256(abi.encode(reconstructedChainedMessagesHash, hashedMessage));\n        }\n        require(\n            reconstructedChainedMessagesHash == chainedMessagesHash,\n            \"reconstructedChainedMessagesHash is not equal to chainedMessagesHash\"\n        );\n\n        /// Check bytecodes\n        uint32 numberOfBytecodes = uint32(bytes4(_totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + 4]));\n        calldataPtr += 4;\n        bytes32 reconstructedChainedL1BytecodesRevealDataHash;\n        for (uint256 i = 0; i < numberOfBytecodes; ++i) {\n            uint32 currentBytecodeLength = uint32(\n                bytes4(_totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + 4])\n            );\n            calldataPtr += 4;\n            reconstructedChainedL1BytecodesRevealDataHash = keccak256(\n                abi.encode(\n                    reconstructedChainedL1BytecodesRevealDataHash,\n                    Utils.hashL2Bytecode(\n                        _totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + currentBytecodeLength]\n                    )\n                )\n            );\n            calldataPtr += currentBytecodeLength;\n        }\n        require(\n            reconstructedChainedL1BytecodesRevealDataHash == chainedL1BytecodesRevealDataHash,\n            \"reconstructedChainedL1BytecodesRevealDataHash is not equal to chainedL1BytecodesRevealDataHash\"\n        );\n\n        /// Check State Diffs\n        /// encoding is as follows:\n        /// header (1 byte version, 3 bytes total len of compressed, 1 byte enumeration index size)\n        /// body (`compressedStateDiffSize` bytes, 4 bytes number of state diffs, `numberOfStateDiffs` * `STATE_DIFF_ENTRY_SIZE` bytes for the uncompressed state diffs)\n        /// encoded state diffs: [20bytes address][32bytes key][32bytes derived key][8bytes enum index][32bytes initial value][32bytes final value]\n        require(\n            uint256(uint8(bytes1(_totalL2ToL1PubdataAndStateDiffs[calldataPtr]))) ==\n                STATE_DIFF_COMPRESSION_VERSION_NUMBER,\n            \"state diff compression version mismatch\"\n        );\n        calldataPtr++;\n\n        uint24 compressedStateDiffSize = uint24(bytes3(_totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + 3]));\n        calldataPtr += 3;\n\n        uint8 enumerationIndexSize = uint8(bytes1(_totalL2ToL1PubdataAndStateDiffs[calldataPtr]));\n        calldataPtr++;\n\n        bytes calldata compressedStateDiffs = _totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr +\n            compressedStateDiffSize];\n        calldataPtr += compressedStateDiffSize;\n\n        bytes calldata totalL2ToL1Pubdata = _totalL2ToL1PubdataAndStateDiffs[:calldataPtr];\n\n        require(calldataPtr <= MAX_ALLOWED_PUBDATA_PER_BATCH, \"L1 Messenger pubdata is too long\");\n\n        uint32 numberOfStateDiffs = uint32(bytes4(_totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr + 4]));\n        calldataPtr += 4;\n\n        bytes calldata stateDiffs = _totalL2ToL1PubdataAndStateDiffs[calldataPtr:calldataPtr +\n            (numberOfStateDiffs * STATE_DIFF_ENTRY_SIZE)];\n        calldataPtr += numberOfStateDiffs * STATE_DIFF_ENTRY_SIZE;\n\n        bytes32 stateDiffHash = COMPRESSOR_CONTRACT.verifyCompressedStateDiffs(\n            numberOfStateDiffs,\n            enumerationIndexSize,\n            stateDiffs,\n            compressedStateDiffs\n        );\n\n        /// Check for calldata strict format\n        require(calldataPtr == _totalL2ToL1PubdataAndStateDiffs.length, \"Extra data in the totalL2ToL1Pubdata array\");\n\n        PUBDATA_CHUNK_PUBLISHER.chunkAndPublishPubdata(totalL2ToL1Pubdata);\n\n        /// Native (VM) L2 to L1 log\n        SystemContractHelper.toL1(true, bytes32(uint256(SystemLogKey.L2_TO_L1_LOGS_TREE_ROOT_KEY)), l2ToL1LogsTreeRoot);\n        SystemContractHelper.toL1(\n            true,\n            bytes32(uint256(SystemLogKey.TOTAL_L2_TO_L1_PUBDATA_KEY)),\n            EfficientCall.keccak(totalL2ToL1Pubdata)\n        );\n        SystemContractHelper.toL1(true, bytes32(uint256(SystemLogKey.STATE_DIFF_HASH_KEY)), stateDiffHash);\n\n        /// Clear logs state\n        chainedLogsHash = bytes32(0);\n        numberOfLogsToProcess = 0;\n        chainedMessagesHash = bytes32(0);\n        chainedL1BytecodesRevealDataHash = bytes32(0);\n    }\n}"
    }
  ]
}