{
  "Title": "M-3: Missing stake limit validation on `RenzoAdapter._stake`",
  "Content": "# Issue M-3: Missing stake limit validation on `RenzoAdapter._stake` \n\nSource: https://github.com/sherlock-audit/2024-05-napier-update-judging/issues/24 \n\n## Found by \nBauer, Ironsidesec, fandonov, zzykxx\n## Summary\n\nEvery `_stake` function in adapter contracts like `RsETHAdapter`, `PufETHAdapter`, and `RenzoAdapter` has the below @dev comment to implement  the stake limit validation.\n\n> /// @dev Need to check the current staking limit before staking to prevent DoS.\n\nBut only `RsETHAdapter`, `PufETHAdapter` validate the stake limits as shown below. But `RenzoAdapter` doesn't validate the stake limit and it reverts in an edge case.\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol#L69-L73\n\n```solidity\nFile: 2024-05-napier-update\\napier-uups-adapters\\src\\adapters\\puffer\\PufETHAdapter.sol\n\n65:  >>>   /// @dev Need to check the current staking limit before staking to prevent DoS.\n66:     function _stake(uint256 stakeAmount) internal override returns (uint256) {\n67:         if (stakeAmount == 0) return 0;\n68: \n69:         uint256 stakeLimit = STETH.getCurrentStakeLimit();\n70:   >>>   if (stakeAmount > stakeLimit) {\n71:             // Cap stake amount\n72:             stakeAmount = stakeLimit;\n73:         }\n```\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol#L71-L75\n\n```solidity\nFile: 2024-05-napier-update\\napier-uups-adapters\\src\\adapters\\kelp\\RsETHAdapter.sol\n\n66:  >>>   /// @dev Need to check the current staking limit before staking to prevent DoS.\n67:     function _stake(uint256 stakeAmount) internal override returns (uint256) {\n68:         if (stakeAmount == 0) return 0;\n69: \n70:         // Check LRTDepositPool stake limit\n71:         uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n72:  >>>    if (stakeAmount > stakeLimit) {\n73:             // Cap stake amount\n74:             stakeAmount = stakeLimit;\n75:         }\n\n```\n\n \n## Vulnerability Detail\n\n1. `RenzoAdapter._stake` calls `depositETH` on `RENZO_RESTAKE_MANAGER`\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/renzo/RenzoAdapter.sol#L59\n\n```solidity\nFile: 2024-05-napier-update\\napier-uups-adapters\\src\\adapters\\renzo\\RenzoAdapter.sol\n\n60:  >>>    /// @dev Need to check the current staking limit before staking to prevent DoS. \n61:     function _stake(uint256 stakeAmount) internal override returns (uint256) {\n62:         if (stakeAmount == 0) return 0;\n63:         if (RENZO_RESTAKE_MANAGER.paused()) revert ProtocolPaused();\n64:         uint256 balanceBefore = EZETH.balanceOf(address(this));\n65:         IWETH9(Constants.WETH).withdraw(stakeAmount);\n66:         RENZO_RESTAKE_MANAGER.depositETH{value: stakeAmount}(0); // @audit-medium no referral id\n67:         uint256 newBalance = EZETH.balanceOf(address(this));\n68:         if (newBalance - balanceBefore == 0) revert InvariantViolation();\n69: \n70:         return stakeAmount;\n\n70:     }\n\n```\n2. And look at `depositETH` line highlighted with `>>>` below, it checks the `MaxTVLReached`, and it will revert if max TVL is reached. Maybe someone manipulated to cause DOS or unmanipulatedly hit the threshold triggering the revert. And the comment on `_stake` says to check the current limit to prevent DOS. But `RenzoAdapter._stake` is missing that.\n\nhttps://etherscan.io/address/0xbaacd5f849024dcc80520baa952f11adfc59f9d0#code#F1#L558\nLine 558 on https://etherscan.deth.net/address/0xbaacd5f849024dcc80520baa952f11adfc59f9d0\n\n```solidity\n    function depositETH(uint256 _referralId) public payable nonReentrant notPaused {\n        // Get the total TVL\n        (, , uint256 totalTVL) = calculateTVLs();\n\n        // Enforce TVL limit if set\n >>>    if (maxDepositTVL != 0 && totalTVL + msg.value > maxDepositTVL) {\n            revert MaxTVLReached();\n        }\n\n...\n    }\n```\n\n## Impact\n\nDOS or Missing validation the dev intended to make but didn't implement.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/renzo/RenzoAdapter.sol#L59\n\nhttps://etherscan.io/address/0xbaacd5f849024dcc80520baa952f11adfc59f9d0#code#F1#L558\n\nLine 558 on https://etherscan.deth.net/address/0xbaacd5f849024dcc80520baa952f11adfc59f9d0\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nhttps://github.com/sherlock-audit/2024-05-napier-update/blob/c31af59c6399182fd04b40530d79d98632d2bfa7/napier-uups-adapters/src/adapters/renzo/RenzoAdapter.sol#L59\n\n```diff\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n        if (RENZO_RESTAKE_MANAGER.paused()) revert ProtocolPaused();\n\n+       uint maxDepositTVL = RENZO_RESTAKE_MANAGER.maxDepositTVL();\n+       uint totalTVL =  RENZO_RESTAKE_MANAGER.totalTVL();\n+       if (maxDepositTVL != 0 && totalTVL + stakeAmount > maxDepositTVL) {\n+           stakeAmount = maxDepositTVL - totalTVL;\n+       }\n\n        uint256 balanceBefore = EZETH.balanceOf(address(this));\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        RENZO_RESTAKE_MANAGER.depositETH{value: stakeAmount}(0); // @audit-medium no referral id\n        uint256 newBalance = EZETH.balanceOf(address(this));\n        if (newBalance - balanceBefore == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/napierfi/napier-uups-adapters/pull/11\n\n\n**zzykxx**\n\nAn edge case in the proposed fix was found: `_stake()` reverts if `totalTVL` is greater than `maxDepositTVL`. It has been fixed in new PR: https://github.com/napierfi/napier-uups-adapters/pull/22\n\n**sherlock-admin2**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/369",
  "Code": [
    {
      "filename": "napier-uups-adapters/src/adapters/puffer/PufETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {IPufferVault} from \"./interfaces/IPufferVault.sol\";\nimport {IPufferDepositor, Permit} from \"./interfaces/IPufferDepositor.sol\";\nimport {IStETH} from \"@napier/v1-tranche/adapters/lido/interfaces/IStETH.sol\";\n\n// libs\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice PufETHAdapter - ePufETH (Napier pufETH Adapter)\n/// @notice Puffer is a decentralized native liquid restaking protocol (nLRP) built on Eigenlayer\n/// It makes native restaking on Eigenlayer more accessible, allowing anyone to run an Ethereum Proof of Stake\n/// (PoS) validator while supercharging their rewards.\ncontract PufETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice stETH\n    IStETH constant STETH = IStETH(Constants.STETH);\n\n    /// @notice pufETH\n    IPufferVault constant PUFETH = IPufferVault(Constants.PUFETH);\n\n    /// @notice Puffer Depositor\n    IPufferDepositor constant PUFFER_DEPOSITOR = IPufferDepositor(Constants.PUF_DEPOSITOR);\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier pufETH Adapter\", \"ePufETH\");\n\n        PUFETH.approve(address(PUFFER_DEPOSITOR), type(uint256).max);\n        STETH.approve(address(PUFFER_DEPOSITOR), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Puffer\n    /// @dev Puffer doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Puffer allows stETH or wstETH via PufferDepositor.\n    /// @dev Lido has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        uint256 stakeLimit = STETH.getCurrentStakeLimit();\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _stETHAmt = STETH.balanceOf(address(this));\n        STETH.submit{value: stakeAmount}(address(this));\n        _stETHAmt = STETH.balanceOf(address(this)) - _stETHAmt;\n        if (_stETHAmt == 0) revert InvariantViolation();\n\n        // Stake stETH to PufferDepositor\n        uint256 _pufETHAmt = PUFFER_DEPOSITOR.depositStETH(Permit(block.timestamp, _stETHAmt, 0, 0, 0));\n\n        if (_pufETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        uint256 share = PUFETH.balanceOf(address(this));\n        return $.totalQueueEth + $.bufferEth + PUFETH.convertToAssets(share);\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/kelp/RsETHAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {ILRTOracle} from \"./interfaces/ILRTOracle.sol\";\nimport {ILRTDepositPool} from \"./interfaces/ILRTDepositPool.sol\";\n\n// libs\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable@4.9.3/token/ERC20/IERC20Upgradeable.sol\";\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RsETHAdapter - eRsETH (Napier rsETH Adapter)\n/// @notice rsETH is a Liquid Restaked Token (LRT) issued by Kelp DAO designed\n/// to offer liquidity to illiquid assets deposited into restaking platforms,\n///  such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking\ncontract RsETHAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice LRTDepositPool\n    ILRTDepositPool constant RSETH_DEPOSIT_POOL = ILRTDepositPool(Constants.RSETH_DEPOSIT_POOL);\n\n    /// @notice LRTOracle\n    ILRTOracle constant RSETH_ORACLE = ILRTOracle(Constants.RSETH_ORACLE);\n\n    /// @notice rsETH\n    IERC20Upgradeable constant RSETH = IERC20Upgradeable(Constants.RSETH);\n\n    /// @notice RSETH referral id\n    string constant REFERRAL_ID = \"Napier-RsETHAdapter\";\n\n    error OnlyWETHOrRETH();\n    error InvariantViolation();\n    error MinAmountToDepositError();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier rsETH Adapter\", \"eRsETH\");\n    }\n\n    /// @notice Claim withdrawal from Kelp\n    /// @dev Kelp doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Kelp allows ETH, ETHx, stETH or sfrxETH via LRTDepositPool.\n    /// @dev Kelp has a limit on the amount of ETH that can be staked.\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n\n        // Check LRTDepositPool stake limit\n        uint256 stakeLimit = RSETH_DEPOSIT_POOL.getAssetCurrentLimit(Constants.ETH);\n        if (stakeAmount > stakeLimit) {\n            // Cap stake amount\n            stakeAmount = stakeLimit;\n        }\n        // Check LRTDepositPool minAmountToDeposit\n        if (stakeAmount <= RSETH_DEPOSIT_POOL.minAmountToDeposit()) revert MinAmountToDepositError();\n        // Check paused of LRTDepositPool\n        if (RSETH_DEPOSIT_POOL.paused()) revert ProtocolPaused();\n\n        // Interact\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        uint256 _rsETHAmt = RSETH.balanceOf(address(this));\n        RSETH_DEPOSIT_POOL.depositETH{value: stakeAmount}(0, REFERRAL_ID);\n        _rsETHAmt = RSETH.balanceOf(address(this)) - _rsETHAmt;\n\n        if (_rsETHAmt == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Puffer doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n        return $.totalQueueEth + $.bufferEth + (RSETH.balanceOf(address(this)) * RSETH_ORACLE.rsETHPrice()) / 1e18;\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/renzo/RenzoAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {IRenzoRestakeManager} from \"./interfaces/IRenzoRestakeManager.sol\";\nimport {IRateProvider} from \"./interfaces/IRateProvider.sol\";\n\n// libs\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RenzoAdapter - eEzETH (Napier renzoETH Adapter)\ncontract RenzoAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice\n    IERC20 constant EZETH = IERC20(Constants.EZETH);\n\n    /// @notice\n    IRenzoRestakeManager constant RENZO_RESTAKE_MANAGER = IRenzoRestakeManager(Constants.RENZO_RESTAKE_MANAGER);\n\n    /// @notice\n    IRateProvider constant RATE_PROVIDER = IRateProvider(Constants.RENZO_RATE_PROVIDER);\n\n    error InvariantViolation();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier ezETH Adapter\", \"eEzETH\");\n\n        EZETH.approve(address(RENZO_RESTAKE_MANAGER), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Renzo\n    /// @dev Renzo doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Mint .\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n        if (RENZO_RESTAKE_MANAGER.paused()) revert ProtocolPaused();\n        uint256 balanceBefore = EZETH.balanceOf(address(this));\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        RENZO_RESTAKE_MANAGER.depositETH{value: stakeAmount}(0);\n        uint256 newBalance = EZETH.balanceOf(address(this));\n        if (newBalance - balanceBefore == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        return $.totalQueueEth + $.bufferEth + (EZETH.balanceOf(address(this)) * RATE_PROVIDER.getRate()) / 1e18;\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/renzo/RenzoAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {IRenzoRestakeManager} from \"./interfaces/IRenzoRestakeManager.sol\";\nimport {IRateProvider} from \"./interfaces/IRateProvider.sol\";\n\n// libs\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RenzoAdapter - eEzETH (Napier renzoETH Adapter)\ncontract RenzoAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice\n    IERC20 constant EZETH = IERC20(Constants.EZETH);\n\n    /// @notice\n    IRenzoRestakeManager constant RENZO_RESTAKE_MANAGER = IRenzoRestakeManager(Constants.RENZO_RESTAKE_MANAGER);\n\n    /// @notice\n    IRateProvider constant RATE_PROVIDER = IRateProvider(Constants.RENZO_RATE_PROVIDER);\n\n    error InvariantViolation();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier ezETH Adapter\", \"eEzETH\");\n\n        EZETH.approve(address(RENZO_RESTAKE_MANAGER), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Renzo\n    /// @dev Renzo doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Mint .\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n        if (RENZO_RESTAKE_MANAGER.paused()) revert ProtocolPaused();\n        uint256 balanceBefore = EZETH.balanceOf(address(this));\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        RENZO_RESTAKE_MANAGER.depositETH{value: stakeAmount}(0);\n        uint256 newBalance = EZETH.balanceOf(address(this));\n        if (newBalance - balanceBefore == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        return $.totalQueueEth + $.bufferEth + (EZETH.balanceOf(address(this)) * RATE_PROVIDER.getRate()) / 1e18;\n    }\n}"
    },
    {
      "filename": "napier-uups-adapters/src/adapters/renzo/RenzoAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\n// interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"@napier/v1-tranche/interfaces/IWETH9.sol\";\nimport {IRenzoRestakeManager} from \"./interfaces/IRenzoRestakeManager.sol\";\nimport {IRateProvider} from \"./interfaces/IRateProvider.sol\";\n\n// libs\nimport {LSTAdapterStorage} from \"../../Structs.sol\";\nimport \"../../Constants.sol\" as Constants;\n\nimport {BaseLSTAdapterUpgradeable} from \"../BaseLSTAdapterUpgradeable.sol\";\n\n/// @notice RenzoAdapter - eEzETH (Napier renzoETH Adapter)\ncontract RenzoAdapter is BaseLSTAdapterUpgradeable {\n    /// @notice\n    IERC20 constant EZETH = IERC20(Constants.EZETH);\n\n    /// @notice\n    IRenzoRestakeManager constant RENZO_RESTAKE_MANAGER = IRenzoRestakeManager(Constants.RENZO_RESTAKE_MANAGER);\n\n    /// @notice\n    IRateProvider constant RATE_PROVIDER = IRateProvider(Constants.RENZO_RATE_PROVIDER);\n\n    error InvariantViolation();\n    error ProtocolPaused();\n\n    receive() external payable {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _owner,\n        address _rebalancer,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) public initializer {\n        __BaseLSTAdapter_init(_owner, _rebalancer, _maxStakeLimit, _stakeLimitIncreasePerBlock);\n        __ERC20_init(\"Napier ezETH Adapter\", \"eEzETH\");\n\n        EZETH.approve(address(RENZO_RESTAKE_MANAGER), type(uint256).max);\n    }\n\n    /// @notice Claim withdrawal from Renzo\n    /// @dev Renzo doesn't have claim functionality yet.\n    function claimWithdrawal(uint256) external pure override {\n        revert NotImplemented();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Rebalancer functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @notice Mint .\n    /// @dev Need to check the current staking limit before staking to prevent DoS.\n    function _stake(uint256 stakeAmount) internal override returns (uint256) {\n        if (stakeAmount == 0) return 0;\n        if (RENZO_RESTAKE_MANAGER.paused()) revert ProtocolPaused();\n        uint256 balanceBefore = EZETH.balanceOf(address(this));\n        IWETH9(Constants.WETH).withdraw(stakeAmount);\n        RENZO_RESTAKE_MANAGER.depositETH{value: stakeAmount}(0);\n        uint256 newBalance = EZETH.balanceOf(address(this));\n        if (newBalance - balanceBefore == 0) revert InvariantViolation();\n\n        return stakeAmount;\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function requestWithdrawal() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function requestWithdrawalAll() external pure override {\n        revert NotImplemented();\n    }\n\n    /// @dev Renzo doesn't have withdraw function yet.\n    function _requestWithdrawal(uint256) internal pure override returns (uint256, uint256) {\n        revert NotImplemented();\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        LSTAdapterStorage storage $ = _getStorage();\n\n        return $.totalQueueEth + $.bufferEth + (EZETH.balanceOf(address(this)) * RATE_PROVIDER.getRate()) / 1e18;\n    }\n}"
    }
  ]
}