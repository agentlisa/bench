{
  "Title": "[M-03] Undesired behavior",
  "Content": "_Submitted by robee, also found by 0x1f8b, csanuragjain, and Dravee_\n\n[NestedRecords.sol#L117-L131](https://github.com/code-423n4/2022-02-nested/blob/69cf51d8e4eeb8bce3025db7f4f74cc565c9fad3/contracts/NestedRecords.sol#:~:text=uint256%20amount%20%3D%20records,_nftId%5D.reserve%20%3D%20_reserve%3B)<br>\n\nYou push a parameter into an array of tokens without checking if it already exists. And, if at first it's added with amount 0, it can later on be pushed with a greater amount and be twice in the array. Then in all processing it will consider the first occurrence and therefore the occurrence with amount 0.\n\n         NestedRecords.store pushed the parameter _token\n\n**[maximebrugel (Nested Finance) disagreed with High severity and commented](https://github.com/code-423n4/2022-02-nested-findings/issues/6#issuecomment-1034735686):**\n > Indeed, `_amount` is not checked and may result in the loss of funds for the user... If we only look at the `store` function.\n> \n> **However**, this situation can't happen because of the `NestedFactory' (the only one able to call).\n> \n> The Factory is calling with this private function : \n> ```javascript\n> /// @dev Transfer tokens to the reserve, and compute the amount received to store\n> /// in the records. We need to know the amount received in case of deflationary tokens.\n> /// @param _token The token to transfer (IERC20)\n> /// @param _amount The amount to send to the reserve\n> /// @param _nftId The Token ID to store the assets\n> function _transferToReserveAndStore(\n>     IERC20 _token,\n>     uint256 _amount,\n>     uint256 _nftId\n> ) private {\n>     address reserveAddr = address(reserve);\n>     uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n>     // Send output to reserve\n>     _token.safeTransfer(reserveAddr, _amount);\n>     uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n>     nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n> }\n> ```\n> \n> Here, the `store` amount parameter can be `0` if : \n> - `_amount` is equal to 0. Then `balanceReserveAfter - balanceReserveBefore` = `0`.\n> - `_amount` is not equal to 0 but the `safeTransfer` function is transferring `0` tokens (100% fees, malicious contract,...).\n> \n> We can't consider the second option, It is an external cause and we are not able to manage the exotic behaviors of ERC20s.\n> So, when the `_amount` parameter of this function can be equal to `0` ?\n> \n> => In `submitOutOrders` : \n> ```javascript\n> amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n> \n> (...)\n> \n> amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n> feesAmount = amountBought / 100; // 1% Fee\n> if (_toReserve) {\n>     _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n> }\n> ```\n> **But the `ZeroExOperator` or `FlatOperator` will revert if the amount bought is `0`.**\n> \n> => In `_submitOrder`\n> \n> ```javascript\n> (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n> require(success, \"NF: OPERATOR_CALL_FAILED\");\n> if (_toReserve) {\n>     _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n> }\n> ```\n> **Same,  the `ZeroExOperator` or `FlatOperator` will revert if the amount bought is `0`.**\n> \n> In conclusion, we should check this parameter, but in the actual code state it can't happen (without taking into account the exotic ERC20s that we do not manage). If we add an operator that does not check the amount bought it can happen, so, maybe reducing the severity ?\n> \n> PR: [Med/High Risk Fixes](https://github.com/NestedFi/nested-core-lego/pull/100)\n\n**[harleythedog (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-nested-findings/issues/6#issuecomment-1053229547):**\n > Agree with sponsor, this issue doesn't exist with the current operators, so it is not currently a threat. I am going to downgrade this to medium.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/NestedRecords.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"./abstracts/OwnableFactoryHandler.sol\";\n\n/// @title Tracks data for underlying assets of NestedNFTs\ncontract NestedRecords is OwnableFactoryHandler {\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when maxHoldingsCount is updated\n    /// @param maxHoldingsCount The new value\n    event MaxHoldingsChanges(uint256 maxHoldingsCount);\n\n    /// @dev Emitted when the lock timestamp of an NFT is increased\n    /// @param nftId The NFT ID\n    /// @param timestamp The new lock timestamp of the portfolio\n    event LockTimestampIncreased(uint256 nftId, uint256 timestamp);\n\n    /// @dev Emitted when the reserve is updated for a specific portfolio\n    /// @param nftId The NFT ID\n    /// @param newReserve The new reserve address\n    event reserveUpdated(uint256 nftId, address newReserve);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Store user asset informations\n    struct NftRecord {\n        mapping(address => uint256) holdings;\n        address[] tokens;\n        address reserve;\n        uint256 lockTimestamp;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    /// @dev stores for each NFT ID an asset record\n    mapping(uint256 => NftRecord) public records;\n\n    /// @dev The maximum number of holdings for an NFT record\n    uint256 public maxHoldingsCount;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(uint256 _maxHoldingsCount) {\n        maxHoldingsCount = _maxHoldingsCount;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the maximum number of holdings for an NFT record\n    /// @param _maxHoldingsCount The new maximum number of holdings\n    function setMaxHoldingsCount(uint256 _maxHoldingsCount) external onlyOwner {\n        require(_maxHoldingsCount != 0, \"NRC: INVALID_MAX_HOLDINGS\");\n        maxHoldingsCount = _maxHoldingsCount;\n        emit MaxHoldingsChanges(maxHoldingsCount);\n    }\n\n    /* ------------------------- FACTORY FUNCTIONS ------------------------- */\n\n    /// @notice Update the amount for a specific holding and delete\n    /// the holding if the amount is zero.\n    /// @param _nftId The id of the NFT\n    /// @param _token The token/holding address\n    /// @param _amount Updated amount for this asset\n    function updateHoldingAmount(\n        uint256 _nftId,\n        address _token,\n        uint256 _amount\n    ) public onlyFactory {\n        if (_amount == 0) {\n            uint256 tokenIndex = 0;\n            address[] memory tokens = getAssetTokens(_nftId);\n            while (tokenIndex < tokens.length) {\n                if (tokens[tokenIndex] == _token) {\n                    deleteAsset(_nftId, tokenIndex);\n                    break;\n                }\n                tokenIndex++;\n            }\n        } else {\n            records[_nftId].holdings[_token] = _amount;\n        }\n    }\n\n    /// @notice Fully delete a holding record for an NFT\n    /// @param _nftId The id of the NFT\n    /// @param _tokenIndex The token index in holdings array\n    function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {\n        address[] storage tokens = records[_nftId].tokens;\n        address token = tokens[_tokenIndex];\n\n        require(records[_nftId].holdings[token] != 0, \"NRC: HOLDING_INACTIVE\");\n\n        delete records[_nftId].holdings[token];\n        tokens[_tokenIndex] = tokens[tokens.length - 1];\n        tokens.pop();\n    }\n\n    /// @notice Delete a holding item in holding mapping. Does not remove token in NftRecord.tokens array\n    /// @param _nftId NFT's identifier\n    /// @param _token Token address for holding to remove\n    function freeHolding(uint256 _nftId, address _token) public onlyFactory {\n        delete records[_nftId].holdings[_token];\n    }\n\n    /// @notice Helper function that creates a record or add the holding if record already exists\n    /// @param _nftId The NFT's identifier\n    /// @param _token The token/holding address\n    /// @param _amount Amount to add for this asset\n    /// @param _reserve Reserve address\n    function store(\n        uint256 _nftId,\n        address _token,\n        uint256 _amount,\n        address _reserve\n    ) external onlyFactory {\n        uint256 amount = records[_nftId].holdings[_token];\n        if (amount != 0) {\n            require(records[_nftId].reserve == _reserve, \"NRC: RESERVE_MISMATCH\");\n            updateHoldingAmount(_nftId, _token, amount + _amount);\n            return;\n        }\n        require(records[_nftId].tokens.length < maxHoldingsCount, \"NRC: TOO_MANY_TOKENS\");\n        require(\n            _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),\n            \"NRC: INVALID_RESERVE\"\n        );\n\n        records[_nftId].holdings[_token] = _amount;\n        records[_nftId].tokens.push(_token);\n        records[_nftId].reserve = _reserve;\n    }\n\n    /// @notice The factory can update the lock timestamp of a NFT record\n    /// The new timestamp must be greater than the records lockTimestamp\n    //  if block.timestamp > actual lock timestamp\n    /// @param _nftId The NFT id to get the record\n    /// @param _timestamp The new timestamp\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external onlyFactory {\n        require(_timestamp > records[_nftId].lockTimestamp, \"NRC: LOCK_PERIOD_CANT_DECREASE\");\n        records[_nftId].lockTimestamp = _timestamp;\n        emit LockTimestampIncreased(_nftId, _timestamp);\n    }\n\n    /// @notice Delete from mapping assetTokens\n    /// @param _nftId The id of the NFT\n    function removeNFT(uint256 _nftId) external onlyFactory {\n        delete records[_nftId];\n    }\n\n    /// @notice Set the reserve where assets are stored\n    /// @param _nftId The NFT ID to update\n    /// @param _nextReserve Address for the new reserve\n    function setReserve(uint256 _nftId, address _nextReserve) external onlyFactory {\n        records[_nftId].reserve = _nextReserve;\n        emit reserveUpdated(_nftId, _nextReserve);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get content of assetTokens mapping\n    /// @param _nftId The id of the NFT>\n    function getAssetTokens(uint256 _nftId) public view returns (address[] memory) {\n        return records[_nftId].tokens;\n    }\n\n    /// @notice Get reserve the assets are stored in\n    /// @param _nftId The NFT ID\n    /// @return The reserve address these assets are stored in\n    function getAssetReserve(uint256 _nftId) external view returns (address) {\n        return records[_nftId].reserve;\n    }\n\n    /// @notice Get how many tokens are in a portfolio/NFT\n    /// @param _nftId NFT ID to examine\n    /// @return The array length\n    function getAssetTokensLength(uint256 _nftId) public view returns (uint256) {\n        return records[_nftId].tokens.length;\n    }\n\n    /// @notice Get holding object for this NFT ID\n    /// @param _nftId The id of the NFT\n    /// @param _token The address of the token\n    function getAssetHolding(uint256 _nftId, address _token) public view returns (uint256) {\n        return records[_nftId].holdings[_token];\n    }\n\n    /// @notice Returns the holdings associated to a NestedAsset\n    /// @param _nftId the id of the NestedAsset\n    /// @return The holdings\n    function tokenHoldings(uint256 _nftId) public view returns (address[] memory, uint256[] memory) {\n        address[] memory tokens = getAssetTokens(_nftId);\n        uint256 tokensCount = tokens.length;\n        uint256[] memory amounts = new uint256[](tokensCount);\n\n        for (uint256 i = 0; i < tokensCount; i++) {\n            amounts[i] = getAssetHolding(_nftId, tokens[i]);\n        }\n        return (tokens, amounts);\n    }\n\n    /// @notice Get the lock timestamp of a portfolio/NFT\n    /// @param _nftId The NFT ID\n    /// @return The lock timestamp from the NftRecord\n    function getLockTimestamp(uint256 _nftId) external view returns (uint256) {\n        return records[_nftId].lockTimestamp;\n    }\n}"
    }
  ]
}