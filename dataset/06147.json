{
  "Title": "[N-05] Un-migratable handles might exist in Lens Protocol V1",
  "Content": "\nIn `LensHandles.sol`, the `_validateLocalNameMigration()` function is used to validate migrated handles:\n\n[LensHandles.sol#L210-L223](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/namespaces/LensHandles.sol#L210-L223)\n\n```solidity\n        bytes1 firstByte = localNameAsBytes[0];\n        if (firstByte == '-' || firstByte == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '-' && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n```\n\nAs seen from above, handles can only be migrated if:\n* Its first byte is alphanumeric.\n* Only contains alphanumeric characters, '\\-' or \"\\_\".\n\nAdditionally, the `_migrateProfile()` function in `MigrationLib.sol` removes the last 5 bytes of each handle:\n\n[MigrationLib.sol#L77-L80](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MigrationLib.sol#L77-L80)\n\n```solidity\n                assembly {\n                    let handle_length := mload(handle)\n                    mstore(handle, sub(handle_length, DOT_LENS_SUFFIX_LENGTH)) // Cut 5 chars (.lens) from the end\n                }\n```\n\nThis means that any V1 handle that does not contan \".lens\" and is shorter than 5 bytes cannot be migrated.\n\nHowever, the rules mentioned above are not strictly enforced in Lens Protocol V1:\n\n[PublishingLogic.sol#L391](https://polygonscan.com/address/0xBA97fc9137b7cbBBC7fcB70a87DA645d917C902F#code#F8#L391)\n\n```solidity\n    function _validateHandle(string calldata handle) private pure {\n        bytes memory byteHandle = bytes(handle);\n        if (byteHandle.length == 0 || byteHandle.length > Constants.MAX_HANDLE_LENGTH)\n            revert Errors.HandleLengthInvalid();\n\n        uint256 byteHandleLength = byteHandle.length;\n        for (uint256 i = 0; i < byteHandleLength; ) {\n            if (\n                (byteHandle[i] < '0' ||\n                    byteHandle[i] > 'z' ||\n                    (byteHandle[i] > '9' && byteHandle[i] < 'a')) &&\n                byteHandle[i] != '.' &&\n                byteHandle[i] != '-' &&\n                byteHandle[i] != '_'\n            ) revert Errors.HandleContainsInvalidCharacters();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n\nAs seen from above, V1 handles can also contain \".\", and its first byte is not only restricted to alphanumeric characters. Additionally, handles do not have to end with the \".lens\" suffix. This means that it might be possible to create a handle that cannot be migrated after the V2 upgrade.\n\n### Recommendation\n\nEnsure all profile handles obey the following rules before the V2 upgrade:\n\n* First byte is alphanumeric.\n* Only contains alphanumeric characters, '\\-' or \"\\_\".\n* Ends with the \".lens\" suffix.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/namespaces/LensHandles.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\nimport {HandlesEvents} from 'contracts/namespaces/constants/Events.sol';\nimport {HandlesErrors} from 'contracts/namespaces/constants/Errors.sol';\nimport {HandleTokenURILib} from 'contracts/libraries/token-uris/HandleTokenURILib.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\n * namespace applied as a suffix, using the dot symbol as separator.\n *\n *      handle = ${localName}.${namespace}\n *\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\n *\n *      handle === ${localName} ; inside some namespace.\n */\ncontract LensHandles is ERC721, ImmutableOwnable, ILensHandles {\n    using Address for address;\n\n    uint256 internal constant MAX_HANDLE_LENGTH = 31;\n    string internal constant NAMESPACE = 'lens';\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\n    uint256 internal constant SEPARATOR_LENGTH = 1; // bytes('.').length;\n    bytes32 internal constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\n    uint256 internal immutable TOKEN_GUARDIAN_COOLDOWN;\n\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\n\n    mapping(uint256 tokenId => string localName) internal _localNames;\n\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\n        if (\n            msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)\n        ) {\n            revert HandlesErrors.NotOwnerNorWhitelisted();\n        }\n        _;\n    }\n\n    modifier onlyEOA() {\n        if (msg.sender.isContract()) {\n            revert HandlesErrors.NotEOA();\n        }\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != LENS_HUB) {\n            revert HandlesErrors.NotHub();\n        }\n        _;\n    }\n\n    constructor(\n        address owner,\n        address lensHub,\n        uint256 tokenGuardianCooldown\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\n    }\n\n    function name() public pure override returns (string memory) {\n        return string.concat(symbol(), ' Handles');\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return string.concat('.', NAMESPACE);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return HandleTokenURILib.getTokenURI(tokenId, _localNames[tokenId]);\n    }\n\n    /// @inheritdoc ILensHandles\n    function mintHandle(address to, string calldata localName)\n        external\n        onlyOwnerOrWhitelistedProfileCreator\n        returns (uint256)\n    {\n        _validateLocalName(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\n        _validateLocalNameMigration(localName);\n        return _mintHandle(to, localName);\n    }\n\n    function burn(uint256 tokenId) external {\n        if (msg.sender != ownerOf(tokenId)) {\n            revert HandlesErrors.NotOwner();\n        }\n        _burn(tokenId);\n        delete _localNames[tokenId];\n    }\n\n    /// ************************************\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\n    /// ************************************\n\n    function DANGER__disableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != 0) {\n            revert HandlesErrors.DisablingAlreadyTriggered();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: false,\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\n            timestamp: block.timestamp\n        });\n    }\n\n    function enableTokenGuardian() external onlyEOA {\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == 0) {\n            revert HandlesErrors.AlreadyEnabled();\n        }\n        _tokenGuardianDisablingTimestamp[msg.sender] = 0;\n        emit HandlesEvents.TokenGuardianStateChanged({\n            wallet: msg.sender,\n            enabled: true,\n            tokenGuardianDisablingTimestamp: 0,\n            timestamp: block.timestamp\n        });\n    }\n\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (to != address(0) && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\n        // We allow removing approvals even if the wallet has the token guardian enabled\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\n            revert HandlesErrors.GuardianEnabled();\n        }\n        super.setApprovalForAll(operator, approved);\n    }\n\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function getNamespace() external pure returns (string memory) {\n        return NAMESPACE;\n    }\n\n    function getNamespaceHash() external pure returns (bytes32) {\n        return NAMESPACE_HASH;\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getLocalName(uint256 tokenId) public view returns (string memory) {\n        string memory localName = _localNames[tokenId];\n        if (bytes(localName).length == 0) {\n            revert HandlesErrors.DoesNotExist();\n        }\n        return _localNames[tokenId];\n    }\n\n    // TODO: Should we revert if it doesn't exist?\n    function getHandle(uint256 tokenId) public view returns (string memory) {\n        string memory localName = getLocalName(tokenId);\n        return string.concat(localName, '.', NAMESPACE);\n    }\n\n    function getTokenId(string memory localName) public pure returns (uint256) {\n        return uint256(keccak256(bytes(localName)));\n    }\n\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256) {\n        return _tokenGuardianDisablingTimestamp[wallet];\n    }\n\n    //////////////////////////////////////\n    ///        INTERNAL FUNCTIONS      ///\n    //////////////////////////////////////\n\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\n        uint256 tokenId = getTokenId(localName);\n        _mint(to, tokenId);\n        _localNames[tokenId] = localName;\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\n        return tokenId;\n    }\n\n    function _validateLocalNameMigration(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        bytes1 firstByte = localNameAsBytes[0];\n        if (firstByte == '-' || firstByte == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '-' && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _validateLocalName(string memory localName) internal view {\n        bytes memory localNameAsBytes = bytes(localName);\n        uint256 localNameLength = localNameAsBytes.length;\n\n        if (localNameLength == 0 || localNameLength + SEPARATOR_LENGTH + NAMESPACE_LENGTH > MAX_HANDLE_LENGTH) {\n            revert HandlesErrors.HandleLengthInvalid();\n        }\n\n        if (localNameAsBytes[0] == '_') {\n            revert HandlesErrors.HandleFirstCharInvalid();\n        }\n\n        uint256 i;\n        while (i < localNameLength) {\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '_') {\n                revert HandlesErrors.HandleContainsInvalidCharacters();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _isAlphaNumeric(bytes1 char) internal pure returns (bool) {\n        return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'z');\n    }\n\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\n        return\n            !wallet.isContract() &&\n            (_tokenGuardianDisablingTimestamp[wallet] == 0 ||\n                block.timestamp < _tokenGuardianDisablingTimestamp[wallet]);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* firstTokenId */,\n        uint256 batchSize\n    ) internal override {\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\n            // Cannot transfer handle if the guardian is enabled, except at minting time.\n            revert HandlesErrors.GuardianEnabled();\n        }\n\n        super._beforeTokenTransfer(from, to, 0, batchSize);\n    }\n}"
    },
    {
      "filename": "contracts/libraries/MigrationLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport {Events} from 'contracts/libraries/constants/Events.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowNFT} from 'contracts/FollowNFT.sol';\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\n\ninterface ILegacyFeeFollowModule {\n    struct ProfileData {\n        address currency;\n        uint256 amount;\n        address recipient;\n    }\n\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory);\n}\n\nlibrary MigrationLib {\n    uint256 internal constant LENS_PROTOCOL_PROFILE_ID = 1;\n    uint256 internal constant DOT_LENS_SUFFIX_LENGTH = 5;\n\n    // Profiles Handles Migration:\n\n    event ProfileMigrated(uint256 profileId, address profileDestination, string handle, uint256 handleId);\n\n    /**\n     * @notice Migrates an array of profiles from V1 to V2. This function can be callable by anyone.\n     * We would still perform the migration in batches by ourselves, but good to allow users to migrate on their own if they want to.\n     *\n     * @param profileIds The array of profile IDs to migrate.\n     */\n    function batchMigrateProfiles(\n        uint256[] calldata profileIds,\n        LensHandles lensHandles,\n        TokenHandleRegistry tokenHandleRegistry\n    ) external {\n        uint256 i;\n        while (i < profileIds.length) {\n            _migrateProfile(profileIds[i], lensHandles, tokenHandleRegistry);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Migrates a profile from V1 to V2.\n     *\n     * @dev We do not revert in any case, as we want to allow the migration to continue even if one profile fails\n     *      (and it usually fails if already migrated or profileNFT moved).\n     * @dev Estimated gas cost of one profile migration is around 178k gas.\n     *\n     * @param profileId The profile ID to migrate.\n     */\n    function _migrateProfile(\n        uint256 profileId,\n        LensHandles lensHandles,\n        TokenHandleRegistry tokenHandleRegistry\n    ) private {\n        address profileOwner = StorageLib.getTokenData(profileId).owner;\n        // We check if the profile exists by checking owner != address(0).\n        if (profileOwner != address(0)) {\n            // We check if the profile has already been migrated by checking __DEPRECATED__handle != \"\".\n            string memory handle = StorageLib.getProfile(profileId).__DEPRECATED__handle;\n            if (bytes(handle).length == 0) {\n                return; // Already migrated\n            }\n            bytes32 handleHash = keccak256(bytes(handle));\n            // We check if the profile is the \"lensprotocol\" profile by checking profileId != 1.\n            // \"lensprotocol\" is the only edge case without the .lens suffix:\n            if (profileId != LENS_PROTOCOL_PROFILE_ID) {\n                assembly {\n                    let handle_length := mload(handle)\n                    mstore(handle, sub(handle_length, DOT_LENS_SUFFIX_LENGTH)) // Cut 5 chars (.lens) from the end\n                }\n            }\n            // We mint a new handle on the LensHandles contract. The resulting handle NFT is sent to the profile owner.\n            uint256 handleId = lensHandles.migrateHandle(profileOwner, handle);\n            // We link it to the profile in the TokenHandleRegistry contract.\n            tokenHandleRegistry.migrationLink(handleId, profileId);\n            emit ProfileMigrated(profileId, profileOwner, handle, handleId);\n            delete StorageLib.getProfile(profileId).__DEPRECATED__handle;\n            delete StorageLib.profileIdByHandleHash()[handleHash];\n        }\n    }\n\n    // FollowNFT Migration:\n\n    function batchMigrateFollows(\n        uint256[] calldata followerProfileIds,\n        uint256[] calldata idsOfProfileFollowed,\n        uint256[] calldata followTokenIds\n    ) external {\n        if (\n            followerProfileIds.length != idsOfProfileFollowed.length ||\n            followerProfileIds.length != followTokenIds.length\n        ) {\n            revert Errors.ArrayMismatch();\n        }\n        uint256 i;\n        while (i < followerProfileIds.length) {\n            _migrateFollow(followerProfileIds[i], idsOfProfileFollowed[i], followTokenIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _migrateFollow(\n        uint256 followerProfileId,\n        uint256 idOfProfileFollowed,\n        uint256 followTokenId\n    ) private {\n        uint48 mintTimestamp = FollowNFT(StorageLib.getProfile(idOfProfileFollowed).followNFT).tryMigrate({\n            followerProfileId: followerProfileId,\n            followerProfileOwner: StorageLib.getTokenData(followerProfileId).owner,\n            idOfProfileFollowed: idOfProfileFollowed,\n            followTokenId: followTokenId\n        });\n        // `mintTimestamp` will be 0 if:\n        // - Follow NFT was already migrated\n        // - Follow NFT does not exist or was burnt\n        // - Follower profile Owner is different from Follow NFT Owner\n        if (mintTimestamp != 0) {\n            emit Events.Followed({\n                followerProfileId: followerProfileId,\n                idOfProfileFollowed: idOfProfileFollowed,\n                followTokenIdAssigned: followTokenId,\n                followModuleData: '',\n                processFollowModuleReturnData: '',\n                timestamp: mintTimestamp // The only case where this won't match block.timestamp is during the migration\n            });\n        }\n    }\n\n    function batchMigrateFollowModules(\n        uint256[] calldata profileIds,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule\n    ) external {\n        uint256 i;\n        while (i < profileIds.length) {\n            address currentFollowModule = StorageLib.getProfile(profileIds[i]).followModule;\n            if (currentFollowModule == legacyFeeFollowModule) {\n                // If the profile had the legacy 'feeFollowModule' set, we need to read its parameters\n                // and initialize the new feeFollowModule with them.\n                StorageLib.getProfile(profileIds[i]).followModule = newFeeFollowModule;\n                ILegacyFeeFollowModule.ProfileData memory feeFollowModuleData = ILegacyFeeFollowModule(\n                    legacyFeeFollowModule\n                ).getProfileData(profileIds[i]);\n                IFollowModule(newFeeFollowModule).initializeFollowModule({\n                    profileId: profileIds[i],\n                    transactionExecutor: msg.sender,\n                    data: abi.encode(\n                        feeFollowModuleData.currency,\n                        feeFollowModuleData.amount,\n                        feeFollowModuleData.recipient\n                    )\n                });\n            } else if (currentFollowModule == legacyProfileFollowModule) {\n                // If the profile had `ProfileFollowModule` set, we just remove the follow module, as in Lens V2\n                // you can only follow with a Lens profile.\n                delete StorageLib.getProfile(profileIds[i]).followModule;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    }
  ]
}