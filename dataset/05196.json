{
  "Title": "[M-04] Complete liquidity removals fail from stableswap pools",
  "Content": "\n<https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/stableswap/src/lib.rs#L638><br>\n<https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/stableswap/src/lib.rs#L551>\n\n### Impact\n\nThe contracts for stableswap has 2 functions dealing with removal of liquidity: `remove_liquidity_one_asset` and `withdraw_asset_amount`. However, both these functions allow redeeming LP tokens and payout in only one token. Critically, this contract is missing Curve protocol's `remove_liquidity` function, which allows redeeming LP tokens for all the different tokens in the pool.\n\nThe result of this decision is that when the complete liquidity of a pool is to be removed, the contract reverts with an arithmetic overflow. In curve protocol, when removing the complete liquidity, the composing tokens are removed from the pool. However, they also need to be converted to a single token, using a liquidity that won't exist anymore. This leads to an issue somewhere in the mathematics of the curve liquidity calculation, and thus reverts.\n\n### Proof of Concept\n\nA simple POC to remove the complete liquidity is coded up below. This POC reverts when the entire amount of shares is being redeemed.\n\n```rust\n#[test]\nfn test_Attack_min_shares() {\n\tlet asset_a: AssetId = 1;\n\tlet asset_b: AssetId = 2;\n\tlet asset_c: AssetId = 3;\n\n\tExtBuilder::default()\n\t\t.with_endowed_accounts(vec![\n\t\t\t(BOB, asset_a, 2*ONE),\n\t\t\t(ALICE, asset_a, 1*ONE),\n\t\t\t(ALICE, asset_b, 1*ONE),\n\t\t\t(ALICE, asset_c, 1*ONE),\n\t\t])\n\t\t.with_registered_asset(\"one\".as_bytes().to_vec(), asset_a, 18)\n\t\t.with_registered_asset(\"two\".as_bytes().to_vec(), asset_b, 6)\n\t\t.with_registered_asset(\"three\".as_bytes().to_vec(), asset_c, 6)\n\t\t.with_pool(\n\t\t\tALICE,\n\t\t\tPoolInfo::<AssetId, u64> {\n\t\t\t\tassets: vec![asset_a, asset_b, asset_c].try_into().unwrap(),\n\t\t\t\tinitial_amplification: NonZeroU16::new(2000).unwrap(),\n\t\t\t\tfinal_amplification: NonZeroU16::new(2000).unwrap(),\n\t\t\t\tinitial_block: 0,\n\t\t\t\tfinal_block: 0,\n\t\t\t\tfee: Permill::zero(),\n\t\t\t},\n\t\t\tInitialLiquidity {\n\t\t\t\taccount: ALICE,\n\t\t\t\tassets: vec![\n\t\t\t\t\tAssetAmount::new(asset_a, 1*ONE),\n\t\t\t\t\tAssetAmount::new(asset_b, 1*ONE),\n\t\t\t\t\tAssetAmount::new(asset_c, 1*ONE),\n\t\t\t\t],\n\t\t\t},\n\t\t)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet pool_id = get_pool_id_at(0);\n\n\t\t\tlet received = Tokens::free_balance(pool_id, &ALICE);\n            println!(\"LP tokens received: {}\", received);\n\n\n            assert_ok!(Stableswap::remove_liquidity_one_asset(\n                RuntimeOrigin::signed(ALICE),\n                pool_id,\n                asset_a,\n                received,\n                0\n            ));\n\n            let asset_a_remliq_bal = Tokens::free_balance(asset_a, &ALICE);\n            println!(\"asset a rem: {}\", asset_a_remliq_bal);\n\t\t});\n}\n```\n\nHere ALICE adds liquidity, and is trying to redeem all her LP tokens. This reverts with the following:\n\n```\nrunning 1 test\nLP tokens received: 23786876415280195891619\nthread 'tests::add_liquidity::test_Attack_min_shares' panicked at 'Expected Ok(_). Got Err(\n    Arithmetic(\n        Overflow,\n    ),\n)', pallets/stableswap/src/tests/add_liquidity.rs:889:13\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\ntest tests::add_liquidity::test_Attack_min_shares ... FAILED\n```\n\nThis is because the internal math of the stableswap algorithm fails when there is no more liquidity.\n\n### Tools Used\n\nSubstrate\n\n### Recommended Mitigation Steps\n\nAllow multi-token liquidity withdrawal, which would allow complete redeeming of all LP tokens.\n\n### Assessed type\n\nUnder/Overflow\n\n**[enthusiastmartin (HydraDX) disputed and commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/86#issuecomment-1979220996):**\n > It is not issue and it is by design, as we don't need the multi-token withdrawal functionality.\n\n**[Lambda (judge) commented](https://github.com/code-423n4/2024-02-hydradx-findings/issues/86#issuecomment-1985427184):**\n > The warden demonstrated that the initial liquidity cannot be removed from the system because of an overflow. This can lead to (temporary) locked funds in edge cases, so Medium is appropriate here.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-hydradx",
  "Code": [
    {
      "filename": "HydraDX-node/pallets/stableswap/src/lib.rs",
      "content": "// Copyright (C) 2020-2022  Intergalactic, Limited (GIB).\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Stableswap pallet\n//!\n//! Curve/stableswap AMM implementation.\n//!\n//! ## Overview\n//!\n//! Curve style AMM at is designed to provide highly efficient and low-slippage trades for stablecoins.\n//!\n//! ### Stableswap Hooks\n//!\n//! Stableswap pallet supports multiple hooks which are triggerred on certain operations:\n//! - on_liquidity_changed - called when liquidity is added or removed from the pool\n//! - on_trade - called when trade is executed\n//!\n//! This is currently used to update on-chain oracle.\n//!\n//! ### Terminology\n//!\n//! * **LP** - liquidity provider\n//! * **Share Token** - a token representing share asset of specific pool. Each pool has its own share token.\n//! * **Amplification** - curve AMM pool amplification parameter\n//!\n//! ## Assumptions\n//!\n//! Maximum number of assets in pool is 5.\n//!\n//! A pool can be created only by allowed `AuthorityOrigin`.\n//!\n//! First LP to provided liquidity must add initial liquidity of all pool assets. Subsequent calls to add_liquidity, LP can provide only 1 asset.\n//!\n//! Initial liquidity is first liquidity added to the pool (that is first call of `add_liquidity`).\n//!\n//! LP is given certain amount of shares by minting a pool's share token.\n//!\n//! When LP decides to withdraw liquidity, it receives selected asset.\n//!\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nextern crate core;\n\nuse frame_support::pallet_prelude::{DispatchResult, Get};\nuse frame_support::{ensure, require_transactional, transactional};\nuse frame_system::pallet_prelude::BlockNumberFor;\nuse hydradx_traits::{registry::InspectRegistry, AccountIdFor};\npub use pallet::*;\nuse sp_runtime::traits::{BlockNumberProvider, Zero};\nuse sp_runtime::{ArithmeticError, DispatchError, Permill, SaturatedConversion};\nuse sp_std::num::NonZeroU16;\nuse sp_std::prelude::*;\nuse sp_std::vec;\n\nmod trade_execution;\npub mod types;\npub mod weights;\n\npub use trade_execution::*;\n\nuse crate::types::{AssetAmount, Balance, PoolInfo, PoolState, StableswapHooks, Tradability};\nuse hydra_dx_math::stableswap::types::AssetReserve;\nuse hydradx_traits::pools::DustRemovalAccountWhitelist;\nuse orml_traits::MultiCurrency;\nuse sp_std::collections::btree_map::BTreeMap;\nuse weights::WeightInfo;\n\n#[cfg(test)]\npub(crate) mod tests;\n\n#[cfg(any(feature = \"runtime-benchmarks\", test))]\nmod benchmarks;\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub use crate::types::BenchmarkHelper;\n\n/// Stableswap account id identifier.\n/// Used as identifier to create share token unique names and account id.\npub const POOL_IDENTIFIER: &[u8] = b\"sts\";\n\npub const MAX_ASSETS_IN_POOL: u32 = 5;\n\nconst D_ITERATIONS: u8 = hydra_dx_math::stableswap::MAX_D_ITERATIONS;\nconst Y_ITERATIONS: u8 = hydra_dx_math::stableswap::MAX_Y_ITERATIONS;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse codec::HasCompact;\n\tuse core::ops::RangeInclusive;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\tuse hydradx_traits::pools::DustRemovalAccountWhitelist;\n\tuse sp_runtime::traits::{BlockNumberProvider, Zero};\n\tuse sp_runtime::ArithmeticError;\n\tuse sp_runtime::Permill;\n\tuse sp_std::num::NonZeroU16;\n\n\t#[pallet::pallet]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n\t\t/// Provider for the current block number.\n\t\ttype BlockNumberProvider: BlockNumberProvider<BlockNumber = BlockNumberFor<Self>>;\n\n\t\t/// Identifier for the class of asset.\n\t\ttype AssetId: Member\n\t\t\t+ Parameter\n\t\t\t+ Ord\n\t\t\t+ Default\n\t\t\t+ Copy\n\t\t\t+ HasCompact\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ MaxEncodedLen\n\t\t\t+ TypeInfo;\n\n\t\t/// Multi currency mechanism\n\t\ttype Currency: MultiCurrency<Self::AccountId, CurrencyId = Self::AssetId, Balance = Balance>;\n\n\t\t/// Account ID constructor - pool account are derived from unique pool id\n\t\ttype ShareAccountId: AccountIdFor<Self::AssetId, AccountId = Self::AccountId>;\n\n\t\t/// Asset registry mechanism to check if asset is registered and retrieve asset decimals.\n\t\ttype AssetInspection: InspectRegistry<Self::AssetId>;\n\n\t\t/// The origin which can create a new pool\n\t\ttype AuthorityOrigin: EnsureOrigin<Self::RuntimeOrigin>;\n\n\t\t/// Account whitelist manager to exclude pool accounts from dusting mechanism.\n\t\ttype DustAccountHandler: DustRemovalAccountWhitelist<Self::AccountId, Error = DispatchError>;\n\n\t\t/// Hooks are actions executed on add_liquidity, sell or buy.\n\t\ttype Hooks: StableswapHooks<Self::AssetId>;\n\n\t\t/// Minimum pool liquidity\n\t\t#[pallet::constant]\n\t\ttype MinPoolLiquidity: Get<Balance>;\n\n\t\t/// Minimum trading amount\n\t\t#[pallet::constant]\n\t\ttype MinTradingLimit: Get<Balance>;\n\n\t\t/// Amplification inclusive range. Pool's amp can be selected from the range only.\n\t\t#[pallet::constant]\n\t\ttype AmplificationRange: Get<RangeInclusive<NonZeroU16>>;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t#[cfg(feature = \"runtime-benchmarks\")]\n\t\ttype BenchmarkHelper: BenchmarkHelper<Self::AssetId>;\n\t}\n\n\t/// Existing pools\n\t#[pallet::storage]\n\t#[pallet::getter(fn pools)]\n\tpub type Pools<T: Config> = StorageMap<_, Blake2_128Concat, T::AssetId, PoolInfo<T::AssetId, BlockNumberFor<T>>>;\n\n\t/// Tradability state of pool assets.\n\t#[pallet::storage]\n\t#[pallet::getter(fn asset_tradability)]\n\tpub type AssetTradability<T: Config> =\n\t\tStorageDoubleMap<_, Blake2_128Concat, T::AssetId, Blake2_128Concat, T::AssetId, Tradability, ValueQuery>;\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// A pool was created.\n\t\tPoolCreated {\n\t\t\tpool_id: T::AssetId,\n\t\t\tassets: Vec<T::AssetId>,\n\t\t\tamplification: NonZeroU16,\n\t\t\tfee: Permill,\n\t\t},\n\t\t/// Pool fee has been updated.\n\t\tFeeUpdated { pool_id: T::AssetId, fee: Permill },\n\t\t/// Liquidity of an asset was added to a pool.\n\t\tLiquidityAdded {\n\t\t\tpool_id: T::AssetId,\n\t\t\twho: T::AccountId,\n\t\t\tshares: Balance,\n\t\t\tassets: Vec<AssetAmount<T::AssetId>>,\n\t\t},\n\t\t/// Liquidity removed.\n\t\tLiquidityRemoved {\n\t\t\tpool_id: T::AssetId,\n\t\t\twho: T::AccountId,\n\t\t\tshares: Balance,\n\t\t\tamounts: Vec<AssetAmount<T::AssetId>>,\n\t\t\tfee: Balance,\n\t\t},\n\t\t/// Sell trade executed. Trade fee paid in asset leaving the pool (already subtracted from amount_out).\n\t\tSellExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\tfee: Balance,\n\t\t},\n\t\t/// Buy trade executed. Trade fee paid in asset entering the pool (already included in amount_in).\n\t\tBuyExecuted {\n\t\t\twho: T::AccountId,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tamount_out: Balance,\n\t\t\tfee: Balance,\n\t\t},\n\n\t\t/// Asset's tradable state has been updated.\n\t\tTradableStateUpdated {\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tstate: Tradability,\n\t\t},\n\n\t\t/// AAmplification of a pool has been scheduled to change.\n\t\tAmplificationChanging {\n\t\t\tpool_id: T::AssetId,\n\t\t\tcurrent_amplification: NonZeroU16,\n\t\t\tfinal_amplification: NonZeroU16,\n\t\t\tstart_block: BlockNumberFor<T>,\n\t\t\tend_block: BlockNumberFor<T>,\n\t\t},\n\t}\n\n\t#[pallet::error]\n\t#[cfg_attr(test, derive(PartialEq, Eq))]\n\tpub enum Error<T> {\n\t\t/// Creating a pool with same assets or less than 2 assets is not allowed.\n\t\tIncorrectAssets,\n\n\t\t/// Maximum number of assets has been exceeded.\n\t\tMaxAssetsExceeded,\n\n\t\t/// A pool with given assets does not exist.\n\t\tPoolNotFound,\n\n\t\t/// A pool with given assets already exists.\n\t\tPoolExists,\n\n\t\t/// Asset is not in the pool.\n\t\tAssetNotInPool,\n\n\t\t/// Share asset is not registered in Registry.\n\t\tShareAssetNotRegistered,\n\n\t\t/// Share asset is amount assets when creating a pool.\n\t\tShareAssetInPoolAssets,\n\n\t\t/// One or more assets are not registered in AssetRegistry\n\t\tAssetNotRegistered,\n\n\t\t/// Invalid asset amount provided. Amount must be greater than zero.\n\t\tInvalidAssetAmount,\n\n\t\t/// Balance of an asset is not sufficient to perform a trade.\n\t\tInsufficientBalance,\n\n\t\t/// Balance of a share asset is not sufficient to withdraw liquidity.\n\t\tInsufficientShares,\n\n\t\t/// Liquidity has not reached the required minimum.\n\t\tInsufficientLiquidity,\n\n\t\t/// Insufficient liquidity left in the pool after withdrawal.\n\t\tInsufficientLiquidityRemaining,\n\n\t\t/// Amount is less than the minimum trading amount configured.\n\t\tInsufficientTradingAmount,\n\n\t\t/// Minimum limit has not been reached during trade.\n\t\tBuyLimitNotReached,\n\n\t\t/// Maximum limit has been exceeded during trade.\n\t\tSellLimitExceeded,\n\n\t\t/// Initial liquidity of asset must be > 0.\n\t\tInvalidInitialLiquidity,\n\n\t\t/// Amplification is outside configured range.\n\t\tInvalidAmplification,\n\n\t\t/// Remaining balance of share asset is below asset's existential deposit.\n\t\tInsufficientShareBalance,\n\n\t\t/// Not allowed to perform an operation on given asset.\n\t\tNotAllowed,\n\n\t\t/// Future block number is in the past.\n\t\tPastBlock,\n\n\t\t/// New amplification is equal to the previous value.\n\t\tSameAmplification,\n\n\t\t/// Slippage protection.\n\t\tSlippageLimit,\n\n\t\t/// Failed to retrieve asset decimals.\n\t\tUnknownDecimals,\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Create a stable pool with given list of assets.\n\t\t///\n\t\t/// All assets must be correctly registered in `T::AssetRegistry`.\n\t\t/// Note that this does not seed the pool with liquidity. Use `add_liquidity` to provide\n\t\t/// initial liquidity.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: Must be T::AuthorityOrigin\n\t\t/// - `share_asset`: Preregistered share asset identifier\n\t\t/// - `assets`: List of Asset ids\n\t\t/// - `amplification`: Pool amplification\n\t\t/// - `fee`: fee to be applied on trade and liquidity operations\n\t\t///\n\t\t/// Emits `PoolCreated` event if successful.\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::create_pool())]\n\t\t#[transactional]\n\t\tpub fn create_pool(\n\t\t\torigin: OriginFor<T>,\n\t\t\tshare_asset: T::AssetId,\n\t\t\tassets: Vec<T::AssetId>,\n\t\t\tamplification: u16,\n\t\t\tfee: Permill,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin)?;\n\n\t\t\tlet amplification = NonZeroU16::new(amplification).ok_or(Error::<T>::InvalidAmplification)?;\n\n\t\t\tlet pool_id = Self::do_create_pool(share_asset, &assets, amplification, fee)?;\n\n\t\t\tSelf::deposit_event(Event::PoolCreated {\n\t\t\t\tpool_id,\n\t\t\t\tassets,\n\t\t\t\tamplification,\n\t\t\t\tfee,\n\t\t\t});\n\n\t\t\tSelf::deposit_event(Event::AmplificationChanging {\n\t\t\t\tpool_id,\n\t\t\t\tcurrent_amplification: amplification,\n\t\t\t\tfinal_amplification: amplification,\n\t\t\t\tstart_block: T::BlockNumberProvider::current_block_number(),\n\t\t\t\tend_block: T::BlockNumberProvider::current_block_number(),\n\t\t\t});\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Update pool's fee.\n\t\t///\n\t\t/// if pool does not exist, `PoolNotFound` is returned.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: Must be T::AuthorityOrigin\n\t\t/// - `pool_id`: pool to update\n\t\t/// - `fee`: new pool fee\n\t\t///\n\t\t/// Emits `FeeUpdated` event if successful.\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_pool_fee())]\n\t\t#[transactional]\n\t\tpub fn update_pool_fee(origin: OriginFor<T>, pool_id: T::AssetId, fee: Permill) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin)?;\n\n\t\t\tPools::<T>::try_mutate(pool_id, |maybe_pool| -> DispatchResult {\n\t\t\t\tlet pool = maybe_pool.as_mut().ok_or(Error::<T>::PoolNotFound)?;\n\n\t\t\t\tpool.fee = fee;\n\t\t\t\tSelf::deposit_event(Event::FeeUpdated { pool_id, fee });\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\n\t\t/// Update pool's amplification.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: Must be T::AuthorityOrigin\n\t\t/// - `pool_id`: pool to update\n\t\t/// - `future_amplification`: new desired pool amplification\n\t\t/// - `future_block`: future block number when the amplification is updated\n\t\t///\n\t\t/// Emits `AmplificationUpdated` event if successful.\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::update_amplification())]\n\t\t#[transactional]\n\t\tpub fn update_amplification(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tfinal_amplification: u16,\n\t\t\tstart_block: BlockNumberFor<T>,\n\t\t\tend_block: BlockNumberFor<T>,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin)?;\n\n\t\t\tlet current_block = T::BlockNumberProvider::current_block_number();\n\t\t\tensure!(\n\t\t\t\tend_block > start_block && start_block >= current_block,\n\t\t\t\tError::<T>::PastBlock\n\t\t\t);\n\n\t\t\tPools::<T>::try_mutate(pool_id, |maybe_pool| -> DispatchResult {\n\t\t\t\tlet pool = maybe_pool.as_mut().ok_or(Error::<T>::PoolNotFound)?;\n\n\t\t\t\tlet current_amplification = Self::get_amplification(pool);\n\n\t\t\t\tensure!(\n\t\t\t\t\tcurrent_amplification != final_amplification as u128,\n\t\t\t\t\tError::<T>::SameAmplification\n\t\t\t\t);\n\n\t\t\t\tpool.initial_amplification =\n\t\t\t\t\tNonZeroU16::new(current_amplification.saturated_into()).ok_or(Error::<T>::InvalidAmplification)?;\n\t\t\t\tpool.final_amplification =\n\t\t\t\t\tNonZeroU16::new(final_amplification).ok_or(Error::<T>::InvalidAmplification)?;\n\t\t\t\tpool.initial_block = start_block;\n\t\t\t\tpool.final_block = end_block;\n\n\t\t\t\tensure!(\n\t\t\t\t\tT::AmplificationRange::get().contains(&pool.final_amplification),\n\t\t\t\t\tError::<T>::InvalidAmplification\n\t\t\t\t);\n\t\t\t\tSelf::deposit_event(Event::AmplificationChanging {\n\t\t\t\t\tpool_id,\n\t\t\t\t\tcurrent_amplification: pool.initial_amplification,\n\t\t\t\t\tfinal_amplification: pool.final_amplification,\n\t\t\t\t\tstart_block: pool.initial_block,\n\t\t\t\t\tend_block: pool.final_block,\n\t\t\t\t});\n\t\t\t\tOk(())\n\t\t\t})\n\t\t}\n\n\t\t/// Add liquidity to selected pool.\n\t\t///\n\t\t/// First call of `add_liquidity` must provide \"initial liquidity\" of all assets.\n\t\t///\n\t\t/// If there is liquidity already in the pool, LP can provide liquidity of any number of pool assets.\n\t\t///\n\t\t/// LP must have sufficient amount of each asset.\n\t\t///\n\t\t/// Origin is given corresponding amount of shares.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: liquidity provider\n\t\t/// - `pool_id`: Pool Id\n\t\t/// - `assets`: asset id and liquidity amount provided\n\t\t///\n\t\t/// Emits `LiquidityAdded` event when successful.\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_liquidity()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_liquidity_changed_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn add_liquidity(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tassets: Vec<AssetAmount<T::AssetId>>,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tlet shares = Self::do_add_liquidity(&who, pool_id, &assets)?;\n\n\t\t\tSelf::deposit_event(Event::LiquidityAdded {\n\t\t\t\tpool_id,\n\t\t\t\twho,\n\t\t\t\tshares,\n\t\t\t\tassets,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Add liquidity to selected pool given exact amount of shares to receive.\n\t\t///\n\t\t/// Similar to `add_liquidity` but LP specifies exact amount of shares to receive.\n\t\t///\n\t\t/// This functionality is used mainly by on-chain routing when a swap between Omnipool asset and stable asset is performed.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: liquidity provider\n\t\t/// - `pool_id`: Pool Id\n\t\t/// - `shares`: amount of shares to receive\n\t\t/// - `asset_id`: asset id of an asset to provide as liquidity\n\t\t/// - `max_asset_amount`: slippage limit. Max amount of asset.\n\t\t///\n\t\t/// Emits `LiquidityAdded` event when successful.\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::add_liquidity_shares()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_liquidity_changed_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn add_liquidity_shares(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tshares: Balance,\n\t\t\tasset_id: T::AssetId,\n\t\t\tmax_asset_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\t\t\tlet amount_in = Self::do_add_liquidity_shares(&who, pool_id, shares, asset_id, max_asset_amount)?;\n\t\t\tSelf::deposit_event(Event::LiquidityAdded {\n\t\t\t\tpool_id,\n\t\t\t\twho,\n\t\t\t\tshares,\n\t\t\t\tassets: vec![AssetAmount::new(asset_id, amount_in)],\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove liquidity from selected pool.\n\t\t///\n\t\t/// Withdraws liquidity of selected asset from a pool.\n\t\t///\n\t\t/// Share amount is burned and LP receives corresponding amount of chosen asset.\n\t\t///\n\t\t/// Withdraw fee is applied to the asset amount.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: liquidity provider\n\t\t/// - `pool_id`: Pool Id\n\t\t/// - `asset_id`: id of asset to receive\n\t\t/// - 'share_amount': amount of shares to withdraw\n\t\t/// - 'min_amount_out': minimum amount to receive\n\t\t///\n\t\t/// Emits `LiquidityRemoved` event when successful.\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::remove_liquidity_one_asset()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_liquidity_changed_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn remove_liquidity_one_asset(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tshare_amount: Balance,\n\t\t\tmin_amount_out: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset_id, Tradability::REMOVE_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\t\t\tensure!(share_amount > Balance::zero(), Error::<T>::InvalidAssetAmount);\n\n\t\t\tlet current_share_balance = T::Currency::free_balance(pool_id, &who);\n\t\t\tensure!(current_share_balance >= share_amount, Error::<T>::InsufficientShares);\n\t\t\tensure!(\n\t\t\t\tcurrent_share_balance == share_amount\n\t\t\t\t\t|| current_share_balance.saturating_sub(share_amount) >= T::MinPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientShareBalance\n\t\t\t);\n\n\t\t\t// Retrive pool state.\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet asset_idx = pool.find_asset(asset_id).ok_or(Error::<T>::AssetNotInPool)?;\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\t\t\tlet initial_reserves = pool\n\t\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\t\t\tlet share_issuance = T::Currency::total_issuance(pool_id);\n\n\t\t\tensure!(\n\t\t\t\tshare_issuance == share_amount\n\t\t\t\t\t|| share_issuance.saturating_sub(share_amount) >= T::MinPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientLiquidityRemaining\n\t\t\t);\n\n\t\t\tlet amplification = Self::get_amplification(&pool);\n\n\t\t\t//Calculate how much asset user will receive. Note that the fee is already subtracted from the amount.\n\t\t\tlet (amount, fee) = hydra_dx_math::stableswap::calculate_withdraw_one_asset::<D_ITERATIONS, Y_ITERATIONS>(\n\t\t\t\t&initial_reserves,\n\t\t\t\tshare_amount,\n\t\t\t\tasset_idx,\n\t\t\t\tshare_issuance,\n\t\t\t\tamplification,\n\t\t\t\tpool.fee,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tensure!(amount >= min_amount_out, Error::<T>::SlippageLimit);\n\n\t\t\t// Burn shares and transfer asset to user.\n\t\t\tT::Currency::withdraw(pool_id, &who, share_amount)?;\n\t\t\tT::Currency::transfer(asset_id, &pool_account, &who, amount)?;\n\n\t\t\t// All done and updated. let's call the on_liquidity_changed hook.\n\t\t\tSelf::call_on_liquidity_change_hook(pool_id, &initial_reserves, share_issuance)?;\n\n\t\t\tSelf::deposit_event(Event::LiquidityRemoved {\n\t\t\t\tpool_id,\n\t\t\t\twho,\n\t\t\t\tshares: share_amount,\n\t\t\t\tamounts: vec![AssetAmount { asset_id, amount }],\n\t\t\t\tfee,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove liquidity from selected pool by specifying exact amount of asset to receive.\n\t\t///\n\t\t/// Similar to `remove_liquidity_one_asset` but LP specifies exact amount of asset to receive instead of share amount.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: liquidity provider\n\t\t/// - `pool_id`: Pool Id\n\t\t/// - `asset_id`: id of asset to receive\n\t\t/// - 'amount': amount of asset to receive\n\t\t/// - 'max_share_amount': Slippage limit. Max amount of shares to burn.\n\t\t///\n\t\t/// Emits `LiquidityRemoved` event when successful.\n\t\t#[pallet::call_index(6)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::withdraw_asset_amount()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_liquidity_changed_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn withdraw_asset_amount(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tamount: Balance,\n\t\t\tmax_share_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset_id, Tradability::REMOVE_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\t\t\tensure!(amount > Balance::zero(), Error::<T>::InvalidAssetAmount);\n\n\t\t\t// Retrieve pool state.\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet asset_idx = pool.find_asset(asset_id).ok_or(Error::<T>::AssetNotInPool)?;\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\t\t\tlet initial_reserves = pool\n\t\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\t\t\tlet share_issuance = T::Currency::total_issuance(pool_id);\n\t\t\tlet amplification = Self::get_amplification(&pool);\n\n\t\t\t// Calculate how much shares user needs to provide to receive `amount` of asset.\n\t\t\tlet shares = hydra_dx_math::stableswap::calculate_shares_for_amount::<D_ITERATIONS>(\n\t\t\t\t&initial_reserves,\n\t\t\t\tasset_idx,\n\t\t\t\tamount,\n\t\t\t\tamplification,\n\t\t\t\tshare_issuance,\n\t\t\t\tpool.fee,\n\t\t\t)\n\t\t\t.ok_or(ArithmeticError::Overflow)?;\n\n\t\t\tensure!(shares <= max_share_amount, Error::<T>::SlippageLimit);\n\n\t\t\tlet current_share_balance = T::Currency::free_balance(pool_id, &who);\n\t\t\tensure!(\n\t\t\t\tcurrent_share_balance == shares\n\t\t\t\t\t|| current_share_balance.saturating_sub(shares) >= T::MinPoolLiquidity::get(),\n\t\t\t\tError::<T>::InsufficientShareBalance\n\t\t\t);\n\n\t\t\t// Burn shares and transfer asset to user.\n\t\t\tT::Currency::withdraw(pool_id, &who, shares)?;\n\t\t\tT::Currency::transfer(asset_id, &pool_account, &who, amount)?;\n\n\t\t\t// All done and updated. let's call the on_liquidity_changed hook.\n\t\t\tSelf::call_on_liquidity_change_hook(pool_id, &initial_reserves, share_issuance)?;\n\n\t\t\tSelf::deposit_event(Event::LiquidityRemoved {\n\t\t\t\tpool_id,\n\t\t\t\twho,\n\t\t\t\tshares,\n\t\t\t\tamounts: vec![AssetAmount { asset_id, amount }],\n\t\t\t\tfee: 0u128, // dev note: figure out the actual fee amount in this case. For now, we dont need it.\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Execute a swap of `asset_in` for `asset_out`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`: origin of the caller\n\t\t/// - `pool_id`: Id of a pool\n\t\t/// - `asset_in`: ID of asset sold to the pool\n\t\t/// - `asset_out`: ID of asset bought from the pool\n\t\t/// - `amount_in`: Amount of asset to be sold to the pool\n\t\t/// - `min_buy_amount`: Minimum amount required to receive\n\t\t///\n\t\t/// Emits `SellExecuted` event when successful.\n\t\t///\n\t\t#[pallet::call_index(7)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::sell()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_trade_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn sell(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tamount_in: Balance,\n\t\t\tmin_buy_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset_in, Tradability::SELL)\n\t\t\t\t\t&& Self::is_asset_allowed(pool_id, asset_out, Tradability::BUY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tamount_in >= T::MinTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::free_balance(asset_in, &who) >= amount_in,\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\t\t\tlet initial_reserves = pool\n\t\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\n\t\t\tlet (amount_out, fee_amount) = Self::calculate_out_amount(pool_id, asset_in, asset_out, amount_in)?;\n\t\t\tensure!(amount_out >= min_buy_amount, Error::<T>::BuyLimitNotReached);\n\n\t\t\tT::Currency::transfer(asset_in, &who, &pool_account, amount_in)?;\n\t\t\tT::Currency::transfer(asset_out, &pool_account, &who, amount_out)?;\n\n\t\t\t//All done and updated. Let's call on_trade hook.\n\t\t\tSelf::call_on_trade_hook(pool_id, asset_in, asset_out, &initial_reserves)?;\n\n\t\t\tSelf::deposit_event(Event::SellExecuted {\n\t\t\t\twho,\n\t\t\t\tpool_id,\n\t\t\t\tasset_in,\n\t\t\t\tasset_out,\n\t\t\t\tamount_in,\n\t\t\t\tamount_out,\n\t\t\t\tfee: fee_amount,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Execute a swap of `asset_in` for `asset_out`.\n\t\t///\n\t\t/// Parameters:\n\t\t/// - `origin`:\n\t\t/// - `pool_id`: Id of a pool\n\t\t/// - `asset_out`: ID of asset bought from the pool\n\t\t/// - `asset_in`: ID of asset sold to the pool\n\t\t/// - `amount_out`: Amount of asset to receive from the pool\n\t\t/// - `max_sell_amount`: Maximum amount allowed to be sold\n\t\t///\n\t\t/// Emits `BuyExecuted` event when successful.\n\t\t///\n\t\t#[pallet::call_index(8)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::buy()\n\t\t\t\t\t\t\t.saturating_add(T::Hooks::on_trade_weight(MAX_ASSETS_IN_POOL as usize)))]\n\t\t#[transactional]\n\t\tpub fn buy(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_out: T::AssetId,\n\t\t\tasset_in: T::AssetId,\n\t\t\tamount_out: Balance,\n\t\t\tmax_sell_amount: Balance,\n\t\t) -> DispatchResult {\n\t\t\tlet who = ensure_signed(origin)?;\n\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset_in, Tradability::SELL)\n\t\t\t\t\t&& Self::is_asset_allowed(pool_id, asset_out, Tradability::BUY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tamount_out >= T::MinTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\t\t\tlet initial_reserves = pool\n\t\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\n\t\t\tlet (amount_in, fee_amount) = Self::calculate_in_amount(pool_id, asset_in, asset_out, amount_out)?;\n\n\t\t\tlet pool_account = Self::pool_account(pool_id);\n\n\t\t\tensure!(amount_in <= max_sell_amount, Error::<T>::SellLimitExceeded);\n\n\t\t\tensure!(\n\t\t\t\tT::Currency::free_balance(asset_in, &who) >= amount_in,\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\n\t\t\tT::Currency::transfer(asset_in, &who, &pool_account, amount_in)?;\n\t\t\tT::Currency::transfer(asset_out, &pool_account, &who, amount_out)?;\n\n\t\t\t//All done and updated. Let's call on_trade_hook.\n\t\t\tSelf::call_on_trade_hook(pool_id, asset_in, asset_out, &initial_reserves)?;\n\n\t\t\tSelf::deposit_event(Event::BuyExecuted {\n\t\t\t\twho,\n\t\t\t\tpool_id,\n\t\t\t\tasset_in,\n\t\t\t\tasset_out,\n\t\t\t\tamount_in,\n\t\t\t\tamount_out,\n\t\t\t\tfee: fee_amount,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\n\t\t#[pallet::call_index(9)]\n\t\t#[pallet::weight(<T as Config>::WeightInfo::set_asset_tradable_state())]\n\t\t#[transactional]\n\t\tpub fn set_asset_tradable_state(\n\t\t\torigin: OriginFor<T>,\n\t\t\tpool_id: T::AssetId,\n\t\t\tasset_id: T::AssetId,\n\t\t\tstate: Tradability,\n\t\t) -> DispatchResult {\n\t\t\tT::AuthorityOrigin::ensure_origin(origin)?;\n\n\t\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\t\tlet _ = pool.find_asset(asset_id).ok_or(Error::<T>::AssetNotInPool)?;\n\n\t\t\tAssetTradability::<T>::mutate(pool_id, asset_id, |current_state| {\n\t\t\t\t*current_state = state;\n\t\t\t});\n\n\t\t\tSelf::deposit_event(Event::TradableStateUpdated {\n\t\t\t\tpool_id,\n\t\t\t\tasset_id,\n\t\t\t\tstate,\n\t\t\t});\n\n\t\t\tOk(())\n\t\t}\n\t}\n\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {}\n}\n\nimpl<T: Config> Pallet<T> {\n\t/// Calculates out amount given in amount.\n\t/// Returns (out_amount, fee_amount) on success. Note that fee amount is already subtracted from the out amount.\n\tfn calculate_out_amount(\n\t\tpool_id: T::AssetId,\n\t\tasset_in: T::AssetId,\n\t\tasset_out: T::AssetId,\n\t\tamount_in: Balance,\n\t) -> Result<(Balance, Balance), DispatchError> {\n\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\n\t\tlet index_in = pool.find_asset(asset_in).ok_or(Error::<T>::AssetNotInPool)?;\n\t\tlet index_out = pool.find_asset(asset_out).ok_or(Error::<T>::AssetNotInPool)?;\n\n\t\tlet pool_account = Self::pool_account(pool_id);\n\t\tlet initial_reserves = pool\n\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\n\t\tensure!(!initial_reserves[index_in].is_zero(), Error::<T>::InsufficientLiquidity);\n\t\tensure!(\n\t\t\t!initial_reserves[index_out].is_zero(),\n\t\t\tError::<T>::InsufficientLiquidity\n\t\t);\n\n\t\tlet amplification = Self::get_amplification(&pool);\n\t\thydra_dx_math::stableswap::calculate_out_given_in_with_fee::<D_ITERATIONS, Y_ITERATIONS>(\n\t\t\t&initial_reserves,\n\t\t\tindex_in,\n\t\t\tindex_out,\n\t\t\tamount_in,\n\t\t\tamplification,\n\t\t\tpool.fee,\n\t\t)\n\t\t.ok_or_else(|| ArithmeticError::Overflow.into())\n\t}\n\n\t/// Calculates in amount given out amount.\n\t/// Returns (in_amount, fee_amount) on success. Note that fee amount is already added to the in amount.\n\tfn calculate_in_amount(\n\t\tpool_id: T::AssetId,\n\t\tasset_in: T::AssetId,\n\t\tasset_out: T::AssetId,\n\t\tamount_out: Balance,\n\t) -> Result<(Balance, Balance), DispatchError> {\n\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\n\t\tlet index_in = pool.find_asset(asset_in).ok_or(Error::<T>::AssetNotInPool)?;\n\t\tlet index_out = pool.find_asset(asset_out).ok_or(Error::<T>::AssetNotInPool)?;\n\n\t\tlet pool_account = Self::pool_account(pool_id);\n\t\tlet initial_reserves = pool\n\t\t\t.reserves_with_decimals::<T>(&pool_account)\n\t\t\t.ok_or(Error::<T>::UnknownDecimals)?;\n\n\t\tensure!(\n\t\t\tinitial_reserves[index_out].amount > amount_out,\n\t\t\tError::<T>::InsufficientLiquidity\n\t\t);\n\t\tensure!(!initial_reserves[index_in].is_zero(), Error::<T>::InsufficientLiquidity);\n\n\t\tlet amplification = Self::get_amplification(&pool);\n\t\thydra_dx_math::stableswap::calculate_in_given_out_with_fee::<D_ITERATIONS, Y_ITERATIONS>(\n\t\t\t&initial_reserves,\n\t\t\tindex_in,\n\t\t\tindex_out,\n\t\t\tamount_out,\n\t\t\tamplification,\n\t\t\tpool.fee,\n\t\t)\n\t\t.ok_or_else(|| ArithmeticError::Overflow.into())\n\t}\n\n\t#[require_transactional]\n\tfn do_create_pool(\n\t\tshare_asset: T::AssetId,\n\t\tassets: &[T::AssetId],\n\t\tamplification: NonZeroU16,\n\t\tfee: Permill,\n\t) -> Result<T::AssetId, DispatchError> {\n\t\tensure!(!Pools::<T>::contains_key(share_asset), Error::<T>::PoolExists);\n\t\tensure!(\n\t\t\tT::AssetInspection::exists(share_asset),\n\t\t\tError::<T>::ShareAssetNotRegistered\n\t\t);\n\n\t\tensure!(!assets.contains(&share_asset), Error::<T>::ShareAssetInPoolAssets);\n\n\t\tlet block_number = T::BlockNumberProvider::current_block_number();\n\n\t\tlet mut pool_assets = assets.to_vec();\n\t\tpool_assets.sort();\n\n\t\tlet pool = PoolInfo {\n\t\t\tassets: pool_assets\n\t\t\t\t.clone()\n\t\t\t\t.try_into()\n\t\t\t\t.map_err(|_| Error::<T>::MaxAssetsExceeded)?,\n\t\t\tinitial_amplification: amplification,\n\t\t\tfinal_amplification: amplification,\n\t\t\tinitial_block: block_number,\n\t\t\tfinal_block: block_number,\n\t\t\tfee,\n\t\t};\n\t\tensure!(pool.is_valid(), Error::<T>::IncorrectAssets);\n\t\tensure!(\n\t\t\tT::AmplificationRange::get().contains(&amplification),\n\t\t\tError::<T>::InvalidAmplification\n\t\t);\n\t\tfor asset in pool.assets.iter() {\n\t\t\tensure!(T::AssetInspection::exists(*asset), Error::<T>::AssetNotRegistered);\n\t\t}\n\n\t\tPools::<T>::insert(share_asset, pool);\n\t\tT::DustAccountHandler::add_account(&Self::pool_account(share_asset))?;\n\t\tOk(share_asset)\n\t}\n\n\t#[require_transactional]\n\tfn do_add_liquidity(\n\t\twho: &T::AccountId,\n\t\tpool_id: T::AssetId,\n\t\tassets: &[AssetAmount<T::AssetId>],\n\t) -> Result<Balance, DispatchError> {\n\t\tlet pool = Pools::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;\n\t\tensure!(assets.len() <= pool.assets.len(), Error::<T>::MaxAssetsExceeded);\n\t\tlet mut added_assets = BTreeMap::<T::AssetId, Balance>::new();\n\t\tfor asset in assets.iter() {\n\t\t\tensure!(\n\t\t\t\tSelf::is_asset_allowed(pool_id, asset.asset_id, Tradability::ADD_LIQUIDITY),\n\t\t\t\tError::<T>::NotAllowed\n\t\t\t);\n\t\t\tensure!(\n\t\t\t\tasset.amount >= T::MinTradingLimit::get(),\n\t\t\t\tError::<T>::InsufficientTradingAmount\n\t\t\t);\n\t\t\tensure!(\n\t\t\t\tT::Currency::free_balance(asset.asset_id, who) >= asset.amount,\n\t\t\t\tError::<T>::InsufficientBalance\n\t\t\t);\n\t\t\tif added_assets.insert(asset.asset_id, asset.amount).is_some() {\n\t\t\t\treturn Err(Error::<T>::IncorrectAssets.into());\n\t\t\t}\n\t\t}\n\n\t\tlet pool_account = Self::pool_account(pool_id);\n\t\tlet mut initial_reserves = Vec::with_capacity(pool.assets.len());\n\t\tlet mut updated_reserves = Vec::with_capacity(pool.assets.len());\n\t\tlet mut added_amounts = Vec::with_capacity(pool.assets.len());\n\t\tfor pool_asset in pool.assets.iter() {\n\t\t\tlet decimals = Self::retrieve_decimals(*pool_asset).ok_or(Error::<T>::UnknownDecimals)?;\n\t\t\tlet reserve = T::Currency::free_balance(*pool_asset, &pool_account);\n\t\t\tinitial_reserves.push(AssetReserve {\n\t\t\t\tamount: reserve,\n\t\t\t\tdecimals,\n\t\t\t});\n\t\t\tif let Some(liq_added) = added_assets.remove(pool_asset) {\n\t\t\t\tlet inc_reserve = reserve.checked_add(liq_added).ok_or(Arith"
    }
  ]
}