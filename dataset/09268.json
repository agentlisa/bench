{
  "Title": "[L-01] Missing parameter validations in ",
  "Content": "<h2 id=\"l-01-missing-parameter-validations-in-speedbumppricegateaddgate\" style=\"position:relative;\"><a href=\"#l-01-missing-parameter-validations-in-speedbumppricegateaddgate\" aria-label=\"l 01 missing parameter validations in speedbumppricegateaddgate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Missing parameter validations in <code>SpeedBumpPriceGate#addGate</code></h2>\n<p>Callers of <code>addGate</code> can create price gates with a zero price floor (allowing users to claim free tokens), and zero <code>priceIncreaseDenominator</code> (causing price calculation to revert with a divide by zero error).</p>\n<p><a href=\"https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L36-L45\"><code>SpeedBumpPriceGate#addGate</code></a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"32\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">addGate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceDecay</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIncrease</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// prefix operator increments then evaluates</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">Gate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">gate</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">gates</span><span class=\"mtk1\">[++</span><span class=\"mtk12\">numGates</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decayFactor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceDecay</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceIncreaseFactor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIncrease</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Suggestion: Validate that <code>priceFloor</code> and <code>priceIncreaseDenominator</code> are nonzero.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"33\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">addGate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceDecay</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIncrease</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"Price floor must be nonzero\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">\"Denominator must be nonzero\"</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// prefix operator increments then evaluates</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">Gate</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">gate</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">gates</span><span class=\"mtk1\">[++</span><span class=\"mtk12\">numGates</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceFloor</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decayFactor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceDecay</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceIncreaseFactor</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIncrease</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIncreaseDenominator</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">gate</span><span class=\"mtk1\">.</span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">beneficiary</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/SpeedBumpPriceGate.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IPriceGate.sol\";\n\n/// @title A factory pattern for a price gate whose price increases exponentially on purchase and decays linearly thereafter\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract has no management key, anyone can add a gate\n/// @dev Note passing thru the gate forwards all gas, so beneficiary can be a contract, possibly malicious\ncontract SpeedBumpPriceGate is IPriceGate {\n\n    // this represents a single gate\n    struct Gate {\n        uint priceIncreaseFactor;\n        uint priceIncreaseDenominator;\n        uint lastPrice;\n        uint decayFactor;\n        uint priceFloor;\n        uint lastPurchaseBlock;\n        address beneficiary;\n    }\n\n    // array-like mapping of gate structs\n    mapping (uint => Gate) public gates;\n    // count the gates as they come in!\n    uint public numGates;\n\n    /// @notice Add a price gate to the list of available price gates\n    /// @dev Anyone can call this, but it must be connected to MerkleIdentity via priceGateIndex to be used\n    /// @dev The price increase factor is split into numerator and denominator to enable fractions (wow! I love fractions!)\n    /// @param priceFloor the starting price and the lowest price that can be reached via decay\n    /// @param priceDecay the per-block rate at which the price reduces until it hits the price floor\n    /// @param priceIncrease the numerator of the factor by which the price multiplies when a purchase occurs\n    /// @param priceIncreaseDenominator the denominator of the price increase factor\n    /// @param beneficiary who receives the proceeds from a purchase\n    function addGate(uint priceFloor, uint priceDecay, uint priceIncrease, uint priceIncreaseDenominator, address beneficiary) external {\n        // prefix operator increments then evaluates\n        Gate storage gate = gates[++numGates];\n        gate.priceFloor = priceFloor;\n        gate.decayFactor = priceDecay;\n        gate.priceIncreaseFactor = priceIncrease;\n        gate.priceIncreaseDenominator = priceIncreaseDenominator;\n        gate.beneficiary = beneficiary;\n    }\n\n    /// @notice Get the cost of passing thru this gate\n    /// @param index which gate are we talking about?\n    /// @return _ethCost the amount of ether required to pass thru this gate\n    function getCost(uint index) override public view returns (uint _ethCost) {\n        Gate memory gate = gates[index];\n        // compute the linear decay\n        uint decay = gate.decayFactor * (block.number - gate.lastPurchaseBlock);\n        // gate.lastPrice - decay < gate.priceFloor (left side could underflow)\n        if (gate.lastPrice < decay + gate.priceFloor) {\n            return gate.priceFloor;\n        } else {\n            return gate.lastPrice - decay;\n        }\n    }\n\n    /// @notice Pass thru this gate, should be called by MerkleIndex\n    /// @dev This can be called by anyone, devs can call it to test it on mainnet\n    /// @param index which gate are we passing thru?\n    function passThruGate(uint index, address) override external payable {\n        uint price = getCost(index);\n        require(msg.value >= price, 'Please send more ETH');\n\n        // bump up the price\n        Gate storage gate = gates[index];\n        // multiply by the price increase factor\n        gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n        // move up the reference\n        gate.lastPurchaseBlock = block.number;\n\n        // pass thru the ether\n        if (msg.value > 0) {\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n            (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n            require(sent, 'ETH transfer failed');\n        }\n    }\n}"
    }
  ]
}