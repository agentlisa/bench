{
  "Title": "[L-01] Aura's `withdraw()` and `redeem()` functions do not send any reward tokens",
  "Content": "When the controller sees a call to Aura's `withdraw()` or `redeem()` function, it sets `tokensIn` to an array of the `asset` along with all reward tokens:\n```solidity\nfunction canCallWithdrawAndRedeem(address target)\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    uint256 rewardLength = IRewards(target).extraRewardsLength();\n    address[] memory tokensIn = new address[](rewardLength + 2);\n    for (uint256 i = 0; i < rewardLength; i++) {\n        tokensIn[i] = IRewards(IRewards(target).extraRewards(i)).rewardToken();\n    }\n    tokensIn[rewardLength] = IERC4626(target).asset();\n    tokensIn[rewardLength + 1] = IRewards(target).rewardToken();\n\n    address[] memory tokensOut = new address[](1);\n    tokensOut[0] = target;\n    return (true, tokensIn, tokensOut);\n}\n```\nHowever, if we examing the code, we will see that no rewards are sent, so the `tokensIn` array could simply be set to `[asset]`.\n```solidity\nfunction _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){\n    //also withdraw from linked rewards\n    for(uint i=0; i < extraRewards.length; i++){\n        IRewards(extraRewards[i]).withdraw(from, amount);\n    }\n\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[from] = _balances[from].sub(amount);\n\n    //tell operator to withdraw from here directly to user\n    IDeposit(operator).withdrawTo(pid,amount,receiver);\n    emit Withdrawn(from, amount);\n\n    emit Transfer(from, address(0), amount);\n\n    return true;\n}\n```\nhttps://github.com/aurafinance/convex-platform/blob/3cd1ce3657bae8abb975b9dd06f28247c22880d3/contracts/contracts/BaseRewardPool.sol#LL269C1-L285C6\n\nWe can see that there is no call to withdraw the `rewardToken` of the main pool.\n\nWhile it seems that there are withdrawals of the `extraRewards`, the `withdraw()` function on those does not actually claim those rewards, it simply uses the `updateReward()` modifier to update the stored rewards waiting to be claimed:\n```solidity\nfunction withdraw(address _account, uint256 amount)\n    public\n    updateReward(_account)\n{\n    require(msg.sender == address(deposits), \"!authorized\");\n    //require(amount > 0, 'VirtualDepositRewardPool : Cannot withdraw 0');\n\n    emit Withdrawn(_account, amount);\n}\n```\nhttps://github.com/aurafinance/convex-platform/blob/3cd1ce3657bae8abb975b9dd06f28247c22880d3/contracts/contracts/VirtualBalanceRewardPool.sol#L179-L187\n\n**Recommendation**\n\nThe `canCallWithdrawAndRedeem()` function can be simplified to only include the `IERC4626(target).asset()` token in the `tokensIn` array.\n\n**Review**\n\nFixed in [commit 49db04366e255568f0cab1e6e083b9fff808b384](https://github.com/sentimentxyz/controller/pull/64/commits/49db04366e255568f0cab1e6e083b9fff808b384) as recommended.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/MathUtil.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   BaseRewardPool\n * @author  Synthetix -> ConvexFinance\n * @notice  Unipool rewards contract that is re-deployed from rFactory for each staking pool.\n * @dev     Changes made here by ConvexFinance are to do with the delayed reward allocation. Curve is queued for\n *          rewards and the distribution only begins once the new rewards are sufficiently large, or the epoch\n *          has ended. Additionally, enables hooks for `extraRewards` that can be enabled at any point to\n *          distribute a child reward token (i.e. a secondary one from Curve, or a seperate one).\n */\ncontract BaseRewardPool {\n     using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 7 days;\n\n    address public immutable operator;\n    address public immutable rewardManager;\n\n    uint256 public immutable pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) internal _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev This is called directly from RewardFactory\n     * @param pid_           Effectively the pool identifier - used in the Booster\n     * @param stakingToken_  Pool LP token\n     * @param rewardToken_   Crv\n     * @param operator_      Booster\n     * @param rewardManager_ RewardFactory\n     */\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) public {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns(bool){\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0),\"!reward setting\");\n        \n        if(extraRewards.length >= 12){\n            return false;\n        }\n        \n        extraRewards.push(_reward);\n        return true;\n    }\n    function clearExtraRewards() external{\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return MathUtil.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount)\n        public \n        returns(bool)\n    {\n        _processStake(_amount, msg.sender);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns(bool){\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount)\n        public\n        returns(bool)\n    {\n        _processStake(_amount, _for);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n        \n        return true;\n    }\n\n    /**\n     * @dev Generic internal staking function that basically does 3 things: update rewards based\n     *      on previous balance, trigger also on any child contracts, then update balances.\n     * @param _amount    Units to add to the users balance\n     * @param _receiver  Address of user who will receive the stake\n     */\n    function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(_receiver, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_receiver] = _balances[_receiver].add(_amount);\n\n        emit Transfer(address(0), _receiver, _amount);\n    }\n\n    function withdraw(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(amount > 0, 'RewardPool : Cannot withdraw 0');\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n     \n        if(claim){\n            getReward(msg.sender,true);\n        }\n\n        emit Transfer(msg.sender, address(0), amount);\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external{\n        withdraw(_balances[msg.sender],claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) public returns(bool){\n        _withdrawAndUnwrapTo(amount, msg.sender, msg.sender);\n        //get rewards too\n        if(claim){\n            getReward(msg.sender,true);\n        }\n        return true;\n    }\n\n    function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(from, amount);\n        }\n        \n        _totalSupply = _totalSupply.sub(amount);\n        _balances[from] = _balances[from].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid,amount,receiver);\n        emit Withdrawn(from, amount);\n\n        emit Transfer(from, address(0), amount);\n\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external{\n        withdrawAndUnwrap(_balances[msg.sender],claim);\n    }\n\n    /**\n     * @dev Gives a staker their rewards, with the option of claiming extra rewards\n     * @param _account     Account for which to claim\n     * @param _claimExtras Get the child rewards too?\n     */\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Called by a staker to get their allocated rewards\n     */\n    function getReward() external returns(bool){\n        getReward(msg.sender,true);\n        return true;\n    }\n\n    /**\n     * @dev Processes queued rewards in isolation, providing the period has finished.\n     *      This allows a cheaper way to trigger rewards on low value pools.\n     */\n    function processIdleRewards() external {\n        if (block.timestamp >= periodFinish && queuedRewards > 0) {\n            notifyRewardAmount(queuedRewards);\n            queuedRewards = 0;\n        }\n    }\n\n    /**\n     * @dev Called by the booster to allocate new Crv rewards to this pool\n     *      Curve is queued for rewards and the distribution only begins once the new rewards are sufficiently\n     *      large, or the epoch has ended.\n     */\n    function queueNewRewards(uint256 _rewards) external returns(bool){\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if(queuedRatio < newRewardRatio){\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        }else{\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    },
    {
      "filename": "contracts/contracts/VirtualBalanceRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: VirtualBalanceRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/MathUtil.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\nabstract contract VirtualBalanceWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IDeposit public immutable deposits;\n\n    constructor(address deposit_) internal {\n        deposits = IDeposit(deposit_);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return deposits.totalSupply();\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits.balanceOf(account);\n    }\n}\n\n/**\n * @title   VirtualBalanceRewardPool\n * @author  ConvexFinance\n * @notice  Reward pool used for ExtraRewards in Booster lockFees (3crv) and\n *          Extra reward stashes\n * @dev     The rewards are sent to this contract for distribution to stakers. This\n *          contract does not hold any of the staking tokens it just maintains a virtual\n *          balance of what a user has staked in the staking pool (BaseRewardPool).\n *          For example the Booster sends veCRV fees (3Crv) to a VirtualBalanceRewardPool\n *          which tracks the virtual balance of cxvCRV stakers and distributes their share\n *          of 3Crv rewards\n */\ncontract VirtualBalanceRewardPool is VirtualBalanceWrapper {\n    using SafeERC20 for IERC20;\n    \n    IERC20 public immutable rewardToken;\n    uint256 public constant duration = 7 days;\n\n    address public immutable operator;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(uint256 => uint256) public epochRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    /**\n     * @param deposit_  Parent deposit pool e.g cvxCRV staking in BaseRewardPool\n     * @param reward_   The rewards token e.g 3Crv\n     * @param op_       Operator contract (Booster)\n     */\n    constructor(\n        address deposit_,\n        address reward_,\n        address op_\n    ) public VirtualBalanceWrapper(deposit_) {\n        rewardToken = IERC20(reward_);\n        operator = op_;\n    }\n\n\n    /**\n     * @notice Update rewards earned by this account\n     */\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return MathUtil.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    /**\n     * @notice  Update reward, emit, call linked reward's stake\n     * @dev     Callable by the deposits address which is the BaseRewardPool\n     *          this updates the virtual balance of this user as this contract doesn't\n     *          actually hold any staked tokens it just diributes reward tokens\n     */\n    function stake(address _account, uint256 amount)\n        external\n        updateReward(_account)\n    {\n        require(msg.sender == address(deposits), \"!authorized\");\n       // require(amount > 0, 'VirtualDepositRewardPool: Cannot stake 0');\n        emit Staked(_account, amount);\n    }\n\n    /**\n     * @notice  Withdraw stake and update reward, emit, call linked reward's stake\n     * @dev     See stake\n     */\n    function withdraw(address _account, uint256 amount)\n        public\n        updateReward(_account)\n    {\n        require(msg.sender == address(deposits), \"!authorized\");\n        //require(amount > 0, 'VirtualDepositRewardPool : Cannot withdraw 0');\n\n        emit Withdrawn(_account, amount);\n    }\n\n    /**\n     * @notice  Get rewards for this account\n     * @dev     This can be called directly but it is usually called by the\n     *          BaseRewardPool getReward when the BaseRewardPool loops through\n     *          it's extraRewards array calling getReward on all of them\n     */\n    function getReward(address _account) public updateReward(_account){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            emit RewardPaid(_account, reward);\n        }\n    }\n\n    function getReward() external{\n        getReward(msg.sender);\n    }\n    /**\n     * @dev Processes queued rewards in isolation, providing the period has finished.\n     *      This allows a cheaper way to trigger rewards on low value pools.\n     */\n    function processIdleRewards() external {\n        if (block.timestamp >= periodFinish && queuedRewards > 0) {\n            notifyRewardAmount(queuedRewards);\n            queuedRewards = 0;\n        }\n    }\n    function queueNewRewards(uint256 _rewards) external{\n        require(msg.sender == operator, \"!authorized\");\n\n        uint256 epoch = block.timestamp.div(duration);\n        epochRewards[epoch] = epochRewards[epoch].add(_rewards);\n        if(epochRewards[epoch] > 1e31) {\n          return;\n        }\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if(queuedRatio < newRewardRatio){\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        }else{\n            queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    }
  ]
}