{
  "Title": "M-7: The 1-second overlap between the during- and after-allocation periods may cause funds to become stuck, permanently.",
  "Content": "# Issue M-7: The 1-second overlap between the during- and after-allocation periods may cause funds to become stuck, permanently. \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/261 \n\n## Found by \nalexxander, jkoppel, shirochan\nThere is a 1-second overlap between the  during- and after-allocation periods of both the QV strategy and the DonationVotingMerkle strategies. In the QV strategy, this can lead to funds permanently becoming stuck.\n\n## Vulnerability Detail\n\n1. A QVSimpleStrategy pool is created. Alice is the Pool manager. 10 people are given voting rights. The pool is funded for 100k USDC.\n2. Everyone except Bob votes, giving Carol and Dan each 50% of the votes.\n3. Carol tells Alice she really needs the money, and asks her to distribute ASAP. Alice schedules a distribute() transaction to occur the moment allocation ends.\n4. At the last minute, the Bob votes, casting all his votes for Carol.\n5. It so happens that Alice and Bob's transaction occur in the same block. Further, it so happens that this block is scheduled with block.timestamp exactly equal to `allocationEndTime`. (Note that, other some comments talk about the registration and allocation period times being in milliseconds, they are actually in seconds.)\n6. For this second, both `onlyActiveAllocation` and `onlyAfterAllocation` pass\n7.  Bob's vote gets scheduled within the block after the call to distribute()\n8. The call to distribute gives 50% of the funds to Carol, or 50k USDC. Bob's vote changes  the total so that 55% of votes are for Carol, and 45% for Dan.\n9. Dan can now be given his $45k. But the remaining $5k is stuck in the pool forever.\n\nIf there is one block every 40 seconds, then there is a 2.5% chance that a block will run on the exact second of overlap. However, the contest page says it should run on any EVM-compatible chain. If there is a rollup that has blocks every second, then the conditions for this bug to occur has a 100% chance\n\nIf there is collusion from the miner, then there is also a significantly higher chance.\n\n## Impact\n\nA chance of permanent loss of funds\n\n## Code Snippet\n\nWhen `block.timestamp == allocationEndTime`, then both _checkOnlyAfterRegistration and _checkOnlyActiveAllocation pass.\n\nI am guessing that the protocol authors thought `block.timestamp` was in milliseconds, when it is actually in seconds. That makes this problem 1000x more likely to occur  without miner collusion.\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol#L317C1-L328C6\n\n```solidity\n   function _checkOnlyActiveAllocation() internal view virtual {\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    function _checkOnlyAfterAllocation() internal view virtual {\n        if (block.timestamp < allocationEndTime) revert ALLOCATION_NOT_ENDED();\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Don't have this 1-second overlap\n2. Add a withdraw function to QVBaseStrategy\n\n\n\n## Discussion\n\n**jack-the-pug**\n\n@neeksec  https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/656 is a dup of this.\n\n**jack-the-pug**\n\nFixed: https://github.com/allo-protocol/allo-v2/pull/337\n\n**neeksec**\n\n@Evert0x \n\nI agree with @jack-the-pug 's https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/261#issuecomment-1778751023. #656 should be a dup of this one.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title QVBaseStrategy\n/// @notice Base strategy for quadratic voting strategies\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\nabstract contract QVBaseStrategy is BaseStrategy {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId ID of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender, Status status);\n\n    /// @notice Emitted when a recipient is registered\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(address indexed recipientId, Status status, address sender);\n    /// @notice Emitted when the pool timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when a recipient receives votes\n    /// @param recipientId ID of the recipient\n    /// @param votes The votes allocated to the recipient\n    /// @param allocator The allocator assigning the votes\n    event Allocated(address indexed recipientId, uint256 votes, address allocator);\n\n    /// @notice Emitted when a recipient is reviewed\n    /// @param recipientId ID of the recipient\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event Reviewed(address indexed recipientId, Status status, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    // slot 0\n    /// @notice The total number of votes cast for all recipients\n    uint256 public totalRecipientVotes;\n\n    // slot 1\n    /// @notice The number of votes required to review a recipient\n    uint256 public reviewThreshold;\n\n    // slot 2\n    /// @notice The start and end times for registrations and allocations\n    /// @dev The values will be in milliseconds since the epoch\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    // slot 3\n    /// @notice Whether or not the strategy is using registry gating\n    bool public registryGating;\n\n    /// @notice Whether or not the strategy requires metadata\n    bool public metadataRequired;\n\n    /// @notice The registry contract\n    IRegistry private _registry;\n\n    // slots [4...n]\n    /// @notice The status of the recipient for this strategy only\n    /// @dev There is a core `IStrategy.RecipientStatus` that this should map to\n    enum InternalRecipientStatus {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed\n    }\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParams {\n        // slot 0\n        bool registryGating;\n        bool metadataRequired;\n        // slot 1\n        uint256 reviewThreshold;\n        // slot 2\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n    }\n\n    /// @notice The details of the recipient\n    struct Recipient {\n        // slot 0\n        uint256 totalVotesReceived;\n        // slot 1\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n        Status recipientStatus;\n    }\n\n    /// @notice The details of the allocator\n    struct Allocator {\n        // slot 0\n        uint256 voiceCredits;\n        // slots [1...n]\n        mapping(address => uint256) voiceCreditsCastToRecipient;\n        mapping(address => uint256) votesCastToRecipient;\n    }\n\n    /// @notice The details of the recipient are returned using their ID\n    /// @dev recipientId => Recipient\n    mapping(address => Recipient) public recipients;\n\n    /// @notice The details of the allocator are returned using their address\n    /// @dev allocator address => Allocator\n    mapping(address => Allocator) public allocators;\n\n    /// @notice Returns whether or not the recipient has been paid out using their ID\n    /// @dev recipientId => paid out\n    mapping(address => bool) public paidOut;\n\n    // recipientId -> status -> count\n    mapping(address => mapping(Status => uint256)) public reviewsByStatus;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev Reverts if the registration is not active\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ====================================\n    /// =========== Initialize =============\n    /// ====================================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    function initialize(uint256 _poolId, bytes memory _data) external virtual;\n\n    /// @notice Internal initialize function\n    /// @param _poolId The ID of the pool\n    /// @param _params The initialize params for the strategy\n    function __QVBaseStrategy_init(uint256 _poolId, InitializeParams memory _params) internal {\n        __BaseStrategy_init(_poolId);\n\n        registryGating = _params.registryGating;\n        metadataRequired = _params.metadataRequired;\n        _registry = allo.getRegistry();\n\n        reviewThreshold = _params.reviewThreshold;\n\n        _updatePoolTimestamps(\n            _params.registrationStartTime,\n            _params.registrationEndTime,\n            _params.allocationStartTime,\n            _params.allocationEndTime\n        );\n    }\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Get recipient status\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view virtual override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Checks if a pool is active or not\n    /// @return Whether the pool is active or not\n    function _isPoolActive() internal view virtual override returns (bool) {\n        if (registrationStartTime <= block.timestamp && block.timestamp <= registrationEndTime) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Review recipient(s) application(s)\n    /// @dev You can review multiple recipients at once or just one. This can only be called by a pool manager and\n    ///      only during active registration.\n    /// @param _recipientIds Ids of the recipients\n    /// @param _recipientStatuses Statuses of the recipients\n    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n        external\n        virtual\n        onlyPoolManager(msg.sender)\n        onlyActiveRegistration\n    {\n        // make sure the arrays are the same length\n        uint256 recipientLength = _recipientIds.length;\n        if (recipientLength != _recipientStatuses.length) revert INVALID();\n\n        for (uint256 i; i < recipientLength;) {\n            Status recipientStatus = _recipientStatuses[i];\n            address recipientId = _recipientIds[i];\n\n            // if the status is none or appealed then revert\n            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            reviewsByStatus[recipientId][recipientStatus]++;\n\n            if (reviewsByStatus[recipientId][recipientStatus] >= reviewThreshold) {\n                Recipient storage recipient = recipients[recipientId];\n                recipient.recipientStatus = recipientStatus;\n\n                emit RecipientStatusUpdated(recipientId, recipientStatus, address(0));\n            }\n\n            emit Reviewed(recipientId, recipientStatus, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) external onlyPoolManager(msg.sender) {\n        _updatePoolTimestamps(_registrationStartTime, _registrationEndTime, _allocationStartTime, _allocationEndTime);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Check if the registration is active\n    /// @dev Reverts if the registration is not active\n    function _checkOnlyActiveRegistration() internal view virtual {\n        if (registrationStartTime > block.timestamp || block.timestamp > registrationEndTime) {\n            revert REGISTRATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    function _checkOnlyActiveAllocation() internal view virtual {\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    function _checkOnlyAfterAllocation() internal view virtual {\n        if (block.timestamp < allocationEndTime) revert ALLOCATION_NOT_ENDED();\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function _updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) internal {\n        // validate the timestamps for this strategy\n        if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime\n        ) {\n            revert INVALID();\n        }\n\n        // Set the new values\n        registrationStartTime = _registrationStartTime;\n        registrationEndTime = _registrationEndTime;\n        allocationStartTime = _allocationStartTime;\n        allocationEndTime = _allocationEndTime;\n\n        // emit the event\n        emit TimestampsUpdated(\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\n        );\n    }\n\n    /// @notice Submit application to pool\n    /// @dev The '_data' parameter is encoded as follows:\n    ///     - If registryGating is true, then the data is encoded as (address recipientId, address recipientAddress, Metadata metadata)\n    ///     - If registryGating is false, then the data is encoded as (address recipientAddress, address registryAnchor, Metadata metadata)\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The ID of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        address recipientAddress;\n        address registryAnchor;\n        bool isUsingRegistryAnchor;\n\n        Metadata memory metadata;\n\n        // decode data custom to this strategy\n        if (registryGating) {\n            (recipientId, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\n\n            // when registry gating is enabled, the recipientId must be a profile member\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            (recipientAddress, registryAnchor, metadata) = abi.decode(_data, (address, address, Metadata));\n            isUsingRegistryAnchor = registryAnchor != address(0);\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // when using registry anchor, the ID of the recipient must be a profile member\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // make sure that if metadata is required, it is provided\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        // make sure the recipient address is not the zero address\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        Recipient storage recipient = recipients[recipientId];\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.metadata = metadata;\n        recipient.useRegistryAnchor = registryGating ? true : isUsingRegistryAnchor;\n\n        Status currentStatus = recipient.recipientStatus;\n\n        if (currentStatus == Status.None) {\n            // recipient registering new application\n            recipient.recipientStatus = Status.Pending;\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            if (currentStatus == Status.Accepted) {\n                // recipient updating accepted application\n                recipient.recipientStatus = Status.Pending;\n            } else if (currentStatus == Status.Rejected) {\n                // recipient updating rejected application\n                recipient.recipientStatus = Status.Appealed;\n            }\n\n            // emit the new status with the '_data' that was passed in\n            emit UpdatedRegistration(recipientId, _data, _sender, recipient.recipientStatus);\n        }\n    }\n\n    /// @notice Distribute the tokens to the recipients\n    /// @dev The '_sender' must be a pool manager and the allocation must have ended\n    /// @param _recipientIds The recipient ids\n    /// @param _sender The sender of the transaction\n    function _distribute(address[] memory _recipientIds, bytes memory, address _sender)\n        internal\n        virtual\n        override\n        onlyPoolManager(_sender)\n        onlyAfterAllocation\n    {\n        uint256 payoutLength = _recipientIds.length;\n        for (uint256 i; i < payoutLength;) {\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n\n            PayoutSummary memory payout = _getPayout(recipientId, \"\");\n            uint256 amount = payout.amount;\n\n            if (paidOut[recipientId] || !_isAcceptedRecipient(recipientId) || amount == 0) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            IAllo.Pool memory pool = allo.getPool(poolId);\n            _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n            paidOut[recipientId] = true;\n\n            emit Distributed(recipientId, recipient.recipientAddress, amount, _sender);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Check if sender is a profile member\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return If the '_sender' is a profile member\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Getter for a recipient using the ID\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory) {\n        return recipients[_recipientId];\n    }\n\n    /// ====================================\n    /// ============ QV Helper ==============\n    /// ====================================\n\n    /// @notice Calculate the square root of a number (Babylonian method)\n    /// @param x The number\n    /// @return y The square root\n    function _sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /// @notice Allocate voice credits to a recipient\n    /// @dev This can only be called during active allocation period\n    /// @param _allocator The allocator details\n    /// @param _recipient The recipient details\n    /// @param _recipientId The ID of the recipient\n    /// @param _voiceCreditsToAllocate The voice credits to allocate to the recipient\n    /// @param _sender The sender of the transaction\n    function _qv_allocate(\n        Allocator storage _allocator,\n        Recipient storage _recipient,\n        address _recipientId,\n        uint256 _voiceCreditsToAllocate,\n        address _sender\n    ) internal onlyActiveAllocation {\n        // check the `_voiceCreditsToAllocate` is > 0\n        if (_voiceCreditsToAllocate == 0) revert INVALID();\n\n        // get the previous values\n        uint256 creditsCastToRecipient = _allocator.voiceCreditsCastToRecipient[_recipientId];\n        uint256 votesCastToRecipient = _allocator.votesCastToRecipient[_recipientId];\n\n        // get the total credits and calculate the vote result\n        uint256 totalCredits = _voiceCreditsToAllocate + creditsCastToRecipient;\n        uint256 voteResult = _sqrt(totalCredits * 1e18);\n\n        // update the values\n        voteResult -= votesCastToRecipient;\n        totalRecipientVotes += voteResult;\n        _recipient.totalVotesReceived += voteResult;\n\n        _allocator.voiceCreditsCastToRecipient[_recipientId] += totalCredits;\n        _allocator.votesCastToRecipient[_recipientId] += voteResult;\n\n        // emit the event with the vote results\n        emit Allocated(_recipientId, voteResult, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return If the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view virtual returns (bool);\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return If the allocator is valid\n    function _isValidAllocator(address _allocator) internal view virtual override returns (bool);\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return If the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        virtual\n        returns (bool);\n\n    /// @notice Get the payout for a single recipient\n    /// @param _recipientId The ID of the recipient\n    /// @return The payout as a 'PayoutSummary' struct\n    function _getPayout(address _recipientId, bytes memory)\n        internal\n        view\n        virtual\n        override\n        returns (PayoutSummary memory)\n    {\n        Recipient memory recipient = recipients[_recipientId];\n\n        // Calculate the payout amount based on the percentage of total votes\n        uint256 amount;\n        if (!paidOut[_recipientId] && totalRecipientVotes != 0) {\n            amount = poolAmount * recipient.totalVotesReceived / totalRecipientVotes;\n        }\n        return PayoutSummary(recipient.recipientAddress, amount);\n    }\n}"
    }
  ]
}