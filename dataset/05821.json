{
  "Title": "[L-11] VotiumStrategy allows to recover ERC20 tokens but not native ETH",
  "Content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L215\n\nThe implementation of `withdrawStuckTokens()` allows the owner of the protocol to recover any ERC20 token, but fails to consider native ETH transfers.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-asymmetry",
  "Code": [
    {
      "filename": "contracts/strategies/votium/VotiumStrategyCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../external_interfaces/IWETH.sol\";\nimport \"../../external_interfaces/ISwapRouter.sol\";\nimport \"../../external_interfaces/IVotiumMerkleStash.sol\";\nimport \"../../external_interfaces/ISnapshotDelegationRegistry.sol\";\nimport \"../../external_interfaces/ILockedCvx.sol\";\nimport \"../../external_interfaces/IClaimZap.sol\";\nimport \"../../external_interfaces/ICrvEthPool.sol\";\nimport \"../../external_interfaces/IAfEth.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../external_interfaces/ISafEth.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title Votium Strategy Token internal functions\n/// @author Asymmetry Finance\ncontract VotiumStrategyCore is\n    Initializable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    address public constant SNAPSHOT_DELEGATE_REGISTRY =\n        0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446;\n    address constant CVX_ADDRESS = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address constant VLCVX_ADDRESS = 0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    struct SwapData {\n        address sellToken;\n        address spender;\n        address swapTarget;\n        bytes swapCallData;\n    }\n\n    struct ChainlinkResponse {\n        uint80 roundId;\n        int256 answer;\n        uint256 updatedAt;\n        bool success;\n    }\n\n    uint256 public cvxUnlockObligations;\n    address public rewarder;\n    address public manager;\n\n    AggregatorV3Interface public chainlinkCvxEthFeed;\n    uint256 latestWithdrawId;\n\n    // used to add storage variables in the future\n    uint256[20] private __gap;\n\n    event DepositReward(\n        uint256 indexed newPrice,\n        uint256 indexed ethAmount,\n        uint256 indexed cvxAmount\n    );\n\n    event FailedToSell(address indexed tokenAddress);\n\n    error SwapFailed(uint256 index);\n    error ChainlinkFailed();\n    error NotRewarder();\n    error InvalidLockedAmount();\n    error NotOwner();\n    error WithdrawNotReady();\n    error AlreadyWithdrawn();\n\n    /**\n        @notice - Sets the address for the chainlink feed\n        @param _cvxEthFeedAddress - Address of the chainlink feed\n    */\n    function setChainlinkCvxEthFeed(\n        address _cvxEthFeedAddress\n    ) public onlyOwner {\n        chainlinkCvxEthFeed = AggregatorV3Interface(_cvxEthFeedAddress);\n    }\n\n    modifier onlyRewarder() {\n        if (msg.sender != rewarder) revert NotRewarder();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - Address of the owner of the contract (asym multisig)\n        @param _rewarder - Address of the rewarder contract (reward oracle)\n        @param _manager - Address of the manager contract (afEth)\n    */\n    function initialize(\n        address _owner,\n        address _rewarder,\n        address _manager\n    ) external initializer {\n        bytes32 VotiumVoteDelegationId = 0x6376782e65746800000000000000000000000000000000000000000000000000;\n        address DelegationRegistry = 0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446;\n        address votiumVoteProxyAddress = 0xde1E6A7ED0ad3F61D531a8a78E83CcDdbd6E0c49;\n        ISnapshotDelegationRegistry(DelegationRegistry).setDelegate(\n            VotiumVoteDelegationId,\n            votiumVoteProxyAddress\n        );\n        rewarder = _rewarder;\n        manager = _manager;\n        __ERC20_init(\"Votium AfEth Strategy\", \"vAfEth\");\n        _transferOwnership(_owner);\n        chainlinkCvxEthFeed = AggregatorV3Interface(\n            0xC9CbF687f43176B302F03f5e58470b77D07c61c6\n        );\n    }\n\n    /**\n     * @notice - Function to set the address of the rewarder account that periodically claims rewards\n     * @param _rewarder - Address of the rewarder account\n     */\n    function setRewarder(address _rewarder) external onlyOwner {\n        rewarder = _rewarder;\n    }\n\n    /**\n     * @notice - The amount of cvx in the entire system\n     * @return - Amount of cvx in the entire system\n     */\n    function cvxInSystem() public view returns (uint256) {\n        (uint256 total, , , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        return total + IERC20(CVX_ADDRESS).balanceOf(address(this));\n    }\n\n    /**\n     * @notice - Gets price of afEth in cvx\n     * @return - Price of afEth in cvx\n     */\n    function cvxPerVotium() public view returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 totalCvx = cvxInSystem();\n        if (supply == 0 || totalCvx == 0) return 1e18;\n        return ((totalCvx - cvxUnlockObligations) * 1e18) / supply;\n    }\n\n    /**\n        @notice - Eth per cvx (chainlink)\n        @param _validate - Whether or not to validate the chainlink response\n        @return - Price of cvx in eth\n     */\n    function ethPerCvx(bool _validate) public view returns (uint256) {\n        ChainlinkResponse memory cl;\n        try chainlinkCvxEthFeed.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        ) {\n            cl.success = true;\n            cl.roundId = roundId;\n            cl.answer = answer;\n            cl.updatedAt = updatedAt;\n        } catch {\n            cl.success = false;\n        }\n        // verify chainlink response\n        if (\n            (!_validate ||\n                (cl.success == true &&\n                    cl.roundId != 0 &&\n                    cl.answer >= 0 &&\n                    cl.updatedAt != 0 &&\n                    cl.updatedAt <= block.timestamp &&\n                    block.timestamp - cl.updatedAt <= 25 hours))\n        ) {\n            return uint256(cl.answer);\n        } else {\n            revert ChainlinkFailed();\n        }\n    }\n\n    /**\n     * @notice Allow rewarder oracle account to claim rewards\n     * @param _claimProofs - Array of claim proofs\n     */\n    function claimRewards(\n        IVotiumMerkleStash.ClaimParam[] calldata _claimProofs\n    ) public onlyRewarder {\n        claimVotiumRewards(_claimProofs);\n        claimVlCvxRewards();\n    }\n\n    /**\n     * @notice - Sells amount of eth from votium contract\n     * @dev - Puts it into safEthStrategy or votiumStrategy, whichever is underweight.\n     *  */\n    function depositRewards(uint256 _amount) public payable {\n        uint256 cvxAmount = buyCvx(_amount);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        emit DepositReward(cvxPerVotium(), _amount, cvxAmount);\n    }\n\n    /**\n     * @notice - Allows owner to withdraw any stuck erc20 tokens\n     * @dev - Lets us handle any that were not successfully sold via cvx\n     * @param _token - Address of the token to withdraw\n     */\n    function withdrawStuckTokens(address _token) public onlyOwner {\n        IERC20(_token).transfer(\n            msg.sender,\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice - Internal utility function to buy cvx using eth\n     * @param _ethAmountIn - Amount of eth to spend\n     * @return cvxAmountOut - Amount of cvx bought\n     */\n    function buyCvx(\n        uint256 _ethAmountIn\n    ) internal returns (uint256 cvxAmountOut) {\n        address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n        // eth -> cvx\n        uint256 cvxBalanceBefore = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying{\n            value: _ethAmountIn\n        }(\n            0,\n            1,\n            _ethAmountIn,\n            0 // this is handled at the afEth level\n        );\n        uint256 cvxBalanceAfter = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        cvxAmountOut = cvxBalanceAfter - cvxBalanceBefore;\n    }\n\n    /**\n     * @notice - Internal utility function to sell cvx for eth\n     * @param _cvxAmountIn - Amount of cvx to sell\n     * @return ethAmountOut - Amount of eth received\n     */\n    function sellCvx(\n        uint256 _cvxAmountIn\n    ) internal returns (uint256 ethAmountOut) {\n        address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n        // cvx -> eth\n        uint256 ethBalanceBefore = address(this).balance;\n        IERC20(CVX_ADDRESS).approve(CVX_ETH_CRV_POOL_ADDRESS, _cvxAmountIn);\n\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying(\n            1,\n            0,\n            _cvxAmountIn,\n            0 // this is handled at the afEth level\n        );\n        ethAmountOut = address(this).balance - ethBalanceBefore;\n    }\n\n    /**\n     * @notice - Function for rewarder to sell all claimed token rewards and buy & lock more cvx\n     * @dev - Causes price to go up\n     * @param _swapsData - Array of SwapData for 0x swaps\n     */\n    function applyRewards(SwapData[] calldata _swapsData) public onlyRewarder {\n        uint256 ethBalanceBefore = address(this).balance;\n        for (uint256 i = 0; i < _swapsData.length; i++) {\n            // Some tokens do not allow approval if allowance already exists\n            uint256 allowance = IERC20(_swapsData[i].sellToken).allowance(\n                address(this),\n                address(_swapsData[i].spender)\n            );\n            if (allowance != type(uint256).max) {\n                if (allowance > 0) {\n                    IERC20(_swapsData[i].sellToken).approve(\n                        address(_swapsData[i].spender),\n                        0\n                    );\n                }\n                IERC20(_swapsData[i].sellToken).approve(\n                    address(_swapsData[i].spender),\n                    type(uint256).max\n                );\n            }\n            (bool success, ) = _swapsData[i].swapTarget.call(\n                _swapsData[i].swapCallData\n            );\n            if (!success) {\n                emit FailedToSell(_swapsData[i].sellToken);\n            }\n        }\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        if (address(manager) != address(0))\n            IAfEth(manager).depositRewards{value: ethReceived}(ethReceived);\n        else depositRewards(ethReceived);\n    }\n\n    /**\n     * @notice - Internal utility function to claim votium reward tokens\n     * @param _claimProofs - Array of claim proofs\n     */\n    function claimVotiumRewards(\n        IVotiumMerkleStash.ClaimParam[] calldata _claimProofs\n    ) private {\n        IVotiumMerkleStash(0x378Ba9B73309bE80BF4C2c027aAD799766a7ED5A)\n            .claimMulti(address(this), _claimProofs);\n    }\n\n    /**\n     * @notice - Internal utility function to claim vlCvx reward tokens\n     */\n    function claimVlCvxRewards() private {\n        address[] memory emptyArray;\n        IClaimZap(0x3f29cB4111CbdA8081642DA1f75B3c12DECf2516).claimRewards(\n            emptyArray,\n            emptyArray,\n            emptyArray,\n            emptyArray,\n            0,\n            0,\n            0,\n            0,\n            8\n        );\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}