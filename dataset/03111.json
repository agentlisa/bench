{
  "Title": "Invalid Beneficiary",
  "Content": "The [`setPaymentDelegation` function](https://github.com/celo-org/celo-monorepo/blob/0fea04630b9c7d4920b0fbe0ffe53e3438a0e9db/packages/protocol/contracts/common/Accounts.sol#L327) of the `Accounts` contract allows a validator to set the zero address as their beneficiary with a non-zero payment fraction. In this scenario, the reward distribution mechanism will [attempt to mint](https://github.com/celo-org/celo-monorepo/blob/0fea04630b9c7d4920b0fbe0ffe53e3438a0e9db/packages/protocol/contracts/governance/Validators.sol#L528) tokens to the zero address, which [will revert](https://github.com/celo-org/celo-monorepo/blob/0fea04630b9c7d4920b0fbe0ffe53e3438a0e9db/packages/protocol/contracts/stability/StableToken.sol#L248). Consequently, neither the validator nor their group will receive the epoch payment.\n\n\nConsider preventing validators from setting a zero beneficiary with a non-zero payment fraction. Additionally, in the interest of clearly signaling user intentions, consider introducing a `deletePaymentDelegation` function so the `setPaymentDelegation` function can disallow any zero beneficiary.\n\n\n***Update:** Fixed in [pull request #9283](https://github.com/celo-org/celo-monorepo/pull/9283).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Accounts.sol",
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 3, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender), \"Account exists\");\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length);\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return List of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength += offchainStorageRoots[account][i].length;\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of vaidator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidyLib value. Must not\n   * be greater than 1.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Not an account\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @return Beneficiary address and fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Not an account\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`  \n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account. \n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(isAccount(account), \"Unknown account\");\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or \n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer \n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and \n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"not an account\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Not an account\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and \n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and \n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role. \n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(add"
    }
  ]
}