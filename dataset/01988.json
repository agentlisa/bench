{
  "Title": "A transaction doesn't have the sequence information",
  "Content": "##### Description\n\nIn case of multiple transactions are approved any owner is able to choose the sequense of transactions. In some cases this owner can extract additional benefits from choosing the ordering.\n\nIn addition, transactions allow only one target call per transaction - it may be not enough for DeFi interactions. Complex DeFi interactions require making a few approved transactions, so benefits from sequencing can arise.\n\n- https://github.com/cloudwalk/brlc-multisig/blob/b5d6c2b6273162d5666d48649890b15a113df7a7/contracts/base/IMultiSigWallet.sol#L11-L18\n- https://github.com/cloudwalk/brlc-multisig/blob/b5d6c2b6273162d5666d48649890b15a113df7a7/contracts/base/MultiSigWalletBase.sol#L378\n\n##### Recommendation\n\nWe recommend adding the nonce information in transactions and allowing a list of targets.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/base/IMultiSigWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\n/**\n * @title MultiSigWallet types interface\n * @author CloudWalk Inc.\n */\ninterface IMultiSigWalletTypes {\n    /// @dev Structure with data of a single transaction.\n    struct Transaction {\n        address to;         // The address of the transaction receiver.\n        bool executed;      // The execution status of the transaction. True if executed.\n        uint128 cooldown;   // The timestamp before which the transaction cannot be executed.\n        uint128 expiration; // The timestamp after which the transaction cannot be executed.\n        uint256 value;      // The value in native tokens to be sent along with the transaction.\n        bytes data;         // The data to be sent along with the transaction.\n    }\n}\n\n/**\n * @title MultiSigWallet interface\n * @author CloudWalk Inc.\n * @dev The interface of the multi-signature wallet contract.\n */\ninterface IMultiSigWallet is IMultiSigWalletTypes {\n    // --------------------------- Events ---------------------------\n\n    /**\n     * @dev Emitted when native tokens are deposited to the contract.\n     * @param sender The address of the native tokens sender.\n     * @param amount The amount of deposited native tokens.\n     */\n    event Deposit(address indexed sender, uint256 amount);\n\n    /**\n     * @dev Emitted when a new transaction is submitted.\n     * @param owner The address that submitted the transaction.\n     * @param txId The Id of the transaction that is submitted.\n     */\n    event Submit(address indexed owner, uint256 indexed txId);\n\n    /**\n     * @dev Emitted when a transaction is approved.\n     * @param owner The address that approved the transaction.\n     * @param txId The Id of the transaction that is approved.\n     */\n    event Approve(address indexed owner, uint256 indexed txId);\n\n    /**\n     * @dev Emitted when a transaction approval is revoked.\n     * @param owner The address that revoked the transaction approval.\n     * @param txId The Id of the transaction whose approval is revoked.\n     */\n    event Revoke(address indexed owner, uint256 indexed txId);\n\n    /**\n     * @dev Emitted when a transaction is executed.\n     * @param owner The address that executed the transaction.\n     * @param txId The Id of the transaction that is executed.\n     */\n    event Execute(address indexed owner, uint256 indexed txId);\n\n    /**\n     * @dev Emitted when wallet owners are configured.\n     * @param newOwners The array of addresses that became the wallet owners.\n     * @param newRequiredApprovals The new number of approvals required to execute a transaction.\n     */\n    event ConfigureOwners(address[] newOwners, uint256 newRequiredApprovals);\n\n    /**\n     * @dev Emitted when a transaction expiration time is configured.\n     * @param newExpirationTime The new value of the expiration time.\n     */\n    event ConfigureExpirationTime(uint256 newExpirationTime);\n\n    /**\n     * @dev Emitted when a transaction cooldown time is configured.\n     * @param newCooldownTime The new value of the cooldown time.\n     */\n    event ConfigureCooldownTime(uint256 newCooldownTime);\n\n    // ------------------------- Functions --------------------------\n\n    /**\n     * @dev Submits a new transaction.\n     *\n     * Emits a {Submit} event.\n     *\n     * @param to The address of the transaction receiver.\n     * @param value The value of the transaction in native tokens.\n     * @param data The input data of the transaction.\n     */\n    function submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Submits and approves a new transaction.\n     *\n     * Emits a {Submit} event.\n     * Emits an {Approve} event.\n     *\n     * @param to The address of the transaction receiver.\n     * @param value The value of the transaction in native tokens.\n     * @param data The input data of the transaction.\n     */\n    function submitAndApprove(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Approves a previously submitted transaction.\n     *\n     * Emits an {Approve} event.\n     *\n     * @param txId The Id of the transaction to approve.\n     */\n    function approve(uint256 txId) external;\n\n    /**\n     * @dev Approves and executes a previously submitted transaction.\n     *\n     * Emits an {Approve} event.\n     * Emits an {Execute} event.\n     *\n     * @param txId The Id of the transaction to approve and execute.\n     */\n    function approveAndExecute(uint256 txId) external;\n\n    /**\n     * @dev Executes a previously submitted transaction.\n     *\n     * Emits an {Execute} event.\n     *\n     * @param txId The Id of the transaction to execute.\n     */\n    function execute(uint256 txId) external;\n\n    /**\n     * @dev Revokes a previously approved status of a transaction.\n     *\n     * Emits a {Revoke} event.\n     *\n     * @param txId The Id of the transaction to revoke the approved status.\n     */\n    function revoke(uint256 txId) external;\n\n    /**\n     * @dev Configures wallet owners.\n     *\n     * Emits a {ConfigureOwners} event.\n     *\n     * @param newOwners The array of addresses to become the wallet owners.\n     * @param newRequiredApprovals The new number of approvals required to execute a transaction.\n     */\n    function configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) external;\n\n    /**\n     * @dev Configures the expiration time that will be applied to new transactions.\n     *\n     * Emits a {ConfigureExpirationTime} event.\n     *\n     * @param newExpirationTime The new value of the expiration time.\n     */\n    function configureExpirationTime(uint120 newExpirationTime) external;\n\n    /**\n     * @dev Configures the cooldown time that will be applied to new transactions.\n     *\n     * Emits a {ConfigureCooldownTime} event.\n     *\n     * @param newCooldownTime The new value of the cooldown time.\n     */\n    function configureCooldownTime(uint120 newCooldownTime) external;\n\n    /**\n     * @dev Returns the number of approvals for a transaction.\n     * @param txId The Id of the transaction to check.\n     */\n    function getApprovalCount(uint256 txId) external view returns (uint256);\n\n    /**\n     * @dev Returns the approval status of a transaction.\n     * @param txId The Id of the transaction to check.\n     * @param owner The address of the wallet owner to check.\n     * @return True if the transaction is approved.\n     */\n    function getApprovalStatus(uint256 txId, address owner) external view returns (bool);\n\n    /**\n     * @dev Returns a single transaction.\n     * @param txId The Id of the transaction to return.\n     */\n    function getTransaction(uint256 txId) external view returns (Transaction memory);\n\n    /**\n     * @dev Returns an array of transactions.\n     * @param txId The Id of the first transaction in the range to return.\n     * @param limit The maximum number of transactions in the range to return.\n     */\n    function getTransactions(uint256 txId, uint256 limit) external view returns (Transaction[] memory);\n\n    /**\n     * @dev Returns an array of wallet owners.\n     */\n    function owners() external view returns (address[] memory);\n\n    /**\n     * @dev Checks if an account is configured as a wallet owner.\n     */\n    function isOwner(address account) external view returns (bool);\n\n    /**\n     * @dev Returns the number of approvals required to execute a transaction.\n     */\n    function requiredApprovals() external view returns (uint256);\n\n    /**\n     * @dev Returns the total number of transactions in the wallet.\n     */\n    function transactionCount() external view returns (uint256);\n\n    /**\n     * @dev Returns the configured expiration time.\n     */\n    function expirationTime() external view returns (uint120);\n\n    /**\n     * @dev Returns the configured cooldown time.\n     */\n    function cooldownTime() external view returns (uint120);\n}"
    },
    {
      "filename": "contracts/base/MultiSigWalletBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IMultiSigWallet } from \"./IMultiSigWallet.sol\";\nimport { MultiSigWalletStorage } from \"./MultiSigWalletStorage.sol\";\n\n/**\n * @title MultiSigWalletBase contract\n * @author CloudWalk Inc.\n * @dev The base of the multi-signature wallet contract.\n */\nabstract contract MultiSigWalletBase is MultiSigWalletStorage, IMultiSigWallet {\n    // --------------------------- Errors ---------------------------\n\n    /// @dev An unauthorized account called a function.\n    error UnauthorizedCaller();\n\n    /// @dev A transaction with the specified Id does not exist.\n    error TransactionNotExist();\n\n    /// @dev A transaction with the specified Id is already executed.\n    error TransactionAlreadyExecuted();\n\n    /// @dev A transaction with the specified Id must be approved by the caller.\n    error TransactionNotApproved();\n\n    /// @dev A transaction with the specified Id is already approved by the caller.\n    error TransactionAlreadyApproved();\n\n    /// @dev An empty array of addresses was passed when configuring the wallet owners.\n    error EmptyOwnersArray();\n\n    /// @dev The zero address was passed within the owners array when configuring the wallet owners.\n    error ZeroOwnerAddress();\n\n    /// @dev A duplicate address was passed within the owners array when configuring the wallet owners.\n    error DuplicateOwnerAddress();\n\n    /// @dev An invalid number of required approvals was passed when configuring the wallet owners.\n    error InvalidRequiredApprovals();\n\n    /// @dev The number of approvals for a given transaction is less than the required minimum.\n    error NotEnoughApprovals();\n\n    /// @dev A low level call/transaction to the transaction receiver failed.\n    error InternalTransactionFailed(bytes data);\n\n    /// @dev A transaction with the specified Id has already expired.\n    error TransactionExpired();\n\n    /// @dev A transaction with the specified Id is on cooldown.\n    error CooldownNotEnded();\n\n    // ------------------------- Modifiers --------------------------\n\n    /**\n     * @dev Throws if called by any account other than a wallet owner.\n     */\n    modifier onlyOwner() {\n        if (!_isOwner[msg.sender]) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the contract itself.\n     */\n    modifier onlySelfCall() {\n        if (msg.sender != address(this)) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    // ------------------------- Functions --------------------------\n\n    /**\n     * @dev Called when native tokens are sent to the contract.\n     *\n     * Emits a {Deposit} event.\n     */\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submit}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _submit(to, value, data);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submitAndApprove}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submitAndApprove(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _approve(_submit(to, value, data));\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approve}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be already approved by the caller.\n     */\n    function approve(uint256 txId) external onlyOwner {\n        _approve(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approveAndExecute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must not be already approved by the caller.\n     * - The transaction with the given Id must have at least the required number of approvals minus one.\n     */\n    function approveAndExecute(uint256 txId) external onlyOwner {\n        _approve(txId);\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-execute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must have at least the required number of approvals.\n     */\n    function execute(uint256 txId) external onlyOwner {\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-revoke}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must be approved by the caller.\n     */\n    function revoke(uint256 txId) external onlyOwner {\n        _revoke(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureOwners}\n     *\n     * Requirements:\n     *\n     * - The array of wallet owners must not be empty.\n     * - The number of required approvals must not be zero and must not exceed the length of the wallet owners array.\n     */\n    function configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) external onlySelfCall {\n        _configureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureExpirationTime}\n     */\n    function configureExpirationTime(uint120 newExpirationTime) external onlySelfCall {\n        _configureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureCooldownTime}\n     */\n    function configureCooldownTime(uint120 newCooldownTime) external onlySelfCall {\n        _configureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalCount}.\n     */\n    function getApprovalCount(uint256 txId) external view returns (uint256) {\n        return _approvalCount[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalStatus}.\n     */\n    function getApprovalStatus(uint256 txId, address owner) external view returns (bool) {\n        return _approvalStatus[txId][owner];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransaction}.\n     */\n    function getTransaction(uint256 txId) external view returns (Transaction memory) {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        return _transactions[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransactions}.\n     *\n     * The total number of returned transactions will not exceed the provided limit, but may be less.\n     * The function will return an empty array if there is no transaction with the given Id or if the limit is zero.\n     * The empty transaction array will be returned if the transaction with the provided Id does not exist or the\n     * provided limit is zero.\n     */\n    function getTransactions(uint256 txId, uint256 limit) external view returns (Transaction[] memory txs) {\n        uint256 len = _transactions.length;\n        if (len <= txId || limit == 0) {\n            txs = new Transaction[](0);\n        } else {\n            len -= txId;\n            if (len > limit) {\n                len = limit;\n            }\n            txs = new Transaction[](len);\n            for (uint256 i = 0; i < len; i++) {\n                txs[i] = _transactions[txId];\n                txId++;\n            }\n        }\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-owners}.\n     */\n    function owners() external view returns (address[] memory) {\n        return _owners;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-isOwner}.\n     */\n    function isOwner(address account) external view returns (bool) {\n        return _isOwner[account];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-requiredApprovals}.\n     */\n    function requiredApprovals() external view returns (uint256) {\n        return _requiredApprovals;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-transactionCount}.\n     */\n    function transactionCount() external view returns (uint256) {\n        return _transactions.length;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-expirationTime}.\n     */\n    function expirationTime() external view returns (uint120) {\n        return _expirationTime;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-cooldownTime}.\n     */\n    function cooldownTime() external view returns (uint120) {\n        return _cooldownTime;\n    }\n\n    /**\n     * @dev See {MultiSigWallet-submit}.\n     */\n    function _submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) internal returns (uint256 txId) {\n        uint128 blockTimestamp = toUint128(block.timestamp);\n\n        _transactions.push(\n            Transaction({\n                to: to,\n                executed: false,\n                cooldown: blockTimestamp + _cooldownTime,\n                expiration: blockTimestamp + _cooldownTime + _expirationTime,\n                value: value,\n                data: data\n            })\n        );\n\n        txId = _transactions.length - 1;\n\n        emit Submit(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-approve}.\n     */\n    function _approve(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (_approvalStatus[txId][msg.sender]) {\n            revert TransactionAlreadyApproved();\n        }\n\n        Transaction memory transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] += 1;\n        _approvalStatus[txId][msg.sender] = true;\n\n        emit Approve(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-execute}.\n     */\n    function _execute(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.cooldown > block.timestamp) {\n            revert CooldownNotEnded();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n        if (_approvalCount[txId] < _requiredApprovals) {\n            revert NotEnoughApprovals();\n        }\n\n        transaction.executed = true;\n\n        emit Execute(msg.sender, txId);\n\n        (bool success, bytes memory data) = transaction.to.call{ value: transaction.value }(transaction.data);\n        if (!success) {\n            revert InternalTransactionFailed(data);\n        }\n    }\n\n    /**\n     * @dev See {MultiSigWallet-revoke}.\n     */\n    function _revoke(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (!_approvalStatus[txId][msg.sender]) {\n            revert TransactionNotApproved();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] -= 1;\n        _approvalStatus[txId][msg.sender] = false;\n\n        emit Revoke(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureOwners}.\n     */\n    function _configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) internal {\n        if (newOwners.length == 0) {\n            revert EmptyOwnersArray();\n        }\n        if (newRequiredApprovals == 0) {\n            revert InvalidRequiredApprovals();\n        }\n        if (newRequiredApprovals > newOwners.length) {\n            revert InvalidRequiredApprovals();\n        }\n\n        uint256 len;\n        if (_owners.length != 0) {\n            len = _owners.length;\n            for (uint256 i = 0; i < len; i++) {\n                _isOwner[_owners[i]] = false;\n            }\n        }\n\n        address owner;\n        len = newOwners.length;\n        for (uint256 i = 0; i < len; i++) {\n            owner = newOwners[i];\n\n            if (owner == address(0)) {\n                revert ZeroOwnerAddress();\n            }\n            if (_isOwner[owner]) {\n                revert DuplicateOwnerAddress();\n            }\n\n            _isOwner[owner] = true;\n        }\n\n        _owners = newOwners;\n        _requiredApprovals = newRequiredApprovals;\n\n        emit ConfigureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureExpirationTime}.\n     */\n    function _configureExpirationTime(uint120 newExpirationTime) internal {\n        _expirationTime = newExpirationTime;\n        emit ConfigureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureCooldownTime}.\n     */\n    function _configureCooldownTime(uint120 newCooldownTime) internal {\n        _cooldownTime = newCooldownTime;\n        emit ConfigureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n}"
    }
  ]
}