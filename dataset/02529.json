{
  "Title": "M-3: Repaying loans with small amounts of debt tokens can lead to underflowing in the `roll` function",
  "Content": "# Issue M-3: Repaying loans with small amounts of debt tokens can lead to underflowing in the `roll` function \n\nSource: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/263 \n\n## Found by \ntsvetanovv, rvierdiiev, ck, zaskoh, Allarious, Trumpero, Breeje, berndartmueller, jonatascm, Deivitto\n\n## Summary\n\nDue to precision issues when repaying a loan with small amounts of debt tokens, the `loan.amount` can be reduced whereas the `loan.collateral` remains unchanged. This can lead to underflowing in the `roll` function.\n\n## Vulnerability Detail\n\nThe `decollateralized` calculation in the `repay` function rounds down to zero if the `repaid` amount is small enough. This allows iteratively repaying a loan with very small amounts of debt tokens without reducing the collateral.\n\nThe consequence is that the `roll` function can revert due to underflowing the `newCollateral` calculation once the `loan.collateral` is greater than `collateralFor(loan.amount, req.loanToCollateral)` (`loan.amount` is reduced by repaying the loan)\n\nAs any ERC-20 tokens with different decimals can be used, this precision issue is amplified if the decimals of the collateral and debt tokens differ greatly.\n\n## Impact\n\nThe `roll` function can revert due to underflowing the `newCollateral` calculation if the `repay` function is (iteratively) called with small amounts of debt tokens.\n\n## Code Snippet\n\n[Cooler.sol#L114](https://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L114)\n\n```solidity\nfunction repay (uint256 loanID, uint256 repaid) external {\n    Loan storage loan = loans[loanID];\n\n    if (block.timestamp > loan.expiry)\n        revert Default();\n\n    uint256 decollateralized = loan.collateral * repaid / loan.amount; // @audit-info (10e18 * 10) / 1_000e18 = 0 (rounds down due to imprecision)\n\n    if (repaid == loan.amount) delete loans[loanID];\n    else {\n        loan.amount -= repaid;\n        loan.collateral -= decollateralized;\n    }\n\n    debt.transferFrom(msg.sender, loan.lender, repaid);\n    collateral.transfer(owner, decollateralized);\n}\n```\n\n[Cooler.sol#L139](https://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L139)\n\nCalculating `newCollateral` in L139 can potentially revert due to underflowing if `loan.collateral` is greater than the required collateral (`collateralFor(loan.amount, req.loanToCollateral) `).\n\nA malicious user can use the imprecision issue in the `repay` function in L114 to repay small amounts of debt tokens (`loan.collateral * repaid` < `loan.amount`), which leads to no reduction of loan collateral, whereas the `loan.amount` is reduced.\n\nThis will prevent the `roll` function from being called.\n\n```solidity\nfunction roll (uint256 loanID) external {\n    Loan storage loan = loans[loanID];\n    Request memory req = loan.request;\n\n    if (block.timestamp > loan.expiry)\n        revert Default();\n\n    if (!loan.rollable)\n        revert NotRollable();\n\n    uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n    uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n    loan.amount += newDebt;\n    loan.expiry += req.duration;\n    loan.collateral += newCollateral;\n\n    collateral.transferFrom(msg.sender, address(this), newCollateral);\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider preventing the loan from being repaid if the amount of returned collateral tokens is zero (i.e., `decollateralized == 0`).\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n\n> Good Spot. \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/36",
  "Code": [
    {
      "filename": "src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./lib/mininterfaces.sol\";\nimport \"./Factory.sol\";\n\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration loans\n///         for a specific user and debt-collateral pair.\ncontract Cooler {\n    // Errors\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n\n    // Data Structures\n\n    Request[] public requests;\n    struct Request { // A loan begins with a borrow request. It specifies:\n        uint256 amount; // the amount they want to borrow,\n        uint256 interest; // the annualized percentage they will pay as interest,\n        uint256 loanToCollateral; // the loan-to-collateral ratio they want,\n        uint256 duration; // and the length of time until the loan defaults.\n        bool active; // Any lender can clear an active loan request.\n    } \n\n    Loan[] public loans;\n    struct Loan { // A request is converted to a loan when a lender clears it.\n        Request request; // The terms of the loan are saved, along with:\n        uint256 amount; // the amount of debt owed,\n        uint256 collateral; // the amount of collateral pledged,\n        uint256 expiry; // the time when the loan defaults,\n        bool rollable; // whether the loan can be rolled over,\n        address lender; // and the lender's address.\n    }\n\n    // Facilitates transfer of lender ownership to new address\n    mapping(uint256 => address) public approvals;\n\n    // Immutables\n\n    // This address owns the collateral in escrow.\n    address private immutable owner;\n    // This token is borrowed against.\n    ERC20 public immutable collateral;\n    // This token is lent.\n    ERC20 public immutable debt;\n    // This contract created the Cooler\n    CoolerFactory public immutable factory;\n\n    // This makes the code look prettier.\n    uint256 private constant decimals = 1e18;\n\n    // Initialization\n\n    constructor (address o, ERC20 c, ERC20 d) {\n        owner = o;\n        collateral = c;\n        debt = d;\n        factory = CoolerFactory(msg.sender);\n    }\n\n    // Borrower\n\n    /// @notice request a loan with given parameters\n    /// @notice collateral is taken at time of request\n    /// @param amount of debt tokens to borrow\n    /// @param interest to pay (annualized % of 'amount')\n    /// @param loanToCollateral debt tokens per collateral token pledged\n    /// @param duration of loan tenure in seconds\n    /// @param reqID index of request in requests[]\n    function request (\n        uint256 amount,\n        uint256 interest,\n        uint256 loanToCollateral,\n        uint256 duration\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        factory.newEvent(reqID, CoolerFactory.Events.Request);\n        requests.push(\n            Request(amount, interest, loanToCollateral, duration, true)\n        );\n        collateral.transferFrom(msg.sender, address(this), collateralFor(amount, loanToCollateral));\n    }\n\n    /// @notice cancel a loan request and return collateral\n    /// @param reqID index of request in requests[]\n    function rescind (uint256 reqID) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n\n        factory.newEvent(reqID, CoolerFactory.Events.Rescind);\n\n        Request storage req = requests[reqID];\n\n        if (!req.active)\n            revert Deactivated();\n        \n        req.active = false;\n        collateral.transfer(owner, collateralFor(req.amount, req.loanToCollateral));\n    }\n\n    /// @notice repay a loan to recoup collateral\n    /// @param loanID index of loan in loans[]\n    /// @param repaid debt tokens to repay\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\n    /// @notice roll a loan over\n    /// @notice uses terms from request\n    /// @param loanID index of loan in loans[]\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n\n        uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n        uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n        loan.amount += newDebt;\n        loan.expiry += req.duration;\n        loan.collateral += newCollateral;\n        \n        collateral.transferFrom(msg.sender, address(this), newCollateral);\n    }\n\n    /// @notice delegate voting power on collateral\n    /// @param to address to delegate\n    function delegate (address to) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n        IDelegateERC20(address(collateral)).delegate(to);\n    }\n\n    // Lender\n\n    /// @notice fill a requested loan as a lender\n    /// @param reqID index of request in requests[]\n    /// @param loanID index of loan in loans[]\n    function clear (uint256 reqID) external returns (uint256 loanID) {\n        Request storage req = requests[reqID];\n\n        factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n        if (!req.active) \n            revert Deactivated();\n        else req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n\n    /// @notice change 'rollable' status of loan\n    /// @param loanID index of loan in loans[]\n    /// @return bool new 'rollable' status\n    function toggleRoll(uint256 loanID) external returns (bool) {\n        Loan storage loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        loan.rollable = !loan.rollable;\n        return loan.rollable;\n    }\n\n    /// @notice send collateral to lender upon default\n    /// @param loanID index of loan in loans[]\n    /// @return uint256 collateral amount\n    function defaulted (uint256 loanID) external returns (uint256) {\n        Loan memory loan = loans[loanID];\n        delete loans[loanID];\n\n        if (block.timestamp <= loan.expiry) \n            revert NoDefault();\n\n        collateral.transfer(loan.lender, loan.collateral);\n        return loan.collateral;\n    }\n\n    /// @notice approve transfer of loan ownership to new address\n    /// @param to address to approve\n    /// @param loanID index of loan in loans[]\n    function approve (address to, uint256 loanID) external {\n        Loan memory loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        approvals[loanID] = to;\n    }\n\n    /// @notice execute approved transfer of loan ownership\n    /// @param loanID index of loan in loans[]\n    function transfer (uint256 loanID) external {\n        if (msg.sender != approvals[loanID])\n            revert OnlyApproved();\n\n        approvals[loanID] = address(0);\n        loans[loanID].lender = msg.sender;\n    }\n\n    // Views\n\n    /// @notice compute collateral needed for loan amount at given loan to collateral ratio\n    /// @param amount of collateral tokens\n    /// @param loanToCollateral ratio for loan\n    function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n        return amount * decimals / loanToCollateral;\n    }\n\n    /// @notice compute interest cost on amount for duration at given annualized rate\n    /// @param amount of debt tokens\n    /// @param rate of interest (annualized)\n    /// @param duration of loan in seconds\n    /// @return interest as a number of debt tokens\n    function interestFor(uint256 amount, uint256 rate, uint256 duration) public pure returns (uint256) {\n        uint256 interest = rate * duration / 365 days;\n        return amount * interest / decimals;\n    }\n\n    /// @notice check if given loan is in default\n    /// @param loanID index of loan in loans[]\n    /// @return defaulted status\n    function isDefaulted(uint256 loanID) external view returns (bool) {\n        return block.timestamp > loans[loanID].expiry;\n    }\n\n    /// @notice check if given request is active\n    /// @param reqID index of request in requests[]\n    /// @return active status\n    function isActive(uint256 reqID) external view returns (bool) {\n        return requests[reqID].active;\n    }\n}"
    },
    {
      "filename": "src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./lib/mininterfaces.sol\";\nimport \"./Factory.sol\";\n\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration loans\n///         for a specific user and debt-collateral pair.\ncontract Cooler {\n    // Errors\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n\n    // Data Structures\n\n    Request[] public requests;\n    struct Request { // A loan begins with a borrow request. It specifies:\n        uint256 amount; // the amount they want to borrow,\n        uint256 interest; // the annualized percentage they will pay as interest,\n        uint256 loanToCollateral; // the loan-to-collateral ratio they want,\n        uint256 duration; // and the length of time until the loan defaults.\n        bool active; // Any lender can clear an active loan request.\n    } \n\n    Loan[] public loans;\n    struct Loan { // A request is converted to a loan when a lender clears it.\n        Request request; // The terms of the loan are saved, along with:\n        uint256 amount; // the amount of debt owed,\n        uint256 collateral; // the amount of collateral pledged,\n        uint256 expiry; // the time when the loan defaults,\n        bool rollable; // whether the loan can be rolled over,\n        address lender; // and the lender's address.\n    }\n\n    // Facilitates transfer of lender ownership to new address\n    mapping(uint256 => address) public approvals;\n\n    // Immutables\n\n    // This address owns the collateral in escrow.\n    address private immutable owner;\n    // This token is borrowed against.\n    ERC20 public immutable collateral;\n    // This token is lent.\n    ERC20 public immutable debt;\n    // This contract created the Cooler\n    CoolerFactory public immutable factory;\n\n    // This makes the code look prettier.\n    uint256 private constant decimals = 1e18;\n\n    // Initialization\n\n    constructor (address o, ERC20 c, ERC20 d) {\n        owner = o;\n        collateral = c;\n        debt = d;\n        factory = CoolerFactory(msg.sender);\n    }\n\n    // Borrower\n\n    /// @notice request a loan with given parameters\n    /// @notice collateral is taken at time of request\n    /// @param amount of debt tokens to borrow\n    /// @param interest to pay (annualized % of 'amount')\n    /// @param loanToCollateral debt tokens per collateral token pledged\n    /// @param duration of loan tenure in seconds\n    /// @param reqID index of request in requests[]\n    function request (\n        uint256 amount,\n        uint256 interest,\n        uint256 loanToCollateral,\n        uint256 duration\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        factory.newEvent(reqID, CoolerFactory.Events.Request);\n        requests.push(\n            Request(amount, interest, loanToCollateral, duration, true)\n        );\n        collateral.transferFrom(msg.sender, address(this), collateralFor(amount, loanToCollateral));\n    }\n\n    /// @notice cancel a loan request and return collateral\n    /// @param reqID index of request in requests[]\n    function rescind (uint256 reqID) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n\n        factory.newEvent(reqID, CoolerFactory.Events.Rescind);\n\n        Request storage req = requests[reqID];\n\n        if (!req.active)\n            revert Deactivated();\n        \n        req.active = false;\n        collateral.transfer(owner, collateralFor(req.amount, req.loanToCollateral));\n    }\n\n    /// @notice repay a loan to recoup collateral\n    /// @param loanID index of loan in loans[]\n    /// @param repaid debt tokens to repay\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\n    /// @notice roll a loan over\n    /// @notice uses terms from request\n    /// @param loanID index of loan in loans[]\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n\n        uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n        uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n        loan.amount += newDebt;\n        loan.expiry += req.duration;\n        loan.collateral += newCollateral;\n        \n        collateral.transferFrom(msg.sender, address(this), newCollateral);\n    }\n\n    /// @notice delegate voting power on collateral\n    /// @param to address to delegate\n    function delegate (address to) external {\n        if (msg.sender != owner) \n            revert OnlyApproved();\n        IDelegateERC20(address(collateral)).delegate(to);\n    }\n\n    // Lender\n\n    /// @notice fill a requested loan as a lender\n    /// @param reqID index of request in requests[]\n    /// @param loanID index of loan in loans[]\n    function clear (uint256 reqID) external returns (uint256 loanID) {\n        Request storage req = requests[reqID];\n\n        factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n        if (!req.active) \n            revert Deactivated();\n        else req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n\n    /// @notice change 'rollable' status of loan\n    /// @param loanID index of loan in loans[]\n    /// @return bool new 'rollable' status\n    function toggleRoll(uint256 loanID) external returns (bool) {\n        Loan storage loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        loan.rollable = !loan.rollable;\n        return loan.rollable;\n    }\n\n    /// @notice send collateral to lender upon default\n    /// @param loanID index of loan in loans[]\n    /// @return uint256 collateral amount\n    function defaulted (uint256 loanID) external returns (uint256) {\n        Loan memory loan = loans[loanID];\n        delete loans[loanID];\n\n        if (block.timestamp <= loan.expiry) \n            revert NoDefault();\n\n        collateral.transfer(loan.lender, loan.collateral);\n        return loan.collateral;\n    }\n\n    /// @notice approve transfer of loan ownership to new address\n    /// @param to address to approve\n    /// @param loanID index of loan in loans[]\n    function approve (address to, uint256 loanID) external {\n        Loan memory loan = loans[loanID];\n\n        if (msg.sender != loan.lender)\n            revert OnlyApproved();\n\n        approvals[loanID] = to;\n    }\n\n    /// @notice execute approved transfer of loan ownership\n    /// @param loanID index of loan in loans[]\n    function transfer (uint256 loanID) external {\n        if (msg.sender != approvals[loanID])\n            revert OnlyApproved();\n\n        approvals[loanID] = address(0);\n        loans[loanID].lender = msg.sender;\n    }\n\n    // Views\n\n    /// @notice compute collateral needed for loan amount at given loan to collateral ratio\n    /// @param amount of collateral tokens\n    /// @param loanToCollateral ratio for loan\n    function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n        return amount * decimals / loanToCollateral;\n    }\n\n    /// @notice compute interest cost on amount for duration at given annualized rate\n    /// @param amount of debt tokens\n    /// @param rate of interest (annualized)\n    /// @param duration of loan in seconds\n    /// @return interest as a number of debt tokens\n    function interestFor(uint256 amount, uint256 rate, uint256 duration) public pure returns (uint256) {\n        uint256 interest = rate * duration / 365 days;\n        return amount * interest / decimals;\n    }\n\n    /// @notice check if given loan is in default\n    /// @param loanID index of loan in loans[]\n    /// @return defaulted status\n    function isDefaulted(uint256 loanID) external view returns (bool) {\n        return block.timestamp > loans[loanID].expiry;\n    }\n\n    /// @notice check if given request is active\n    /// @param reqID index of request in requests[]\n    /// @return active status\n    function isActive(uint256 reqID) external view returns (bool) {\n        return requests[reqID].active;\n    }\n}"
    }
  ]
}