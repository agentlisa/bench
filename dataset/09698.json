{
  "Title": "[M-03] LibSwap: Excess funds from swaps are not returned",
  "Content": "_Submitted by hickuphh3, also found by 0xDjango, cccz, JMukesh, and Ruhum_\n\n[LibSwap.sol#L29-L58](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Libraries/LibSwap.sol#L29-L58)<br>\n\nIt is probable for `_swapData.fromAmount` to be greater than the actual amount used (eg. when swapping for an exact output, or when performing another swap after swapping with an exact input). However, these funds aren’t returned back to the user and are left in the lifi contract.\n\n### Proof of Concept\n\n[AnyswapFacet.test.ts#L153-L194](https://github.com/code-423n4/2022-03-lifinance/blob/main/test/facets/AnyswapFacet.test.ts#L153-L194)<br>\n\nThe test referenced above swaps for MATIC for 1000 USDT exactly. Logging the matic amounts before and after the swap and bridge call, one will find 18.01 MATIC is unused and left in the contract when it should be returned to the user.\n\n### Recommended Mitigation Steps\n\nStore the contract’s from balance before and after the swap. Refund any excess back to the user.\n\n```jsx\nuint256 actualFromAmount = LibAsset.getOwnBalance(fromAssetId);\n(bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\nif (!success) {\n  string memory reason = LibUtil.getRevertMsg(res);\n  revert(reason);\n}\nactualFromAmount -= LibAsset.getOwnBalance(fromAssetId);\nrequire(fromAmount >= actualFromAmount, 'actual amount used more than specified');\n// transfer excess back to user\nif (actualFromAmount != fromAmount) {\n  // transfer excess to user\n  // difference calculation be unchecked since fromAmount > actualFromAmount\n}\n```\n\nThis comes with the requirement that the funds for every swap should be pulled from the user.\n\n**[H3xept (Li.Fi) resolved and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/33#issuecomment-1096482980):**\n > Fixed in lifinance/lifi-contracts@4d66e5ad5f9a897d9f8a66eb7a4e765e0b6ff97c\n\n**[maxklenk (Li.Fi) disagreed with High severity and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/33#issuecomment-1098863344):**\n > We \"disagree with severity\" as this issue would not allow to access other users funds and only happens if the user passes these kind of swaps himself. The multi-swap feature is mainly used to allow swapping multiple different tokens into one, which is then fully swapped.\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/33#issuecomment-1100699308):**\n > Agree with sponsor and adjusting this to Medium Risk.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Libraries/LibSwap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\n\nlibrary LibSwap {\n    uint256 private constant MAX_INT = 2**256 - 1;\n\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }\n}"
    },
    {
      "filename": "test/facets/AnyswapFacet.test.ts",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  AnyswapFacet,\n  DexManagerFacet,\n  IERC20,\n  IERC20__factory,\n} from '../../typechain'\nimport { deployments, network } from 'hardhat'\nimport { constants, utils } from 'ethers'\nimport { node_url } from '../../utils/network'\nimport { SignerWithAddress } from '@nomiclabs/hardhat-ethers/dist/src/signers'\nimport { expect } from '../chai-setup'\n\nconst ANYSWAP_ROUTER = '0x4f3aff3a747fcade12598081e80c6605a8be192f'\nconst USDT_ADDRESS = '0xc2132D05D31c914a87C6611C10748AEb04B58e8F'\nconst WMATIC_ADDRESS = '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'\nconst MATIC_ROUTER = '0x2ef4a574b72e1f555185afa8a09c6d1a8ac4025c'\nconst anyMATIC_ADDRESS = '0x21804205c744dd98fbc87898704564d5094bb167'\nconst anyUSDT_ADDRESS = '0xE3eeDa11f06a656FcAee19de663E84C7e61d3Cac'\nconst UNISWAP_ADDRESS = '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff'\nconst BEEFY_ADDRESS = '0xFbdd194376de19a88118e84E279b977f165d01b8'\nconst BEEFY_ROUTER = '0x6fF0609046A38D76Bd40C5863b4D1a2dCe687f73'\n\ndescribe('AnyswapFacet', function () {\n  let lifi: AnyswapFacet\n  let dexMgr: DexManagerFacet\n  let alice: SignerWithAddress\n  let beefHolder: SignerWithAddress\n  let lifiData: any\n  let token: IERC20\n  let usdt: IERC20\n  let wmatic: IERC20\n\n  const setupTest = deployments.createFixture(\n    async ({ deployments, ethers }) => {\n      await deployments.fixture('DeployAnyswapFacet')\n      const diamond = await ethers.getContract('LiFiDiamond')\n      lifi = <AnyswapFacet>(\n        await ethers.getContractAt('AnyswapFacet', diamond.address)\n      )\n      dexMgr = <DexManagerFacet>(\n        await ethers.getContractAt('DexManagerFacet', diamond.address)\n      )\n      await dexMgr.addDex(UNISWAP_ADDRESS)\n\n      await network.provider.request({\n        method: 'hardhat_impersonateAccount',\n        params: ['0x6722846282868a9c084b423aee79eb8ff69fc497'],\n      })\n\n      await network.provider.request({\n        method: 'hardhat_impersonateAccount',\n        params: ['0xf71b335a1d9449c381d867f4172fc1bb3d2bfb7b'],\n      })\n\n      alice = await ethers.getSigner(\n        '0x6722846282868a9c084b423aee79eb8ff69fc497'\n      )\n\n      beefHolder = await ethers.getSigner(\n        '0xf71b335a1d9449c381d867f4172fc1bb3d2bfb7b'\n      )\n\n      wmatic = IERC20__factory.connect(WMATIC_ADDRESS, alice)\n\n      usdt = IERC20__factory.connect(USDT_ADDRESS, alice)\n      lifiData = {\n        transactionId: utils.randomBytes(32),\n        integrator: 'ACME Devs',\n        referrer: constants.AddressZero,\n        sendingAssetId: usdt.address,\n        receivingAssetId: usdt.address,\n        receiver: alice.address,\n        destinationChainId: 100,\n        amount: utils.parseUnits('1000', 6),\n      }\n      token = IERC20__factory.connect(anyUSDT_ADDRESS, alice)\n      await usdt.approve(lifi.address, utils.parseUnits('1000', 6))\n    }\n  )\n\n  before(async function () {\n    this.timeout(0)\n    await network.provider.request({\n      method: 'hardhat_reset',\n      params: [\n        {\n          forking: {\n            jsonRpcUrl: node_url('polygon'),\n            blockNumber: 25689963,\n          },\n        },\n      ],\n    })\n  })\n\n  beforeEach(async () => {\n    await setupTest()\n  })\n\n  it('starts a bridge transaction using native token on the sending chain', async () => {\n    const AnyswapData = {\n      token: anyMATIC_ADDRESS,\n      router: MATIC_ROUTER,\n      amount: utils.parseEther('1000'),\n      recipient: alice.address,\n      toChainId: 100,\n    }\n\n    await lifi\n      .connect(alice)\n      .startBridgeTokensViaAnyswap(lifiData, AnyswapData, {\n        gasLimit: 500000,\n        value: utils.parseEther('1000'),\n      })\n  })\n\n  it('starts a bridge transaction using anyToken implementation on the sending chain', async () => {\n    const beefy = IERC20__factory.connect(BEEFY_ADDRESS, beefHolder)\n    await beefy.approve(lifi.address, utils.parseEther('10'))\n\n    const AnyswapData = {\n      token: BEEFY_ADDRESS,\n      router: BEEFY_ROUTER,\n      amount: utils.parseEther('10'),\n      recipient: beefHolder.address,\n      toChainId: 100,\n    }\n\n    await lifi\n      .connect(beefHolder)\n      .startBridgeTokensViaAnyswap(lifiData, AnyswapData, {\n        gasLimit: 500000,\n      })\n  })\n\n  it('starts a bridge transaction on the sending chain', async () => {\n    const AnyswapData = {\n      token: token.address,\n      router: ANYSWAP_ROUTER,\n      amount: utils.parseUnits('1000', 6),\n      recipient: alice.address,\n      toChainId: 100,\n    }\n\n    await lifi\n      .connect(alice)\n      .startBridgeTokensViaAnyswap(lifiData, AnyswapData, {\n        gasLimit: 500000,\n      })\n  })\n\n  it('performs a swap then starts bridge transaction on the sending chain', async () => {\n    const to = lifi.address // should be a checksummed recipient address\n    const deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20 minutes from the current Unix time\n\n    const iface = new utils.Interface([\n      'function swapETHForExactTokens(uint,address[],address,uint256)',\n    ])\n\n    // Generate swap calldata\n    const uniswapData = iface.encodeFunctionData('swapETHForExactTokens', [\n      utils.parseUnits('1000', 6),\n      [wmatic.address, usdt.address],\n      to,\n      deadline,\n    ])\n\n    const swapData = [\n      {\n        callTo: UNISWAP_ADDRESS,\n        approveTo: UNISWAP_ADDRESS,\n        sendingAssetId: '0x0000000000000000000000000000000000000000',\n        receivingAssetId: usdt.address,\n        fromAmount: utils.parseEther('700'),\n        callData: uniswapData,\n      },\n    ]\n\n    const AnyswapData = {\n      token: token.address,\n      router: ANYSWAP_ROUTER,\n      amount: utils.parseUnits('1000', 6),\n      recipient: alice.address,\n      toChainId: 137,\n    }\n\n    await lifi\n      .connect(alice)\n      .swapAndStartBridgeTokensViaAnyswap(lifiData, swapData, AnyswapData, {\n        gasLimit: 500000,\n        value: utils.parseEther('700'),\n      })\n  })\n\n  it('fails to perform a swap when the dex is not approved', async () => {\n    await dexMgr.removeDex(UNISWAP_ADDRESS)\n    const to = lifi.address // should be a checksummed recipient address\n    const deadline = Math.floor(Date.now() / 1000) + 60 * 20 // 20 minutes from the current Unix time\n\n    const iface = new utils.Interface([\n      'function swapETHForExactTokens(uint,address[],address,uint256)',\n    ])\n\n    // Generate swap calldata\n    const uniswapData = iface.encodeFunctionData('swapETHForExactTokens', [\n      utils.parseUnits('1000', 6),\n      [wmatic.address, usdt.address],\n      to,\n      deadline,\n    ])\n\n    const swapData = [\n      {\n        callTo: UNISWAP_ADDRESS,\n        approveTo: UNISWAP_ADDRESS,\n        sendingAssetId: '0x0000000000000000000000000000000000000000',\n        receivingAssetId: usdt.address,\n        fromAmount: utils.parseEther('700'),\n        callData: uniswapData,\n      },\n    ]\n\n    const AnyswapData = {\n      token: token.address,\n      router: ANYSWAP_ROUTER,\n      amount: utils.parseUnits('1000', 6),\n      recipient: alice.address,\n      toChainId: 137,\n    }\n\n    await expect(\n      lifi\n        .connect(alice)\n        .swapAndStartBridgeTokensViaAnyswap(lifiData, swapData, AnyswapData, {\n          gasLimit: 500000,\n          value: utils.parseEther('700'),\n        })\n    ).to.be.revertedWith('Contract call not allowed!')\n  })\n})"
    }
  ]
}