{
  "Title": "M-1: Curve points should be guaranteed to be monotonic increasing",
  "Content": "# Issue M-1: Curve points should be guaranteed to be monotonic increasing \n\nSource: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/111 \n\n## Found by \nhickuphh3, minhquanym, WATCHPUG, ElKu, berndartmueller, rvierdiiev\n\n## Summary\n\nLack of checks to ensure the points in the curve are monotonic increasing, which can result in a malfunction of `deposit()` / `extendLock()` due to underflow when the curve is not set properly.\n\n## Vulnerability Detail\n\nIn the current implementation, `getMultiplier()` assume the later point in the curve is always bigger than the previous point, otherwise `curve[n + 1] - curve[n]` will revert due to underflow.\n\nHowever, since there is no check in `__TimeLockPool_init()` / `setCurve()` / `setCurvePoint()` to guarantee that, a lower point can actually be set after a higher point.\n\n## Impact\n\n`deposit()` / `extendLock()` may revert due to underflow.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L35-L63\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L280-L311\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/TimeLockPool.sol#L322-L337\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a new internal function to validate the curve points:\n\n```solidity\nfunction checkCurve(uint256[] calldata _curve) internal {\n    if (_curve.length < 2) {\n        revert ShortCurveError();\n    }\n    for (uint256 i; i < curve.length - 1; ++i) {\n            if (\n                curve[i + 1] < curve[i]\n            ) {\n                revert CurveIncreaseError();\n            }\n        }\n}\n```\n\n## Discussion\n\n**federava**\n\nAgree on the recommendation. Using that logic everywhere the curve is set should be sufficient: `setCurve()`, `setCurvePoint()` and in `__TimeLockPool_init()`. Thanks!\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/18) from this issue\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/9",
  "Code": [
    {
      "filename": "merit-liquidity-mining/contracts/TimeLockPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./base/BasePool.sol\";\nimport \"./interfaces/ITimeLockPool.sol\";\n\ncontract TimeLockPool is BasePool, ITimeLockPool {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    error SmallMaxLockDuration();\n    error NonExistingDepositError();\n    error TooSoonError();\n    error MaxBonusError();\n\n    uint256 public maxBonus;\n    uint256 public maxLockDuration;\n    uint256 public constant MIN_LOCK_DURATION = 10 minutes;\n    \n    uint256[] public curve;\n    uint256 public unit;\n\n    mapping(address => Deposit[]) public depositsOf;\n\n    struct Deposit {\n        uint256 amount;\n        uint256 shareAmount;\n        uint64 start;\n        uint64 end;\n    }\n    function __TimeLockPool_init(\n        string memory _name,\n        string memory _symbol,\n        address _depositToken,\n        address _rewardToken,\n        address _escrowPool,\n        uint256 _escrowPortion,\n        uint256 _escrowDuration,\n        uint256 _maxBonus,\n        uint256 _maxLockDuration,\n        uint256[] memory _curve\n    ) internal onlyInitializing {\n        __BasePool_init(_name, _symbol, _depositToken, _rewardToken, _escrowPool, _escrowPortion, _escrowDuration);\n        if (_maxLockDuration < MIN_LOCK_DURATION) {\n            revert SmallMaxLockDuration();\n        }\n        if (_curve.length < 2) {\n            revert ShortCurveError();\n        }\n        for (uint i=0; i < _curve.length; i++) {\n            if (_curve[i] > _maxBonus) {\n                revert MaxBonusError();\n            }\n            curve.push(_curve[i]);\n        }\n        maxBonus = _maxBonus;\n        maxLockDuration = _maxLockDuration;\n        unit = _maxLockDuration / (curve.length - 1);\n    }\n\n    error DepositExpiredError();\n    error ZeroDurationError();\n    error ZeroAmountError();\n    error ShortCurveError();\n\n    event Deposited(uint256 amount, uint256 duration, address indexed receiver, address indexed from);\n    event Withdrawn(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);\n    event LockExtended(uint256 indexed depositId, uint256 duration, address indexed from);\n    event LockIncreased(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);\n    event CurveChanged(address indexed sender);\n\n    /**\n     * @notice Creates a lock with an amount of tokens and mint the corresponding shares.\n     * @dev The function forces the duration to be in between the minimum and maximum\n     * duration if it the duration parameter is outside of those bounds. Uses the multiplier\n     * function to get the amount of shares to mint.\n     * @param _amount uint256 amount of tokens to be deposited\n     * @param _duration uint256 time that the deposit will be locked.\n     * @param _receiver uint256 owner of the lock\n     */\n    function deposit(uint256 _amount, uint256 _duration, address _receiver) external override {\n        if (_amount == 0) {\n            revert ZeroAmountError();\n        }\n        // Don't allow locking > maxLockDuration\n        uint256 duration = _duration.min(maxLockDuration);\n        // Enforce min lockup duration to prevent flash loan or MEV transaction ordering\n        duration = duration.max(MIN_LOCK_DURATION);\n\n        depositToken.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        uint256 mintAmount = _amount * getMultiplier(duration) / 1e18;\n\n        depositsOf[_receiver].push(Deposit({\n            amount: _amount,\n            shareAmount: mintAmount,\n            start: uint64(block.timestamp),\n            end: uint64(block.timestamp) + uint64(duration)\n        }));\n\n        _mint(_receiver, mintAmount);\n        emit Deposited(_amount, duration, _receiver, _msgSender());\n    }\n\n    /**\n     * @notice Withdraws all the tokens from the lock\n     * @dev The lock has to be expired to withdraw the tokens. When the withdrawl happens\n     * the shares minted on the deposit are burnt.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _receiver uint256 owner of the lock\n     */\n    function withdraw(uint256 _depositId, address _receiver) external {\n        if (_depositId >= depositsOf[_msgSender()].length) {\n            revert NonExistingDepositError();\n        }\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n        if (block.timestamp < userDeposit.end) {\n            revert TooSoonError();\n        }\n\n        // remove Deposit\n        depositsOf[_msgSender()][_depositId] = depositsOf[_msgSender()][depositsOf[_msgSender()].length - 1];\n        depositsOf[_msgSender()].pop();\n\n        // burn pool shares\n        _burn(_msgSender(), userDeposit.shareAmount);\n        \n        // return tokens\n        depositToken.safeTransfer(_receiver, userDeposit.amount);\n        emit Withdrawn(_depositId, _receiver, _msgSender(), userDeposit.amount);\n    }\n\n    /**\n     * @notice Adds more time to current lock.\n     * @dev This function extends the duration of a specific lock -deposit- of the sender.\n     * While doing so, it uses the timestamp of the current block and calculates the remaining\n     * time to the end of the lock, and adds the increase duration. This results is a new\n     * duration that can be different to the original duration from the lock one (>, = or <), \n     * and gets multiplied by the correspondant multiplier. The final result can be more, same,\n     * or less shares, which will be minted/burned accordingly.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _increaseDuration uint256 time to be added to the lock meassured from the end of the lock\n     */\n    function extendLock(uint256 _depositId, uint256 _increaseDuration) external {\n        // Check if actually increasing\n        if (_increaseDuration == 0) {\n            revert ZeroDurationError();\n        }\n\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n\n        // Only can extend if it has not expired\n        if (block.timestamp >= userDeposit.end) {\n            revert DepositExpiredError();\n        }\n        \n        // Enforce min increase to prevent flash loan or MEV transaction ordering\n        uint256 increaseDuration = _increaseDuration.max(MIN_LOCK_DURATION);\n        \n        // New duration is the time expiration plus the increase\n        uint256 duration = maxLockDuration.min(uint256(userDeposit.end - block.timestamp) + increaseDuration);\n\n        uint256 mintAmount = userDeposit.amount * getMultiplier(duration) / 1e18;\n\n        // Multiplier curve changes with time, need to check if the mint amount is bigger, equal or smaller than the already minted\n        \n        // If the new amount if bigger mint the difference\n        if (mintAmount > userDeposit.shareAmount) {\n            depositsOf[_msgSender()][_depositId].shareAmount =  mintAmount;\n            _mint(_msgSender(), mintAmount - userDeposit.shareAmount);\n        // If the new amount is less then burn that difference\n        } else if (mintAmount < userDeposit.shareAmount) {\n            depositsOf[_msgSender()][_depositId].shareAmount =  mintAmount;\n            _burn(_msgSender(), userDeposit.shareAmount - mintAmount);\n        }\n\n        depositsOf[_msgSender()][_depositId].start = uint64(block.timestamp);\n        depositsOf[_msgSender()][_depositId].end = uint64(block.timestamp) + uint64(duration);\n        emit LockExtended(_depositId, _increaseDuration, _msgSender());\n    }\n\n    /**\n     * @notice Adds more deposits to current lock.\n     * @dev This function increases the deposit amount of a specific lock -deposit- of the sender.\n     * While doing so, it uses the timestamp of the current block and calculates the remaining\n     * time to the end of the lock. Then it uses this time duration to mint the shares that correspond\n     * to the multiplier of that time and the increase amount being deposited. The result is an increase\n     * both in deposit amount and share amount of the deposit.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _receiver address owner of the lock\n     * @param _increaseAmount uint256 amount of tokens to add to the lock.\n     */\n    function increaseLock(uint256 _depositId, address _receiver, uint256 _increaseAmount) external {\n        // Check if actually increasing\n        if (_increaseAmount == 0) {\n            revert ZeroAmountError();\n        }\n\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n\n        // Only can extend if it has not expired\n        if (block.timestamp >= userDeposit.end) {\n            revert DepositExpiredError();\n        }\n\n        depositToken.safeTransferFrom(_msgSender(), address(this), _increaseAmount);\n\n        // Multiplier should be acording the remaining time to the deposit to end\n        uint256 remainingDuration = uint256(userDeposit.end - block.timestamp);\n\n        uint256 mintAmount = _increaseAmount * getMultiplier(remainingDuration) / 1e18;\n\n        depositsOf[_receiver][_depositId].amount += _increaseAmount;\n        depositsOf[_receiver][_depositId].shareAmount += mintAmount;\n\n        _mint(_receiver, mintAmount);\n        emit LockIncreased(_depositId, _receiver, _msgSender(), _increaseAmount);\n    }\n\n    /**\n     * @notice Gets the multiplier from the curve given a duration.\n     * @dev This function calculates a multiplier by fetching the points in the curve given a duration.\n     * It can achieve this by linearly interpolating between the points of the curve to get a much more\n     * precise result. The unit parameter is related to the maximum possible duration of the deposits \n     * and the amount of points in the curve.\n     * @param _lockDuration uint256 time that the deposit will be locked.\n     * @return uint256 number used to multiply and get amount of shares.\n     */\n    function getMultiplier(uint256 _lockDuration) public view returns(uint256) {\n        // There is no need to check _lockDuration amount, it is always checked before\n        // in the functions that call this function\n\n        // n is the time unit where the lockDuration stands\n        uint n = _lockDuration / unit;\n        // if last point no need to interpolate\n        // trim de curve if it exceedes the maxBonus // TODO check if this is needed\n        if (n == curve.length - 1) {\n            return 1e18 + curve[n];\n        }\n        // linear interpolation between points\n        return 1e18 + curve[n] + (_lockDuration - n * unit) * (curve[n + 1] - curve[n]) / unit;\n    }\n\n    function getTotalDeposit(address _account) public view returns(uint256) {\n        uint256 total;\n        for(uint256 i = 0; i < depositsOf[_account].length; i++) {\n            total += depositsOf[_account][i].amount;\n        }\n\n        return total;\n    }\n\n    function getDepositsOf(address _account) public view returns(Deposit[] memory) {\n        return depositsOf[_account];\n    }\n\n    function getDepositsOfLength(address _account) public view returns(uint256) {\n        return depositsOf[_account].length;\n    }\n\n    function maxBonusError(uint256 _point) internal returns(uint256) {\n        if (_point > maxBonus) {\n            revert MaxBonusError();\n        } else {\n            return _point;\n        }\n    }\n\n    /**\n     * @notice Can set an entire new curve.\n     * @dev This function can change current curve by a completely new. For doing so, it does not\n     * matter if the new curve's length is larger, equal, or shorter because the function manages\n     * all of those cases.\n     * @param _curve uint256 array of the points that compose the curve.\n     */\n    function setCurve(uint256[] calldata _curve) external onlyGov {\n        if (_curve.length < 2) {\n            revert ShortCurveError();\n        }\n        // same length curves\n        if (curve.length == _curve.length) {\n            for (uint i=0; i < curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n        // replacing with a shorter curve\n        } else if (curve.length > _curve.length) {\n            for (uint i=0; i < _curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n            uint initialLength = curve.length;\n            for (uint j=0; j < initialLength - _curve.length; j++) {\n                curve.pop();\n            }\n            unit = maxLockDuration / (curve.length - 1);\n        // replacing with a longer curve\n        } else {\n            for (uint i=0; i < curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n            uint initialLength = curve.length;\n            for (uint j=0; j < _curve.length - initialLength; j++) {\n                curve.push(maxBonusError(_curve[initialLength + j]));\n            }\n            unit = maxLockDuration / (curve.length - 1);\n        }\n        emit CurveChanged(_msgSender());\n    }\n\n    /**\n     * @notice Can set a point of the curve.\n     * @dev This function can replace any point in the curve by inputing the existing index,\n     * add a point to the curve by using the index that equals the amount of points of the curve,\n     * and remove the last point of the curve if an index greated than the length is used. The first\n     * point of the curve index is zero.\n     * @param _newPoint uint256 point to be set.\n     * @param _position uint256 position of the array to be set (zero-based indexing convention).\n     */\n    function setCurvePoint(uint256 _newPoint, uint256 _position) external onlyGov {\n        if (_newPoint > maxBonus) {\n            revert MaxBonusError();\n        }\n        if (_position < curve.length) {\n            curve[_position] = _newPoint;\n        } else if (_position == curve.length) {\n            curve.push(_newPoint);\n        } else {\n            if (curve.length - 1 < 2) {\n                revert ShortCurveError();\n            }\n            curve.pop();\n        }\n        emit CurveChanged(_msgSender());\n    }\n}"
    },
    {
      "filename": "merit-liquidity-mining/contracts/TimeLockPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./base/BasePool.sol\";\nimport \"./interfaces/ITimeLockPool.sol\";\n\ncontract TimeLockPool is BasePool, ITimeLockPool {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    error SmallMaxLockDuration();\n    error NonExistingDepositError();\n    error TooSoonError();\n    error MaxBonusError();\n\n    uint256 public maxBonus;\n    uint256 public maxLockDuration;\n    uint256 public constant MIN_LOCK_DURATION = 10 minutes;\n    \n    uint256[] public curve;\n    uint256 public unit;\n\n    mapping(address => Deposit[]) public depositsOf;\n\n    struct Deposit {\n        uint256 amount;\n        uint256 shareAmount;\n        uint64 start;\n        uint64 end;\n    }\n    function __TimeLockPool_init(\n        string memory _name,\n        string memory _symbol,\n        address _depositToken,\n        address _rewardToken,\n        address _escrowPool,\n        uint256 _escrowPortion,\n        uint256 _escrowDuration,\n        uint256 _maxBonus,\n        uint256 _maxLockDuration,\n        uint256[] memory _curve\n    ) internal onlyInitializing {\n        __BasePool_init(_name, _symbol, _depositToken, _rewardToken, _escrowPool, _escrowPortion, _escrowDuration);\n        if (_maxLockDuration < MIN_LOCK_DURATION) {\n            revert SmallMaxLockDuration();\n        }\n        if (_curve.length < 2) {\n            revert ShortCurveError();\n        }\n        for (uint i=0; i < _curve.length; i++) {\n            if (_curve[i] > _maxBonus) {\n                revert MaxBonusError();\n            }\n            curve.push(_curve[i]);\n        }\n        maxBonus = _maxBonus;\n        maxLockDuration = _maxLockDuration;\n        unit = _maxLockDuration / (curve.length - 1);\n    }\n\n    error DepositExpiredError();\n    error ZeroDurationError();\n    error ZeroAmountError();\n    error ShortCurveError();\n\n    event Deposited(uint256 amount, uint256 duration, address indexed receiver, address indexed from);\n    event Withdrawn(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);\n    event LockExtended(uint256 indexed depositId, uint256 duration, address indexed from);\n    event LockIncreased(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);\n    event CurveChanged(address indexed sender);\n\n    /**\n     * @notice Creates a lock with an amount of tokens and mint the corresponding shares.\n     * @dev The function forces the duration to be in between the minimum and maximum\n     * duration if it the duration parameter is outside of those bounds. Uses the multiplier\n     * function to get the amount of shares to mint.\n     * @param _amount uint256 amount of tokens to be deposited\n     * @param _duration uint256 time that the deposit will be locked.\n     * @param _receiver uint256 owner of the lock\n     */\n    function deposit(uint256 _amount, uint256 _duration, address _receiver) external override {\n        if (_amount == 0) {\n            revert ZeroAmountError();\n        }\n        // Don't allow locking > maxLockDuration\n        uint256 duration = _duration.min(maxLockDuration);\n        // Enforce min lockup duration to prevent flash loan or MEV transaction ordering\n        duration = duration.max(MIN_LOCK_DURATION);\n\n        depositToken.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        uint256 mintAmount = _amount * getMultiplier(duration) / 1e18;\n\n        depositsOf[_receiver].push(Deposit({\n            amount: _amount,\n            shareAmount: mintAmount,\n            start: uint64(block.timestamp),\n            end: uint64(block.timestamp) + uint64(duration)\n        }));\n\n        _mint(_receiver, mintAmount);\n        emit Deposited(_amount, duration, _receiver, _msgSender());\n    }\n\n    /**\n     * @notice Withdraws all the tokens from the lock\n     * @dev The lock has to be expired to withdraw the tokens. When the withdrawl happens\n     * the shares minted on the deposit are burnt.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _receiver uint256 owner of the lock\n     */\n    function withdraw(uint256 _depositId, address _receiver) external {\n        if (_depositId >= depositsOf[_msgSender()].length) {\n            revert NonExistingDepositError();\n        }\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n        if (block.timestamp < userDeposit.end) {\n            revert TooSoonError();\n        }\n\n        // remove Deposit\n        depositsOf[_msgSender()][_depositId] = depositsOf[_msgSender()][depositsOf[_msgSender()].length - 1];\n        depositsOf[_msgSender()].pop();\n\n        // burn pool shares\n        _burn(_msgSender(), userDeposit.shareAmount);\n        \n        // return tokens\n        depositToken.safeTransfer(_receiver, userDeposit.amount);\n        emit Withdrawn(_depositId, _receiver, _msgSender(), userDeposit.amount);\n    }\n\n    /**\n     * @notice Adds more time to current lock.\n     * @dev This function extends the duration of a specific lock -deposit- of the sender.\n     * While doing so, it uses the timestamp of the current block and calculates the remaining\n     * time to the end of the lock, and adds the increase duration. This results is a new\n     * duration that can be different to the original duration from the lock one (>, = or <), \n     * and gets multiplied by the correspondant multiplier. The final result can be more, same,\n     * or less shares, which will be minted/burned accordingly.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _increaseDuration uint256 time to be added to the lock meassured from the end of the lock\n     */\n    function extendLock(uint256 _depositId, uint256 _increaseDuration) external {\n        // Check if actually increasing\n        if (_increaseDuration == 0) {\n            revert ZeroDurationError();\n        }\n\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n\n        // Only can extend if it has not expired\n        if (block.timestamp >= userDeposit.end) {\n            revert DepositExpiredError();\n        }\n        \n        // Enforce min increase to prevent flash loan or MEV transaction ordering\n        uint256 increaseDuration = _increaseDuration.max(MIN_LOCK_DURATION);\n        \n        // New duration is the time expiration plus the increase\n        uint256 duration = maxLockDuration.min(uint256(userDeposit.end - block.timestamp) + increaseDuration);\n\n        uint256 mintAmount = userDeposit.amount * getMultiplier(duration) / 1e18;\n\n        // Multiplier curve changes with time, need to check if the mint amount is bigger, equal or smaller than the already minted\n        \n        // If the new amount if bigger mint the difference\n        if (mintAmount > userDeposit.shareAmount) {\n            depositsOf[_msgSender()][_depositId].shareAmount =  mintAmount;\n            _mint(_msgSender(), mintAmount - userDeposit.shareAmount);\n        // If the new amount is less then burn that difference\n        } else if (mintAmount < userDeposit.shareAmount) {\n            depositsOf[_msgSender()][_depositId].shareAmount =  mintAmount;\n            _burn(_msgSender(), userDeposit.shareAmount - mintAmount);\n        }\n\n        depositsOf[_msgSender()][_depositId].start = uint64(block.timestamp);\n        depositsOf[_msgSender()][_depositId].end = uint64(block.timestamp) + uint64(duration);\n        emit LockExtended(_depositId, _increaseDuration, _msgSender());\n    }\n\n    /**\n     * @notice Adds more deposits to current lock.\n     * @dev This function increases the deposit amount of a specific lock -deposit- of the sender.\n     * While doing so, it uses the timestamp of the current block and calculates the remaining\n     * time to the end of the lock. Then it uses this time duration to mint the shares that correspond\n     * to the multiplier of that time and the increase amount being deposited. The result is an increase\n     * both in deposit amount and share amount of the deposit.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _receiver address owner of the lock\n     * @param _increaseAmount uint256 amount of tokens to add to the lock.\n     */\n    function increaseLock(uint256 _depositId, address _receiver, uint256 _increaseAmount) external {\n        // Check if actually increasing\n        if (_increaseAmount == 0) {\n            revert ZeroAmountError();\n        }\n\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n\n        // Only can extend if it has not expired\n        if (block.timestamp >= userDeposit.end) {\n            revert DepositExpiredError();\n        }\n\n        depositToken.safeTransferFrom(_msgSender(), address(this), _increaseAmount);\n\n        // Multiplier should be acording the remaining time to the deposit to end\n        uint256 remainingDuration = uint256(userDeposit.end - block.timestamp);\n\n        uint256 mintAmount = _increaseAmount * getMultiplier(remainingDuration) / 1e18;\n\n        depositsOf[_receiver][_depositId].amount += _increaseAmount;\n        depositsOf[_receiver][_depositId].shareAmount += mintAmount;\n\n        _mint(_receiver, mintAmount);\n        emit LockIncreased(_depositId, _receiver, _msgSender(), _increaseAmount);\n    }\n\n    /**\n     * @notice Gets the multiplier from the curve given a duration.\n     * @dev This function calculates a multiplier by fetching the points in the curve given a duration.\n     * It can achieve this by linearly interpolating between the points of the curve to get a much more\n     * precise result. The unit parameter is related to the maximum possible duration of the deposits \n     * and the amount of points in the curve.\n     * @param _lockDuration uint256 time that the deposit will be locked.\n     * @return uint256 number used to multiply and get amount of shares.\n     */\n    function getMultiplier(uint256 _lockDuration) public view returns(uint256) {\n        // There is no need to check _lockDuration amount, it is always checked before\n        // in the functions that call this function\n\n        // n is the time unit where the lockDuration stands\n        uint n = _lockDuration / unit;\n        // if last point no need to interpolate\n        // trim de curve if it exceedes the maxBonus // TODO check if this is needed\n        if (n == curve.length - 1) {\n            return 1e18 + curve[n];\n        }\n        // linear interpolation between points\n        return 1e18 + curve[n] + (_lockDuration - n * unit) * (curve[n + 1] - curve[n]) / unit;\n    }\n\n    function getTotalDeposit(address _account) public view returns(uint256) {\n        uint256 total;\n        for(uint256 i = 0; i < depositsOf[_account].length; i++) {\n            total += depositsOf[_account][i].amount;\n        }\n\n        return total;\n    }\n\n    function getDepositsOf(address _account) public view returns(Deposit[] memory) {\n        return depositsOf[_account];\n    }\n\n    function getDepositsOfLength(address _account) public view returns(uint256) {\n        return depositsOf[_account].length;\n    }\n\n    function maxBonusError(uint256 _point) internal returns(uint256) {\n        if (_point > maxBonus) {\n            revert MaxBonusError();\n        } else {\n            return _point;\n        }\n    }\n\n    /**\n     * @notice Can set an entire new curve.\n     * @dev This function can change current curve by a completely new. For doing so, it does not\n     * matter if the new curve's length is larger, equal, or shorter because the function manages\n     * all of those cases.\n     * @param _curve uint256 array of the points that compose the curve.\n     */\n    function setCurve(uint256[] calldata _curve) external onlyGov {\n        if (_curve.length < 2) {\n            revert ShortCurveError();\n        }\n        // same length curves\n        if (curve.length == _curve.length) {\n            for (uint i=0; i < curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n        // replacing with a shorter curve\n        } else if (curve.length > _curve.length) {\n            for (uint i=0; i < _curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n            uint initialLength = curve.length;\n            for (uint j=0; j < initialLength - _curve.length; j++) {\n                curve.pop();\n            }\n            unit = maxLockDuration / (curve.length - 1);\n        // replacing with a longer curve\n        } else {\n            for (uint i=0; i < curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n            uint initialLength = curve.length;\n            for (uint j=0; j < _curve.length - initialLength; j++) {\n                curve.push(maxBonusError(_curve[initialLength + j]));\n            }\n            unit = maxLockDuration / (curve.length - 1);\n        }\n        emit CurveChanged(_msgSender());\n    }\n\n    /**\n     * @notice Can set a point of the curve.\n     * @dev This function can replace any point in the curve by inputing the existing index,\n     * add a point to the curve by using the index that equals the amount of points of the curve,\n     * and remove the last point of the curve if an index greated than the length is used. The first\n     * point of the curve index is zero.\n     * @param _newPoint uint256 point to be set.\n     * @param _position uint256 position of the array to be set (zero-based indexing convention).\n     */\n    function setCurvePoint(uint256 _newPoint, uint256 _position) external onlyGov {\n        if (_newPoint > maxBonus) {\n            revert MaxBonusError();\n        }\n        if (_position < curve.length) {\n            curve[_position] = _newPoint;\n        } else if (_position == curve.length) {\n            curve.push(_newPoint);\n        } else {\n            if (curve.length - 1 < 2) {\n                revert ShortCurveError();\n            }\n            curve.pop();\n        }\n        emit CurveChanged(_msgSender());\n    }\n}"
    },
    {
      "filename": "merit-liquidity-mining/contracts/TimeLockPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./base/BasePool.sol\";\nimport \"./interfaces/ITimeLockPool.sol\";\n\ncontract TimeLockPool is BasePool, ITimeLockPool {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    error SmallMaxLockDuration();\n    error NonExistingDepositError();\n    error TooSoonError();\n    error MaxBonusError();\n\n    uint256 public maxBonus;\n    uint256 public maxLockDuration;\n    uint256 public constant MIN_LOCK_DURATION = 10 minutes;\n    \n    uint256[] public curve;\n    uint256 public unit;\n\n    mapping(address => Deposit[]) public depositsOf;\n\n    struct Deposit {\n        uint256 amount;\n        uint256 shareAmount;\n        uint64 start;\n        uint64 end;\n    }\n    function __TimeLockPool_init(\n        string memory _name,\n        string memory _symbol,\n        address _depositToken,\n        address _rewardToken,\n        address _escrowPool,\n        uint256 _escrowPortion,\n        uint256 _escrowDuration,\n        uint256 _maxBonus,\n        uint256 _maxLockDuration,\n        uint256[] memory _curve\n    ) internal onlyInitializing {\n        __BasePool_init(_name, _symbol, _depositToken, _rewardToken, _escrowPool, _escrowPortion, _escrowDuration);\n        if (_maxLockDuration < MIN_LOCK_DURATION) {\n            revert SmallMaxLockDuration();\n        }\n        if (_curve.length < 2) {\n            revert ShortCurveError();\n        }\n        for (uint i=0; i < _curve.length; i++) {\n            if (_curve[i] > _maxBonus) {\n                revert MaxBonusError();\n            }\n            curve.push(_curve[i]);\n        }\n        maxBonus = _maxBonus;\n        maxLockDuration = _maxLockDuration;\n        unit = _maxLockDuration / (curve.length - 1);\n    }\n\n    error DepositExpiredError();\n    error ZeroDurationError();\n    error ZeroAmountError();\n    error ShortCurveError();\n\n    event Deposited(uint256 amount, uint256 duration, address indexed receiver, address indexed from);\n    event Withdrawn(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);\n    event LockExtended(uint256 indexed depositId, uint256 duration, address indexed from);\n    event LockIncreased(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);\n    event CurveChanged(address indexed sender);\n\n    /**\n     * @notice Creates a lock with an amount of tokens and mint the corresponding shares.\n     * @dev The function forces the duration to be in between the minimum and maximum\n     * duration if it the duration parameter is outside of those bounds. Uses the multiplier\n     * function to get the amount of shares to mint.\n     * @param _amount uint256 amount of tokens to be deposited\n     * @param _duration uint256 time that the deposit will be locked.\n     * @param _receiver uint256 owner of the lock\n     */\n    function deposit(uint256 _amount, uint256 _duration, address _receiver) external override {\n        if (_amount == 0) {\n            revert ZeroAmountError();\n        }\n        // Don't allow locking > maxLockDuration\n        uint256 duration = _duration.min(maxLockDuration);\n        // Enforce min lockup duration to prevent flash loan or MEV transaction ordering\n        duration = duration.max(MIN_LOCK_DURATION);\n\n        depositToken.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        uint256 mintAmount = _amount * getMultiplier(duration) / 1e18;\n\n        depositsOf[_receiver].push(Deposit({\n            amount: _amount,\n            shareAmount: mintAmount,\n            start: uint64(block.timestamp),\n            end: uint64(block.timestamp) + uint64(duration)\n        }));"
    }
  ]
}