{
  "Title": "No event registration when changing the parameters of the contract",
  "Content": "##### Description\nhttps://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingLogicAave.sol#L20\nWe recommend adding the `Lend` event logging for the`lend()`function.\n\nhttps://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingLogicAave.sol#L42\nWe recommend adding logging of the `UnLend` event for the`unlend()`function.\n\nhttps://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingLogicCompound.sol#L19\nWe recommend adding the `Lend` event logging for the`lend()`function.\nhttps://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingLogicCompound.sol#L43\nWe recommend adding logging of the `UnLend` event for the`unlend()`function.\n\nhttps://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingManager.sol#L93\nWe recommend adding logging of the `RemoveToken` event to the`removeToken()` function.\n\nhttps://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingManager.sol#L105\nWe recommend adding logging of the `AddToken` event for the`addToken()` function.\n\n##### Recommendation\nWe recommend adding logging.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/callManagers/LendingManager/LendingLogicAave.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/IAaveLendingPool.sol\";\n\ncontract LendingLogicAave is ILendingLogic {\n\n    IAaveLendingPool public lendingPool;\n    uint16 public referralCode;\n\n    constructor(address _lendingPool, uint16 _referralCode) {\n        lendingPool = IAaveLendingPool(_lendingPool);\n        referralCode = _referralCode;\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        address core = lendingPool.core();\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, address(core), 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, address(core), _amount);\n\n        // Deposit into Aave\n        targets[2] = address(lendingPool);\n        data[2] =  abi.encodeWithSelector(lendingPool.deposit.selector, _underlying, _amount, referralCode);\n\n        return(targets, data);\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(IAToken.redeem.selector, _amount);\n        \n        return(targets, data);\n    }\n\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingLogicAave.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/IAaveLendingPool.sol\";\n\ncontract LendingLogicAave is ILendingLogic {\n\n    IAaveLendingPool public lendingPool;\n    uint16 public referralCode;\n\n    constructor(address _lendingPool, uint16 _referralCode) {\n        lendingPool = IAaveLendingPool(_lendingPool);\n        referralCode = _referralCode;\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        address core = lendingPool.core();\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, address(core), 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, address(core), _amount);\n\n        // Deposit into Aave\n        targets[2] = address(lendingPool);\n        data[2] =  abi.encodeWithSelector(lendingPool.deposit.selector, _underlying, _amount, referralCode);\n\n        return(targets, data);\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(IAToken.redeem.selector, _amount);\n        \n        return(targets, data);\n    }\n\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingLogicCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/ICToken.sol\";\n\ncontract LendingLogicCompound is ILendingLogic {\n\n    LendingRegistry public lendingRegistry;\n    bytes32 public constant PROTOCOL = keccak256(abi.encodePacked(\"Compound\"));\n\n    constructor(address _lendingRegistry) {\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n\n        address cToken = lendingRegistry.underlyingToProtocolWrapped(_underlying, PROTOCOL);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, cToken, 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, cToken, _amount);\n\n        // Deposit into Compound\n        targets[2] = cToken;\n\n        data[2] =  abi.encodeWithSelector(ICToken.mint.selector, _amount);\n\n        return(targets, data);\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(ICToken.redeem.selector, _amount);\n        \n        return(targets, data);\n    }\n\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingLogicCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/ICToken.sol\";\n\ncontract LendingLogicCompound is ILendingLogic {\n\n    LendingRegistry public lendingRegistry;\n    bytes32 public constant PROTOCOL = keccak256(abi.encodePacked(\"Compound\"));\n\n    constructor(address _lendingRegistry) {\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n\n        address cToken = lendingRegistry.underlyingToProtocolWrapped(_underlying, PROTOCOL);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, cToken, 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, cToken, _amount);\n\n        // Deposit into Compound\n        targets[2] = cToken;\n\n        data[2] =  abi.encodeWithSelector(ICToken.mint.selector, _amount);\n\n        return(targets, data);\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(ICToken.redeem.selector, _amount);\n        \n        return(targets, data);\n    }\n\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/IExperiPie.sol\";\n\ncontract LendingManager is Ownable {\n    using Math for uint256;\n\n    LendingRegistry public lendingRegistry;\n    IExperiPie public basket;\n\n    event Lend(address indexed underlying, uint256 amount, bytes32 indexed protocol);\n    event UnLend(address indexed wrapped, uint256 amount);\n    /**\n        @notice Constructor\n        @param _lendingRegistry Address of the lendingRegistry contract\n        @param _basket Address of the pool/pie/basket to manage\n    */\n    constructor(address _lendingRegistry, address _basket) public {\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        basket = IExperiPie(_basket);\n    }\n\n    /**\n        @notice Move underlying to a lending protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount of underlying to lend\n        @param _protocol Bytes32 protocol key to lend to\n    */\n    function lend(address _underlying, uint256 _amount, bytes32 _protocol) public onlyOwner {\n        // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_underlying).balanceOf(address(basket)));\n\n        //lend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getLendTXData(_underlying, amount, _protocol);\n\n        basket.callNoValue(_targets, _data);\n\n        // if needed remove underlying from basket\n        removeToken(_underlying);\n\n        // add wrapped token\n        addToken(lendingRegistry.underlyingToProtocolWrapped(_underlying, _protocol));\n\n        emit Lend(_underlying, _amount, _protocol);\n    }\n\n    /**\n        @notice Unlend wrapped token from its lending protocol\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of the wrapped token to unlend\n    */\n    function unlend(address _wrapped, uint256 _amount) public onlyOwner {\n        // unlend token\n         // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_wrapped).balanceOf(address(basket)));\n\n        //Unlend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getUnlendTXData(_wrapped, amount);\n        basket.callNoValue(_targets, _data);\n\n        // if needed add underlying\n        addToken(lendingRegistry.wrappedToUnderlying(_wrapped));\n\n        // if needed remove wrapped\n        removeToken(_wrapped);\n\n        emit UnLend(_wrapped, _amount);\n    }\n\n    /**\n        @notice Unlend and immediately lend in a different protocol\n        @param _wrapped Address of the wrapped token to bounce to another protocol\n        @param _amount Amount of the wrapped token to bounce to the other protocol\n        @param _toProtocol Protocol to deposit bounced tokens in\n    */\n    function bounce(address _wrapped, uint256 _amount, bytes32 _toProtocol) external {\n       unlend(_wrapped, _amount);\n       // Bounce all to new protocol\n       lend(lendingRegistry.wrappedToUnderlying(_wrapped), uint256(-1), _toProtocol);\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if(balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.removeToken.selector, _token), 0);\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if(balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.addToken.selector, _token), 0);\n    }\n \n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/IExperiPie.sol\";\n\ncontract LendingManager is Ownable {\n    using Math for uint256;\n\n    LendingRegistry public lendingRegistry;\n    IExperiPie public basket;\n\n    event Lend(address indexed underlying, uint256 amount, bytes32 indexed protocol);\n    event UnLend(address indexed wrapped, uint256 amount);\n    /**\n        @notice Constructor\n        @param _lendingRegistry Address of the lendingRegistry contract\n        @param _basket Address of the pool/pie/basket to manage\n    */\n    constructor(address _lendingRegistry, address _basket) public {\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        basket = IExperiPie(_basket);\n    }\n\n    /**\n        @notice Move underlying to a lending protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount of underlying to lend\n        @param _protocol Bytes32 protocol key to lend to\n    */\n    function lend(address _underlying, uint256 _amount, bytes32 _protocol) public onlyOwner {\n        // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_underlying).balanceOf(address(basket)));\n\n        //lend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getLendTXData(_underlying, amount, _protocol);\n\n        basket.callNoValue(_targets, _data);\n\n        // if needed remove underlying from basket\n        removeToken(_underlying);\n\n        // add wrapped token\n        addToken(lendingRegistry.underlyingToProtocolWrapped(_underlying, _protocol));\n\n        emit Lend(_underlying, _amount, _protocol);\n    }\n\n    /**\n        @notice Unlend wrapped token from its lending protocol\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of the wrapped token to unlend\n    */\n    function unlend(address _wrapped, uint256 _amount) public onlyOwner {\n        // unlend token\n         // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_wrapped).balanceOf(address(basket)));\n\n        //Unlend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getUnlendTXData(_wrapped, amount);\n        basket.callNoValue(_targets, _data);\n\n        // if needed add underlying\n        addToken(lendingRegistry.wrappedToUnderlying(_wrapped));\n\n        // if needed remove wrapped\n        removeToken(_wrapped);\n\n        emit UnLend(_wrapped, _amount);\n    }\n\n    /**\n        @notice Unlend and immediately lend in a different protocol\n        @param _wrapped Address of the wrapped token to bounce to another protocol\n        @param _amount Amount of the wrapped token to bounce to the other protocol\n        @param _toProtocol Protocol to deposit bounced tokens in\n    */\n    function bounce(address _wrapped, uint256 _amount, bytes32 _toProtocol) external {\n       unlend(_wrapped, _amount);\n       // Bounce all to new protocol\n       lend(lendingRegistry.wrappedToUnderlying(_wrapped), uint256(-1), _toProtocol);\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if(balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.removeToken.selector, _token), 0);\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if(balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.addToken.selector, _token), 0);\n    }\n \n}"
    }
  ]
}