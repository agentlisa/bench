{
  "Title": "[L-05] Reserve ratio can be set to 100%",
  "Content": "\n[MarketControllerFactory Line 85](https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/WildcatMarketControllerFactory.sol#L85)\n\n### Issue Description\n\nThe protocol allows borrowers to set a reserve ratio that they must maintain to avoid being charged a delinquency fee. In the current implementation, this parameter can be set to 100%, rendering the entire functionality redundant, as borrowers would not be able to withdraw any funds from the market. Additionally,  the market would fall into delinquency immediately after the start.\n\n### Recommended Mitigation Steps\n\nTo mitigate this issue, modify the check on `maximumReserveRatioBips` to revert if `constraints.maximumReserveRatioBips >= 10000`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/WildcatMarketControllerFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './interfaces/IWildcatMarketController.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './market/WildcatMarket.sol';\nimport './WildcatMarketController.sol';\n\ncontract WildcatMarketControllerFactory {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  event NewController(address borrower, address controller, string namePrefix, string symbolPrefix);\n  event UpdateProtocolFeeConfiguration(\n    address feeRecipient,\n    uint16 protocolFeeBips,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  );\n\n  error NotRegisteredBorrower();\n  error InvalidProtocolFeeConfiguration();\n  error CallerNotArchControllerOwner();\n  error InvalidConstraints();\n  error ControllerAlreadyDeployed();\n\n  // Returns immutable arch-controller\n  IWildcatArchController public immutable archController;\n\n  // Returns sentinel used by controller\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  address public immutable controllerInitCodeStorage;\n\n  uint256 public immutable controllerInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  ProtocolFeeConfiguration internal _protocolFeeConfiguration;\n\n  EnumerableSet.AddressSet internal _deployedControllers;\n\n  modifier onlyArchControllerOwner() {\n    if (msg.sender != archController.owner()) {\n      revert CallerNotArchControllerOwner();\n    }\n    _;\n  }\n\n  constructor(\n    address _archController,\n    address _sentinel,\n    MarketParameterConstraints memory constraints\n  ) {\n    archController = IWildcatArchController(_archController);\n    sentinel = _sentinel;\n    if (\n      constraints.minimumAnnualInterestBips > constraints.maximumAnnualInterestBips ||\n      constraints.maximumAnnualInterestBips > 10000 ||\n      constraints.minimumDelinquencyFeeBips > constraints.maximumDelinquencyFeeBips ||\n      constraints.maximumDelinquencyFeeBips > 10000 ||\n      constraints.minimumReserveRatioBips > constraints.maximumReserveRatioBips ||\n      constraints.maximumReserveRatioBips > 10000 ||\n      constraints.minimumDelinquencyGracePeriod > constraints.maximumDelinquencyGracePeriod ||\n      constraints.minimumWithdrawalBatchDuration > constraints.maximumWithdrawalBatchDuration\n    ) {\n      revert InvalidConstraints();\n    }\n    MinimumDelinquencyGracePeriod = constraints.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = constraints.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = constraints.minimumReserveRatioBips;\n    MaximumReserveRatioBips = constraints.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = constraints.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = constraints.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = constraints.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = constraints.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = constraints.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = constraints.maximumAnnualInterestBips;\n\n    (controllerInitCodeStorage, controllerInitCodeHash) = _storeControllerInitCode();\n    (marketInitCodeStorage, marketInitCodeHash) = _storeMarketInitCode();\n  }\n\n  function _storeControllerInitCode()\n    internal\n    virtual\n    returns (address initCodeStorage, uint256 initCodeHash)\n  {\n    bytes memory controllerInitCode = type(WildcatMarketController).creationCode;\n    initCodeHash = uint256(keccak256(controllerInitCode));\n    initCodeStorage = LibStoredInitCode.deployInitCode(controllerInitCode);\n  }\n\n  function _storeMarketInitCode()\n    internal\n    virtual\n    returns (address initCodeStorage, uint256 initCodeHash)\n  {\n    bytes memory marketInitCode = type(WildcatMarket).creationCode;\n    initCodeHash = uint256(keccak256(marketInitCode));\n    initCodeStorage = LibStoredInitCode.deployInitCode(marketInitCode);\n  }\n\n  function isDeployedController(address controller) external view returns (bool) {\n    return _deployedControllers.contains(controller);\n  }\n\n  function getDeployedControllersCount() external view returns (uint256) {\n    return _deployedControllers.length();\n  }\n\n  function getDeployedControllers() external view returns (address[] memory) {\n    return _deployedControllers.values();\n  }\n\n  function getDeployedControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _deployedControllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _deployedControllers.at(start + i);\n    }\n  }\n\n  /**\n   * @dev Returns protocol fee configuration for new markets.\n   *\n   *      These can be updated by the arch-controller owner but\n   *      `protocolFeeBips` and `feeRecipient` are immutable once\n   *      a market is deployed.\n   *\n   * @return feeRecipient         feeRecipient to use in new markets\n   * @return originationFeeAsset  Asset used to pay fees for new market\n   *                              deployments\n   * @return originationFeeAmount Amount of originationFeeAsset paid\n   *                              for new market deployments\n   * @return protocolFeeBips      protocolFeeBips to use in new markets\n   */\n  function getProtocolFeeConfiguration()\n    external\n    view\n    returns (\n      address feeRecipient,\n      address originationFeeAsset,\n      uint80 originationFeeAmount,\n      uint16 protocolFeeBips\n    )\n  {\n    return (\n      _protocolFeeConfiguration.feeRecipient,\n      _protocolFeeConfiguration.originationFeeAsset,\n      _protocolFeeConfiguration.originationFeeAmount,\n      _protocolFeeConfiguration.protocolFeeBips\n    );\n  }\n\n  /**\n   * @dev Sets protocol fee configuration for new market deployments via\n   *      controllers deployed by this factory.\n   *\n   *      If caller is not `archController.owner()`, reverts with\n   *      `NotArchControllerOwner`.\n   *\n   *      Revert with `InvalidProtocolFeeConfiguration` if:\n   *      - `protocolFeeBips > 0 && feeRecipient == address(0)`\n   *      - OR `originationFeeAmount > 0 && originationFeeAsset == address(0)`\n   *      - OR `originationFeeAmount > 0 && feeRecipient == address(0)`\n   */\n  function setProtocolFeeConfiguration(\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external onlyArchControllerOwner {\n    bool hasOriginationFee = originationFeeAmount > 0;\n    bool nullFeeRecipient = feeRecipient == address(0);\n    bool nullOriginationFeeAsset = originationFeeAsset == address(0);\n    if (\n      (protocolFeeBips > 0 && nullFeeRecipient) ||\n      (hasOriginationFee && nullFeeRecipient) ||\n      (hasOriginationFee && nullOriginationFeeAsset)\n    ) {\n      revert InvalidProtocolFeeConfiguration();\n    }\n    _protocolFeeConfiguration = ProtocolFeeConfiguration({\n      feeRecipient: feeRecipient,\n      originationFeeAsset: originationFeeAsset,\n      originationFeeAmount: originationFeeAmount,\n      protocolFeeBips: protocolFeeBips\n    });\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            Controller Deployment                           */\n  /* -------------------------------------------------------------------------- */\n\n  address internal _tmpMarketBorrowerParameter = address(1);\n\n  function getMarketControllerParameters()\n    external\n    view\n    virtual\n    returns (MarketControllerParameters memory parameters)\n  {\n    parameters.archController = address(archController);\n    parameters.borrower = _tmpMarketBorrowerParameter;\n    parameters.sentinel = sentinel;\n    parameters.marketInitCodeStorage = marketInitCodeStorage;\n    parameters.marketInitCodeHash = marketInitCodeHash;\n    parameters.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    parameters.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    parameters.minimumReserveRatioBips = MinimumReserveRatioBips;\n    parameters.maximumReserveRatioBips = MaximumReserveRatioBips;\n    parameters.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    parameters.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    parameters.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    parameters.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    parameters.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    parameters.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarketController`\n   *      unique to the borrower and registers it with the arch-controller.\n   *\n   *      If a controller is already deployed for the borrower, reverts\n   *      with `ControllerAlreadyDeployed`.\n   *\n   *\t  If `archController.isRegisteredBorrower(msg.sender)` returns false\n   *      reverts with `NotRegisteredBorrower`.\n   *\n   *      Calls `archController.registerController(controller)` and emits\n   *      `NewController(borrower, controller)`.\n   */\n  function deployController() public returns (address controller) {\n    if (!archController.isRegisteredBorrower(msg.sender)) {\n      revert NotRegisteredBorrower();\n    }\n    _tmpMarketBorrowerParameter = msg.sender;\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n    controller = LibStoredInitCode.calculateCreate2Address(\n      ownCreate2Prefix,\n      salt,\n      controllerInitCodeHash\n    );\n    if (controller.codehash != bytes32(0)) {\n      revert ControllerAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(controllerInitCodeStorage, salt);\n    _tmpMarketBorrowerParameter = address(1);\n    archController.registerController(controller);\n    _deployedControllers.add(controller);\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarketController`\n   *      unique to the borrower and registers it with the arch-controller,\n   *      then deploys a new market through the controller.\n   *\n   *      If a controller is already deployed for the borrower, reverts\n   *      with `ControllerAlreadyDeployed`.\n   *\n   *\t  If `archController.isRegisteredBorrower(msg.sender)` returns false\n   *\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      Calls `archController.registerController(controller)` and emits\n   * \t  `NewController(borrower, controller, namePrefix, symbolPrefix)`.\n   */\n  function deployControllerAndMarket(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    address asset,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address controller, address market) {\n    controller = deployController();\n    market = IWildcatMarketController(controller).deployMarket(\n      asset,\n      namePrefix,\n      symbolPrefix,\n      maxTotalSupply,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n  }\n\n  function computeControllerAddress(address borrower) external view returns (address) {\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(borrower)));\n    return\n      LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, controllerInitCodeHash);\n  }\n}"
    }
  ]
}