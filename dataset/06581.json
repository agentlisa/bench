{
  "Title": "[L-08] `setOperator` and `setRewardsRecipient` don't check for `address(0)`",
  "Content": "\n- https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L78\n- https://github.com/code-423n4/2023-05-xeth/blob/main/src/CVXStaker.sol#L89\n\nCheck that the arguments are not `address(0)`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-xeth",
  "Code": [
    {
      "filename": "src/CVXStaker.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/Ownable.sol\";\nimport \"./interfaces/ICurvePool.sol\";\nimport \"./interfaces/ICVXBooster.sol\";\nimport \"./interfaces/IBaseRewardPool.sol\";\n\ncontract CVXStaker is Ownable {\n    using SafeERC20 for IERC20;\n\n    address public operator;\n    // @notice CLP tokens for curve pool\n    IERC20 public immutable clpToken;\n    CvxPoolInfo public cvxPoolInfo;\n    // @notice Cvx booster\n    ICVXBooster public immutable booster;\n\n    address public rewardsRecipient;\n    address[] public rewardTokens;\n\n    struct CvxPoolInfo {\n        address token;\n        address rewards;\n        uint32 pId;\n    }\n\n    struct Position {\n        uint256 staked;\n        uint256 earned;\n    }\n\n    error NotOperator();\n    error NotOperatorOrOwner();\n\n    event SetCvxPoolInfo(uint32 indexed pId, address token, address rewards);\n    event SetOperator(address operator);\n    event RecoveredToken(address token, address to, uint256 amount);\n    event SetRewardsRecipient(address recipient);\n\n    constructor(\n        address _operator,\n        IERC20 _clpToken,\n        ICVXBooster _booster,\n        address[] memory _rewardTokens\n    ) {\n        operator = _operator;\n        clpToken = _clpToken;\n        booster = _booster;\n        rewardTokens = _rewardTokens;\n    }\n\n    /**\n     * @dev Sets the CVX pool information.\n     * @param _pId The pool ID of the CVX pool.\n     * @param _token The address of the CLP token.\n     * @param _rewards The address of the CVX reward pool.\n     * Only the contract owner can call this function.\n     */\n    function setCvxPoolInfo(\n        uint32 _pId,\n        address _token,\n        address _rewards\n    ) external onlyOwner {\n        cvxPoolInfo.pId = _pId;\n        cvxPoolInfo.token = _token;\n        cvxPoolInfo.rewards = _rewards;\n\n        emit SetCvxPoolInfo(_pId, _token, _rewards);\n    }\n\n    /**\n     * @notice Set operator\n     * @param _operator New operator\n     */\n    function setOperator(address _operator) external onlyOwner {\n        operator = _operator;\n\n        emit SetOperator(_operator);\n    }\n\n    /**\n     * @dev Sets the address of the rewards recipient.\n     * @param _recipeint The address of the rewards recipient.\n     * Only the contract owner can call this function.\n     */\n    function setRewardsRecipient(address _recipeint) external onlyOwner {\n        rewardsRecipient = _recipeint;\n\n        emit SetRewardsRecipient(_recipeint);\n    }\n\n    /**\n     * @notice Recover any token from AMO\n     * @param token Token to recover\n     * @param to Recipient address\n     * @param amount Amount to recover\n     */\n    function recoverToken(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n\n        emit RecoveredToken(token, to, amount);\n    }\n\n    /**\n     * @dev Checks whether the CVX pool is currently shutdown.\n     * @return A boolean indicating whether the CVX pool is currently shutdown.\n     */\n    function isCvxShutdown() public view returns (bool) {\n        // It's not necessary to check that the booster itself is shutdown, as that can only\n        // be shutdown once all the pools are shutdown - see Cvx BoosterOwner.shutdownSystem()\n        return booster.poolInfo(cvxPoolInfo.pId).shutdown;\n    }\n\n    /**\n     * @dev Deposits a specified amount of CLP tokens into the booster and stakes them in the reward pool.\n     * @param amount The amount of CLP tokens to deposit and stake.\n     * Only the operator can call this function.\n     */\n    function depositAndStake(uint256 amount) external onlyOperator {\n        // Only deposit if the aura pool is open. Otherwise leave the CLP Token in this contract.\n        if (!isCvxShutdown()) {\n            clpToken.safeIncreaseAllowance(address(booster), amount);\n            booster.deposit(cvxPoolInfo.pId, amount, true);\n        }\n    }\n\n    /**\n     * @dev Withdraws a specified amount of staked tokens from the reward pool and unwraps them to the original tokens.\n     * @param amount The amount of tokens to withdraw and unwrap.\n     * @param claim A boolean indicating whether to claim rewards before withdrawing.\n     * @param to The address to receive the unwrapped tokens.\n     * If set to 0x0, the tokens will remain in the contract.\n     * Only the contract owner or operator can call this function.\n     */\n    function withdrawAndUnwrap(\n        uint256 amount,\n        bool claim,\n        address to\n    ) external onlyOperatorOrOwner {\n        // Optimistically use CLP balance in this contract, and then try and unstake any remaining\n        uint256 clpBalance = clpToken.balanceOf(address(this));\n        uint256 toUnstake = (amount < clpBalance) ? 0 : amount - clpBalance;\n        if (toUnstake > 0) {\n            IBaseRewardPool(cvxPoolInfo.rewards).withdrawAndUnwrap(\n                toUnstake,\n                claim\n            );\n        }\n\n        if (to != address(0)) {\n            // unwrapped amount is 1 to 1\n            clpToken.safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @dev Withdraws all staked tokens from the reward pool and unwraps them to the original tokens.\n     * @param claim A boolean indicating whether to claim rewards before withdrawing.\n     * @param sendToOperator A boolean indicating whether to send the unwrapped tokens to the operator.\n     * If false, the tokens will remain in the contract.\n     * Only the contract owner can call this function.\n     */\n    function withdrawAllAndUnwrap(\n        bool claim,\n        bool sendToOperator\n    ) external onlyOwner {\n        IBaseRewardPool(cvxPoolInfo.rewards).withdrawAllAndUnwrap(claim);\n        if (sendToOperator) {\n            uint256 totalBalance = clpToken.balanceOf(address(this));\n            clpToken.safeTransfer(operator, totalBalance);\n        }\n    }\n\n    /**\n     * @dev Claims the rewards and transfers them to the rewards recipient, if specified.\n     * @param claimExtras A boolean indicating whether to claim extra rewards.\n     */\n    function getReward(bool claimExtras) external {\n        IBaseRewardPool(cvxPoolInfo.rewards).getReward(\n            address(this),\n            claimExtras\n        );\n        if (rewardsRecipient != address(0)) {\n            for (uint i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = IERC20(rewardTokens[i]).balanceOf(\n                    address(this)\n                );\n                IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the current staked balance of the contract.\n     * @return balance The current staked balance.\n     */\n    function stakedBalance() public view returns (uint256 balance) {\n        balance = IBaseRewardPool(cvxPoolInfo.rewards).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Returns the amount of earned rewards by the contract.\n     * @return earnedRewards The amount of earned rewards.\n     */\n    function earned() public view returns (uint256 earnedRewards) {\n        earnedRewards = IBaseRewardPool(cvxPoolInfo.rewards).earned(\n            address(this)\n        );\n    }\n\n    /**\n     * @notice show staked position and earned rewards\n     */\n    function showPositions() external view returns (Position memory position) {\n        position.staked = stakedBalance();\n        position.earned = earned();\n    }\n\n    /// @dev Modifier to restrict function execution to only the contract operator.\n    /// @notice Throws a custom exception `NotOperator` if the caller is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert NotOperator();\n        }\n        _;\n    }\n\n    /// @dev Modifier to restrict function execution to only the contract operator or owner.\n    /// @notice Throws a custom exception `NotOperatorOrOwner` if the caller is neither the operator nor the owner.\n    modifier onlyOperatorOrOwner() {\n        if (msg.sender != operator && msg.sender != owner()) {\n            revert NotOperatorOrOwner();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/CVXStaker.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/Ownable.sol\";\nimport \"./interfaces/ICurvePool.sol\";\nimport \"./interfaces/ICVXBooster.sol\";\nimport \"./interfaces/IBaseRewardPool.sol\";\n\ncontract CVXStaker is Ownable {\n    using SafeERC20 for IERC20;\n\n    address public operator;\n    // @notice CLP tokens for curve pool\n    IERC20 public immutable clpToken;\n    CvxPoolInfo public cvxPoolInfo;\n    // @notice Cvx booster\n    ICVXBooster public immutable booster;\n\n    address public rewardsRecipient;\n    address[] public rewardTokens;\n\n    struct CvxPoolInfo {\n        address token;\n        address rewards;\n        uint32 pId;\n    }\n\n    struct Position {\n        uint256 staked;\n        uint256 earned;\n    }\n\n    error NotOperator();\n    error NotOperatorOrOwner();\n\n    event SetCvxPoolInfo(uint32 indexed pId, address token, address rewards);\n    event SetOperator(address operator);\n    event RecoveredToken(address token, address to, uint256 amount);\n    event SetRewardsRecipient(address recipient);\n\n    constructor(\n        address _operator,\n        IERC20 _clpToken,\n        ICVXBooster _booster,\n        address[] memory _rewardTokens\n    ) {\n        operator = _operator;\n        clpToken = _clpToken;\n        booster = _booster;\n        rewardTokens = _rewardTokens;\n    }\n\n    /**\n     * @dev Sets the CVX pool information.\n     * @param _pId The pool ID of the CVX pool.\n     * @param _token The address of the CLP token.\n     * @param _rewards The address of the CVX reward pool.\n     * Only the contract owner can call this function.\n     */\n    function setCvxPoolInfo(\n        uint32 _pId,\n        address _token,\n        address _rewards\n    ) external onlyOwner {\n        cvxPoolInfo.pId = _pId;\n        cvxPoolInfo.token = _token;\n        cvxPoolInfo.rewards = _rewards;\n\n        emit SetCvxPoolInfo(_pId, _token, _rewards);\n    }\n\n    /**\n     * @notice Set operator\n     * @param _operator New operator\n     */\n    function setOperator(address _operator) external onlyOwner {\n        operator = _operator;\n\n        emit SetOperator(_operator);\n    }\n\n    /**\n     * @dev Sets the address of the rewards recipient.\n     * @param _recipeint The address of the rewards recipient.\n     * Only the contract owner can call this function.\n     */\n    function setRewardsRecipient(address _recipeint) external onlyOwner {\n        rewardsRecipient = _recipeint;\n\n        emit SetRewardsRecipient(_recipeint);\n    }\n\n    /**\n     * @notice Recover any token from AMO\n     * @param token Token to recover\n     * @param to Recipient address\n     * @param amount Amount to recover\n     */\n    function recoverToken(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n\n        emit RecoveredToken(token, to, amount);\n    }\n\n    /**\n     * @dev Checks whether the CVX pool is currently shutdown.\n     * @return A boolean indicating whether the CVX pool is currently shutdown.\n     */\n    function isCvxShutdown() public view returns (bool) {\n        // It's not necessary to check that the booster itself is shutdown, as that can only\n        // be shutdown once all the pools are shutdown - see Cvx BoosterOwner.shutdownSystem()\n        return booster.poolInfo(cvxPoolInfo.pId).shutdown;\n    }\n\n    /**\n     * @dev Deposits a specified amount of CLP tokens into the booster and stakes them in the reward pool.\n     * @param amount The amount of CLP tokens to deposit and stake.\n     * Only the operator can call this function.\n     */\n    function depositAndStake(uint256 amount) external onlyOperator {\n        // Only deposit if the aura pool is open. Otherwise leave the CLP Token in this contract.\n        if (!isCvxShutdown()) {\n            clpToken.safeIncreaseAllowance(address(booster), amount);\n            booster.deposit(cvxPoolInfo.pId, amount, true);\n        }\n    }\n\n    /**\n     * @dev Withdraws a specified amount of staked tokens from the reward pool and unwraps them to the original tokens.\n     * @param amount The amount of tokens to withdraw and unwrap.\n     * @param claim A boolean indicating whether to claim rewards before withdrawing.\n     * @param to The address to receive the unwrapped tokens.\n     * If set to 0x0, the tokens will remain in the contract.\n     * Only the contract owner or operator can call this function.\n     */\n    function withdrawAndUnwrap(\n        uint256 amount,\n        bool claim,\n        address to\n    ) external onlyOperatorOrOwner {\n        // Optimistically use CLP balance in this contract, and then try and unstake any remaining\n        uint256 clpBalance = clpToken.balanceOf(address(this));\n        uint256 toUnstake = (amount < clpBalance) ? 0 : amount - clpBalance;\n        if (toUnstake > 0) {\n            IBaseRewardPool(cvxPoolInfo.rewards).withdrawAndUnwrap(\n                toUnstake,\n                claim\n            );\n        }\n\n        if (to != address(0)) {\n            // unwrapped amount is 1 to 1\n            clpToken.safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @dev Withdraws all staked tokens from the reward pool and unwraps them to the original tokens.\n     * @param claim A boolean indicating whether to claim rewards before withdrawing.\n     * @param sendToOperator A boolean indicating whether to send the unwrapped tokens to the operator.\n     * If false, the tokens will remain in the contract.\n     * Only the contract owner can call this function.\n     */\n    function withdrawAllAndUnwrap(\n        bool claim,\n        bool sendToOperator\n    ) external onlyOwner {\n        IBaseRewardPool(cvxPoolInfo.rewards).withdrawAllAndUnwrap(claim);\n        if (sendToOperator) {\n            uint256 totalBalance = clpToken.balanceOf(address(this));\n            clpToken.safeTransfer(operator, totalBalance);\n        }\n    }\n\n    /**\n     * @dev Claims the rewards and transfers them to the rewards recipient, if specified.\n     * @param claimExtras A boolean indicating whether to claim extra rewards.\n     */\n    function getReward(bool claimExtras) external {\n        IBaseRewardPool(cvxPoolInfo.rewards).getReward(\n            address(this),\n            claimExtras\n        );\n        if (rewardsRecipient != address(0)) {\n            for (uint i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = IERC20(rewardTokens[i]).balanceOf(\n                    address(this)\n                );\n                IERC20(rewardTokens[i]).safeTransfer(rewardsRecipient, balance);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the current staked balance of the contract.\n     * @return balance The current staked balance.\n     */\n    function stakedBalance() public view returns (uint256 balance) {\n        balance = IBaseRewardPool(cvxPoolInfo.rewards).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Returns the amount of earned rewards by the contract.\n     * @return earnedRewards The amount of earned rewards.\n     */\n    function earned() public view returns (uint256 earnedRewards) {\n        earnedRewards = IBaseRewardPool(cvxPoolInfo.rewards).earned(\n            address(this)\n        );\n    }\n\n    /**\n     * @notice show staked position and earned rewards\n     */\n    function showPositions() external view returns (Position memory position) {\n        position.staked = stakedBalance();\n        position.earned = earned();\n    }\n\n    /// @dev Modifier to restrict function execution to only the contract operator.\n    /// @notice Throws a custom exception `NotOperator` if the caller is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert NotOperator();\n        }\n        _;\n    }\n\n    /// @dev Modifier to restrict function execution to only the contract operator or owner.\n    /// @notice Throws a custom exception `NotOperatorOrOwner` if the caller is neither the operator nor the owner.\n    modifier onlyOperatorOrOwner() {\n        if (msg.sender != operator && msg.sender != owner()) {\n            revert NotOperatorOrOwner();\n        }\n        _;\n    }\n}"
    }
  ]
}