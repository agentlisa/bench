{
  "Title": "Unused keys trimming doesn't remove keys and signatures from storage",
  "Content": "##### Description\nThis function \nhttps://github.com/lidofinance/lido-dao/blob/5b449b740cddfbef5c107505677e6a576e2c2b69/contracts/0.4.24/nos/NodeOperatorsRegistry.sol#L212 \nleave keys data in storage. \nIt may be dangerous.\n##### Recommendation\nWe recommend to remove properly.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/0.4.24/nos/NodeOperatorsRegistry.sol",
      "content": "// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"@aragon/os/contracts/common/IsContract.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath64.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"../interfaces/INodeOperatorsRegistry.sol\";\nimport \"../lib/MemUtils.sol\";\n\n\n/**\n  * @title Node Operator registry implementation\n  *\n  * See the comment of `INodeOperatorsRegistry`.\n  *\n  * NOTE: the code below assumes moderate amount of node operators, e.g. up to 50.\n  */\ncontract NodeOperatorsRegistry is INodeOperatorsRegistry, IsContract, AragonApp {\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n    using UnstructuredStorage for bytes32;\n\n    /// ACL\n    bytes32 constant public MANAGE_SIGNING_KEYS = keccak256(\"MANAGE_SIGNING_KEYS\");\n    bytes32 constant public ADD_NODE_OPERATOR_ROLE = keccak256(\"ADD_NODE_OPERATOR_ROLE\");\n    bytes32 constant public SET_NODE_OPERATOR_ACTIVE_ROLE = keccak256(\"SET_NODE_OPERATOR_ACTIVE_ROLE\");\n    bytes32 constant public SET_NODE_OPERATOR_NAME_ROLE = keccak256(\"SET_NODE_OPERATOR_NAME_ROLE\");\n    bytes32 constant public SET_NODE_OPERATOR_ADDRESS_ROLE = keccak256(\"SET_NODE_OPERATOR_ADDRESS_ROLE\");\n    bytes32 constant public SET_NODE_OPERATOR_LIMIT_ROLE = keccak256(\"SET_NODE_OPERATOR_LIMIT_ROLE\");\n    bytes32 constant public REPORT_STOPPED_VALIDATORS_ROLE = keccak256(\"REPORT_STOPPED_VALIDATORS_ROLE\");\n\n    uint256 constant public PUBKEY_LENGTH = 48;\n    uint256 constant public SIGNATURE_LENGTH = 96;\n\n    uint256 internal constant UINT64_MAX = uint256(uint64(-1));\n\n    bytes32 internal constant SIGNING_KEYS_MAPPING_NAME = keccak256(\"lido.NodeOperatorsRegistry.signingKeysMappingName\");\n\n\n    /// @dev Node Operator parameters and internal state\n    struct NodeOperator {\n        bool active;    // a flag indicating if the operator can participate in further staking and reward distribution\n        address rewardAddress;  // Ethereum 1 address which receives steth rewards for this operator\n        string name;    // human-readable name\n        uint64 stakingLimit;    // the maximum number of validators to stake for this operator\n        uint64 stoppedValidators;   // number of signing keys which stopped validation (e.g. were slashed)\n\n        uint64 totalSigningKeys;    // total amount of signing keys of this operator\n        uint64 usedSigningKeys;     // number of signing keys of this operator which were used in deposits to the Ethereum 2\n    }\n\n    /// @dev Memory cache entry used in the assignNextKeys function\n    struct DepositLookupCacheEntry {\n        // Makes no sense to pack types since reading memory is as fast as any op\n        uint256 id;\n        uint256 stakingLimit;\n        uint256 stoppedValidators;\n        uint256 totalSigningKeys;\n        uint256 usedSigningKeys;\n        uint256 initialUsedSigningKeys;\n    }\n\n    /// @dev Mapping of all node operators. Mapping is used to be able to extend the struct.\n    mapping(uint256 => NodeOperator) internal operators;\n\n    // @dev Total number of operators\n    bytes32 internal constant TOTAL_OPERATORS_COUNT_POSITION = keccak256(\"lido.NodeOperatorsRegistry.totalOperatorsCount\");\n\n    // @dev Cached number of active operators\n    bytes32 internal constant ACTIVE_OPERATORS_COUNT_POSITION = keccak256(\"lido.NodeOperatorsRegistry.activeOperatorsCount\");\n\n    /// @dev link to the Lido contract\n    bytes32 internal constant LIDO_POSITION = keccak256(\"lido.NodeOperatorsRegistry.lido\");\n\n    /// @dev link to the index of operations with keys\n    bytes32 internal constant KEYS_OP_INDEX_POSITION = keccak256(\"lido.NodeOperatorsRegistry.keysOpIndex\");\n\n\n    modifier onlyLido() {\n        require(msg.sender == LIDO_POSITION.getStorageAddress(), \"APP_AUTH_FAILED\");\n        _;\n    }\n\n    modifier validAddress(address _a) {\n        require(_a != address(0), \"EMPTY_ADDRESS\");\n        _;\n    }\n\n    modifier operatorExists(uint256 _id) {\n        require(_id < getNodeOperatorsCount(), \"NODE_OPERATOR_NOT_FOUND\");\n        _;\n    }\n\n    function initialize(address _lido) public onlyInit {\n        TOTAL_OPERATORS_COUNT_POSITION.setStorageUint256(0);\n        ACTIVE_OPERATORS_COUNT_POSITION.setStorageUint256(0);\n        KEYS_OP_INDEX_POSITION.setStorageUint256(0);\n        LIDO_POSITION.setStorageAddress(_lido);\n        initialized();\n    }\n\n    /**\n      * @notice Add node operator named `_name` with reward address `_rewardAddress` and staking limit = 0\n      * @param _name Human-readable name\n      * @param _rewardAddress Ethereum 1 address which receives stETH rewards for this operator\n      * @return a unique key of the added operator\n      */\n    function addNodeOperator(string _name, address _rewardAddress) external\n        auth(ADD_NODE_OPERATOR_ROLE)\n        validAddress(_rewardAddress)\n        returns (uint256 id)\n    {\n        id = getNodeOperatorsCount();\n        TOTAL_OPERATORS_COUNT_POSITION.setStorageUint256(id.add(1));\n\n        NodeOperator storage operator = operators[id];\n\n        uint256 activeOperatorsCount = getActiveNodeOperatorsCount();\n        ACTIVE_OPERATORS_COUNT_POSITION.setStorageUint256(activeOperatorsCount.add(1));\n\n        operator.active = true;\n        operator.name = _name;\n        operator.rewardAddress = _rewardAddress;\n        operator.stakingLimit = 0;\n\n        emit NodeOperatorAdded(id, _name, _rewardAddress, 0);\n\n        return id;\n    }\n\n    /**\n      * @notice `_active ? 'Enable' : 'Disable'` the node operator #`_id`\n      */\n    function setNodeOperatorActive(uint256 _id, bool _active) external\n        authP(SET_NODE_OPERATOR_ACTIVE_ROLE, arr(_id, _active ? uint256(1) : uint256(0)))\n        operatorExists(_id)\n    {\n        _increaseKeysOpIndex();\n        if (operators[_id].active != _active) {\n            uint256 activeOperatorsCount = getActiveNodeOperatorsCount();\n            if (_active)\n                ACTIVE_OPERATORS_COUNT_POSITION.setStorageUint256(activeOperatorsCount.add(1));\n            else\n                ACTIVE_OPERATORS_COUNT_POSITION.setStorageUint256(activeOperatorsCount.sub(1));\n        }\n\n        operators[_id].active = _active;\n\n        emit NodeOperatorActiveSet(_id, _active);\n    }\n\n    /**\n      * @notice Change human-readable name of the node operator #`_id` to `_name`\n      */\n    function setNodeOperatorName(uint256 _id, string _name) external\n        authP(SET_NODE_OPERATOR_NAME_ROLE, arr(_id))\n        operatorExists(_id)\n    {\n        operators[_id].name = _name;\n        emit NodeOperatorNameSet(_id, _name);\n    }\n\n    /**\n      * @notice Change reward address of the node operator #`_id` to `_rewardAddress`\n      */\n    function setNodeOperatorRewardAddress(uint256 _id, address _rewardAddress) external\n        authP(SET_NODE_OPERATOR_ADDRESS_ROLE, arr(_id, uint256(_rewardAddress)))\n        operatorExists(_id)\n        validAddress(_rewardAddress)\n    {\n        operators[_id].rewardAddress = _rewardAddress;\n        emit NodeOperatorRewardAddressSet(_id, _rewardAddress);\n    }\n\n    /**\n      * @notice Set the maximum number of validators to stake for the node operator #`_id` to `_stakingLimit`\n      */\n    function setNodeOperatorStakingLimit(uint256 _id, uint64 _stakingLimit) external\n        authP(SET_NODE_OPERATOR_LIMIT_ROLE, arr(_id, uint256(_stakingLimit)))\n        operatorExists(_id)\n    {\n        _increaseKeysOpIndex();\n        operators[_id].stakingLimit = _stakingLimit;\n        emit NodeOperatorStakingLimitSet(_id, _stakingLimit);\n    }\n\n    /**\n      * @notice Report `_stoppedIncrement` more stopped validators of the node operator #`_id`\n      */\n    function reportStoppedValidators(uint256 _id, uint64 _stoppedIncrement) external\n        authP(REPORT_STOPPED_VALIDATORS_ROLE, arr(_id, uint256(_stoppedIncrement)))\n        operatorExists(_id)\n    {\n        require(0 != _stoppedIncrement, \"EMPTY_VALUE\");\n        operators[_id].stoppedValidators = operators[_id].stoppedValidators.add(_stoppedIncrement);\n        require(operators[_id].stoppedValidators <= operators[_id].usedSigningKeys, \"STOPPED_MORE_THAN_LAUNCHED\");\n\n        emit NodeOperatorTotalStoppedValidatorsReported(_id, operators[_id].stoppedValidators);\n    }\n\n    /**\n      * @notice Remove unused signing keys\n      * @dev Function is used by the Lido contract\n      */\n    function trimUnusedKeys() external onlyLido {\n        uint256 length = getNodeOperatorsCount();\n        for (uint256 operatorId = 0; operatorId < length; ++operatorId) {\n            uint64 totalSigningKeys = operators[operatorId].totalSigningKeys;\n            uint64 usedSigningKeys = operators[operatorId].usedSigningKeys;\n            if (totalSigningKeys != usedSigningKeys) { // write only if update is needed\n                operators[operatorId].totalSigningKeys = usedSigningKeys;  // discard unused keys\n                emit NodeOperatorTotalKeysTrimmed(operatorId, totalSigningKeys - usedSigningKeys);\n            }\n        }\n    }\n\n    /**\n      * @notice Add `_quantity` validator signing keys of operator #`_id` to the set of usable keys. Concatenated keys are: `_pubkeys`. Can be done by the DAO in question by using the designated rewards address.\n      * @dev Along with each key the DAO has to provide a signatures for the\n      *      (pubkey, withdrawal_credentials, 32000000000) message.\n      *      Given that information, the contract'll be able to call\n      *      deposit_contract.deposit on-chain.\n      * @param _operator_id Node Operator id\n      * @param _quantity Number of signing keys provided\n      * @param _pubkeys Several concatenated validator signing keys\n      * @param _signatures Several concatenated signatures for (pubkey, withdrawal_credentials, 32000000000) messages\n      */\n    function addSigningKeys(uint256 _operator_id, uint256 _quantity, bytes _pubkeys, bytes _signatures) external\n        authP(MANAGE_SIGNING_KEYS, arr(_operator_id))\n    {\n        _addSigningKeys(_operator_id, _quantity, _pubkeys, _signatures);\n    }\n\n    /**\n      * @notice Add `_quantity` validator signing keys of operator #`_id` to the set of usable keys. Concatenated keys are: `_pubkeys`. Can be done by node operator in question by using the designated rewards address.\n      * @dev Along with each key the DAO has to provide a signatures for the\n      *      (pubkey, withdrawal_credentials, 32000000000) message.\n      *      Given that information, the contract'll be able to call\n      *      deposit_contract.deposit on-chain.\n      * @param _operator_id Node Operator id\n      * @param _quantity Number of signing keys provided\n      * @param _pubkeys Several concatenated validator signing keys\n      * @param _signatures Several concatenated signatures for (pubkey, withdrawal_credentials, 32000000000) messages\n      */\n    function addSigningKeysOperatorBH(\n        uint256 _operator_id,\n        uint256 _quantity,\n        bytes _pubkeys,\n        bytes _signatures\n    )\n        external\n    {\n        require(msg.sender == operators[_operator_id].rewardAddress, \"APP_AUTH_FAILED\");\n        _addSigningKeys(_operator_id, _quantity, _pubkeys, _signatures);\n    }\n\n    /**\n      * @notice Removes a validator signing key #`_index` of operator #`_id` from the set of usable keys. Executed on behalf of DAO.\n      * @param _operator_id Node Operator id\n      * @param _index Index of the key, starting with 0\n      */\n    function removeSigningKey(uint256 _operator_id, uint256 _index)\n        external\n        authP(MANAGE_SIGNING_KEYS, arr(_operator_id))\n    {\n        _removeSigningKey(_operator_id, _index);\n    }\n\n    /**\n      * @notice Removes an #`_amount` of validator signing keys starting from #`_index` of operator #`_id` usable keys. Executed on behalf of DAO.\n      * @param _operator_id Node Operator id\n      * @param _index Index of the key, starting with 0\n      * @param _amount Number of keys to remove\n      */\n    function removeSigningKeys(uint256 _operator_id, uint256 _index, uint256 _amount)\n        external\n        authP(MANAGE_SIGNING_KEYS, arr(_operator_id))\n    {\n        // removing from the last index to the highest one, so we won't get outside the array\n        for (uint256 i = _index + _amount; i > _index ; --i) {\n            _removeSigningKey(_operator_id, i - 1);\n        }\n    }\n\n    /**\n      * @notice Removes a validator signing key #`_index` of operator #`_id` from the set of usable keys. Executed on behalf of Node Operator.\n      * @param _operator_id Node Operator id\n      * @param _index Index of the key, starting with 0\n      */\n    function removeSigningKeyOperatorBH(uint256 _operator_id, uint256 _index) external {\n        require(msg.sender == operators[_operator_id].rewardAddress, \"APP_AUTH_FAILED\");\n        _removeSigningKey(_operator_id, _index);\n    }\n\n    /**\n      * @notice Removes an #`_amount` of validator signing keys starting from #`_index` of operator #`_id` usable keys. Executed on behalf of Node Operator.\n      * @param _operator_id Node Operator id\n      * @param _index Index of the key, starting with 0\n      * @param _amount Number of keys to remove\n      */\n    function removeSigningKeysOperatorBH(uint256 _operator_id, uint256 _index, uint256 _amount) external {\n        require(msg.sender == operators[_operator_id].rewardAddress, \"APP_AUTH_FAILED\");\n        // removing from the last index to the highest one, so we won't get outside the array\n        for (uint256 i = _index + _amount; i > _index ; --i) {\n            _removeSigningKey(_operator_id, i - 1);\n        }\n    }\n\n    /**\n     * @notice Selects and returns at most `_numKeys` signing keys (as well as the corresponding\n     *         signatures) from the set of active keys and marks the selected keys as used.\n     *         May only be called by the Lido contract.\n     *\n     * @param _numKeys The number of keys to select. The actual number of selected keys may be less\n     *        due to the lack of active keys.\n     */\n    function assignNextSigningKeys(uint256 _numKeys) external onlyLido returns (bytes memory pubkeys, bytes memory signatures) {\n        // Memory is very cheap, although you don't want to grow it too much\n        DepositLookupCacheEntry[] memory cache = _loadOperatorCache();\n        if (0 == cache.length)\n            return (new bytes(0), new bytes(0));\n\n        uint256 numAssignedKeys = 0;\n        DepositLookupCacheEntry memory entry;\n\n        while (numAssignedKeys < _numKeys) {\n            // Finding the best suitable operator\n            uint256 bestOperatorIdx = cache.length;   // 'not found' flag\n            uint256 smallestStake;\n            // The loop is ligthweight comparing to an ether transfer and .deposit invocation\n            for (uint256 idx = 0; idx < cache.length; ++idx) {\n                entry = cache[idx];\n\n                assert(entry.usedSigningKeys <= entry.totalSigningKeys);\n                if (entry.usedSigningKeys == entry.totalSigningKeys)\n                    continue;\n\n                uint256 stake = entry.usedSigningKeys.sub(entry.stoppedValidators);\n                if (stake + 1 > entry.stakingLimit)\n                    continue;\n\n                if (bestOperatorIdx == cache.length || stake < smallestStake) {\n                    bestOperatorIdx = idx;\n                    smallestStake = stake;\n                }\n            }\n\n            if (bestOperatorIdx == cache.length)  // not found\n                break;\n\n            entry = cache[bestOperatorIdx];\n            assert(entry.usedSigningKeys < UINT64_MAX);\n\n            ++entry.usedSigningKeys;\n            ++numAssignedKeys;\n        }\n\n        if (numAssignedKeys == 0) {\n            return (new bytes(0), new bytes(0));\n        }\n\n        if (numAssignedKeys > 1) {\n            // we can allocate without zeroing out since we're going to rewrite the whole array\n            pubkeys = MemUtils.unsafeAllocateBytes(numAssignedKeys * PUBKEY_LENGTH);\n            signatures = MemUtils.unsafeAllocateBytes(numAssignedKeys * SIGNATURE_LENGTH);\n        }\n\n        uint256 numLoadedKeys = 0;\n\n        for (uint256 i = 0; i < cache.length; ++i) {\n            entry = cache[i];\n\n            if (entry.usedSigningKeys == entry.initialUsedSigningKeys) {\n                continue;\n            }\n\n            operators[entry.id].usedSigningKeys = uint64(entry.usedSigningKeys);\n\n            for (uint256 keyIndex = entry.initialUsedSigningKeys; keyIndex < entry.usedSigningKeys; ++keyIndex) {\n                (bytes memory pubkey, bytes memory signature) = _loadSigningKey(entry.id, keyIndex);\n                if (numAssignedKeys == 1) {\n                    return (pubkey, signature);\n                } else {\n                    MemUtils.copyBytes(pubkey, pubkeys, numLoadedKeys * PUBKEY_LENGTH);\n                    MemUtils.copyBytes(signature, signatures, numLoadedKeys * SIGNATURE_LENGTH);\n                    ++numLoadedKeys;\n                }\n            }\n\n            if (numLoadedKeys == numAssignedKeys) {\n                break;\n            }\n        }\n\n        assert(numLoadedKeys == numAssignedKeys);\n        return (pubkeys, signatures);\n    }\n\n    /**\n      * @notice Returns the rewards distribution proportional to the effective stake for each node operator.\n      * @param _totalRewardShares Total amount of reward shares to distribute.\n      */\n    function getRewardsDistribution(uint256 _totalRewardShares) external view\n        returns (\n            address[] memory recipients,\n            uint256[] memory shares\n        )\n    {\n        uint256 nodeOperatorCount = getNodeOperatorsCount();\n\n        uint256 activeCount = getActiveNodeOperatorsCount();\n        recipients = new address[](activeCount);\n        shares = new uint256[](activeCount);\n        uint256 idx = 0;\n\n        uint256 effectiveStakeTotal = 0;\n        for (uint256 operatorId = 0; operatorId < nodeOperatorCount; ++operatorId) {\n            NodeOperator storage operator = operators[operatorId];\n            if (!operator.active)\n                continue;\n\n            uint256 effectiveStake = operator.usedSigningKeys.sub(operator.stoppedValidators);\n            effectiveStakeTotal = effectiveStakeTotal.add(effectiveStake);\n\n            recipients[idx] = operator.rewardAddress;\n            shares[idx] = effectiveStake;\n\n            ++idx;\n        }\n\n        if (effectiveStakeTotal == 0)\n            return (recipients, shares);\n\n        uint256 perValidatorReward = _totalRewardShares.div(effectiveStakeTotal);\n\n        for (idx = 0; idx < activeCount; ++idx) {\n            shares[idx] = shares[idx].mul(perValidatorReward);\n        }\n\n        return (recipients, shares);\n    }\n\n    /**\n      * @notice Returns number of active node operators\n      */\n    function getActiveNodeOperatorsCount() public view returns (uint256) {\n        return ACTIVE_OPERATORS_COUNT_POSITION.getStorageUint256();\n    }\n\n    /**\n      * @notice Returns the n-th node operator\n      * @param _id Node Operator id\n      * @param _fullInfo If true, name will be returned as well\n      */\n    function getNodeOperator(uint256 _id, bool _fullInfo) external view\n        operatorExists(_id)\n        returns\n        (\n            bool active,\n            string name,\n            address rewardAddress,\n            uint64 stakingLimit,\n            uint64 stoppedValidators,\n            uint64 totalSigningKeys,\n            uint64 usedSigningKeys\n        )\n    {\n        NodeOperator storage operator = operators[_id];\n\n        active = operator.active;\n        name = _fullInfo ? operator.name : \"\";    // reading name is 2+ SLOADs\n        rewardAddress = operator.rewardAddress;\n        stakingLimit = operator.stakingLimit;\n        stoppedValidators = operator.stoppedValidators;\n        totalSigningKeys = operator.totalSigningKeys;\n        usedSigningKeys = operator.usedSigningKeys;\n    }\n\n    /**\n      * @notice Returns total number of signing keys of the node operator #`_operator_id`\n      */\n    function getTotalSigningKeyCount(uint256 _operator_id) external view operatorExists(_operator_id) returns (uint256) {\n        return operators[_operator_id].totalSigningKeys;\n    }\n\n    /**\n      * @notice Returns number of usable signing keys of the node operator #`_operator_id`\n      */\n    function getUnusedSigningKeyCount(uint256 _operator_id) external view operatorExists(_operator_id) returns (uint256) {\n        return operators[_operator_id].totalSigningKeys.sub(operators[_operator_id].usedSigningKeys);\n    }\n\n    /**\n      * @notice Returns n-th signing key of the node operator #`_operator_id`\n      * @param _operator_id Node Operator id\n      * @param _index Index of the key, starting with 0\n      * @return key Key\n      * @return depositSignature Signature needed for a deposit_contract.deposit call\n      * @return used Flag indication if the key was used in the staking\n      */\n    function getSigningKey(uint256 _operator_id, uint256 _index) external view\n        operatorExists(_operator_id)\n        returns (bytes key, bytes depositSignature, bool used)\n    {\n        require(_index < operators[_operator_id].totalSigningKeys, \"KEY_NOT_FOUND\");\n\n        (bytes memory key_, bytes memory signature) = _loadSigningKey(_operator_id, _index);\n\n        return (key_, signature, _index < operators[_operator_id].usedSigningKeys);\n    }\n\n    /**\n      * @notice Returns total number of node operators\n      */\n    function getNodeOperatorsCount() public view returns (uint256) {\n        return TOTAL_OPERATORS_COUNT_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Returns a monotonically increasing counter that gets incremented when any of the following happens:\n     *   1. a node operator's key(s) is added;\n     *   2. a node operator's key(s) is removed;\n     *   3. a node operator's approved keys limit is changed.\n     *   4. a node operator was activated/deactivated. Activation or deactivation of node operator\n     *      might lead to usage of unvalidated keys in the assignNextSigningKeys method.\n     */\n    function getKeysOpIndex() public view returns (uint256) {\n        return KEYS_OP_INDEX_POSITION.getStorageUint256();\n    }\n\n    function _isEmptySigningKey(bytes memory _key) internal pure returns (bool) {\n        assert(_key.length == PUBKEY_LENGTH);\n        // algorithm applicability constraint\n        assert(PUBKEY_LENGTH >= 32 && PUBKEY_LENGTH <= 64);\n\n        uint256 k1;\n        uint256 k2;\n        assembly {\n            k1 := mload(add(_key, 0x20))\n            k2 := mload(add(_key, 0x40))\n        }\n\n        return 0 == k1 && 0 == (k2 >> ((2 * 32 - PUBKEY_LENGTH) * 8));\n    }\n\n    function to64(uint256 v) internal pure returns (uint64) {\n        assert(v <= uint256(uint64(-1)));\n        return uint64(v);\n    }\n\n    function _signingKeyOffset(uint256 _operator_id, uint256 _keyIndex) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(SIGNING_KEYS_MAPPING_NAME, _operator_id, _keyIndex)));\n    }\n\n    function _storeSigningKey(uint256 _operator_id, uint256 _keyIndex, bytes memory _key, bytes memory _signature) internal {\n        assert(_key.length == PUBKEY_LENGTH);\n        assert(_signature.length == SIGNATURE_LENGTH);\n        // algorithm applicability constraints\n        assert(PUBKEY_LENGTH >= 32 && PUBKEY_LENGTH <= 64);\n        assert(0 == SIGNATURE_LENGTH % 32);\n\n        // key\n        uint256 offset = _signingKeyOffset(_operator_id, _keyIndex);\n        uint256 keyExcessBits = (2 * 32 - PUBKEY_LENGTH) * 8;\n        assembly {\n            sstore(offset, mload(add(_key, 0x20)))\n            sstore(add(offset, 1), shl(keyExcessBits, shr(keyExcessBits, mload(add(_key, 0x40)))))\n        }\n        offset += 2;\n\n        // signature\n        for (uint256 i = 0; i < SIGNATURE_LENGTH; i += 32) {\n            assembly {\n                sstore(offset, mload(add(_signature, add(0x20, i))))\n            }\n            offset++;\n        }\n    }\n\n    function _addSigningKeys(uint256 _operator_id, uint256 _quantity, bytes _pubkeys, bytes _signatures) internal\n        operatorExists(_operator_id)\n    {\n        require(_quantity != 0, \"NO_KEYS\");\n        require(_pubkeys.length == _quantity.mul(PUBKEY_LENGTH), \"INVALID_LENGTH\");\n        require(_signatures.length == _quantity.mul(SIGNATURE_LENGTH), \"INVALID_LENGTH\");\n\n        _increaseKeysOpIndex();\n\n        for (uint256 i = 0; i < _quantity; ++i) {\n            bytes memory key = BytesLib.slice(_pubkeys, i * PUBKEY_LENGTH, PUBKEY_LENGTH);\n            require(!_isEmptySigningKey(key), \"EMPTY_KEY\");\n            bytes memory sig = BytesLib.slice(_signatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\n\n            _storeSigningKey(_operator_id, operators[_operator_id].totalSigningKeys + i, key, sig);\n            emit SigningKeyAdded(_operator_id, key);\n        }\n\n        operators[_operator_id].totalSigningKeys = operators[_operator_id].totalSigningKeys.add(to64(_quantity));\n    }\n\n    function _removeSigningKey(uint256 _operator_id, uint256 _index) internal\n        operatorExists(_operator_id)\n    {\n        require(_index < operators[_operator_id].totalSigningKeys, \"KEY_NOT_FOUND\");\n        require(_index >= operators[_operator_id].usedSigningKeys, \"KEY_WAS_USED\");\n\n        _increaseKeysOpIndex();\n\n        (bytes memory removedKey, ) = _loadSigningKey(_operator_id, _index);\n\n        uint256 lastIndex = operators[_operator_id].totalSigningKeys.sub(1);\n        if (_index < lastIndex) {\n            (bytes memory key, bytes memory signature) = _loadSigningKey(_operator_id, lastIndex);\n            _storeSigningKey(_operator_id, _index, key, signature);\n        }\n\n        _deleteSigningKey(_operator_id, lastIndex);\n        operators[_operator_id].totalSigningKeys = operators[_operator_id].totalSigningKeys.sub(1);\n\n        if (_index < operators[_operator_id].stakingLimit) {\n            // decreasing the staking limit so the key at _index can't be used anymore\n            operators[_operator_id].stakingLimit = uint64(_index);\n        }\n\n        emit SigningKeyRemoved(_operator_id, removedKey);\n    }\n\n    function _deleteSigningKey(uint256 _operator_id, uint256 _keyIndex) internal {\n        uint256 offset = _signingKeyOffset(_operator_id, _keyIndex);\n        for (uint256 i = 0; i < (PUBKEY_LENGTH + SIGNATURE_LENGTH) / 32 + 1; ++i) {\n            assembly {\n                sstore(add(offset, i), 0)\n            }\n        }\n    }\n\n    function _loadSigningKey(uint256 _operator_id, uint256 _keyIndex) internal view returns (bytes memory key, bytes memory signature) {\n        // algorithm applicability constraints\n        assert(PUBKEY_LENGTH >= 32 && PUBKEY_LENGTH <= 64);\n        assert(0 == SIGNATURE_LENGTH % 32);\n\n        uint256 offset = _signingKeyOffset(_operator_id, _keyIndex);\n\n        // key\n        bytes memory tmpKey = new bytes(64);\n        assembly {\n            mstore(add(tmpKey, 0x20), sload(offset))\n            mstore(add(tmpKey, 0x40), sload(add(offset, 1)))\n        }\n        offset += 2;\n        key = BytesLib.slice(tmpKey, 0, PUBKEY_LENGTH);\n\n        // signature\n        signature = new bytes(SIGNATURE_LENGTH);\n        for (uint256 i = 0; i < SIGNATURE_LENGTH; i += 32) {\n            assembly {\n                mstore(add(signature, add(0x20, i)), sload(offset))\n            }\n            offset++;\n        }\n\n        return (key, signature);\n    }\n\n    function _loadOperatorCache() internal view returns (DepositLookupCacheEntry[] memory cache) {\n        cache = new DepositLookupCacheEntry[](getActiveNodeOperatorsCount());\n        if (0 == cache.length)\n            return cache;\n\n        uint256 totalOperators = getNodeOperatorsCount();\n        uint256 idx = 0;\n        for (uint256 operatorId = 0; operatorId < totalOperators; ++operatorId) {\n            NodeOperator storage operator = operators[operatorId];\n\n            if (!operator.active)\n                continue;\n\n            DepositLookupCacheEntry memory entry = cache[idx++];\n            entry.id = operatorId;\n            entry.stakingLimit = operator.stakingLimit;\n            entry.stoppedValidators = operator.stoppedValidators;\n            entry.totalSigningKeys = operator.totalSigningKeys;\n            entry.usedSigningKeys = operator.usedSigningKeys;\n            entry.initialUsedSigningKeys = entry.usedSigningKeys;\n        }\n        require(idx == cache.length, \"INCOSISTENT_ACTIVE_COUNT\");\n\n        return cache;\n    }\n\n    function _increaseKeysOpIndex() internal {\n        uint256 keysOpIndex = getKeysOpIndex();\n        KEYS_OP_INDEX_POSITION.setStorageUint256(keysOpIndex + 1);\n        emit KeysOpIndexSet(keysOpIndex + 1);\n    }\n}"
    }
  ]
}