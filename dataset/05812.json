{
  "Title": "[M-09] Missing circuit breaker checks in `ethPerCvx()` for Chainlink's price feed",
  "Content": "\nThe `ethPerCvx()` function relies on a Chainlink oracle to fetch the CVX / ETH price:\n\n[VotiumStrategyCore.sol#L158-L169](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L158-L169)\n\n```solidity\n        try chainlinkCvxEthFeed.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        ) {\n            cl.success = true;\n            cl.roundId = roundId;\n            cl.answer = answer;\n            cl.updatedAt = updatedAt;\n        } catch {\n```\n\nThe return values from `latestRoundData()` are validated as such:\n\n[VotiumStrategyCore.sol#L173-L181](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L173-L181)\n\n```solidity\n        if (\n            (!_validate ||\n                (cl.success == true &&\n                    cl.roundId != 0 &&\n                    cl.answer >= 0 &&\n                    cl.updatedAt != 0 &&\n                    cl.updatedAt <= block.timestamp &&\n                    block.timestamp - cl.updatedAt <= 25 hours))\n        ) {\n```\n\nAs seen from above, there is no check to ensure that `cl.answer` does not go below or above a certain price.\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. Therefore, if CVX experiences a huge drop/rise in value, the CVX / ETH price feed will continue to return `minAnswer`/`maxAnswer` instead of the actual price of CVX.\n\nCurrently, `minAnswer` is set to `1e13` and `maxAnswer` is set to `1e18`. This can be checked by looking at the [AccessControlledOffchainAggregator](https://etherscan.io/address/0xf1F7F7BFCc5E9D6BB8D9617756beC06A5Cbe1a49) contract for the CVX / ETH price feed. Therefore, if CVX ever experiences a flash crash and its price drops to below `1e13` (eg. `100`), the `cl.answer` will still be `1e13`.\n\nThis becomes problematic as `ethPerCvx()` is used to determine the price of vAfEth:\n\n[VotiumStrategy.sol#L31-L33](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L31-L33)\n\n```solidity\n    function price() external view override returns (uint256) {\n        return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n    }\n```\n\nFurthermore, vAfEth's price is used to calculate the amount of AfEth to mint to users whenever they call `deposit()`:\n\n[AfEth.sol#L162-L166](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L162-L166)\n\n```solidity\n        totalValue +=\n            (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n            (vMinted * vStrategy.price());\n        if (totalValue == 0) revert FailedToDeposit();\n        uint256 amountToMint = totalValue / priceBeforeDeposit;\n```\n\nIf CVX experiences a flash crash, `vStrategy.price()` will be `1e13`, which is much larger than the actual price of CVX. This will cause `totalValue` to become extremely large, which in turn causes `amountToMint` to be extremely large as well. Therefore, the caller will receive a huge amount of afEth.\n\n### Impact\n\nDue to Chainlink's in-built circuit breaker mechanism, if CVX experiences a flash crash, `ethPerCvx()` will return a price higher than the actual price of CVX. Should this occur, an attacker can call `deposit()` to receive a huge amount of afEth as it uses an incorrect CVX price.\n\nThis would lead to a loss of funds for previous depositors, as the attacker would hold a majority of afEth's total supply and can withdraw most of the protocol's TVL.\n\n### Proof of Concept\n\nAssume the following:\n\n*   For convenience, assume that 1 safEth is worth 1 ETH.\n*   The `AfEth` contract has the following state:\n    *   `ratio = 5e17` (50%)\n    *   `totalSupply() = 100e18`\n    *   `safEthBalanceMinusPending() = 50e18`\n    *   `vEthStrategy.balanceOf(address(this))` (vAfEth balance) is `50e18`\n*   The `VotiumStrategy` contract has the following state:\n    *   Only 50 vAfEth has been minted so far (`totalSupply() = 50e18`).\n    *   The contract only has 50 CVX in total (`cvxInSystem() = 50e18`).\n    *   This means that [`cvxPerVotium()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L140-L149) returns `1e18` as:\n\n```solidity\n((totalCvx - cvxUnlockObligations) * 1e18) / supply = ((50e18 - 0) * 1e18) / 50e18 = 1e18\n```\n\nThe price of CVX flash crashes from `2e15 / 1e18` ETH per CVX to `100 / 1e18` ETH per CVX. Now, if an attacker calls `deposit()` with 10 ETH:\n\n*   `priceBeforeDeposit`, which is equal to `price()`, is `5e17 + 5e12` as:\n\n```solidity\nsafEthValueInEth = (1e18 * 50e18) / 1e18 = 50e18\nvEthValueInEth = (1e13 * 50e18) / 1e18 = 5e14\n((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply() = ((50e18 + 5e14) * 1e18) / 100e18 = 5e17 + 5e12\n```\n\n*   Since `ratio` is 50%, 5 ETH is staked into safEth:\n    *   `sMinted = 5e18`, since the price of safEth and ETH is equal.\n*   The other 5 ETH is deposited into `VotiumStrategy`:\n    *   `priceBefore`, which is equal to `cvxPerVotium()`, is `1e18` as shown above.\n    *   Since 1 ETH is worth `1e16` CVX (according to the price above), `cvxAmount = 5e34`.\n    *   Therefore, `vMinted = 5e34` as:\n\n```solidity\nmintAmount = ((cvxAmount * 1e18) / priceBefore) = ((5e34 * 1e18) / 1e18) = 5e34 \n```\n\n*   To calculate `vStrategy.price()` after `VotiumStrategy`'s `deposit()` function is called:\n    *   `ethPerCvx()` returns `1e13`, which is `minAnswer` for the CVX / ETH price fee.\n    *   `cvxPerVotium()` is still `1e18` as:\n\n```solidity\nsupply = totalSupply() = 5e34 + 50e18\ntotalCvx = cvxInSystem() = 5e34 + 50e18\n((totalCvx - cvxUnlockObligations) * 1e18) / supply = ((5e34 + 50e18 - 0) * 1e18) / (5e34 + 50e18) = 1e18\n```\n\n*   Therefore `vStrategy.price()` returns `1e13` as:\n\n```solidity\n(cvxPerVotium() * ethPerCvx(false)) / 1e18 = (1e18 * 1e13) / 1e18 = 1e13\n```\n\n*   To calculate the amount of AfEth minted to the caller:\n\n```solidity\ntotalValue = (5e18 * 1e18) + (5e34 * 1e13) = 5e47 + 5e36\namountToMint = totalValue / priceBeforeDeposit = (5e47 + 5e36) / (5e17 + 5e12) = ~1e30\n```\n\nAs seen from above, the attacker will receive `1e30` AfEth, which is huge compared to the remaining `100e18` held by previous depositors before the flash crash.\n\nTherefore, almost all of the protocol's TVL now belongs to the attacker as he holds most of AfEth's total supply. This results in a loss of funds for all previous depositors.\n\n### Recommended Mitigation\n\nConsider validating that the price returned by Chainlink's price feed does not go below/above a minimum/maximum price:\n\n[VotiumStrategyCore.sol#L173-L181](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L173-L181)\n\n```diff\n        if (\n            (!_validate ||\n                (cl.success == true &&\n                    cl.roundId != 0 &&\n-                   cl.answer >= 0 &&\n+                   cl.answer >= MIN_PRICE &&\n+                   cl.answer <= MAX_PRICE &&\n                    cl.updatedAt != 0 &&\n                    cl.updatedAt <= block.timestamp &&\n                    block.timestamp - cl.updatedAt <= 25 hours))\n        ) {\n```\n\nThis ensures that an incorrect price will never be used should CVX experience a flash crash, thereby protecting the assets of existing depositors.\n\n**[Asymmetry acknowledged](https://github.com/code-423n4/2023-10-asymmetry-mitigation?tab=readme-ov-file#out-of-scope)**\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-asymmetry",
  "Code": [
    {
      "filename": "contracts/strategies/votium/VotiumStrategyCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../external_interfaces/IWETH.sol\";\nimport \"../../external_interfaces/ISwapRouter.sol\";\nimport \"../../external_interfaces/IVotiumMerkleStash.sol\";\nimport \"../../external_interfaces/ISnapshotDelegationRegistry.sol\";\nimport \"../../external_interfaces/ILockedCvx.sol\";\nimport \"../../external_interfaces/IClaimZap.sol\";\nimport \"../../external_interfaces/ICrvEthPool.sol\";\nimport \"../../external_interfaces/IAfEth.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../external_interfaces/ISafEth.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title Votium Strategy Token internal functions\n/// @author Asymmetry Finance\ncontract VotiumStrategyCore is\n    Initializable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    address public constant SNAPSHOT_DELEGATE_REGISTRY =\n        0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446;\n    address constant CVX_ADDRESS = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address constant VLCVX_ADDRESS = 0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    struct SwapData {\n        address sellToken;\n        address spender;\n        address swapTarget;\n        bytes swapCallData;\n    }\n\n    struct ChainlinkResponse {\n        uint80 roundId;\n        int256 answer;\n        uint256 updatedAt;\n        bool success;\n    }\n\n    uint256 public cvxUnlockObligations;\n    address public rewarder;\n    address public manager;\n\n    AggregatorV3Interface public chainlinkCvxEthFeed;\n    uint256 latestWithdrawId;\n\n    // used to add storage variables in the future\n    uint256[20] private __gap;\n\n    event DepositReward(\n        uint256 indexed newPrice,\n        uint256 indexed ethAmount,\n        uint256 indexed cvxAmount\n    );\n\n    event FailedToSell(address indexed tokenAddress);\n\n    error SwapFailed(uint256 index);\n    error ChainlinkFailed();\n    error NotRewarder();\n    error InvalidLockedAmount();\n    error NotOwner();\n    error WithdrawNotReady();\n    error AlreadyWithdrawn();\n\n    /**\n        @notice - Sets the address for the chainlink feed\n        @param _cvxEthFeedAddress - Address of the chainlink feed\n    */\n    function setChainlinkCvxEthFeed(\n        address _cvxEthFeedAddress\n    ) public onlyOwner {\n        chainlinkCvxEthFeed = AggregatorV3Interface(_cvxEthFeedAddress);\n    }\n\n    modifier onlyRewarder() {\n        if (msg.sender != rewarder) revert NotRewarder();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - Address of the owner of the contract (asym multisig)\n        @param _rewarder - Address of the rewarder contract (reward oracle)\n        @param _manager - Address of the manager contract (afEth)\n    */\n    function initialize(\n        address _owner,\n        address _rewarder,\n        address _manager\n    ) external initializer {\n        bytes32 VotiumVoteDelegationId = 0x6376782e65746800000000000000000000000000000000000000000000000000;\n        address DelegationRegistry = 0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446;\n        address votiumVoteProxyAddress = 0xde1E6A7ED0ad3F61D531a8a78E83CcDdbd6E0c49;\n        ISnapshotDelegationRegistry(DelegationRegistry).setDelegate(\n            VotiumVoteDelegationId,\n            votiumVoteProxyAddress\n        );\n        rewarder = _rewarder;\n        manager = _manager;\n        __ERC20_init(\"Votium AfEth Strategy\", \"vAfEth\");\n        _transferOwnership(_owner);\n        chainlinkCvxEthFeed = AggregatorV3Interface(\n            0xC9CbF687f43176B302F03f5e58470b77D07c61c6\n        );\n    }\n\n    /**\n     * @notice - Function to set the address of the rewarder account that periodically claims rewards\n     * @param _rewarder - Address of the rewarder account\n     */\n    function setRewarder(address _rewarder) external onlyOwner {\n        rewarder = _rewarder;\n    }\n\n    /**\n     * @notice - The amount of cvx in the entire system\n     * @return - Amount of cvx in the entire system\n     */\n    function cvxInSystem() public view returns (uint256) {\n        (uint256 total, , , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        return total + IERC20(CVX_ADDRESS).balanceOf(address(this));\n    }\n\n    /**\n     * @notice - Gets price of afEth in cvx\n     * @return - Price of afEth in cvx\n     */\n    function cvxPerVotium() public view returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 totalCvx = cvxInSystem();\n        if (supply == 0 || totalCvx == 0) return 1e18;\n        return ((totalCvx - cvxUnlockObligations) * 1e18) / supply;\n    }\n\n    /**\n        @notice - Eth per cvx (chainlink)\n        @param _validate - Whether or not to validate the chainlink response\n        @return - Price of cvx in eth\n     */\n    function ethPerCvx(bool _validate) public view returns (uint256) {\n        ChainlinkResponse memory cl;\n        try chainlinkCvxEthFeed.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        ) {\n            cl.success = true;\n            cl.roundId = roundId;\n            cl.answer = answer;\n            cl.updatedAt = updatedAt;\n        } catch {\n            cl.success = false;\n        }\n        // verify chainlink response\n        if (\n            (!_validate ||\n                (cl.success == true &&\n                    cl.roundId != 0 &&\n                    cl.answer >= 0 &&\n                    cl.updatedAt != 0 &&\n                    cl.updatedAt <= block.timestamp &&\n                    block.timestamp - cl.updatedAt <= 25 hours))\n        ) {\n            return uint256(cl.answer);\n        } else {\n            revert ChainlinkFailed();\n        }\n    }\n\n    /**\n     * @notice Allow rewarder oracle account to claim rewards\n     * @param _claimProofs - Array of claim proofs\n     */\n    function claimRewards(\n        IVotiumMerkleStash.ClaimParam[] calldata _claimProofs\n    ) public onlyRewarder {\n        claimVotiumRewards(_claimProofs);\n        claimVlCvxRewards();\n    }\n\n    /**\n     * @notice - Sells amount of eth from votium contract\n     * @dev - Puts it into safEthStrategy or votiumStrategy, whichever is underweight.\n     *  */\n    function depositRewards(uint256 _amount) public payable {\n        uint256 cvxAmount = buyCvx(_amount);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        emit DepositReward(cvxPerVotium(), _amount, cvxAmount);\n    }\n\n    /**\n     * @notice - Allows owner to withdraw any stuck erc20 tokens\n     * @dev - Lets us handle any that were not successfully sold via cvx\n     * @param _token - Address of the token to withdraw\n     */\n    function withdrawStuckTokens(address _token) public onlyOwner {\n        IERC20(_token).transfer(\n            msg.sender,\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice - Internal utility function to buy cvx using eth\n     * @param _ethAmountIn - Amount of eth to spend\n     * @return cvxAmountOut - Amount of cvx bought\n     */\n    function buyCvx(\n        uint256 _ethAmountIn\n    ) internal returns (uint256 cvxAmountOut) {\n        address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n        // eth -> cvx\n        uint256 cvxBalanceBefore = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying{\n            value: _ethAmountIn\n        }(\n            0,\n            1,\n            _ethAmountIn,\n            0 // this is handled at the afEth level\n        );\n        uint256 cvxBalanceAfter = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        cvxAmountOut = cvxBalanceAfter - cvxBalanceBefore;\n    }\n\n    /**\n     * @notice - Internal utility function to sell cvx for eth\n     * @param _cvxAmountIn - Amount of cvx to sell\n     * @return ethAmountOut - Amount of eth received\n     */\n    function sellCvx(\n        uint256 _cvxAmountIn\n    ) internal returns (uint256 ethAmountOut) {\n        address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n        // cvx -> eth\n        uint256 ethBalanceBefore = address(this).balance;\n        IERC20(CVX_ADDRESS).approve(CVX_ETH_CRV_POOL_ADDRESS, _cvxAmountIn);\n\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying(\n            1,\n            0,\n            _cvxAmountIn,\n            0 // this is handled at the afEth level\n        );\n        ethAmountOut = address(this).balance - ethBalanceBefore;\n    }\n\n    /**\n     * @notice - Function for rewarder to sell all claimed token rewards and buy & lock more cvx\n     * @dev - Causes price to go up\n     * @param _swapsData - Array of SwapData for 0x swaps\n     */\n    function applyRewards(SwapData[] calldata _swapsData) public onlyRewarder {\n        uint256 ethBalanceBefore = address(this).balance;\n        for (uint256 i = 0; i < _swapsData.length; i++) {\n            // Some tokens do not allow approval if allowance already exists\n            uint256 allowance = IERC20(_swapsData[i].sellToken).allowance(\n                address(this),\n                address(_swapsData[i].spender)\n            );\n            if (allowance != type(uint256).max) {\n                if (allowance > 0) {\n                    IERC20(_swapsData[i].sellToken).approve(\n                        address(_swapsData[i].spender),\n                        0\n                    );\n                }\n                IERC20(_swapsData[i].sellToken).approve(\n                    address(_swapsData[i].spender),\n                    type(uint256).max\n                );\n            }\n            (bool success, ) = _swapsData[i].swapTarget.call(\n                _swapsData[i].swapCallData\n            );\n            if (!success) {\n                emit FailedToSell(_swapsData[i].sellToken);\n            }\n        }\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        if (address(manager) != address(0))\n            IAfEth(manager).depositRewards{value: ethReceived}(ethReceived);\n        else depositRewards(ethReceived);\n    }\n\n    /**\n     * @notice - Internal utility function to claim votium reward tokens\n     * @param _claimProofs - Array of claim proofs\n     */\n    function claimVotiumRewards(\n        IVotiumMerkleStash.ClaimParam[] calldata _claimProofs\n    ) private {\n        IVotiumMerkleStash(0x378Ba9B73309bE80BF4C2c027aAD799766a7ED5A)\n            .claimMulti(address(this), _claimProofs);\n    }\n\n    /**\n     * @notice - Internal utility function to claim vlCvx reward tokens\n     */\n    function claimVlCvxRewards() private {\n        address[] memory emptyArray;\n        IClaimZap(0x3f29cB4111CbdA8081642DA1f75B3c12DECf2516).claimRewards(\n            emptyArray,\n            emptyArray,\n            emptyArray,\n            emptyArray,\n            0,\n            0,\n            0,\n            0,\n            8\n        );\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/strategies/votium/VotiumStrategyCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../external_interfaces/IWETH.sol\";\nimport \"../../external_interfaces/ISwapRouter.sol\";\nimport \"../../external_interfaces/IVotiumMerkleStash.sol\";\nimport \"../../external_interfaces/ISnapshotDelegationRegistry.sol\";\nimport \"../../external_interfaces/ILockedCvx.sol\";\nimport \"../../external_interfaces/IClaimZap.sol\";\nimport \"../../external_interfaces/ICrvEthPool.sol\";\nimport \"../../external_interfaces/IAfEth.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../../external_interfaces/ISafEth.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title Votium Strategy Token internal functions\n/// @author Asymmetry Finance\ncontract VotiumStrategyCore is\n    Initializable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    address public constant SNAPSHOT_DELEGATE_REGISTRY =\n        0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446;\n    address constant CVX_ADDRESS = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address constant VLCVX_ADDRESS = 0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    struct SwapData {\n        address sellToken;\n        address spender;\n        address swapTarget;\n        bytes swapCallData;\n    }\n\n    struct ChainlinkResponse {\n        uint80 roundId;\n        int256 answer;\n        uint256 updatedAt;\n        bool success;\n    }\n\n    uint256 public cvxUnlockObligations;\n    address public rewarder;\n    address public manager;\n\n    AggregatorV3Interface public chainlinkCvxEthFeed;\n    uint256 latestWithdrawId;\n\n    // used to add storage variables in the future\n    uint256[20] private __gap;\n\n    event DepositReward(\n        uint256 indexed newPrice,\n        uint256 indexed ethAmount,\n        uint256 indexed cvxAmount\n    );\n\n    event FailedToSell(address indexed tokenAddress);\n\n    error SwapFailed(uint256 index);\n    error ChainlinkFailed();\n    error NotRewarder();\n    error InvalidLockedAmount();\n    error NotOwner();\n    error WithdrawNotReady();\n    error AlreadyWithdrawn();\n\n    /**\n        @notice - Sets the address for the chainlink feed\n        @param _cvxEthFeedAddress - Address of the chainlink feed\n    */\n    function setChainlinkCvxEthFeed(\n        address _cvxEthFeedAddress\n    ) public onlyOwner {\n        chainlinkCvxEthFeed = AggregatorV3Interface(_cvxEthFeedAddress);\n    }\n\n    modifier onlyRewarder() {\n        if (msg.sender != rewarder) revert NotRewarder();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - Address of the owner of the contract (asym multisig)\n        @param _rewarder - Address of the rewarder contract (reward oracle)\n        @param _manager - Address of the manager contract (afEth)\n    */\n    function initialize(\n        address _owner,\n        address _rewarder,\n        address _manager\n    ) external initializer {\n        bytes32 VotiumVoteDelegationId = 0x6376782e65746800000000000000000000000000000000000000000000000000;\n        address DelegationRegistry = 0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446;\n        address votiumVoteProxyAddress = 0xde1E6A7ED0ad3F61D531a8a78E83CcDdbd6E0c49;\n        ISnapshotDelegationRegistry(DelegationRegistry).setDelegate(\n            VotiumVoteDelegationId,\n            votiumVoteProxyAddress\n        );\n        rewarder = _rewarder;\n        manager = _manager;\n        __ERC20_init(\"Votium AfEth Strategy\", \"vAfEth\");\n        _transferOwnership(_owner);\n        chainlinkCvxEthFeed = AggregatorV3Interface(\n            0xC9CbF687f43176B302F03f5e58470b77D07c61c6\n        );\n    }\n\n    /**\n     * @notice - Function to set the address of the rewarder account that periodically claims rewards\n     * @param _rewarder - Address of the rewarder account\n     */\n    function setRewarder(address _rewarder) external onlyOwner {\n        rewarder = _rewarder;\n    }\n\n    /**\n     * @notice - The amount of cvx in the entire system\n     * @return - Amount of cvx in the entire system\n     */\n    function cvxInSystem() public view returns (uint256) {\n        (uint256 total, , , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        return total + IERC20(CVX_ADDRESS).balanceOf(address(this));\n    }\n\n    /**\n     * @notice - Gets price of afEth in cvx\n     * @return - Price of afEth in cvx\n     */\n    function cvxPerVotium() public view returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 totalCvx = cvxInSystem();\n        if (supply == 0 || totalCvx == 0) return 1e18;\n        return ((totalCvx - cvxUnlockObligations) * 1e18) / supply;\n    }\n\n    /**\n        @notice - Eth per cvx (chainlink)\n        @param _validate - Whether or not to validate the chainlink response\n        @return - Price of cvx in eth\n     */\n    function ethPerCvx(bool _validate) public view returns (uint256) {\n        ChainlinkResponse memory cl;\n        try chainlinkCvxEthFeed.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        ) {\n            cl.success = true;\n            cl.roundId = roundId;\n            cl.answer = answer;\n            cl.updatedAt = updatedAt;\n        } catch {\n            cl.success = false;\n        }\n        // verify chainlink response\n        if (\n            (!_validate ||\n                (cl.success == true &&\n                    cl.roundId != 0 &&\n                    cl.answer >= 0 &&\n                    cl.updatedAt != 0 &&\n                    cl.updatedAt <= block.timestamp &&\n                    block.timestamp - cl.updatedAt <= 25 hours))\n        ) {\n            return uint256(cl.answer);\n        } else {\n            revert ChainlinkFailed();\n        }\n    }\n\n    /**\n     * @notice Allow rewarder oracle account to claim rewards\n     * @param _claimProofs - Array of claim proofs\n     */\n    function claimRewards(\n        IVotiumMerkleStash.ClaimParam[] calldata _claimProofs\n    ) public onlyRewarder {\n        claimVotiumRewards(_claimProofs);\n        claimVlCvxRewards();\n    }\n\n    /**\n     * @notice - Sells amount of eth from votium contract\n     * @dev - Puts it into safEthStrategy or votiumStrategy, whichever is underweight.\n     *  */\n    function depositRewards(uint256 _amount) public payable {\n        uint256 cvxAmount = buyCvx(_amount);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        emit DepositReward(cvxPerVotium(), _amount, cvxAmount);\n    }\n\n    /**\n     * @notice - Allows owner to withdraw any stuck erc20 tokens\n     * @dev - Lets us handle any that were not successfully sold via cvx\n     * @param _token - Address of the token to withdraw\n     */\n    function withdrawStuckTokens(address _token) public onlyOwner {\n        IERC20(_token).transfer(\n            msg.sender,\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice - Internal utility function to buy cvx using eth\n     * @param _ethAmountIn - Amount of eth to spend\n     * @return cvxAmountOut - Amount of cvx bought\n     */\n    function buyCvx(\n        uint256 _ethAmountIn\n    ) internal returns (uint256 cvxAmountOut) {\n        address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n        // eth -> cvx\n        uint256 cvxBalanceBefore = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying{\n            value: _ethAmountIn\n        }(\n            0,\n            1,\n            _ethAmountIn,\n            0 // this is handled at the afEth level\n        );\n        uint256 cvxBalanceAfter = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        cvxAmountOut = cvxBalanceAfter - cvxBalanceBefore;\n    }\n\n    /**\n     * @notice - Internal utility function to sell cvx for eth\n     * @param _cvxAmountIn - Amount of cvx to sell\n     * @return ethAmountOut - Amount of eth received\n     */\n    function sellCvx(\n        uint256 _cvxAmountIn\n    ) internal returns (uint256 ethAmountOut) {\n        address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n        // cvx -> eth\n        uint256 ethBalanceBefore = address(this).balance;\n        IERC20(CVX_ADDRESS).approve(CVX_ETH_CRV_POOL_ADDRESS, _cvxAmountIn);\n\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying(\n            1,\n            0,\n            _cvxAmountIn,\n            0 // this is handled at the afEth level\n        );\n        ethAmountOut = address(this).balance - ethBalanceBefore;\n    }\n\n    /**\n     * @notice - Function for rewarder to sell all claimed token rewards and buy & lock more cvx\n     * @dev - Causes price to go up\n     * @param _swapsData - Array of SwapData for 0x swaps\n     */\n    function applyRewards(SwapData[] calldata _swapsData) public onlyRewarder {\n        uint256 ethBalanceBefore = address(this).balance;\n        for (uint256 i = 0; i < _swapsData.length; i++) {\n            // Some tokens do not allow approval if allowance already exists\n            uint256 allowance = IERC20(_swapsData[i].sellToken).allowance(\n                address(this),\n                address(_swapsData[i].spender)\n            );\n            if (allowance != type(uint256).max) {\n                if (allowance > 0) {\n                    IERC20(_swapsData[i].sellToken).approve(\n                        address(_swapsData[i].spender),\n                        0\n                    );\n                }\n                IERC20(_swapsData[i].sellToken).approve(\n                    address(_swapsData[i].spender),\n                    type(uint256).max\n                );\n            }\n            (bool success, ) = _swapsData[i].swapTarget.call(\n                _swapsData[i].swapCallData\n            );\n            if (!success) {\n                emit FailedToSell(_swapsData[i].sellToken);\n            }\n        }\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        if (address(manager) != address(0))\n            IAfEth(manager).depositRewards{value: ethReceived}(ethReceived);\n        else depositRewards(ethReceived);\n    }\n\n    /**\n     * @notice - Internal utility function to claim votium reward tokens\n     * @param _claimProofs - Array of claim proofs\n     */\n    function claimVotiumRewards(\n        IVotiumMerkleStash.ClaimParam[] calldata _claimProofs\n    ) private {\n        IVotiumMerkleStash(0x378Ba9B73309bE80BF4C2c027aAD799766a7ED5A)\n            .claimMulti(address(this), _claimProofs);\n    }\n\n    /**\n     * @notice - Internal utility function to claim vlCvx reward tokens\n     */\n    function claimVlCvxRewards() private {\n        address[] memory emptyArray;\n        IClaimZap(0x3f29cB4111CbdA8081642DA1f75B3c12DECf2516).claimRewards(\n            emptyArray,\n            emptyArray,\n            emptyArray,\n            emptyArray,\n            0,\n            0,\n            0,\n            0,\n            8\n        );\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/strategies/votium/VotiumStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./VotiumStrategyCore.sol\";\n\n/// @title Votium Strategy Token\n/// @author Asymmetry Finance\ncontract VotiumStrategy is VotiumStrategyCore, AbstractStrategy {\n    event WithdrawRequest(\n        address indexed user,\n        uint256 amount,\n        uint256 withdrawId\n    );\n\n    struct WithdrawRequestInfo {\n        uint256 cvxOwed;\n        bool withdrawn;\n        uint256 epoch;\n        address owner;\n    }\n\n    mapping(uint256 => WithdrawRequestInfo)\n        public withdrawIdToWithdrawRequestInfo;\n\n    /**\n     * @notice Gets price in eth\n     * @return Price of token in eth\n     */\n    function price() external view override returns (uint256) {\n        return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n    }\n\n    /**\n     * @notice Deposit eth to mint this token at current price\n     * @return mintAmount Amount of tokens minted\n     */\n    function deposit() public payable override returns (uint256 mintAmount) {\n        uint256 priceBefore = cvxPerVotium();\n        uint256 cvxAmount = buyCvx(msg.value);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        mintAmount = ((cvxAmount * 1e18) / priceBefore);\n        _mint(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Request to withdraw from strategy emits event with eligible withdraw epoch\n     * @notice Burns afEth tokens and determines equivilent amount of cvx to start unlocking\n     * @param _amount Amount to request withdraw\n     * @return withdrawId Id of withdraw request\n     */\n    function requestWithdraw(\n        uint256 _amount\n    ) public override returns (uint256 withdrawId) {\n        latestWithdrawId++;\n        uint256 _priceInCvx = cvxPerVotium();\n\n        _burn(msg.sender, _amount);\n\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        cvxUnlockObligations += cvxAmount;\n\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n                (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n                    .epochs(currentEpoch);\n                uint256 timeDifference = lockedBalances[i].unlockTime -\n                    currentEpochStartingTime;\n                uint256 epochOffset = timeDifference /\n                    ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n                uint256 withdrawEpoch = currentEpoch + epochOffset;\n                withdrawIdToWithdrawRequestInfo[\n                    latestWithdrawId\n                ] = WithdrawRequestInfo({\n                    cvxOwed: cvxAmount,\n                    withdrawn: false,\n                    epoch: withdrawEpoch,\n                    owner: msg.sender\n                });\n\n                emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n                return latestWithdrawId;\n            }\n        }\n        // should never get here\n        revert InvalidLockedAmount();\n    }\n\n    /**\n     * @notice Withdraws from requested withdraw if eligible epoch has passed\n     * @param _withdrawId Id of withdraw request\n     */\n    function withdraw(uint256 _withdrawId) external override {\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].owner != msg.sender)\n            revert NotOwner();\n        if (!this.canWithdraw(_withdrawId)) revert WithdrawNotReady();\n\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn)\n            revert AlreadyWithdrawn();\n\n        relock();\n\n        uint256 cvxWithdrawAmount = withdrawIdToWithdrawRequestInfo[_withdrawId]\n            .cvxOwed;\n\n        uint256 ethReceived = sellCvx(cvxWithdrawAmount);\n        cvxUnlockObligations -= cvxWithdrawAmount;\n        withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn = true;\n\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice Relocks cvx while ensuring there is enough to cover all withdraw requests\n     * @dev This happens automatically on withdraw but will need to be manually called if no withdraws happen in an epoch where locks are expiring\n     */\n    function relock() public {\n        (, uint256 unlockable, , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        if (unlockable > 0)\n            ILockedCvx(VLCVX_ADDRESS).processExpiredLocks(false);\n        uint256 cvxBalance = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        uint256 cvxAmountToRelock = cvxBalance > cvxUnlockObligations\n            ? cvxBalance - cvxUnlockObligations\n            : 0;\n        if (cvxAmountToRelock > 0) {\n            IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmountToRelock);\n            ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmountToRelock, 0);\n        }\n    }\n\n    /**\n     * @notice Checks if withdraw request is eligible to be withdrawn\n     * @param _withdrawId Id of withdraw request\n     */\n    function canWithdraw(\n        uint256 _withdrawId\n    ) external view virtual override returns (bool) {\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        return\n            withdrawIdToWithdrawRequestInfo[_withdrawId].epoch <= currentEpoch;\n    }\n\n    /**\n     * @notice Checks how long it will take to withdraw a given amount\n     * @param _amount Amount of afEth to check how long it will take to withdraw\n     * @return When it would be withdrawable based on the amount\n     */\n    function withdrawTime(\n        uint256 _amount\n    ) external view virtual override returns (uint256) {\n        uint256 _priceInCvx = cvxPerVotium();\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (\n                totalLockedBalancePlusUnlockable >=\n                cvxUnlockObligations + cvxAmount\n            ) {\n                return lockedBalances[i].unlockTime;\n            }\n        }\n        revert InvalidLockedAmount();\n    }\n}"
    },
    {
      "filename": "contracts/AfEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/strategies/votium/VotiumStrategy.sol\";\nimport \"contracts/external_interfaces/IVotiumStrategy.sol\";\nimport \"contracts/strategies/AbstractStrategy.sol\";\n\n// AfEth is the strategy manager for safEth and votium strategies\ncontract AfEth is Initializable, OwnableUpgradeable, ERC20Upgradeable {\n    uint256 public ratio;\n    uint256 public protocolFee;\n    address public feeAddress;\n    address public constant SAF_ETH_ADDRESS =\n        0x6732Efaf6f39926346BeF8b821a04B6361C4F3e5;\n    address public vEthAddress; // Votium Strategy Address\n    uint256 public latestWithdrawId;\n\n    struct WithdrawInfo {\n        address owner;\n        uint256 amount;\n        uint256 safEthWithdrawAmount;\n        uint256 vEthWithdrawId;\n        uint256 withdrawTime;\n    }\n\n    mapping(uint256 => WithdrawInfo) public withdrawIdInfo;\n    bool public pauseDeposit;\n    bool public pauseWithdraw;\n\n    error StrategyAlreadyAdded();\n    error StrategyNotFound();\n    error InsufficientBalance();\n    error InvalidStrategy();\n    error InvalidFee();\n    error CanNotWithdraw();\n    error NotOwner();\n    error FailedToSend();\n    error FailedToDeposit();\n    error Paused();\n    error BelowMinOut();\n\n    event WithdrawRequest(\n        address indexed account,\n        uint256 amount,\n        uint256 withdrawId,\n        uint256 withdrawTime\n    );\n\n    address private constant CVX_ADDRESS =\n        0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address private constant VLCVX_ADDRESS =\n        0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    uint256 public pendingSafEthWithdraws;\n\n    modifier onlyWithdrawIdOwner(uint256 withdrawId) {\n        if (withdrawIdInfo[withdrawId].owner != msg.sender) revert NotOwner();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    cons"
    }
  ]
}