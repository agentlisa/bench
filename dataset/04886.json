{
  "Title": "[06] Distinguish event emitting between slashing self-stakes and slashing community-stakes",
  "Content": "\nIn `slash()`, the event emitted for slashing of self-stakes and slashing of community-stakes have the same fields. From an off-chain perspective, when a staker is slashed for both self-stakes and community-stakes, `commnuityStakee` address will not be emitted, and it might be hard to distinguish between self-stakes and community-stakes from the same tx.\n\n```solidity\n//id-staking-v2/contracts/IdentityStaking.sol\n\n  function slash(\n    address[] calldata selfStakers,\n    address[] calldata communityStakers,\n    address[] calldata communityStakees,\n    uint88 percent\n  ) external onlyRole(SLASHER_ROLE) whenNotPaused {\n...\n    for (uint256 i = 0; i < numSelfStakers; i++) {\n...\n|>      emit Slash(staker, slashedAmount, currentSlashRound);\n    }\n...\n    for (uint256 i = 0; i < numCommunityStakers; i++) {\n...\n|>      emit Slash(staker, slashedAmount, currentSlashRound);\n    }\n  }\n```\n\nhttps://github.com/code-423n4/2024-03-gitcoin/blob/6529b351cd72a858541f60c52f0e5ad0fb6f1b16/id-staking-v2/contracts/IdentityStaking.sol#L497\n\n### Recommendation\n\nConsider adding `stakee` indexed field in the event of community-stake slashing.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-gitcoin",
  "Code": [
    {
      "filename": "id-staking-v2/contracts/IdentityStaking.sol",
      "content": "// SPDX-License-Identifier: GPL\npragma solidity ^0.8.23;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IIdentityStaking} from \"./IIdentityStaking.sol\";\n\n/// @title IdentityStaking\n/// @author Passport\n/// @notice This contract is used to stake GTC on self/community identity\ncontract IdentityStaking is\n  IIdentityStaking,\n  Initializable,\n  UUPSUpgradeable,\n  AccessControlUpgradeable,\n  PausableUpgradeable\n{\n  /***** SECTION 0: Errors, State, Events *****/\n\n  /// @dev Address parameter cannot be zero\n  error AddressCannotBeZero();\n\n  /// @dev Stake amount must be greater than zero\n  error AmountMustBeGreaterThanZero();\n\n  /// @dev A community stake cannot be placed on the staker's own address\n  error CannotStakeOnSelf();\n\n  /// @dev An ERC20 transfer failed\n  error FailedTransfer();\n\n  /// @dev The lock time must be between 12 and 104 weeks, and after any existing lock\n  error InvalidLockTime();\n\n  /// @dev The stake is still locked and cannot be withdrawn\n  error StakeIsLocked();\n\n  /// @dev The requested withdrawal amount is greater than the stake\n  error AmountTooHigh();\n\n  /// @dev The slash percent must be between 1 and 100\n  error InvalidSlashPercent();\n\n  /// @dev The staker and stakee arrays must be the same length\n  error StakerStakeeMismatch();\n\n  /// @dev The requested funds are greater than the slashed amount for this user\n  error FundsNotAvailableToRelease();\n\n  /// @dev The requested funds are not available to release for this user from the given round\n  error FundsNotAvailableToReleaseFromRound();\n\n  /// @dev The round has already been burned and its slashed stake cannot be released\n  error RoundAlreadyBurned();\n\n  /// @dev The minimum burn round duration has not been met, controlled by the `burnRoundMinimumDuration`\n  error MinimumBurnRoundDurationNotMet();\n\n  /// @notice Role held by addresses which are permitted to submit a slash.\n  bytes32 public constant SLASHER_ROLE = keccak256(\"SLASHER_ROLE\");\n\n  /// @notice Role held by addresses which are permitted to release an un-burned slash.\n  bytes32 public constant RELEASER_ROLE = keccak256(\"RELEASER_ROLE\");\n\n  /// @notice Role held by addresses which are permitted to pause the contract.\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  /// @notice Struct representing a stake\n  /// @param unlockTime The unix time in seconds after which the stake can be withdrawn\n  /// @param amount The amount of GTC staked, with 18 decimals\n  /// @param slashedAmount The amount of GTC slashed (could already be burned)\n  /// @param slashedInRound The round in which the stake was last slashed\n  /// @dev uint88s can hold up to 300 million w/ 18 decimals, or 3x the current max supply\n  ///      `amount` does not include any slashed or burned GTC\n  struct Stake {\n    uint64 unlockTime;\n    uint88 amount;\n    uint88 slashedAmount;\n    uint16 slashedInRound;\n  }\n\n  /// @inheritdoc IIdentityStaking\n  mapping(address => uint88) public userTotalStaked;\n\n  /// @inheritdoc IIdentityStaking\n  mapping(address => Stake) public selfStakes;\n\n  /// @inheritdoc IIdentityStaking\n  mapping(address => mapping(address => Stake)) public communityStakes;\n\n  /// @notice The current round of slashing, incremented on each call to `lockAndBurn`\n  /// @dev uint16 can hold up to 65,535 rounds, or 16,383 years with 90 day rounds\n  ///      Set to `1` in the initializer\n  uint16 public currentSlashRound;\n\n  /// @notice The minimum duration between burn rounds\n  /// @dev This sets the minimum appeal period for a slash\n  ///      Set to `90 days` in the initializer\n  uint64 public burnRoundMinimumDuration;\n\n  /// @notice The timestamp of the last burn\n  uint256 public lastBurnTimestamp;\n\n  /// @notice The address to which all burned tokens are sent\n  /// @dev Set in the initializer\n  ///      This could be set to the zero address. But in the case of GTC,\n  ///      it is set to the GTC token contract address because GTC cannot\n  ///      be transferred to the zero address\n  address public burnAddress;\n\n  /// @notice The total amount of GTC slashed in each round\n  mapping(uint16 => uint88) public totalSlashed;\n\n  /// @notice The GTC token contract\n  IERC20 public token;\n\n  /// @notice Emitted when a self-stake is added/increased/extended\n  /// @param staker The staker's address\n  /// @param amount The additional amount added for this particular transaction\n  /// @param unlockTime Unlock time for the full self-stake amount for this staker\n  /// @dev `amount` could be `0` for an extension\n  event SelfStake(address indexed staker, uint88 amount, uint64 unlockTime);\n\n  /// @notice Emitted when a community stake is added/increased/extended\n  /// @param staker The staker's address\n  /// @param stakee The stakee's address\n  /// @param amount The additional amount added for this particular transaction\n  /// @param unlockTime Unlock time for the full community stake amount for this staker on this stakee\n  /// @dev `amount` could be `0` for an extension\n  event CommunityStake(\n    address indexed staker,\n    address indexed stakee,\n    uint88 amount,\n    uint64 unlockTime\n  );\n\n  /// @notice Emitted when a self-stake is withdrawn\n  /// @param staker The staker's address\n  /// @param amount The amount withdrawn in this transaction\n  event SelfStakeWithdrawn(address indexed staker, uint88 amount);\n\n  /// @notice Emitted when a community stake is withdrawn\n  /// @param staker The staker's address\n  /// @param stakee The stakee's address\n  /// @param amount The amount withdrawn in this transaction\n  event CommunityStakeWithdrawn(address indexed staker, address indexed stakee, uint88 amount);\n\n  /// @notice Emitted when a slash is submitted\n  /// @param staker Address of the staker who is slashed\n  /// @param amount The amount slashed in this transaction\n  /// @param round The round in which the slash occurred\n  event Slash(address indexed staker, uint88 amount, uint16 round);\n\n  /// @notice Emitted when a round is burned\n  /// @param round The round that was burned\n  /// @param amount The amount of GTC burned in this transaction\n  event Burn(uint16 indexed round, uint88 amount);\n\n  /***** SECTION 1: Admin Functions *****/\n\n  /// @notice Initialize the contract\n  /// @param tokenAddress The address of the GTC token contract\n  /// @param _burnAddress The address to which all burned tokens are sent\n  /// @param initialAdmin The initial address to assign the DEFAULT_ADMIN_ROLE\n  /// @param initialSlashers The initial addresses to assign the SLASHER_ROLE\n  /// @param initialReleasers The initial addresses to assign the RELEASER_ROLE\n  function initialize(\n    address tokenAddress,\n    address _burnAddress,\n    address initialAdmin,\n    address[] calldata initialSlashers,\n    address[] calldata initialReleasers\n  ) public initializer {\n    if (tokenAddress == address(0)) {\n      revert AddressCannotBeZero();\n    }\n\n    __AccessControl_init();\n    __Pausable_init();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);\n    _grantRole(PAUSER_ROLE, initialAdmin);\n\n    for (uint256 i = 0; i < initialSlashers.length; i++) {\n      _grantRole(SLASHER_ROLE, initialSlashers[i]);\n    }\n\n    for (uint256 i = 0; i < initialReleasers.length; i++) {\n      _grantRole(RELEASER_ROLE, initialReleasers[i]);\n    }\n\n    token = IERC20(tokenAddress);\n    burnAddress = _burnAddress;\n\n    currentSlashRound = 1;\n    burnRoundMinimumDuration = 90 days;\n    lastBurnTimestamp = block.timestamp;\n  }\n\n  /// @notice Pause the contract\n  function pause() external onlyRole(PAUSER_ROLE) whenNotPaused {\n    _pause();\n  }\n\n  /// @notice Unpause the contract\n  function unpause() external onlyRole(PAUSER_ROLE) whenPaused {\n    _unpause();\n  }\n\n  /// @inheritdoc UUPSUpgradeable\n  /// @dev Only the admin can upgrade the contract\n  /// @dev UUPSUpgradeable allows the contract to be permanently frozen in the future\n  function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n  /***** SECTION 2: Staking Functions *****/\n\n  /// @notice Add self stake\n  /// @param amount The amount of GTC to Stake\n  /// @param duration The duration in seconds of the stake lock period\n  /// @dev The duration must be between 12 weeks and 104 weeks, and after any existing lock\n  ///      The amount must be greater than zero\n  ///      The unlock time is calculated as `block.timestamp + duration`\n  ///      If there is any existing self-stake, the unlock time is extended for the entire stake amount\n  function selfStake(uint88 amount, uint64 duration) external whenNotPaused {\n    if (amount == 0) {\n      revert AmountMustBeGreaterThanZero();\n    }\n\n    uint64 unlockTime = duration + uint64(block.timestamp);\n\n    if (\n      // Must be between 12 weeks and 104 weeks\n      unlockTime < block.timestamp + 12 weeks ||\n      unlockTime > block.timestamp + 104 weeks ||\n      // Must be later than any existing lock\n      unlockTime < selfStakes[msg.sender].unlockTime\n    ) {\n      revert InvalidLockTime();\n    }\n\n    selfStakes[msg.sender].amount += amount;\n    selfStakes[msg.sender].unlockTime = unlockTime;\n    userTotalStaked[msg.sender] += amount;\n\n    emit SelfStake(msg.sender, amount, unlockTime);\n\n    if (!token.transferFrom(msg.sender, address(this), amount)) {\n      revert FailedTransfer();\n    }\n  }\n\n  /// @notice Extend lock period for self stake\n  /// @param duration The duration in seconds for the new lock period\n  /// @dev The duration must be between 12 weeks and 104 weeks, and after any existing lock for this self-stake\n  ///      The unlock time is calculated as `block.timestamp + duration`\n  function extendSelfStake(uint64 duration) external whenNotPaused {\n    if (selfStakes[msg.sender].amount == 0) {\n      revert AmountMustBeGreaterThanZero();\n    }\n\n    uint64 unlockTime = duration + uint64(block.timestamp);\n\n    if (\n      // Must be between 12 weeks and 104 weeks\n      unlockTime < block.timestamp + 12 weeks ||\n      unlockTime > block.timestamp + 104 weeks ||\n      // Must be later than any existing lock\n      unlockTime < selfStakes[msg.sender].unlockTime\n    ) {\n      revert InvalidLockTime();\n    }\n\n    selfStakes[msg.sender].unlockTime = unlockTime;\n\n    emit SelfStake(msg.sender, 0, unlockTime);\n  }\n\n  /// @notice Withdraw unlocked self stake\n  /// @param amount The amount to withdraw\n  function withdrawSelfStake(uint88 amount) external whenNotPaused {\n    Stake storage sStake = selfStakes[msg.sender];\n\n    if (sStake.unlockTime > block.timestamp) {\n      revert StakeIsLocked();\n    }\n\n    if (amount > sStake.amount) {\n      revert AmountTooHigh();\n    }\n\n    sStake.amount -= amount;\n    userTotalStaked[msg.sender] -= amount;\n\n    emit SelfStakeWithdrawn(msg.sender, amount);\n\n    if (!token.transfer(msg.sender, amount)) {\n      revert FailedTransfer();\n    }\n  }\n\n  /// @notice Add community stake on a stakee\n  /// @param stakee The address of the stakee\n  /// @param amount The amount to stake\n  /// @param duration The duration in seconds of the stake lock period\n  /// @dev The duration must be between 12-104 weeks and 104 weeks, and after any existing lock for this staker+stakee\n  ///      The amount must be greater than zero\n  ///      The unlock time is calculated as `block.timestamp + duration`\n  ///      If there is any existing stake by this staker on this stakee, the unlock time is extended for the entire stake amount\n  function communityStake(address stakee, uint88 amount, uint64 duration) external whenNotPaused {\n    if (stakee == msg.sender) {\n      revert CannotStakeOnSelf();\n    }\n    if (stakee == address(0)) {\n      revert AddressCannotBeZero();\n    }\n    if (amount == 0) {\n      revert AmountMustBeGreaterThanZero();\n    }\n\n    uint64 unlockTime = duration + uint64(block.timestamp);\n\n    if (\n      // Must be between 12 weeks and 104 weeks\n      unlockTime < block.timestamp + 12 weeks ||\n      unlockTime > block.timestamp + 104 weeks ||\n      // Must be later than any existing lock\n      unlockTime < communityStakes[msg.sender][stakee].unlockTime\n    ) {\n      revert InvalidLockTime();\n    }\n\n    communityStakes[msg.sender][stakee].amount += amount;\n    communityStakes[msg.sender][stakee].unlockTime = unlockTime;\n    userTotalStaked[msg.sender] += amount;\n\n    emit CommunityStake(msg.sender, stakee, amount, unlockTime);\n\n    if (!token.transferFrom(msg.sender, address(this), amount)) {\n      revert FailedTransfer();\n    }\n  }\n\n  /// @notice Extend lock period for community stake on a stakee\n  /// @param stakee The address of the stakee\n  /// @param duration The duration in seconds for the new lock period\n  /// @dev The duration must be between 12-104 weeks and 104 weeks, and after any existing lock for this staker+stakee\n  ///      The unlock time is calculated as `block.timestamp + duration`\n  function extendCommunityStake(address stakee, uint64 duration) external whenNotPaused {\n    if (stakee == address(0)) {\n      revert AddressCannotBeZero();\n    }\n\n    Stake storage comStake = communityStakes[msg.sender][stakee];\n\n    if (comStake.amount == 0) {\n      revert AmountMustBeGreaterThanZero();\n    }\n\n    uint64 unlockTime = duration + uint64(block.timestamp);\n\n    if (\n      // Must be between 12 weeks and 104 weeks\n      unlockTime < block.timestamp + 12 weeks ||\n      unlockTime > block.timestamp + 104 weeks ||\n      // Must be later than any existing lock\n      unlockTime < comStake.unlockTime\n    ) {\n      revert InvalidLockTime();\n    }\n\n    comStake.unlockTime = unlockTime;\n\n    emit CommunityStake(msg.sender, stakee, 0, unlockTime);\n  }\n\n  /// @notice Withdraw unlocked community stake on a stakee\n  /// @param stakee The address of the stakee\n  /// @param amount The amount to withdraw\n  function withdrawCommunityStake(address stakee, uint88 amount) external whenNotPaused {\n    if (stakee == address(0)) {\n      revert AddressCannotBeZero();\n    }\n\n    if (amount == 0) {\n      revert AmountMustBeGreaterThanZero();\n    }\n\n    Stake storage comStake = communityStakes[msg.sender][stakee];\n\n    if (comStake.unlockTime > block.timestamp) {\n      revert StakeIsLocked();\n    }\n\n    if (amount > comStake.amount) {\n      revert AmountTooHigh();\n    }\n\n    comStake.amount -= amount;\n    userTotalStaked[msg.sender] -= amount;\n\n    emit CommunityStakeWithdrawn(msg.sender, stakee, amount);\n\n    if (!token.transfer(msg.sender, amount)) {\n      revert FailedTransfer();\n    }\n  }\n\n  /***** SECTION 3: Slashing Functions *****/\n\n  /// @notice Submit a slash\n  /// @param selfStakers The addresses of the self-stakers to slash\n  /// @param communityStakers Ordered list of the community-stakers to slash\n  /// @param communityStakees Ordered list of the community-stakees to slash\n  /// @param percent The percentage to slash from each stake\n  /// @dev The slash percent must be between 1 and 100\n  ///      The community staker and stakee arrays must be the same length\n  ///      Ordered such that communityStakers[i] has a communityStake on communityStakees[i]\n  ///      All staked amounts are liable to be slashed, even if they are unlocked\n  function slash(\n    address[] calldata selfStakers,\n    address[] calldata communityStakers,\n    address[] calldata communityStakees,\n    uint88 percent\n  ) external onlyRole(SLASHER_ROLE) whenNotPaused {\n    if (percent > 100 || percent == 0) {\n      revert InvalidSlashPercent();\n    }\n\n    uint256 numSelfStakers = selfStakers.length;\n    uint256 numCommunityStakers = communityStakers.length;\n\n    if (numCommunityStakers != communityStakees.length) {\n      revert StakerStakeeMismatch();\n    }\n\n    for (uint256 i = 0; i < numSelfStakers; i++) {\n      address staker = selfStakers[i];\n      uint88 slashedAmount = (percent * selfStakes[staker].amount) / 100;\n\n      Stake storage sStake = selfStakes[staker];\n\n      if (sStake.slashedInRound != 0 && sStake.slashedInRound != currentSlashRound) {\n        if (sStake.slashedInRound == currentSlashRound - 1) {\n          // If this is a slash from the previous round (not yet burned), move\n          // it to the current round\n          totalSlashed[currentSlashRound - 1] -= sStake.slashedAmount;\n          totalSlashed[currentSlashRound] += sStake.slashedAmount;\n        } else {\n          // Otherwise, this is a stale slash and can be overwritten\n          sStake.slashedAmount = 0;\n        }\n      }\n\n      totalSlashed[currentSlashRound] += slashedAmount;\n\n      sStake.slashedInRound = currentSlashRound;\n      sStake.slashedAmount += slashedAmount;\n      sStake.amount -= slashedAmount;\n\n      userTotalStaked[staker] -= slashedAmount;\n\n      emit Slash(staker, slashedAmount, currentSlashRound);\n    }\n\n    for (uint256 i = 0; i < numCommunityStakers; i++) {\n      address staker = communityStakers[i];\n      address stakee = communityStakees[i];\n      uint88 slashedAmount = (percent * communityStakes[staker][stakee].amount) / 100;\n\n      Stake storage comStake = communityStakes[staker][stakee];\n\n      if (comStake.slashedInRound != 0 && comStake.slashedInRound != currentSlashRound) {\n        if (comStake.slashedInRound == currentSlashRound - 1) {\n          // If this is a slash from the previous round (not yet burned), move\n          // it to the current round\n          totalSlashed[currentSlashRound - 1] -= comStake.slashedAmount;\n          totalSlashed[currentSlashRound] += comStake.slashedAmount;\n        } else {\n          // Otherwise, this is a stale slash and can be overwritten\n          comStake.slashedAmount = 0;\n        }\n      }\n\n      totalSlashed[currentSlashRound] += slashedAmount;\n\n      comStake.slashedInRound = currentSlashRound;\n      comStake.slashedAmount += slashedAmount;\n      comStake.amount -= slashedAmount;\n\n      userTotalStaked[staker] -= slashedAmount;\n\n      emit Slash(staker, slashedAmount, currentSlashRound);\n    }\n  }\n\n  /// @notice Progress to the next slash round, this has 3 effects:\n  ///      1) Locks the current round so that it can be burned after `burnRoundMinimumDuration` has passed\n  ///      2) Burns the previous round\n  ///      3) Starts the new round\n  /// @dev Anyone can call this function, the `burnRoundMinimumDuration` keeps everything in check\n  ///      This is all about enforcing a minimum appeal period for a slash\n  ///      The \"locking\" is implicit, in that the previous round is always burned and there is a minimum duration between burns\n  function lockAndBurn() external whenNotPaused {\n    if (block.timestamp - lastBurnTimestamp < burnRoundMinimumDuration) {\n      revert MinimumBurnRoundDurationNotMet();\n    }\n    uint16 roundToBurn = currentSlashRound - 1;\n    uint88 amountToBurn = totalSlashed[roundToBurn];\n\n    ++currentSlashRound;\n    lastBurnTimestamp = block.timestamp;\n\n    if (amountToBurn > 0) {\n      if (!token.transfer(burnAddress, amountToBurn)) {\n        revert FailedTransfer();\n      }\n    }\n\n    emit Burn(roundToBurn, amountToBurn);\n  }\n\n  /// @notice Release slashed funds\n  /// @param staker The staker's address\n  /// @param stakee The stakee's address\n  /// @param amountToRelease The amount to release\n  /// @param slashRound The round from which to release the funds\n  /// @dev Only funds from the current round and the previous round can be released (prior rounds already burned)\n  ///      If stakee == staker, the funds are released from the self-stake, otherwise from the community-stake\n  ///      Funds can only be released back to the original staker\n  function release(\n    address staker,\n    address stakee,\n    uint88 amountToRelease,\n    uint16 slashRound\n  ) external onlyRole(RELEASER_ROLE) whenNotPaused {\n    if (slashRound < currentSlashRound - 1) {\n      revert RoundAlreadyBurned();\n    }\n\n    if (stakee == address(0)) {\n      revert AddressCannotBeZero();\n    }\n\n    if (staker == address(0)) {\n      revert AddressCannotBeZero();\n    }\n\n    if (staker == stakee) {\n      if (amountToRelease > selfStakes[staker].slashedAmount) {\n        revert FundsNotAvailableToRelease();\n      }\n\n      if (selfStakes[staker].slashedInRound != slashRound) {\n        revert FundsNotAvailableToReleaseFromRound();\n      }\n\n      selfStakes[staker].slashedAmount -= amountToRelease;\n      selfStakes[staker].amount += amountToRelease;\n    } else {\n      if (amountToRelease > communityStakes[staker][stakee].slashedAmount) {\n        revert FundsNotAvailableToRelease();\n      }\n\n      if (communityStakes[staker][stakee].slashedInRound != slashRound) {\n        revert FundsNotAvailableToReleaseFromRound();\n      }\n\n      communityStakes[staker][stakee].slashedAmount -= amountToRelease;\n      communityStakes[staker][stakee].amount += amountToRelease;\n    }\n\n    totalSlashed[slashRound] -= amountToRelease;\n  }\n}"
    }
  ]
}