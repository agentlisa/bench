{
  "Title": "M-7: OperationalStaking::_unstake Delegators can bypass 28 days unstaking cooldown when enough rewards have accumulated",
  "Content": "# Issue M-7: OperationalStaking::_unstake Delegators can bypass 28 days unstaking cooldown when enough rewards have accumulated \n\nSource: https://github.com/sherlock-audit/2023-11-covalent-judging/issues/78 \n\n## Found by \ncergyk, irresponsible, qmdddd\n## Summary\nWhen rewards are distributed, they are distributed evenly accross all of the shares held for a validator. However participants collecting rewards burn shares, and thus receive less rewards in subsequent rounds, compared to participants which have left rewards in the contract. This means that delegators can unstake instead of redeeming rewards, which will progressively replace the initial staked amount with claimable rewards.\n\n## Vulnerability Detail\nWe can see in the function `redeemRewards` that the equivalent amount of shares is burned to redeem:\nhttps://github.com/sherlock-audit/2023-11-covalent/blob/main/cqt-staking/contracts/OperationalStaking.sol#L616-L631\n\nThis means that by redeeming rewards a validator will receive less of the future rewards than the stake he invested.\n\nConversely, this means that delegators can progressively derisk their staking position by burning small quantity of shares from their stake (by calling `unstake`) instead of claiming rewards. When enough rewards accumulated, they have the equivalent of their initial amount in the contract, but it is less risky, since as rewards, they are not subject to the unstaking cooldown of 28 days and can be transferred out immediately.\n\n### Scenario\n\nAlice is a validator staking 35 000 CQT.\nBob delegates 35 000 CQT to Alice.\n\nShares distribution:\n- Alice owns 35 000e18 shares\n- Bob owns 35 000e18 shares\n\nOwner distributes rewards to the tune of 70000 CQT (an exaggerated amount to make the point here)\n\nAlice withdraws all her rewards, and burning half of her shares\nBob unstakes all of his position, but does not redeem his rewards\n\nShares distribution:\n- Alice owns 17 500e18 shares\n- Bob owns 17 500e18 shares\n\nAlice and Bob still have the same number of shares, and have the same claim to future rewards.\nHowever Bob's position has less risk compared to a normal delegator, since he can get all of his funds out anytime by calling `redeemRewards`, and does not have to wait a cooldown period.\n\n## Impact\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse a `claimedRewards` mapping to track already claimed rewards instead of burning shares when redeeming rewards\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid: should provide a POC\n\n\n\n**noslav**\n\nfixed partially by\n[prevent bypassing cooldown with redelegateUnstaked - sa78/sa68/sa76](https://github.com/covalenthq/cqt-staking/pull/125/commits/5bf8940c8d5642652b1987cc74cb2f6780b06b08)\n\n**rogarcia**\n\nPR: https://github.com/covalenthq/cqt-staking/pull/125\ncommit: https://github.com/covalenthq/cqt-staking/pull/125/commits/5bf8940c8d5642652b1987cc74cb2f6780b06b08\n\n\n\n**sherlock-admin**\n\n> Escalate\n> \n>  issue #68  is not a duplicate of this issue at all and should be its own issue.\n\nYou've deleted an escalation for this issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/127",
  "Code": [
    {
      "filename": "cqt-staking/contracts/OperationalStaking.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\ncontract OperationalStaking is OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant DIVIDER = 10 ** 18; // 18 decimals used for scaling rates\n    uint128 public constant REWARD_REDEEM_THRESHOLD = 10 ** 8; // minimum number of tokens that can be redeemed\n    uint128 public constant DEFAULT_VALIDATOR_ENABLE_MIN_STAKE = 35000 * 10 ** 18; // minimum number of self-staked tokens for a validator to become / stay enabled\n    uint128 public constant DEFAULT_DELEGATOR_MIN_STAKE = 10 ** 18; // stake/unstake operations are invalid if they put you below this threshold (except unstaking to 0)\n\n    IERC20Upgradeable public CQT;\n    uint128 public rewardPool; // how many tokens are allocated for rewards\n    uint128 public validatorCoolDown; // how many blocks until validator unstaking is unlocked\n    uint128 public delegatorCoolDown; // how many blocks until delegator unstaking is unlocked\n    uint128 public maxCapMultiplier; // *see readme\n    uint128 public validatorMaxStake; // how many tokens validators can stake at most\n    address public stakingManager;\n    uint128 public validatorsN; // number of validators, used to get validator ids\n    mapping(uint128 => Validator) internal _validators; // id -> validator instance\n\n    uint128 public validatorEnableMinStake; // minimum number of self-staked tokens for a validator to become / stay enabled\n    uint128 public delegatorMinStake; // stake/unstake operations are invalid if they put you below this threshold (except unstaking to 0)\n\n    bool private _unpaused;\n\n    struct Staking {\n        uint128 shares; // # of validator shares that the delegator owns\n        uint128 staked; // # of CQT that a delegator delegated originally through stake() transaction\n    }\n\n    struct Unstaking {\n        uint128 coolDownEnd; // epoch when unstaking can be redeemed\n        uint128 amount; // # of unstaked CQT\n    }\n\n    struct Validator {\n        uint128 commissionAvailableToRedeem;\n        uint128 exchangeRate; // validator exchange rate\n        address _address; // wallet address of the operator which is mapped to the validator instance\n        uint128 delegated; // track amount of tokens delegated\n        uint128 totalShares; // total number of validator shares\n        uint128 commissionRate;\n        uint256 disabledAtBlock;\n        mapping(address => Staking) stakings;\n        mapping(address => Unstaking[]) unstakings;\n        bool frozen;\n    }\n\n    event InitializedSemantics(\n        address cqt,\n        uint128 validatorCoolDown,\n        uint128 delegatorCoolDown,\n        uint128 maxCapMultiplier,\n        uint128 validatorMaxStake,\n        uint128 validatorEnableMinStake,\n        uint128 delegatorMinStake\n    );\n\n    event RewardTokensDeposited(uint128 amount);\n\n    event ValidatorAdded(uint128 indexed id, uint128 commissionRate, address indexed validator);\n\n    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);\n\n    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakeId);\n\n    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n\n    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 indexed unstakeId, uint128 amount);\n\n    event AllocatedTokensTaken(uint128 amount);\n\n    event RewardFailedDueLowPool(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueZeroStake(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueValidatorDisabled(uint128 indexed validatorId, uint128 amount);\n\n    event RewardFailedDueValidatorFrozen(uint128 indexed validatorId, uint128 amount);\n\n    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n\n    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n\n    event StakingManagerChanged(address indexed operationalManager);\n\n    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 amount);\n\n    event ValidatorMaxCapChanged(uint128 amount);\n\n    event ValidatorEnableMinStakeChanged(uint128 amount);\n\n    event DelegatorMinStakeChanged(uint128 amount);\n\n    event ValidatorUnstakeCooldownChanged(uint128 amount);\n\n    event DelegatorUnstakeCooldownChanged(uint128 amount);\n\n    event ValidatorDisabled(uint128 indexed validatorId, uint256 blockNumber);\n\n    event Redelegated(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n\n    event MaxCapMultiplierChanged(uint128 newMaxCapMultiplier);\n\n    event ValidatorEnabled(uint128 indexed validatorId);\n\n    event ValidatorAddressChanged(uint128 indexed validatorId, address indexed newAddress);\n\n    event Paused(address account);\n\n    event Unpaused(address account);\n\n    event ValidatorFrozen(uint128 indexed validatorId, string reason);\n\n    event ValidatorUnfrozen(uint128 indexed validatorId);\n\n    event RewardsDisbursed(uint128 indexed rewardId);\n\n    modifier onlyStakingManager() {\n        require(stakingManager == msg.sender, \"Caller is not stakingManager\");\n        _;\n    }\n\n    modifier onlyStakingManagerOrOwner() {\n        require(msg.sender == stakingManager || msg.sender == owner(), \"Caller is not stakingManager or owner\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(_unpaused, \"paused\");\n        _;\n    }\n\n    function initialize(address cqt, uint128 dCoolDown, uint128 vCoolDown, uint128 maxCapM, uint128 vMaxStake) external initializer {\n        __Ownable_init();\n        validatorCoolDown = vCoolDown; // 180*6857 = ~ 6 months\n        delegatorCoolDown = dCoolDown; //  28*6857 = ~ 28 days\n        maxCapMultiplier = maxCapM;\n        validatorMaxStake = vMaxStake;\n\n        validatorEnableMinStake = DEFAULT_VALIDATOR_ENABLE_MIN_STAKE;\n        delegatorMinStake = DEFAULT_DELEGATOR_MIN_STAKE;\n\n        _unpaused = true;\n\n        CQT = IERC20Upgradeable(cqt);\n        emit InitializedSemantics(cqt, vCoolDown, dCoolDown, maxCapM, vMaxStake, validatorEnableMinStake, delegatorMinStake);\n    }\n\n    function setStakingManagerAddress(address newAddress) external onlyOwner {\n        require(newAddress != address(0), \"Invalid address\");\n        stakingManager = newAddress;\n        emit StakingManagerChanged(newAddress);\n    }\n\n    /*\n     * Transfer CQT from the owner to the contract for reward allocation\n     */\n    function depositRewardTokens(uint128 amount) external onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        unchecked {\n            rewardPool += amount;\n        }\n        _transferToContract(msg.sender, amount);\n        emit RewardTokensDeposited(amount);\n    }\n\n    /*\n     * Transfer reward CQT from the contract to the owner\n     */\n    function takeOutRewardTokens(uint128 amount) external onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        require(amount <= rewardPool, \"Reward pool is too small\");\n        unchecked {\n            rewardPool -= amount;\n        }\n        emit AllocatedTokensTaken(amount);\n        _transferFromContract(msg.sender, amount);\n    }\n\n    /*\n     * Updates validator max cap multiplier that determines how many tokens can be delegated\n     */\n    function setMaxCapMultiplier(uint128 newMaxCapMultiplier) external onlyOwner {\n        require(newMaxCapMultiplier > 0, \"Must be greater than 0\");\n        maxCapMultiplier = newMaxCapMultiplier;\n        emit MaxCapMultiplierChanged(newMaxCapMultiplier);\n    }\n\n    /*\n     * Updates maximum number of tokens that a validator can stake\n     */\n    function setValidatorMaxStake(uint128 maxStake) external onlyOwner {\n        require(maxStake > 0, \"Provided max stake is 0\");\n        validatorMaxStake = maxStake;\n        emit ValidatorMaxCapChanged(maxStake);\n    }\n\n    /*\n     * Updates minimum number of tokens that a validator must self-stake before enabling\n     */\n    function setValidatorEnableMinStake(uint128 minStake) public onlyOwner {\n        require(minStake <= validatorMaxStake, \"minStake cannot be greater than validatorMaxStake\");\n        validatorEnableMinStake = minStake;\n        emit ValidatorEnableMinStakeChanged(minStake);\n    }\n\n    /*\n     * Updates minimum valid position threshold for per-delegator stake\n     */\n    function setDelegatorMinStake(uint128 minStake) public onlyOwner {\n        require(minStake <= validatorMaxStake, \"minStake cannot be greater than validatorMaxStake\");\n        delegatorMinStake = minStake;\n        emit DelegatorMinStakeChanged(minStake);\n    }\n\n    /*\n     * Updates the validator cool down period (in blocks)\n     * Note: this doesn't effect the existing unstakes\n     */\n    function setValidatorCoolDown(uint128 coolDown) external onlyOwner {\n        validatorCoolDown = coolDown;\n        emit ValidatorUnstakeCooldownChanged(coolDown);\n    }\n\n    /*\n     * Updates the delegator cool down period (in blocks)\n     * Note: this doesn't effect the existing unstakes\n     */\n    function setDelegatorCoolDown(uint128 coolDown) external onlyOwner {\n        delegatorCoolDown = coolDown;\n        emit DelegatorUnstakeCooldownChanged(coolDown);\n    }\n\n    /*\n     * Adds new validator instance\n     */\n    function addValidator(address validator, uint128 commissionRate) external onlyStakingManager whenNotPaused returns (uint256 id) {\n        require(commissionRate < DIVIDER, \"Rate must be less than 100%\");\n        require(validator != address(0), \"Validator address is 0\");\n        Validator storage v = _validators[validatorsN]; // use current number of validators for the id of a new validator instance\n        v._address = validator;\n        v.exchangeRate = uint128(DIVIDER); // make it 1:1 initially\n        v.commissionRate = commissionRate;\n        v.disabledAtBlock = 1; // set it to 1 to indicate that the validator is disabled\n\n        emit ValidatorAdded(validatorsN, commissionRate, validator);\n        unchecked {\n            validatorsN += 1;\n        }\n\n        return validatorsN - 1;\n    }\n\n    /*\n     * Reward emission\n     */\n    function rewardValidators(uint128 rewardId, uint128[] calldata ids, uint128[] calldata amounts) external onlyStakingManager whenNotPaused {\n        require(ids.length == amounts.length, \"Given ids and amounts arrays must be of the same length\");\n        uint128 newRewardPool = rewardPool;\n        uint128 amount;\n        uint128 validatorId;\n        uint128 commissionPaid;\n\n        for (uint256 j = 0; j < ids.length; j++) {\n            amount = amounts[j];\n            validatorId = ids[j];\n\n            // make sure there are enough tokens in the reward pool\n            if (newRewardPool < amount) {\n                emit RewardFailedDueLowPool(validatorId, amount);\n                continue;\n            }\n\n            Validator storage v = _validators[validatorId];\n\n            if (v.frozen) {\n                emit RewardFailedDueValidatorFrozen(validatorId, amount);\n                continue;\n            }\n\n            if (v.disabledAtBlock != 0) {\n                // validator became disabled (due to e.g. unstaking past base stake)\n                // between proof submission and finalization\n                emit RewardFailedDueValidatorDisabled(validatorId, amount);\n                continue;\n            }\n\n            if (v.totalShares == 0) {\n                // mathematically undefined -- no exchangeRate can turn zero into nonzero\n                // (this condition is only possible in testing with minValidatorEnableStake == 0;\n                //  in prod, validators with zero stake will always be disabled and so will trigger\n                //  the above check, not this one)\n                emit RewardFailedDueZeroStake(validatorId, amount);\n                continue;\n            }\n\n            commissionPaid = uint128((uint256(amount) * uint256(v.commissionRate)) / DIVIDER);\n\n            // distribute the tokens by increasing the exchange rate\n            // div by zero impossible due to check above\n            // (and in fact, presuming minValidatorEnableStake >= DIVIDER, v.totalShares will\n            //  always be >= DIVIDER while validator is enabled)\n            v.exchangeRate += uint128((uint256(amount - commissionPaid) * uint256(DIVIDER)) / v.totalShares);\n\n            // commission is not compounded\n            // commisison is distributed under the validator instance\n            v.commissionAvailableToRedeem += commissionPaid;\n\n            newRewardPool -= amount;\n        }\n\n        rewardPool = newRewardPool; // can never access these tokens anymore, reserved for validator rewards\n        emit RewardsDisbursed(rewardId);\n    }\n\n    /*\n     * Disables validator instance starting from the given block\n     */\n    function disableValidator(uint128 validatorId) external onlyStakingManagerOrOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        _validators[validatorId].disabledAtBlock = block.number;\n        emit ValidatorDisabled(validatorId, block.number);\n    }\n\n    /*\n     * Enables validator instance by setting the disabledAtBlock to 0\n     */\n    function enableValidator(uint128 validatorId) external onlyStakingManagerOrOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[validatorId];\n\n        if (v.disabledAtBlock == 0) {\n            // if validator is already enabled, succeed quietly\n            return;\n        }\n\n        uint128 staked = _sharesToTokens(v.stakings[v._address].shares, v.exchangeRate);\n\n        require(staked >= validatorEnableMinStake, \"Validator is insufficiently staked\");\n\n        v.disabledAtBlock = 0;\n        emit ValidatorEnabled(validatorId);\n    }\n\n    /*\n     * Determines whether a validator is currently able to be used by operators\n     */\n    function isValidatorEnabled(uint128 validatorId) external view returns (bool) {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        return _validators[validatorId].disabledAtBlock == 0;\n    }\n\n    /*\n     * Updates validator comission rate\n     * Commission rate is a number between 0 and 10^18 (0%-100%)\n     */\n    function setValidatorCommissionRate(uint128 validatorId, uint128 amount) external onlyOwner {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(amount < DIVIDER, \"Rate must be less than 100%\");\n        _validators[validatorId].commissionRate = amount;\n        emit ValidatorCommissionRateChanged(validatorId, amount);\n    }\n\n    /*\n     * Used to transfer CQT from delegators, validators, and the owner to the contract\n     */\n    function _transferToContract(address from, uint128 amount) internal {\n        CQT.safeTransferFrom(from, address(this), amount);\n    }\n\n    /*\n     * Used to transfer CQT from contract, for reward redemption or transferring out unstaked tokens\n     */\n    function _transferFromContract(address to, uint128 amount) internal {\n        CQT.safeTransfer(to, amount);\n    }\n\n    /*\n     * Used to convert validator shares to CQT\n     */\n    function _sharesToTokens(uint128 sharesN, uint128 rate) internal pure returns (uint128) {\n        return uint128((uint256(sharesN) * uint256(rate)) / DIVIDER);\n    }\n\n    /*\n     * Used to convert CQT to validator shares\n     */\n    function _tokensToShares(uint128 amount, uint128 rate) internal pure returns (uint128) {\n        return uint128((uint256(amount) * DIVIDER) / uint256(rate));\n    }\n\n    /*\n     * Delegates tokens under the provided validator\n     */\n    function stake(uint128 validatorId, uint128 amount) external whenNotPaused {\n        _stake(validatorId, amount, true);\n    }\n\n    /*\n     * withTransfer is set to false when delegators recover unstaked or redelegated tokens.\n     * These tokens are already in the contract.\n     */\n    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(amount >= REWARD_REDEEM_THRESHOLD, \"Stake amount is too small\");\n        Validator storage v = _validators[validatorId];\n        bool isValidator = msg.sender == v._address;\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        // validators should be able to stake if they are disabled.\n        if (!isValidator) require(v.disabledAtBlock == 0, \"Validator is disabled\");\n\n        Staking storage s = v.stakings[msg.sender];\n\n        uint128 newStaked = s.staked + amount;\n\n        require(newStaked >= delegatorMinStake, \"Cannot stake to a position less than delegatorMinStake\");\n\n        uint128 sharesAdd = _tokensToShares(amount, v.exchangeRate);\n\n        if (isValidator) {\n            // compares with newStaked to ignore compounded rewards\n            require(newStaked <= validatorMaxStake, \"Validator max stake exceeded\");\n        } else {\n            // cannot stake more than validator delegation max cap\n            uint128 delegationMaxCap = v.stakings[v._address].staked * maxCapMultiplier;\n            uint128 newDelegated = v.delegated + amount;\n            require(newDelegated <= delegationMaxCap, \"Validator max delegation exceeded\");\n            v.delegated = newDelegated;\n        }\n\n        // \"buy/mint\" shares\n        v.totalShares += sharesAdd;\n        s.shares += sharesAdd;\n\n        // keep track of staked tokens\n        s.staked = newStaked;\n        if (withTransfer) _transferToContract(msg.sender, amount);\n        emit Staked(validatorId, msg.sender, amount);\n    }\n\n    /*\n     * Undelegates all staked tokens from the provided validator\n     */\n    function unstakeAll(uint128 validatorId) external whenNotPaused {\n        _unstake(validatorId, 0); // pass 0 to request full amount\n    }\n\n    /*\n     * Undelegates some number of tokens from the provided validator\n     */\n    function unstake(uint128 validatorId, uint128 amount) external whenNotPaused {\n        require(amount > 0, \"Amount is 0\");\n        _unstake(validatorId, amount);\n    }\n\n    /*\n     * Undelegates tokens from the provided validator\n     */\n    function _unstake(uint128 validatorId, uint128 amount) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n\n        Validator storage v = _validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(amount <= s.staked, \"Cannot unstake amount greater than current stake\");\n\n        bool isUnstakingAll = amount == 0 || amount == s.staked;\n        uint128 effectiveAmount = isUnstakingAll ? s.staked : amount;\n        uint128 newStaked = s.staked - effectiveAmount;\n\n        if (isUnstakingAll) {\n            // enforce precondition for later math that effectiveAmount is always nonzero\n            require(effectiveAmount > 0, \"Already fully unstaked\");\n        } else {\n            // to prevent buildup of Unstaking[] elements, do not allow user to repeatedly unstake trivial amounts\n            // (but do allow removal of a trivial amount if it is the entire remaining stake)\n            require(effectiveAmount >= REWARD_REDEEM_THRESHOLD, \"Unstake amount is too small\");\n\n            // to prevent \"spam\" delegations, and runaway exchangeRate inflation from all-but-dust self-stake unstaking,\n            // disallow unstaking that would result in a new stake below delegatorMinStake\n            // (with the exception of an unstaking that takes the stake exactly to zero)\n            require(newStaked >= delegatorMinStake, \"Cannot unstake to a position below delegatorMinStake (except to zero)\");\n        }\n\n        bool isValidator = msg.sender == v._address;\n        if (isValidator && v.disabledAtBlock == 0) {\n            // validators will have to disable themselves if they want to unstake tokens below delegation max cap\n            uint128 newValidatorMaxCap = newStaked * maxCapMultiplier;\n            require(v.delegated <= newValidatorMaxCap, \"Cannot decrease delegation max-cap below current delegation while validator is enabled\");\n        }\n        if (!isValidator) {\n            v.delegated -= effectiveAmount;\n        }\n\n        uint128 sharesToRemove = _tokensToShares(effectiveAmount, v.exchangeRate);\n\n        // sometimes, due to conversion inconsistencies, sharesToRemove might end up larger than s.shares;\n        // so we clamp sharesToRemove to s.shares (the redeemer unstakes trivially more tokens in this case)\n        if (sharesToRemove > s.shares) sharesToRemove = s.shares;\n\n        // sanity check: sharesToRemove should never be zero while amount is nonzero, as this would enable\n        // infinite draining of funds\n        require(sharesToRemove > 0, \"Underflow error\");\n\n        unchecked {\n            s.shares -= sharesToRemove;\n        }\n        v.totalShares -= sharesToRemove;\n\n        // remove staked tokens\n        s.staked = newStaked;\n\n        // disable validator if they unstaked to below their required self-stake\n        if (isValidator && validatorEnableMinStake > 0 && v.disabledAtBlock == 0 && s.staked < validatorEnableMinStake) {\n            uint256 disabledAtBlock = block.number;\n            v.disabledAtBlock = disabledAtBlock;\n            emit ValidatorDisabled(validatorId, disabledAtBlock);\n        }\n\n        // create unstaking instance\n        uint128 coolDownEnd = uint128(v.disabledAtBlock != 0 ? v.disabledAtBlock : block.number);\n        unchecked {\n            coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown);\n        }\n        uint128 unstakeId = uint128(v.unstakings[msg.sender].length);\n        v.unstakings[msg.sender].push(Unstaking(coolDownEnd, effectiveAmount));\n        emit Unstaked(validatorId, msg.sender, effectiveAmount, unstakeId);\n    }\n\n    /*\n     * Restakes unstaked tokens (with the same validator)\n     */\n    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) external whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(_validators[validatorId].unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = _validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);\n        _stake(validatorId, amount, false);\n    }\n\n    /*\n     * Transfers out unlocked unstaked tokens back to the delegator\n     */\n    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) external whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(_validators[validatorId].unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = _validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(uint128(block.number) > us.coolDownEnd, \"Cooldown period has not ended\");\n        require(us.amount >= amount, \"Amount is too high\");\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit UnstakeRedeemed(validatorId, msg.sender, unstakingId, amount);\n        _transferFromContract(msg.sender, amount);\n    }\n\n    /*\n     * Redeems all available rewards\n     */\n    function redeemAllRewards(uint128 validatorId, address beneficiary) external whenNotPaused {\n        _redeemRewards(validatorId, beneficiary, 0); // pass 0 to request full amount\n    }\n\n    /*\n     * Redeems partial rewards\n     */\n    function redeemRewards(uint128 validatorId, address beneficiary, uint128 amount) external whenNotPaused {\n        require(amount > 0, \"Amount is 0\");\n        _redeemRewards(validatorId, beneficiary, amount);\n    }\n\n    function _redeemRewards(uint128 validatorId, address beneficiary, uint128 amount) internal {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(beneficiary != address(0x0), \"Invalid beneficiary\");\n        Validator storage v = _validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        // how many tokens a delegator/validator has in total on the contract\n        // include earned commission if the delegator is the validator\n        uint128 totalValue = _sharesToTokens(s.shares, v.exchangeRate);\n\n        // how many tokens a delegator/validator has \"unlocked\", free to be redeemed\n        // (i.e. not staked or in unstaking cooldown)\n        uint128 totalUnlockedValue = (totalValue < s.staked) ? 0 : (totalValue - s.staked);\n\n        bool isRedeemingAll = (amount == 0 || amount == totalUnlockedValue); // amount is 0 when it's requested to redeem all rewards\n\n        // make sure rewards exist\n        // (note that this still works in the case where we're redeeming all! always doing this check saves a branch op)\n        require(amount <= totalUnlockedValue, \"Cannot redeem amount greater than held, unstaked rewards\");\n\n        uint128 effectiveAmount = isRedeemingAll ? totalUnlockedValue : amount;\n\n        // can only redeem above redeem threshold\n        require(effectiveAmount >= REWARD_REDEEM_THRESHOLD, \"Requested amount must be higher than redeem threshold\");\n\n        uint128 sharesToBurn = _tokensToShares(effectiveAmount, v.exchangeRate);\n\n        // sometimes, due to conversion inconsistencies, sharesToBurn might end up larger than s.shares;\n        // so we clamp sharesToBurn to s.shares (the redeemer gets trivially more value out in this case)\n        if (sharesToBurn > s.shares) sharesToBurn = s.shares;\n\n        // sanity check: sharesToBurn should never be zero while effectiveAmount is nonzero, as this\n        // would enable infinite draining of funds\n        require(sharesToBurn > 0, \"Underflow error\");\n\n        unchecked {\n            v.totalShares -= sharesToBurn;\n        }\n        unchecked {\n            s.shares -= sharesToBurn;\n        }\n\n        emit RewardRedeemed(validatorId, beneficiary, effectiveAmount);\n        _transferFromContract(beneficiary, effectiveAmount);\n    }\n\n    function redeemCommission(uint128 validatorId, address beneficiary, uint128 amount) public whenNotPaused {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        require(beneficiary != address(0x0), \"Invalid beneficiary\");\n        Validator storage v = _validators[validatorId];\n        require(v._address == msg.sender, \"The sender is not the validator\");\n\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(v.commissionAvailableToRedeem > 0, \"No commission available to redeem\");\n        require(amount > 0, \"The requested amount is 0\");\n        require(amount <= v.commissionAvailableToRedeem, \"Requested amount is higher than commission available to redeem\");\n        unchecked {\n            v.commissionAvailableToRedeem -= amount;\n        }\n\n        _transferFromContract(beneficiary, amount);\n        emit CommissionRewardRedeemed(validatorId, beneficiary, amount);\n    }\n\n    function redeemAllCommission(uint128 validatorId, address beneficiary) external whenNotPaused {\n        redeemCommission(validatorId, beneficiary, _validators[validatorId].commissionAvailableToRedeem);\n    }\n\n    /*\n     * Redelegates tokens to another validator if a validator got disabled.\n     * First the tokens need to be unstaked\n     */\n    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) external whenNotPaused {\n        require(oldValidatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[oldValidatorId];\n\n        // assets of delegators cannot be moved while validator is frozen\n        require(!v.frozen, \"Validator is frozen\");\n\n        require(v.disabledAtBlock != 0, \"Validator is not disabled\");\n        require(v._address != msg.sender, \"Validator cannot redelegate\");\n        require(v.unstakings[msg.sender].length > unstakingId, \"Unstaking does not exist\");\n        Unstaking storage us = v.unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        // stake tokens back to the contract using new validator, set withTransfer to false since the tokens are already in the contract\n        unchecked {\n            us.amount -= amount;\n        }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0) us.coolDownEnd = 0;\n        emit Redelegated(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);\n        _stake(newValidatorId, amount, false);\n    }\n\n    /*\n     * Changes the validator staking address, this will transfer validator staking data and optionally unstakings\n     */\n    function setValidatorAddress(uint128 validatorId, address newAddress) external whenNotPaused {\n        Validator storage v = _validators[validatorId];\n        require(msg.sender == v._address, \"Sender is not the validator\");\n        require(v._address != newAddress, \"The new address cannot be equal to the current validator address\");\n        require(newAddress != address(0), \"Invalid validator address\");\n        require(!v.frozen, \"Validator is frozen\");\n\n        v.stakings[newAddress].shares += v.stakings[msg.sender].shares;\n        v.stakings[newAddress].staked += v.stakings[msg.sender].staked;\n        delete v.stakings[msg.sender];\n\n        Unstaking[] storage oldUnstakings = v.unstakings[msg.sender];\n        uint256 length = oldUnstakings.length;\n        require(length <= 300, \"Cannot transfer more than 300 unstakings\");\n        Unstaking[] storage newUnstakings = v.unstakings[newAddress];\n        for (uint128 i = 0; i < length; ++i) {\n            newUnstakings.push(oldUnstakings[i]);\n        }\n        delete v.unstakings[msg.sender];\n\n        v._address = newAddress;\n        emit ValidatorAddressChanged(validatorId, newAddress);\n    }\n\n    /*\n     * Gets metadata\n     */\n    function getMetadata()\n        external\n        view\n        returns (\n            address CQTaddress,\n            address _stakingManager,\n            uint128 _validatorsN,\n            uint128 _rewardPool,\n            uint128 _validatorCoolDown,\n            uint128 _delegatorCoolDown,\n            uint128 _maxCapMultiplier,\n            uint128 _validatorMaxStake,\n            uint128 _validatorEnableMinStake,\n            uint128 _delegatorMinStake\n        )\n    {\n        return (\n            address(CQT),\n            stakingManager,\n            validatorsN,\n            rewardPool,\n            validatorCoolDown,\n            delegatorCoolDown,\n            maxCapMultiplier,\n            validatorMaxStake,\n            validatorEnableMinStake,\n            delegatorMinStake\n        );\n    }\n\n    /*\n     * Returns validator metadata with how many tokens were staked and delegated excluding compounded rewards\n     */\n    function getValidatorMetadata(uint128 validatorId) public view returns (address _address, uint128 staked, uint128 delegated, uint128 commissionRate, uint256 disabledAtBlock) {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = _validators[validatorId];\n        return (v._address, v.stakings[v._address].staked, v.delegated, v.commissionRate, v.disabledAtBlock);\n    }\n\n    /*\n     * Returns metadata for each validator\n     */\n    function getAllValidatorsMetadata()\n        external\n        view\n        returns (address[] memory addresses, uint128[] memory staked, uint128[] memory delegated, uint128[] memory commissionRates, uint256[] memory disabledAtBlocks)\n    {\n        return getValidatorsMetadata(0, validatorsN);\n    }\n\n    /*\n     * Returns metadata for validators whose ids are between startId and endId exclusively\n     */\n    function getValidatorsMetadata(\n        uint128 startId,\n        uint128 endId\n    ) public view returns (address[] memory addresses, uint128[] memory staked, uint128[] memory delegated, uint128[] memory commissionRates, uint256[] memory disabledAtBlocks) {\n        require(endId <= validatorsN, \"Invalid end id\");\n        require(startId < endId, \"Start id must be less than end id\");\n\n        uint128 n = endI"
    }
  ]
}