{
  "Title": "[M-12] During oracle outages or feeder outages/disagreement, the ParaSpaceFallbackOracle is not used",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136\n\n\n# Vulnerability details\n\n## Impact\nIf the feeders haven't updated their prices within the default six-hour time window, the floor oracle will revert when requests are made to get the current price, and these reverts are not caught by the wrapper oracle which handles the fallback oracle, so rather than using the fallback oracle in these cases, the calls will revert, leading to liquidations to fail (see my other submission for the full chain from the floor oracle to the liquidation function).\n\nAdditionally, the code uses the deprecated chainlink `latestAnswer()` API for its token requests, which may revert once it is no longer supported\n\n## Proof of Concept\n`getPrice()` will fail if the values are stale:\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #1\n\n236      function getPrice(address _asset)\n237          external\n238          view\n239          override\n240          returns (uint256 price)\n241      {\n242 @>       uint256 updatedAt = assetPriceMap[_asset].updatedAt;\n243          require(\n244              (block.number - updatedAt) <= config.expirationPeriod,\n245 @>           \"NFTOracle: asset price expired\"\n246          );\n247          return assetPriceMap[_asset].twap;\n248:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L236-L248\n\nThey can be stale due to too much price skew, or the feeders being down, e.g. due to another bug:\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #2\n\n369          // config maxPriceDeviation as multiple directly(not percent) for simplicity\n370          if (priceDeviation >= config.maxPriceDeviation) {\n371              return false;\n372:         }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L369-L372\n\n```solidity\nFile: /paraspace-core/contracts/misc/NFTFloorOracle.sol   #3\n\n376      function _finalizePrice(address _asset, uint256 _twap) internal {\n377          PriceInformation storage assetPriceMapEntry = assetPriceMap[_asset];\n378          assetPriceMapEntry.twap = _twap;\n379 @>       assetPriceMapEntry.updatedAt = block.number;\n380          assetPriceMapEntry.updatedTimestamp = block.timestamp;\n381          emit AssetDataSet(\n382              _asset,\n383              assetPriceMapEntry.twap,\n384              assetPriceMapEntry.updatedAt\n385          );\n386:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386\n\nThe wrapper oracle does not use a try-catch, so it can't swallow these reverts and allow the fallback oracle to be used:\n```solidity\nFile: /paraspace-core/contracts/misc/ParaSpaceOracle.sol   #4\n\n114      /// @inheritdoc IPriceOracleGetter\n115      function getAssetPrice(address asset)\n116          public\n117          view\n118          override\n119          returns (uint256)\n120      {\n121          if (asset == BASE_CURRENCY) {\n122              return BASE_CURRENCY_UNIT;\n123          }\n124  \n125          uint256 price = 0;\n126          IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n127          if (address(source) != address(0)) {\n128 @>           price = uint256(source.latestAnswer());\n129          }\n130          if (price == 0 && address(_fallbackOracle) != address(0)) {\n131 @>           price = _fallbackOracle.getAssetPrice(asset);\n132          }\n133  \n134          require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n135          return price;\n136:     }\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136\n\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nUse a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/ParaSpaceOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IEACAggregatorProxy} from \"../interfaces/IEACAggregatorProxy.sol\";\n\nimport {Errors} from \"../protocol/libraries/helpers/Errors.sol\";\nimport {IACLManager} from \"../interfaces/IACLManager.sol\";\nimport {IAtomicPriceAggregator} from \"../interfaces/IAtomicPriceAggregator.sol\";\nimport {IPoolAddressesProvider} from \"../interfaces/IPoolAddressesProvider.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IParaSpaceOracle} from \"../interfaces/IParaSpaceOracle.sol\";\n\n/**\n * @title ParaSpaceOracle\n *\n * @notice Contract to get asset prices, manage price sources and update the fallback oracle\n * - Use of Chainlink Aggregators as first source of price\n * - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallback oracle\n * - Owned by the ParaSpace governance\n */\ncontract ParaSpaceOracle is IParaSpaceOracle {\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n    // Map of asset price sources (asset => priceSource)\n    mapping(address => address) private assetsSources;\n\n    IPriceOracleGetter private _fallbackOracle;\n    address public immutable override BASE_CURRENCY;\n    uint256 public immutable override BASE_CURRENCY_UNIT;\n\n    /**\n     * @dev Only asset listing or pool admin can call functions marked by this modifier.\n     **/\n    modifier onlyAssetListingOrPoolAdmins() {\n        _onlyAssetListingOrPoolAdmins();\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     * @param provider The address of the new PoolAddressesProvider\n     * @param assets The addresses of the assets\n     * @param sources The address of the source of each asset\n     * @param fallbackOracle The address of the fallback oracle to use if the data of an\n     *        aggregator is not consistent\n     * @param baseCurrency The base currency used for the price quotes. If USD is used, base currency is 0x0\n     * @param baseCurrencyUnit The unit of the base currency\n     */\n    constructor(\n        IPoolAddressesProvider provider,\n        address[] memory assets,\n        address[] memory sources,\n        address fallbackOracle,\n        address baseCurrency,\n        uint256 baseCurrencyUnit\n    ) {\n        ADDRESSES_PROVIDER = provider;\n        BASE_CURRENCY = baseCurrency;\n        BASE_CURRENCY_UNIT = baseCurrencyUnit;\n        _setFallbackOracle(fallbackOracle);\n        _setAssetsSources(assets, sources);\n        emit BaseCurrencySet(baseCurrency, baseCurrencyUnit);\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function setAssetSources(\n        address[] calldata assets,\n        address[] calldata sources\n    ) external override onlyAssetListingOrPoolAdmins {\n        _setAssetsSources(assets, sources);\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function setFallbackOracle(address fallbackOracle)\n        external\n        override\n        onlyAssetListingOrPoolAdmins\n    {\n        _setFallbackOracle(fallbackOracle);\n    }\n\n    /**\n     * @notice Internal function to set the sources for each asset\n     * @param assets The addresses of the assets\n     * @param sources The address of the source of each asset\n     */\n    function _setAssetsSources(\n        address[] memory assets,\n        address[] memory sources\n    ) internal {\n        require(\n            assets.length == sources.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(\n                assets[i] != BASE_CURRENCY,\n                Errors.SET_ORACLE_SOURCE_NOT_ALLOWED\n            );\n            assetsSources[assets[i]] = sources[i];\n            emit AssetSourceUpdated(assets[i], sources[i]);\n        }\n    }\n\n    /**\n     * @notice Internal function to set the fallback oracle\n     * @param fallbackOracle The address of the fallback oracle\n     */\n    function _setFallbackOracle(address fallbackOracle) internal {\n        _fallbackOracle = IPriceOracleGetter(fallbackOracle);\n        emit FallbackOracleUpdated(fallbackOracle);\n    }\n\n    /// @inheritdoc IPriceOracleGetter\n    function getAssetPrice(address asset)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (asset == BASE_CURRENCY) {\n            return BASE_CURRENCY_UNIT;\n        }\n\n        uint256 price = 0;\n        IEACAggregatorProxy source = IEACAggregatorProxy(assetsSources[asset]);\n        if (address(source) != address(0)) {\n            price = uint256(source.latestAnswer());\n        }\n        if (price == 0 && address(_fallbackOracle) != address(0)) {\n            price = _fallbackOracle.getAssetPrice(asset);\n        }\n\n        require(price != 0, Errors.ORACLE_PRICE_NOT_READY);\n        return price;\n    }\n\n    function getTokenPrice(address asset, uint256 tokenId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        IAtomicPriceAggregator source = IAtomicPriceAggregator(\n            assetsSources[asset]\n        );\n\n        if (address(source) != address(0)) {\n            return source.getTokenPrice(tokenId);\n        }\n\n        revert(Errors.ORACLE_PRICE_NOT_READY);\n    }\n\n    function getTokensPrices(address asset, uint256[] calldata tokenIds)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        IAtomicPriceAggregator source = IAtomicPriceAggregator(\n            assetsSources[asset]\n        );\n\n        if (address(source) != address(0)) {\n            return source.getTokensPrices(tokenIds);\n        }\n\n        revert(Errors.ORACLE_PRICE_NOT_READY);\n    }\n\n    function getTokensPricesSum(address asset, uint256[] calldata tokenIds)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        IAtomicPriceAggregator source = IAtomicPriceAggregator(\n            assetsSources[asset]\n        );\n\n        if (address(source) != address(0)) {\n            return source.getTokensPricesSum(tokenIds);\n        }\n\n        revert(Errors.ORACLE_PRICE_NOT_READY);\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function getAssetsPrices(address[] calldata assets)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory prices = new uint256[](assets.length);\n        for (uint256 i = 0; i < assets.length; i++) {\n            prices[i] = getAssetPrice(assets[i]);\n        }\n        return prices;\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function getSourceOfAsset(address asset)\n        external\n        view\n        override\n        returns (address)\n    {\n        return assetsSources[asset];\n    }\n\n    /// @inheritdoc IParaSpaceOracle\n    function getFallbackOracle() external view returns (address) {\n        return address(_fallbackOracle);\n    }\n\n    function _onlyAssetListingOrPoolAdmins() internal view {\n        IACLManager aclManager = IACLManager(\n            ADDRESSES_PROVIDER.getACLManager()\n        );\n        require(\n            aclManager.isAssetListingAdmin(msg.sender) ||\n                aclManager.isPoolAdmin(msg.sender),\n            Errors.CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN\n        );\n    }\n}"
    }
  ]
}