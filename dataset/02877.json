{
  "Title": "M-2: If an auction has no bidder, the NFT ownership should go back to the loan lenders",
  "Content": "# Issue M-2: If an auction has no bidder, the NFT ownership should go back to the loan lenders \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/258 \n\n## Found by \n\\_\\_141345\\_\\_\n\n## Summary\n\nThe lenders in principal have the claim for the loan collateral, but current rule will let the liquidation caller get the collateral for free. Effectively take advantage from the vault LP, which is not fair.\n\n\n## Vulnerability Detail\n\nAfter the `endAuction()`, the collateral will be released to the initiator. Essentially, the initiator gets the NFT for free. But the lenders of the loan take the loss.\n\nHowever, the lenders should have the claim to the collateral, since originally the funds are provided by the lenders. If the collateral at the end is owned by whoever calls the liquidation function, it is not fair for the lenders. And will discourage future users to use the protocol.\n\n\n## Impact\n\n- Lenders could suffer fund loss in some cases.\n- The unfair mechanism will discourage future users.\n\n\n## Code Snippet\n\nIf there is no bidder, the winner will be assigned to the auction initiator. And the debts will all be wrote off.\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L178-L204\n\nAfter the `endAuction()`, the collateral will be released to the initiator. \nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/CollateralToken.sol#L341-L346\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf there is no bidder for the auction, allow the NFT to get auctioned for another chance.\n\n\n\n## Discussion\n\n**androolloyd**\n\nworking as intended\n\n**141345**\n\nEscalate for 3 USDC\n\nA borrower uses the NFT as collateral, the lender will get the collateral if the borrower defaults, that's how lending works normally. However, according to the current rule, anyone starts the liquidation process could potentially get the collateral, if no bidder bid on the auction. And the liquidator initiator already gets compensated by the initiator fee. \n\nCurrent rule allows for a situation that 3rd user could gain the ownership of the NFT by calling `liquidate()`. But in common practice, it is the lender should claim the ownership of the collateral.\n\nOne step further, if by any chance, the initiator could start some DoS attack and make the protocol inoperable, this rule may become part of the attack, to get the collateral for free.\n\nAlthough it is a corner case, I believe this is a business logic issue.\n\n\n**sherlock-admin**\n\n > Escalate for 3 USDC\n> \n> A borrower uses the NFT as collateral, the lender will get the collateral if the borrower defaults, that's how lending works normally. However, according to the current rule, anyone starts the liquidation process could potentially get the collateral, if no bidder bid on the auction. And the liquidator initiator already gets compensated by the initiator fee. \n> \n> Current rule allows for a situation that 3rd user could gain the ownership of the NFT by calling `liquidate()`. But in common practice, it is the lender should claim the ownership of the collateral.\n> \n> One step further, if by any chance, the initiator could start some DoS attack and make the protocol inoperable, this rule may become part of the attack, to get the collateral for free.\n> \n> Although it is a corner case, I believe this is a business logic issue.\n> \n\nYou've created a valid escalation for 3 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\nWill be rewarded a medium as it requires the auction to end with 0 bids\n\n**sherlock-admin**\n\n> Escalation accepted.\n> \n> Will be rewarded a medium as it requires the auction to end with 0 bids\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "lib/astaria-gpl/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.16;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IAuctionHouse} from \"./interfaces/IAuctionHouse.sol\";\nimport {ITransferProxy} from \"./interfaces/ITransferProxy.sol\";\n\nimport \"./interfaces/IWETH9.sol\";\nimport {ILienToken} from \"../../../src/interfaces/ILienToken.sol\";\nimport {ICollateralToken} from \"../../../src/interfaces/ICollateralToken.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"./utils/SafeCastLib.sol\";\nimport {PublicVault, IPublicVault} from \"../../../src/PublicVault.sol\";\n\ncontract AuctionHouse is Auth, IAuctionHouse {\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using FixedPointMathLib for uint256;\n  // The minimum amount of time left in an auction after a new bid is created\n  uint256 public timeBuffer;\n  // The minimum percentage difference between the last bid amount and the current bid.\n  uint256 public minBidIncrementPercentage;\n\n  // / The address of the WETH contract, so that any ETH transferred can be handled as an ERC-20\n  address public weth;\n\n  ITransferProxy TRANSFER_PROXY;\n  ILienToken LIEN_TOKEN;\n  ICollateralToken COLLATERAL_TOKEN;\n\n  // A mapping of all of the auctions currently running.\n  // collateralToken ID => auction\n  mapping(uint256 => IAuctionHouse.Auction) auctions;\n\n  /*\n   * Constructor\n   */\n  constructor(\n    address weth_,\n    Authority AUTHORITY_,\n    ICollateralToken COLLATERAL_TOKEN_,\n    ILienToken LIEN_TOKEN_,\n    ITransferProxy transferProxy_\n  ) Auth(msg.sender, Authority(address(AUTHORITY_))) {\n    weth = weth_;\n    TRANSFER_PROXY = transferProxy_;\n    COLLATERAL_TOKEN = COLLATERAL_TOKEN_;\n    LIEN_TOKEN = LIEN_TOKEN_;\n    timeBuffer = 15 minutes;\n    // extend 15 minutes after every bid made in last 15 minutes\n    minBidIncrementPercentage = 5;\n    // 5%\n\n    ERC20(weth).safeApprove(address(LIEN_TOKEN), type(uint256).max);\n  }\n\n  /**\n   * @notice Create an auction.\n   * @dev Store the auction details in the auctions mapping and emit an AuctionCreated event.\n   * If there is no curator, or if the curator is the auction creator, automatically approve the auction.\n   */\n  function createAuction(\n    uint256 tokenId,\n    uint256 duration,\n    address initiator,\n    uint256 initiatorFee\n  ) external requiresAuth returns (uint256 reserve) {\n    (reserve, ) = LIEN_TOKEN.stopLiens(tokenId);\n\n    Auction storage newAuction = auctions[tokenId];\n    newAuction.duration = duration.safeCastTo64();\n    newAuction.reservePrice = reserve;\n    newAuction.initiator = initiator;\n    newAuction.initiatorFee = initiatorFee;\n    newAuction.firstBidTime = block.timestamp.safeCastTo64();\n    newAuction.maxDuration = (duration + 1 days).safeCastTo64();\n    newAuction.currentBid = 0;\n\n    emit AuctionCreated(tokenId, duration, reserve);\n  }\n\n  /**\n   * @notice Create a bid on a token, with a given amount.\n   * @dev If provided a valid bid, transfers the provided amount to this contract.\n   * If the auction is run in native ETH, the ETH is wrapped so it can be identically to other\n   * auction currencies in this contract.\n   */\n  function createBid(uint256 tokenId, uint256 amount) external override {\n    address lastBidder = auctions[tokenId].bidder;\n    uint256 currentBid = auctions[tokenId].currentBid;\n    uint256 duration = auctions[tokenId].duration;\n    uint64 firstBidTime = auctions[tokenId].firstBidTime;\n    require(\n      firstBidTime == 0 || block.timestamp < firstBidTime + duration,\n      \"Auction expired\"\n    );\n    require(\n      amount > currentBid + ((currentBid * minBidIncrementPercentage) / 100),\n      \"Must send more than last bid by minBidIncrementPercentage amount\"\n    );\n\n    // If this is the first valid bid, we should set the starting time now.\n    // If it's not, then we should refund the last bidder\n    uint256 vaultPayment = (amount - currentBid);\n\n    if (firstBidTime == 0) {\n      auctions[tokenId].firstBidTime = block.timestamp.safeCastTo64();\n    } else if (lastBidder != address(0)) {\n      uint256 lastBidderRefund = amount - vaultPayment;\n      _handleOutGoingPayment(lastBidder, lastBidderRefund);\n    }\n\n    _handleIncomingPayment(tokenId, vaultPayment, address(msg.sender));\n\n    auctions[tokenId].currentBid = amount;\n    auctions[tokenId].bidder = address(msg.sender);\n\n    bool extended = false;\n    // at this point we know that the timestamp is less than start + duration (since the auction would be over, otherwise)\n    // we want to know by how much the timestamp is less than start + duration\n    // if the difference is less than the timeBuffer, increase the duration by the timeBuffer\n    if (firstBidTime + duration - block.timestamp < timeBuffer) {\n      // Playing code golf for gas optimization:\n      // uint256 expectedEnd = auctions[auctionId].firstBidTime.add(auctions[auctionId].duration);\n      // uint256 timeRemaining = expectedEnd.sub(block.timestamp);\n      // uint256 timeToAdd = timeBuffer.sub(timeRemaining);\n      // uint256 newDuration = auctions[auctionId].duration.add(timeToAdd);\n\n      //TODO: add the cap to the duration, do not let it extend beyond 24 hours extra from max duration\n      uint64 newDuration = uint256(\n        duration + (block.timestamp + timeBuffer - firstBidTime)\n      ).safeCastTo64();\n      if (newDuration <= auctions[tokenId].maxDuration) {\n        auctions[tokenId].duration = newDuration;\n      } else {\n        auctions[tokenId].duration =\n          auctions[tokenId].maxDuration -\n          firstBidTime;\n      }\n      extended = true;\n    }\n\n    emit AuctionBid(\n      tokenId,\n      msg.sender,\n      amount,\n      lastBidder == address(0), // firstBid boolean\n      extended\n    );\n\n    if (extended) {\n      emit AuctionDurationExtended(tokenId, auctions[tokenId].duration);\n    }\n  }\n\n  /**\n   * @notice End an auction, finalizing the bid on if applicable and paying out the respective parties.\n   * @dev If for some reason the auction cannot be finalized (invalid token recipient, for example),\n   * The auction is reset and the NFT is transferred back to the auction creator.\n   */\n  function endAuction(uint256 auctionId)\n    external\n    override\n    requiresAuth\n    returns (address winner)\n  {\n    require(\n      block.timestamp >=\n        auctions[auctionId].firstBidTime + auctions[auctionId].duration,\n      \"Auction hasn't completed\"\n    );\n    Auction storage auction = auctions[auctionId];\n    if (auction.bidder == address(0)) {\n      winner = auction.initiator;\n    } else {\n      winner = auction.bidder;\n    }\n\n    emit AuctionEnded(\n      auctionId,\n      winner,\n      auction.currentBid,\n      auction.recipients\n    );\n    uint256[] memory liensRemaining = LIEN_TOKEN.getLiens(auctionId);\n\n    for (uint256 i = 0; i < liensRemaining.length; i++) {\n      ILienToken.Lien memory lien = LIEN_TOKEN.getLien(liensRemaining[i]);\n      if (\n        PublicVault(LIEN_TOKEN.ownerOf(i)).supportsInterface(\n          type(IPublicVault).interfaceId\n        )\n      ) {\n        PublicVault(LIEN_TOKEN.ownerOf(i)).decreaseYIntercept(lien.amount);\n      }\n    }\n    LIEN_TOKEN.removeLiens(auctionId, liensRemaining);\n    delete auctions[auctionId];\n  }\n\n  /**\n   * @notice Cancel an auction.\n   * @dev Transfers the NFT back to the auction creator and emits an AuctionCanceled event\n   */\n  function cancelAuction(uint256 auctionId, address canceledBy)\n    external\n    requiresAuth\n  {\n    require(\n      auctions[auctionId].currentBid < auctions[auctionId].reservePrice,\n      \"cancelAuction: Auction is at or above reserve\"\n    );\n    _handleIncomingPayment(\n      auctionId,\n      auctions[auctionId].reservePrice,\n      canceledBy\n    );\n    _cancelAuction(auctionId);\n  }\n\n  function getAuctionData(uint256 _auctionId)\n    public\n    view\n    returns (\n      uint256 amount,\n      uint256 duration,\n      uint256 firstBidTime,\n      uint256 reservePrice,\n      address bidder\n    )\n  {\n    IAuctionHouse.Auction memory auction = auctions[_auctionId];\n    return (\n      auction.currentBid,\n      auction.duration,\n      auction.firstBidTime,\n      auction.reservePrice,\n      auction.bidder\n    );\n  }\n\n  event PaymentMade(address, uint256);\n  event PaymentAmount(uint256);\n\n  /**\n   * @dev Given an amount and a currency, transfer the currency to this contract.\n   */\n  function _handleIncomingPayment(\n    uint256 tokenId,\n    uint256 transferAmount,\n    address payer\n  ) internal {\n    require(transferAmount > uint256(0), \"cannot send nothing\");\n\n    Auction storage auction = auctions[tokenId];\n\n    //fee is in percent\n    //muldiv?\n    //        uint256 initiatorPayment = (transferAmount * auction.initiatorFee) / 100;\n    uint256 initiatorPayment = transferAmount.mulDivDown(\n      auction.initiatorFee,\n      100\n    ); //maybe consider making protocl computed like other fees\n\n    TRANSFER_PROXY.tokenTransferFrom(\n      weth,\n      payer,\n      auction.initiator,\n      initiatorPayment\n    );\n    transferAmount -= initiatorPayment;\n\n    uint256[] memory liens = LIEN_TOKEN.getLiens(tokenId);\n    uint256 totalLienAmount = 0;\n    if (liens.length > 0) {\n      for (uint256 i = 0; i < liens.length; ++i) {\n        uint256 payment;\n        uint256 lienId = liens[i];\n\n        ILienToken.Lien memory lien = LIEN_TOKEN.getLien(lienId);\n\n        if (transferAmount >= lien.amount) {\n          payment = lien.amount;\n          transferAmount -= payment;\n        } else {\n          payment = transferAmount;\n          transferAmount = 0;\n        }\n\n        if (payment > 0) {\n          LIEN_TOKEN.makePayment(tokenId, payment, lien.position, payer);\n        }\n      }\n    } else {\n      TRANSFER_PROXY.tokenTransferFrom(\n        weth,\n        payer,\n        COLLATERAL_TOKEN.ownerOf(tokenId),\n        transferAmount\n      );\n    }\n  }\n\n  function _handleOutGoingPayment(address to, uint256 amount) internal {\n    TRANSFER_PROXY.tokenTransferFrom(weth, address(msg.sender), to, amount);\n  }\n\n  function _cancelAuction(uint256 tokenId) internal {\n    emit AuctionCanceled(tokenId);\n    delete auctions[tokenId];\n  }\n\n  function auctionExists(uint256 tokenId) public view returns (bool) {\n    return auctions[tokenId].initiator != address(0);\n  }\n}"
    },
    {
      "filename": "src/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\n\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {\n  ICollateralBase,\n  ICollateralToken\n} from \"./interfaces/ICollateralToken.sol\";\nimport {IERC165} from \"./interfaces/IERC721.sol\";\nimport {IERC721Receiver} from \"./interfaces/IERC721Receiver.sol\";\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\n\ninterface IFlashAction {\n  struct Underlying {\n    address token;\n    uint256 tokenId;\n  }\n\n  function onFlashAction(Underlying calldata, bytes calldata)\n    external\n    returns (bytes32);\n}\n\ninterface ISecurityHook {\n  function getState(address, uint256) external view returns (bytes memory);\n}\n\ncontract CollateralToken is Auth, ERC721, IERC721Receiver, ICollateralToken {\n  using SafeTransferLib for ERC20;\n  using CollateralLookup for address;\n\n  struct Asset {\n    address tokenContract;\n    uint256 tokenId;\n  }\n\n  //mapping of the collateralToken ID and its underlying asset\n  mapping(uint256 => Asset) idToUnderlying;\n  //mapping of a security token hook for an nft's token contract address\n  mapping(address => address) public securityHooks;\n\n  ITransferProxy public TRANSFER_PROXY;\n  ILienToken public LIEN_TOKEN;\n  IAuctionHouse public AUCTION_HOUSE;\n  IAstariaRouter public ASTARIA_ROUTER;\n  uint256 public auctionWindow;\n\n  event Deposit721(\n    address indexed tokenContract,\n    uint256 indexed tokenId,\n    uint256 indexed collateralId,\n    address depositedFor\n  );\n  event ReleaseTo(\n    address indexed underlyingAsset,\n    uint256 assetId,\n    address indexed to\n  );\n  event File(bytes32 indexed what, bytes data);\n\n  constructor(\n    Authority AUTHORITY_,\n    ITransferProxy TRANSFER_PROXY_,\n    ILienToken LIEN_TOKEN_\n  )\n    Auth(msg.sender, Authority(AUTHORITY_))\n    ERC721(\"Astaria Collateral Token\", \"ACT\")\n  {\n    TRANSFER_PROXY = TRANSFER_PROXY_;\n    LIEN_TOKEN = LIEN_TOKEN_;\n\n    auctionWindow = uint256(2 days);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ICollateralToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @notice Sets addresses for the AuctionHouse, CollateralToken, and AstariaRouter contracts to use, as well as the securityHook.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function file(bytes32 what, bytes calldata data) external requiresAuth {\n    if (what == \"setAuctionWindow\") {\n      uint256 value = abi.decode(data, (uint256));\n      auctionWindow = value;\n    } else if (what == \"setAstariaRouter\") {\n      address addr = abi.decode(data, (address));\n      ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else if (what == \"setAuctionHouse\") {\n      address addr = abi.decode(data, (address));\n      AUCTION_HOUSE = IAuctionHouse(addr);\n    } else if (what == \"setSecurityHook\") {\n      (address target, address hook) = abi.decode(data, (address, address));\n      securityHooks[target] = hook;\n    } else {\n      revert(\"unsupported/file\");\n    }\n    emit File(what, data);\n  }\n\n  modifier releaseCheck(uint256 collateralId) {\n    require(\n      uint256(0) == LIEN_TOKEN.getLiens(collateralId).length &&\n        !AUCTION_HOUSE.auctionExists(collateralId),\n      \"must be no liens or auctions to call this\"\n    );\n    _;\n  }\n\n  modifier onlyOwner(uint256 collateralId) {\n    require(ownerOf(collateralId) == msg.sender, \"onlyOwner: only the owner\");\n    _;\n  }\n\n  /**\n   * @notice Executes a FlashAction using locked collateral. A valid FlashAction performs a specified action with the collateral within a single transaction and must end with the collateral being returned to the Vault it was locked in.\n   * @param receiver The FlashAction to execute.\n   * @param collateralId The ID of the CollateralToken to temporarily unwrap.\n   * @param data Input data used in the FlashAction.\n   */\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n    address addr;\n    uint256 tokenId;\n    (addr, tokenId) = getUnderlying(collateralId);\n    IERC721 nft = IERC721(addr);\n\n    bytes memory preTransferState;\n    //look to see if we have a security handler for this asset\n\n    if (securityHooks[addr] != address(0)) {\n      preTransferState = ISecurityHook(securityHooks[addr]).getState(\n        addr,\n        tokenId\n      );\n    }\n    // transfer the NFT to the destination optimistically\n\n    nft.transferFrom(address(this), address(receiver), tokenId);\n    // invoke the call passed by the msg.sender\n    require(\n      receiver.onFlashAction(IFlashAction.Underlying(addr, tokenId), data) ==\n        keccak256(\"FlashAction.onFlashAction\"),\n      \"flashAction: callback failed\"\n    );\n\n    if (securityHooks[addr] != address(0)) {\n      require(\n        keccak256(preTransferState) ==\n          keccak256(ISecurityHook(securityHooks[addr]).getState(addr, tokenId)),\n        \"flashAction: Data must be the same\"\n      );\n    }\n\n    // validate that the NFT returned after the call\n    require(\n      nft.ownerOf(tokenId) == address(this),\n      \"flashAction: NFT not returned\"\n    );\n  }\n\n  /**\n   * @notice Unlocks the NFT for a CollateralToken and sends it to a specified address.\n   * @param collateralId The ID for the CollateralToken of the NFT to unlock.\n   * @param releaseTo The address to send the NFT to.\n   */\n  function releaseToAddress(uint256 collateralId, address releaseTo)\n    public\n    releaseCheck(collateralId)\n  {\n    //check liens\n    require(\n      msg.sender == ownerOf(collateralId),\n      \"You don't have permission to call this\"\n    );\n    _releaseToAddress(collateralId, releaseTo);\n  }\n\n  /**\n   * @dev Transfers locked collateral to a specified address and deletes the reference to the CollateralToken for that NFT.\n   * @param collateralId The ID for the CollateralToken of the NFT to unlock.\n   * @param releaseTo The address to send the NFT to.\n   */\n  function _releaseToAddress(uint256 collateralId, address releaseTo) internal {\n    (address underlyingAsset, uint256 assetId) = getUnderlying(collateralId);\n    IERC721(underlyingAsset).transferFrom(address(this), releaseTo, assetId);\n    delete idToUnderlying[collateralId];\n    _burn(collateralId);\n    emit ReleaseTo(underlyingAsset, assetId, releaseTo);\n  }\n\n  /**\n   * @notice Retrieve the address and tokenId of the underlying NFT of a CollateralToken.\n   * @param collateralId The ID of the CollateralToken wrapping the NFT.\n   * @return The address and tokenId of the underlying NFT.\n   */\n  function getUnderlying(uint256 collateralId)\n    public\n    view\n    returns (address, uint256)\n  {\n    Asset memory underlying = idToUnderlying[collateralId];\n    return (underlying.tokenContract, underlying.tokenId);\n  }\n\n  /**\n   * @notice Retrieve the tokenURI for a CollateralToken.\n   * @param collateralId The ID of the CollateralToken.\n   * @return the URI of the CollateralToken.\n   */\n  function tokenURI(uint256 collateralId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    (address underlyingAsset, uint256 assetId) = getUnderlying(collateralId);\n    return ERC721(underlyingAsset).tokenURI(assetId);\n  }\n\n  /**\n   * @dev Mints a new CollateralToken wrapping an NFT.\n   * @param operator_ the approved sender that called safeTransferFrom\n   * @param from_ the owner of the collateral deposited\n   * @param data_ calldata that is apart of the callback\n   * @return a static return of the receive signature\n   */\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    uint256 collateralId = msg.sender.computeId(tokenId_);\n\n    (address underlyingAsset, ) = getUnderlying(collateralId);\n    if (underlyingAsset == address(0)) {\n      if (msg.sender == address(this) || msg.sender == address(LIEN_TOKEN)) {\n        revert(\"system assets are not valid collateral\");\n      }\n\n      address depositFor = operator_;\n\n      if (operator_ != from_) {\n        depositFor = from_;\n      }\n\n      _mint(depositFor, collateralId);\n\n      idToUnderlying[collateralId] = Asset({\n        tokenContract: msg.sender,\n        tokenId: tokenId_\n      });\n\n      emit Deposit721(msg.sender, tokenId_, collateralId, depositFor);\n    }\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  modifier whenNotPaused() {\n    if (ASTARIA_ROUTER.paused()) {\n      revert(\"protocol is paused\");\n    }\n    _;\n  }\n\n  /**\n   * @notice Begins an auction for the NFT of a liquidated CollateralToken.\n   * @param collateralId The ID of the CollateralToken being liquidated.\n   * @param liquidator The address of the user that triggered the liquidation.\n   */\n  function auctionVault(\n    uint256 collateralId,\n    address liquidator,\n    uint256 liquidatorFee\n  ) external whenNotPaused requiresAuth returns (uint256 reserve) {\n    require(\n      !AUCTION_HOUSE.auctionExists(collateralId),\n      \"auctionVault: auction already exists\"\n    );\n    reserve = AUCTION_HOUSE.createAuction(\n      collateralId,\n      auctionWindow,\n      liquidator,\n      liquidatorFee\n    );\n  }\n\n  /**\n   * @notice Cancels the auction for a CollateralToken and returns the NFT to the borrower.\n   * @param tokenId The ID of the CollateralToken to cancel the auction for.\n   */\n  function cancelAuction(uint256 tokenId) external onlyOwner(tokenId) {\n    require(AUCTION_HOUSE.auctionExists(tokenId), \"Auction doesn't exist\");\n\n    AUCTION_HOUSE.cancelAuction(tokenId, msg.sender);\n  }\n\n  /**\n   * @notice Ends the auction for a CollateralToken.\n   * @param tokenId The ID of the CollateralToken to stop the auction for.\n   */\n  function endAuction(uint256 tokenId) external {\n    require(AUCTION_HOUSE.auctionExists(tokenId), \"Auction doesn't exist\");\n\n    address winner = AUCTION_HOUSE.endAuction(tokenId);\n    _releaseToAddress(tokenId, winner);\n  }\n}"
    }
  ]
}