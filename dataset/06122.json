{
  "Title": "[G-11] Division operations between unsigned could be unchecked",
  "Content": "- Severity: Gas Optimization\n- Confidence: High\n- Total Gas Saved: 425\n\n### Description\nDivision operations on unsigned integers should be unchecked to save gas since they cannot overflow or underflow. Because unsigned integers cannot have negative values, execution of division operations outside `unchecked` blocks adds nothing but overhead. Saves about 85 gas.\n\n<details>\n\n<summary>\nThere are 5 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/core/AMPHClaimer.sol\n```\n \nLine: 250          _cliff = _distributedAmph / BASE_SUPPLY_PER_CLIFF\n```\nShould be unchecked - \\_distributedAmph / BASE\\_SUPPLY\\_PER\\_CLIFF.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/AMPHClaimer.sol#L250](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/AMPHClaimer.sol#L250)\n\n- File: solidity/contracts/core/USDA.sol\n```\n \nLine: 262          _gonsPerFragment = _totalGons / _totalSupply\n```\nShould be unchecked - \\_totalGons / \\_totalSupply.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L262](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/USDA.sol#L262)\n\n- File: solidity/contracts/utils/UFragments.sol\n```\n \nLine: 104          _gonsPerFragment = _totalGons / _totalSupply\n```\nShould be unchecked - \\_totalGons / \\_totalSupply.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L104](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L104)\n\n- File: solidity/contracts/utils/UFragments.sol\n```\n \nLine: 196          uint256 _value = _gonValue / _gonsPerFragment\n```\nShould be unchecked - \\_gonValue / \\_gonsPerFragment.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L196](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L196)\n\n- File: solidity/contracts/utils/UFragments.sol\n```\n \nLine: 245          uint256 _value = _gonValue / _gonsPerFragment\n```\nShould be unchecked - \\_gonValue / \\_gonsPerFragment.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L245](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/utils/UFragments.sol#L245)\n\n</details>\n\n**[0xShaito (Amphora) confirmed](https://github.com/code-423n4/2023-07-amphora-findings/issues/284#issuecomment-1679071625)**\n\n\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/AMPHClaimer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {SafeERC20, IERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\n\n/// @notice AMPHClaimer contract, used to exchange CVX and CRV at a fixed rate for AMPH\ncontract AMPHClaimer is IAMPHClaimer, Ownable {\n  using SafeERC20 for IERC20;\n\n  uint256 internal constant _BASE = 1 ether;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _FIFTY_MILLIONS = 50_000_000 * 1e6;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _TWENTY_FIVE_THOUSANDS = 25_000 * 1e6;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _FIFTY = 50 * 1e6;\n\n  /// @dev The base supply of AMPH per cliff, denominated in 1e6\n  uint256 public constant BASE_SUPPLY_PER_CLIFF = 8_000_000 * 1e6;\n\n  /// @dev The total number of cliffs (for both tokens)\n  uint256 public constant TOTAL_CLIFFS = 1000;\n\n  /// @dev The CVX token\n  IERC20 public immutable CVX;\n\n  /// @dev The CRV token\n  IERC20 public immutable CRV;\n\n  /// @dev The AMPH token\n  IERC20 public immutable AMPH;\n\n  /// @dev The total amount of AMPH minted for rewards in CRV, denominated in 1e6\n  uint256 public distributedAmph;\n\n  /// @dev Percentage of rewards taken in CVX (1e18 == 100%)\n  uint256 public cvxRewardFee;\n\n  /// @dev Percentage of rewards taken in CRV (1e18 == 100%)\n  uint256 public crvRewardFee;\n\n  /// @dev The vault controller\n  IVaultController public vaultController;\n\n  constructor(\n    address _vaultController,\n    IERC20 _amph,\n    IERC20 _cvx,\n    IERC20 _crv,\n    uint256 _cvxRewardFee,\n    uint256 _crvRewardFee\n  ) {\n    vaultController = IVaultController(_vaultController);\n    CVX = _cvx;\n    CRV = _crv;\n    AMPH = _amph;\n\n    cvxRewardFee = _cvxRewardFee;\n    crvRewardFee = _crvRewardFee;\n  }\n\n  /// @notice Claims an amount of AMPH given a CVX and CRV quantity\n  /// @param _vaultId The vault id that is claiming\n  /// @param _cvxTotalRewards The max CVX amount to exchange from the sender\n  /// @param _crvTotalRewards The max CVR amount to exchange from the sender\n  /// @param _beneficiary The receiver of the AMPH rewards\n  /// @return _cvxAmountToSend The amount of CVX that the treasury got\n  /// @return _crvAmountToSend The amount of CRV that the treasury got\n  /// @return _claimedAmph The amount of AMPH received by the beneficiary\n  function claimAmph(\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards,\n    address _beneficiary\n  ) external override returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimedAmph) {\n    (_cvxAmountToSend, _crvAmountToSend, _claimedAmph) =\n      _claimable(msg.sender, _vaultId, _cvxTotalRewards, _crvTotalRewards);\n\n    /// Update the state\n    if (_crvAmountToSend != 0 && _claimedAmph != 0) distributedAmph += (_claimedAmph / 1e12); // scale back to 1e6\n\n    CVX.safeTransferFrom(msg.sender, owner(), _cvxAmountToSend);\n    CRV.safeTransferFrom(msg.sender, owner(), _crvAmountToSend);\n\n    // transfer AMPH token to minter\n    AMPH.safeTransfer(_beneficiary, _claimedAmph);\n\n    emit ClaimedAmph(msg.sender, _cvxAmountToSend, _crvAmountToSend, _claimedAmph);\n  }\n\n  /// @notice Returns the claimable amount of AMPH given a CVX and CRV quantity\n  /// @param _sender The address of the account claiming\n  /// @param _vaultId The vault id that is claiming\n  /// @param _cvxTotalRewards The max CVX amount to exchange from the sender\n  /// @param _crvTotalRewards The max CVR amount to exchange from the sender\n  /// @return _cvxAmountToSend The amount of CVX the user will have to send\n  /// @return _crvAmountToSend The amount of CRV the user will have to send\n  /// @return _claimableAmph The amount of AMPH that would be received by the beneficiary\n  function claimable(\n    address _sender,\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards\n  ) external view override returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimableAmph) {\n    (_cvxAmountToSend, _crvAmountToSend, _claimableAmph) =\n      _claimable(_sender, _vaultId, _cvxTotalRewards, _crvTotalRewards);\n  }\n\n  /// @notice Used by governance to change the vault controller\n  /// @param _newVaultController The new vault controller\n  function changeVaultController(address _newVaultController) external override onlyOwner {\n    vaultController = IVaultController(_newVaultController);\n\n    emit ChangedVaultController(_newVaultController);\n  }\n\n  /// @notice Used by governance to recover tokens from the contract\n  /// @param _token The token to recover\n  /// @param _amount The amount to recover\n  function recoverDust(address _token, uint256 _amount) external override onlyOwner {\n    IERC20(_token).transfer(owner(), _amount);\n\n    emit RecoveredDust(_token, owner(), _amount);\n  }\n\n  /// @notice Used by governance to change the fee taken from the CVX reward\n  /// @param _newFee The new reward fee\n  function changeCvxRewardFee(uint256 _newFee) external override onlyOwner {\n    cvxRewardFee = _newFee;\n\n    emit ChangedCvxRewardFee(_newFee);\n  }\n\n  /// @notice Used by governance to change the fee taken from the CRV reward\n  /// @param _newFee The new reward fee\n  function changeCrvRewardFee(uint256 _newFee) external override onlyOwner {\n    crvRewardFee = _newFee;\n\n    emit ChangedCrvRewardFee(_newFee);\n  }\n\n  /// @dev Receives a total and a percentage, returns the amount equivalent of the percentage\n  function _totalToFraction(uint256 _total, uint256 _fraction) internal pure returns (uint256 _amount) {\n    if (_total == 0) return 0;\n    _amount = (_total * _fraction) / _BASE;\n  }\n\n  /// @dev Doesn't revert but returns 0 so the vault contract doesn't revert on calling the claim function\n  /// @dev Returns the claimable amount of AMPH, also the CVX and CRV the contract will take from the user\n  function _claimable(\n    address _sender,\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards\n  ) internal view returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimableAmph) {\n    if (_sender != vaultController.vaultIdVaultAddress(_vaultId)) return (0, 0, 0);\n\n    uint256 _amphBalance = AMPH.balanceOf(address(this));\n\n    // if amounts are zero, or AMPH balance is zero simply return all zeros\n    if (_crvTotalRewards == 0 || _amphBalance == 0) return (0, 0, 0);\n\n    uint256 _cvxRewardsFeeToExchange = _totalToFraction(_cvxTotalRewards, cvxRewardFee);\n    uint256 _crvRewardsFeeToExchange = _totalToFraction(_crvTotalRewards, crvRewardFee);\n\n    uint256 _amphByCrv = _calculate(_crvRewardsFeeToExchange);\n\n    // Check if all cliffs consumed\n    if (_getCliff((_amphByCrv / 1e12) + distributedAmph) >= TOTAL_CLIFFS) return (0, 0, 0);\n\n    // check for rounding errors\n    if (_amphByCrv == 0) return (0, 0, 0);\n\n    if (_amphBalance >= _amphByCrv) {\n      // contract has the full amount\n      _cvxAmountToSend = _cvxRewardsFeeToExchange;\n      _crvAmountToSend = _crvRewardsFeeToExchange;\n      _claimableAmph = _amphByCrv;\n    } else {\n      // contract doesnt have the full amount\n      return (0, 0, 0);\n    }\n  }\n\n  /// @dev Returns the rate of the token, denominated in 1e6\n  function _getRate(uint256 _distributedAmph) internal pure returns (uint256 _rate) {\n    uint256 _foo = (_TWENTY_FIVE_THOUSANDS * BASE_SUPPLY_PER_CLIFF) / Math.max(_distributedAmph, _FIFTY_MILLIONS);\n    uint256 _bar = (_distributedAmph * 1e12) / (BASE_SUPPLY_PER_CLIFF * _FIFTY);\n\n    _rate = 1e6 + (_foo - _bar);\n  }\n\n  /// @dev Returns how much AMPH would be minted given a token amount\n  function _calculate(uint256 _tokenAmountToSend) internal view returns (uint256 _amphAmount) {\n    if (_tokenAmountToSend == 0) return 0;\n\n    uint256 _tempAmountReceived = _tokenAmountToSend; // CRV, 1e18\n    uint256 _amphToMint; // 1e18\n\n    uint256 _distributedAmph = distributedAmph;\n\n    while (_tempAmountReceived > 0) {\n      uint256 _amphForThisTurn;\n\n      // all cliffs start when a certain amount of CRV is accumulated and finish when a certain amount is reached, this is the start of the current cliff\n      uint256 _bottomLastCliff = _getCliff(_distributedAmph) * BASE_SUPPLY_PER_CLIFF;\n\n      // get rate\n      uint256 _rate = _getRate(_distributedAmph); // 1e6\n\n      // calculate how many AMPH to mint given that rate.\n      // transform the CRV amount to 1e6 and multiply.\n      // perform the mul first to avoid rounding errors.\n      _amphForThisTurn = ((_rate * _tempAmountReceived) / 1e12) / 1e6; // 1e6\n\n      // calculate the amph available for this cliff\n      uint256 _amphAvailableForThisCliff = (_bottomLastCliff + BASE_SUPPLY_PER_CLIFF) - _distributedAmph; // 1e6\n\n      // check if the amount of amph to mint surpasses the cliff\n      if (_amphAvailableForThisCliff < _amphForThisTurn) {\n        /// surpassing the cliff\n        _amphForThisTurn = _amphAvailableForThisCliff;\n        // calculate how many CRV are entering this cliff\n        uint256 _amountTokenToEnter = (_amphAvailableForThisCliff * 1e18) / _rate;\n        _tempAmountReceived -= _amountTokenToEnter;\n      } else {\n        /// within the cliff\n        _tempAmountReceived = 0;\n      }\n\n      _distributedAmph += _amphForThisTurn; // 1e6\n\n      _amphToMint += (_amphForThisTurn * 1e12); // 1e18\n    }\n\n    // return\n    _amphAmount = _amphToMint;\n  }\n\n  /// @dev Returns the current cliff, it will round down but is on purpose\n  function _getCliff(uint256 _distributedAmph) internal pure returns (uint256 _cliff) {\n    _cliff = _distributedAmph / BASE_SUPPLY_PER_CLIFF;\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/core/USDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {Roles} from '@contracts/utils/Roles.sol';\nimport {UFragments} from '@contracts/utils/UFragments.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\n\nimport {IERC20Metadata, IERC20} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\n/// @notice USDA token contract, handles all minting/burning of usda\n/// @dev extends UFragments\ncontract USDA is Pausable, UFragments, IUSDA, ExponentialNoError, Roles {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  bytes32 public constant VAULT_CONTROLLER_ROLE = keccak256('VAULT_CONTROLLER');\n\n  EnumerableSet.AddressSet internal _vaultControllers;\n\n  /// @dev The reserve token\n  IERC20 public sUSD;\n\n  /// @dev The address of the pauser\n  address public pauser;\n\n  /// @dev The reserve amount\n  uint256 public reserveAmount;\n\n  /// @notice Checks if _msgSender() is a valid VaultController\n  modifier onlyVaultController() {\n    _checkRole(VAULT_CONTROLLER_ROLE, _msgSender());\n    _;\n  }\n\n  /// @notice Checks if _msgSender() is pauser\n  modifier onlyPauser() {\n    if (_msgSender() != address(pauser)) revert USDA_OnlyPauser();\n    _;\n  }\n\n  /// @notice Any function with this modifier will call the pay_interest() function before any function logic is called\n  modifier paysInterest() {\n    for (uint256 _i; _i < _vaultControllers.length();) {\n      IVaultController(_vaultControllers.at(_i)).calculateInterest();\n      unchecked {\n        _i++;\n      }\n    }\n    _;\n  }\n\n  constructor(IERC20 _sUSDAddr) UFragments('USDA Token', 'USDA') {\n    sUSD = _sUSDAddr;\n  }\n\n  /// @notice Sets the pauser for both USDA and VaultController\n  /// @dev The pauser is a separate role from the owner\n  function setPauser(address _pauser) external override onlyOwner {\n    pauser = _pauser;\n\n    emit PauserSet(_pauser);\n  }\n\n  /// @notice Pause contract\n  /// @dev Can only be called by the pauser\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpause contract, pauser only\n  /// @dev Can only be called by the pauser\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Deposit sUSD to mint USDA\n  /// @dev Caller should obtain 1 USDA for each sUSD\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the susd transfer\n  /// 'fragments' are the units that we see, so 1000 fragments == 1000 USDA\n  /// 'gons' are the internal accounting unit, used to keep scale.\n  /// We use the variable _gonsPerFragment in order to convert between the two\n  /// try dimensional analysis when doing the math in order to verify units are correct\n  /// @param _susdAmount The amount of sUSD to deposit\n  function deposit(uint256 _susdAmount) external override {\n    _deposit(_susdAmount, _msgSender());\n  }\n\n  /// @notice Deposits sUSD to mint USDA and transfer to a different address\n  /// @param _susdAmount The amount of sUSD to deposit\n  /// @param _target The address to receive the USDA tokens\n  function depositTo(uint256 _susdAmount, address _target) external override {\n    _deposit(_susdAmount, _target);\n  }\n\n  /// @notice Business logic to deposit sUSD and mint USDA for the caller\n  function _deposit(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _mint(_target, _susdAmount);\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n\n    emit Deposit(_target, _susdAmount);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @param _susdAmount The amount of sUSD to withdraw\n  function withdraw(uint256 _susdAmount) external override {\n    _withdraw(_susdAmount, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD to a specific address by burning USDA from the caller\n  /// @dev The _target address should obtain 1 sUSD for every 1 USDA burned from the caller\n  /// @param _susdAmount amount of sUSD to withdraw\n  /// @param _target address to receive the sUSD\n  function withdrawTo(uint256 _susdAmount, address _target) external override {\n    _withdraw(_susdAmount, _target);\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev The caller should obtain 1 sUSD for every 1 USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the sender\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAll() external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _msgSender());\n  }\n\n  /// @notice Withdraw sUSD by burning USDA\n  /// @dev This function is effectively just withdraw, but we calculate the amount for the _target\n  /// @param _target should obtain 1 sUSD for every 1 USDA burned from caller\n  /// @param _susdWithdrawn The amount os sUSD withdrawn\n  function withdrawAllTo(address _target) external override returns (uint256 _susdWithdrawn) {\n    uint256 _balance = this.balanceOf(_msgSender());\n    _susdWithdrawn = _balance > reserveAmount ? reserveAmount : _balance;\n    _withdraw(_susdWithdrawn, _target);\n  }\n\n  /// @notice business logic to withdraw sUSD and burn USDA from the caller\n  function _withdraw(uint256 _susdAmount, address _target) internal paysInterest whenNotPaused {\n    if (reserveAmount == 0) revert USDA_EmptyReserve();\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    if (_susdAmount > this.balanceOf(_msgSender())) revert USDA_InsufficientFunds();\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    sUSD.transfer(_target, _susdAmount);\n    _burn(_msgSender(), _susdAmount);\n\n    emit Withdraw(_target, _susdAmount);\n  }\n\n  /// @notice Admin function to mint USDA\n  /// @param _susdAmount The amount of USDA to mint, denominated in sUSD\n  function mint(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _mint(_msgSender(), _susdAmount);\n  }\n\n  /// @dev mint a specific `amount` of tokens to the `target`\n  function _mint(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\n    _gonBalances[_target] += _amount * __gonsPerFragment;\n    // total supply is in fragments, and so we add amount\n    _totalSupply += _amount;\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\n    _totalGons += _amount * __gonsPerFragment;\n    // emit both a mint and transfer event\n    emit Transfer(address(0), _target, _amount);\n    emit Mint(_target, _amount);\n  }\n\n  /// @notice Admin function to burn USDA\n  /// @param _susdAmount The amount of USDA to burn, denominated in sUSD\n  function burn(uint256 _susdAmount) external override paysInterest onlyOwner {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    _burn(_msgSender(), _susdAmount);\n  }\n\n  /// @dev burn a specific `amount` of tokens from the `target`\n  function _burn(address _target, uint256 _amount) internal {\n    uint256 __gonsPerFragment = _gonsPerFragment;\n    // modify the gonbalances of the sender, subtracting the amount of gons, therefore amount * gonsperfragment\n    _gonBalances[_target] -= (_amount * __gonsPerFragment);\n    // modify totalSupply and totalGons\n    _totalSupply -= _amount;\n    _totalGons -= (_amount * __gonsPerFragment);\n    // emit both a burn and transfer event\n    emit Transfer(_target, address(0), _amount);\n    emit Burn(_target, _amount);\n  }\n\n  /// @notice Donates susd to the protocol reserve\n  /// @param _susdAmount The amount of sUSD to donate\n  function donate(uint256 _susdAmount) external override paysInterest whenNotPaused {\n    if (_susdAmount == 0) revert USDA_ZeroAmount();\n    // Account for the susd received\n    reserveAmount += _susdAmount;\n    sUSD.transferFrom(_msgSender(), address(this), _susdAmount);\n    _donation(_susdAmount);\n  }\n\n  /// @notice Recovers accidentally sent sUSD to this contract\n  /// @param _to The receiver of the dust\n  function recoverDust(address _to) external onlyOwner {\n    // All sUSD sent directly to the contract is not accounted into the reserveAmount\n    // This function allows governance to recover it\n    uint256 _amount = sUSD.balanceOf(address(this)) - reserveAmount;\n    sUSD.transfer(_to, _amount);\n\n    emit RecoveredDust(owner(), _amount);\n  }\n\n  /// @notice Function for the vaultController to mint\n  /// @param _target The address to mint the USDA to\n  /// @param _amount The amount of USDA to mint\n  function vaultControllerMint(address _target, uint256 _amount) external override onlyVaultController whenNotPaused {\n    _mint(_target, _amount);\n  }\n\n  /// @notice Function for the vaultController to burn\n  /// @param _target The address to burn the USDA from\n  /// @param _amount The amount of USDA to burn\n  function vaultControllerBurn(address _target, uint256 _amount) external override onlyVaultController {\n    if (_gonBalances[_target] < (_amount * _gonsPerFragment)) revert USDA_NotEnoughBalance();\n    _burn(_target, _amount);\n  }\n\n  /// @notice Allows VaultController to send sUSD from the reserve\n  /// @param _target The address to receive the sUSD from reserve\n  /// @param _susdAmount The amount of sUSD to send\n  function vaultControllerTransfer(\n    address _target,\n    uint256 _susdAmount\n  ) external override onlyVaultController whenNotPaused {\n    // Account for the susd withdrawn\n    reserveAmount -= _susdAmount;\n    // ensure transfer success\n    sUSD.transfer(_target, _susdAmount);\n\n    emit VaultControllerTransfer(_target, _susdAmount);\n  }\n\n  /// @notice Function for the vaultController to scale all USDA balances\n  /// @param _amount The amount of USDA (e18) to donate\n  function vaultControllerDonate(uint256 _amount) external override onlyVaultController {\n    _donation(_amount);\n  }\n\n  /// @notice Function for distributing the donation to all USDA holders\n  /// @param _amount The amount of USDA to donate\n  function _donation(uint256 _amount) internal {\n    _totalSupply += _amount;\n    if (_totalSupply > MAX_SUPPLY) _totalSupply = MAX_SUPPLY;\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Donation(_msgSender(), _amount, _totalSupply);\n  }\n\n  /// @notice Returns the reserve ratio\n  /// @return _e18reserveRatio The USDA reserve ratio\n  function reserveRatio() external view override returns (uint192 _e18reserveRatio) {\n    _e18reserveRatio = _safeu192((reserveAmount * EXP_SCALE) / _totalSupply);\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                                ROLES\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Adds a new vault controller\n  /// @param _vaultController The new vault controller to add\n  function addVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.add(_vaultController);\n    _grantRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerAdded(_vaultController);\n  }\n\n  /// @notice Removes a vault controller\n  /// @param _vaultController The vault controller to remove\n  function removeVaultController(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n    _revokeRole(VAULT_CONTROLLER_ROLE, _vaultController);\n\n    emit VaultControllerRemoved(_vaultController);\n  }\n\n  /// @notice Removes a vault controller from the list\n  /// @param _vaultController The vault controller to remove\n  /// @dev The vault controller is removed from the list but keeps the role as to not brick it\n  function removeVaultControllerFromList(address _vaultController) external onlyOwner {\n    _vaultControllers.remove(_vaultController);\n\n    emit VaultControllerRemovedFromList(_vaultController);\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/utils/UFragments.sol",
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable */\npragma solidity ^0.8.9;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\n/**\n * @title uFragments ERC20 token\n * @notice USDA uses the uFragments concept from the Ideal Money project to play interest\n *      Implementation is shamelessly borrowed from Ampleforth project\n *      uFragments is a normal ERC20 token, but its supply can be adjusted by splitting and\n *      combining tokens proportionally across all wallets.\n *\n *\n *      uFragment balances are internally represented with a hidden denomination, 'gons'.\n *      We support splitting the currency in expansion and combining the currency on contraction by\n *      changing the exchange rate between the hidden 'gons' and the public 'fragments'.\n */\ncontract UFragments is Ownable, IERC20Metadata {\n  // PLEASE READ BEFORE CHANGING ANY ACCOUNTING OR MATH\n  // Anytime there is division, there is a risk of numerical instability from rounding errors. In\n  // order to minimize this risk, we adhere to the following guidelines:\n  // 1) The conversion rate adopted is the number of gons that equals 1 fragment.\n  //    The inverse rate must not be used--_totalGons is always the numerator and _totalSupply is\n  //    always the denominator. (i.e. If you want to convert gons to fragments instead of\n  //    multiplying by the inverse rate, you should divide by the normal rate)\n  // 2) Gon balances converted into Fragments are always rounded down (truncated).\n  //\n  // We make the following guarantees:\n  // - If address 'A' transfers x Fragments to address 'B'. A's resulting external balance will\n  //   be decreased by precisely x Fragments, and B's external balance will be precisely\n  //   increased by x Fragments.\n  //\n  // We do not guarantee that the sum of all balances equals the result of calling totalSupply().\n  // This is because, for any conversion function 'f()' that has non-zero rounding error,\n  // f(x0) + f(x1) + ... + f(xn) is not always equal to f(x0 + x1 + ... xn).\n\n  event LogRebase(uint256 indexed epoch, uint256 totalSupply);\n  event LogMonetaryPolicyUpdated(address monetaryPolicy);\n\n  /// @notice Thrown when the signature is invalid\n  error UFragments_InvalidSignature();\n\n  /// @notice Thrown when the recipient is invalid\n  error UFragments_InvalidRecipient();\n\n  // Used for authentication\n  address public monetaryPolicy;\n\n  modifier onlyMonetaryPolicy() {\n    require(msg.sender == monetaryPolicy);\n    _;\n  }\n\n  modifier validRecipient(address _to) {\n    if (_to == address(0) || _to == address(this)) revert UFragments_InvalidRecipient();\n    _;\n  }\n\n  uint256 private constant DECIMALS = 18;\n  uint256 private constant MAX_UINT256 = 2 ** 256 - 1;\n  uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 1 * 10 ** DECIMALS;\n\n  // _totalGons is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n  // Use the highest value that fits in a uint256 for max granularity.\n  uint256 public _totalGons; // = INITIAL_FRAGMENTS_SUPPLY * 10**48;\n\n  // MAX_SUPPLY = maximum integer < (sqrt(4*_totalGons + 1) - 1) / 2\n  uint256 public MAX_SUPPLY; // = type(uint128).max; // (2^128) - 1\n\n  uint256 public _totalSupply;\n  uint256 public _gonsPerFragment;\n  mapping(address => uint256) public _gonBalances;\n\n  string public name;\n  string public symbol;\n  uint8 public constant decimals = uint8(DECIMALS);\n\n  // This is denominated in Fragments, because the gons-fragments conversion might change before\n  // it's fully paid.\n  mapping(address => mapping(address => uint256)) private _allowedFragments;\n\n  // EIP-2612: permit â€“ 712-signed approvals\n  // https://eips.ethereum.org/EIPS/eip-2612\n  string public constant EIP712_REVISION = '1';\n  bytes32 public constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  // EIP-2612: keeps track of number of permits per address\n  mapping(address => uint256) private _nonces;\n\n  constructor(string memory _name, string memory _symbol) {\n    name = _name;\n    symbol = _symbol;\n\n    //set og initial values\n    _totalGons = INITIAL_FRAGMENTS_SUPPLY * 10 ** 48;\n    MAX_SUPPLY = 2 ** 128 - 1;\n    _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n    _gonBalances[address(0x0)] = _totalGons; //send starting supply to a burner address so _totalSupply is never 0\n    _gonsPerFragment = _totalGons / _totalSupply;\n    emit Transfer(address(this), address(0x0), _totalSupply);\n  }\n\n  /**\n   * @param _monetaryPolicy The address of the monetary policy contract to use for authentication.\n   */\n  function setMonetaryPolicy(address _monetaryPolicy) external onlyOwner {\n    monetaryPolicy = _monetaryPolicy;\n    emit LogMonetaryPolicyUpdated(_monetaryPolicy);\n  }\n\n  /**\n   * @notice returns the total supply\n   * @return __totalSupply The total number of fragments.\n   */\n  function totalSupply() external view override returns (uint256 __totalSupply) {\n    return _totalSupply;\n  }\n\n  /**\n   * @param _who The address to query.\n   * @return _balance The balance of the specified address.\n   */\n  function balanceOf(address _who) external view override returns (uint256 _balance) {\n    return _gonBalances[_who] / _gonsPerFragment;\n  }\n\n  /**\n   * @param _who The address to query.\n   * @return _balance The gon balance of the specified address.\n   */\n  function scaledBalanceOf(address _who) external view returns (uint256 _balance) {\n    return _gonBalances[_who];\n  }\n\n  /**\n   *  @notice Returns the scaled total supply\n   * @return __totalGons the total number of gons.\n   */\n  function scaledTotalSupply() external view returns (uint256 __totalGons) {\n    return _totalGons;\n  }\n\n  /**\n   * @notice Returns the nonces of a given address\n   * @param _who The address to query.\n   * @return _addressNonces The number of successful permits by the specified address.\n   */\n  function nonces(address _who) public view returns (uint256 _addressNonces) {\n    return _nonces[_who];\n  }\n\n  /**\n   * @notice Returns the EIP712 domain separator\n   * @return _domainSeparator The computed DOMAIN_SEPARATOR to be used off-chain services\n   *         which implement EIP-712.\n   *         https://eips.ethereum.org/EIPS/eip-2612\n   */\n  function DOMAIN_SEPARATOR() public view returns (bytes32 _domainSeparator) {\n    uint256 _chainId;\n    assembly {\n      _chainId := chainid()\n    }\n    return keccak256(\n      abi.encode(EIP712_DOMAIN, keccak256(bytes(name)), keccak256(bytes(EIP712_REVISION)), _chainId, address(this))\n    );\n  }\n\n  /**\n   * @notice Transfer tokens to a specified address.\n   * @param _to The address to transfer to.\n   * @param _value The amount to be transferred.\n   * @return _success True on success, false otherwise.\n   */\n  function transfer(address _to, uint256 _value) external override validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _value * _gonsPerFragment;\n\n    _gonBalances[msg.sender] = _gonBalances[msg.sender] - _gonValue;\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer all of the sender's wallet balance to a specified address.\n   * @param _to The address to transfer to.\n   * @return _success True on success, false otherwise.\n   */\n  function transferAll(address _to) external validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _gonBalances[msg.sender];\n    uint256 _value = _gonValue / _gonsPerFragment;\n\n    delete _gonBalances[msg.sender];\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Function to check the amount of tokens that an owner has allowed to a spender.\n   * @param _owner The address which owns the funds.\n   * @param _spender The address which will spend the funds.\n   * @return _remaining The number of tokens still available for the _spender.\n   */\n  function allowance(address _owner, address _spender) external view override returns (uint256 _remaining) {\n    return _allowedFragments[_owner][_spender];\n  }\n\n  /**\n   * @notice Transfer tokens from one address to another.\n   * @param _from The address you want to send tokens from.\n   * @param _to The address you want to transfer to.\n   * @param _value The amount of tokens to be transferred.\n   * @return _success True on success, false otherwise.\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external override validRecipient(_to) returns (bool _success) {\n    _allowedFragments[_from][msg.sender] = _allowedFragments[_from][msg.sender] - _value;\n\n    uint256 _gonValue = _value * _gonsPerFragment;\n    _gonBalances[_from] = _gonBalances[_from] - _gonValue;\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer all balance tokens from one address to another.\n   * @param _from The address you want to send tokens from.\n   * @param _to The address you want to transfer to.\n   * @return _success True on success, false otherwise.\n   */\n  function transferAllFrom(address _from, address _to) external validRecipient(_to) returns (bool _success) {\n    uint256 _gonValue = _gonBalances[_from];\n    uint256 _value = _gonValue / _gonsPerFragment;\n\n    _allowedFragments[_from][msg.sender] = _allowedFragments[_from][msg.sender] - _value;\n\n    delete _gonBalances[_from];\n    _gonBalances[_to] = _gonBalances[_to] + _gonValue;\n\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @notice Approve the passed address to spend the specified amount of tokens on behalf of\n   * msg.sender. This method is included for ERC20 compatibility.\n   * increaseAllowance and decreaseAllowance should be used instead.\n   * Changing an allowance with this method brings the risk that someone may transfer both\n   * the old and the new allowance - if they are both greater than zero - if a transfer\n   * transaction is mined before the later approve() call is mined.\n   *\n   * @param _spender The addr"
    }
  ]
}