{
  "Title": "M-2: Curve LP staking allows adding false tokensIn to account by setting _claim_rewards to false",
  "Content": "# Issue M-2: Curve LP staking allows adding false tokensIn to account by setting _claim_rewards to false \n\nSource: https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/20 \n\n## Found by \nobront\n\n## Summary\n\nIn CurveLPStakingController.sol and BalancerLPStakingController.sol, `canDepositAndClaim()` and `canWithdrawAndClaim()` assume that the user is claiming reward tokens, and add these tokens to the `tokensIn` array (to add to their account). \n\nHowever, the only requirement to go down this code path is to use the full function signature (ie `deposit(uint256,address,bool)`), so false tokens will be added to a user account if they use the full signature with the `_claim_rewards` bool set to `false`.\n\n## Vulnerability Detail\n\nEach Controller returns an array of `tokensIn` that will be added to the user's account, if they don't already hold a balance.\n\nIn CurveLPStakingController.sol and BalancerLPStakingController.sol, there are two overlapping pairs of function signatures: \n- `deposit(uint256)` and `deposit(uint256,address,bool)` are the same function, but the middle parameter (`_addr`) defaults to `msg.sender` and the final parameter (`_claim_rewards`) defaults to `false`\n- `withdraw(uint256)` and `withdraw(uint256,bool)` are the same function, but the final parameter (`_claim_rewards`) defaults to `false`\n\nThe assumption in the Controller logic is that, if a user uses the full signature, they are claiming their rewards. However, this isn't always the case. It is perfectly valid for a user to use the full function and pass `false` (the default argument) to the `_claim_rewards` parameter.\n\nIn this case, the function signature would lead to `canDepositAndClaim()` or `canWithdrawAndClaim()`, and all the rewards tokens would be added to the user's account.\n\n## Impact\n\nAccounting on user accounts can be thrown off (intentionally or unintentionally), resulting in mismatches between their assets array and hasAsset mapping and the reality of their account.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-sentiment/blob/main/controller-merged/src/balancer/BalancerLPStakingController.sol#L24-L25\n\nhttps://github.com/sherlock-audit/2022-11-sentiment/blob/main/controller-merged/src/balancer/BalancerLPStakingController.sol#L52\n\nhttps://github.com/sherlock-audit/2022-11-sentiment/blob/main/controller-merged/src/balancer/BalancerLPStakingController.sol#L72-L92\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn `canCall()`, decode the calldata to get the value of the `_claim_rewards` bool. If this value is false, call the non-claim version of the function (ie `canDeposit()` instead of `canDepositAndClaim()`).\n\n## Discussion\n\n**ruvaag**\n\nWhile I agree with the issue, I'm not sure if it qualifies as a medium because I don't think this can lead to loss of funds or functionality.\n\n**zobront**\n\nConfirmed fix in https://github.com/sentimentxyz/controller/pull/48\n\n**Evert0x**\n\nI think a medium severity is valid as there is a risk of to let users add tokens to their account that they don't really have.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/17",
  "Code": [
    {
      "filename": "controller-merged/src/balancer/BalancerLPStakingController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\n\ninterface IChildGauge {\n    function lp_token() external view returns (address);\n    function reward_tokens(uint256) external view returns (address);\n}\n\n/**\n    @title Curve LP staking controller\n    @notice Interaction controller for staking curve LP controllers\n*/\ncontract BalancerLPStakingController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice deposit(uint256)\n    bytes4 constant DEPOSIT = 0xb6b55f25;\n\n    /// @notice deposit(uint256,address,bool)\n    bytes4 constant DEPOSITCLAIM = 0x83df6747;\n\n    /// @notice withdraw(uint256)\n    bytes4 constant WITHDRAW = 0x2e1a7d4d;\n\n    /// @notice withdraw(uint256,address,bool)\n    bytes4 constant WITHDRAWCLAIM = 0x00ebf5dd;\n\n    /// @notice claim_rewards()\n    bytes4 constant CLAIM = 0xe6f1daf2;\n\n    /// @notice reward count\n    uint256 constant rewardsCount = 8;\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == DEPOSIT) return canDeposit(target);\n        if (sig == DEPOSITCLAIM) return canDepositAndClaim(target);\n        if (sig == WITHDRAW) return canWithdraw(target);\n        if (sig == WITHDRAWCLAIM) return canWithdrawAndClaim(target);\n        if (sig == CLAIM) return canClaim(target);\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    function canDeposit(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensIn[0] = target;\n        tokensOut[0] = IChildGauge(target).lp_token();\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canDepositAndClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount + 1);\n        address reward; uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        tokensIn[i] = target;\n        i++;\n        assembly { mstore(tokensIn, i) }\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = IChildGauge(target).lp_token();\n\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canWithdraw(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n        tokensIn[0] = IChildGauge(target).lp_token();\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canWithdrawAndClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount + 1);\n        address reward;\n        uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        tokensIn[i] = IChildGauge(target).lp_token();\n        i++;\n        assembly { mstore(tokensIn, i) }\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount);\n        address reward;\n        uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        assembly { mstore(tokensIn, i) }\n\n        return (true, tokensIn, new address[](0));\n    }\n}"
    },
    {
      "filename": "controller-merged/src/balancer/BalancerLPStakingController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\n\ninterface IChildGauge {\n    function lp_token() external view returns (address);\n    function reward_tokens(uint256) external view returns (address);\n}\n\n/**\n    @title Curve LP staking controller\n    @notice Interaction controller for staking curve LP controllers\n*/\ncontract BalancerLPStakingController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice deposit(uint256)\n    bytes4 constant DEPOSIT = 0xb6b55f25;\n\n    /// @notice deposit(uint256,address,bool)\n    bytes4 constant DEPOSITCLAIM = 0x83df6747;\n\n    /// @notice withdraw(uint256)\n    bytes4 constant WITHDRAW = 0x2e1a7d4d;\n\n    /// @notice withdraw(uint256,address,bool)\n    bytes4 constant WITHDRAWCLAIM = 0x00ebf5dd;\n\n    /// @notice claim_rewards()\n    bytes4 constant CLAIM = 0xe6f1daf2;\n\n    /// @notice reward count\n    uint256 constant rewardsCount = 8;\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == DEPOSIT) return canDeposit(target);\n        if (sig == DEPOSITCLAIM) return canDepositAndClaim(target);\n        if (sig == WITHDRAW) return canWithdraw(target);\n        if (sig == WITHDRAWCLAIM) return canWithdrawAndClaim(target);\n        if (sig == CLAIM) return canClaim(target);\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    function canDeposit(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensIn[0] = target;\n        tokensOut[0] = IChildGauge(target).lp_token();\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canDepositAndClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount + 1);\n        address reward; uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        tokensIn[i] = target;\n        i++;\n        assembly { mstore(tokensIn, i) }\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = IChildGauge(target).lp_token();\n\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canWithdraw(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n        tokensIn[0] = IChildGauge(target).lp_token();\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canWithdrawAndClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount + 1);\n        address reward;\n        uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        tokensIn[i] = IChildGauge(target).lp_token();\n        i++;\n        assembly { mstore(tokensIn, i) }\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount);\n        address reward;\n        uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        assembly { mstore(tokensIn, i) }\n\n        return (true, tokensIn, new address[](0));\n    }\n}"
    },
    {
      "filename": "controller-merged/src/balancer/BalancerLPStakingController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\n\ninterface IChildGauge {\n    function lp_token() external view returns (address);\n    function reward_tokens(uint256) external view returns (address);\n}\n\n/**\n    @title Curve LP staking controller\n    @notice Interaction controller for staking curve LP controllers\n*/\ncontract BalancerLPStakingController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice deposit(uint256)\n    bytes4 constant DEPOSIT = 0xb6b55f25;\n\n    /// @notice deposit(uint256,address,bool)\n    bytes4 constant DEPOSITCLAIM = 0x83df6747;\n\n    /// @notice withdraw(uint256)\n    bytes4 constant WITHDRAW = 0x2e1a7d4d;\n\n    /// @notice withdraw(uint256,address,bool)\n    bytes4 constant WITHDRAWCLAIM = 0x00ebf5dd;\n\n    /// @notice claim_rewards()\n    bytes4 constant CLAIM = 0xe6f1daf2;\n\n    /// @notice reward count\n    uint256 constant rewardsCount = 8;\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == DEPOSIT) return canDeposit(target);\n        if (sig == DEPOSITCLAIM) return canDepositAndClaim(target);\n        if (sig == WITHDRAW) return canWithdraw(target);\n        if (sig == WITHDRAWCLAIM) return canWithdrawAndClaim(target);\n        if (sig == CLAIM) return canClaim(target);\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    function canDeposit(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensIn[0] = target;\n        tokensOut[0] = IChildGauge(target).lp_token();\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canDepositAndClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount + 1);\n        address reward; uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        tokensIn[i] = target;\n        i++;\n        assembly { mstore(tokensIn, i) }\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = IChildGauge(target).lp_token();\n\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canWithdraw(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n        tokensIn[0] = IChildGauge(target).lp_token();\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canWithdrawAndClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount + 1);\n        address reward;\n        uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        tokensIn[i] = IChildGauge(target).lp_token();\n        i++;\n        assembly { mstore(tokensIn, i) }\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n        return (true, tokensIn, tokensOut);\n    }\n\n    function canClaim(address target)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](rewardsCount);\n        address reward;\n        uint i;\n        for (; i<rewardsCount; i++) {\n            reward = IChildGauge(target).reward_tokens(i);\n            if (reward == address(0)) break;\n            tokensIn[i] = reward;\n        }\n        assembly { mstore(tokensIn, i) }\n\n        return (true, tokensIn, new address[](0));\n    }\n}"
    }
  ]
}