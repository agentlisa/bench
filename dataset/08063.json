{
  "Title": "[N-03] Constants may be used",
  "Content": "\nConstants may be used instead of literal values.\n\n### Instances\n\n*   [`uint[] memory supply = pair.sampleSupply(8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L550)\n*   [`prices = pair.sample(token1, decimals, 8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L561)\n*   [`(unitReserves, assetReserves) = pair.sampleReserves(8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L562)\n*   [`prices = pair.sample(token0, decimals, 8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L565)\n*   [`(assetReserves, unitReserves) = pair.sampleReserves(8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L566)\n*   [`prices = pair.sample(token1, decimals, 8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L571)\n*   [`(unitReserves, assetReserves) = pair.sampleReserves(8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L572)\n*   [`prices = pair.sample(token0, decimals, 8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L575)\n*   [`(assetReserves, unitReserves) = pair.sampleReserves(8, 1);`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L576)\n*   [`for(uint i; i < 8; ++i) {`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L581)\n*   [`return 1e18; // Stable coins supported by the lending market are instantiated by governance and their price will always be 1 note`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L499)\n*   [`return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L503)\n*   [`return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L507)\n*   [`return getPriceCanto(underlying) * getPriceNote(address(wcanto), false) / 1e18;`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L520)\n*   [`LpPricesCumulative += (token0TVL + token1TVL) * 1e18 / supply[i];`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L584)\n*   [`return LpPrice * getPriceNote(address(wcanto), false) / 1e18; // return the price in terms of Note`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L592)\n*   [`return price * 1e18 / decimals; //return the scaled price`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L533)\n*   [`return price * 1e18 / decimals; // divide by decimals now to maintain precision`](https://github.com/code-423n4/2022-09-canto/blob/65fbb8b9de22cf8f8f3d742b38b4be41ee35c468/src/Swap/BaseV1-periphery.sol#L545)\n\n### Recommendation\n\nDefine constant variables for repeated values (8 and 1e18).\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-09-canto",
  "Code": [
    {
      "filename": "src/Swap/BaseV1-periphery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"../deps/CToken.sol\";\nimport \"../deps/PriceOracle.sol\";\nimport \"./BaseV1-libs.sol\";\n\ninterface IBaseV1Factory {\n    function allPairsLength() external view returns (uint);\n    function isPair(address pair) external view returns (bool);\n    function pairCodeHash() external pure returns (bytes32);\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address);\n}\n\ninterface IBaseV1Pair {\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function mint(address to) external returns (uint liquidity);\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function getAmountOut(uint, address) external view returns (uint);\n    function current(address tokenIn, uint amountIn) external view returns(uint);\n    function token0() external view returns(address);\n    function token1() external view returns(address);\n    function stable() external view returns(bool);\n    function _k(uint x, uint y) external view returns(uint);\n    //LP token pricing\n    function sampleReserves(uint points, uint window) external view returns(uint[] memory, uint[] memory);\n    function sampleSupply(uint points, uint window) external view returns(uint[] memory);\n    function sample(address tokenIn, uint amountIn, uint points, uint window) external view returns(uint[] memory);\n    function quote(address tokenIn, uint amountIn, uint granularity) external view returns(uint);\n}\n\ninterface IWCANTO {\n    function deposit() external payable ;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external ;\n}\n\ninterface ICErc20 {\n    function underlying() external view returns(address);\n}\n\ncontract BaseV1Router01 is PriceOracle {\n    //address of Unitroller to obtain prices with respect to USDC\n    address public immutable note;  \n    //address of Comptroller, so that price of note may be set to 1 in Account Liquidity calculations\n    address public immutable Comptroller;\n\n    address public admin;\n\n    struct route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    address public immutable factory;\n    IWCANTO public immutable wcanto;\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n    bytes32 immutable pairCodeHash;\n\n    mapping(address => bool) public isStable;\n\n    error SenderNotAdmin(address sender, address admin);\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, \"BaseV1Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _wcanto, address note_, address Comptroller_) {\n        factory = _factory;\n        pairCodeHash = IBaseV1Factory(_factory).pairCodeHash();\n        wcanto = IWCANTO(_wcanto);\n        note = note_;\n        Comptroller = Comptroller_;\n        admin = msg.sender;\n    }\n\n    receive() external payable {\n        assert(msg.sender == address(wcanto)); // only accept ETH via fallback from the WETH contract\n    }\n\n    // admin for setting the stable pairs\n    function setAdmin(address admin_) external {\n        require(msg.sender == admin);\n        admin = admin_;\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"BaseV1Router: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"BaseV1Router: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address tokenA, address tokenB, bool stable) public view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1, stable)),\n            pairCodeHash // init code hash\n        )))));\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quoteLiquidity(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, \"BaseV1Router: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"BaseV1Router: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA * reserveB / reserveA;\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address tokenA, address tokenB, bool stable) public view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IBaseV1Pair(pairFor(tokenA, tokenB, stable)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\n        address pair = pairFor(tokenIn, tokenOut, true);\n        uint amountStable;\n        uint amountVolatile;\n        if (IBaseV1Factory(factory).isPair(pair)) {\n            amountStable = IBaseV1Pair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        pair = pairFor(tokenIn, tokenOut, false);\n        if (IBaseV1Factory(factory).isPair(pair)) {\n            amountVolatile = IBaseV1Pair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return amountStable > amountVolatile ? (amountStable, true) : (amountVolatile, false);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(uint amountIn, route[] memory routes) public view returns (uint[] memory amounts) {\n        require(routes.length >= 1, \"BaseV1Router: INVALID_PATH\");\n        amounts = new uint[](routes.length+1);\n        amounts[0] = amountIn;\n        for (uint i = 0; i < routes.length; i++) {\n            address pair = pairFor(routes[i].from, routes[i].to, routes[i].stable);\n            if (IBaseV1Factory(factory).isPair(pair)) {\n                amounts[i+1] = IBaseV1Pair(pair).getAmountOut(amounts[i], routes[i].from);\n            }\n        }\n    }\n\n    function isPair(address pair) public view returns (bool) {\n        return IBaseV1Factory(factory).isPair(pair);\n    }\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    ) external view returns (uint amountA, uint amountB, uint liquidity) {\n        // create the pair if it doesn\"t exist yet\n        address _pair = IBaseV1Factory(factory).getPair(tokenA, tokenB, stable);\n        (uint reserveA, uint reserveB) = (0,0);\n        uint _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = erc20(_pair).totalSupply();\n            (reserveA, reserveB) = getReserves(tokenA, tokenB, stable);\n        }\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\n            } else {\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\n            }\n        }\n    }\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity\n    ) public view returns (uint amountA, uint amountB) {\n        // create the pair if it doesn\"t exist yet\n        address _pair = IBaseV1Factory(factory).getPair(tokenA, tokenB, stable);\n\n        if (_pair == address(0)) {\n            return (0,0);\n        }\n\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n        uint _totalSupply = erc20(_pair).totalSupply();\n\n        amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution\n        amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution\n\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal returns (uint amountA, uint amountB) {\n        require(amountADesired >= amountAMin);\n        require(amountBDesired >= amountBMin);\n        // create the pair if it doesn\"t exist yet\n        address _pair = IBaseV1Factory(factory).getPair(tokenA, tokenB, stable);\n        if (_pair == address(0)) {\n            _pair = IBaseV1Factory(factory).createPair(tokenA, tokenB, stable);\n        }\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, \"BaseV1Router: INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, \"BaseV1Router: INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, stable, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = pairFor(tokenA, tokenB, stable);\n        _safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        _safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IBaseV1Pair(pair).mint(to);\n    }\n\n    function addLiquidityCANTO(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountCANTOMin,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) returns (uint amountToken, uint amountCANTO, uint liquidity) {\n        (amountToken, amountCANTO) = _addLiquidity(\n            token,\n            address(wcanto),\n            stable,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountCANTOMin\n        );\n        address pair = pairFor(token, address(wcanto), stable);\n        _safeTransferFrom(token, msg.sender, pair, amountToken);\n        wcanto.deposit{value: amountCANTO}();\n        assert(wcanto.transfer(pair, amountCANTO));\n        liquidity = IBaseV1Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountCANTO) _safeTransferCANTO(msg.sender, msg.value - amountCANTO);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = pairFor(tokenA, tokenB, stable);\n        require(IBaseV1Pair(pair).transferFrom(msg.sender, pair, liquidity)); // send liquidity to pair\n        (uint amount0, uint amount1) = IBaseV1Pair(pair).burn(to);\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, \"BaseV1Router: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"BaseV1Router: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidityCANTO(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountCANTOMin,\n        address to,\n        uint deadline\n    ) public ensure(deadline) returns (uint amountToken, uint amountCANTO) {\n        (amountToken, amountCANTO) = removeLiquidity(\n            token,\n            address(wcanto),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountCANTOMin,\n            address(this),\n            deadline\n        );\n        _safeTransfer(token, to, amountToken);\n        wcanto.withdraw(amountCANTO);\n        _safeTransferCANTO(to, amountCANTO);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB) {\n        address pair = pairFor(tokenA, tokenB, stable);\n        {\n            uint value = approveMax ? type(uint).max : liquidity;\n            IBaseV1Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        }\n\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, stable, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n\n    function removeLiquidityCANTOWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountCANTOMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountCANTO) {\n        address pair = pairFor(token, address(wcanto), stable);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IBaseV1Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountCANTO) = removeLiquidityCANTO(token, stable, liquidity, amountTokenMin, amountCANTOMin, to, deadline);\n    }\n    \n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, route[] memory routes, address _to) internal virtual {\n        for (uint i = 0; i < routes.length; i++) {\n            (address token0,) = sortTokens(routes[i].from, routes[i].to);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = routes[i].from == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < routes.length - 1 ? pairFor(routes[i+1].from, routes[i+1].to, routes[i+1].stable) : _to;\n            IBaseV1Pair(pairFor(routes[i].from, routes[i].to, routes[i].stable)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        route[] memory routes = new route[](1);\n        routes[0].from = tokenFrom;\n        routes[0].to = tokenTo;\n        routes[0].stable = stable;\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"BaseV1Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"BaseV1Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactCANTOForTokens(uint amountOutMin, route[] calldata routes, address to, uint deadline)\n    external\n    payable\n    ensure(deadline)\n    returns (uint[] memory amounts)\n    {\n        require(routes[0].from == address(wcanto), \"BaseV1Router: INVALID_PATH\");\n        amounts = getAmountsOut(msg.value, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"BaseV1Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        wcanto.deposit{value: amounts[0]}();\n        assert(wcanto.transfer(pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]));\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForCANTO(uint amountIn, uint amountOutMin, route[] calldata routes, address to, uint deadline)\n    external\n    ensure(deadline)\n    returns (uint[] memory amounts)\n    {\n        require(routes[routes.length - 1].to == address(wcanto), \"BaseV1Router: INVALID_PATH\");\n        amounts = getAmountsOut(amountIn, routes);\n        require(amounts[amounts.length - 1] >= amountOutMin, \"BaseV1Router: INSUFFICIENT_OUTPUT_AMOUNT\");\n        _safeTransferFrom(\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\n        );\n        _swap(amounts, routes, address(this));\n        wcanto.withdraw(amounts[amounts.length - 1]);\n        _safeTransferCANTO(to, amounts[amounts.length - 1]);\n    }\n\n    function UNSAFE_swapExactTokensForTokens(\n        uint[] memory amounts,\n        route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory) {\n        _safeTransferFrom(routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]);\n        _swap(amounts, routes, to);\n        return amounts;\n    }\n\n    function _safeTransferCANTO(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0, \"token code length failure\");\n\n        erc20 tokenCon = erc20(token);\n        tokenCon.transferFrom(from, to, value);\n    }\n\n    function setStable(address underlying) external returns (uint) {\n        if (msg.sender != admin) {\n            revert SenderNotAdmin(msg.sender, admin);\n        }\n\n        isStable[underlying] = true;\n    }\n\n    //returns the underlying price of the assets as a mantissa (scaled by 1e18)\n    function getUnderlyingPrice(CToken ctoken) external override view returns(uint) {\n         address underlying;\n        { //manual scope to pop symbol off of stack\n        string memory symbol = ctoken.symbol();\n        if (compareStrings(symbol, \"cCANTO\")) {\n            underlying = address(wcanto);\n            return getPriceNote(address(wcanto), false);\n        } else {\n            underlying = address(ICErc20(address(ctoken)).underlying()); // We are getting the price for a CErc20 lending market\n        }\n        //set price statically to 1 when the Comptroller is retrieving Price\n        if (compareStrings(symbol, \"cNOTE\")) { // note in terms of note will always be 1 \n            return 1e18; // Stable coins supported by the lending market are instantiated by governance and their price will always be 1 note\n        } \n        else if (compareStrings(symbol, \"cUSDT\") && (msg.sender == Comptroller )) {\n            uint decimals = erc20(underlying).decimals();\n            return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller\n        } \n        else if (compareStrings(symbol, \"cUSDC\") && (msg.sender == Comptroller)) {\n            uint decimals = erc20(underlying).decimals();\n            return 1e18 * 1e18 / (10 ** decimals); //Scale Price as a mantissa to maintain precision in comptroller\n        }\n        }\n        \n        if (isPair(underlying)) { // this is an LP Token\n            return getPriceLP(IBaseV1Pair(underlying));\n        }\n        // this is not an LP Token\n        else {\n            if (isStable[underlying]) {\n                return getPriceNote(underlying, true); // value has already been scaled\n            }\n\n            return getPriceCanto(underlying) * getPriceNote(address(wcanto), false) / 1e18;\n        }   \n    }\n    \n    //return the price of this asset in terms of Canto\n    function getPriceCanto(address token_) internal view returns(uint) {\n        erc20 token = erc20(token_);\n        address pair = pairFor(address(wcanto), address(token), false);\n        if (!isPair(pair)) {\n            return 0; // this pair does not exist with Canto\n        }\n        uint decimals = 10 ** token.decimals(); // get decimals of token\n        uint price = IBaseV1Pair(pair).quote(address(token), decimals, 8); // how much Canto is this asset worth?\n        return price * 1e18 / decimals; //return the scaled price\n    } \n    \n    // returns the price of token in terms of note, scaled by 18 decimals, Notice this will most likely be used with pairs that are stable with note\n    function getPriceNote(address token_, bool stable) internal view returns(uint) { \n        erc20 token = erc20(token_);\n        address pair = pairFor(note, address(token), stable); // pairs with Note may be volatile or stable\n        if (!isPair(pair)) {\n            return 0; // this pair has not yet been deployed\n        }\n        uint decimals = 10 ** token.decimals();\n        uint price = IBaseV1Pair(pair).quote(address(token), decimals, 8);\n        return price * 1e18 / decimals; // divide by decimals now to maintain precision\n    }\n\n    // this function returns the TWAP of the LP tokens from pair\n    function getPriceLP(IBaseV1Pair pair) internal view returns(uint) {\n        uint[] memory supply = pair.sampleSupply(8, 1);\n        uint[] memory prices; \n        uint[] memory unitReserves; \n        uint[] memory assetReserves; \n        address token0 = pair.token0();\n        address token1 = pair.token1();\n        uint decimals;\n\n        if (pair.stable()) { // stable pairs will be priced in terms of Note\n            if (token0 == note) { //token0 is the unit, token1 will be priced with respect to this asset initially\n                decimals = 10 ** (erc20(token1).decimals()); // we must normalize the price of token1 to 18 decimals\n                prices = pair.sample(token1, decimals, 8, 1);\n                (unitReserves, assetReserves) = pair.sampleReserves(8, 1);\n            } else {\n                decimals = 10 ** (erc20(token0).decimals());\n                prices = pair.sample(token0, decimals, 8, 1);\n                (assetReserves, unitReserves) = pair.sampleReserves(8, 1);\n            }\n        } else { // non-stable pairs will be priced in terms of Canto\n            if (token0 == address(wcanto)) { // token0 is Canto, and the unit asset of this pair is Canto\n                decimals = 10 ** (erc20(token1).decimals());\n                prices = pair.sample(token1, decimals, 8, 1);\n                (unitReserves, assetReserves) = pair.sampleReserves(8, 1);\n            } else {\n                decimals = 10 ** (erc20(token0)).decimals();\n                prices = pair.sample(token0, decimals, 8, 1);\n                (assetReserves, unitReserves) = pair.sampleReserves(8, 1);\n            }\n        }\n        uint LpPricesCumulative;\n\n        for(uint i; i < 8; ++i) {\n            uint token0TVL = assetReserves[i] * (prices[i] / decimals);\n            uint token1TVL = unitReserves[i]; // price of the unit asset is always 1\n            LpPricesCumulative += (token0TVL + token1TVL) * 1e18 / supply[i];\n        }\n        uint LpPrice = LpPricesCumulative / 8; // take the average of the cumulative prices \n        \n        if (pair.stable()) { // this asset has been priced in terms of Note\n            return LpPrice;\n        }\n        // this asset has been priced in terms of Canto\n        return LpPrice * getPriceNote(address(wcanto), false) / 1e18; // return the price in terms of Note\n    }   \n\n\n    function compareStrings(string memory str1, string memory str2) internal pure returns(bool) {\n        return (keccak256(abi.encodePacked(str1)) == keccak256(abi.encodePacked(str2)));\n    }\n\n    function _returnStableBooleans(uint8 stable) internal pure returns (bool, bool){\n        if (stable == 2) {\n            return (true, false);\n        } else if (stable == 3) {\n            return (false, true);\n        } else if (stable == 4) {\n            return (false, false);\n        } else {\n            return (true, true);\n        }\n    }\n}"
    },
    {
      "filename": "src/Swap/BaseV1-periphery.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"../deps/CToken.sol\";\nimport \"../deps/PriceOracle.sol\";\nimport \"./BaseV1-libs.sol\";\n\ninterface IBaseV1Factory {\n    function allPairsLength() external view returns (uint);\n    function isPair(address pair) external view returns (bool);\n    function pairCodeHash() external pure returns (bytes32);\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address);\n}\n\ninterface IBaseV1Pair {\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function mint(address to) external returns (uint liquidity);\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function getAmountOut(uint, address) external view returns (uint);\n    function current(address tokenIn, uint amountIn) external view returns(uint);\n    function token0() external view returns(address);\n    function token1() external view returns(address);\n    function stable() external view returns(bool);\n    function _k(uint x, uint y) external view returns(uint);\n    //LP token pricing\n    function sampleReserves(uint points, uint window) external view returns(uint[] memory, uint[] memory);\n    function sampleSupply(uint points, uint window) external view returns(uint[] memory);\n    function sample(address tokenIn, uint amountIn, uint points, uint window) external view returns(uint[] memory);\n    function quote(address tokenIn, uint amountIn, uint granularity) external view returns(uint);\n}\n\ninterface IWCANTO {\n    function deposit() external payable ;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external ;\n}\n\ninterface ICErc20 {\n    function underlying() external view returns(address);\n}\n\ncontract BaseV1Router01 is PriceOracle {\n    //address of Unitroller to obtain prices with respect to USDC\n    address public immutable note;  \n    //address of Comptroller, so that price of note may be set to 1 in Account Liquidity calculations\n    address public immutable Comptroller;\n\n    address public admin;\n\n    struct route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    address public immutable factory;\n    IWCANTO public immutable wcanto;\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n    bytes32 immutable pairCodeHash;\n\n    mapping(address => bool) public isStable;\n\n    error SenderNotAdmin(address sender, address admin);\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, \"BaseV1Router: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _wcanto, address note_, address Comptroller_) {\n        factory = _factory;\n        pairCodeHash = IBaseV1Factory(_factory).pairCodeHash();\n        wcanto = IWCANTO(_wcanto);\n        note = note_;\n        Comptroller = Comptroller_;\n        admin = msg.sender;\n    }\n\n    receive() external payable {\n        assert(msg.sender == address(wcanto)); // only accept ETH via fallback from the WETH contract\n    }\n\n    // admin for setting the stable pairs\n    function setAdmin(address admin_) external {\n        require(msg.sender == admin);\n        admin = admin_;\n    }\n\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"BaseV1Router: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"BaseV1Router: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address tokenA, address tokenB, bool stable) public view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1, stable)),\n            pairCodeHash // init code hash\n        )))));\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quoteLiquidity(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, \"BaseV1Router: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"BaseV1Router: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA * reserveB / reserveA;\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address tokenA, address tokenB, bool stable) public view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IBaseV1Pair(pairFor(tokenA, tokenB, stable)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\n        address pair = pairFor(tokenIn, tokenOut, true);\n        uint amountStable;\n        uint amountVolatile;\n        if (IBaseV1Factory(factory).isPair(pair)) {\n            amountStable = IBaseV1Pair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        pair = pairFor(tokenIn, tokenOut, false);\n        if (IBaseV1Factory(factory).isPair(pair)) {\n            amountVolatile = IBaseV1Pair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return amountStable > amountVolatile ? (amountStable, true) : (amountVolatile, false);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(uint amountIn, route[] memory routes) public view returns (uint[] memory amounts) {\n        require(routes.length >= 1, \"BaseV1Router: INVALID_PATH\");\n        amounts = new uint[](routes.length+1);\n        amounts[0] = amountIn;\n        for (uint i = 0; i < routes.length; i++) {\n            address pair = pairFor(routes[i].from, routes[i].to, routes[i].st"
    }
  ]
}