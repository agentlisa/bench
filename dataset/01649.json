{
  "Title": "M-7: Wrong assignment of `cumulativeBid` for RangeOrder state in getRangeOrderState function",
  "Content": "# Issue M-7: Wrong assignment of `cumulativeBid` for RangeOrder state in getRangeOrderState function \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/178 \n\n## Found by \nbitsurfer\n## Summary\n\nWrong assignment of `cumulativeBid` for RangeOrder state\n\n## Vulnerability Detail\n\nIn `D3Trading`, the `getRangeOrderState` function is returning RangeOrder (get swap status for internal swap) which is assinging wrong toTokenMMInfo.cumulativeBid which suppose to be `cumulativeBid` not `cumulativeAsk`\n\nThe error lies in the assignment of `roState.toTokenMMInfo.cumulativeBid`. Instead of assigning `tokenCumMap[toToken].cumulativeAsk`, it should be assigning `tokenCumMap[toToken].cumulativeBid`.\n\n```js\nFile: D3Trading.sol\n86:         roState.toTokenMMInfo.cumulativeBid =\n87:             allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeAsk;\n```\n\nThis wrong assignment value definitely will mess up accounting balance, resulting unknown state will occure, which is not expected by the protocol\n\nFor one case, this `getRangeOrderState` is being used in `querySellTokens` & `queryBuyTokens` which may later called from `sellToken` and `buyToken`. The issue is when calling `_contructTokenState` which can be reverted from `PMMRangeOrder` when buy or sell token\n\n```js\nFile: PMMRangeOrder.sol\n100:         // B\n101:         tokenState.B = askOrNot ? tokenState.B0 - tokenMMInfo.cumulativeAsk : tokenState.B0 - tokenMMInfo.cumulativeBid;\n```\n\nWhen the `tokenMMInfo.cumulativeBid` (which was wrongly assign from `cumulativeAsk`) is bigger than `tokenState.B0`, this will revert\n\n## Impact\n\nThis wrong assignment value definitely will mess up accounting balance, resulting unknown state will occure, which is not expected by the protocol. For example reverting state showing a case above.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Trading.sol#L86-L87\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFix the error to\n\n```diff\nFile: D3Trading.sol\n86:         roState.toTokenMMInfo.cumulativeBid =\n--:             allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeAsk;\n++:             allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeBid;\n```\n\n\n\n\n## Discussion\n\n**Attens1423**\n\nfix pr:https://github.com/DODOEX/new-dodo-v3/pull/40\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Pool/D3Trading.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"../lib/PMMRangeOrder.sol\";\nimport \"../lib/Errors.sol\";\nimport {IDODOSwapCallback} from \"../intf/IDODOSwapCallback.sol\";\nimport {ID3Maker} from \"../intf/ID3Maker.sol\";\nimport {ID3Vault} from \"../intf/ID3Vault.sol\";\nimport {D3Funding} from \"./D3Funding.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract D3Trading is D3Funding {\n    using SafeERC20 for IERC20;\n\n    modifier onlyMaker() {\n        require(msg.sender == state._MAKER_, \"not maker\");\n        _;\n    }\n\n    // =============== Read ===============\n\n    /// @notice for external users to read tokenMMInfo\n    function getTokenMMPriceInfoForRead(\n        address token\n    )\n        external\n        view\n        returns (uint256 askDownPrice, uint256 askUpPrice, uint256 bidDownPrice, uint256 bidUpPrice, uint256 swapFee)\n    {\n        (Types.TokenMMInfo memory tokenMMInfo, ) =\n            ID3Maker(state._MAKER_).getTokenMMInfoForPool(token);\n\n        askDownPrice = tokenMMInfo.askDownPrice;\n        askUpPrice = tokenMMInfo.askUpPrice;\n        bidDownPrice = tokenMMInfo.bidDownPrice;\n        bidUpPrice = tokenMMInfo.bidUpPrice;\n        swapFee = tokenMMInfo.swapFeeRate;\n    }\n\n    function getTokenMMOtherInfoForRead(\n        address token\n    )\n        external\n        view\n        returns (\n            uint256 askAmount,\n            uint256 bidAmount,\n            uint256 kAsk,\n            uint256 kBid,\n            uint256 cumulativeAsk,\n            uint256 cumulativeBid\n        )\n    {\n        (Types.TokenMMInfo memory tokenMMInfo, uint256 tokenIndex) =\n            ID3Maker(state._MAKER_).getTokenMMInfoForPool(token);\n        cumulativeAsk = allFlag >> (tokenIndex) & 1 == 0 ? 0 : tokenCumMap[token].cumulativeAsk;\n        cumulativeBid = allFlag >> (tokenIndex) & 1 == 0 ? 0 : tokenCumMap[token].cumulativeBid;\n\n        bidAmount = tokenMMInfo.bidAmount;\n        askAmount = tokenMMInfo.askAmount;\n        kAsk = tokenMMInfo.kAsk;\n        kBid = tokenMMInfo.kBid;\n    }\n\n    // ============ Swap =============\n    /// @notice get swap status for internal swap\n    function getRangeOrderState(\n        address fromToken,\n        address toToken\n    ) public view returns (Types.RangeOrderState memory roState) {\n        roState.oracle = state._ORACLE_;\n        uint256 fromTokenIndex;\n        uint256 toTokenIndex;\n        (roState.fromTokenMMInfo, fromTokenIndex) = ID3Maker(state._MAKER_).getTokenMMInfoForPool(fromToken);\n        (roState.toTokenMMInfo, toTokenIndex) = ID3Maker(state._MAKER_).getTokenMMInfoForPool(toToken);\n\n        // deal with update flag\n\n        roState.fromTokenMMInfo.cumulativeAsk =\n            allFlag >> (fromTokenIndex) & 1 == 0 ? 0 : tokenCumMap[fromToken].cumulativeAsk;\n        roState.fromTokenMMInfo.cumulativeBid =\n            allFlag >> (fromTokenIndex) & 1 == 0 ? 0 : tokenCumMap[fromToken].cumulativeBid;\n        roState.toTokenMMInfo.cumulativeAsk =\n            allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeAsk;\n        roState.toTokenMMInfo.cumulativeBid =\n            allFlag >> (toTokenIndex) & 1 == 0 ? 0 : tokenCumMap[toToken].cumulativeAsk;\n    }\n\n    /// @notice user sell a certain amount of fromToken,  get toToken\n    function sellToken(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minReceiveAmount,\n        bytes calldata data\n    ) external poolOngoing nonReentrant returns (uint256) {\n        require(ID3Maker(state._MAKER_).checkHeartbeat(), Errors.HEARTBEAT_CHECK_FAIL);\n\n        _updateCumulative(fromToken);\n        _updateCumulative(toToken);\n\n        (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) =\n            querySellTokens(fromToken, toToken, fromAmount);\n        require(receiveToAmount >= minReceiveAmount, Errors.MINRES_NOT_ENOUGH);\n\n        _transferOut(to, toToken, receiveToAmount);\n\n        // external call & swap callback\n        IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, fromAmount, data);\n        // transfer mtFee to maintainer\n        _transferOut(state._MAINTAINER_, toToken, mtFee);\n\n        require(\n            IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= fromAmount,\n            Errors.FROMAMOUNT_NOT_ENOUGH\n        );\n\n        // record swap\n        _recordSwap(fromToken, toToken, vusdAmount, receiveToAmount + swapFee);\n        require(checkSafe(), Errors.BELOW_IM_RATIO);\n\n        emit Swap(to, fromToken, toToken, payFromAmount, receiveToAmount, swapFee, mtFee, 0);\n        return receiveToAmount;\n    }\n\n    /// @notice user ask for a certain amount of toToken, fromToken's amount will be determined by toToken's amount\n    function buyToken(\n        address to,\n        address fromToken,\n        address toToken,\n        uint256 quoteAmount,\n        uint256 maxPayAmount,\n        bytes calldata data\n    ) external poolOngoing nonReentrant returns (uint256) {\n        require(ID3Maker(state._MAKER_).checkHeartbeat(), Errors.HEARTBEAT_CHECK_FAIL);\n\n        _updateCumulative(fromToken);\n        _updateCumulative(toToken);\n\n        // query amount and transfer out\n        (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) =\n            queryBuyTokens(fromToken, toToken, quoteAmount);\n        require(payFromAmount <= maxPayAmount, Errors.MAXPAY_NOT_ENOUGH);\n\n        _transferOut(to, toToken, receiveToAmount);\n\n        // external call & swap callback\n        IDODOSwapCallback(msg.sender).d3MMSwapCallBack(fromToken, payFromAmount, data);\n        // transfer mtFee to maintainer\n        _transferOut(state._MAINTAINER_, toToken, mtFee);\n\n        require(\n            IERC20(fromToken).balanceOf(address(this)) - state.balances[fromToken] >= payFromAmount,\n            Errors.FROMAMOUNT_NOT_ENOUGH\n        );\n\n        // record swap\n        _recordSwap(fromToken, toToken, vusdAmount, receiveToAmount + swapFee);\n        require(checkSafe(), Errors.BELOW_IM_RATIO);\n\n        emit Swap(to, fromToken, toToken, payFromAmount, receiveToAmount, swapFee, mtFee, 1);\n        return payFromAmount;\n    }\n\n    /// @notice user could query sellToken result deducted swapFee, assign fromAmount\n    /// @return payFromAmount fromToken's amount = fromAmount\n    /// @return receiveToAmount toToken's amount\n    /// @return vusdAmount fromToken bid vusd\n    /// @return swapFee dodo takes the fee\n    function querySellTokens(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) public view returns (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) {\n        require(fromAmount > 1000, Errors.AMOUNT_TOO_SMALL);\n        Types.RangeOrderState memory D3State = getRangeOrderState(fromToken, toToken);\n\n        (payFromAmount, receiveToAmount, vusdAmount) =\n            PMMRangeOrder.querySellTokens(D3State, fromToken, toToken, fromAmount);\n\n        receiveToAmount = receiveToAmount > state.balances[toToken] ? state.balances[toToken] : receiveToAmount;\n\n        uint256 swapFeeRate = D3State.fromTokenMMInfo.swapFeeRate +  D3State.toTokenMMInfo.swapFeeRate;\n        swapFee = DecimalMath.mulFloor(receiveToAmount, swapFeeRate);\n        uint256 mtFeeRate = D3State.fromTokenMMInfo.mtFeeRate +  D3State.toTokenMMInfo.mtFeeRate;\n        mtFee = DecimalMath.mulFloor(receiveToAmount, mtFeeRate);\n\n        return (payFromAmount, receiveToAmount - swapFee, vusdAmount, swapFee, mtFee);\n    }\n\n    /// @notice user could query sellToken result deducted swapFee, assign toAmount\n    /// @return payFromAmount fromToken's amount\n    /// @return receiveToAmount toToken's amount = toAmount\n    /// @return vusdAmount fromToken bid vusd\n    /// @return swapFee dodo takes the fee\n    function queryBuyTokens(\n        address fromToken,\n        address toToken,\n        uint256 toAmount\n    ) public view returns (uint256 payFromAmount, uint256 receiveToAmount, uint256 vusdAmount, uint256 swapFee, uint256 mtFee) {\n        require(toAmount > 1000, Errors.AMOUNT_TOO_SMALL);\n        Types.RangeOrderState memory D3State = getRangeOrderState(fromToken, toToken);\n\n        // query amount and transfer out\n        {\n        uint256 swapFeeRate = D3State.fromTokenMMInfo.swapFeeRate +  D3State.toTokenMMInfo.swapFeeRate;\n        swapFee = DecimalMath.mulFloor(toAmount, swapFeeRate);\n        uint256 mtFeeRate = D3State.fromTokenMMInfo.mtFeeRate +  D3State.toTokenMMInfo.mtFeeRate;\n        mtFee = DecimalMath.mulFloor(toAmount, mtFeeRate);\n        toAmount += swapFee;\n        }\n\n        require(toAmount <= state.balances[toToken], Errors.BALANCE_NOT_ENOUGH);\n\n        uint256 receiveToAmountWithFee;\n        (payFromAmount, receiveToAmountWithFee , vusdAmount) =\n            PMMRangeOrder.queryBuyTokens(D3State, fromToken, toToken, toAmount);\n\n        return (payFromAmount, receiveToAmountWithFee - swapFee, vusdAmount, swapFee, mtFee);\n    }\n\n    // ================ internal ==========================\n\n    function _recordSwap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount) internal {\n        tokenCumMap[fromToken].cumulativeBid += fromAmount;\n        tokenCumMap[toToken].cumulativeAsk += toAmount;\n\n        _updateReserve(fromToken);\n        _updateReserve(toToken);\n    }\n\n    function _updateCumulative(address token) internal {\n        uint256 tokenIndex = ID3Maker(state._MAKER_).getOneTokenOriginIndex(token);\n        uint256 tokenFlag = (allFlag >> tokenIndex) & 1;\n        if (tokenFlag == 0) {\n            tokenCumMap[token].cumulativeAsk = 0;\n            tokenCumMap[token].cumulativeBid = 0;\n            allFlag |= (1 << tokenIndex);\n        }\n    }\n\n    function _transferOut(address to, address token, uint256 amount) internal {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    // ================ call by maker ==========================\n    function setNewAllFlag(uint256 newFlag) external onlyMaker {\n        allFlag = newFlag;\n    }\n}"
    }
  ]
}