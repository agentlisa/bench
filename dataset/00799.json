{
  "Title": "Not Update Rewards in `handleIncomingUpdate` Function of `SDLPoolPrimary` Leads to Incorrect Reward Calculations",
  "Content": "# Not Update Rewards in `handleIncomingUpdate` Function of `SDLPoolPrimary` Leads to Incorrect Reward Calculations\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L231\">https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L231</a>\n\n\n## Summary\nFailing to update rewards before executing the [`handleIncomingUpdate`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L231) function in [`SDLPoolPrimary`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol), while adjusting the `effectiveBalance` of the [`ccipController`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol), results in miscalculated rewards. This oversight can obstruct the distribution of rewards for the secondary chain.\n\n## Vulnerability Details\n- Actions taken in the secondary pool are queued and then communicated to the primary pool. The primary pool must acknowledge these changes before they are executed. The message sent to the primary pool includes the number of new queued locks to be minted (`numNewQueuedLocks`) and the change in the reSDL supply (`reSDLSupplyChange`).\n\n- Upon receiving the message, the [`SDLPoolCCIPControllerPrimary` ](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol) contract updates the `reSDLSupplyByChain` and forwards the message to [`SDLPoolPrimary`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L231). The [`SDLPoolPrimary`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L231) contract then processes the message, returning the `mintStartIndex` for the secondary chain to use when minting new locks. It also updates the [`effectiveBalances`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L243)  for the `ccipController` and the `totalEffectiveBalance`.\n```js\n  function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        uint64 sourceChainSelector = _message.sourceChainSelector;\n\n        (uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange) = abi.decode(_message.data, (uint256, int256));\n\n        if (totalRESDLSupplyChange > 0) {\n  >>        reSDLSupplyByChain[sourceChainSelector] += uint256(totalRESDLSupplyChange);\n        } else if (totalRESDLSupplyChange < 0) {\n  >>        reSDLSupplyByChain[sourceChainSelector] -= uint256(-1 * totalRESDLSupplyChange);\n        }\n  >>    uint256 mintStartIndex =ISDLPoolPrimary(sdlPool).handleIncomingUpdate(numNewRESDLTokens, totalRESDLSupplyChange);   \n        _ccipSendUpdate(sourceChainSelector, mintStartIndex);\n\n        emit MessageReceived(_message.messageId, sourceChainSelector);\n    }\n```\n\n- The issue arises because the [`handleIncomingUpdate`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/sdlPool/SDLPoolPrimary.sol#L231) function does not update the rewards before altering these values. Since these values directly affect reward accounting, failing to update them leads to incorrect calculations. This could result in a scenario where the total rewards accrued by all stakers exceed the available balance in the `rewardsPool`.\n```js\n  function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange)\n        external\n        onlyCCIPController\n        returns (uint256)\n    {\n       // some code ...\n\n        if (_totalRESDLSupplyChange > 0) {\n>>            effectiveBalances[ccipController] += uint256(_totalRESDLSupplyChange);\n>>           totalEffectiveBalance += uint256(_totalRESDLSupplyChange);\n        } else if (_totalRESDLSupplyChange < 0) {\n>>           effectiveBalances[ccipController] -= uint256(-1 * _totalRESDLSupplyChange);\n>>            totalEffectiveBalance -= uint256(-1 * _totalRESDLSupplyChange);\n        }\n  // more code ....\n    }\n```\n- For example, consider Alice has staked `500 sdl` tokens, and there is an outgoing `1000 reSdl`. The state would be as follows:\n\n- `effectiveBalance[alice]` = **500**\n- `effectiveBalance[ccipController]` = **1000**\n- `totalEffectiveBalance` = **1500**\n\n- Now, assume `1500 reward` tokens are distributed this will update the `rewardPerToken = 1` (rewards/totalStaked), and Alice will withdraw her rewards. The amount of rewards Alice receives is calculated using the [`withdrawableRewards`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/RewardsPool.sol#L38) function, which relies on her `effectiveBalance` (controller.staked()). With a `rewardPerToken` of `1` and Alice's `userRewardPerTokenPaid` at `0`, Alice would receive `500 rewards`.\n ```js\n   function withdrawableRewards(address _account) public view virtual returns (uint256) {\n        return (controller.staked(_account) *(rewardPerToken - userRewardPerTokenPaid[_account]) ) / 1e18\n            + userRewards[_account];\n    }\n  ```\n\n- now, someone stakes another `1000 sdl` on the secondary chain, an incoming update with a supply change of `1000` is received on the primary chain. This update changes the `effectiveBalance[ccipController]` to `2000` without a prior reward update which will keep the `userRewardPerTokenPaid` for ccipController 0. \n  ```js\n     function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange)external onlyCCIPController returns (uint256){\n        uint256 mintStartIndex;\n        if (_numNewRESDLTokens != 0) {\n            mintStartIndex = lastLockId + 1;\n            lastLockId += _numNewRESDLTokens;\n        }\n\n        if (_totalRESDLSupplyChange > 0) {\n   >>        effectiveBalances[ccipController] += uint256(_totalRESDLSupplyChange);\n            totalEffectiveBalance += uint256(_totalRESDLSupplyChange);\n        } else if (_totalRESDLSupplyChange < 0) {\n            effectiveBalances[ccipController] -= uint256(-1 * _totalRESDLSupplyChange);\n            totalEffectiveBalance -= uint256(-1 * _totalRESDLSupplyChange);\n        }\n\n        emit IncomingUpdate(_numNewRESDLTokens, _totalRESDLSupplyChange, mintStartIndex);\n\n        return mintStartIndex;\n    }\n  ``` \n\n- Consequently, when the [`RewardsInitiator`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/RewardsInitiator.sol#L41) contract calls the [`distributeRewards`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol#L56) function in [`SDLPoolCCIPControllerPrimary`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol), attempting to `withdrawRewards` from the `rewardPool` the call will perpetually fail. The rewards for the [`ccipController`](https://github.com/Cyfrin/2023-12-stake-link/blob/main/contracts/core/ccip/SDLPoolCCIPControllerPrimary.sol) would be calculated as `2000 * (1 - 0) = 2000 rewards`, while the actual balance of the `rewardsPool` is only `1000 rewards`.\n  ```js\n     function distributeRewards() external onlyRewardsInitiator {\n        uint256 totalRESDL = ISDLPoolPrimary(sdlPool).effectiveBalanceOf(address(this));\n        address[] memory tokens = ISDLPoolPrimary(sdlPool).supportedTokens();\n        uint256 numDestinations = whitelistedChains.length;\n\n    >> ISDLPoolPrimary(sdlPool).withdrawRewards(tokens);\n        // ... more code ..\n    }\n  ```\n\n- notice that the increase of `1000` will never be solved . \n\n## POC \n- here a poc that shows , that not updating reward in incomingUpdates , will cause the distributeReward function to revert , cause of insufficient balance in the reward pool , i used the repo setup : \n```js\n import { ethers } from 'hardhat'\nimport {  expect } from 'chai'\nimport { toEther, deploy, deployUpgradeable, getAccounts, fromEther } from '../../utils/helpers'\nimport {\n  ERC677,\n  CCIPOnRampMock,\n  CCIPOffRampMock,\n  CCIPTokenPoolMock,\n  SDLPoolPrimary,\n  SDLPoolCCIPControllerPrimary,\n  Router,\n} from '../../../typechain-types'\nimport {  Signer } from 'ethers'\n\ndescribe('SDLPoolCCIPControllerPrimary', () => {\n  let linkToken: ERC677\n  let sdlToken: ERC677\n  let token1: ERC677\n  let token2: ERC677\n  let controller: SDLPoolCCIPControllerPrimary\n  let sdlPool: SDLPoolPrimary\n  let onRamp: CCIPOnRampMock\n  let offRamp: CCIPOffRampMock\n  let tokenPool: CCIPTokenPoolMock\n  let tokenPool2: CCIPTokenPoolMock\n  let router: any\n  let accounts: string[]\n  let signers: Signer[]\n\n  before(async () => {\n    ;({ signers, accounts } = await getAccounts())\n  })\n\n  beforeEach(async () => {\n    linkToken = (await deploy('ERC677', ['Chainlink', 'LINK', 1000000000])) as ERC677 // deploy the link token ..\n    sdlToken = (await deploy('ERC677', ['SDL', 'SDL', 1000000000])) as ERC677 // deploy the sdl token \n    token1 = (await deploy('ERC677', ['2', '2', 1000000000])) as ERC677\n    token2 = (await deploy('ERC677', ['2', '2', 1000000000])) as ERC677\n\n    const armProxy = await deploy('CCIPArmProxyMock')\n    // router takes the wrapped native , and the armProxy address \n    router = (await deploy('Router', [accounts[0], armProxy.address])) as Router\n    tokenPool = (await deploy('CCIPTokenPoolMock', [token1.address])) as CCIPTokenPoolMock // token1 pool for cross chain deposit and withdraw  \n    tokenPool2 = (await deploy('CCIPTokenPoolMock', [token2.address])) as CCIPTokenPoolMock // token2 pool for crosschain deposit and withdraw . \n    onRamp = (await deploy('CCIPOnRampMock', [ // deploy the onRamp \n      [token1.address, token2.address],\n      [tokenPool.address, tokenPool2.address],\n      linkToken.address,\n    ])) as CCIPOnRampMock\n    offRamp = (await deploy('CCIPOffRampMock', [\n      router.address,\n      [token1.address, token2.address],\n      [tokenPool.address, tokenPool2.address],\n    ])) as CCIPOffRampMock\n\n    await router.applyRampUpdates([[77, onRamp.address]], [], [[77, offRamp.address]])\n\n    let boostController = await deploy('LinearBoostController', [4 * 365 * 86400, 4])\n    sdlPool = (await deployUpgradeable('SDLPoolPrimary', [\n      'reSDL',\n      'reSDL',\n      sdlToken.address,\n      boostController.address,\n    ])) as SDLPoolPrimary\n    controller = (await deploy('SDLPoolCCIPControllerPrimary', [\n      router.address,\n      linkToken.address,\n      sdlToken.address,\n      sdlPool.address,\n      toEther(10),\n    ])) as SDLPoolCCIPControllerPrimary\n\n    await linkToken.transfer(controller.address, toEther(100))\n    await sdlToken.transfer(accounts[1], toEther(200))\n    await sdlPool.setCCIPController(controller.address)\n    await controller.setRESDLTokenBridge(accounts[5])\n    await controller.setRewardsInitiator(accounts[0])\n    await controller.addWhitelistedChain(77, accounts[4], '0x11', '0x22')\n  })\n\n \n\n  it('poc that when there is encoming updates the rewared is wrong calculated',async () => {\n      let wToken = await deploy('WrappedSDTokenMock', [token1.address])\n      let rewardsPool = await deploy('RewardsPoolWSD', [\n        sdlPool.address,\n        token1.address,\n        wToken.address,\n      ])\n      let wtokenPool = (await deploy('CCIPTokenPoolMock', [wToken.address])) as CCIPTokenPoolMock\n      await sdlPool.addToken(token1.address, rewardsPool.address)\n      await controller.approveRewardTokens([wToken.address]) // approve the wrapped token to wroter from the ccipPramiry\n      await controller.setWrappedRewardToken(token1.address, wToken.address)\n      await onRamp.setTokenPool(wToken.address, wtokenPool.address)\n      await offRamp.setTokenPool(wToken.address, wtokenPool.address)\n      //1.user stakes : \n      await sdlToken.transferAndCall(sdlPool.address,toEther(1000),ethers.utils.defaultAbiCoder.encode(['uint256', 'uint64'], [0, 0]))\n      //2.distrubute rewared : \n      await token1.transferAndCall(sdlPool.address, toEther(1000), '0x')\n      //3. @audit incoming updates from secondary chain with 1000 resdl in supplychange : \n      await offRamp.connect(signers[4]).executeSingleMessage(\n         ethers.utils.formatBytes32String('messageId'),\n        77,\n        ethers.utils.defaultAbiCoder.encode(['uint256','int256'], [3,toEther(1000)]),\n        controller.address,\n        []\n      )\n      // here the error : the sum of withdrawable rewards , will be more then the availabel reward balance in rewardPool . \n      let user = await sdlPool.withdrawableRewards(accounts[0]) // get the user withdrawAble rewards : \n      let wr = await sdlPool.withdrawableRewards(controller.address) // get the ccipController withdrawable rewards : \n      let rewardsAvailable = (await rewardsPool.totalRewards()) // get the total rewared available to distribute : \n      // since not user withdrew reward nor ccipController , the total rewareds should be greater or equal the total withdrawAble rewards , but this not the case : \n      expect(fromEther((wr[0].add(user[0])))).greaterThan(fromEther(rewardsAvailable))\n      // now when the staker withdraw rewards the remain rewards will be not enough for ccipController : \n      await sdlPool.withdrawRewards([token1.address]);\n      // distributing rewards will revert, since there is not enough balance to cover the ccipController rewards :\n      await expect(controller.distributeRewards())\n      .to.be.revertedWith('');\n   })\n \n})\n```\n\n## Impact\nIncorrect reward calculations could  prevent rightful stakers from receiving their due rewards or leave unclaimable rewards in the pool (in the case of negative supply change), thereby compromising the protocol's credibility.\n## Tools Used\nmanual review\n## recommendations : \n- Implement an `updateReward(ccipController)` call within the `handleIncomingUpdate` function to ensure rewards are recalculated whenever `effectiveBalance` changes. This will prevent miscalculations and maintain reward distribution accuracy. \n```Diff\n function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange)\n        external\n++      updateRewards(ccipController)\n        onlyCCIPController\n        returns (uint256)\n     {\n        uint256 mintStartIndex;\n        if (_numNewRESDLTokens != 0) {\n            mintStartIndex = lastLockId + 1;\n            lastLockId += _numNewRESDLTokens;\n        }\n\n        if (_totalRESDLSupplyChange > 0) {\n            effectiveBalances[ccipController] += uint256(_totalRESDLSupplyChange);\n            totalEffectiveBalance += uint256(_totalRESDLSupplyChange);\n        } else if (_totalRESDLSupplyChange < 0) {\n            effectiveBalances[ccipController] -= uint256(-1 * _totalRESDLSupplyChange);\n            totalEffectiveBalance -= uint256(-1 * _totalRESDLSupplyChange);\n        }\n\n        emit IncomingUpdate(_numNewRESDLTokens, _totalRESDLSupplyChange, mintStartIndex);\n\n        return mintStartIndex;\n    }\n```",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clqf7mgla0001yeyfah59c674",
  "Code": [
    {
      "filename": "contracts/core/sdlPool/SDLPoolPrimary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Primary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed only on the primary chain\n */\ncontract SDLPoolPrimary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public delegatorPool;\n\n    event IncomingUpdate(uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange, uint256 mintStartIndex);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public reinitializer(2) {\n        if (delegatorPool == address(0)) {\n            __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        } else {\n            delegatorPool = ccipController;\n        }\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * - see _updateLock() for more details on updating an existing lock or _createLock() for more details on\n     *   creating a new lock\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _storeUpdatedLock(_sender, lockId, _value, lockingDuration);\n            } else {\n                _storeNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _storeUpdatedLock(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        if (locks[_lockId].expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = locks[_lockId].duration / 2;\n        if (locks[_lockId].startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        locks[_lockId].expiry = expiry;\n\n        uint256 boostAmount = locks[_lockId].boostAmount;\n        locks[_lockId].boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        emit InitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        if (locks[_lockId].startTime != 0) {\n            uint64 expiry = locks[_lockId].expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = locks[_lockId].amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        emit Withdraw(msg.sender, _lockId, _amount);\n\n        if (_amount == baseAmount) {\n            delete locks[_lockId];\n            delete lockOwners[_lockId];\n            balances[msg.sender] -= 1;\n            if (tokenApprovals[_lockId] != address(0)) delete tokenApprovals[_lockId];\n            emit Transfer(msg.sender, address(0), _lockId);\n        } else {\n            locks[_lockId].amount = baseAmount - _amount;\n        }\n\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        sdlToken.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @notice handles an outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of lock\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     */\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    )\n        external\n        onlyCCIPController\n        onlyLockOwner(_lockId, _sender)\n        updateRewards(_sender)\n        updateRewards(ccipController)\n        returns (Lock memory)\n    {\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        effectiveBalances[ccipController] += totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles an incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of lock\n     * @param _lockId id of lock\n     * @param _lock lock\n     */\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) updateRewards(ccipController) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        effectiveBalances[ccipController] -= totalAmount;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an incoming update from a secondary chain\n     * @dev updates the total reSDL supply and keeps reSDL lock ids consistent between chains\n     * @param _numNewRESDLTokens number of new reSDL locks to be minted on other chain\n     * @param _totalRESDLSupplyChange total reSDL supply change on other chain\n     */\n    function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange)\n        external\n        onlyCCIPController\n        returns (uint256)\n    {\n        uint256 mintStartIndex;\n        if (_numNewRESDLTokens != 0) {\n            mintStartIndex = lastLockId + 1;\n            lastLockId += _numNewRESDLTokens;\n        }\n\n        if (_totalRESDLSupplyChange > 0) {\n            effectiveBalances[ccipController] += uint256(_totalRESDLSupplyChange);\n            totalEffectiveBalance += uint256(_totalRESDLSupplyChange);\n        } else if (_totalRESDLSupplyChange < 0) {\n            effectiveBalances[ccipController] -= uint256(-1 * _totalRESDLSupplyChange);\n            totalEffectiveBalance -= uint256(-1 * _totalRESDLSupplyChange);\n        }\n\n        emit IncomingUpdate(_numNewRESDLTokens, _totalRESDLSupplyChange, mintStartIndex);\n\n        return mintStartIndex;\n    }\n\n    /**\n     * @notice used by the delegator pool to migrate user stakes to this contract\n     * @dev\n     * - creates a new lock to represent the migrated stake\n     * - reverts if `_lockingDuration` exceeds maximum\n     * @param _sender owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function migrate(\n        address _sender,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) external {\n        if (msg.sender != delegatorPool) revert SenderNotAuthorized();\n        sdlToken.safeTransferFrom(delegatorPool, address(this), _amount);\n        _storeNewLock(_sender, _amount, _lockingDuration);\n    }\n\n    /**\n     * @notice stores a new lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeNewLock(\n        address _owner,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal updateRewards(_owner) {\n        Lock memory lock = _createLock(_amount, _lockingDuration);\n        uint256 lockId = lastLockId + 1;\n\n        locks[lockId] = lock;\n        lockOwners[lockId] = _owner;\n        balances[_owner] += 1;\n        lastLockId++;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_owner] += totalAmount;\n        totalEffectiveBalance += totalAmount;\n\n        emit CreateLock(_owner, lockId, lock.amount, lock.boostAmount, lock.duration);\n        emit Transfer(address(0), _owner, lockId);\n    }\n\n    /**\n     * @notice stores an updated lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeUpdatedLock(\n        address _owner,\n        uint256 _lockId,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal onlyLockOwner(_lockId, _owner) updateRewards(_owner) {\n        Lock memory lock = _updateLock(locks[_lockId], _amount, _lockingDuration);\n\n        int256 diffTotalAmount = int256(lock.amount + lock.boostAmount) -\n            int256(locks[_lockId].amount + locks[_lockId].boostAmount);\n\n        if (diffTotalAmount > 0) {\n            effectiveBalances[_owner] += uint256(diffTotalAmount);\n            totalEffectiveBalance += uint256(diffTotalAmount);\n        } else if (diffTotalAmount < 0) {\n            effectiveBalances[_owner] -= uint256(-1 * diffTotalAmount);\n            totalEffectiveBalance -= uint256(-1 * diffTotalAmount);\n        }\n\n        locks[_lockId] = lock;\n\n        emit UpdateLock(_owner, _lockId, lock.amount, lock.boostAmount, lock.duration);\n    }\n}"
    },
    {
      "filename": "contracts/core/sdlPool/SDLPoolPrimary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Primary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed only on the primary chain\n */\ncontract SDLPoolPrimary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public delegatorPool;\n\n    event IncomingUpdate(uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange, uint256 mintStartIndex);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public reinitializer(2) {\n        if (delegatorPool == address(0)) {\n            __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        } else {\n            delegatorPool = ccipController;\n        }\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * - see _updateLock() for more details on updating an existing lock or _createLock() for more details on\n     *   creating a new lock\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _storeUpdatedLock(_sender, lockId, _value, lockingDuration);\n            } else {\n                _storeNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _storeUpdatedLock(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        if (locks[_lockId].expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = locks[_lockId].duration / 2;\n        if (locks[_lockId].startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        locks[_lockId].expiry = expiry;\n\n        uint256 boostAmount = locks[_lockId].boostAmount;\n        locks[_lockId].boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        emit InitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        if (locks[_lockId].startTime != 0) {\n            uint64 expiry = locks[_lockId].expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = locks[_lockId].amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        emit Withdraw(msg.sender, _lockId, _amount);\n\n        if (_amount == baseAmount) {\n            delete locks[_lockId];\n            delete lockOwners[_lockId];\n            balances[msg.sender] -= 1;\n            if (tokenApprovals[_lockId] != address(0)) delete tokenApprovals[_lockId];\n            emit Transfer(msg.sender, address(0), _lockId);\n        } else {\n            locks[_lockId].amount = baseAmount - _amount;\n        }\n\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        sdlToken.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @notice handles an outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of lock\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     */\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    )\n        external\n        onlyCCIPController\n        onlyLockOwner(_lockId, _sender)\n        updateRewards(_sender)\n        updateRewards(ccipController)\n        returns (Lock memory)\n    {\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        effectiveBalances[ccipController] += totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles an incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of lock\n     * @param _lockId id of lock\n     * @param _lock lock\n     */\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) updateRewards(ccipController) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        effectiveBalances[ccipController] -= totalAmount;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an incoming update from a secondary chain\n     * @dev updates the total reSDL supply and keeps reSDL lock ids consistent between chains\n     * @param _numNewRESDLTokens number of new reSDL locks to be minted on other chain\n     * @param _totalRESDLSupplyChange total reSDL supply change on other chain\n     */\n    function handleIncomingUpdate(uint256 _numNewRESDLTokens, int256 _totalRESDLSupplyChange)\n        external\n        onlyCCIPController\n        returns (uint256)\n    {\n        uint256 mintStartIndex;\n        if (_numNewRESDLTokens != 0) {\n            mintStartIndex = lastLockId + 1;\n            lastLockId += _numNewRESDLTokens;\n        }\n\n        if (_totalRESDLSupplyChange > 0) {\n            effectiveBalances[ccipController] += uint256(_totalRESDLSupplyChange);\n            totalEffectiveBalance += uint256(_totalRESDLSupplyChange);\n        } else if (_totalRESDLSupplyChange < 0) {\n            effectiveBalances[ccipController] -= uint256(-1 * _totalRESDLSupplyChange);\n            totalEffectiveBalance -= uint256(-1 * _totalRESDLSupplyChange);\n        }\n\n        emit IncomingUpdate(_numNewRESDLTokens, _totalRESDLSupplyChange, mintStartIndex);\n\n        return mintStartIndex;\n    }\n\n    /**\n     * @notice used by the delegator pool to migrate user stakes to this contract\n     * @dev\n     * - creates a new lock to represent the migrated stake\n     * - reverts if `_lockingDuration` exceeds maximum\n     * @param _sender owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function migrate(\n        address _sender,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) external {\n        if (msg.sender != delegatorPool) revert SenderNotAuthorized();\n        sdlToken.safeTransferFrom(delegatorPool, address(this), _amount);\n        _storeNewLock(_sender, _amount, _lockingDuration);\n    }\n\n    /**\n     * @notice stores a new lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeNewLock(\n        address _owner,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal updateRewards(_owner) {\n        Lock memory lock = _createLock(_amount, _lockingDuration);\n        uint256 lockId = lastLockId + 1;\n\n        locks[lockId] = lock;\n        lockOwners[lockId] = _owner;\n        balances[_owner] += 1;\n        lastLockId++;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_owner] += totalAmount;\n        totalEffectiveBalance += totalAmount;\n\n        emit CreateLock(_owner, lockId, lock.amount, lock.boostAmount, lock.duration);\n        emit Transfer(address(0), _owner, lockId);\n    }\n\n    /**\n     * @notice stores an updated lock\n     * @param _owner owner of lock\n     * @param _amount amount to stake\n     * @param _lockingDuration duration of lock\n     */\n    function _storeUpdatedLock(\n        address _owner,\n        uint256 _lockId,\n        uint256 _amount,\n        uint64 _lockingDuration\n    ) internal onlyLockOwner(_lockId, _owner) updateRewards(_owner) {\n        Lock memory lock = _updateLock(locks[_lockId], _amount, _lockingDuration);\n\n        int256 diffTotalAmount = int256(lock.amount + lock.boostAmount) -\n            int256(locks[_lockId].amount + locks[_lockId].boostAmount);\n\n        if (diffTotalAmount > 0) {\n            effectiveBalances[_owner] += uint256(diffTotalAmount);\n            totalEffectiveBalance += uint256(diffTotalAmount);\n        } else if (diffTotalAmount < 0) {\n            effectiveBalances[_owner] -= uint256(-1 * diffTotalAmount);\n            totalEffectiveBalance -= uint256(-1 * diffTotalAmount);\n        }\n\n        locks[_lockId] = lock;\n\n        emit UpdateLock(_owner, _lockId, lock.amount, lock.boostAmount, lock.duration);\n    }\n}"
    },
    {
      "filename": "contracts/core/sdlPool/SDLPoolPrimary.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport \"./base/SDLPool.sol\";\n\n/**\n * @title SDL Pool Primary\n * @notice Allows users to stake/lock SDL tokens and receive a percentage of the protocol's earned rewards\n * @dev deployed only on the primary chain\n */\ncontract SDLPoolPrimary is SDLPool {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public delegatorPool;\n\n    event IncomingUpdate(uint256 numNewRESDLTokens, int256 totalRESDLSupplyChange, uint256 mintStartIndex);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice initializes contract\n     * @param _name name of the staking derivative token\n     * @param _symbol symbol of the staking derivative token\n     * @param _sdlToken address of the SDL token\n     * @param _boostController address of the boost controller\n     **/\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _sdlToken,\n        address _boostController\n    ) public reinitializer(2) {\n        if (delegatorPool == address(0)) {\n            __SDLPoolBase_init(_name, _symbol, _sdlToken, _boostController);\n        } else {\n            delegatorPool = ccipController;\n        }\n    }\n\n    /**\n     * @notice ERC677 implementation to stake/lock SDL tokens or distribute rewards\n     * @dev\n     * - will update/create a lock if the token transferred is SDL or will distribute rewards otherwise\n     *\n     * For Non-SDL:\n     * - reverts if token is unsupported\n     *\n     * For SDL:\n     * - set lockId to 0 to create a new lock or set lockId to > 0 to stake more into an existing lock\n     * - set lockingDuration to 0 to stake without locking or set lockingDuration to > 0 to lock for an amount\n     *   time in seconds\n     * - see _updateLock() for more details on updating an existing lock or _createLock() for more details on\n     *   creating a new lock\n     * @param _sender of the stake\n     * @param _value of the token transfer\n     * @param _calldata encoded lockId (uint256) and lockingDuration (uint64)\n     **/\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external override {\n        if (msg.sender != address(sdlToken) && !isTokenSupported(msg.sender)) revert UnauthorizedToken();\n\n        if (_value == 0) revert InvalidValue();\n\n        if (msg.sender == address(sdlToken)) {\n            (uint256 lockId, uint64 lockingDuration) = abi.decode(_calldata, (uint256, uint64));\n            if (lockId != 0) {\n                _storeUpdatedLock(_sender, lockId, _value, lockingDuration);\n            } else {\n                _storeNewLock(_sender, _value, lockingDuration);\n            }\n        } else {\n            distributeToken(msg.sender);\n        }\n    }\n\n    /**\n     * @notice extends the locking duration of a lock\n     * @dev\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if `_lockingDuration` is less than current locking duration of lock\n     * - reverts if `_lockingDuration` is 0 or exceeds the maximum\n     * @param _lockId id of lock\n     * @param _lockingDuration new locking duration to set\n     **/\n    function extendLockDuration(uint256 _lockId, uint64 _lockingDuration) external {\n        if (_lockingDuration == 0) revert InvalidLockingDuration();\n        _storeUpdatedLock(msg.sender, _lockId, 0, _lockingDuration);\n    }\n\n    /**\n     * @notice initiates the unlock period for a lock\n     * @dev\n     * - at least half of the locking duration must have elapsed to initiate the unlock period\n     * - the unlock period consists of half of the locking duration\n     * - boost will be set to 0 upon initiation of the unlock period\n     *\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if a minimum of half the locking duration has not elapsed\n     * @param _lockId id of lock\n     **/\n    function initiateUnlock(uint256 _lockId) external onlyLockOwner(_lockId, msg.sender) updateRewards(msg.sender) {\n        if (locks[_lockId].expiry != 0) revert UnlockAlreadyInitiated();\n        uint64 halfDuration = locks[_lockId].duration / 2;\n        if (locks[_lockId].startTime + halfDuration > block.timestamp) revert HalfDurationNotElapsed();\n\n        uint64 expiry = uint64(block.timestamp) + halfDuration;\n        locks[_lockId].expiry = expiry;\n\n        uint256 boostAmount = locks[_lockId].boostAmount;\n        locks[_lockId].boostAmount = 0;\n        effectiveBalances[msg.sender] -= boostAmount;\n        totalEffectiveBalance -= boostAmount;\n\n        emit InitiateUnlock(msg.sender, _lockId, expiry);\n    }\n\n    /**\n     * @notice withdraws unlocked SDL\n     * @dev\n     * - SDL can only be withdrawn if unlocked (once the unlock period has elapsed or if it was never\n     *   locked in the first place)\n     * - reverts if `_lockId` is invalid or sender is not owner of lock\n     * - reverts if not unlocked\n     * - reverts if `_amount` exceeds the amount staked in the lock\n     * @param _lockId id of the lock\n     * @param _amount amount to withdraw from the lock\n     **/\n    function withdraw(uint256 _lockId, uint256 _amount)\n        external\n        onlyLockOwner(_lockId, msg.sender)\n        updateRewards(msg.sender)\n    {\n        if (locks[_lockId].startTime != 0) {\n            uint64 expiry = locks[_lockId].expiry;\n            if (expiry == 0) revert UnlockNotInitiated();\n            if (expiry > block.timestamp) revert TotalDurationNotElapsed();\n        }\n\n        uint256 baseAmount = locks[_lockId].amount;\n        if (_amount > baseAmount) revert InsufficientBalance();\n\n        emit Withdraw(msg.sender, _lockId, _amount);\n\n        if (_amount == baseAmount) {\n            delete locks[_lockId];\n            delete lockOwners[_lockId];\n            balances[msg.sender] -= 1;\n            if (tokenApprovals[_lockId] != address(0)) delete tokenApprovals[_lockId];\n            emit Transfer(msg.sender, address(0), _lockId);\n        } else {\n            locks[_lockId].amount = baseAmount - _amount;\n        }\n\n        effectiveBalances[msg.sender] -= _amount;\n        totalEffectiveBalance -= _amount;\n\n        sdlToken.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @notice handles an outgoing transfer of an reSDL lock to another chain\n     * @param _sender sender of lock\n     * @param _lockId id of lock\n     * @param _sdlReceiver address to receive underlying SDL on this chain\n     */\n    function handleOutgoingRESDL(\n        address _sender,\n        uint256 _lockId,\n        address _sdlReceiver\n    )\n        external\n        onlyCCIPController\n        onlyLockOwner(_lockId, _sender)\n        updateRewards(_sender)\n        updateRewards(ccipController)\n        returns (Lock memory)\n    {\n        Lock memory lock = locks[_lockId];\n\n        delete locks[_lockId].amount;\n        delete lockOwners[_lockId];\n        balances[_sender] -= 1;\n\n        uint256 totalAmount = lock.amount + lock.boostAmount;\n        effectiveBalances[_sender] -= totalAmount;\n        effectiveBalances[ccipController] += totalAmount;\n\n        sdlToken.safeTransfer(_sdlReceiver, lock.amount);\n\n        emit OutgoingRESDL(_sender, _lockId);\n\n        return lock;\n    }\n\n    /**\n     * @notice handles an incoming transfer of an reSDL lock from another chain\n     * @param _receiver receiver of lock\n     * @param _lockId id of lock\n     * @param _lock lock\n     */\n    function handleIncomingRESDL(\n        address _receiver,\n        uint256 _lockId,\n        Lock calldata _lock\n    ) external onlyCCIPController updateRewards(_receiver) updateRewards(ccipController) {\n        if (lockOwners[_lockId] != address(0)) revert InvalidLockId();\n\n        locks[_lockId] = Lock(_lock.amount, _lock.boostAmount, _lock.startTime, _lock.duration, _lock.expiry);\n        lockOwners[_lockId] = _receiver;\n        balances[_receiver] += 1;\n\n        uint256 totalAmount = _lock.amount + _lock.boostAmount;\n        effectiveBalances[_receiver] += totalAmount;\n        effectiveBalances[ccipController] -= totalAmount;\n\n        emit IncomingRESDL(_receiver, _lockId);\n    }\n\n    /**\n     * @notice handles an incoming update from a secondary chain\n     * @dev updates the total reSDL supply and keeps reSDL lock ids consistent between chains\n     * @param _numNewRESDLTokens number of new reSDL locks to be minted on other chain\n     * @param _totalRESDLSupplyChange total reSDL supply change on other chain\n     */\n    function handleIncomingUpdate(uint256 _nu"
    }
  ]
}