{
  "Title": "M-2: Incorrect implementation of `BPF` leads to kicker losing rewards in a `take` action",
  "Content": "# Issue M-2: Incorrect implementation of `BPF` leads to kicker losing rewards in a `take` action \n\nSource: https://github.com/sherlock-audit/2023-09-ajna-judging/issues/18 \n\n## Found by \nsantipu\\_\n\nWhen a `take` action takes place, if `ThresholdPrice >= NeutralPrice` and `PriceTake = NeutralPrice`, the Bond Payment Factor (`BPF`) should be `bondFactor` but it will be 0, causing the loss of rewards of the kicker in that action. \n\n## Vulnerability Detail\n\nThe Bond Payment Factor (`BPF`) is the formula that determines the reward/penalty over the bond of a kicker in each `take` action. According to the whitepaper, the formula is described as:\n\n```solidity\n// If TP < NP\nBPF = bondFactor * min(1, max(-1, (NP - price) / (NP - TP)))\n\n// If TP >= NP\nBPF = bondFactor     (if price <= NP)\nBPF = -bondFactor    (if price > NP)\n```\n\nThe implementation of this formula is the following:\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/helpers/PoolHelper.sol#L382-L411\n```solidity\nfunction _bpf(\n    uint256 debt_,\n    uint256 collateral_,\n    uint256 neutralPrice_,\n    uint256 bondFactor_,\n    uint256 auctionPrice_\n) pure returns (int256) {\n    int256 thresholdPrice = int256(Maths.wdiv(debt_, collateral_));\n\n    int256 sign;\n    if (thresholdPrice < int256(neutralPrice_)) {\n        // BPF = BondFactor * min(1, max(-1, (neutralPrice - price) / (neutralPrice - thresholdPrice)))\n        sign = Maths.minInt(\n            1e18,\n            Maths.maxInt(\n                -1 * 1e18,\n                PRBMathSD59x18.div(\n                    int256(neutralPrice_) - int256(auctionPrice_),\n                    int256(neutralPrice_) - thresholdPrice\n                )\n            )\n        );\n    } else {\n        int256 val = int256(neutralPrice_) - int256(auctionPrice_);\n        if (val < 0 )      sign = -1e18;\n        else if (val != 0) sign = 1e18; // @audit Sign will be zero when NP = auctionPrice\n    }\n\n    return PRBMathSD59x18.mul(int256(bondFactor_), sign);\n}\n```\n\nThe issue is that the implementation of the `BPF` formula in the code doesn't match the specification, leading to the loss of rewards in that `take` action in cases where `TP >= NP` and `price = NP`. \n\nAs showed in the above snippet, in cases where `TP >= NP` and `NP = price` (thus `val = 0`) the function won't set a value for `sign` (will be `0` by default) so that will result in a computed `BPF` of `0`, instead of `bondFactor` that would be the correct `BPF`.\n\n## Impact\n\nThe kicker will lose the rewards in that `take` action if the previous conditions are satisfied. \n\nWhile the probability of this conditions to be met is not usual, the impact is the loss of rewards for that kicker and that may cause to lose part of the bond if later a `take` is performed with a negative `BPF`. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/main/ajna-core/src/libraries/helpers/PoolHelper.sol#L407\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the `_bpf` function to match the specification in order to fairly distribute the rewards in a `take` action:\n\n```diff\nfunction _bpf(\n    uint256 debt_,\n    uint256 collateral_,\n    uint256 neutralPrice_,\n    uint256 bondFactor_,\n    uint256 auctionPrice_\n) pure returns (int256) {\n    int256 thresholdPrice = int256(Maths.wdiv(debt_, collateral_));\n\n    int256 sign;\n    if (thresholdPrice < int256(neutralPrice_)) {\n        // BPF = BondFactor * min(1, max(-1, (neutralPrice - price) / (neutralPrice - thresholdPrice)))\n        sign = Maths.minInt(\n            1e18,\n            Maths.maxInt(\n                -1 * 1e18,\n                PRBMathSD59x18.div(\n                    int256(neutralPrice_) - int256(auctionPrice_),\n                    int256(neutralPrice_) - thresholdPrice\n                )\n            )\n        );\n    } else {\n        int256 val = int256(neutralPrice_) - int256(auctionPrice_);\n        if (val < 0 )      sign = -1e18;\n-       else if (val != 0) sign = 1e18;\n+       else               sign = 1e18;\n    }\n\n    return PRBMathSD59x18.mul(int256(bondFactor_), sign);\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**n33k** commented:\n>  \"consistent with the whitepaper, sign could be 0\"\n\n\n\n**santipu03**\n\nEscalate\n\nThis issue has been erroneously excluded and should be high severity because the `_bpf` function **DOES NOT** adhere to the specification and it causes the loss of rewards for a kicker. This was confirmed by the sponsors during the contest.\n\nAs a summary, the whitepaper states the following:\n> If ð‘‡ð‘ƒ â‰¥ ð‘ð‘ƒ, then the second factor in this equation is replaced with the step function that returns +1 if the take price is less than or equal to the NP, and -1 otherwise:\nðµð‘ƒð¹ = ðµð‘œð‘›ð‘‘ð¹ð‘Žð‘ð‘¡ð‘œð‘Ÿ  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ð‘ƒð‘Ÿð‘–ð‘ð‘’ð‘¡ð‘Žð‘˜ð‘’ â‰¤ ð‘ð‘ƒ\nðµð‘ƒð¹ = âˆ’ ðµð‘œð‘›ð‘‘ð¹ð‘Žð‘ð‘¡ð‘œð‘Ÿ &nbsp;&nbsp;&nbsp;          if ð‘ƒð‘Ÿð‘–ð‘ð‘’ð‘¡ð‘Žð‘˜ð‘’ > ð‘ð‘ƒ\n\nTherefore, following the specification, in cases when `TP â‰¥ NP` and `PriceTake = NP`, then the correct BPF should be: `BPF = BondFactor`. \nBut in these cases, the implementation erroneously sets `BPF = 0`. The impact will be that the kicker will lose all the rewards on that `take` action because `BPF` is set to `0` instead of `BondFactor`. \n\nIf the auction is completed in one take, the kicker will lose all the rewards from that auction that should belong to him. If the auction is settled later in time after this action, then the `auctionPrice` (`priceTake`) will be lower than `NP` so the kicker will lose part of the bond because of this issue (because the lost rewards would cancel out the later losses). \n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue has been erroneously excluded and should be high severity because the `_bpf` function **DOES NOT** adhere to the specification and it causes the loss of rewards for a kicker. This was confirmed by the sponsors during the contest.\n> \n> As a summary, the whitepaper states the following:\n> > If ð‘‡ð‘ƒ â‰¥ ð‘ð‘ƒ, then the second factor in this equation is replaced with the step function that returns +1 if the take price is less than or equal to the NP, and -1 otherwise:\n> ðµð‘ƒð¹ = ðµð‘œð‘›ð‘‘ð¹ð‘Žð‘ð‘¡ð‘œð‘Ÿ  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ð‘ƒð‘Ÿð‘–ð‘ð‘’ð‘¡ð‘Žð‘˜ð‘’ â‰¤ ð‘ð‘ƒ\n> ðµð‘ƒð¹ = âˆ’ ðµð‘œð‘›ð‘‘ð¹ð‘Žð‘ð‘¡ð‘œð‘Ÿ &nbsp;&nbsp;&nbsp;          if ð‘ƒð‘Ÿð‘–ð‘ð‘’ð‘¡ð‘Žð‘˜ð‘’ > ð‘ð‘ƒ\n> \n> Therefore, following the specification, in cases when `TP â‰¥ NP` and `PriceTake = NP`, then the correct BPF should be: `BPF = BondFactor`. \n> But in these cases, the implementation erroneously sets `BPF = 0`. The impact will be that the kicker will lose all the rewards on that `take` action because `BPF` is set to `0` instead of `BondFactor`. \n> \n> If the auction is completed in one take, the kicker will lose all the rewards from that auction that should belong to him. If the auction is settled later in time after this action, then the `auctionPrice` (`priceTake`) will be lower than `NP` so the kicker will lose part of the bond because of this issue (because the lost rewards would cancel out the later losses). \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neeksec**\n\nThis is a valid one.\nI suggest to set severity to `Medium` because the probability of meeting the condition NP=TP is pretty low.\n\n**kadenzipfel**\n\nThis should be low severity as it's a slight inconsistency from the specification which has an extremely low chance of occurring considering the fact that two independently varying 18 decimal numbers are extremely unlikely to collide. \n\nFurthermore, there's no loss of funds as one wei in each direction would be a gain or a loss in bond reward or penalty respectively. There's no flaw in the design of making the reward 0 in this circumstance as it would be just as reasonable for the protocol to deem NP == price as a penalized circumstance as it is to make it rewarded or neutral.\n\n**santipu03**\n\nIt's correct that it's highly unlikely for this scenario to happen, but in case it occurs, the impact is high because is causing the kicker to lose all the rewards in that `take` action. \n\nThis issue doesn't argue wether the design is flawed or not, it simply points out a scenario where the kicker should be winning a reward over the bond but actually doesn't because of an error on the code. \n\n**kadenzipfel**\n\nGiven the level of precision, 1/1,000,000,000 is probably an optimistic likelihood of this occurring. We can reasonably write off the impact of it actually happening with these odds.\n\nSee [judging docs for medium severity](https://docs.sherlock.xyz/audits/judging/judging#ii.-criteria-for-issue-severity): \"The attack path is possible with assumptions that either mimic on-chain conditions or **reflect conditions that have a reasonable chance of becoming true in the future**.\"\n\n**Evert0x**\n\nIf the `1/1,000,000,000` odds are optimistic, I plan to reject escalation and keep issues state as is. \n\n@santipu03 please follow up with a comment if you see a more realistic scenario or attack path where NP will be equal to TP\n\n**Czar102**\n\n@santipu03 is there any reason why could `NP = TP` with a larger probability? Could this be manipulated easily? What happens with the kicker's reward, is it locked forever or is it owned by anyone?\n\n**santipu03**\n\nI want to emphasize that this issue has significant implications not only for the kicker but also for the borrower. Specifically, the borrower faces the risk of receiving less repayment from the taker than deserved. This situation arises if the Bond Payment Factor (BPF) is erroneously set to 0 (like in this case), which in turn increases the Take Penalty Factor (TPF). Consequently, the taker repays a lesser portion of the borrower's debt for the same token amount in the `take` action. Then, the tokens intended for the kicker and borrower will be mistakenly redirected to reserves.\n\nThe severity of this issue is undeniably high, though is difficult to predict its likelihood.\n\nAjna's goal is to operate as an immutable, trustless protocol. Over time, it's probable that this issue will eventually manifest, leading to significant disruptions, such as kickers losing rewards and borrowers facing undue penalties.\n\nThe issue has been confirmed by the sponsors via DMs, and they are likely to have already addressed it. However, given the uncertainty surrounding its probability, I'll leave the judges with the final decision and will respect that. \n\n**Czar102**\n\n@santipu03 please provide information if it is possible to influence the result of `NP = TP`. If those values are like random numbers of order `1e18` then I will classify this as a Medium. Otherwise please explain in detail how could the attacker change the values of any/both of these variables so that they could collide in a real-life scenario.\n\n**santipu03**\n\nTo recap, this issue arises because when `TP >= NP` and `NP = auctionPrice`. In such cases, the kicker should receive full rewards (`bondFactor`) as per the specification, but due to a bug, the kicker will earn nothing. Additionally, this bug results in increased penalties for the borrower.\n\nThe scenario of `TP >= NP` is likely, but `NP` equalling `auctionPrice` is less probable. However, it's still possible and can be exploited by an attacker.\n\n`NP` (Neutral Price) is fixed at the time a borrower is kicked and remains unchanged throughout the auction. In contrast, `auctionPrice` starts at `referencePrice` and decreases over time. An attacker can manipulate this by calling `take` shortly before it should be due to market conditions, to keep the `auctionPrice` high, or by delaying it, allowing the `auctionPrice` to lower. This way an attacker can game the value of `auctionPrice` griefing the kicker and borrower. \n\n**Czar102**\n\n@neeksec would you agree with the above statement that the attacker can manipulate the `auctionPrice` by carefully using `take`? Or is it more difficult?\n\n**neeksec**\n\nI agree that the `taker` can control `auctionPrice` to some extent. But making `auctionPrice` equal to NP is still very difficult.\n\n[`_auctionPrice`](https://github.com/sherlock-audit/2023-09-ajna/blob/87abfb6a9150e5df3819de58cbd972a66b3b50e3/ajna-core/src/libraries/helpers/PoolHelper.sol#L353-L370) involves complex computations, and the `taker` can only control the `block.timestamp` within it by delaying the call to `take`. The final result returned is difficult to be manipluted to be equal to NP with this limited control over `block.timestamp`.\n\n**Czar102**\n\nI don't know the codebase, but I would think that for certain situations (like very low price), the probability of a collision is larger. If the two parameters that need to equal can be manipulated by changing a timestamp parameter, this allows the attacker for only `1e3 - 1e4` additional \"trials\", which doesn't change the probability to any reasonable level (hence it's of the order of `1e-14` now). @santipu03 are you sure you can't come up for any reasons to increase the probability? PoC or an extremely detailed explanation appreciated.\nThis issue surely won't be of high severity, but it still has an opportunity to qualify for medium.\n\n**santipu03**\n\nI've just realised we've been missing a critical factor in this issue. \n\nTo clarify, the `_auctionPrice` function is designed so that 18 hours after `kickTime` (equivalent to 64,800 seconds), it will return a value equal to `referencePrice`. The calculation of [`referencePrice`](https://github.com/sherlock-audit/2023-09-ajna/blob/87abfb6a9150e5df3819de58cbd972a66b3b50e3/ajna-core/src/libraries/external/KickerActions.sol#L319C5-L319C101) is determined as the maximum of `NP` and `HTP`, and typically `NP` is higher than `HTP`. This means that once 18 hours have elapsed in the auction, the `auctionPrice` will align exactly with the value of `NP`.\n\nI found out this by playing with a variation of the [`_auctionPrice`](https://github.com/sherlock-audit/2023-09-ajna/blob/87abfb6a9150e5df3819de58cbd972a66b3b50e3/ajna-core/src/libraries/helpers/PoolHelper.sol#L353-L370) function:\n```diff\nfunction _auctionPrice(\n    uint256 referencePrice_,\n-   uint256 kickTime_\n+   uint256 secondsElapsed\n) view returns (uint256 price_) {\n-   uint256 elapsedMinutes = Maths.wdiv((block.timestamp - kickTime_) * 1e18, 1 minutes * 1e18);\n+  uint256 elapsedMinutes = Maths.wdiv(secondsElapsed * 1e18, 1 minutes * 1e18);\n\n    // ...\n}\n```\n\nIf we paste this variation of `_auctionPrice` into chisel it reveals that when `secondsElapsed = 64800`, the value returned is `referencePrice / 256`, which is essentially the same as `NP`:\n\n```\n âžœ _auctionPrice(256e18, 64800) == 1e18\nType: bool\nâ”” Value: true\n```\n\nWhat this implies is that the likelihood of `NP` matching `auctionPrice` is not as low as previously thought. Specifically, at the exact 18-hour mark since the auction started, `NP` will equal `auctionPrice`. This collision will trigger the impact we discussed earlier. Given that Ethereum blocks are generated approximately every 12 seconds, it means that for every auction reaching 18 hours (most of them), there's about a 1 in 12 chance that `NP` will coincide with `auctionPrice`, posing a significant risk.\n\n**Czar102**\n\n@neeksec can you confirm?\n\n**neeksec**\n\n@Czar102 \nAfter reviewing the relevant code along with Section 7.2 'Liquidation Call' of the whitepaper, I can confirm that @santipu03 is correct in his https://github.com/sherlock-audit/2023-09-ajna-judging/issues/18#issuecomment-1821310337.\n\nThe auctionPrice_ will intersect with neutralPrice_ at a predetermined time, within the 72 hour auction. This issue is highly likely to occur.\n\n**kadenzipfel**\n\nIn the case that NP > HTP and referencePrice = NP, it is true that the auctionPrice == referencePrice, and thus the BPF will unexpectedly be 0. Furthermore, the likelihood is even higher than suggested here where the block time doesn't have to be perfectly timed, it just has to be within the two hour window before the next halving. The likelihood is thus reasonably high to constitute a valid issue on the basis of likelihood.\n\nTo be clear though, this should certainly not be classified as a high severity as initially suggested in the escalation, and arguably not even a medium, for the following reason:\n\n- If the auctionPrice > NP, the kicker earns a fee and the taker pays a fee.\n- If the auctionPrice < NP, the taker earns a fee and the kicker pays a fee.\n- Thus, it would be a reasonable design decision to make it such that if the auctionPrice == NP, that no one pays a fee.\n\nNote the [criteria for medium and high severity vulnerabilities](https://docs.sherlock.xyz/audits/judging/judging#ii.-criteria-for-issue-severity): \"The vulnerability must be something that is not considered an acceptable risk by a reasonable protocol team.\" This being said, perhaps the deviation of the implementation from the specification warrants it being a medium risk finding regardless.\n\nEdit: To be extra clear, there is no attack vector here. The vulnerability is simply that the kicker/taker will not receive/pay the amount of fees that they expect according to the white paper. There is no way to exploit it for profit.\n\n**neeksec**\n\nI think @kadenzipfel is right, there is no attack vector here.\n\n```\nThus, it would be a reasonable design decision to make it such that if the auctionPrice == NP, that no one pays a fee.\n```\n\nThere is no deviation of the implementation from the specification. This behavior is described in `Section 7.3 Liquidation Bonds` of the whitepaper. The graph in that section clearly shows that when auction price equals NP, the profit/loss to kicker should be zero. \n\n<img width=\"523\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-09-ajna-judging/assets/141397640/e48a3a81-f362-4a91-b6af-5ff80e082de0\">\n\n\n**Czar102**\n\n@santipu03 would you agree with the above?\n\n**santipu03**\n\n> There is no deviation of the implementation from the specification. This behavior is described in Section 7.3 Liquidation Bonds of the whitepaper. The graph in that section clearly shows that when auction price equals NP, the profit/loss to kicker should be zero.\n\nIt's critical to understand that `BPF` is not determined by only one formula. The graph from above represents the `BPF` curve in case `TP < NP`, but my report is highlighting an inconsistency in the implementation in the cases where `TP >= NP`. The formulas used to calculate the `BPF` in both cases are not the same, refer to section **7.3.3 Determining the Reward or Penalty** on the whitepaper for clarification. \n\n> Thus, it would be a reasonable design decision to make it such that if the auctionPrice == NP, that no one pays a fee.\n\nAs @Czar102 remarked on other issues, considerations about design choices are out of scope. The specification explicitly states that when `TP >= NP` and `NP = auctionPrice` then `BPF` must be `bondFactor`, instead the implementation makes `BPF = 0` in those cases. \n\nThis discrepancy leads to significant consequences: kickers lose rewards and borrowers lose assets, as `TPF` (Take Penalty Factor) is higher than it should be. Furthermore, this creates an **attack vector**: with an inflated `TPF`, takers are incentivized to exploit the situation, paying less for borrower collateral when `auctionPrice = NP`, as well as griefing the kicker.\n\n**neeksec**\n\nI agree that the graph is for case `TP < NP` and is not relevant to this issue.\n\n`The specification explicitly states that when TP >= NP and NP = auctionPrice then BPF must be bondFactor`\n\n@santipu03 Can you show where this is stated?\n\n**santipu03**\n\nAs outlined in my previous message, section **7.3.3 Determining the Reward or Penalty**:\n\n<img src=\"https://github.com/sherlock-audit/2023-09-ajna-judging/assets/90318659/5b5267c3-c108-4c5c-9b87-52dfb4c3e9e5\"  height=\"450\" />\n\n**dmitriia**\n\nBy definition of `NP`, which is neutral price level, when `AP == NP` the reward have to be zero.\n\nI don't like drastic swings the formula produces when TP is at or above NP either, but this is a corner case state, achievable on the series of subsequent takes only as initially NP to TP ratio NP defined with is above 1. \n\nThis corner case should ideally go away when TP becomes snapshotted. \n\n\n**Czar102**\n\nIt seems that the issue is the difference between the implementation and the documentation. The loss of funds @santipu03 refers to is the loss of funds that happens when parties have an expectation for the contract to behave as described in the documentation. If the documentation was different (stating that `BPF == 0` for `auctionPrice == NP`), there wouldn't be an issue.\n\nIs that right? @dmitriia @santipu03 \n\n**dmitriia**\n\nYes, as per base NP definition from 7.3 of 10-12-2023 whitepaper\n\n> the NP is the price at which a kicker will have their bond returned to them without penalty or reward (thus being considered a neutral outcome from the kicker's perspective)\n\nany deviations from that are issues by themselves, and in this case it looks like it's the documentation one, where it needs to be corrected.\n\n**santipu03**\n\nDuring the contest, I encountered this issue and immediately reached out to the sponsors to clarify whether it was a discrepancy in the documentation or an actual flaw in the implementation. The response I received was this:\n\n![image](https://github.com/sherlock-audit/2023-09-ajna-judging/assets/90318659/b52acbfc-e46c-42be-b1e9-7d6daccf3430)\n\nIt's important to note that the determination of whether an issue is a documentation mistake or an implementation flaw rests with the development team, not the auditors. Considering the high likelihood and potential for fund loss, I believe this issue deserves a medium/high severity rating.\n\nIn comparison, when I reported issue #19, it was classified as informational since it was merely a documentation error. However, this current issue clearly stems from an implementation mistake as per the sponsor's comment, setting it apart from the previous one.\n\n**Czar102**\n\nI wanted to decide whether it should be medium or high. If the contracts work properly for both options, but the implementation is different than the documentation and the expectation of a different behavior can implicitly make users lose funds, the issue will be considered medium severity.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [santipu03](https://github.com/sherlock-audit/2023-09-ajna-judging/issues/18/#issuecomment-1799125943): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/114",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/helpers/PoolHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\nimport { Math }           from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport { Buckets } from '../internal/Buckets.sol';\nimport { Maths }   from '../internal/Maths.sol';\n\n    error BucketIndexOutOfBounds();\n    error BucketPriceOutOfBounds();\n\n    /*************************/\n    /*** Price Conversions ***/\n    /*************************/\n\n    /// @dev constant price indices defining the min and max of the potential price range\n    int256  constant MAX_BUCKET_INDEX  =  4_156;\n    int256  constant MIN_BUCKET_INDEX  = -3_232;\n    uint256 constant MAX_FENWICK_INDEX =  7_388;\n\n    uint256 constant MIN_PRICE = 99_836_282_890;\n    uint256 constant MAX_PRICE = 1_004_968_987.606512354182109771 * 1e18;\n\n    uint256 constant MAX_INFLATED_PRICE = 50_248_449_380.325617709105488550 * 1e18; // 50 * MAX_PRICE\n\n    /// @dev deposit buffer (extra margin) used for calculating reserves\n    uint256 constant DEPOSIT_BUFFER = 1.000000001 * 1e18;\n\n    /// @dev step amounts in basis points. This is a constant across pools at `0.005`, achieved by dividing `WAD` by `10,000`\n    int256 constant FLOAT_STEP_INT = 1.005 * 1e18;\n\n    /**\n     *  @notice Calculates the price (`WAD` precision) for a given `Fenwick` index.\n     *  @dev    Reverts with `BucketIndexOutOfBounds` if index exceeds maximum constant.\n     *  @dev    Uses fixed-point math to get around lack of floating point numbers in `EVM`.\n     *  @dev    Fenwick index is converted to bucket index.\n     *  @dev    Fenwick index to bucket index conversion:\n     *  @dev      `1.00`      : bucket index `0`,     fenwick index `4156`: `7388-4156-3232=0`.\n     *  @dev      `MAX_PRICE` : bucket index `4156`,  fenwick index `0`:    `7388-0-3232=4156`.\n     *  @dev      `MIN_PRICE` : bucket index - `3232`, fenwick index `7388`: `7388-7388-3232=-3232`.\n     *  @dev    `V1`: `price = MIN_PRICE + (FLOAT_STEP * index)`\n     *  @dev    `V2`: `price = MAX_PRICE * (FLOAT_STEP ** (abs(int256(index - MAX_PRICE_INDEX))));`\n     *  @dev    `V3 (final)`: `x^y = 2^(y*log_2(x))`\n     */\n    function _priceAt(\n        uint256 index_\n    ) pure returns (uint256) {\n        // Lowest Fenwick index is highest price, so invert the index and offset by highest bucket index.\n        int256 bucketIndex = MAX_BUCKET_INDEX - int256(index_);\n        if (bucketIndex < MIN_BUCKET_INDEX || bucketIndex > MAX_BUCKET_INDEX) revert BucketIndexOutOfBounds();\n\n        return uint256(\n            PRBMathSD59x18.exp2(\n                PRBMathSD59x18.mul(\n                    PRBMathSD59x18.fromInt(bucketIndex),\n                    PRBMathSD59x18.log2(FLOAT_STEP_INT)\n                )\n            )\n        );\n    }\n\n    /**\n     *  @notice Calculates the  Fenwick  index for a given price.\n     *  @dev    Reverts with `BucketPriceOutOfBounds` if price exceeds maximum constant.\n     *  @dev    Price expected to be inputted as a `WAD` (`18` decimal).\n     *  @dev    `V1`: `bucket index = (price - MIN_PRICE) / FLOAT_STEP`\n     *  @dev    `V2`: `bucket index = (log(FLOAT_STEP) * price) /  MAX_PRICE`\n     *  @dev    `V3 (final)`: `bucket index =  log_2(price) / log_2(FLOAT_STEP)`\n     *  @dev    `Fenwick index = 7388 - bucket index + 3232`\n     */\n    function _indexOf(\n        uint256 price_\n    ) pure returns (uint256) {\n        if (price_ < MIN_PRICE || price_ > MAX_PRICE) revert BucketPriceOutOfBounds();\n\n        int256 index = PRBMathSD59x18.div(\n            PRBMathSD59x18.log2(int256(price_)),\n            PRBMathSD59x18.log2(FLOAT_STEP_INT)\n        );\n\n        int256 ceilIndex = PRBMathSD59x18.ceil(index);\n        if (index < 0 && ceilIndex - index > 0.5 * 1e18) {\n            return uint256(4157 - PRBMathSD59x18.toInt(ceilIndex));\n        }\n        return uint256(4156 - PRBMathSD59x18.toInt(ceilIndex));\n    }\n\n    /**********************/\n    /*** Pool Utilities ***/\n    /**********************/\n\n    /**\n     *  @notice Calculates the minimum debt amount that can be borrowed or can remain in a loan in pool.\n     *  @param  debt_          The debt amount to calculate minimum debt amount for.\n     *  @param  loansCount_    The number of loans in pool.\n     *  @return minDebtAmount_ Minimum debt amount value of the pool.\n     */\n    function _minDebtAmount(\n        uint256 debt_,\n        uint256 loansCount_\n    ) pure returns (uint256 minDebtAmount_) {\n        if (loansCount_ != 0) {\n            minDebtAmount_ = Maths.wdiv(Maths.wdiv(debt_, Maths.wad(loansCount_)), 10**19);\n        }\n    }\n\n    /**\n     *  @notice Calculates origination fee for a given interest rate.\n     *  @notice Calculated as greater of the current annualized interest rate divided by `52` (one week of interest) or `5` bps.\n     *  @param  interestRate_ The current interest rate.\n     *  @return Fee rate based upon the given interest rate.\n     */\n    function _borrowFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // greater of the current annualized interest rate divided by 52 (one week of interest) or 5 bps\n        return Maths.max(Maths.wdiv(interestRate_, 52 * 1e18), 0.0005 * 1e18);\n    }\n\n    /**\n     * @notice Calculates the unutilized deposit fee, charged to lenders who deposit below the `LUP`.\n     * @param  interestRate_ The current interest rate.\n     * @return Fee rate based upon the given interest rate, capped at 10%.\n     */\n    function _depositFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // current annualized rate divided by 365 (24 hours of interest), capped at 10%\n        return Maths.min(Maths.wdiv(interestRate_, 365 * 1e18), 0.1 * 1e18);\n    }\n\n    /**\n     *  @notice Calculates debt-weighted average threshold price.\n     *  @param  t0Debt_              Pool debt owed by borrowers in `t0` terms.\n     *  @param  inflator_            Pool's borrower inflator.\n     *  @param  t0Debt2ToCollateral_ `t0-debt-squared-to-collateral` accumulator. \n     */\n    function _dwatp(\n        uint256 t0Debt_,\n        uint256 inflator_,\n        uint256 t0Debt2ToCollateral_\n    ) pure returns (uint256) {\n        return t0Debt_ == 0 ? 0 : Maths.wdiv(Maths.wmul(inflator_, t0Debt2ToCollateral_), t0Debt_);\n    }\n\n    /**\n     *  @notice Collateralization calculation.\n     *  @param debt_       Debt to calculate collateralization for.\n     *  @param collateral_ Collateral to calculate collateralization for.\n     *  @param price_      Price to calculate collateralization for.\n     *  @param type_       Type of the pool.\n     *  @return `True` if collateralization calculated is equal or greater than `1`.\n     */\n    function _isCollateralized(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 price_,\n        uint8 type_\n    ) pure returns (bool) {\n        if (type_ == uint8(PoolType.ERC20)) return Maths.wmul(collateral_, price_) >= debt_;\n        else {\n            //slither-disable-next-line divide-before-multiply\n            collateral_ = (collateral_ / Maths.WAD) * Maths.WAD; // use collateral floor\n            return Maths.wmul(collateral_, price_) >= debt_;\n        }\n    }\n\n    /**\n     *  @notice Price precision adjustment used in calculating collateral dust for a bucket.\n     *          To ensure the accuracy of the exchange rate calculation, buckets with smaller prices require\n     *          larger minimum amounts of collateral.  This formula imposes a lower bound independent of token scale.\n     *  @param  bucketIndex_              Index of the bucket, or `0` for encumbered collateral with no bucket affinity.\n     *  @return pricePrecisionAdjustment_ Unscaled integer of the minimum number of decimal places the dust limit requires.\n     */\n    function _getCollateralDustPricePrecisionAdjustment(\n        uint256 bucketIndex_\n    ) pure returns (uint256 pricePrecisionAdjustment_) {\n        // conditional is a gas optimization\n        if (bucketIndex_ > 3900) {\n            int256 bucketOffset = int256(bucketIndex_ - 3900);\n            int256 result = PRBMathSD59x18.sqrt(PRBMathSD59x18.div(bucketOffset * 1e18, int256(36 * 1e18)));\n            pricePrecisionAdjustment_ = uint256(result / 1e18);\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of collateral calculated for the given amount of `LP`.\n     *  @dev    The value returned is capped at collateral amount available in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate collateral for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return collateralAmount_ Amount of collateral calculated for the given `LP `amount.\n     */\n    function _lpToCollateral(\n        uint256 bucketCollateral_,\n        uint256 bucketLP_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 collateralAmount_) {\n        collateralAmount_ = Buckets.lpToCollateral(\n            bucketCollateral_,\n            bucketLP_,\n            deposit_,\n            lenderLPBalance_,\n            bucketPrice_,\n            Math.Rounding.Down\n        );\n\n        if (collateralAmount_ > bucketCollateral_) {\n            // user is owed more collateral than is available in the bucket\n            collateralAmount_ = bucketCollateral_;\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of quote tokens calculated for the given amount of `LP`.\n     *  @dev    The value returned is capped at available bucket deposit.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate quote token amount for.\n     *  @param  maxQuoteToken_    The max quote token amount to calculate `LP` for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return quoteTokenAmount_ Amount of quote tokens calculated for the given `LP` amount, capped at available bucket deposit.\n     */\n    function _lpToQuoteToken(\n        uint256 bucketLP_,\n        uint256 bucketCollateral_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 maxQuoteToken_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 quoteTokenAmount_) {\n        quoteTokenAmount_ = Buckets.lpToQuoteTokens(\n            bucketCollateral_,\n            bucketLP_,\n            deposit_,\n            lenderLPBalance_,\n            bucketPrice_,\n            Math.Rounding.Down\n        );\n\n        if (quoteTokenAmount_ > deposit_)       quoteTokenAmount_ = deposit_;\n        if (quoteTokenAmount_ > maxQuoteToken_) quoteTokenAmount_ = maxQuoteToken_;\n    }\n\n    /**\n     *  @notice Rounds a token amount down to the minimum amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        scaledAmount_ = (amount_ / tokenScale_) * tokenScale_;\n    }\n\n    /**\n     *  @notice Rounds a token amount up to the next amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundUpToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        if (amount_ % tokenScale_ == 0)\n            scaledAmount_ = amount_;\n        else\n            scaledAmount_ = _roundToScale(amount_, tokenScale_) + tokenScale_;\n    }\n\n    /*********************************/\n    /*** Reserve Auction Utilities ***/\n    /*********************************/\n\n    uint256 constant MINUTE_HALF_LIFE    = 0.988514020352896135_356867505 * 1e27;  // 0.5^(1/60)\n\n    /**\n     *  @notice Calculates claimable reserves within the pool.\n     *  @dev    Claimable reserve auctions and escrowed auction bonds are guaranteed by the pool.\n     *  @param  debt_                    Pool's debt.\n     *  @param  poolSize_                Pool's deposit size.\n     *  @param  totalBondEscrowed_       Total bond escrowed.\n     *  @param  reserveAuctionUnclaimed_ Pool's unclaimed reserve auction.\n     *  @param  quoteTokenBalance_       Pool's quote token balance.\n     *  @return claimable_               Calculated pool reserves.\n     */  \n    function _claimableReserves(\n        uint256 debt_,\n        uint256 poolSize_,\n        uint256 totalBondEscrowed_,\n        uint256 reserveAuctionUnclaimed_,\n        uint256 quoteTokenBalance_\n    ) pure returns (uint256 claimable_) {\n        uint256 guaranteedFunds = totalBondEscrowed_ + reserveAuctionUnclaimed_;\n\n        // calculate claimable reserves if there's quote token excess\n        if (quoteTokenBalance_ > guaranteedFunds) {\n            claimable_ = Maths.wmul(0.995 * 1e18, debt_) + quoteTokenBalance_;\n\n            claimable_ -= Maths.min(\n                claimable_,\n                // require 1.0 + 1e-9 deposit buffer (extra margin) for deposits\n                Maths.wmul(DEPOSIT_BUFFER, poolSize_) + guaranteedFunds\n            );\n\n            // incremental claimable reserve should not exceed excess quote in pool\n            claimable_ = Maths.min(\n                claimable_,\n                quoteTokenBalance_ - guaranteedFunds\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculates reserves auction price.\n     *  @param  reserveAuctionKicked_ Time when reserve auction was started (kicked).\n     *  @return price_                Calculated auction price.\n     */     \n    function _reserveAuctionPrice(\n        uint256 reserveAuctionKicked_\n    ) view returns (uint256 price_) {\n        if (reserveAuctionKicked_ != 0) {\n            uint256 secondsElapsed   = block.timestamp - reserveAuctionKicked_;\n            uint256 hoursComponent   = 1e27 >> secondsElapsed / 3600;\n            uint256 minutesComponent = Maths.rpow(MINUTE_HALF_LIFE, secondsElapsed % 3600 / 60);\n\n            price_ = Maths.rayToWad(1_000_000_000 * Maths.rmul(hoursComponent, minutesComponent));\n        }\n    }\n\n    /*************************/\n    /*** Auction Utilities ***/\n    /*************************/\n\n    /**\n     *  @notice Calculates auction price.\n     *  @param  referencePrice_ Recorded at kick, used to calculate start price.\n     *  @param  kickTime_       Time when auction was kicked.\n     *  @return price_          Calculated auction price.\n     */\n    function _auctionPrice(\n        uint256 referencePrice_,\n        uint256 kickTime_\n    ) view returns (uint256 price_) {\n        uint256 elapsedMinutes = Maths.wdiv((block.timestamp - kickTime_) * 1e18, 1 minutes * 1e18);\n\n        int256 timeAdjustment;\n        if (elapsedMinutes < 120 * 1e18) {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256(elapsedMinutes / 20));\n            price_ = 256 * Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment)));\n        } else if (elapsedMinutes < 840 * 1e18) {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256((elapsedMinutes - 120 * 1e18) / 120));\n            price_ = 4 * Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment)));\n        } else {\n            timeAdjustment = PRBMathSD59x18.mul(-1 * 1e18, int256((elapsedMinutes - 840 * 1e18) / 60));\n            price_ = Maths.wmul(referencePrice_, uint256(PRBMathSD59x18.exp2(timeAdjustment))) / 16;\n        }\n    }\n\n    /**\n     *  @notice Calculates bond penalty factor.\n     *  @dev    Called in kick and take.\n     *  @param debt_         Borrower debt.\n     *  @param collateral_   Borrower collateral.\n     *  @param neutralPrice_ `NP` of auction.\n     *  @param bondFactor_   Factor used to determine bondSize.\n     *  @param auctionPrice_ Auction price at the time of call.\n     *  @return bpf_         Factor used in determining bond `reward` (positive) or `penalty` (negative).\n     */\n    function _bpf(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 neutralPrice_,\n        uint256 bondFactor_,\n        uint256 auctionPrice_\n    ) pure returns (int256) {\n        int256 thresholdPrice = int256(Maths.wdiv(debt_, collateral_));\n\n        int256 sign;\n        if (thresholdPrice < int256(neutralPrice_)) {\n            // BPF = BondFactor * min(1, max(-1, (neutralPrice - price) / (neutralPrice - thresholdPrice)))\n            sign = Maths.minInt(\n                1e18,\n                Maths.maxInt(\n                    -1 * 1e18,\n                    PRBMathSD59x18.div(\n                        int256(neutralPrice_) - int256(auctionPrice_),\n                        int256(neutralPrice_) - thresholdPrice\n                    )\n                )\n            );\n        } else {\n            int256 val = int256(neutralPrice_) - int256(auctionPrice_);\n            if (val < 0 )      sign = -1e18;\n            else if (val != 0) sign = 1e18;\n        }\n\n        return PRBMathSD59x18.mul(int256(bondFactor_), sign);\n    }\n\n    /**\n     *  @notice Calculates bond parameters of an auction.\n     *  @param  borrowerDebt_   Borrower's debt before entering in liquidation.\n     *  @param  npTpRatio_      Borrower's Np to Tp ratio\n     */\n    function _bondParams(\n        uint256 borrowerDebt_,\n        uint256 npTpRatio_\n    ) pure returns (uint256 bondFactor_, uint256 bondSize_) {\n        // bondFactor = min((NP-to-TP-ratio - 1)/10, 0.03)\n        bondFactor_ = Maths.min(\n            0.03 * 1e18,\n            (npTpRatio_ - 1e18) / 10\n        );\n\n        bondSize_ = Maths.wmul(bondFactor_,  borrowerDebt_);\n    }"
    },
    {
      "filename": "ajna-core/src/libraries/helpers/PoolHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\nimport { Math }           from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport { Buckets } from '../internal/Buckets.sol';\nimport { Maths }   from '../internal/Maths.sol';\n\n    error BucketIndexOutOfBounds();\n    error BucketPriceOutOfBounds();\n\n    /*************************/\n    /*** Price Conversions ***/\n    /*************************/\n\n    /// @dev constant price indices defining the min and max of the potential price range\n    int256  constant MAX_BUCKET_INDEX  =  4_156;\n    int256  constant MIN_BUCKET_INDEX  = -3_232;\n    uint256 constant MAX_FENWICK_INDEX =  7_388;\n\n    uint256 constant MIN_PRICE = 99_836_282_890;\n    uint256 constant MAX_PRICE = 1_004_968_987.606512354182109771 * 1e18;\n\n    uint256 constant MAX_INFLATED_PRICE = 50_248_449_380.325617709105488550 * 1e18; // 50 * MAX_PRICE\n\n    /// @dev deposit buffer (extra margin) used for calculating reserves\n    uint256 constant DEPOSIT_BUFFER = 1.000000001 * 1e18;\n\n    /// @dev step amounts in basis points. This is a constant across pools at `0.005`, achieved by dividing `WAD` by `10,000`\n    int256 constant FLOAT_STEP_INT = 1.005 * 1e18;\n\n    /**\n     *  @notice Calculates the price (`WAD` precision) for a given `Fenwick` index.\n     *  @dev    Reverts with `BucketIndexOutOfBounds` if index exceeds maximum constant.\n     *  @dev    Uses fixed-point math to get around lack of floating point numbers in `EVM`.\n     *  @dev    Fenwick index is converted to bucket index.\n     *  @dev    Fenwick index to bucket index conversion:\n     *  @dev      `1.00`      : bucket index `0`,     fenwick index `4156`: `7388-4156-3232=0`.\n     *  @dev      `MAX_PRICE` : bucket index `4156`,  fenwick index `0`:    `7388-0-3232=4156`.\n     *  @dev      `MIN_PRICE` : bucket index - `3232`, fenwick index `7388`: `7388-7388-3232=-3232`.\n     *  @dev    `V1`: `price = MIN_PRICE + (FLOAT_STEP * index)`\n     *  @dev    `V2`: `price = MAX_PRICE * (FLOAT_STEP ** (abs(int256(index - MAX_PRICE_INDEX))));`\n     *  @dev    `V3 (final)`: `x^y = 2^(y*log_2(x))`\n     */\n    function _priceAt(\n        uint256 index_\n    ) pure returns (uint256) {\n        // Lowest Fenwick index is highest price, so invert the index and offset by highest bucket index.\n        int256 bucketIndex = MAX_BUCKET_INDEX - int256(index_);\n        if (bucketIndex < MIN_BUCKET_INDEX || bucketIndex > MAX_BUCKET_INDEX) revert BucketIndexOutOfBounds();\n\n        return uint256(\n            PRBMathSD59x18.exp2(\n                PRBMathSD59x18.mul(\n                    PRBMathSD59x18.fromInt(bucketIndex),\n                    PRBMathSD59x18.log2(FLOAT_STEP_INT)\n                )\n            )\n        );\n    }\n\n    /**\n     *  @notice Calculates the  Fenwick  index for a given price.\n     *  @dev    Reverts with `BucketPriceOutOfBounds` if price exceeds maximum constant.\n     *  @dev    Price expected to be inputted as a `WAD` (`18` decimal).\n     *  @dev    `V1`: `bucket index = (price - MIN_PRICE) / FLOAT_STEP`\n     *  @dev    `V2`: `bucket index = (log(FLOAT_STEP) * price) /  MAX_PRICE`\n     *  @dev    `V3 (final)`: `bucket index =  log_2(price) / log_2(FLOAT_STEP)`\n     *  @dev    `Fenwick index = 7388 - bucket index + 3232`\n     */\n    function _indexOf(\n        uint256 price_\n    ) pure returns (uint256) {\n        if (price_ < MIN_PRICE || price_ > MAX_PRICE) revert BucketPriceOutOfBounds();\n\n        int256 index = PRBMathSD59x18.div(\n            PRBMathSD59x18.log2(int256(price_)),\n            PRBMathSD59x18.log2(FLOAT_STEP_INT)\n        );\n\n        int256 ceilIndex = PRBMathSD59x18.ceil(index);\n        if (index < 0 && ceilIndex - index > 0.5 * 1e18) {\n            return uint256(4157 - PRBMathSD59x18.toInt(ceilIndex));\n        }\n        return uint256(4156 - PRBMathSD59x18.toInt(ceilIndex));\n    }\n\n    /**********************/\n    /*** Pool Utilities ***/\n    /**********************/\n\n    /**\n     *  @notice Calculates the minimum debt amount that can be borrowed or can remain in a loan in pool.\n     *  @param  debt_          The debt amount to calculate minimum debt amount for.\n     *  @param  loansCount_    The number of loans in pool.\n     *  @return minDebtAmount_ Minimum debt amount value of the pool.\n     */\n    function _minDebtAmount(\n        uint256 debt_,\n        uint256 loansCount_\n    ) pure returns (uint256 minDebtAmount_) {\n        if (loansCount_ != 0) {\n            minDebtAmount_ = Maths.wdiv(Maths.wdiv(debt_, Maths.wad(loansCount_)), 10**19);\n        }\n    }\n\n    /**\n     *  @notice Calculates origination fee for a given interest rate.\n     *  @notice Calculated as greater of the current annualized interest rate divided by `52` (one week of interest) or `5` bps.\n     *  @param  interestRate_ The current interest rate.\n     *  @return Fee rate based upon the given interest rate.\n     */\n    function _borrowFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // greater of the current annualized interest rate divided by 52 (one week of interest) or 5 bps\n        return Maths.max(Maths.wdiv(interestRate_, 52 * 1e18), 0.0005 * 1e18);\n    }\n\n    /**\n     * @notice Calculates the unutilized deposit fee, charged to lenders who deposit below the `LUP`.\n     * @param  interestRate_ The current interest rate.\n     * @return Fee rate based upon the given interest rate, capped at 10%.\n     */\n    function _depositFeeRate(\n        uint256 interestRate_\n    ) pure returns (uint256) {\n        // current annualized rate divided by 365 (24 hours of interest), capped at 10%\n        return Maths.min(Maths.wdiv(interestRate_, 365 * 1e18), 0.1 * 1e18);\n    }\n\n    /**\n     *  @notice Calculates debt-weighted average threshold price.\n     *  @param  t0Debt_              Pool debt owed by borrowers in `t0` terms.\n     *  @param  inflator_            Pool's borrower inflator.\n     *  @param  t0Debt2ToCollateral_ `t0-debt-squared-to-collateral` accumulator. \n     */\n    function _dwatp(\n        uint256 t0Debt_,\n        uint256 inflator_,\n        uint256 t0Debt2ToCollateral_\n    ) pure returns (uint256) {\n        return t0Debt_ == 0 ? 0 : Maths.wdiv(Maths.wmul(inflator_, t0Debt2ToCollateral_), t0Debt_);\n    }\n\n    /**\n     *  @notice Collateralization calculation.\n     *  @param debt_       Debt to calculate collateralization for.\n     *  @param collateral_ Collateral to calculate collateralization for.\n     *  @param price_      Price to calculate collateralization for.\n     *  @param type_       Type of the pool.\n     *  @return `True` if collateralization calculated is equal or greater than `1`.\n     */\n    function _isCollateralized(\n        uint256 debt_,\n        uint256 collateral_,\n        uint256 price_,\n        uint8 type_\n    ) pure returns (bool) {\n        if (type_ == uint8(PoolType.ERC20)) return Maths.wmul(collateral_, price_) >= debt_;\n        else {\n            //slither-disable-next-line divide-before-multiply\n            collateral_ = (collateral_ / Maths.WAD) * Maths.WAD; // use collateral floor\n            return Maths.wmul(collateral_, price_) >= debt_;\n        }\n    }\n\n    /**\n     *  @notice Price precision adjustment used in calculating collateral dust for a bucket.\n     *          To ensure the accuracy of the exchange rate calculation, buckets with smaller prices require\n     *          larger minimum amounts of collateral.  This formula imposes a lower bound independent of token scale.\n     *  @param  bucketIndex_              Index of the bucket, or `0` for encumbered collateral with no bucket affinity.\n     *  @return pricePrecisionAdjustment_ Unscaled integer of the minimum number of decimal places the dust limit requires.\n     */\n    function _getCollateralDustPricePrecisionAdjustment(\n        uint256 bucketIndex_\n    ) pure returns (uint256 pricePrecisionAdjustment_) {\n        // conditional is a gas optimization\n        if (bucketIndex_ > 3900) {\n            int256 bucketOffset = int256(bucketIndex_ - 3900);\n            int256 result = PRBMathSD59x18.sqrt(PRBMathSD59x18.div(bucketOffset * 1e18, int256(36 * 1e18)));\n            pricePrecisionAdjustment_ = uint256(result / 1e18);\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of collateral calculated for the given amount of `LP`.\n     *  @dev    The value returned is capped at collateral amount available in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate collateral for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return collateralAmount_ Amount of collateral calculated for the given `LP `amount.\n     */\n    function _lpToCollateral(\n        uint256 bucketCollateral_,\n        uint256 bucketLP_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 collateralAmount_) {\n        collateralAmount_ = Buckets.lpToCollateral(\n            bucketCollateral_,\n            bucketLP_,\n            deposit_,\n            lenderLPBalance_,\n            bucketPrice_,\n            Math.Rounding.Down\n        );\n\n        if (collateralAmount_ > bucketCollateral_) {\n            // user is owed more collateral than is available in the bucket\n            collateralAmount_ = bucketCollateral_;\n        }\n    }\n\n    /**\n     *  @notice Returns the amount of quote tokens calculated for the given amount of `LP`.\n     *  @dev    The value returned is capped at available bucket deposit.\n     *  @param  bucketLP_         Amount of `LP` in bucket.\n     *  @param  bucketCollateral_ Amount of collateral in bucket.\n     *  @param  deposit_          Current bucket deposit (quote tokens). Used to calculate bucket's exchange rate / `LP`.\n     *  @param  lenderLPBalance_  The amount of `LP` to calculate quote token amount for.\n     *  @param  maxQuoteToken_    The max quote token amount to calculate `LP` for.\n     *  @param  bucketPrice_      Bucket's price.\n     *  @return quoteTokenAmount_ Amount of quote tokens calculated for the given `LP` amount, capped at available bucket deposit.\n     */\n    function _lpToQuoteToken(\n        uint256 bucketLP_,\n        uint256 bucketCollateral_,\n        uint256 deposit_,\n        uint256 lenderLPBalance_,\n        uint256 maxQuoteToken_,\n        uint256 bucketPrice_\n    ) pure returns (uint256 quoteTokenAmount_) {\n        quoteTokenAmount_ = Buckets.lpToQuoteTokens(\n            bucketCollateral_,\n            bucketLP_,\n            deposit_,\n            lenderLPBalance_,\n            bucketPrice_,\n            Math.Rounding.Down\n        );\n\n        if (quoteTokenAmount_ > deposit_)       quoteTokenAmount_ = deposit_;\n        if (quoteTokenAmount_ > maxQuoteToken_) quoteTokenAmount_ = maxQuoteToken_;\n    }\n\n    /**\n     *  @notice Rounds a token amount down to the minimum amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        scaledAmount_ = (amount_ / tokenScale_) * tokenScale_;\n    }\n\n    /**\n     *  @notice Rounds a token amount up to the next amount permissible by the token scale.\n     *  @param  amount_       Value to be rounded.\n     *  @param  tokenScale_   Scale of the token, presented as a power of `10`.\n     *  @return scaledAmount_ Rounded value.\n     */\n    function _roundUpToScale(\n        uint256 amount_,\n        uint256 tokenScale_\n    ) pure returns (uint256 scaledAmount_) {\n        if (amount_ % tokenScale_ == 0)\n            scaledAmount_ = amount_;\n        else\n            scaledAmount_ = _roundToScale(amount_, tokenScale_) + tokenScale_;\n    }\n\n    /*********************************/\n    /*** Reserve Auction Utilities ***/\n    /*********************************/\n\n    uint256 constant MINUTE_HALF_LIFE    = 0.988514020352896135_356867505 * 1e27;  // 0.5^(1/60)\n\n    /**\n     *  @notice Calculates claimable reserves within the pool.\n     *  @dev    Claimable reserve auctions and escrowed auction bonds are guaranteed by the pool.\n     *  @param  debt_                    Pool's debt.\n     *  @param  poolSize_                Pool's deposit size.\n     *  @param  totalBondEscrowed_       Total bond escrowed.\n     *  @param  reserveAuctionUnclaimed_ Pool's unclaimed reserve auction.\n     *  @param  quoteTokenBalance_       Pool's quote token balance.\n     *  @return claimable_               Calculated pool reserves.\n     */  \n    function _claimableReserves(\n        uint256 debt_,\n        uint256 poolSize_,\n        uint256 totalBondEscrowed_,\n        uint256 reserveAuctionUnclaimed_,\n        uint256 quoteTokenBalance_\n    ) pure returns (uint256 claimable_) {\n        uint256 guaranteedFunds = totalBondEscrowed_ + reserveAuctionUnclaimed_;\n\n        // calculate claimable reserves if there's quote token excess\n        if (quoteTokenBalance_ > guaranteedFunds) {\n            claimable_ = Maths.wmul(0.995 * 1e18, debt_) + quoteTokenBalance_;\n\n            claimable_ -= Maths.min(\n                claimable_,\n                // require 1.0 + 1e-9 deposit buffer (extra margin) for deposits\n                Maths.wmul(DEPOSIT_BUFFER, poolSize_) + guaranteedFunds\n            );\n\n            // incremental claimable reserve should not exceed excess quote in pool\n            claimable_ = Maths.min(\n                claimable_,\n                quoteTokenBalance_ - guaranteedFunds\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculates reserves auction price.\n     *  @param  reserveAuctionKicked_ Time when reserve auction was started (kicked).\n     *  @return price_                Calculated auction price.\n     */     \n    function _reserveAuctionPrice(\n        uint256 reserveAuctionKicked_\n    ) view returns (uint256 price_) {\n        if (reserveAuctionKicked_ != 0) {\n            uint256 secondsElapsed   = block.timestamp - reserveAuctionKicked_;\n            uint256 hoursComponent   = 1e27 >> secondsElapsed / 3600;\n            uint256 minutesComponent = Maths.rpow(MINUTE_HALF_LIFE, secondsElapsed % 3600 / 60);\n\n            price_ = Ma"
    }
  ]
}