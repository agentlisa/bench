{
  "Title": "[M-12] changeTokenOf makes it impossible for holders of oldToken to redeem the overflowed assets.",
  "Content": "# Lines of code\n\nhttps://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L588-L606\n\n\n# Vulnerability details\n\n## Impact\nWhen the owner calls the changeTokenOf function of the JBController contract, the token corresponding to the current project will be changed, which will make the oldToken holder unable to redeem the overflowing assets.\n## Proof of Concept\nhttps://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L588-L606\nhttps://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L236-L269\n## Tools Used\nNone\n## Recommended Mitigation Steps\nConsider adding a delay to changeTokenOf, or adding a function to convert oldToken to newToken\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
  "Code": [
    {
      "filename": "contracts/JBController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBMigratable.sol';\nimport './interfaces/IJBOperatorStore.sol';\nimport './interfaces/IJBPaymentTerminal.sol';\nimport './interfaces/IJBProjects.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\nimport './libraries/JBOperations.sol';\nimport './libraries/JBSplitsGroups.sol';\n\n/**\n  @notice\n  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.\n\n  @dev\n  Adheres to -\n  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.\n  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.\n\n  @dev\n  Inherits from -\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\n  ERC165: Introspection on interface adherance. \n*/\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n\n  //*********************************************************************//\n  // --------------------- internal stored properties ------------------ //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.\n\n    _projectId The ID of the project to get the tracker of.\n  */\n  mapping(uint256 => int256) internal _processedTokenTrackerOf;\n\n  /**\n    @notice\n    Data regarding the distribution limit of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of token that a project can distribute per funding cycle.\n\n    @dev\n    bits 232-255: The currency of amount that a project can distribute.\n\n    _projectId The ID of the project to get the packed distribution limit data of.\n    _configuration The configuration during which the packed distribution limit data applies.\n    _terminal The terminal from which distributions are being limited.\n    _token The token for which distributions are being limited.\n  */\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\n    internal _packedDistributionLimitDataOf;\n\n  /**\n    @notice\n    Data regarding the overflow allowance of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n\n    @dev\n    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n\n    _projectId The ID of the project to get the packed overflow allowance data of.\n    _configuration The configuration during which the packed overflow allowance data applies.\n    _terminal The terminal managing the overflow.\n    _token The token for which overflow is being allowed.\n  */\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n  //*********************************************************************//\n  // --------------- public immutable stored properties ---------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Mints ERC-721's that represent project ownership.\n  */\n  IJBProjects public immutable override projects;\n\n  /**\n    @notice\n    The contract storing all funding cycle configurations.\n  */\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /**\n    @notice\n    The contract that manages token minting and burning.\n  */\n  IJBTokenStore public immutable override tokenStore;\n\n  /**\n    @notice\n    The contract that stores splits for each project.\n  */\n  IJBSplitsStore public immutable override splitsStore;\n\n  /**\n    @notice\n    The directory of terminals and controllers for projects.\n  */\n  IJBDirectory public immutable override directory;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the distribution limit of.\n    @param _configuration The configuration during which the distribution limit applies.\n    @param _terminal The terminal from which distributions are being limited.\n    @param _token The token for which the distribution limit applies.\n\n    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the distribution limit.\n  */\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data >> 232);\n  }\n\n  /**\n    @notice\n    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the overflow allowance of.\n    @param _configuration The configuration of the during which the allowance applies.\n    @param _terminal The terminal managing the overflow.\n    @param _token The token for which the overflow allowance applies.\n\n    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the overflow allowance.\n  */\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data >> 232);\n  }\n\n  /**\n    @notice\n    Gets the amount of reserved tokens that a project has available to distribute.\n\n    @param _projectId The ID of the project to get a reserved token balance of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current amount of reserved tokens.\n  */\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n  /**\n    @notice\n    Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n\n    @param _projectId The ID of the project to get total outstanding tokens of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current total amount of outstanding tokens for the project.\n  */\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  /** \n    @notice\n    A project's funding cycle for the specified configuration along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The funding cycle.\n    @return metadata The funding cycle's metadata.\n  */\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /** \n    @notice\n    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The latest configured funding cycle.\n    @return metadata The latest configured funding cycle's metadata.\n    @return ballotState The state of the configuration.\n  */\n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /** \n    @notice\n    A project's current funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The current funding cycle.\n    @return metadata The current funding cycle's metadata.\n  */\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /** \n    @notice\n    A project's queued funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The queued funding cycle.\n    @return metadata The queued funding cycle's metadata.\n  */\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  */\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //*********************************************************************//\n  // ---------------------------- constructor -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _tokenStore A contract that manages token minting and burning.\n    @param _splitsStore A contract that stores splits for each project.\n  */\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  //*********************************************************************//\n  // --------------------- external transactions ----------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Anyone can deploy a project on an owner's behalf.\n\n    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return projectId The ID of the project.\n  */\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  /**\n    @notice\n    Creates a funding cycle for an already existing project ERC-721.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Only a project owner or operator can launch its funding cycles.\n\n    @param _projectId The ID of the project to launch funding cycles for.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully created.\n  */\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /**\n    @notice\n    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.\n\n    @dev\n    Only a project's owner or a designated operator can configure its funding cycles.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  */\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /**\n    @notice\n    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.\n\n    @dev\n    Deploys a project's ERC20 JBToken contract.\n\n    @dev\n    Only a project's owner or operator can issue its token.\n\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC20's name.\n    @param _symbol The ERC20's symbol.\n  */\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n  /**\n    @notice\n    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.\n\n    @dev\n    Only a project's owner or operator can change its token.\n\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token.\n    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.\n  */\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n  /**\n    @notice\n    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.\n\n    @dev\n    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n\n    @param _projectId The ID of the project to which the tokens being minted belong.\n    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n    @param _beneficiary The account that the tokens are being minted for.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.\n    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.\n\n    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  */\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n\n    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.\n    {\n      // Get a reference to the project's current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &&\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n\n      if (_reservedRate == 0)\n        // If there's no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n\n  /**\n    @notice\n    Burns a token holder's supply.\n\n    @dev\n    Only a token's holder, a designated operator, or a project's terminal can burn it.\n\n    @param _holder The account that is having its tokens burned.\n    @param _projectId The ID of the project to which the tokens being burned belong.\n    @param _tokenCount The number of tokens to burn.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.\n  */\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &&\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n\n  /**\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return The amount of minted reserved tokens.\n  */\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n\n  /**\n    @notice\n    Allows other controllers to signal to this one that a migration is expected for the specified project.\n\n    @dev\n    This controller should not yet be the project's controller.\n\n    @param _projectId The ID of the project that will be migrated to this controller.\n    @param _from The controller being migrated from.\n  */\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project's current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n\n  /**\n    @notice\n    Allows a project to migrate from this controller to another.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project that will be migrated from this controller.\n    @param _to The controller to which the project is migrating.\n  */\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project's current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, '');\n\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n\n  //*********************************************************************//\n  // ------------------------ internal functions ----------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return tokenCount The amount of minted reserved tokens.\n  */\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to new total supply of tokens before minting res"
    }
  ]
}