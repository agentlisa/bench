{
  "Title": "[M-17] Missing checks allow strategists to steal all fund via tailOff",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L533-L563\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L343-L369\n\n\n# Vulnerability details\n\n## Impact\nStrategists can call `tailOff` with malicious payload to steal all funds within any BathToken.\n\nThere are 2 issues that makes this possible:\n- `BathPair.tailOff` allows arbitrary `_stratUtil` address.\n- `BathToken.rebalance` allows underlying token as `filledAssetToRebalance`.\n\nThese allow malicious strategists to input any token address, including the underlying token of a BathToken, and transfer them to a contract of their choosing.\n\n## Proof of Concept\nA malicious strategist calls `tailOff` with the following payload:\n```\n{\n    targetPool: bathUSDC.address,\n    tokenToHandle: USDC.address,\n    targetToken: USDT.address, // any address\n    _stratUtil: maliciousContract.address,\n    amount: USDC.balanceOf(bathUSDC.address),\n    hurdle: 0, // any\n    _poolFee: 0 // any\n}\n```\n`bathUSDC` BathToken will then send all USDC to the strategist's `maliciousContract`. All deposits are lost.\n\n## Recommended Mitigation Steps\n- Whitelist the addresses that can be used as `_stratUtil`.\n- Add a check in `rebalance` to prevent transferring underlying token:\n    ```\n    require(filledAssetToRebalance != underlyingToken, \"must not be underlying\");\n    ```\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/rubiconPools/BathPair.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract allows a strategist to use user funds in order to market make for a Rubicon pair\n/// @notice The BathPair is the admin for the pair's liquidity and has many security checks in place\n/// @notice This contract is also where strategists claim rewards for successful market making\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IStrategistUtility.sol\";\n\ncontract BathPair {\n    /// *** Libraries ***\n    using SafeMath for uint256;\n    using SafeMath for uint16;\n\n    /// *** Storage Variables ***\n\n    /// @notice The Bath House admin of this contract; used with onlyBathHouse()\n    address public bathHouse;\n\n    /// @notice The Rubicon Market strategists direct all activity towards. There is only one market, RubiconMarket.sol, in the Rubicon Protocol\n    address public RubiconMarketAddress;\n\n    /// @notice The initialization status of BathPair\n    bool public initialized;\n\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    int128 internal deprecatedStorageVarKept420Proxy;\n\n    /// @notice Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256 public deprecatedStorageVarKept4Proxy;\n\n    /// @dev The id of the last StrategistTrade made by any strategist on this contract\n    /// @dev This value is globally unique, and increments with every trade\n    uint256 internal last_stratTrade_id;\n\n    /// @notice The total amount of successful offer fills that all strategists have made for a given asset\n    mapping(address => uint256) public totalFillsPerAsset;\n\n    /// @notice Unique id => StrategistTrade created in marketMaking call\n    mapping(uint256 => StrategistTrade) public strategistTrades;\n\n    /// @notice Map a strategist to their outstanding order IDs\n    mapping(address => mapping(address => mapping(address => uint256[])))\n        public outOffersByStrategist;\n\n    /// @notice Tracks the market-kaing fill amounts on a per-asset basis of a strategist\n    /// @dev strategist => erc20asset => fill amount per asset;\n    mapping(address => mapping(address => uint256)) public strategist2Fills;\n\n    /// *** Structs ***\n\n    struct order {\n        uint256 pay_amt;\n        IERC20 pay_gem;\n        uint256 buy_amt;\n        IERC20 buy_gem;\n    }\n\n    struct StrategistTrade {\n        uint256 askId;\n        uint256 askPayAmt;\n        address askAsset;\n        uint256 bidId;\n        uint256 bidPayAmt;\n        address bidAsset;\n        address strategist;\n        uint256 timestamp;\n    }\n\n    /// *** Events ***\n\n    /// @notice Log a new market-making trade placed by a strategist, resulting in a StrategitTrade\n    event LogStrategistTrade(\n        uint256 strategistTradeID,\n        bytes32 askId,\n        bytes32 bidId,\n        address askAsset,\n        address bidAsset,\n        uint256 timestamp,\n        address strategist\n    );\n\n    /// @notice Logs the cancellation of a StrategistTrade\n    event LogScrubbedStratTrade(\n        uint256 strategistIDScrubbed,\n        uint256 assetFill,\n        address assetAddress,\n        address bathAssetAddress,\n        uint256 quoteFill,\n        address quoteAddress,\n        address bathQuoteAddress\n    );\n\n    /// @notice Log when a strategist claims their market-making rewards (effectively a rebate for good performance)\n    event LogStrategistRewardClaim(\n        address strategist,\n        address asset,\n        uint256 amountOfReward,\n        uint256 timestamp\n    );\n\n    /// *** External Functions ***\n\n    /// @notice Constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage\n    function initialize(uint256 _maxOrderSizeBPS, int128 _shapeCoefNum)\n        external\n    {\n        require(!initialized);\n        address _bathHouse = msg.sender; //Assume the initializer is BathHouse\n        require(\n            IBathHouse(_bathHouse).getMarket() !=\n                address(0x0000000000000000000000000000000000000000) &&\n                IBathHouse(_bathHouse).initialized(),\n            \"BathHouse not initialized\"\n        );\n        bathHouse = _bathHouse;\n\n        RubiconMarketAddress = IBathHouse(_bathHouse).getMarket();\n\n        // Shape variables for dynamic inventory management\n        /// *** DEprecate but keep storage variable on OP\n        deprecatedStorageVarKept4Proxy = _maxOrderSizeBPS;\n\n        /// @dev A deprecated storage variable! Turns out order books are elegant and complex math is simply computed off-chain, and priced in on-chain orders at the speed of Ethereum L2s!\n        deprecatedStorageVarKept420Proxy = _shapeCoefNum;\n\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyBathHouse() {\n        require(msg.sender == bathHouse);\n        _;\n    }\n\n    modifier onlyApprovedStrategist(address targetStrategist) {\n        require(\n            IBathHouse(bathHouse).isApprovedStrategist(targetStrategist) ==\n                true,\n            \"you are not an approved strategist - bathPair\"\n        );\n        _;\n    }\n\n    // *** Internal Functions ***\n\n    /// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n    /// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 - reserveRatio in practice assuming strategists use all available liquidity.\n    function enforceReserveRatio(\n        address underlyingAsset,\n        address underlyingQuote\n    )\n        internal\n        view\n        returns (address bathAssetAddress, address bathQuoteAddress)\n    {\n        bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingAsset\n        );\n        bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingQuote\n        );\n        require(\n            (\n                IBathToken(bathAssetAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n            \"Failed to meet asset pool reserve ratio\"\n        );\n        require(\n            (\n                IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n            \"Failed to meet quote pool reserve ratio\"\n        );\n    }\n\n    /// @notice Log whenever a strategist rebalances a fill amount and log the amount while incrementing total fills for that specific asset\n    /// @dev Only log fills for each strategist in an asset specific manner\n    /// @dev Goal is to map a strategist to a fill\n    function logFill(\n        uint256 amt,\n        address strategist,\n        address asset\n    ) internal {\n        strategist2Fills[strategist][asset] += amt;\n        totalFillsPerAsset[asset] += amt;\n    }\n\n    /// @notice Internal function to provide the next unique StrategistTrade ID\n    function _next_id() internal returns (uint256) {\n        last_stratTrade_id++;\n        return last_stratTrade_id;\n    }\n\n    /// @notice This function results in the removal of the Strategist Trade (bid and/or ask on Rubicon Market) from the books and it being deleted from the contract\n    /// @dev The local array of strategist IDs that exists for any given strategist [query via getOutstandingStrategistTrades()] acts as an acitve RAM for outstanding strategist trades\n    /// @dev Cancels outstanding orders and manages the ledger of outstandingAmount() on bathTokens as Strategist Trades are cancelled/scrubbed or expired\n    function handleStratOrderAtID(uint256 id) internal {\n        StrategistTrade memory info = strategistTrades[id];\n        address _asset = info.askAsset;\n        address _quote = info.bidAsset;\n\n        address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _asset\n        );\n        address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _quote\n        );\n        order memory offer1 = getOfferInfo(info.askId); //ask\n        order memory offer2 = getOfferInfo(info.bidId); //bid\n        uint256 askDelta = info.askPayAmt - offer1.pay_amt;\n        uint256 bidDelta = info.bidPayAmt - offer2.pay_amt;\n\n        // if real\n        if (info.askId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (askDelta > 0) {\n                logFill(askDelta, info.strategist, info.askAsset);\n                IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);\n                // not a full fill\n                if (askDelta != info.askPayAmt) {\n                    IBathToken(bathAssetAddress).cancel(\n                        info.askId,\n                        info.askPayAmt.sub(askDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too\n            }\n        }\n\n        // if real\n        if (info.bidId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (bidDelta > 0) {\n                logFill(bidDelta, info.strategist, info.bidAsset);\n                IBathToken(bathQuoteAddress).removeFilledTradeAmount(bidDelta);\n                // not a full fill\n                if (bidDelta != info.bidPayAmt) {\n                    IBathToken(bathQuoteAddress).cancel(\n                        info.bidId,\n                        info.bidPayAmt.sub(bidDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathQuoteAddress).cancel(info.bidId, info.bidPayAmt); // pass amount too\n            }\n        }\n\n        // Delete the order from outOffersByStrategist\n        uint256 target = getIndexFromElement(\n            id,\n            outOffersByStrategist[_asset][_quote][info.strategist]\n        );\n        uint256[] storage current = outOffersByStrategist[_asset][_quote][\n            info.strategist\n        ];\n        current[target] = current[current.length - 1];\n        current.pop(); // Assign the last value to the value we want to delete and pop, best way to do this in solc AFAIK\n\n        emit LogScrubbedStratTrade(\n            id,\n            askDelta,\n            _asset,\n            bathAssetAddress,\n            bidDelta,\n            _quote,\n            bathQuoteAddress\n        );\n    }\n\n    /// @notice Get information about a Rubicon Market offer and return it as an order\n    function getOfferInfo(uint256 id) internal view returns (order memory) {\n        (\n            uint256 ask_amt,\n            IERC20 ask_gem,\n            uint256 bid_amt,\n            IERC20 bid_gem\n        ) = IRubiconMarket(RubiconMarketAddress).getOffer(id);\n        order memory offerInfo = order(ask_amt, ask_gem, bid_amt, bid_gem);\n        return offerInfo;\n    }\n\n    /// @notice A function that returns the index of uid from array\n    /// @dev uid must be in array for the purposes of this contract to enforce outstanding trades per strategist are tracked correctly\n    function getIndexFromElement(uint256 uid, uint256[] storage array)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        bool assigned = false;\n        for (uint256 index = 0; index < array.length; index++) {\n            if (uid == array[index]) {\n                _index = index;\n                assigned = true;\n                return _index;\n            }\n        }\n        require(assigned, \"Didnt Find that element in live list, cannot scrub\");\n    }\n\n    // *** External Functions - Only Approved Strategists ***\n\n    /// @notice Key entry point for strategists to use Bath Token (LP) funds to place market-making trades on the Rubicon Order Book\n    function placeMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n        // Require at least one order is non-zero\n        require(\n            (askNumerator > 0 && askDenominator > 0) ||\n                (bidNumerator > 0 && bidDenominator > 0),\n            \"one order must be non-zero\"\n        );\n\n        address _underlyingAsset = tokenPair[0];\n        address _underlyingQuote = tokenPair[1];\n\n        (\n            address bathAssetAddress,\n            address bathQuoteAddress\n        ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n        require(\n            bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // Calculate new bid and/or ask\n        order memory ask = order(\n            askNumerator,\n            IERC20(_underlyingAsset),\n            askDenominator,\n            IERC20(_underlyingQuote)\n        );\n        order memory bid = order(\n            bidNumerator,\n            IERC20(_underlyingQuote),\n            bidDenominator,\n            IERC20(_underlyingAsset)\n        );\n\n        // Place new bid and/or ask\n        // Note: placeOffer returns a zero if an incomplete order\n        uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n            ask.pay_amt,\n            ask.pay_gem,\n            ask.buy_amt,\n            ask.buy_gem\n        );\n\n        uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n            bid.pay_amt,\n            bid.pay_gem,\n            bid.buy_amt,\n            bid.buy_gem\n        );\n\n        // Strategist trade is recorded so they can get paid and the trade is logged for time\n        StrategistTrade memory outgoing = StrategistTrade(\n            newAskID,\n            ask.pay_amt,\n            _underlyingAsset,\n            newBidID,\n            bid.pay_amt,\n            _underlyingQuote,\n            msg.sender,\n            block.timestamp\n        );\n\n        // Give each trade a unique id for easy handling by strategists\n        id = _next_id();\n        strategistTrades[id] = outgoing;\n        // Allow strategists to easily call a list of their outstanding offers\n        outOffersByStrategist[_underlyingAsset][_underlyingQuote][msg.sender]\n            .push(id);\n\n        emit LogStrategistTrade(\n            id,\n            bytes32(outgoing.askId),\n            bytes32(outgoing.bidId),\n            outgoing.askAsset,\n            outgoing.bidAsset,\n            block.timestamp,\n            outgoing.strategist\n        );\n    }\n\n    /// @notice A function to batch together many placeMarketMakingTrades() in a single transaction\n    function batchMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length,\n            \"not all order lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            placeMarketMakingTrades(\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice A function to requote an outstanding order and replace it with a new Strategist Trade\n    /// @dev Note that this function will create a new unique id for the requote'd ID due to the low-level functionality\n    function requote(\n        uint256 id,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) {\n        // 1. Scrub strat trade\n        scrubStrategistTrade(id);\n\n        // 2. Place another\n        placeMarketMakingTrades(\n            tokenPair,\n            askNumerator,\n            askDenominator,\n            bidNumerator,\n            bidDenominator\n        );\n    }\n\n    /// @notice A function to batch together many requote() calls in a single transaction\n    /// @dev Ids and input are indexed through to execute requotes\n    function batchRequoteOffers(\n        uint256[] memory ids,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length &&\n                ids.length == askNumerators.length,\n            \"not all input lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            requote(\n                ids[index],\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice - function to rebalance fill between two pools\n    function rebalancePair(\n        uint256 assetRebalAmt, //amount of ASSET in the quote buffer\n        uint256 quoteRebalAmt, //amount of QUOTE in the asset buffer\n        address _underlyingAsset,\n        address _underlyingQuote\n    ) external onlyApprovedStrategist(msg.sender) {\n        address _bathHouse = bathHouse;\n        address _bathAssetAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingAsset\n        );\n        address _bathQuoteAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingQuote\n        );\n        require(\n            _bathAssetAddress != address(0) && _bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // This should be localized to the bathToken in future versions\n        uint16 stratReward = IBathHouse(_bathHouse).getBPSToStrats();\n\n        // Simply rebalance given amounts\n        if (assetRebalAmt > 0) {\n            IBathToken(_bathQuoteAddress).rebalance(\n                _bathAssetAddress,\n                _underlyingAsset,\n                stratReward,\n                assetRebalAmt\n            );\n        }\n        if (quoteRebalAmt > 0) {\n            IBathToken(_bathAssetAddress).rebalance(\n                _bathQuoteAddress,\n                _underlyingQuote,\n                stratReward,\n                quoteRebalAmt\n            );\n        }\n    }\n\n    /// @notice Function to attempt inventory risk tail off on an AMM\n    /// @dev This function calls the strategist utility which handles the trade and returns funds to LPs\n    function tailOff(\n        address targetPool,\n        address tokenToHandle,\n        address targetToken,\n        address _stratUtil, // delegatecall target\n        uint256 amount, //fill amount to handle\n        uint256 hurdle, //must clear this on tail off\n        uint24 _poolFee\n    ) external onlyApprovedStrategist(msg.sender) {\n        // transfer here\n        uint16 stratRewardBPS = IBathHouse(bathHouse).getBPSToStrats();\n\n        IBathToken(targetPool).rebalance(\n            _stratUtil,\n            tokenToHandle,\n            stratRewardBPS,\n            amount\n        );\n\n        // Should always exceed hurdle given amountOutMinimum\n        IStrategistUtility(_stratUtil).UNIdump(\n            amount.sub((stratRewardBPS.mul(amount)).div(10000)),\n            tokenToHandle,\n            targetToken,\n            hurdle,\n            _poolFee,\n            targetPool\n        );\n    }\n\n    /// @notice Cancel an outstanding strategist offers and return funds to LPs while logging fills\n    function scrubStrategistTrade(uint256 id)\n        public\n        onlyApprovedStrategist(msg.sender)\n    {\n        require(\n            msg.sender == strategistTrades[id].strategist,\n            \"you are not the strategist that made this order\"\n        );\n        handleStratOrderAtID(id);\n    }\n\n    /// @notice Batch scrub outstanding strategist trades and return funds to LPs\n    function scrubStrategistTrades(uint256[] memory ids)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        for (uint256 index = 0; index < ids.length; index++) {\n            uint256 _id = ids[index];\n            scrubStrategistTrade(_id);\n        }\n    }\n\n    /// @notice Function where strategists claim rewards proportional to their quantity of fills\n    /// @dev This function should allow a strategist to claim ERC20s sitting on this contract (earned via rebalancing) relative to their share or strategist activity on the pair\n    /// @dev Provide the pair on which you want to claim rewards\n    function strategistBootyClaim(address asset, address quote)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        uint256 fillCountA = strategist2Fills[msg.sender][asset];\n        uint256 fillCountQ = strategist2Fills[msg.sender][quote];\n        if (fillCountA > 0) {\n            uint256 booty = (\n                fillCountA.mul(IERC20(asset).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[asset]);\n            IERC20(asset).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                asset,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[asset] -= fillCountA;\n            strategist2Fills[msg.sender][asset] -= fillCountA;\n        }\n        if (fillCountQ > 0) {\n            uint256 booty = (\n                fillCountQ.mul(IERC20(quote).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[quote]);\n            IERC20(quote).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                quote,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[quote] -= fillCountQ;\n            strategist2Fills[msg.sender][quote] -= fillCountQ;\n        }\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The goal of this function is to enable a means to retrieve all outstanding orders a strategist has live in the books\n    /// @dev This is helpful to manage orders as well as track all strategist orders (like their RAM of StratTrade IDs) and place any would-be constraints on strategists\n    function getOutstandingStrategistTrades(\n        address asset,\n        address quote,\n        address strategist\n    ) public view returns (uint256[] memory) {\n        return outOffersByStrategist[asset][quote][strategist];\n    }\n}"
    },
    {
      "filename": "contracts/rubiconPools/BathToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse"
    }
  ]
}