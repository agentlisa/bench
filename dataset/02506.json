{
  "Title": "H-11: The deposit / withdraw / trade transaction lack of expiration timestamp check and slippage control",
  "Content": "# Issue H-11: The deposit / withdraw / trade transaction lack of expiration timestamp check and slippage control \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/39 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nThe deposit / withdraw / trade transaction lack of expiration timestamp and slippage control\n\n## Vulnerability Detail\n\nLet us look into the heavily forked Uniswap V2 contract addLiquidity function implementation\n\nhttps://github.com/Uniswap/v2-periphery/blob/0335e8f7e1bd1e8d8329fd300aea2ef2f36dd19f/contracts/UniswapV2Router02.sol#L61\n\n```solidity\n// **** ADD LIQUIDITY ****\nfunction _addLiquidity(\n\taddress tokenA,\n\taddress tokenB,\n\tuint amountADesired,\n\tuint amountBDesired,\n\tuint amountAMin,\n\tuint amountBMin\n) internal virtual returns (uint amountA, uint amountB) {\n\t// create the pair if it doesn't exist yet\n\tif (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n\t\tIUniswapV2Factory(factory).createPair(tokenA, tokenB);\n\t}\n\t(uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\tif (reserveA == 0 && reserveB == 0) {\n\t\t(amountA, amountB) = (amountADesired, amountBDesired);\n\t} else {\n\t\tuint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n\t\tif (amountBOptimal <= amountBDesired) {\n\t\t\trequire(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n\t\t\t(amountA, amountB) = (amountADesired, amountBOptimal);\n\t\t} else {\n\t\t\tuint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n\t\t\tassert(amountAOptimal <= amountADesired);\n\t\t\trequire(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n\t\t\t(amountA, amountB) = (amountAOptimal, amountBDesired);\n\t\t}\n\t}\n}\n\nfunction addLiquidity(\n\taddress tokenA,\n\taddress tokenB,\n\tuint amountADesired,\n\tuint amountBDesired,\n\tuint amountAMin,\n\tuint amountBMin,\n\taddress to,\n\tuint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n\t(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\tTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n\tTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n\tliquidity = IUniswapV2Pair(pair).mint(to);\n}\n```\n\nthe implementation has two point that worth noting,\n\n**the first point is the deadline check**\n\n```solidity\nmodifier ensure(uint deadline) {\n\trequire(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n\t_;\n}\n```\n\nThe transaction can be pending in mempool  for a long and the trading activity is very time senstive. Without deadline check, the trade transaction can be executed in a long time after the user submit the transaction, at that time, the trade can be done in a sub-optimal price, which harms user's position.\n\nThe deadline check ensure that the transaction can be executed on time and the expired transaction revert.\n\nthe second point is the slippage control:\n\n```solidity\nrequire(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n```\n\nand\n\n```solidity\nrequire(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n```\n\nthe slippage control the user can receive the least optimal amount of the token they want to trade.\n\nIn the current implementation, neither the deadline check nor the slippage control is in place when user deposit / withdraw / trade.\n\n## Impact\n\nAccording to the whitepaper:\n\n> Deposits in the highest priced buckets offer the highest valuations on collateral, and hence offer\nthe most liquidity to borrowers. They are also the first buckets that could be used to purchase\ncollateral if a loan were to be liquidated (see 7.0 LIQUIDATIONS). We can think of a bucket’s\ndeposit as being utilized if the sum of all deposits in buckets priced higher than it is less than the\ntotal debt of all borrowers in the pool. The lowest price among utilized buckets or “lowest\nutilized price” is called the LUP. If we were to pair off lenders with borrowers, matching the\nhighest priced lenders’ deposits with the borrowers’ debts in equal quantities, the LUP would be\nthe price of the marginal (lowest priced and therefore least aggressive) lender thus matched\n(usually, there would be a surplus of lenders that were not matched, corresponding to less than\n100% utilization of the pool).\n\n> The LUP plays a critical role in Ajna: a borrower who is undercollateralized with respect to the\nLUP (i.e. with respect to the marginal utilized lender) is eligible for liquidation. Conversely, a\nlender cannot withdraw deposit if doing so would move the LUP down so far as to make some\nactive loans eligible for liquidation. In order to withdraw quote token in this situation, the lender\nmust first kick the loans in question.\n\nBecause the deadline check is missing, \n\nAfter a lender submit a transaction and want to add the token into Highest price busket to make sure the quote token can be borrowed out and generate yield.\n\nHowever, the transaction is pending in the mempool for a very long time.\n\nBorrower create more debt and other lender's add and withdraw quote token before the lender's transaction is executed.\n\nAfter a long time later, the lender's transaction is executed.\n\nThe lender find out that the highest priced bucket moved and the lender cannot withdraw his token because doing would move the LUP down eligible for liquidiation.\n\nAccording to the whitepaper:\n\n> 6.1 Trading collateral for quote token\n\n> David owns 1 ETH, and would like to sell it for 1100 DAI. He puts the 1 ETH into the 1100\nbucket as claimable collateral (alongside Carol’s 20000 deposit), minting 1100 in LPB in return.\nHe can then redeem that 1100 LPB for quote token, withdrawing 1100 DAI. Note: after David’s\nwithdrawal, the LUP remains at 1100. If the book were different such that his withdrawal would\nmove the LUP below Bob’s threshold price of 901.73, he would not be able to withdraw all of\nthe DAI.\n\nThe case above is ideal, however, because the deadline check is missing, and there is no slippage control, the transactoin can be pending for a long time and by the time the trade transaction is lended, the withdraw amount can be less than 1100 DAI.\n\nAnother example for lack of slippage, for example, the function below is called:\n\n```solidity\n/// @inheritdoc IPoolLenderActions\nfunction removeQuoteToken(\n\tuint256 maxAmount_,\n\tuint256 index_\n) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLPs_) {\n\t_revertIfAuctionClearable(auctions, loans);\n\n\tPoolState memory poolState = _accruePoolInterest();\n\n\t_revertIfAuctionDebtLocked(deposits, poolBalances, index_, poolState.inflator);\n\n\tuint256 newLup;\n\t(\n\t\tremovedAmount_,\n\t\tredeemedLPs_,\n\t\tnewLup\n\t) = LenderActions.removeQuoteToken(\n\t\tbuckets,\n\t\tdeposits,\n\t\tpoolState,\n\t\tRemoveQuoteParams({\n\t\t\tmaxAmount:      maxAmount_,\n\t\t\tindex:          index_,\n\t\t\tthresholdPrice: Loans.getMax(loans).thresholdPrice\n\t\t})\n\t);\n\n\t// update pool interest rate state\n\t_updateInterestState(poolState, newLup);\n\n\t// move quote token amount from pool to lender\n\t_transferQuoteToken(msg.sender, removedAmount_);\n}\n```\n\nwithout specificing the minReceived amount, the removedAmount can be very small comparing to the maxAmount user speicifced.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L130-L158\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L202\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol add deadline check and add slippage control.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/UniswapV2Router02.sol",
      "content": "pragma solidity =0.6.6;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\n\nimport './interfaces/IUniswapV2Router02.sol';\nimport './libraries/UniswapV2Library.sol';\nimport './libraries/SafeMath.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IWETH.sol';\n\ncontract UniswapV2Router02 is IUniswapV2Router02 {\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    }\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    {\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    {\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }\n}"
    },
    {
      "filename": "contracts/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolLenderActions,\n    IPoolState,\n    IPoolLiquidationActions,\n    IPoolReserveAuctionActions,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    LoansState,\n    InflatorState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    BurnEvent,\n    Liquidation\n}                                    from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams\n}                                    from '../interfaces/pool/commons/IPoolInternals.sol';\nimport { StartReserveAuctionParams } from '../interfaces/pool/commons/IPoolReserveAuctionActions.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { Auctions }        from '../libraries/external/Auctions.sol';\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both ERC20 and ERC721 pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant POOL_TYPE          = 0;\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    mapping(uint256 => Bucket) internal buckets;   // deposit index -> bucket\n\n    bool internal isPoolInitialized;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpTokenAllowances; // owner address -> new owner address -> deposit index -> allowed amount\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n    function quoteTokenDust() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 quoteTokenAmountToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        quoteTokenAmountToAdd_ = _roundToScale(quoteTokenAmountToAdd_, poolState.quoteDustLimit);\n\n        uint256 newLup;\n        (bucketLPs_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: quoteTokenAmountToAdd_,\n                index:  index_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, quoteTokenAmountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev write state:\n     *          - _lpTokenAllowances mapping\n     */\n    function approveLpOwnership(\n        address allowedNewOwner_,\n        uint256 index_,\n        uint256 lpsAmountToApprove_\n    ) external nonReentrant {\n        _lpTokenAllowances[msg.sender][allowedNewOwner_][index_] = lpsAmountToApprove_;\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmountToMove_,\n        uint256 fromIndex_,\n        uint256 toIndex_\n    ) external override nonReentrant returns (uint256 fromBucketLPs_, uint256 toBucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolBalances, fromIndex_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            fromBucketLPs_,\n            toBucketLPs_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            MoveQuoteParams({\n                maxAmountToMove: maxAmountToMove_,\n                fromIndex:       fromIndex_,\n                toIndex:         toIndex_,\n                thresholdPrice:  Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLPs_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolBalances, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLPs_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      maxAmount_,\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function transferLPs(\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LenderActions.transferLPs(\n            buckets,\n            _lpTokenAllowances,\n            owner_,\n            newOwner_,\n            indexes_\n        );\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - increment poolBalances.t0DebtInAuction and poolBalances.t0Debt accumulators\n     */\n    function kick(\n        address borrowerAddress_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = Auctions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_\n        );\n\n        // update pool balances state\n        poolBalances.t0DebtInAuction += result.t0KickedDebt;\n        poolBalances.t0Debt          += result.t0KickPenalty;\n\n        // update pool interest rate state\n        poolState.debt += result.kickPenalty;\n        _updateInterestState(poolState, result.lup);\n\n        if(result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - increment poolBalances.t0DebtInAuction and poolBalances.t0Debt accumulators\n     */\n    function kickWithDeposit(\n        uint256 index_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = Auctions.kickWithDeposit(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          += result.t0KickPenalty;\n        poolBalances.t0DebtInAuction += result.t0KickedDebt;\n\n        // update pool interest rate state\n        poolState.debt += result.kickPenalty;\n        _updateInterestState(poolState, result.lup);\n\n        // transfer from kicker to pool the difference to cover bond\n        if(result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - reset kicker's claimable accumulator\n     */\n    function withdrawBonds() external {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n        auctions.kickers[msg.sender].claimable = 0;\n        _transferQuoteToken(msg.sender, claimable);\n    }\n\n    /*********************************/\n    /*** Reserve Auction Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IPoolReserveAuctionActions\n     *  @dev  write state:\n     *          - increment latestBurnEpoch counter\n     *          - update reserveAuction.latestBurnEventEpoch and burn event timestamp state\n     *  @dev reverts on:\n     *          - 2 weeks not passed ReserveAuctionTooSoon()\n     *  @dev emit events:\n     *          - ReserveAuction\n     */\n    function startClaimableReserveAuction() external override nonReentrant {\n        // retrieve timestamp of latest burn event and last burn timestamp\n        uint256 latestBurnEpoch   = reserveAuction.latestBurnEventEpoch;\n        uint256 lastBurnTimestamp = reserveAuction.burnEvents[latestBurnEpoch].timestamp;\n\n        // check that at least two weeks have passed since the last reserve auction completed, and that the auction was not kicked within the past 72 hours\n        if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction.kicked <= 72 hours) {\n            revert ReserveAuctionTooSoon();\n        }\n\n        // start a new claimable reserve auction, passing in relevant parameters such as the current pool size, debt, balance, and inflator value\n        uint256 kickerAward = Auctions.startClaimableReserveAuction(\n            auctions,\n            reserveAuction,\n            StartReserveAuctionParams({\n                poolSize:    Deposits.treeSum(deposits),\n                poolDebt:    poolBalances.t0Debt,\n                poolBalance: _getPoolQuoteTokenBalance(),\n                inflator:    inflatorState.inflator\n            })\n        );\n\n        // increment latest burn event epoch and update burn event timestamp\n        latestBurnEpoch += 1;\n\n        reserveAuction.latestBurnEventEpoch = latestBurnEpoch;\n        reserveAuction.burnEvents[latestBurnEpoch].timestamp = block.timestamp;\n\n        // transfer kicker award to msg.sender\n        _transferQuoteToken(msg.sender, kickerAward);\n    }\n\n    /**\n     *  @inheritdoc IPoolReserveAuctionActions\n     *  @dev  write state:\n     *          - increment reserveAuction.totalAjnaBurned accumulator\n     *          - update burn event totalInterest and totalBurned accumulators\n     */\n    function takeReserves(\n        uint256 maxAmount_\n    ) external override nonReentrant returns (uint256 amount_) {\n        uint256 ajnaRequired;\n        (amount_, ajnaRequired) = Auctions.takeReserves(\n            reserveAuction,\n            maxAmount_\n        );\n\n        uint256 totalBurned = reserveAuction.totalAjnaBurned + ajnaRequired;\n        \n        // accumulate additional ajna burned\n        reserveAuction.totalAjnaBurned = totalBurned;\n\n        uint256 burnEventEpoch = reserveAuction.latestBurnEventEpoch;\n\n        // record burn event information to enable querying by staking rewards\n        BurnEvent storage burnEvent = reserveAuction.burnEvents[burnEventEpoch];\n        burnEvent.totalInterest = reserveAuction.totalInterestEarned;\n        burnEvent.totalBurned   = totalBurned;\n\n        // burn required number of ajna tokens to take quote from reserves\n        IERC20(_getArgAddress(AJNA_ADDRESS)).safeTransferFrom(msg.sender, address(this), ajnaRequired);\n\n        IERC20Token(_getArgAddress(AJNA_ADDRESS)).burn(ajnaRequired);\n\n        // transfer quote token to caller\n        _transferQuoteToken(msg.sender, amount_);\n    }\n\n    /*****************************/\n    /*** Pool Helper Functions ***/\n    /*****************************/\n\n    /**\n     *  @notice Accrues pool interest in current block and returns pool details.\n     *  @dev    external libraries call:\n     *              - PoolCommons.acc"
    }
  ]
}