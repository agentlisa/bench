{
  "Title": "[H-01] `PostAuctionLauncher.sol#finalize()` Adding liquidity to an existing pool may allows the attacker to steal most of the tokens",
  "Content": "_Submitted by WatchPug, also found by 0xRajeev and cmichel._\n\n`PostAuctionLauncher.finalize()` can be called by anyone, and it sends tokens directly to the pair pool to mint liquidity, even when the pair pool exists.\n\nAn attacker may control the LP price by creating the pool and then call `finalize()` to mint LP token with unfair price (pay huge amounts of tokens and get few amounts of LP token), and then remove the initial liquidity they acquired when creating the pool and take out huge amounts of tokens.\n\n<https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L257>\n\n```solidity\n/**\n * @notice Finalizes Token sale and launches LP.\n * @return liquidity Number of LPs.\n */\nfunction finalize() external nonReentrant returns (uint256 liquidity) {\n    // GP: Can we remove admin, let anyone can finalise and launch?\n    // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n    require(marketConnected(), \"PostAuction: Auction must have this launcher address set as the destination wallet\");\n    require(!launcherInfo.launched);\n\n    if (!market.finalized()) {\n        market.finalize();\n    }\n    require(market.finalized());\n\n    launcherInfo.launched = true;\n    if (!market.auctionSuccessful() ) {\n        return 0;\n    }\n\n    /// @dev if the auction is settled in weth, wrap any contract balance \n    uint256 launcherBalance = address(this).balance;\n    if (launcherBalance > 0 ) {\n        IWETH(weth).deposit{value : launcherBalance}();\n    }\n    \n    (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();\n\n    /// @dev cannot start a liquidity pool with no tokens on either side\n    if (token1Amount == 0 || token2Amount == 0 ) {\n        return 0;\n    }\n\n    address pair = factory.getPair(address(token1), address(token2));\n    if(pair == address(0)) {\n        createPool();\n    }\n\n    /// @dev add liquidity to pool via the pair directly\n    _safeTransfer(address(token1), tokenPair, token1Amount);\n    _safeTransfer(address(token2), tokenPair, token2Amount);\n    liquidity = IUniswapV2Pair(tokenPair).mint(address(this));\n    launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));\n\n    /// @dev if unlock time not yet set, add it.\n    if (launcherInfo.unlock == 0 ) {\n        launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));\n    }\n    emit LiquidityAdded(liquidity);\n}\n```\n\nIn line 257, `PostAuctionLauncher` will mint LP with `token1Amount` and `token2Amount`. The amounts (`token1Amount` and `token2Amount`) are computed according to the auction result, without considering the current price (reserves) of the existing `tokenPair`.\n\nSee [PostAuctionLauncher.getTokenAmounts()](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/Liquidity/PostAuctionLauncher.sol#L268)\n\n`PostAuctionLauncher` will receive an unfairly low amount of lp token because the amounts sent to `tokenPair` didn't match the current price of the pair.\n\nSee [UniswapV2Pair.mint(...)](https://github.com/sushiswap/miso/blob/2cdb1486a55ded55c81898b7be8811cb68cfda9e/contracts/UniswapV2/UniswapV2Pair.sol#L135)\n\n```solidity\nliquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n```\n\n#### Impact\n\nLose a majority share of the tokens.\n\n#### Proof of Concept\n\n1.  The attacker creates LP with 0.0000001 token1 and 1000 token2, receives 0.01 LP token;\n2.  Call `PostAuctionLauncher.finalize()`. PostAuctionLauncher will mint liquidity with 2000 token1 and 1000 token2 for example, receives only  0.01 LP token;\n3.  The attacker removes all his LP, receives 1000 token1 (most of which come from `PostAuctionLauncher`).\n\n#### Recommended Mitigation Steps\n\nTo only support tokenPair created by `PostAuctionLauncher` or check for the token price before mint liquidity.\n\n**[Clearwood (Sushi Miso) confirmed and patched](https://github.com/code-423n4/2021-09-sushimiso-findings/issues/14#issuecomment-934641852):**\n > https://github.com/sushiswap/miso/pull/21\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-09-sushimiso",
  "Code": [
    {
      "filename": "contracts/Liquidity/PostAuctionLauncher.sol",
      "content": "pragma solidity 0.6.12;\n\n\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.\n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'\n//\n//----------------------------------------------------------------------------------\n//\n// Chef Gonpachi's Post Auction Launcher\n//\n// A post auction contract that takes the proceeds and creates a liquidity pool\n//\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n//\n// Made for Sushi.com \n// \n// Enjoy. (c) Chef Gonpachi\n// <https://github.com/chefgonpachi/MISO/>\n//\n// ---------------------------------------------------------------------\n// SPDX-License-Identifier: GPL-3.0                        \n// ---------------------------------------------------------------------\n\nimport \"../OpenZeppelin/utils/ReentrancyGuard.sol\";\nimport \"../Access/MISOAccessControls.sol\";\nimport \"../Utils/SafeTransfer.sol\";\nimport \"../Utils/BoringMath.sol\";\nimport \"../UniswapV2/UniswapV2Library.sol\";\nimport \"../UniswapV2/interfaces/IUniswapV2Pair.sol\";\nimport \"../UniswapV2/interfaces/IUniswapV2Factory.sol\";\nimport \"../interfaces/IWETH9.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IMisoAuction.sol\";\n\n\n\ncontract PostAuctionLauncher is MISOAccessControls, SafeTransfer, ReentrancyGuard {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n    using BoringMath32 for uint32;\n    using BoringMath16 for uint16;\n\n\n    /// @notice Number of seconds per day.\n    uint256 private constant SECONDS_PER_DAY = 24 * 60 * 60;\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant LIQUIDITY_PRECISION = 10000;\n    \n    /// @notice MISOLiquidity template id.\n    uint256 public constant liquidityTemplate = 3;\n\n    /// @notice First Token address.\n    IERC20 public token1;\n    /// @notice Second Token address.\n    IERC20 public token2;\n    /// @notice Uniswap V2 factory address.\n    IUniswapV2Factory public factory;\n    /// @notice WETH contract address.\n    address private immutable weth;\n\n\n    /// @notice LP pair address.\n    address public tokenPair;\n    /// @notice Withdraw wallet address.\n    address public wallet;\n    /// @notice Token market contract address.\n    IMisoAuction public market;\n\n    struct LauncherInfo {\n        uint32 locktime;\n        uint64 unlock;\n        uint16 liquidityPercent;\n        bool launched;\n        uint128 liquidityAdded;\n    }\n    LauncherInfo public launcherInfo;\n\n    /// @notice Emitted when LP contract is initialised.\n    event InitLiquidityLauncher(address indexed token1, address indexed token2, address factory, address sender);\n    /// @notice Emitted when LP is launched.\n    event LiquidityAdded(uint256 liquidity);\n    /// @notice Emitted when wallet is updated.\n    event WalletUpdated(address indexed wallet);\n    /// @notice Emitted when launcher is cancelled.\n    event LauncherCancelled(address indexed wallet);\n\n    constructor (address _weth) public {\n        weth = _weth;\n    }\n\n\n    /**\n     * @notice Initializes main contract variables (requires launchwindow to be more than 2 days.)\n     * @param _market Auction address for launcher.\n     * @param _factory Uniswap V2 factory address.\n     * @param _admin Contract owner address.\n     * @param _wallet Withdraw wallet address.\n     * @param _liquidityPercent Percentage of payment currency sent to liquidity pool.\n     * @param _locktime How long the liquidity will be locked. Number of seconds.\n     */\n    function initAuctionLauncher(\n            address _market,\n            address _factory,\n            address _admin,\n            address _wallet,\n            uint256 _liquidityPercent,\n            uint256 _locktime\n    )\n        public\n    {\n        require(_locktime < 10000000000, 'PostAuction: Enter an unix timestamp in seconds, not miliseconds');\n        require(_liquidityPercent <= LIQUIDITY_PRECISION, 'PostAuction: Liquidity percentage greater than 100.00% (>10000)');\n        require(_liquidityPercent > 0, 'PostAuction: Liquidity percentage equals zero');\n        require(_admin != address(0), \"PostAuction: admin is the zero address\");\n        require(_wallet != address(0), \"PostAuction: wallet is the zero address\");\n\n        initAccessControls(_admin);\n\n        market = IMisoAuction(_market);\n        token1 = IERC20(market.paymentCurrency());\n        token2 = IERC20(market.auctionToken());\n\n        if (address(token1) == ETH_ADDRESS) {\n            token1 = IERC20(weth);\n        }\n\n        uint256 d1 = uint256(token1.decimals());\n        uint256 d2 = uint256(token2.decimals());\n        require(d2 >= d1);\n\n        factory = IUniswapV2Factory(_factory);\n        bytes32 pairCodeHash = IUniswapV2Factory(_factory).pairCodeHash();\n        tokenPair = UniswapV2Library.pairFor(_factory, address(token1), address(token2), pairCodeHash);\n   \n        wallet = _wallet;\n        launcherInfo.liquidityPercent = BoringMath.to16(_liquidityPercent);\n        launcherInfo.locktime = BoringMath.to32(_locktime);\n\n        uint256 initalTokenAmount = market.getTotalTokens().mul(_liquidityPercent).div(LIQUIDITY_PRECISION);\n        _safeTransferFrom(address(token2), msg.sender, initalTokenAmount);\n\n        emit InitLiquidityLauncher(address(token1), address(token2), address(_factory), _admin);\n    }\n\n    receive() external payable {\n        if(msg.sender != weth ){\n             depositETH();\n        }\n    }\n\n    /// @notice Deposits ETH to the contract.\n    function depositETH() public payable {\n        require(address(token1) == weth || address(token2) == weth, \"PostAuction: Launcher not accepting ETH\");\n        if (msg.value > 0 ) {\n            IWETH(weth).deposit{value : msg.value}();\n        }\n    }\n\n    /**\n     * @notice Deposits first Token to the contract.\n     * @param _amount Number of tokens to deposit.\n     */\n    function depositToken1(uint256 _amount) external returns (bool success) {\n        return _deposit( address(token1), msg.sender, _amount);\n    }\n\n    /**\n     * @notice Deposits second Token to the contract.\n     * @param _amount Number of tokens to deposit.\n     */\n    function depositToken2(uint256 _amount) external returns (bool success) {\n        return _deposit( address(token2), msg.sender, _amount);\n    }\n\n    /**\n     * @notice Deposits Tokens to the contract.\n     * @param _amount Number of tokens to deposit.\n     * @param _from Where the tokens to deposit will come from.\n     * @param _token Token address.\n     */\n    function _deposit(address _token, address _from, uint _amount) internal returns (bool success) {\n        require(!launcherInfo.launched, \"PostAuction: Must first launch liquidity\");\n        require(launcherInfo.liquidityAdded == 0, \"PostAuction: Liquidity already added\");\n\n        require(_amount > 0, \"PostAuction: Token amount must be greater than 0\");\n        _safeTransferFrom(_token, _from, _amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Checks if market wallet is set to this launcher\n     */\n    function marketConnected() public view returns (bool)  {\n        return market.wallet() == address(this);\n    }\n\n    /**\n     * @notice Finalizes Token sale and launches LP.\n     * @return liquidity Number of LPs.\n     */\n    function finalize() external nonReentrant returns (uint256 liquidity) {\n        // GP: Can we remove admin, let anyone can finalise and launch?\n        // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n        require(marketConnected(), \"PostAuction: Auction must have this launcher address set as the destination wallet\");\n        require(!launcherInfo.launched);\n\n        if (!market.finalized()) {\n            market.finalize();\n        }\n        require(market.finalized());\n\n        launcherInfo.launched = true;\n        if (!market.auctionSuccessful() ) {\n            return 0;\n        }\n\n        /// @dev if the auction is settled in weth, wrap any contract balance \n        uint256 launcherBalance = address(this).balance;\n        if (launcherBalance > 0 ) {\n            IWETH(weth).deposit{value : launcherBalance}();\n        }\n        \n        (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();\n\n        /// @dev cannot start a liquidity pool with no tokens on either side\n        if (token1Amount == 0 || token2Amount == 0 ) {\n            return 0;\n        }\n\n        address pair = factory.getPair(address(token1), address(token2));\n        if(pair == address(0)) {\n            createPool();\n        }\n\n        /// @dev add liquidity to pool via the pair directly\n        _safeTransfer(address(token1), tokenPair, token1Amount);\n        _safeTransfer(address(token2), tokenPair, token2Amount);\n        liquidity = IUniswapV2Pair(tokenPair).mint(address(this));\n        launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));\n\n        /// @dev if unlock time not yet set, add it.\n        if (launcherInfo.unlock == 0 ) {\n            launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));\n        }\n        emit LiquidityAdded(liquidity);\n    }\n\n\n    function getTokenAmounts() public view returns (uint256 token1Amount, uint256 token2Amount) {\n        token1Amount = getToken1Balance().mul(uint256(launcherInfo.liquidityPercent)).div(LIQUIDITY_PRECISION);\n        token2Amount = getToken2Balance(); \n\n        uint256 tokenPrice = market.tokenPrice();  \n        uint256 d2 = uint256(token2.decimals());\n        uint256 maxToken1Amount = token2Amount.mul(tokenPrice).div(10**(d2));\n        uint256 maxToken2Amount = token1Amount\n                                    .mul(10**(d2))\n                                    .div(tokenPrice);\n\n        /// @dev if more than the max.\n        if (token2Amount > maxToken2Amount) {\n            token2Amount =  maxToken2Amount;\n        } \n        /// @dev if more than the max.\n        if (token1Amount > maxToken1Amount) {\n            token1Amount =  maxToken1Amount;\n        }\n\n    }\n\n    /**\n     * @notice Withdraws LPs from the contract.\n     * @return liquidity Number of LPs.\n     */\n    function withdrawLPTokens() external returns (uint256 liquidity) {\n        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n        require(launcherInfo.launched, \"PostAuction: Must first launch liquidity\");\n        require(block.timestamp >= uint256(launcherInfo.unlock), \"PostAuction: Liquidity is locked\");\n        liquidity = IERC20(tokenPair).balanceOf(address(this));\n        require(liquidity > 0, \"PostAuction: Liquidity must be greater than 0\");\n        _safeTransfer(tokenPair, wallet, liquidity);\n    }\n\n    /// @notice Withraws deposited tokens and ETH from the contract to wallet.\n    function withdrawDeposits() external {\n        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n        require(launcherInfo.launched, \"PostAuction: Must first launch liquidity\");\n\n        uint256 token1Amount = getToken1Balance();\n        if (token1Amount > 0 ) {\n            _safeTransfer(address(token1), wallet, token1Amount);\n        }\n        uint256 token2Amount = getToken2Balance();\n        if (token2Amount > 0 ) {\n            _safeTransfer(address(token2), wallet, token2Amount);\n        }\n    }\n\n    // TODO     \n    // GP: Sweep non relevant ERC20s / ETH\n\n\n    //--------------------------------------------------------\n    // Setter functions\n    //--------------------------------------------------------\n\n\n    /**\n     * @notice Admin can set the wallet through this function.\n     * @param _wallet Wallet is where funds will be sent.\n     */\n    function setWallet(address payable _wallet) external {\n        require(hasAdminRole(msg.sender));\n        require(_wallet != address(0), \"Wallet is the zero address\");\n\n        wallet = _wallet;\n\n        emit WalletUpdated(_wallet);\n    }\n\n    function cancelLauncher() external {\n        require(hasAdminRole(msg.sender));\n        require(!launcherInfo.launched);\n\n        launcherInfo.launched = true;\n        emit LauncherCancelled(msg.sender);\n\n    }\n\n    //--------------------------------------------------------\n    // Helper functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Creates new SLP pair through SushiSwap.\n     */\n    function createPool() public {\n        factory.createPair(address(token1), address(token2));\n    }\n\n    //--------------------------------------------------------\n    // Getter functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Gets the number of first token deposited into this contract.\n     * @return uint256 Number of WETH.\n     */\n    function getToken1Balance() public view returns (uint256) {\n         return token1.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Gets the number of second token deposited into this contract.\n     * @return uint256 Number of WETH.\n     */\n    function getToken2Balance() public view returns (uint256) {\n         return token2.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Returns LP token address..\n     * @return address LP address.\n     */\n    function getLPTokenAddress() public view returns (address) {\n        return tokenPair;\n    }\n    /**\n     * @notice Returns LP Token balance.\n     * @return uint256 LP Token balance.\n     */\n    function getLPBalance() public view returns (uint256) {\n         return IERC20(tokenPair).balanceOf(address(this));\n    }\n\n\n    //--------------------------------------------------------\n    // Init functions\n    //--------------------------------------------------------\n\n\n    /**\n     * @notice Decodes and hands auction data to the initAuction function.\n     * @param _data Encoded data for initialization.\n     */\n\n    function init(bytes calldata _data) external payable {\n\n    }\n\n    function initLauncher(\n        bytes calldata _data\n    ) public {\n        (\n            address _market,\n            address _factory,\n            address _admin,\n            address _wallet,\n            uint256 _liquidityPercent,\n            uint256 _locktime\n        ) = abi.decode(_data, (\n            address,\n            address,\n            address,\n            address,\n            uint256,\n            uint256\n        ));\n        initAuctionLauncher( _market, _factory,_admin,_wallet,_liquidityPercent,_locktime);\n    }\n\n    /**\n     * @notice Collects data to initialize the auction and encodes them.\n     * @param _market Auction address for launcher.\n     * @param _factory Uniswap V2 factory address.\n     * @param _admin Contract owner address.\n     * @param _wallet Withdraw wallet address.\n     * @param _liquidityPercent Percentage of payment currency sent to liquidity pool.\n     * @param _locktime How long the liquidity will be locked. Number of seconds.\n     * @return _data All the data in bytes format.\n     */\n    function getLauncherInitData(\n            address _market,\n            address _factory,\n            address _admin,\n            address _wallet,\n            uint256 _liquidityPercent,\n            uint256 _locktime\n    )\n        external \n        pure\n        returns (bytes memory _data)\n    {\n            return abi.encode(_market,\n                                _factory,\n                                _admin,\n                                _wallet,\n                                _liquidityPercent,\n                                _locktime\n            );\n    }\n\n}"
    },
    {
      "filename": "contracts/Liquidity/PostAuctionLauncher.sol",
      "content": "pragma solidity 0.6.12;\n\n\n//----------------------------------------------------------------------------------\n//    I n s t a n t\n//\n//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.\n//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.\n//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:\n//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'\n//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'\n//\n//----------------------------------------------------------------------------------\n//\n// Chef Gonpachi's Post Auction Launcher\n//\n// A post auction contract that takes the proceeds and creates a liquidity pool\n//\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// The above copyright notice and this permission notice shall be included \n// in all copies or substantial portions of the Software.\n//\n// Made for Sushi.com \n// \n// Enjoy. (c) Chef Gonpachi\n// <https://github.com/chefgonpachi/MISO/>\n//\n// ---------------------------------------------------------------------\n// SPDX-License-Identifier: GPL-3.0                        \n// ---------------------------------------------------------------------\n\nimport \"../OpenZeppelin/utils/ReentrancyGuard.sol\";\nimport \"../Access/MISOAccessControls.sol\";\nimport \"../Utils/SafeTransfer.sol\";\nimport \"../Utils/BoringMath.sol\";\nimport \"../UniswapV2/UniswapV2Library.sol\";\nimport \"../UniswapV2/interfaces/IUniswapV2Pair.sol\";\nimport \"../UniswapV2/interfaces/IUniswapV2Factory.sol\";\nimport \"../interfaces/IWETH9.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IMisoAuction.sol\";\n\n\n\ncontract PostAuctionLauncher is MISOAccessControls, SafeTransfer, ReentrancyGuard {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringMath64 for uint64;\n    using BoringMath32 for uint32;\n    using BoringMath16 for uint16;\n\n\n    /// @notice Number of seconds per day.\n    uint256 private constant SECONDS_PER_DAY = 24 * 60 * 60;\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant LIQUIDITY_PRECISION = 10000;\n    \n    /// @notice MISOLiquidity template id.\n    uint256 public constant liquidityTemplate = 3;\n\n    /// @notice First Token address.\n    IERC20 public token1;\n    /// @notice Second Token address.\n    IERC20 public token2;\n    /// @notice Uniswap V2 factory address.\n    IUniswapV2Factory public factory;\n    /// @notice WETH contract address.\n    address private immutable weth;\n\n\n    /// @notice LP pair address.\n    address public tokenPair;\n    /// @notice Withdraw wallet address.\n    address public wallet;\n    /// @notice Token market contract address.\n    IMisoAuction public market;\n\n    struct LauncherInfo {\n        uint32 locktime;\n        uint64 unlock;\n        uint16 liquidityPercent;\n        bool launched;\n        uint128 liquidityAdded;\n    }\n    LauncherInfo public launcherInfo;\n\n    /// @notice Emitted when LP contract is initialised.\n    event InitLiquidityLauncher(address indexed token1, address indexed token2, address factory, address sender);\n    /// @notice Emitted when LP is launched.\n    event LiquidityAdded(uint256 liquidity);\n    /// @notice Emitted when wallet is updated.\n    event WalletUpdated(address indexed wallet);\n    /// @notice Emitted when launcher is cancelled.\n    event LauncherCancelled(address indexed wallet);\n\n    constructor (address _weth) public {\n        weth = _weth;\n    }\n\n\n    /**\n     * @notice Initializes main contract variables (requires launchwindow to be more than 2 days.)\n     * @param _market Auction address for launcher.\n     * @param _factory Uniswap V2 factory address.\n     * @param _admin Contract owner address.\n     * @param _wallet Withdraw wallet address.\n     * @param _liquidityPercent Percentage of payment currency sent to liquidity pool.\n     * @param _locktime How long the liquidity will be locked. Number of seconds.\n     */\n    function initAuctionLauncher(\n            address _market,\n            address _factory,\n            address _admin,\n            address _wallet,\n            uint256 _liquidityPercent,\n            uint256 _locktime\n    )\n        public\n    {\n        require(_locktime < 10000000000, 'PostAuction: Enter an unix timestamp in seconds, not miliseconds');\n        require(_liquidityPercent <= LIQUIDITY_PRECISION, 'PostAuction: Liquidity percentage greater than 100.00% (>10000)');\n        require(_liquidityPercent > 0, 'PostAuction: Liquidity percentage equals zero');\n        require(_admin != address(0), \"PostAuction: admin is the zero address\");\n        require(_wallet != address(0), \"PostAuction: wallet is the zero address\");\n\n        initAccessControls(_admin);\n\n        market = IMisoAuction(_market);\n        token1 = IERC20(market.paymentCurrency());\n        token2 = IERC20(market.auctionToken());\n\n        if (address(token1) == ETH_ADDRESS) {\n            token1 = IERC20(weth);\n        }\n\n        uint256 d1 = uint256(token1.decimals());\n        uint256 d2 = uint256(token2.decimals());\n        require(d2 >= d1);\n\n        factory = IUniswapV2Factory(_factory);\n        bytes32 pairCodeHash = IUniswapV2Factory(_factory).pairCodeHash();\n        tokenPair = UniswapV2Library.pairFor(_factory, address(token1), address(token2), pairCodeHash);\n   \n        wallet = _wallet;\n        launcherInfo.liquidityPercent = BoringMath.to16(_liquidityPercent);\n        launcherInfo.locktime = BoringMath.to32(_locktime);\n\n        uint256 initalTokenAmount = market.getTotalTokens().mul(_liquidityPercent).div(LIQUIDITY_PRECISION);\n        _safeTransferFrom(address(token2), msg.sender, initalTokenAmount);\n\n        emit InitLiquidityLauncher(address(token1), address(token2), address(_factory), _admin);\n    }\n\n    receive() external payable {\n        if(msg.sender != weth ){\n             depositETH();\n        }\n    }\n\n    /// @notice Deposits ETH to the contract.\n    function depositETH() public payable {\n        require(address(token1) == weth || address(token2) == weth, \"PostAuction: Launcher not accepting ETH\");\n        if (msg.value > 0 ) {\n            IWETH(weth).deposit{value : msg.value}();\n        }\n    }\n\n    /**\n     * @notice Deposits first Token to the contract.\n     * @param _amount Number of tokens to deposit.\n     */\n    function depositToken1(uint256 _amount) external returns (bool success) {\n        return _deposit( address(token1), msg.sender, _amount);\n    }\n\n    /**\n     * @notice Deposits second Token to the contract.\n     * @param _amount Number of tokens to deposit.\n     */\n    function depositToken2(uint256 _amount) external returns (bool success) {\n        return _deposit( address(token2), msg.sender, _amount);\n    }\n\n    /**\n     * @notice Deposits Tokens to the contract.\n     * @param _amount Number of tokens to deposit.\n     * @param _from Where the tokens to deposit will come from.\n     * @param _token Token address.\n     */\n    function _deposit(address _token, address _from, uint _amount) internal returns (bool success) {\n        require(!launcherInfo.launched, \"PostAuction: Must first launch liquidity\");\n        require(launcherInfo.liquidityAdded == 0, \"PostAuction: Liquidity already added\");\n\n        require(_amount > 0, \"PostAuction: Token amount must be greater than 0\");\n        _safeTransferFrom(_token, _from, _amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Checks if market wallet is set to this launcher\n     */\n    function marketConnected() public view returns (bool)  {\n        return market.wallet() == address(this);\n    }\n\n    /**\n     * @notice Finalizes Token sale and launches LP.\n     * @return liquidity Number of LPs.\n     */\n    function finalize() external nonReentrant returns (uint256 liquidity) {\n        // GP: Can we remove admin, let anyone can finalise and launch?\n        // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n        require(marketConnected(), \"PostAuction: Auction must have this launcher address set as the destination wallet\");\n        require(!launcherInfo.launched);\n\n        if (!market.finalized()) {\n            market.finalize();\n        }\n        require(market.finalized());\n\n        launcherInfo.launched = true;\n        if (!market.auctionSuccessful() ) {\n            return 0;\n        }\n\n        /// @dev if the auction is settled in weth, wrap any contract balance \n        uint256 launcherBalance = address(this).balance;\n        if (launcherBalance > 0 ) {\n            IWETH(weth).deposit{value : launcherBalance}();\n        }\n        \n        (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();\n\n        /// @dev cannot start a liquidity pool with no tokens on either side\n        if (token1Amount == 0 || token2Amount == 0 ) {\n            return 0;\n        }\n\n        address pair = factory.getPair(address(token1), address(token2));\n        if(pair == address(0)) {\n            createPool();\n        }\n\n        /// @dev add liquidity to pool via the pair directly\n        _safeTransfer(address(token1), tokenPair, token1Amount);\n        _safeTransfer(address(token2), tokenPair, token2Amount);\n        liquidity = IUniswapV2Pair(tokenPair).mint(address(this));\n        launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));\n\n        /// @dev if unlock time not yet set, add it.\n        if (launcherInfo.unlock == 0 ) {\n            launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));\n        }\n        emit LiquidityAdded(liquidity);\n    }\n\n\n    function getTokenAmounts() public view returns (uint256 token1Amount, uint256 token2Amount) {\n        token1Amount = getToken1Balance().mul(uint256(launcherInfo.liquidityPercent)).div(LIQUIDITY_PRECISION);\n        token2Amount = getToken2Balance(); \n\n        uint256 tokenPrice = market.tokenPrice();  \n        uint256 d2 = uint256(token2.decimals());\n        uint256 maxToken1Amount = token2Amount.mul(tokenPrice).div(10**(d2));\n        uint256 maxToken2Amount = token1Amount\n                                    .mul(10**(d2))\n                                    .div(tokenPrice);\n\n        /// @dev if more than the max.\n        if (token2Amount > maxToken2Amount) {\n            token2Amount =  maxToken2Amount;\n        } \n        /// @dev if more than the max.\n        if (token1Amount > maxToken1Amount) {\n            token1Amount =  maxToken1Amount;\n        }\n\n    }\n\n    /**\n     * @notice Withdraws LPs from the contract.\n     * @return liquidity Number of LPs.\n     */\n    function withdrawLPTokens() external returns (uint256 liquidity) {\n        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n        require(launcherInfo.launched, \"PostAuction: Must first launch liquidity\");\n        require(block.timestamp >= uint256(launcherInfo.unlock), \"PostAuction: Liquidity is locked\");\n        liquidity = IERC20(tokenPair).balanceOf(address(this));\n        require(liquidity > 0, \"PostAuction: Liquidity must be greater than 0\");\n        _safeTransfer(tokenPair, wallet, liquidity);\n    }\n\n    /// @notice Withraws deposited tokens and ETH from the contract to wallet.\n    function withdrawDeposits() external {\n        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), \"PostAuction: Sender must be operator\");\n        require(launcherInfo.launched, \"PostAuction: Must first launch liquidity\");\n\n        uint256 token1Amount = getToken1Balance();\n        if (token1Amount > 0 ) {\n            _safeTransfer(address(token1), wallet, token1Amount);\n        }\n        uint256 token2Amount = getToken2Balance();\n        if (token2Amount > 0 ) {\n            _safeTransfer(address(token2), wallet, token2Amount);\n        }\n    }\n\n    // TODO     \n    // GP: Sweep non relevant ERC20s / ETH\n\n\n    //--------------------------------------------------------\n    // Setter functions\n    //--------------------------------------------------------\n\n\n    /**\n     * @notice Admin can set the wallet through this function.\n     * @param _wallet Wallet is where funds will be sent.\n     */\n    function setWallet(address payable _wallet) external {\n        require(hasAdminRole(msg.sender));\n        require(_wallet != address(0), \"Wallet is the zero address\");\n\n        wallet = _wallet;\n\n        emit WalletUpdated(_wallet);\n    }\n\n    function cancelLauncher() external {\n        require(hasAdminRole(msg.sender));\n        require(!launcherInfo.launched);\n\n        launcherInfo.launched = true;\n        emit LauncherCancelled(msg.sender);\n\n    }\n\n    //--------------------------------------------------------\n    // Helper functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Creates new SLP pair through SushiSwap.\n     */\n    function createPool() public {\n        factory.createPair(address(token1), address(token2));\n    }\n\n    //--------------------------------------------------------\n    // Getter functions\n    //--------------------------------------------------------\n\n    /**\n     * @notice Gets the number of first token deposited into this contract.\n     * @return uint256 Number of WETH.\n     */\n    function getToken1Balance() public view returns (uint256) {\n         return token1.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Gets the number of second token deposited into this contract.\n     * @return uint256 Number of WETH.\n     */\n    function getToken2Balance() public view returns (uint256) {\n         return token2.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Returns LP token address..\n     * @return address LP address.\n     */\n    function getLPTokenAddress() public view returns (address) {\n        return tokenPair;\n    }\n    /**\n     * @notice Returns LP Token balance.\n     * @return uint256 LP Token balance.\n     */\n    function getLPBalance() public view returns (uint256) {\n         return IERC20(tokenPair).balanceOf(address(this));\n    }\n\n\n    //--------------------------------------------------------\n    // Init functions\n    //--------------------------------------------------------\n\n\n    /**\n     * @notice Decodes and hands auction data to the initAuction function.\n     * @param _data Encoded data for initialization.\n     */\n\n    function init(bytes calldata _data) external payable {\n\n    }\n\n    function initLauncher(\n        bytes calldata _data\n    ) public {\n        (\n            address _market,\n            address _factory,\n            address _admin,\n            address _wallet,\n            uint256 _liquidityPercent,\n            uint256 _locktime\n        ) = abi.decode(_data, (\n            address,\n            address,\n            address,\n            address,\n            uint256,\n            uint256\n        ));\n        initAuctionLauncher( _market, _factory,_admin,_wallet,_liquidityPercent,_locktime);\n    }\n\n    /**\n     * @notice Collects data to initialize the auction and encodes them.\n     * @param _market Auction address for launcher.\n     * @param _factory Uniswap V2 factory address.\n     * @param _admin Contract owner address.\n     * @param _wallet Withdraw wallet address.\n     * @param _liquidityPercent Percentage of payment currency sent to liquidity pool.\n     * @param _locktime How long the liquidity will be locked. Number of seconds.\n     * @return _data All the data in bytes format.\n     */\n    function getLauncherInitData(\n            address _market,\n            address _factory,\n            address _admin,\n            address _wallet,\n            uint256 _liquidityPercent,\n            uint256 _locktime\n    )\n        external \n        pure\n        returns (bytes memory _data)\n    {"
    }
  ]
}