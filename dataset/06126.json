{
  "Title": "[M-04] Users can unfollow through `FollowNFT` contract when LensHub is paused by governance",
  "Content": "\nWhen the `LensHub` contract has been paused by governance (`_state` set to `ProtocolState.Paused`), users should not be able unfollow profiles. This can be inferred as the `unfollow()` function has the `whenNotPaused` modifier:\n\n[LensHub.sol#L368-L371](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L368-L371)\n\n```solidity\n    function unfollow(uint256 unfollowerProfileId, uint256[] calldata idsOfProfilesToUnfollow)\n        external\n        override\n        whenNotPaused\n```\n\nHowever, in the `FollowNFT` contract, which is deployed for each profile that has followers, the `removeFollower()` and `burn()` functions do not check if the `LensHub` contract is paused:\n\n[FollowNFT.sol#L131-L138](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L131-L138)\n\n```solidity\n    function removeFollower(uint256 followTokenId) external override {\n        address followTokenOwner = ownerOf(followTokenId);\n        if (followTokenOwner == msg.sender || isApprovedForAll(followTokenOwner, msg.sender)) {\n            _unfollowIfHasFollower(followTokenId);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n```\n\n[FollowNFT.sol#L255-L258](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L255-L258)\n\n```solidity\n    function burn(uint256 followTokenId) public override {\n        _unfollowIfHasFollower(followTokenId);\n        super.burn(followTokenId);\n    }\n```\n\nAs such, whenever the system has been paused by governance, users will still be able to unfollow profiles by wrapping their followNFT and then calling either `removeFollower()` or `burn()`.\n\n### Impact\n\nUsers are able to unfollow profiles when the system is paused, which they should not be able to do.\n\nThis could be problematic if governance ever needs to temporarily pause unfollow functionality (eg. for a future upgrade, or unfollowing functionality has a bug, etc...).\n\n### Proof of Concept\n\nThe Foundry test below demonstrates how users will still be able to unfollow profiles by calling `wrap()` and `removeFollower()`, even after the system has been paused by governance. It can be run with the following command:\n\n    forge test --match-test testCanUnfollowWhilePaused -vvv\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport 'test/base/BaseTest.t.sol';\n\ncontract Unfollow_POC is BaseTest {\n    address targetProfileOwner;\n    uint256 targetProfileId;\n    FollowNFT targetFollowNFT;\n\n    address follower;\n    uint256 followerProfileId;\n    uint256 followTokenId;\n\n    function setUp() public override {\n        super.setUp();\n\n        // Create profile for target\n        targetProfileOwner = makeAddr(\"Target\");\n        targetProfileId = _createProfile(targetProfileOwner);\n\n        // Create profile for follower\n        follower = makeAddr(\"Follower\");\n        followerProfileId = _createProfile(follower);\n\n        // Follower follows target\n        vm.prank(follower);\n        followTokenId = hub.follow(\n            followerProfileId,\n            _toUint256Array(targetProfileId),\n            _toUint256Array(0),\n            _toBytesArray('')\n        )[0];\n        targetFollowNFT = FollowNFT(hub.getProfile(targetProfileId).followNFT);\n    }\n\n    function testCanUnfollowWhilePaused() public {\n        // Governance pauses system\n        vm.prank(governance);\n        hub.setState(Types.ProtocolState.Paused);\n        assertEq(uint8(hub.getState()), uint8(Types.ProtocolState.Paused));\n\n        // unfollow() reverts as system is paused\n        vm.startPrank(follower);\n        vm.expectRevert(Errors.Paused.selector);\n        hub.unfollow(followerProfileId, _toUint256Array(targetProfileId));\n\n        // However, follower can still unfollow through FollowNFT contract \n        targetFollowNFT.wrap(followTokenId);\n        targetFollowNFT.removeFollower(followTokenId);        \n        vm.stopPrank();\n\n        // follower isn't following anymore\n        assertFalse(targetFollowNFT.isFollowing(followerProfileId));\n    }\n}\n```\n\n### Recommended Mitigation\n\nAll `FollowNFT` contracts should check that the `LensHub` contract isn't paused before allowing `removeFollower()` or `burn()` to be called. This can be achieved by doing the following:\n\n1.  Add a `whenNotPaused` modifier to `FollowNFT.sol`:\n\n```solidity\nmodifier whenNotPaused() {\n    if (ILensHub(HUB).getState() == Types.ProtocolState.Paused) {\n        revert Errors.Paused();\n    }\n    _;\n}\n```\n\n2.  Use the modifier on `removeFollower()` and `burn()`:\n\n[FollowNFT.sol#L131-L138](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L131-L138)\n\n```diff\n-   function removeFollower(uint256 followTokenId) external override {\n+   function removeFollower(uint256 followTokenId) external override whenNotPaused {\n        // Some code here...\n    }\n```\n\n[FollowNFT.sol#L255-L258](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L255-L258)\n\n```diff\n-   function burn(uint256 followTokenId) public override {\n+   function burn(uint256 followTokenId) public override whenNotPaused {\n        // Some code here...\n    }\n```\n\n### Assessed type\n\nAccess Control\n\n**[donosonaumczuk (Lens) disagreed with severity and commented](https://github.com/code-423n4/2023-07-lens-findings/issues/144#issuecomment-1669794975):**\n > This report is a subset of this [issue 108](https://github.com/code-423n4/2023-07-lens-findings/issues/108).<br>\n> Same resolution, we accept it but we disagree with the severity. It should be Low.\n\n**[Picodes (judge) decreased severity to Low](https://github.com/code-423n4/2023-07-lens-findings/issues/144#issuecomment-1696117127)**\n\n**[juancito (warden) commented via duplicate issue `#108`](https://github.com/code-423n4/2023-07-lens-findings/issues/108#issuecomment-1696721097):**\n> Hi @Picodes. I'd like to ask if you could take a second look at this issue as a Medium risk finding, considering the [Docs](https://docs.code4rena.com/awarding/judging-criteria/severity-categorization#estimating-risk):\n>\n> > *2 â€” Med: Assets not at direct risk, but **the function of the protocol** or its availability **could be impacted***\n>\n> In this case the \"function of the protocol\" is impacted, and availability can also be considered as well. Not for being unavailable, but because of functions being available in moments that they shouldn't be, allowing **important actions for a social network** that users should not be able to perform, out of the control of the protocol.\n> \n> When the protocol is paused, it should not allow unfollow actions (via `removeFollower()`) or new follows (via `batchMigrateProfiles()` for example, among all the other mentioned functions on the Impact section.\n> \n> In DeFi protocols, missing pause modifiers having been evaluated as Medium like [here](https://github.com/code-423n4/2022-02-aave-lens-findings/issues/71), and [here](https://github.com/code-423n4/2023-03-polynomial-findings/issues/232). In the case of Lens Protocol, the functions mentioned on the Impact section should be considered of ultimate importance to have under control as a social network.\n\n**[donosonaumczuk (Lens) commented via duplicate issue `#108`](https://github.com/code-423n4/2023-07-lens-findings/issues/108#issuecomment-1699472401):**\n > Yeah, I think it is a fair argument and can be upgraded to Medium.\n\n**[Picodes (judge) increased severity to Medium and commented via duplicate issue `#108`](https://github.com/code-423n4/2023-07-lens-findings/issues/108#issuecomment-1701376854):**\n> My view on this is that it ultimately depends on the sponsor's intent. In this case, it seems clear by the above comment and what you highlighted that the intent was to be able to totally pause follows and unfollows. So you're right and I'll upgrade this to Medium as a functionality is broken.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/LensHub.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// Interfaces\nimport {ILensProtocol} from 'contracts/interfaces/ILensProtocol.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\n\n// Constants\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\n\n// Lens Hub Components\nimport {LensHubStorage} from 'contracts/base/LensHubStorage.sol';\nimport {LensImplGetters} from 'contracts/base/LensImplGetters.sol';\nimport {LensGovernable} from 'contracts/base/LensGovernable.sol';\nimport {LensProfiles} from 'contracts/base/LensProfiles.sol';\nimport {LensHubEventHooks} from 'contracts/base/LensHubEventHooks.sol';\n\n// Libraries\nimport {ActionLib} from 'contracts/libraries/ActionLib.sol';\nimport {LegacyCollectLib} from 'contracts/libraries/LegacyCollectLib.sol';\nimport {FollowLib} from 'contracts/libraries/FollowLib.sol';\nimport {MetaTxLib} from 'contracts/libraries/MetaTxLib.sol';\nimport {ProfileLib} from 'contracts/libraries/ProfileLib.sol';\nimport {PublicationLib} from 'contracts/libraries/PublicationLib.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\n\n// Lens Migrations V1 to V2\nimport {LensV2Migration} from 'contracts/misc/LensV2Migration.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entry point of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke a LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is\n    LensProfiles,\n    LensGovernable,\n    LensV2Migration,\n    LensImplGetters,\n    LensHubEventHooks,\n    LensHubStorage,\n    ILensProtocol\n{\n    modifier onlyProfileOwnerOrDelegatedExecutor(address expectedOwnerOrDelegatedExecutor, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwnerOrDelegatedExecutor(expectedOwnerOrDelegatedExecutor, profileId);\n        _;\n    }\n\n    modifier whenPublishingEnabled() {\n        if (StorageLib.getState() != Types.ProtocolState.Unpaused) {\n            revert Errors.PublishingPaused();\n        }\n        _;\n    }\n\n    constructor(\n        address moduleGlobals,\n        address followNFTImpl,\n        address collectNFTImpl, // We still pass the deprecated CollectNFTImpl for legacy Collects to work\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule,\n        uint256 tokenGuardianCooldown\n    )\n        LensProfiles(moduleGlobals, tokenGuardianCooldown)\n        LensV2Migration(\n            legacyFeeFollowModule,\n            legacyProfileFollowModule,\n            newFeeFollowModule,\n            lensHandlesAddress,\n            tokenHandleRegistryAddress\n        )\n        LensImplGetters(followNFTImpl, collectNFTImpl)\n    {}\n\n    /// @inheritdoc ILensProtocol\n    function createProfile(Types.CreateProfileParams calldata createProfileParams)\n        external\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        ValidationLib.validateProfileCreatorWhitelisted(msg.sender);\n        unchecked {\n            uint256 profileId = ++_profileCounter;\n            _mint(createProfileParams.to, profileId);\n            ProfileLib.createProfile(createProfileParams, profileId);\n            return profileId;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ///        PROFILE OWNER FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileMetadataURISignature(signature, profileId, metadataURI);\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId) {\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModuleWithSig(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetFollowModuleSignature(signature, profileId, followModule, followModuleInitData);\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeDelegatedExecutorsConfig(delegatorProfileId, delegatedExecutors, approvals);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfigWithSig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwner(signature.signer, delegatorProfileId) {\n        MetaTxLib.validateChangeDelegatedExecutorsConfigSignature(\n            signature,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURIWithSig(\n        uint256 profileId,\n        string calldata imageURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileImageURISignature(signature, profileId, imageURI);\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    ////////////////////////////////////////\n    ///        PUBLISHING FUNCTIONS      ///\n    ////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function post(Types.PostParams calldata postParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, postParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.post({postParams: postParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function postWithSig(Types.PostParams calldata postParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, postParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validatePostSignature(signature, postParams);\n        return PublicationLib.post({postParams: postParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function comment(Types.CommentParams calldata commentParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, commentParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function commentWithSig(Types.CommentParams calldata commentParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, commentParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateCommentSignature(signature, commentParams);\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirror(Types.MirrorParams calldata mirrorParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, mirrorParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirrorWithSig(Types.MirrorParams calldata mirrorParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, mirrorParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateMirrorSignature(signature, mirrorParams);\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quote(Types.QuoteParams calldata quoteParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, quoteParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quoteWithSig(Types.QuoteParams calldata quoteParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, quoteParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateQuoteSignature(signature, quoteParams);\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: signature.signer});\n    }\n\n    /////////////////////////////////////////////////\n    ///        PROFILE INTERACTION FUNCTIONS      ///\n    /////////////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function follow(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, followerProfileId)\n        returns (uint256[] memory)\n    {\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: msg.sender\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function followWithSig(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, followerProfileId)\n        returns (uint256[] memory)\n    {\n        MetaTxLib.validateFollowSignature(signature, followerProfileId, idsOfProfilesToFollow, followTokenIds, datas);\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: signature.signer\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollow(uint256 unfollowerProfileId, uint256[] calldata idsOfProfilesToUnfollow)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, unfollowerProfileId)\n    {\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: msg.sender\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollowWithSig(\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, unfollowerProfileId) {\n        MetaTxLib.validateUnfollowSignature(signature, unfollowerProfileId, idsOfProfilesToUnfollow);\n\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: signature.signer\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, byProfileId) {\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatusWithSig(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, byProfileId) {\n        MetaTxLib.validateSetBlockStatusSignature(signature, byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collect(Types.CollectParams calldata collectParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: msg.sender,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collectWithSig(Types.CollectParams calldata collectParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateLegacyCollectSignature(signature, collectParams);\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: signature.signer,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function act(Types.PublicationActionParams calldata publicationActionParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: msg.sender,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function actWithSig(\n        Types.PublicationActionParams calldata publicationActionParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        MetaTxLib.validateActSignature(signature, publicationActionParams);\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: signature.signer,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    ///////////////////////////////////////////\n    ///        EXTERNAL VIEW FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) external view returns (bool) {\n        address followNFT = _profiles[followedProfileId].followNFT;\n        return followNFT != address(0) && IFollowNFT(followNFT).isFollowing(followerProfileId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor,\n        uint64 configNumber\n    ) external view returns (bool) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).isApproved[configNumber][delegatedExecutor];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor)\n        external\n        view\n        returns (bool)\n    {\n        return ProfileLib.isExecutorApproved(delegatorProfileId, delegatedExecutor);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).configNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsPrevConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).prevConfigNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsMaxConfigNumberSet(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).maxConfigNumberSet;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isBlocked(uint256 profileId, uint256 byProfileId) external view returns (bool) {\n        return _blockedStatus[byProfileId][profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getContentURI(uint256 profileId, uint256 pubId) external view override returns (string memory) {\n        // This function is used by the Collect NFTs' tokenURI function.\n        return PublicationLib.getContentURI(profileId, pubId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getProfile(uint256 profileId) external view override returns (Types.Profile memory) {\n        return _profiles[profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublication(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.Publication memory)\n    {\n        return _publications[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublicationType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.PublicationType)\n    {\n        return PublicationLib.getPublicationType(profileId, pubId);\n    }\n\n    function getActionModuleById(uint256 id) external view override returns (address) {\n        return _actionModules[id];\n    }\n}"
    },
    {
      "filename": "contracts/FollowNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {HubRestricted} from 'contracts/base/HubRestricted.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {LensBaseERC721} from 'contracts/base/LensBaseERC721.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowTokenURILib} from 'contracts/libraries/token-uris/FollowTokenURILib.sol';\n\ncontract FollowNFT is HubRestricted, LensBaseERC721, ERC2981CollectionRoyalties, IFollowNFT {\n    using Strings for uint256;\n\n    string constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\n    string constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\n\n    uint256[5] ___DEPRECATED_SLOTS; // Deprecated slots, previously used for delegations.\n    uint256 internal _followedProfileId;\n\n    // Old uint256 `_lastFollowTokenId` slot splitted into two uint128s to include `_followerCount`.\n    uint128 internal _lastFollowTokenId;\n    // `_followerCount` will not be decreased when a follower profile is burned, making the counter not fully accurate.\n    // New variable added in V2 in the same slot, lower-ordered to not conflict with previous storage layout.\n    uint128 internal _followerCount;\n\n    bool private _initialized;\n\n    // Introduced in v2\n    mapping(uint256 => Types.FollowData) internal _followDataByFollowTokenId;\n    mapping(uint256 => uint256) internal _followTokenIdByFollowerProfileId;\n    mapping(uint256 => uint256) internal _followApprovalByFollowTokenId;\n    uint256 internal _royaltiesInBasisPoints;\n\n    event FollowApproval(uint256 indexed followerProfileId, uint256 indexed followTokenId);\n\n    constructor(address hub) HubRestricted(hub) {\n        _initialized = true;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(uint256 profileId) external override {\n        // This is called right after deployment by the LensHub, so we can skip the onlyHub check.\n        if (_initialized) {\n            revert Errors.Initialized();\n        }\n        _initialized = true;\n        _followedProfileId = profileId;\n        _setRoyalty(1000); // 10% of royalties\n    }\n\n    /// @inheritdoc IFollowNFT\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) external override onlyHub returns (uint256) {\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\n            revert AlreadyFollowing();\n        }\n\n        if (followTokenId == 0) {\n            // Fresh follow.\n            return _followMintingNewToken(followerProfileId);\n        }\n\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner != address(0)) {\n            // Provided follow token is wrapped.\n            return\n                _followWithWrappedToken({\n                    followerProfileId: followerProfileId,\n                    transactionExecutor: transactionExecutor,\n                    followTokenId: followTokenId,\n                    followTokenOwner: followTokenOwner\n                });\n        }\n\n        uint256 currentFollowerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (currentFollowerProfileId != 0) {\n            // Provided follow token is unwrapped.\n            // It has a follower profile set already, it can only be used to follow if that profile was burnt.\n            return\n                _followWithUnwrappedTokenFromBurnedProfile({\n                    followerProfileId: followerProfileId,\n                    followTokenId: followTokenId,\n                    currentFollowerProfileId: currentFollowerProfileId\n                });\n        }\n\n        // Provided follow token does not exist anymore, it can only be used if the profile attempting to follow is\n        // allowed to recover it.\n        return _followByRecoveringToken({followerProfileId: followerProfileId, followTokenId: followTokenId});\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unfollow(uint256 unfollowerProfileId, address transactionExecutor) external override onlyHub {\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[unfollowerProfileId];\n        if (followTokenId == 0) {\n            revert NotFollowing();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            // Follow token is unwrapped.\n            // Unfollowing and allowing recovery.\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n            _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = unfollowerProfileId;\n        } else {\n            // Follow token is wrapped.\n            address unfollowerProfileOwner = IERC721(HUB).ownerOf(unfollowerProfileId);\n            // Follower profile owner or its approved delegated executor must hold the token or be approved-for-all.\n            if (\n                (followTokenOwner != unfollowerProfileOwner) &&\n                (followTokenOwner != transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, unfollowerProfileOwner)\n            ) {\n                revert DoesNotHavePermissions();\n            }\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function removeFollower(uint256 followTokenId) external override {\n        address followTokenOwner = ownerOf(followTokenId);\n        if (followTokenOwner == msg.sender || isApprovedForAll(followTokenOwner, msg.sender)) {\n            _unfollowIfHasFollower(followTokenId);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function approveFollow(uint256 followerProfileId, uint256 followTokenId) external override {\n        if (!IERC721Timestamped(HUB).exists(followerProfileId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            revert OnlyWrappedFollowTokens();\n        }\n        if (followTokenOwner != msg.sender && !isApprovedForAll(followTokenOwner, msg.sender)) {\n            revert DoesNotHavePermissions();\n        }\n        _approveFollow(followerProfileId, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external override {\n        if (wrappedTokenReceiver == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n        _wrap(followTokenId, wrappedTokenReceiver);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId) external override {\n        _wrap(followTokenId, address(0));\n    }\n\n    function _wrap(uint256 followTokenId, address wrappedTokenReceiver) internal {\n        if (_isFollowTokenWrapped(followTokenId)) {\n            revert AlreadyWrapped();\n        }\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId == 0) {\n            followerProfileId = _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n            if (followerProfileId == 0) {\n                revert FollowTokenDoesNotExist();\n            }\n            delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        }\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (msg.sender != followerProfileOwner) {\n            revert DoesNotHavePermissions();\n        }\n        _mint(wrappedTokenReceiver == address(0) ? followerProfileOwner : wrappedTokenReceiver, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unwrap(uint256 followTokenId) external override {\n        if (_followDataByFollowTokenId[followTokenId].followerProfileId == 0) {\n            revert NotFollowing();\n        }\n        super.burn(followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function processBlock(uint256 followerProfileId) external override onlyHub returns (bool) {\n        bool hasUnfollowed;\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n            }\n            _unfollow(followerProfileId, followTokenId);\n            hasUnfollowed = true;\n        }\n        return hasUnfollowed;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerProfileId(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followerProfileId;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function isFollowing(uint256 followerProfileId) external view override returns (bool) {\n        return _followTokenIdByFollowerProfileId[followerProfileId] != 0;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTokenId(uint256 followerProfileId) external view override returns (uint256) {\n        return _followTokenIdByFollowerProfileId[followerProfileId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].originalFollowTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowData(uint256 followTokenId) external view override returns (Types.FollowData memory) {\n        return _followDataByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowApproved(uint256 followTokenId) external view override returns (uint256) {\n        return _followApprovalByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerCount() external view override returns (uint256) {\n        return _followerCount;\n    }\n\n    function burn(uint256 followTokenId) public override {\n        _unfollowIfHasFollower(followTokenId);\n        super.burn(followTokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supports"
    }
  ]
}