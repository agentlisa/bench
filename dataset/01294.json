{
  "Title": "M-2: Exponential Inflation of Voice Credits in Quadratic Voting Strategy",
  "Content": "# Issue M-2: Exponential Inflation of Voice Credits in Quadratic Voting Strategy \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/48 \n\n## Found by \n0x00ffDa, 0x3b, 0xRstStn, 0xarno, 0xbepresent, 0xc0ffEE, 0xdeadbeef, 0xkaden, 0xpoolbaer, Arz, AsenXDeth, BenRai, GimelSec, HChang26, HHK, KingNFT, Kow, Topmark, WATCHPUG, ZdravkoHr., ace13567, alexxander, ashirleyshe, ast3ros, chaduke, coffiasd, dany.armstrong90, detectiveking, honeymewn, jah, jkoppel, jovi, lemonmon, lil.eth, nobody2018, osmanozdemir1, pengun, pontifex, rvierdiiev, seeques, shtesesamoubiq, simon135, tnquanghuy0512, toshii, trachev, twcctop\n\n## Vulnerability Detail\nIn the given code snippet, we observe a potential issue in the way voice credits are being accumulated for each recipient. The specific lines of code in question are:\n```solidity\nfunction _qv_allocate(\n        ...\n    ) internal onlyActiveAllocation {\n        ...\n        uint256 creditsCastToRecipient = _allocator.voiceCreditsCastToRecipient[_recipientId];\n        ...\n        // get the total credits and calculate the vote result\n        uint256 totalCredits = _voiceCreditsToAllocate + creditsCastToRecipient;\n        ...\n        //E update allocator mapping voice for this recipient\n        _allocator.voiceCreditsCastToRecipient[_recipientId] += totalCredits; //E @question should be only _voiceCreditsToAllocate\n        ...\n    }\n```\nWe can see that at the end : \n```solidity\n_allocator.voiceCreditsCastToRecipient[_recipientId] = _allocator.voiceCreditsCastToRecipient[_recipientId] + _voiceCreditsToAllocate +  _allocator.voiceCreditsCastToRecipient[_recipientId];\n```\n\nHere, totalCredits accumulates both the newly allocated voice credits (`_voiceCreditsToAllocate`) and the credits previously cast to this recipient (`creditsCastToRecipient`). Later on, this totalCredits is added again to `voiceCreditsCastToRecipient[_recipientId]`, thereby including the previously cast credits once more\n\n### Proof of Concept (POC):\nLet's consider a scenario where a user allocates credits in three separate transactions:\n\n1. Transaction 1: Allocates 5 credits\n- creditsCastToRecipient initially is 0\n- totalCredits = 5 (5 + 0)\n- New voiceCreditsCastToRecipient[_recipientId] = 5\n\n2. Transaction 2: Allocates another 5 credits\n- creditsCastToRecipient now is 5 (from previous transaction)\n- totalCredits = 10 (5 + 5)\n- New voiceCreditsCastToRecipient[_recipientId] = 15 (10 + 5)\n\n3. Transaction 3: Allocates another 5 credits\n- creditsCastToRecipient now is 15\n- totalCredits = 20 (5 + 15)\n- New voiceCreditsCastToRecipient[_recipientId] = 35 (20 + 15)\n\nFrom the above, we can see that the voice credits cast to the recipient are exponentially growing with each transaction instead of linearly increasing by 5 each time\n\n## Impact\nExponential increase in the voice credits attributed to a recipient, significantly skewing the results of the voting strategy( if one recipient receive 15 votes in one vote and another one receive 5 votes 3 times, the second one will have 20 votes and the first one 15)\nOver time, this could allow for manipulation and loss of trust in the voting mechanism and the percentage of amount received by recipients as long as allocations are used to calculate the match amount they will receive from the pool amount.\n\n## Code Snippet\n\nhttps://github.com/allo-protocol/allo-v2/blob/main/contracts/strategies/qv-base/QVBaseStrategy.sol#L529\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCode should be modified to only add the new voice credits to the recipient's tally. The modified line of code should look like:\n```solidity\n_allocator.voiceCreditsCastToRecipient[_recipientId] += _voiceCreditsToAllocate;\n```\n\n\n\n## Discussion\n\n**MLON33**\n\nhttps://github.com/allo-protocol/allo-v2/pull/338\n\n**jack-the-pug**\n\nFixed\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "contracts/strategies/qv-base/QVBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title QVBaseStrategy\n/// @notice Base strategy for quadratic voting strategies\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\nabstract contract QVBaseStrategy is BaseStrategy {\n    /// ======================\n    /// ======= Events =======\n    /// ======================\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient's application\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    /// @param status The updated status of the recipient\n    event UpdatedRegistration(\n        address indexed recipientId, uint256 applicationId, bytes data, address sender, Status status\n    );\n\n    /// @notice Emitted when a recipient is registered\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient's application\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event RecipientStatusUpdated(address indexed recipientId, uint256 applicationId, Status status, address sender);\n\n    /// @notice Emitted when the pool timestamps are updated\n    /// @param registrationStartTime The start time for the registration\n    /// @param registrationEndTime The end time for the registration\n    /// @param allocationStartTime The start time for the allocation\n    /// @param allocationEndTime The end time for the allocation\n    /// @param sender The sender of the transaction\n    event TimestampsUpdated(\n        uint64 registrationStartTime,\n        uint64 registrationEndTime,\n        uint64 allocationStartTime,\n        uint64 allocationEndTime,\n        address sender\n    );\n\n    /// @notice Emitted when a recipient receives votes\n    /// @param recipientId ID of the recipient\n    /// @param votes The votes allocated to the recipient\n    /// @param allocator The allocator assigning the votes\n    event Allocated(address indexed recipientId, uint256 votes, address allocator);\n\n    /// @notice Emitted when a recipient is reviewed\n    /// @param recipientId ID of the recipient\n    /// @param applicationId ID of the recipient's application\n    /// @param status The status of the recipient\n    /// @param sender The sender of the transaction\n    event Reviewed(address indexed recipientId, uint256 applicationId, Status status, address sender);\n\n    /// ======================\n    /// ======= Storage ======\n    /// ======================\n\n    // slot 0\n    /// @notice The total number of votes cast for all recipients\n    uint256 public totalRecipientVotes;\n\n    // slot 1\n    /// @notice The number of votes required to review a recipient\n    uint256 public reviewThreshold;\n\n    // slot 2\n    /// @notice The start and end times for registrations and allocations\n    /// @dev The values will be in milliseconds since the epoch\n    uint64 public registrationStartTime;\n    uint64 public registrationEndTime;\n    uint64 public allocationStartTime;\n    uint64 public allocationEndTime;\n\n    // slot 3\n    /// @notice Whether or not the strategy is using registry gating\n    bool public registryGating;\n\n    /// @notice Whether or not the strategy requires metadata\n    bool public metadataRequired;\n\n    /// @notice Whether the distribution started or not\n    bool public distributionStarted;\n\n    /// @notice The registry contract\n    IRegistry private _registry;\n\n    // slots [4...n]\n    /// @notice The status of the recipient for this strategy only\n    /// @dev There is a core `IStrategy.RecipientStatus` that this should map to\n    enum InternalRecipientStatus {\n        None,\n        Pending,\n        Accepted,\n        Rejected,\n        Appealed\n    }\n\n    /// @notice The parameters used to initialize the strategy\n    struct InitializeParams {\n        // slot 0\n        bool registryGating;\n        bool metadataRequired;\n        // slot 1\n        uint256 reviewThreshold;\n        // slot 2\n        uint64 registrationStartTime;\n        uint64 registrationEndTime;\n        uint64 allocationStartTime;\n        uint64 allocationEndTime;\n    }\n\n    /// @notice The details of the recipient\n    struct Recipient {\n        // slot 0\n        uint256 totalVotesReceived;\n        // slot 1\n        bool useRegistryAnchor;\n        address recipientAddress;\n        Metadata metadata;\n        Status recipientStatus;\n        // slot 2\n        uint256 applicationId;\n    }\n\n    /// @notice The details of the allocator\n    struct Allocator {\n        // slot 0\n        uint256 voiceCredits;\n        // slots [1...n]\n        mapping(address => uint256) voiceCreditsCastToRecipient;\n        mapping(address => uint256) votesCastToRecipient;\n    }\n\n    /// @notice The details of the recipient are returned using their ID\n    /// @dev recipientId => Recipient\n    mapping(address => Recipient) public recipients;\n\n    /// @notice The details of the allocator are returned using their address\n    /// @dev allocator address => Allocator\n    mapping(address => Allocator) public allocators;\n\n    /// @notice Returns whether or not the recipient has been paid out using their ID\n    /// @dev recipientId => paid out\n    mapping(address => bool) public paidOut;\n\n    // recipientId -> applicationId -> status -> count\n    mapping(address => mapping(uint256 => mapping(Status => uint256))) public reviewsByStatus;\n\n    // recipientId -> applicationId -> reviewer -> status\n    mapping(address => mapping(uint256 => mapping(address => Status))) public reviewedByManager;\n\n    /// ================================\n    /// ========== Modifier ============\n    /// ================================\n\n    /// @notice Modifier to check if the registration is active\n    /// @dev Reverts if the registration is not active\n    modifier onlyActiveRegistration() {\n        _checkOnlyActiveRegistration();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    modifier onlyActiveAllocation() {\n        _checkOnlyActiveAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    modifier onlyAfterAllocation() {\n        _checkOnlyAfterAllocation();\n        _;\n    }\n\n    /// @notice Modifier to check if the allocation has ended\n    /// @dev This will revert if the allocation has ended.\n    modifier onlyBeforeAllocationEnds() {\n        _checkOnlyBeforeAllocationEnds();\n        _;\n    }\n\n    /// ====================================\n    /// ========== Constructor =============\n    /// ====================================\n\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ====================================\n    /// =========== Initialize =============\n    /// ====================================\n\n    /// @notice Initialize the strategy\n    /// @param _poolId The ID of the pool\n    /// @param _data The initialization data for the strategy\n    function initialize(uint256 _poolId, bytes memory _data) external virtual;\n\n    /// @notice Internal initialize function\n    /// @param _poolId The ID of the pool\n    /// @param _params The initialize params for the strategy\n    function __QVBaseStrategy_init(uint256 _poolId, InitializeParams memory _params) internal {\n        __BaseStrategy_init(_poolId);\n\n        registryGating = _params.registryGating;\n        metadataRequired = _params.metadataRequired;\n        _registry = allo.getRegistry();\n\n        reviewThreshold = _params.reviewThreshold;\n\n        _updatePoolTimestamps(\n            _params.registrationStartTime,\n            _params.registrationEndTime,\n            _params.allocationStartTime,\n            _params.allocationEndTime\n        );\n    }\n\n    /// =========================\n    /// ==== View Functions =====\n    /// =========================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Get recipient status\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view virtual override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Checks if a pool is active or not\n    /// @return Whether the pool is active or not\n    function _isPoolActive() internal view virtual override returns (bool) {\n        if (registrationStartTime <= block.timestamp && block.timestamp <= registrationEndTime) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Review recipient(s) application(s)\n    /// @dev You can review multiple recipients at once or just one. This can only be called by a pool manager and\n    ///      only during active registration.\n    /// @param _recipientIds Ids of the recipients\n    /// @param _recipientStatuses Statuses of the recipients\n    function reviewRecipients(address[] calldata _recipientIds, Status[] calldata _recipientStatuses)\n        external\n        virtual\n        onlyPoolManager(msg.sender)\n        onlyBeforeAllocationEnds\n    {\n        // make sure the arrays are the same length\n        uint256 recipientLength = _recipientIds.length;\n        if (recipientLength != _recipientStatuses.length) revert INVALID();\n\n        for (uint256 i; i < recipientLength;) {\n            Status recipientStatus = _recipientStatuses[i];\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n            uint256 applicationId = recipient.applicationId;\n\n            // if the status is none or appealed then revert\n            if (recipientStatus == Status.None || recipientStatus == Status.Appealed) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            if (reviewedByManager[recipientId][applicationId][msg.sender] > Status.None) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            // track the review cast for the recipient and update status counter\n            reviewedByManager[recipientId][applicationId][msg.sender] = recipientStatus;\n            reviewsByStatus[recipientId][applicationId][recipientStatus]++;\n\n            // update the recipient status if the review threshold has been reached\n            if (reviewsByStatus[recipientId][applicationId][recipientStatus] >= reviewThreshold) {\n                recipient.recipientStatus = recipientStatus;\n\n                emit RecipientStatusUpdated(recipientId, applicationId, recipientStatus, address(0));\n            }\n\n            emit Reviewed(recipientId, applicationId, recipientStatus, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) external onlyPoolManager(msg.sender) {\n        _updatePoolTimestamps(_registrationStartTime, _registrationEndTime, _allocationStartTime, _allocationEndTime);\n    }\n\n    /// @notice Withdraw the tokens from the pool\n    /// @dev Callable by the pool manager only 30 days after the allocation has ended\n    /// @param _token The token to withdraw\n    function withdraw(address _token) external onlyPoolManager(msg.sender) {\n        if (block.timestamp <= allocationEndTime + 30 days) {\n            revert INVALID();\n        }\n\n        uint256 amount = _getBalance(_token, address(this));\n\n        // Transfer the tokens to the 'msg.sender' (pool manager calling function)\n        _transferAmount(_token, msg.sender, amount);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Check if the registration is active\n    /// @dev Reverts if the registration is not active\n    function _checkOnlyActiveRegistration() internal view virtual {\n        if (registrationStartTime > block.timestamp || block.timestamp > registrationEndTime) {\n            revert REGISTRATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation is active\n    /// @dev Reverts if the allocation is not active\n    function _checkOnlyActiveAllocation() internal view virtual {\n        if (allocationStartTime > block.timestamp || block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Check if the allocation has ended\n    /// @dev Reverts if the allocation has not ended\n    function _checkOnlyAfterAllocation() internal view virtual {\n        if (block.timestamp <= allocationEndTime) revert ALLOCATION_NOT_ENDED();\n    }\n\n    /// @notice Checks if the allocation has not ended and reverts if it has.\n    /// @dev This will revert if the allocation has ended.\n    function _checkOnlyBeforeAllocationEnds() internal view {\n        if (block.timestamp > allocationEndTime) {\n            revert ALLOCATION_NOT_ACTIVE();\n        }\n    }\n\n    /// @notice Set the start and end dates for the pool\n    /// @param _registrationStartTime The start time for the registration\n    /// @param _registrationEndTime The end time for the registration\n    /// @param _allocationStartTime The start time for the allocation\n    /// @param _allocationEndTime The end time for the allocation\n    function _updatePoolTimestamps(\n        uint64 _registrationStartTime,\n        uint64 _registrationEndTime,\n        uint64 _allocationStartTime,\n        uint64 _allocationEndTime\n    ) internal {\n        // validate the timestamps for this strategy\n        if (\n            block.timestamp > _registrationStartTime || _registrationStartTime > _registrationEndTime\n                || _registrationStartTime > _allocationStartTime || _allocationStartTime > _allocationEndTime\n                || _registrationEndTime > _allocationEndTime\n        ) {\n            revert INVALID();\n        }\n\n        // Set the new values\n        registrationStartTime = _registrationStartTime;\n        registrationEndTime = _registrationEndTime;\n        allocationStartTime = _allocationStartTime;\n        allocationEndTime = _allocationEndTime;\n\n        // emit the event\n        emit TimestampsUpdated(\n            registrationStartTime, registrationEndTime, allocationStartTime, allocationEndTime, msg.sender\n        );\n    }\n\n    /// @notice Submit application to pool\n    /// @dev The '_data' parameter is encoded as follows:\n    ///     - If registryGating is true, then the data is encoded as (address recipientId, address recipientAddress, Metadata metadata)\n    ///     - If registryGating is false, then the data is encoded as (address recipientAddress, address registryAnchor, Metadata metadata)\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The ID of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        onlyActiveRegistration\n        returns (address recipientId)\n    {\n        address recipientAddress;\n        address registryAnchor;\n        bool isUsingRegistryAnchor;\n\n        Metadata memory metadata;\n\n        // decode data custom to this strategy\n        if (registryGating) {\n            (recipientId, recipientAddress, metadata) = abi.decode(_data, (address, address, Metadata));\n\n            // when registry gating is enabled, the recipientId must be a profile member\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            (recipientAddress, registryAnchor, metadata) = abi.decode(_data, (address, address, Metadata));\n            isUsingRegistryAnchor = registryAnchor != address(0);\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // when using registry anchor, the ID of the recipient must be a profile member\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // make sure that if metadata is required, it is provided\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        // make sure the recipient address is not the zero address\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        Recipient storage recipient = recipients[recipientId];\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.metadata = metadata;\n        recipient.useRegistryAnchor = registryGating ? true : isUsingRegistryAnchor;\n        ++recipient.applicationId;\n\n        Status currentStatus = recipient.recipientStatus;\n\n        if (currentStatus == Status.None) {\n            // recipient registering new application\n            recipient.recipientStatus = Status.Pending;\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            // recipient updating rejected/pending/appealed/accepted application\n            if (currentStatus == Status.Rejected) {\n                recipient.recipientStatus = Status.Appealed;\n            } else if (currentStatus == Status.Accepted) {\n                // recipient updating already accepted application\n                recipient.recipientStatus = Status.Pending;\n            }\n\n            // emit the new status with the '_data' that was passed in\n            emit UpdatedRegistration(recipientId, recipient.applicationId, _data, _sender, recipient.recipientStatus);\n        }\n    }\n\n    /// @notice Distribute the tokens to the recipients\n    /// @dev The '_sender' must be a pool manager and the allocation must have ended\n    /// @param _recipientIds The recipient ids\n    /// @param _sender The sender of the transaction\n    function _distribute(address[] memory _recipientIds, bytes memory, address _sender)\n        internal\n        virtual\n        override\n        onlyPoolManager(_sender)\n        onlyAfterAllocation\n    {\n        uint256 payoutLength = _recipientIds.length;\n        for (uint256 i; i < payoutLength;) {\n            address recipientId = _recipientIds[i];\n            Recipient storage recipient = recipients[recipientId];\n\n            PayoutSummary memory payout = _getPayout(recipientId, \"\");\n            uint256 amount = payout.amount;\n\n            if (paidOut[recipientId] || !_isAcceptedRecipient(recipientId) || amount == 0) {\n                revert RECIPIENT_ERROR(recipientId);\n            }\n\n            IAllo.Pool memory pool = allo.getPool(poolId);\n            _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n            paidOut[recipientId] = true;\n\n            emit Distributed(recipientId, recipient.recipientAddress, amount, _sender);\n            unchecked {\n                ++i;\n            }\n        }\n        if (!distributionStarted) {\n            distributionStarted = true;\n        }\n    }\n\n    /// @notice Check if sender is a profile member\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return If the '_sender' is a profile member\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Getter for a recipient using the ID\n    /// @param _recipientId ID of the recipient\n    /// @return The recipient\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory) {\n        return recipients[_recipientId];\n    }\n\n    /// ====================================\n    /// ============ QV Helper ==============\n    /// ====================================\n\n    /// @notice Calculate the square root of a number (Babylonian method)\n    /// @param x The number\n    /// @return y The square root\n    function _sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /// @notice Allocate voice credits to a recipient\n    /// @dev This can only be called during active allocation period\n    /// @param _allocator The allocator details\n    /// @param _recipient The recipient details\n    /// @param _recipientId The ID of the recipient\n    /// @param _voiceCreditsToAllocate The voice credits to allocate to the recipient\n    /// @param _sender The sender of the transaction\n    function _qv_allocate(\n        Allocator storage _allocator,\n        Recipient storage _recipient,\n        address _recipientId,\n        uint256 _voiceCreditsToAllocate,\n        address _sender\n    ) internal onlyActiveAllocation {\n        // check the `_voiceCreditsToAllocate` is > 0\n        if (_voiceCreditsToAllocate == 0) revert INVALID();\n\n        // check if the recipient is accepted\n        if (!_isAcceptedRecipient(_recipientId)) revert RECIPIENT_ERROR(_recipientId);\n\n        // update the allocator voice credits\n        _allocator.voiceCredits += _voiceCreditsToAllocate;\n\n        // creditsCastToRecipient is the voice credits used to cast a vote to the recipient\n        // votesCastToRecipient is the actual votes cast to the recipient\n        uint256 creditsCastToRecipient = _allocator.voiceCreditsCastToRecipient[_recipientId];\n        uint256 votesCastToRecipient = _allocator.votesCastToRecipient[_recipientId];\n\n        // get the total credits and calculate the vote result\n        uint256 totalCredits = _voiceCreditsToAllocate + creditsCastToRecipient;\n        // determine actual votes cast\n        uint256 voteResult = _sqrt(totalCredits * 1e18);\n\n        // update the values\n        voteResult -= votesCastToRecipient;\n        totalRecipientVotes += voteResult;\n        _recipient.totalVotesReceived += voteResult;\n\n        _allocator.voiceCreditsCastToRecipient[_recipientId] += _voiceCreditsToAllocate;\n        _allocator.votesCastToRecipient[_recipientId] += voteResult;\n\n        // emit the event with the vote results\n        emit Allocated(_recipientId, voteResult, _sender);\n    }\n\n    /// @notice Returns if the recipient is accepted\n    /// @param _recipientId The recipient id\n    /// @return If the recipient is accepted\n    function _isAcceptedRecipient(address _recipientId) internal view virtual returns (bool);\n\n    /// @notice Checks if the allocator is valid\n    /// @param _allocator The allocator address\n    /// @return If the allocator is valid\n    function _isValidAllocator(address _allocator) internal view virtual override returns (bool);\n\n    /// @notice Checks if the allocator has voice credits left\n    /// @param _voiceCreditsToAllocate The voice credits to allocate\n    /// @param _allocatedVoiceCredits The allocated voice credits\n    /// @return If the allocator has voice credits left\n    function _hasVoiceCreditsLeft(uint256 _voiceCreditsToAllocate, uint256 _allocatedVoiceCredits)\n        internal\n        view\n        virtual\n        returns (bool);\n\n    /// @notice Get the payout for a single recipient\n    /// @param _recipientId The ID of the recipient\n    /// @return The payout as a 'PayoutSummary' struct\n    function _getPayout(address _recipientId, bytes memory)\n        internal\n        view\n        virtual\n        override\n        returns (PayoutSummary memory)\n    {\n        Recipient memory recipient = recipients[_recipientId];\n\n        // Calculate the payout amount based on the percentage of total votes\n        uint256 amount;\n        if (!paidOut[_recipientId] && totalRecipientVotes != 0) {\n            amount = poolAmount * recipient.totalVotesReceived / totalRecipientVotes;\n        }\n        return PayoutSummary(recipient.recipientAddress, amount);\n    }\n\n    function _beforeIncreasePoolAmount(uint256) internal virtual override {\n        if (distributionStarted) {\n            revert INVALID();\n        }\n    }\n\n    /// @notice Contract should be able to receive NATIVE\n    receive() external payable {}\n}"
    }
  ]
}