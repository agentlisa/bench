{
  "Title": "M-6: Withdrawal caps can be bypassed by opening positions against the SpotHedgeBaseMaker",
  "Content": "# Issue M-6: Withdrawal caps can be bypassed by opening positions against the SpotHedgeBaseMaker \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/117 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nIllIllI\n## Summary\n\nDeposits/withdrawals of base tokens to the SpotHedgeBaseMaker aren't accounted for in the CircuitBreaker's accounting, so the tokens can be used by attackers to increase the amount withdrawable past the high water mark percentage limits.\n\n\n## Vulnerability Detail\n\nThe SpotHedgeBaseMaker allows LPs to deposit base tokens in exchange for shares. The CircuitBreaker doesn't include base tokens in its accounting, until they're converted to quote tokens and added to the vault, which happens when someone opens a short base position, and the SpotHedgeBaseMaker needs to hedge its corresponding long base position, by swapping base tokens for the quote token. The CircuitBreaker keeps track of net deposits/withdrawals of the quote token using a high water mark system, in which the high water mark isn't updated until the sync interval has passed. As long as the _net_ outflow between sync intervals doesn't pass the threshold, withdrawals are allowed.\n\n\n## Impact\n\nAssume there is some sort of exploit, where the attacker is able to artificially inflate their 'fund' amount (e.g. one of my other submissions), and are looking to withdraw their ill-gotten gains. Normally, the amount they'd be able to withdraw would be limited to X% of the TVL of collateral tokens in the vault. By converting some of their 'fund' to margin, and opening huge short base positions against the SpotHedgeBaseMaker, they can cause the SpotHedgeBaseMaker to swap its contract balance of base tokens into collateral tokens, and deposit them into its vault account, increasing the TVL to TVL+Y. Since the time-based threshold will still be the old TVL, they're now able to withdraw `TVL.old * X% + Y`, rather than just `TVL.old * X%`. Depending on the price band limits set for swaps, the attacker can use a flash loan to temporarily skew the base/quote UniswapV3 exchange rate, such that the swap nets a much larger number of quote tokens than would normally be available to trade for. This means that if the 'fund' amount that the attacker has control over is larger than the actual number of collateral tokens in the vault, the attacker can potentially withdraw 100% of the TVL.\n\n\n## Code Snippet\n\nQuote tokens acquired via the swap are deposited into the [vault](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L571), which passes them through the [CircuitBreaker](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/vault/Vault.sol#L339):\n```solidity\n// File: src/maker/SpotHedgeBaseMaker.sol : SpotHedgeBaseMaker.fillOrder()   #1\n\n415                } else {\n416                    quoteTokenAcquired = _formatPerpToSpotQuoteDecimals(amount);\n417 @>                 uint256 oppositeAmountXSpotDecimals = _uniswapV3ExactOutput(\n418                        UniswapV3ExactOutputParams({\n419                            tokenIn: address(_getSpotHedgeBaseMakerStorage().baseToken),\n420                            tokenOut: address(_getSpotHedgeBaseMakerStorage().quoteToken),\n421                            path: path,\n422                            recipient: maker,\n423                            amountOut: quoteTokenAcquired,\n424                            amountInMaximum: _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker)\n425                        })\n426                    );\n427                    oppositeAmount = _formatSpotToPerpBaseDecimals(oppositeAmountXSpotDecimals);\n428                    // Currently we don't utilize fillOrderCallback for B2Q swaps,\n429                    // but we still populate the arguments anyways.\n430                    fillOrderCallbackData.amountXSpotDecimals = quoteTokenAcquired;\n431                    fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n432                }\n433    \n434                // Deposit the acquired quote tokens to Vault.\n435:@>             _deposit(vault, _marketId, quoteTokenAcquired);\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L405-L442\n\nThe CircuitBreaker only tracks [net liqInPeriod changes](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/circuitBreaker/LibLimiter.sol#L39-L49) changes during the withdrawal period, and only triggers the CircuitBreaker based on the TVL older than the withdrawal period:\n\n```solidity\n// File: src/circuitBreaker/LibLimiter.sol : LibLimiter.status()   #2\n\n119            int256 currentLiq = limiter.liqTotal;\n...\n126 @>         int256 futureLiq = currentLiq + limiter.liqInPeriod;\n127            // NOTE: uint256 to int256 conversion here is safe\n128            int256 minLiq = (currentLiq * int256(limiter.minLiqRetainedBps)) / int256(BPS_DENOMINATOR);\n129    \n130 @>         return futureLiq < minLiq ? LimitStatus.Triggered : LimitStatus.Ok;\n131:       }\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/circuitBreaker/LibLimiter.sol#L119-L131\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nCalculate the quote-token value of each base token during LP `deposit()`/`withdraw()`, and add those amounts as CircuitBreaker flows during `deposit()`/`withdraw()`, then also invert those flows prior to depositing into/withdrawing from the vault\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium/Low - Attacker would have to open a big short position against SpotHedgeBaseMaker during some time, exposing itself to losses due to price changes\n\n\n\n**tailingchen**\n\nValid but won't fix.\n\nAlthough circuit breaker can be bypassed, it still depends on the liquidity of SpotHedgeBaseMaker and the price band.\nThe team prefers not to fix it in the early stages. \n\nIf the team want to fix it in the future, we have discussed several possible solutions. These solutions all have some pros and cons. The team is still evaluating possible options.\n1. Separately calculate inflows and outflows for the same period. Only previous TVL is taken.\n2. Do not include whitelisted makerâ€™s deposit into TVL calculations.\n3. Let SHBM check the current rate limit status of CircuitBreaker before depositing collateral into the vault. If the remaining balance that can be withdrawn is too small, it means that the current vault risk is too high and there is a risk that it cannot be withdrawn. Therefore, SHBM can refuse this position opening.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IMaker } from \"./IMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { IUniswapV3Factory } from \"../external/uniswap-v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport { ISwapRouter } from \"../external/uniswap-v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport { IQuoter } from \"../external/uniswap-v3-periphery/contracts/interfaces/IQuoter.sol\";\nimport { Path } from \"../external/uniswap-v3-periphery/contracts/libraries/Path.sol\";\nimport { BytesLib } from \"../external/uniswap-v3-periphery/contracts/libraries/BytesLib.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { IWhitelistLpManager } from \"./IWhitelistLpManager.sol\";\n\ncontract SpotHedgeBaseMaker is\n    ContextBase,\n    AddressResolverUpgradeable,\n    Ownable2StepUpgradeable,\n    ERC20Upgradeable,\n    IMaker\n{\n    using SafeERC20 for IERC20Metadata;\n    using BytesLib for bytes;\n    using Path for bytes;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using LibFormatter for uint256;\n    using LibFormatter for int256;\n    using FixedPointMathLib for uint256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.spotHedgeBaseMaker\n    struct SpotHedgeBaseMakerStorage {\n        uint256 marketId;\n        IERC20Metadata baseToken;\n        IERC20Metadata quoteToken;\n        uint8 baseTokenDecimals;\n        uint8 quoteTokenDecimals;\n        // UniswapV3 related\n        ISwapRouter uniswapV3Router;\n        IUniswapV3Factory uniswapV3Factory;\n        IQuoter uniswapV3Quoter;\n        // Key is a function of (tokenIn, tokenOut).\n        // However, note that since Uniswap's SwapRouter.exactOutput() takes path in reversed order,\n        // one should switch the key's tokenIn and tokenOut when querying paths for exactOutput calls.\n        mapping(bytes32 => bytes) uniswapV3PathMap;\n        // Internal ledger\n        uint256 baseTokenLiability;\n        uint256 minMarginRatio; // Min. marign ratio required by the maker at all time.\n    }\n\n    struct UniswapV3ExactInputParams {\n        address tokenIn;\n        address tokenOut;\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct UniswapV3ExactOutputParams {\n        address tokenIn;\n        address tokenOut;\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct FillOrderCallbackData {\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amountXSpotDecimals;\n        uint256 oppositeAmountXSpotDecimals;\n    }\n\n    //\n    // Event\n    //\n\n    event Deposited(\n        address depositor,\n        uint256 shares, // Amount of share minted\n        uint256 underlying // Amount of underlying token deposited\n    );\n\n    event Withdrawn(\n        address withdrawer,\n        uint256 shares, // Amount of shares burnt\n        uint256 baseAmount, // Amount of base tokens withdrawn from maker contract\n        uint256 quoteAmount // Amount of quote tokens withdrawn from maker's Perp position\n    );\n\n    event UniswapV3RouterSet(address newUniswapV3Router, address oldUniswapV3Router);\n    event UniswapV3FactorySet(address newUniswapV3Factory, address oldUniswapV3Factory);\n    event UniswapV3QuoterSet(address newUniswapV3Quoter, address oldUniswapV3Quoter);\n\n    // solhint-disable-next-line max-line-length\n    // Forked from https://github.com/perpetual-protocol/kantaban-contract/blob/18e0c1fe16490ccc9cbf0d9514e2204964f31624/contracts/interface/IRouterEvent.sol#L6-L13\n    /**\n     * @dev Emitted when UniswapV3 multihop path of tokenIn/tokenOut pair is changed\n     * @param tokenIn The address of tokenIn\n     * @param tokenOut The address of tokenOut\n     * @param oldPath The old UniswapV3 multihop path\n     * @param newPath The new UniswapV3 multihop path\n     */\n    event UniswapV3PathSet(address tokenIn, address tokenOut, bytes newPath, bytes oldPath);\n\n    event MinMarginRatioSet(uint256 newMinMarginRatio, uint256 oldMinMarginRatio);\n\n    event SHMOrderFilled(\n        uint256 marketId,\n        bytes path,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 targetAmount, // in INTERNAL_DECIMALS\n        uint256 oppositeAmount, // in INTERNAL_DECIMALS\n        uint256 spread // In percentage (1e6 = 100%)\n    );\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.spotHedgeBaseMaker\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _SPOT_HEDGE_BASE_MAKER_STORAGE_LOCATION =\n        0xaa0ea57ca6018b18cb09d20625ac40a68ba646a22caa4398d37ac2dfe2dc7500;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyWhitelistLp() {\n        IWhitelistLpManager whitelistManager = getAddressManager().getWhitelistLpManager();\n        if (address(whitelistManager) != address(0)) {\n            if (!whitelistManager.isLpWhitelisted(_sender())) revert LibError.Unauthorized();\n        }\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 marketId_,\n        string memory name_,\n        string memory symbol_,\n        address addressManager_,\n        address uniswapV3Router_,\n        address uniswapV3Factory_,\n        address uniswapV3Quoter_,\n        address baseToken_,\n        uint256 minMarginRatio_\n    ) external initializer {\n        __AddressResolver_init(addressManager_);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n        __ERC20_init(name_, symbol_);\n\n        SpotHedgeBaseMakerStorage storage $ = _getSpotHedgeBaseMakerStorage();\n\n        $.marketId = marketId_;\n\n        setUniswapV3Router(uniswapV3Router_);\n        setUniswapV3Factory(uniswapV3Factory_);\n        setUniswapV3Quoter(uniswapV3Quoter_);\n\n        $.baseToken = IERC20Metadata(baseToken_);\n        $.baseTokenDecimals = IERC20Metadata($.baseToken).decimals();\n        $.quoteToken = IERC20Metadata(_getVault().getCollateralToken());\n        $.quoteTokenDecimals = IERC20Metadata($.quoteToken).decimals();\n\n        setMinMarginRatio(minMarginRatio_);\n    }\n\n    function setUniswapV3Router(address _uniswapV3Router) public onlyOwner {\n        if (_uniswapV3Router == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Router = address(_getSpotHedgeBaseMakerStorage().uniswapV3Router);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Router = ISwapRouter(_uniswapV3Router);\n\n        emit UniswapV3RouterSet(_uniswapV3Router, oldUniswapV3Router);\n    }\n\n    function setUniswapV3Factory(address _uniswapV3Factory) public onlyOwner {\n        if (_uniswapV3Factory == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Factory = address(_getSpotHedgeBaseMakerStorage().uniswapV3Factory);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Factory = IUniswapV3Factory(_uniswapV3Factory);\n\n        emit UniswapV3FactorySet(_uniswapV3Factory, oldUniswapV3Factory);\n    }\n\n    function setUniswapV3Quoter(address _uniswapV3Quoter) public onlyOwner {\n        if (_uniswapV3Quoter == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Quoter = address(_getSpotHedgeBaseMakerStorage().uniswapV3Quoter);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Quoter = IQuoter(_uniswapV3Quoter);\n\n        emit UniswapV3QuoterSet(_uniswapV3Quoter, oldUniswapV3Quoter);\n    }\n\n    // solhint-disable-next-line max-line-length\n    // Forked from https://github.com/perpetual-protocol/kantaban-contract/blob/18e0c1fe16490ccc9cbf0d9514e2204964f31624/contracts/Router.sol#L33-L45\n    function setUniswapV3Path(address tokenIn, address tokenOut, bytes calldata path) external onlyOwner {\n        _verifyPath(tokenIn, tokenOut, path);\n\n        bytes32 key = _getKey(tokenIn, tokenOut);\n        bytes memory oldPath = _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[key];\n        _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[key] = path;\n\n        emit UniswapV3PathSet(tokenIn, tokenOut, path, oldPath);\n    }\n\n    function setMinMarginRatio(uint256 _minMarginRatio) public onlyOwner {\n        if (_minMarginRatio > WAD) {\n            revert LibError.InvalidRatio(_minMarginRatio);\n        }\n        if (_minMarginRatio == 0) {\n            revert LibError.ZeroRatio();\n        }\n        uint256 oldMinMarginRatio = _getSpotHedgeBaseMakerStorage().minMarginRatio;\n        _getSpotHedgeBaseMakerStorage().minMarginRatio = _minMarginRatio;\n\n        emit MinMarginRatioSet(_minMarginRatio, oldMinMarginRatio);\n    }\n\n    function deposit(uint256 amountXBD) external onlyWhitelistLp returns (uint256) {\n        address lp = _sender();\n        address maker = address(this);\n\n        if (amountXBD == 0) revert LibError.ZeroAmount();\n\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amountXBD;\n        } else {\n            // TODO Should consider slippage once maker has spread or other pricing logic.\n            // For now, we will just get account value from ClearingHouse (assume no slippages).\n            // shares per asset = share (share token precision) / (accountValue (INTERNAL_DECIMALS) / basePrice (pyth precision) + baseBalance (base token precision))\n            // shares (share token precision) =  assets (base token precision) * shares per asset\n\n            // TODO: We should add protections to prevent attackers from manipulating the share price by manipulating oracle reported price.\n            // This is because the attacker could potentially mint large amount of shares by forcing the share price low.\n            // Possible protections like rate limiting share price, or any kind of volatility check.\n\n            uint8 shareDecimals = decimals();\n            uint256 vaultValueInBaseXShareDecimals = _getVaultValueInBaseSafe(_getVault(), _getPrice()).formatDecimals(\n                INTERNAL_DECIMALS,\n                shareDecimals\n            );\n\n            shares =\n                (amountXBD.formatDecimals(_getSpotHedgeBaseMakerStorage().baseTokenDecimals, shareDecimals) *\n                    totalSupply()) /\n                vaultValueInBaseXShareDecimals;\n        }\n\n        uint256 balanceBefore = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker);\n        _getSpotHedgeBaseMakerStorage().baseToken.safeTransferFrom(_sender(), maker, amountXBD);\n        uint256 transferredAmount = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker) - balanceBefore;\n\n        if (transferredAmount != amountXBD) {\n            revert LibError.WrongTransferAmount(transferredAmount, amountXBD);\n        }\n\n        _getSpotHedgeBaseMakerStorage().baseTokenLiability += amountXBD;\n\n        _mint(lp, shares);\n\n        emit Deposited(lp, shares, amountXBD);\n\n        return shares;\n    }\n\n    function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256 baseAmount, uint256 quoteAmount) {\n        address lp = _sender();\n        address maker = address(this);\n        IVault vault = _getVault();\n\n        if (shares == 0) revert LibError.ZeroAmount();\n\n        // Must done before burn.\n        uint256 redeemedRatio = shares.divWad(totalSupply()); // in ratio decimals 18\n\n        // Revert early if shares amount exceeds balance\n        _burn(lp, shares);\n\n        _getSpotHedgeBaseMakerStorage().baseTokenLiability -= _getSpotHedgeBaseMakerStorage().baseTokenLiability.mulWad(\n            redeemedRatio\n        );\n\n        uint256 price = _getPrice();\n        uint256 vaultValueInBase = _getVaultValueInBaseSafe(vault, price);\n        uint256 withdrawnBaseAmount = vaultValueInBase.mulWad(redeemedRatio).formatDecimals(\n            INTERNAL_DECIMALS,\n            _getSpotHedgeBaseMakerStorage().baseTokenDecimals\n        );\n\n        uint256 withdrawnQuoteAmount = 0;\n\n        uint256 spotBaseBalance = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker);\n\n        if (withdrawnBaseAmount > spotBaseBalance) {\n            if (vault.getPositionSize(_getSpotHedgeBaseMakerStorage().marketId, maker) != 0) {\n                revert LibError.NotEnoughSpotBaseTokens(withdrawnBaseAmount, spotBaseBalance);\n            } else {\n                withdrawnQuoteAmount = (withdrawnBaseAmount - spotBaseBalance).mulWad(price).formatDecimals(\n                    _getSpotHedgeBaseMakerStorage().baseTokenDecimals,\n                    _getSpotHedgeBaseMakerStorage().quoteTokenDecimals\n                );\n                withdrawnBaseAmount = FixedPointMathLib.min(withdrawnBaseAmount, spotBaseBalance);\n            }\n        }\n\n        if (withdrawnBaseAmount > 0) {\n            _getSpotHedgeBaseMakerStorage().baseToken.safeTransfer(lp, withdrawnBaseAmount);\n        }\n        if (withdrawnQuoteAmount > 0) {\n            // withdrawnQuoteAmount is calculated base on freeCollateral, and since all conversions are round-down,\n            // we can safely assume withdrawnQuoteAmount <= freeCollateral and the withdraw should always pass.\n            // It may not be possible to withdraw the required amount, due to unsettledPnl that cannot be settled totally.\n            _withdraw(vault, _getSpotHedgeBaseMakerStorage().marketId, withdrawnQuoteAmount);\n            _getSpotHedgeBaseMakerStorage().quoteToken.safeTransfer(lp, withdrawnQuoteAmount);\n        }\n\n        emit Withdrawn(lp, shares, withdrawnBaseAmount, withdrawnQuoteAmount);\n\n        return (withdrawnBaseAmount, withdrawnQuoteAmount);\n    }\n\n    function fillOrderCallback(bytes calldata _data) external onlyClearingHouse {\n        FillOrderCallbackData memory data = abi.decode(_data, (FillOrderCallbackData));\n        _fillOrderCallback(data);\n        _checkMinMarginRatio(_getPrice());\n    }\n\n    function fillOrder(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bytes calldata\n    ) external onlyClearingHouse returns (uint256, bytes memory) {\n        IVault vault = _getVault();\n        uint256 _marketId = _getSpotHedgeBaseMakerStorage().marketId;\n        address maker = address(this);\n\n        // Taker perp - maker uniswap matrix:\n        //\n        //                      perp B->Q                   perp Q->B\n        // perp exact input     spot B->Q exact input       spot Q->B exact input\n        // perp exact output    spot B->Q exact output      spot Q->B exact output\n\n        FillOrderCallbackData memory fillOrderCallbackData = FillOrderCallbackData({\n            isBaseToQuote: isBaseToQuote,\n            isExactInput: isExactInput,\n            amountXSpotDecimals: 0, // TBD\n            oppositeAmountXSpotDecimals: 0 // TBD\n        });\n\n        uint256 oppositeAmount;\n        bytes memory path;\n        if (isBaseToQuote) {\n            uint256 quoteTokenAcquired = 0;\n            path = _getPath(\n                address(_getSpotHedgeBaseMakerStorage().baseToken),\n                address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                isExactInput\n            );\n\n            if (isExactInput) {\n                uint256 baseTokenRequired = _formatPerpToSpotBaseDecimals(amount);\n                quoteTokenAcquired = _uniswapV3ExactInput(\n                    UniswapV3ExactInputParams({\n                        tokenIn: address(_getSpotHedgeBaseMakerStorage().baseToken),\n                        tokenOut: address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                        path: path,\n                        recipient: maker,\n                        amountIn: baseTokenRequired,\n                        amountOutMinimum: 0\n                    })\n                );\n                oppositeAmount = _formatSpotToPerpQuoteDecimals(quoteTokenAcquired);\n                // Currently we don't utilize fillOrderCallback for B2Q swaps,\n                // but we still populate the arguments anyways.\n                fillOrderCallbackData.amountXSpotDecimals = baseTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = quoteTokenAcquired;\n            } else {\n                quoteTokenAcquired = _formatPerpToSpotQuoteDecimals(amount);\n                uint256 oppositeAmountXSpotDecimals = _uniswapV3ExactOutput(\n                    UniswapV3ExactOutputParams({\n                        tokenIn: address(_getSpotHedgeBaseMakerStorage().baseToken),\n                        tokenOut: address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                        path: path,\n                        recipient: maker,\n                        amountOut: quoteTokenAcquired,\n                        amountInMaximum: _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker)\n                    })\n                );\n                oppositeAmount = _formatSpotToPerpBaseDecimals(oppositeAmountXSpotDecimals);\n                // Currently we don't utilize fillOrderCallback for B2Q swaps,\n                // but we still populate the arguments anyways.\n                fillOrderCallbackData.amountXSpotDecimals = quoteTokenAcquired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            }\n\n            // Deposit the acquired quote tokens to Vault.\n            _deposit(vault, _marketId, quoteTokenAcquired);\n        } else {\n            // Note we only quote amountIn/Out here and do the swap later in callback.\n            // It is because we are not sure how much USDC the maker could withdraw yet,\n            // because there are potential PnL to be realized after fillOrder(), after the positions are settled,\n            // which may change the maker's free USDC. If we withdraw now, chances are the maker could fall below\n            // margin requirement after PnLs are realized, or the maker might not have enough USDC to\n            // withdraw yet unless we wait until the PnLs are realized.\n            // The best solution is to defer the withdrawal to the callback and withdraw only after\n            // the positions are settled and PnLs are realized.\n            path = _getPath(\n                address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                address(_getSpotHedgeBaseMakerStorage().baseToken),\n                isExactInput\n            );\n\n            if (isExactInput) {\n                uint256 quoteTokenRequired = _formatPerpToSpotQuoteDecimals(amount);\n                // get quote\n                uint256 oppositeAmountXSpotDecimals = _getSpotHedgeBaseMakerStorage().uniswapV3Quoter.quoteExactInput(\n                    path,\n                    quoteTokenRequired\n                );\n                oppositeAmount = _formatSpotToPerpBaseDecimals(oppositeAmountXSpotDecimals);\n\n                fillOrderCallbackData.amountXSpotDecimals = quoteTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            } else {\n                uint256 baseTokenRequired = _formatPerpToSpotBaseDecimals(amount);\n                // get quote\n                uint256 oppositeAmountXSpotDecimals = _getSpotHedgeBaseMakerStorage().uniswapV3Quoter.quoteExactOutput(\n                    path,\n                    baseTokenRequired\n                );\n                oppositeAmount = _formatSpotToPerpQuoteDecimals(oppositeAmountXSpotDecimals);\n\n                fillOrderCallbackData.amountXSpotDecimals = baseTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            }\n        }\n\n        emit SHMOrderFilled(\n            _getSpotHedgeBaseMakerStorage().marketId,\n            path,\n            isBaseToQuote,\n            isExactInput,\n            amount, // targetAmount\n            oppositeAmount,\n            0 // spread\n        );\n\n        return (oppositeAmount, abi.encode(fillOrderCallbackData));\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function getUniswapV3Path(address tokenIn, address tokenOut) external view returns (bytes memory) {\n        return _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[_getKey(tokenIn, tokenOut)];\n    }\n\n    // Ratio decimals = INTERNAL_DECIMALS\n    function getUtilRatio() external view returns (uint256, uint256) {\n        if (_getSpotHedgeBaseMakerStorage().baseTokenLiability == 0) {\n            return (0, 0);\n        }\n\n        // shortCapacityRatio = BaseBalance / BaseLiability\n        uint256 shortCapacityRatio = (WAD * _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(address(this))) /\n            _getSpotHedgeBaseMakerStorage().baseTokenLiability;\n\n        uint256 shortUtilRatio;\n        if ((WAD >= shortCapacityRatio)) {\n            shortUtilRatio = WAD - shortCapacityRatio;\n        }\n        return (0, shortUtilRatio);\n    }\n\n    function isValidSender(address) external pure override returns (bool) {\n        return true;\n    }\n\n    function getAsset() external view returns (address) {\n        return address(_getSpotHedgeBaseMakerStorage().baseToken);\n    }\n\n    function getTotalAssets(uint256 price) external view returns (int256) {\n        return\n            _getVaultValueInBase(_getVault(), price).formatDecimals(\n                INTERNAL_DECIMALS,\n                _getSpotHedgeBaseMakerStorage().baseToken.decimals()\n            );\n    }\n\n    // For backward-compatibility\n    function marketId() external view returns (uint256) {\n        return _getSpotHedgeBaseMakerStorage().marketId;\n    }\n\n    // For backward-compatibility\n    function baseToken() external view returns (IERC20Metadata) {\n        return _getSpotHedgeBaseMakerStorage().baseToken;\n    }\n\n    // For backward-compatibility\n    function quoteToken() external view returns (IERC20Metadata) {\n        return _getSpotHedgeBaseMakerStorage().quoteToken;\n    }\n\n    // For backward-compatibility\n    function baseTokenDecimals() external view returns (uint8) {\n        return _getSpotHedgeBaseMakerStorage().baseTokenDecimals;\n    }\n\n    // For backward-compatibility\n    function quoteTokenDecimals() external view returns (uint8) {\n        return _getSpotHedgeBaseMakerStorage().quoteTokenDecimals;\n    }\n\n    // For backward-compatibility\n    function baseTokenLiability() external view returns (uint256) {\n        return _getSpotHedgeBaseMakerStorage().baseTokenLiability;\n    }\n\n    // For backward-compatibility\n    function minMarginRatio() external view returns (uint256) {\n        return _getSpotHedgeBaseMakerStorage().minMarginRatio;\n    }\n\n    //\n    // INTERNAL NON-VIEW\n    //\n\n    function _deposit(IVault vault, uint256 _marketId, uint256 amount) internal {\n        _getSpotHedgeBaseMakerStorage().quoteToken.approve(address(vault), amount);\n        vault.deposit(address(this), amount);\n        vault.transferFundToMargin(_marketId, amount);\n    }\n\n    function _withdraw(IVault vault, uint256 _marketId, uint256 amount) internal {\n        vault.transferMarginToFund(_marketId, amount);\n        vault.withdraw(amount);\n    }\n\n    function _uniswapV3ExactInput(UniswapV3ExactInputParams memory params) internal returns (uint256 amountOut) {\n        IERC20Metadata(params.tokenIn).approve(\n            address(_getSpotHedgeBaseMakerStorage().uniswapV3Router),\n            params.amountIn\n        );\n\n        return\n            _getSpotHedgeBaseMakerStorage().uniswapV3Router.exactInput(\n                ISwapRouter.ExactInputParams({\n                    path: params.path,\n                    recipient: params.recipient, // transfer tokenOut directly to recipient\n                    deadline: block.timestamp,\n                    amountIn: params.amountIn,\n                    amountOutMinimum: params.amountOutMinimum\n                })\n            );\n    }\n\n    function _uniswapV3ExactOutput(UniswapV3ExactOutputParams memory params) internal returns (uint256 amountIn) {\n        IERC20Metadata tokenIn = IERC20Metadata(params.tokenIn);\n        tokenIn.approve(address(_getSpotHedgeBaseMakerStorage().uniswapV3Router), tokenIn.balanceOf(address(this)));\n\n        // might revert at this step, if amount in > free collateral\n        amountIn = _getSpotHedgeBaseMakerStorage().uniswapV3Router.exactOutput(\n            ISwapRouter.ExactOutputParams({\n                path: params.path,\n                recipient: params.recipient, // transfer tokenOut directly to recipient\n                deadline: block.timestamp,\n                amountOut: params.amountOut,\n                amountInMaximum: params.amountInMaximum\n            })\n        );\n\n        tokenIn.approve(address(_getSpotHedgeBaseMakerStorage().uniswapV3Router), 0);\n        return amountIn;\n    }\n\n    function _fillOrderCallback(FillOrderCallbackData memory data) internal {\n        if (data.isBaseToQuote) {\n            // do nothing\n            return;\n        }\n\n        (address tokenIn, address tokenOut) = (\n            address(_getSpotHedgeBaseMakerStorage().quoteToken),\n            address(_getSpotHedgeBaseMakerStorage().baseToken)\n        );\n        address maker = address(this);\n        uint256 _marketId = _getSpotHedgeBaseMakerStorage().marketId;\n        IVault vault = _getVault();\n\n        bytes memory path;\n        // Note we don't explicitly check maker's quote asset balance because\n        // if it is insufficient, it would revert in swap anyways.\n        if (data.isExactInput) {\n            _withdraw(vault, _marketId, data.amountXSpotDecimals);\n            path = _getPath(\n                tokenIn,\n                tokenOut,\n                true // isExactInput\n            );\n            _uniswapV3ExactInput(\n                UniswapV3ExactInputParams({\n                    tokenIn: tokenIn,\n                    tokenOut: tokenOut,\n                    path: path,\n                    recipient: maker,\n                    amountIn: data.amountXSpotDecimals,\n                    amountOutMinimum: data.oppositeAmountXSpotDecimals\n                })\n            );\n            return;\n        }\n\n        // else = if data.isExactOutput\n        _withdraw(vault, _marketId, data.oppositeAmountXSpotDecimals);\n        path = _getPath(\n            tokenIn,\n            tokenOut,\n            false // isExactInput\n        );\n        _uniswapV3ExactOutput(\n            UniswapV3ExactOutputParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                path: path,\n                recipient: maker,\n                amountOut: data.amountXSpotDecimals,\n                amountInMaximum: data.oppositeAmountXSpotDecimals\n            })\n        );\n\n        uint256 remainQuoteTokenAmount = _getSpotHedgeBaseMakerStorage().quoteToken.balanceOf(maker);\n        if (remainQuoteTokenAmount > 0) {\n            _deposit(vault, _marketId, remainQuoteTokenAmount);\n        }\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    function _checkMinMarginRatio(uint256 price) internal view {\n        int256 marginRatio = _getVault().getMarginRatio(_getSpotHedgeBaseMakerStorage().marketId, address(this), price);\n        int256 minMarginRatio_ = _getSpotHedgeBaseMakerStorage().minMarginRatio.toInt256();\n        if (marginRatio < minMarginRatio_) revert LibError.MinMarginRatioExceeded(marginRatio, minMarginRatio_);\n    }\n\n    function _getPath(address tokenIn, address tokenOut, bool isExactInput) internal view returns (bytes memory path) {\n        (address tokenA, address tokenB) = (isExactInput)\n            ? (tokenIn, tokenOut) // Note the ordering of tokenIn/tokenOut is switched because // Uniswap SwapRouter.exactOutput() takes path in reversed order.\n            : (tokenOut, tokenIn);\n\n        path = _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[_getKey(tokenA, tokenB)];\n        if (keccak256(path) == keccak256(bytes(\"\"))) revert LibError.PathNotSet(tokenA, tokenB);\n\n        return path;\n    }\n\n    // solhint-disable-next-line max-line-length\n    // Forked from https://github.com/perpetual-protocol/kantaban-contract/blob/18e0c1fe16490ccc9cbf0d9514e2204964f31624/contracts/Router.sol#L86-L118\n    function _verifyPath(address expectedTokenIn, address expectedTokenOut, bytes memory path) internal view {\n        address firstTokenIn = path.toAddress(0);\n\n        if (firstTokenIn != expectedTokenIn) revert LibError.UnexpectedPathTokenIn(firstTokenIn, expectedTokenIn);\n\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            bytes memory pool = path.getFirstPool();\n\n            (address tokenIn, address tokenOut, uint24 fee) = pool.decodeFirstPool();\n\n            address poolAddress = IUniswapV3Factory(_getSpotHedgeBaseMakerStorage().uniswapV3Factory).getPool(\n                tokenIn,\n                tokenOut,\n                fee\n            );\n\n            if (poolAddress == address(0)) revert LibError.ZeroPoolAddress(tokenIn, tokenOut, fee);\n\n            if (hasMultiplePools) {\n                path = path.skipToken();\n                continue;\n            }\n\n            // else = hasSinglePool\n            if (tokenOut != expectedTokenOut) revert LibError.UnexpectedPathTokenOut(tokenOut, expectedTokenOut);\n            break;\n        }\n    }\n\n    function _getVaultValueInBase(IVault vault, uint256 price) internal view returns (int256) {\n        int256 accountValue = vault.getAccountValue(_getSpotHedgeBaseMakerStorage().marketId, address(this), price);\n        int256 accountValueInBase = (accountValue * WAD.toInt256()) / price.toInt256();\n        int256 spotValueInBase = _getSpotHedgeBaseMakerStorage()\n            .baseToken\n            .balanceOf(address(this))\n            .formatDecimals(_getSpotHedgeBaseMakerStorage().baseTokenDecimals, INTERNAL_DECIMALS)\n            .toInt256();\n        return accountValueInBase + spotValueInBase;\n    }\n\n    function _getVaultValueInBaseSafe(IVault vault, uint256 price) internal view returns (uint256) {\n        // Revert early since we don't allow deposit/withdraw when the vault's value is negative or zero.\n        int256 vaultValueInBase = _getVaultValueInBase(vault, price);\n        if (vaultValueInBase <= 0) revert LibError.NegativeOrZeroVaultValueInBase(vaultValueInBase);\n\n        return vaultValueInBase.toUint256();\n    }\n\n    function _formatPerpToSpotBaseDecimals(uint256 perpBaseAmount) internal view returns (uint256) {\n        return perpBaseAmount.formatDecimals(INTERNAL_DECIMALS, _getSpotHedgeBaseMakerStorage().baseTokenDecimals);\n    }\n\n    function _formatPerpToSpotQuoteDecimals(uint256 perpQuoteAmount) internal view returns (uint256) {\n        return perpQuoteAmount.formatDecimals(INTERNAL_DECIMALS, _getSpotHedgeBaseMakerStorage().quoteTokenDecimals);\n    }\n\n    function _formatSpotToPerpBaseDecimals(uint256 spotBaseAmount) internal view returns (uint256) {\n        return spotBaseAmount.formatDecimals(_getSpotHedgeBaseMakerStorage().baseTokenDecimals, INTERNAL_DECIMALS);\n    }\n\n    function _formatSpotToPerpQuoteDecimals(uint256 spotQuoteAmount) internal view returns (uint256) {\n        return spotQuoteAmount.formatDecimals(_getSpotHedgeBaseMakerStorage().quoteTokenDecimals, INTERNAL_DECIMALS);\n    }\n\n    function _getPrice() internal view returns (uint256) {\n        IAddressManager addressManager = getAddressManager();\n        (uint256 price, ) = addressManager.getPythOracleAdapter().getPrice(\n            addressManager.getConfig().getPriceFeedId(_getSpotHedgeBaseMakerStorage().marketId)\n        );\n        return price;\n    }\n\n    //\n    // INTERNAL PURE\n    //\n\n    // solhint-disable-next-line max-line-length\n    // Fo"
    }
  ]
}