{
  "Title": "The Ether can't be withdrawn from the NodeDelegator contract under certain conditions",
  "Content": "##### Description\nIf `ETH_TOKEN` is not included in the list of supported assets, Ether can still be [transferred](https://github.com/Kelp-DAO/LRT-rsETH/blob/e75e9ef168a7b192abf76869977cd2ac8134849c/contracts/LRTDepositPool.sol#L352) to the `NDC` using the `transferETHToNodeDelegator` function. However, it [cannot be transferred back](https://github.com/Kelp-DAO/LRT-rsETH/blob/e75e9ef168a7b192abf76869977cd2ac8134849c/contracts/NodeDelegator.sol#L103) using the `transferBackToLRTDepositPool` function.\n##### Recommendation\nWe recommend checking the presence of `ETH_TOKEN` in the supportedAssets list during the execution of the sendETHFromDepositPoolToNDC function.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/LRTDepositPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\n\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @title LRTDepositPool - Deposit Pool Contract for LSTs\n/// @notice Handles LST asset deposits\ncontract LRTDepositPool is ILRTDepositPool, LRTConfigRoleChecker, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    uint256 public maxNodeDelegatorLimit;\n    uint256 public minAmountToDeposit;\n\n    mapping(address => uint256) public isNodeDelegator; // 0: not a node delegator, 1: is a node delegator\n    address[] public nodeDelegatorQueue;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        maxNodeDelegatorLimit = 10;\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice gets the total asset present in protocol\n    /// @param asset Asset address\n    /// @return totalAssetDeposit total asset present in protocol\n    function getTotalAssetDeposits(address asset) public view override returns (uint256 totalAssetDeposit) {\n        (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer) =\n            getAssetDistributionData(asset);\n        return (assetLyingInDepositPool + assetLyingInNDCs + assetStakedInEigenLayer);\n    }\n\n    /// @notice gets the current limit of asset deposit\n    /// @param asset Asset address\n    /// @return currentLimit Current limit of asset deposit\n    function getAssetCurrentLimit(address asset) public view override returns (uint256) {\n        if (getTotalAssetDeposits(asset) > lrtConfig.depositLimitByAsset(asset)) {\n            return 0;\n        }\n\n        return lrtConfig.depositLimitByAsset(asset) - getTotalAssetDeposits(asset);\n    }\n\n    /// @dev get node delegator queue\n    /// @return nodeDelegatorQueue Array of node delegator contract addresses\n    function getNodeDelegatorQueue() external view override returns (address[] memory) {\n        return nodeDelegatorQueue;\n    }\n\n    /// @dev provides asset amount distribution data among depositPool, NDCs and eigenLayer\n    /// @param asset the asset to get the total amount of\n    /// @return assetLyingInDepositPool asset amount lying in this LRTDepositPool contract\n    /// @return assetLyingInNDCs asset amount sum lying in all NDC contract\n    /// @return assetStakedInEigenLayer asset amount deposited in eigen layer strategies through all NDCs\n    function getAssetDistributionData(address asset)\n        public\n        view\n        override\n        onlySupportedAsset(asset)\n        returns (uint256 assetLyingInDepositPool, uint256 assetLyingInNDCs, uint256 assetStakedInEigenLayer)\n    {\n        if (asset == LRTConstants.ETH_TOKEN) {\n            return getETHDistributionData();\n        }\n        assetLyingInDepositPool = IERC20(asset).balanceOf(address(this));\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            assetLyingInNDCs += IERC20(asset).balanceOf(nodeDelegatorQueue[i]);\n            assetStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev provides ETH amount distribution data among depositPool, NDCs and eigenLayer\n    function getETHDistributionData()\n        public\n        view\n        override\n        returns (uint256 ethLyingInDepositPool, uint256 ethLyingInNDCs, uint256 ethStakedInEigenLayer)\n    {\n        ethLyingInDepositPool = address(this).balance;\n\n        uint256 ndcsCount = nodeDelegatorQueue.length;\n        for (uint256 i; i < ndcsCount;) {\n            ethLyingInNDCs += nodeDelegatorQueue[i].balance;\n            ethStakedInEigenLayer += INodeDelegator(nodeDelegatorQueue[i]).getETHEigenPodBalance();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice View amount of rsETH to mint for given asset amount\n    /// @param asset Asset address\n    /// @param amount Asset amount\n    /// @return rsethAmountToMint Amount of rseth to mint\n    function getRsETHAmountToMint(\n        address asset,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (uint256 rsethAmountToMint)\n    {\n        // setup oracle contract\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        // calculate rseth amount to mint based on asset amount and asset exchange rate\n        rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.rsETHPrice();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows user to deposit ETH to the protocol\n    /// @param minRSETHAmountExpected Minimum amount of rseth to receive\n    /// @param referralId referral id\n    function depositETH(\n        uint256 minRSETHAmountExpected,\n        string calldata referralId\n    )\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n    {\n        // checks\n        uint256 rsethAmountToMint = _beforeDeposit(LRTConstants.ETH_TOKEN, msg.value, minRSETHAmountExpected);\n\n        // interactions\n        _mintRsETH(rsethAmountToMint);\n\n        emit ETHDeposit(msg.sender, msg.value, rsethAmountToMint, referralId);\n    }\n\n    /// @notice helps user stake LST to the protocol\n    /// @param asset LST asset address to stake\n    /// @param depositAmount LST asset amount to stake\n    /// @param minRSETHAmountExpected Minimum amount of rseth to receive\n    function depositAsset(\n        address asset,\n        uint256 depositAmount,\n        uint256 minRSETHAmountExpected,\n        string calldata referralId\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        onlySupportedAsset(asset)\n    {\n        // checks\n        uint256 rsethAmountToMint = _beforeDeposit(asset, depositAmount, minRSETHAmountExpected);\n\n        // interactions\n        if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {\n            revert TokenTransferFailed();\n        }\n        _mintRsETH(rsethAmountToMint);\n\n        emit AssetDeposit(msg.sender, asset, depositAmount, rsethAmountToMint, referralId);\n    }\n\n    function _beforeDeposit(\n        address asset,\n        uint256 depositAmount,\n        uint256 minRSETHAmountExpected\n    )\n        private\n        view\n        returns (uint256 rsethAmountToMint)\n    {\n        if (depositAmount == 0 || depositAmount < minAmountToDeposit) {\n            revert InvalidAmountToDeposit();\n        }\n\n        if (depositAmount > getAssetCurrentLimit(asset)) {\n            revert MaximumDepositLimitReached();\n        }\n        rsethAmountToMint = getRsETHAmountToMint(asset, depositAmount);\n\n        if (rsethAmountToMint < minRSETHAmountExpected) {\n            revert MinimumAmountToReceiveNotMet();\n        }\n    }\n\n    /// @dev private function to mint rseth\n    /// @param rsethAmountToMint Amount of rseth minted\n    function _mintRsETH(uint256 rsethAmountToMint) private {\n        address rsethToken = lrtConfig.rsETH();\n        // mint rseth for user\n        IRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);\n    }\n\n    /// @notice add new node delegator contract addresses\n    /// @dev only callable by LRT admin\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function addNodeDelegatorContractToQueue(address[] calldata nodeDelegatorContracts) external onlyLRTAdmin {\n        uint256 length = nodeDelegatorContracts.length;\n        if (nodeDelegatorQueue.length + length > maxNodeDelegatorLimit) {\n            revert MaximumNodeDelegatorLimitReached();\n        }\n\n        for (uint256 i; i < length;) {\n            UtilLib.checkNonZeroAddress(nodeDelegatorContracts[i]);\n\n            // check if node delegator contract is already added and add it if not\n            if (isNodeDelegator[nodeDelegatorContracts[i]] == 0) {\n                nodeDelegatorQueue.push(nodeDelegatorContracts[i]);\n            }\n\n            isNodeDelegator[nodeDelegatorContracts[i]] = 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit NodeDelegatorAddedinQueue(nodeDelegatorContracts);\n    }\n\n    /// @notice remove node delegator contract address from queue\n    /// @dev only callable by LRT admin\n    /// @param nodeDelegatorAddress NodeDelegator contract address\n    function removeNodeDelegatorContractFromQueue(address nodeDelegatorAddress) public onlyLRTAdmin {\n        // 1. check if node delegator contract is in queue\n        uint256 length = nodeDelegatorQueue.length;\n        uint256 ndcIndex;\n\n        for (uint256 i; i < length;) {\n            if (nodeDelegatorQueue[i] == nodeDelegatorAddress) {\n                ndcIndex = i;\n                break;\n            }\n\n            // 1.1 If node delegator contract is not found in queue, revert\n            if (i == length - 1) {\n                revert NodeDelegatorNotFound();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // 2. revert if node delegator contract has any asset balances.\n\n        // 2.1 check if NDC has native ETH balance in eigen layer and in itself.\n        if (\n            INodeDelegator(nodeDelegatorAddress).getETHEigenPodBalance() > 0\n                || address(nodeDelegatorAddress).balance > 0\n        ) {\n            revert NodeDelegatorHasETH();\n        }\n\n        // 2.2  check if NDC has LST balance\n        address[] memory supportedAssets = lrtConfig.getSupportedAssetList();\n        uint256 supportedAssetsLength = supportedAssets.length;\n\n        uint256 assetBalance;\n        for (uint256 i; i < supportedAssetsLength; i++) {\n            if (supportedAssets[i] == LRTConstants.ETH_TOKEN) {\n                // ETH already checked above.\n                continue;\n            }\n\n            assetBalance = IERC20(supportedAssets[i]).balanceOf(nodeDelegatorAddress)\n                + INodeDelegator(nodeDelegatorAddress).getAssetBalance(supportedAssets[i]);\n\n            if (assetBalance > 0) {\n                revert NodeDelegatorHasAssetBalance(supportedAssets[i], assetBalance);\n            }\n        }\n\n        // 3. remove node delegator contract from queue\n\n        // 3.1 remove from isNodeDelegator mapping\n        isNodeDelegator[nodeDelegatorAddress] = 0;\n        // 3.2 remove from nodeDelegatorQueue\n        nodeDelegatorQueue[ndcIndex] = nodeDelegatorQueue[length - 1];\n        nodeDelegatorQueue.pop();\n\n        emit NodeDelegatorRemovedFromQueue(nodeDelegatorAddress);\n    }\n\n    /// @notice remove many node delegator contracts from queue\n    /// @dev calls internally removeNodeDelegatorContractFromQueue which is only callable by LRT admin\n    /// @param nodeDelegatorContracts Array of NodeDelegator contract addresses\n    function removeManyNodeDelegatorContractsFromQueue(address[] calldata nodeDelegatorContracts) external {\n        uint256 length = nodeDelegatorContracts.length;\n\n        for (uint256 i; i < length;) {\n            removeNodeDelegatorContractFromQueue(nodeDelegatorContracts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice transfers asset lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param asset Asset address\n    /// @param amount Asset amount to transfer\n    function transferAssetToNodeDelegator(\n        uint256 ndcIndex,\n        address asset,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        if (!IERC20(asset).transfer(nodeDelegator, amount)) {\n            revert TokenTransferFailed();\n        }\n    }\n\n    /// @notice transfers ETH lying in this DepositPool to node delegator contract\n    /// @dev only callable by LRT manager\n    /// @param ndcIndex Index of NodeDelegator contract address in nodeDelegatorQueue\n    /// @param amount ETH amount to transfer\n    function transferETHToNodeDelegator(uint256 ndcIndex, uint256 amount) external nonReentrant onlyLRTManager {\n        address nodeDelegator = nodeDelegatorQueue[ndcIndex];\n        INodeDelegator(nodeDelegator).sendETHFromDepositPoolToNDC{ value: amount }();\n    }\n\n    /// @notice swap ETH for LST asset which is accepted by LRTDepositPool\n    /// @dev use LRTOracle to get price for toToken. Only callable by LRT manager\n    /// @param toAsset Asset address to swap to\n    /// @param minToAssetAmount Minimum asset amount to swap to\n    function swapETHForAssetWithinDepositPool(\n        address toAsset,\n        uint256 minToAssetAmount\n    )\n        external\n        payable\n        onlyLRTManager\n        onlySupportedAsset(toAsset)\n    {\n        // checks\n        uint256 ethAmountSent = msg.value;\n\n        uint256 returnAmount = getSwapETHToAssetReturnAmount(toAsset, ethAmountSent);\n\n        if (returnAmount < minToAssetAmount || IERC20(toAsset).balanceOf(address(this)) < returnAmount) {\n            revert NotEnoughAssetToTransfer();\n        }\n\n        // interactions\n        IERC20(toAsset).transfer(msg.sender, returnAmount);\n\n        emit ETHSwappedForLST(ethAmountSent, toAsset, returnAmount);\n    }\n\n    /// @notice get return amount for swapping ETH to asset that is accepted by LRTDepositPool\n    /// @dev use LRTOracle to get price for toToken\n    /// @param toAsset Asset address to swap to\n    /// @param ethAmountToSend Eth amount to swap from\n    /// @return returnAmount Return amount of toAsset\n    function getSwapETHToAssetReturnAmount(\n        address toAsset,\n        uint256 ethAmountToSend\n    )\n        public\n        view\n        returns (uint256 returnAmount)\n    {\n        address lrtOracleAddress = lrtConfig.getContract(LRTConstants.LRT_ORACLE);\n        ILRTOracle lrtOracle = ILRTOracle(lrtOracleAddress);\n\n        uint256 ethPricePerUint = 1e18;\n\n        return ethPricePerUint * ethAmountToSend / lrtOracle.getAssetPrice(toAsset);\n    }\n\n    /// @notice update max node delegator count\n    /// @dev only callable by LRT admin\n    /// @param maxNodeDelegatorLimit_ Maximum count of node delegator\n    function updateMaxNodeDelegatorLimit(uint256 maxNodeDelegatorLimit_) external onlyLRTAdmin {\n        if (maxNodeDelegatorLimit_ < nodeDelegatorQueue.length) {\n            revert InvalidMaximumNodeDelegatorLimit();\n        }\n\n        maxNodeDelegatorLimit = maxNodeDelegatorLimit_;\n        emit MaxNodeDelegatorLimitUpdated(maxNodeDelegatorLimit);\n    }\n\n    /// @notice update min amount to deposit\n    /// @dev only callable by LRT admin\n    /// @param minAmountToDeposit_ Minimum amount to deposit\n    function setMinAmountToDeposit(uint256 minAmountToDeposit_) external onlyLRTAdmin {\n        minAmountToDeposit = minAmountToDeposit_;\n        emit MinAmountToDepositUpdated(minAmountToDeposit_);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n\n    receive() external payable { }\n}"
    }
  ]
}