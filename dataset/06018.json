{
  "Title": "[G-06] Use custom errors instead of require/assert",
  "Content": "\nConsider the use of a custom error, as it leads to a cheaper deploy cost and run time cost. The run time cost is only relevant when the revert condition is met.\n<details>\n\n```solidity\nfile: contracts/GeVault.sol\n\n79     require(_treasury != address(0x0), \"GEV: Invalid Treasury\");\n\n80     require(_uniswapPool != address(0x0), \"GEV: Invalid Pool\");\n\n81     require(weth != address(0x0), \"GEV: Invalid WETH\");\n\n120    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n\n125    require( t.lowerTick() > ticks[ticks.length-1].upperTick(), \"GEV: Push Tick Overlap\");\n\n127    require( t.upperTick() < ticks[ticks.length-1].lowerTick(), \"GEV: Push Tick Overlap\");\n\n141    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n\n146    require( t.lowerTick() > ticks[0].upperTick(), \"GEV: Shift Tick Overlap\");\n\n148    require( t.upperTick() < ticks[0].lowerTick(), \"GEV: Shift Tick Overlap\");\n\n170    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n\n184    require(newBaseFeeX4 < 1e4, \"GEV: Invalid Base Fee\");\n\n203    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n\n215    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n\n217    require(liquidity <= balanceOf(msg.sender), \"GEV: Insufficient Balance\");\n\n218    require(liquidity > 0, \"GEV: Withdraw Zero\");\n\n249    require(isEnabled, \"GEV: Pool Disabled\");\n\n250    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n\n251    require(token == address(token0) || token == address(token1), \"GEV: Invalid Token\");\n\n252    require(amount > 0 || msg.value > 0, \"GEV: Deposit Zero\");\n\n256    require(token == address(WETH), \"GEV: Invalid Weth\");\n\n269    require(tvlCap > valueX8 + getTVL(), \"GEV: Max Cap Reached\")\n\n281    require(liquidity > 0, \"GEV: No Liquidity Added\");\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/GeVault.sol#L79\n\n```solidity\nfile: contracts/RangeManager.sol\n\n49    require( address(lendingPool) != address(0x0), \"Invalid address\" );\n\n60    require(start < end, \"Range invalid\");\n\n76    require(beacon != address(0x0), \"Invalid beacon\");\n\n108   require(step < tokenisedRanges.length && step < tokenisedTicker.length, \"Invalid step\");\n\n206   require(hf > 1.01e18, \"Health factor is too low\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/RangeManager.sol#L49\n\n\n```solidity\nfile:  main/contracts/RoeRouter.sol\n\n34    require(treasury_ != address(0x0), \"Invalid address\");\n\n68       require (\n      lendingPoolAddressProvider != address(0x0) \n      && token0 != address(0x0) \n      && token1 != address(0x0) \n      && ammRouter != address(0x0), \n      \"Invalid Address\"\n    );\n\n75  require(token0 < token1, \"Invalid Order\");\n\n84  require(newTreasury != address(0x0), \"Invalid address\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/RoeRouter.sol#L34\n\n```solidity\nfile:  contracts/TokenisableRange.sol\n\n86    require(address(_oracle) != address(0x0), \"Invalid oracle\");\n\n87    require(status == ProxyState.INIT_PROXY, \"!InitProxy\");\n\n135   require(status == ProxyState.INIT_LP, \"!InitLP\");\n\n136   require(msg.sender == creator, \"Unallowed call\");\n\n209   require(addedValue > liquidityValue * 95 / 100 && liquidityValue > addedValue * 95 / 100, \"TR: Claim Fee Slippage\");\n\n225   require(totalSupply() > 0, \"TR Closed\"); \n\n271   require (TOKEN0_PRICE > 0 && TOKEN1_PRICE > 0, \"Invalid Oracle Price\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/TokenisableRange.sol#L86\n\n```solidity\nfile:  contracts/helper/FixedOracle.sol\n\n11    require(msg.sender == owner, \"Only the owner can call this function.\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/helper/FixedOracle.sol#L11\n\n```solidity\nfile:  contracts/helper/LPOracle.sol\n\n29   require(lpToken != address(0x0) && clToken0 != address(0x0) && clToken1 != address(0x0), \"Invalid address\");\n\n63   require(timeStamp > 0, \"Round not complete\");\n\n101  require(decimalsA <= 18 && decimalsB <= 18, \"Incorrect tokens\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/helper/LPOracle.sol#L29\n\n```solidity\nfile:  contracts/helper/OracleConvert.sol\n\n23    require(clToken0 != address(0x0) && clToken1 != address(0x0), \"Invalid address\");\n\n26    require(CL_TOKENA.decimals() + CL_TOKENB.decimals() >= 16, \"Decimals error\");\n\n44    require(timeStamp > 0, \"Round not complete\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/helper/OracleConvert.sol#L23\n\n```solidity\nfile:  contracts/helper/V3Proxy.sol\n\n87     require(acceptPayable, \"CannotReceiveETH\");\n\n91     require(acceptPayable, \"CannotReceiveETH\");\n\n99     require(path.length == 2, \"Direct swap only\");\n\n106    require(path.length == 2, \"Direct swap only\");\n\n113    require(path.length == 2, \"Direct swap only\");\n\n125    require(path.length == 2, \"Direct swap only\");\n\n138    require(path.length == 2, \"Direct swap only\");\n\n148    require(path.length == 2, \"Direct swap only\");\n\n161    require(path.length == 2, \"Direct swap only\");\n\n179    require(path.length == 2, \"Direct swap only\");\n\n180    require(path[1] == ROUTER.WETH9(), \"Invalid path\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/helper/V3Proxy.sol#L87\n\n```solidity\nfile:  contracts/PositionManager/OptionsPositionManager.sol\n\n69    require( address(lendingPool) == msg.sender, \"OPM: Call Unallowed\");\n\n91    require( address(lendingPool) == msg.sender, \"OPM: Call Unallowed\");\n\n137   require(sourceSwap == token0 || sourceSwap == token1, \"OPM: Invalid Swap Token\");\n\n167   require(options.length == amounts.length && sourceSwap.length == options.length, \"OPM: Array Length Mismatch\");\n\n198   require(options.length == amounts.length, \"ARRAY_LEN_MISMATCH\");\n\n235   require(debt > 0, \"OPM: No Debt\");\n\n261   require(collateralAsset == token0 || collateralAsset == token1, \"OPM: Invalid Collateral Asset\");\n\n369   require(feeAmount <= IERC20(collateralAsset).balanceOf(address(this)), \"OPM: Insufficient Collateral\");\n\n393   require( LP.getReserveData(optionAddress).aTokenAddress != address(0x0), \"OPM: Invalid Address\" );\n\n420   require( LP.getReserveData(optionAddress).aTokenAddress != address(0x0), \"OPM: Invalid Address\" );\n\n441   require(sourceAsset == token0 || sourceAsset == token1, \"OPM: Invalid Swap Asset\");\n\n495   require( amountsIn[0] <= maxAmount && amountsIn[0] > 0, \"OPM: Invalid Swap Amounts\" );\n\n496   require( amountsIn[0] <= ERC20(path[0]).balanceOf(address(this)), \"OPM: Insufficient Token Amount\" );\n\n523   require ( priceAssetA > 0 && priceAssetB > 0, \"OPM: Invalid Oracle Price\");\n\n525   require( amountB > 0, \"OPM: Target Amount Too Low\");\n\n536   require(token0 == address(t0) && token1 == address(t1), \"OPM: Invalid Debt Asset\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/PositionManager/OptionsPositionManager.sol#L69\n\n```solidity\nfile: contracts/PositionManager/PositionManager.sol\n\n30   require(roerouter != address(0x0), \"Invalid address\");\n\n145  require( valueA <= valueB * 101 / 100, \"PM: LP Oracle Error\");\n\n146  require( valueB <= valueA * 101 / 100, \"PM: LP Oracle Error\");\n\n```\nhttps://github.com/code-423n4/2023-08-goodentry/blob/main/contracts/PositionManager/PositionManager.sol#L30\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-08-goodentry",
  "Code": [
    {
      "filename": "contracts/GeVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport \"./openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IAaveLendingPoolV2.sol\";\nimport \"../interfaces/IUniswapV3Pool.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"./RangeManager.sol\";\nimport \"./RoeRouter.sol\";\n\n\n/**\nGeVault is a reblancing vault that holds TokenisableRanges tickers\nFunctionalities:\n- Hold a list of tickers for a single pair, evenly spaced\n- Hold balances of those tickers, deposited in the ROE LP\n- Deposit one underlying asset split evenly into 2 or more consecutive ticks above/below the current price\n- Withdraw one underlying asset, taken out evenly from 2 or more consecutive ticks\n- Calculate the current balance of assets\n\nDesign:\n \n */\ncontract GeVault is ERC20, Ownable, ReentrancyGuard {\n  using SafeERC20 for ERC20;\n  \n  event Deposit(address indexed sender, address indexed token, uint amount, uint liquidity);\n  event Withdraw(address indexed sender, address indexed token, uint amount, uint liquidity);\n  event PushTick(address indexed ticker);\n  event ShiftTick(address indexed ticker);\n  event ModifyTick(address indexed ticker, uint index);\n  event Rebalance(uint tickIndex);\n  event SetEnabled(bool isEnabled);\n  event SetTreasury(address treasury);\n  event SetFee(uint baseFeeX4);\n  event SetTvlCap(uint tvlCap);\n\n  RangeManager rangeManager; \n  /// @notice Ticks properly ordered in ascending price order\n  TokenisableRange[] public ticks;\n  \n  /// @notice Tracks the beginning of active ticks: the next 4 ticks are the active\n  uint public tickIndex; \n  /// @notice Pair tokens\n  ERC20 public token0;\n  ERC20 public token1;\n  bool public isEnabled = true;\n  /// @notice Pool base fee \n  uint public baseFeeX4 = 20;\n  /// @notice Max vault TVL with 8 decimals\n  uint public tvlCap = 1e12;\n  \n  /// CONSTANTS \n  /// immutable keyword removed for coverage testing bug in brownie\n  address public treasury;\n  IUniswapV3Pool public uniswapPool;\n  ILendingPool public lendingPool;\n  IPriceOracle public oracle;\n  uint public constant nearbyRanges = 2;\n  IWETH public WETH;\n  bool public baseTokenIsToken0;\n  \n\n  constructor(\n    address _treasury, \n    address roeRouter, \n    address _uniswapPool, \n    uint poolId, \n    string memory name, \n    string memory symbol,\n    address weth,\n    bool _baseTokenIsToken0\n  ) \n    ERC20(name, symbol)\n  {\n    require(_treasury != address(0x0), \"GEV: Invalid Treasury\");\n    require(_uniswapPool != address(0x0), \"GEV: Invalid Pool\");\n    require(weth != address(0x0), \"GEV: Invalid WETH\");\n\n    (address lpap, address _token0, address _token1,, ) = RoeRouter(roeRouter).pools(poolId);\n    token0 = ERC20(_token0);\n    token1 = ERC20(_token1);\n    \n    lendingPool = ILendingPool(ILendingPoolAddressesProvider(lpap).getLendingPool());\n    oracle = IPriceOracle(ILendingPoolAddressesProvider(lpap).getPriceOracle());\n    treasury = _treasury;\n    uniswapPool = IUniswapV3Pool(_uniswapPool);\n    WETH = IWETH(weth);\n    baseTokenIsToken0 = _baseTokenIsToken0;\n  }\n  \n  \n  //////// ADMIN\n  \n  \n  /// @notice Set pool status\n  /// @param _isEnabled Pool status\n  function setEnabled(bool _isEnabled) public onlyOwner { \n    isEnabled = _isEnabled; \n    emit SetEnabled(_isEnabled);\n  }\n  \n  /// @notice Set treasury address\n  /// @param newTreasury New address\n  function setTreasury(address newTreasury) public onlyOwner { \n    treasury = newTreasury; \n    emit SetTreasury(newTreasury);\n  }\n\n\n  /// @notice Add a new ticker to the list\n  /// @param tr Tick address\n  function pushTick(address tr) public onlyOwner {\n    TokenisableRange t = TokenisableRange(tr);\n    (ERC20 t0,) = t.TOKEN0();\n    (ERC20 t1,) = t.TOKEN1();\n    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n    if (ticks.length == 0) ticks.push(t);\n    else {\n      // Check that tick is properly ordered\n      if (baseTokenIsToken0) \n        require( t.lowerTick() > ticks[ticks.length-1].upperTick(), \"GEV: Push Tick Overlap\");\n      else \n        require( t.upperTick() < ticks[ticks.length-1].lowerTick(), \"GEV: Push Tick Overlap\");\n      \n      ticks.push(TokenisableRange(tr));\n    }\n    emit PushTick(tr);\n  }  \n\n\n  /// @notice Add a new ticker to the list\n  /// @param tr Tick address\n  function shiftTick(address tr) public onlyOwner {\n    TokenisableRange t = TokenisableRange(tr);\n    (ERC20 t0,) = t.TOKEN0();\n    (ERC20 t1,) = t.TOKEN1();\n    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n    if (ticks.length == 0) ticks.push(t);\n    else {\n      // Check that tick is properly ordered\n      if (!baseTokenIsToken0) \n        require( t.lowerTick() > ticks[0].upperTick(), \"GEV: Shift Tick Overlap\");\n      else \n        require( t.upperTick() < ticks[0].lowerTick(), \"GEV: Shift Tick Overlap\");\n      \n      // extend array by pushing last elt\n      ticks.push(ticks[ticks.length-1]);\n      // shift each element\n      if (ticks.length > 2){\n        for (uint k = 0; k < ticks.length - 2; k++) \n          ticks[ticks.length - 2 - k] = ticks[ticks.length - 3 - k];\n        }\n      // add new tick in first place\n      ticks[0] = t;\n    }\n    emit ShiftTick(tr);\n  }\n\n\n  /// @notice Modify ticker\n  /// @param tr New tick address\n  /// @param index Tick to modify\n  function modifyTick(address tr, uint index) public onlyOwner {\n    (ERC20 t0,) = TokenisableRange(tr).TOKEN0();\n    (ERC20 t1,) = TokenisableRange(tr).TOKEN1();\n    require(t0 == token0 && t1 == token1, \"GEV: Invalid TR\");\n    ticks[index] = TokenisableRange(tr);\n    emit ModifyTick(tr, index);\n  }\n  \n  /// @notice Ticks length getter\n  /// @return len Ticks length\n  function getTickLength() public view returns(uint len){\n    len = ticks.length;\n  }\n  \n  /// @notice Set the base fee\n  /// @param newBaseFeeX4 New base fee in E4\n  function setBaseFee(uint newBaseFeeX4) public onlyOwner {\n  require(newBaseFeeX4 < 1e4, \"GEV: Invalid Base Fee\");\n    baseFeeX4 = newBaseFeeX4;\n    emit SetFee(newBaseFeeX4);\n  }\n  \n  /// @notice Set the TVL cap\n  /// @param newTvlCap New TVL cap\n  function setTvlCap(uint newTvlCap) public onlyOwner {\n    tvlCap = newTvlCap;\n    emit SetTvlCap(newTvlCap);\n  }\n  \n  \n  //////// PUBLIC FUNCTIONS\n  \n    \n  /// @notice Rebalance tickers\n  /// @dev Provide the list of tickers from \n  function rebalance() public {\n    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n    removeFromAllTicks();\n    if (isEnabled) deployAssets();\n  }\n  \n\n  /// @notice Withdraw assets from the ticker\n  /// @param liquidity Amount of GEV tokens to redeem; if 0, redeem all\n  /// @param token Address of the token redeemed for\n  /// @return amount Total token returned\n  /// @dev For simplicity+efficieny, withdrawal is like a rebalancing, but a subset of the tokens are sent back to the user before redeploying\n  function withdraw(uint liquidity, address token) public nonReentrant returns (uint amount) {\n    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n    if (liquidity == 0) liquidity = balanceOf(msg.sender);\n    require(liquidity <= balanceOf(msg.sender), \"GEV: Insufficient Balance\");\n    require(liquidity > 0, \"GEV: Withdraw Zero\");\n    \n    uint vaultValueX8 = getTVL();\n    uint valueX8 = vaultValueX8 * liquidity / totalSupply();\n    amount = valueX8 * 10**ERC20(token).decimals() / oracle.getAssetPrice(token);\n    uint fee = amount * getAdjustedBaseFee(token == address(token1)) / 1e4;\n    \n    _burn(msg.sender, liquidity);\n    removeFromAllTicks();\n    ERC20(token).safeTransfer(treasury, fee);\n    uint bal = amount - fee;\n\n    if (token == address(WETH)){\n      WETH.withdraw(bal);\n      payable(msg.sender).transfer(bal);\n    }\n    else {\n      ERC20(token).safeTransfer(msg.sender, bal);\n    }\n    \n    // if pool enabled, deploy assets in ticks, otherwise just let assets sit here until totally withdrawn\n    if (isEnabled) deployAssets();\n    emit Withdraw(msg.sender, token, amount, liquidity);\n  }\n\n\n  /// @notice deposit tokens in the pool, convert to WETH if necessary\n  /// @param token Token address\n  /// @param amount Amount of token deposited\n  function deposit(address token, uint amount) public payable nonReentrant returns (uint liquidity) \n  {\n    require(isEnabled, \"GEV: Pool Disabled\");\n    require(poolMatchesOracle(), \"GEV: Oracle Error\");\n    require(token == address(token0) || token == address(token1), \"GEV: Invalid Token\");\n    require(amount > 0 || msg.value > 0, \"GEV: Deposit Zero\");\n    \n    // Wrap if necessary and deposit here\n    if (msg.value > 0){\n      require(token == address(WETH), \"GEV: Invalid Weth\");\n      // wraps ETH by sending to the wrapper that sends back WETH\n      WETH.deposit{value: msg.value}();\n      amount = msg.value;\n    }\n    else { \n      ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    }\n    \n    // Send deposit fee to treasury\n    uint fee = amount * getAdjustedBaseFee(token == address(token0)) / 1e4;\n    ERC20(token).safeTransfer(treasury, fee);\n    uint valueX8 = oracle.getAssetPrice(token) * (amount - fee) / 10**ERC20(token).decimals();\n    require(tvlCap > valueX8 + getTVL(), \"GEV: Max Cap Reached\");\n\n    uint vaultValueX8 = getTVL();\n    uint tSupply = totalSupply();\n    // initial liquidity at 1e18 token ~ $1\n    if (tSupply == 0 || vaultValueX8 == 0)\n      liquidity = valueX8 * 1e10;\n    else {\n      liquidity = tSupply * valueX8 / vaultValueX8;\n    }\n    \n    rebalance();\n    require(liquidity > 0, \"GEV: No Liquidity Added\");\n    _mint(msg.sender, liquidity);    \n    emit Deposit(msg.sender, token, amount, liquidity);\n  }\n  \n  \n  /// @notice Get value of 1e18 GEV tokens\n  /// @return priceX8 price of 1e18 tokens with 8 decimals\n  function latestAnswer() external view returns (uint256 priceX8) {\n    uint supply = totalSupply();\n    if (supply == 0) return 0;\n    uint vaultValue = getTVL();\n    priceX8 = vaultValue * 1e18 / supply;\n  }\n  \n  \n  /// @notice Get vault underlying assets\n  function getReserves() public view returns (uint amount0, uint amount1){\n    for (uint k = 0; k < ticks.length; k++){\n      TokenisableRange t = ticks[k];\n      address aTick = lendingPool.getReserveData(address(t)).aTokenAddress;\n      uint bal = ERC20(aTick).balanceOf(address(this));\n      (uint amt0, uint amt1) = t.getTokenAmounts(bal);\n      amount0 += amt0;\n      amount1 += amt1;\n    }\n  }\n\n\n  //////// INTERNAL FUNCTIONS\n  \n  /// @notice Remove assets from all the underlying ticks\n  function removeFromAllTicks() internal {\n    for (uint k = 0; k < ticks.length; k++){\n      removeFromTick(k);\n    }    \n  }\n  \n  \n  /// @notice Remove from tick\n  function removeFromTick(uint index) internal {\n    TokenisableRange tr = ticks[index];\n    address aTokenAddress = lendingPool.getReserveData(address(tr)).aTokenAddress;\n    uint aBal = ERC20(aTokenAddress).balanceOf(address(this));\n    uint sBal = tr.balanceOf(aTokenAddress);\n\n    // if there are less tokens available than the balance (because of outstanding debt), withdraw what's available\n    if (aBal > sBal) aBal = sBal;\n    if (aBal > 0){\n      lendingPool.withdraw(address(tr), aBal, address(this));\n      tr.withdraw(aBal, 0, 0);\n    }\n  }\n  \n  \n  /// @notice \n  function deployAssets() internal { \n    uint newTickIndex = getActiveTickIndex();\n    uint availToken0 = token0.balanceOf(address(this));\n    uint availToken1 = token1.balanceOf(address(this));\n    \n    // Check which is the main token\n    (uint amount0ft, uint amount1ft) = ticks[newTickIndex].getTokenAmountsExcludingFees(1e18);\n    uint tick0Index = newTickIndex;\n    uint tick1Index = newTickIndex + 2;\n    if (amount1ft > 0){\n      tick0Index = newTickIndex + 2;\n      tick1Index = newTickIndex;\n    }\n    \n    // Deposit into the ticks + into the LP\n    if (availToken0 > 0){\n      depositAndStash(ticks[tick0Index], availToken0 / 2, 0);\n      depositAndStash(ticks[tick0Index+1], availToken0 / 2, 0);\n    }\n    if (availToken1 > 0){\n      depositAndStash(ticks[tick1Index], 0, availToken1 / 2);\n      depositAndStash(ticks[tick1Index+1], 0, availToken1 / 2);\n    }\n    \n    if (newTickIndex != tickIndex) tickIndex = newTickIndex;\n    emit Rebalance(tickIndex);\n  }\n  \n  \n  /// @notice Checks that the pool price isn't manipulated\n  function poolMatchesOracle() public view returns (bool matches){\n    (uint160 sqrtPriceX96,,,,,,) = uniswapPool.slot0();\n    \n    uint decimals0 = token0.decimals();\n    uint decimals1 = token1.decimals();\n    uint priceX8 = 10**decimals0;\n    // Overflow if dont scale down the sqrtPrice before div 2*192\n    priceX8 = priceX8 * uint(sqrtPriceX96 / 2 ** 12) ** 2 * 1e8 / 2**168;\n    priceX8 = priceX8 / 10**decimals1;\n    uint oraclePrice = 1e8 * oracle.getAssetPrice(address(token0)) / oracle.getAssetPrice(address(token1));\n    if (oraclePrice < priceX8 * 101 / 100 && oraclePrice > priceX8 * 99 / 100) matches = true;\n  }\n\n\n  /// @notice Helper that checks current allowance and approves if necessary\n  /// @param token Target token\n  /// @param spender Spender\n  /// @param amount Amount below which we need to approve the token spending\n  function checkSetApprove(address token, address spender, uint amount) private {\n    if ( ERC20(token).allowance(address(this), spender) < amount ) ERC20(token).safeIncreaseAllowance(spender, type(uint256).max);\n  }\n  \n  \n  /// @notice Calculate the vault total ticks value\n  /// @return valueX8 Total value of the vault with 8 decimals\n  function getTVL() public view returns (uint valueX8){\n    for(uint k=0; k<ticks.length; k++){\n      TokenisableRange t = ticks[k];\n      uint bal = getTickBalance(k);\n      valueX8 += bal * t.latestAnswer() / 1e18;\n    }\n  }\n  \n  \n  /// @notice Deposit assets in a ticker, and the ticker in lending pool\n  /// @param t Tik address\n  /// @return liquidity The amount of ticker liquidity added\n  function depositAndStash(TokenisableRange t, uint amount0, uint amount1) internal returns (uint liquidity){\n    checkSetApprove(address(token0), address(t), amount0);\n    checkSetApprove(address(token1), address(t), amount1);\n    liquidity = t.deposit(amount0, amount1);\n    \n    uint bal = t.balanceOf(address(this));\n    if (bal > 0){\n      checkSetApprove(address(t), address(lendingPool), bal);\n      lendingPool.deposit(address(t), bal, address(this), 0);\n    }\n  }\n  \n  \n  /// @notice Get balance of tick deposited in GE\n  /// @param index Tick index\n  /// @return liquidity Amount of Ticker\n  function getTickBalance(uint index) public view returns (uint liquidity) {\n    TokenisableRange t = ticks[index];\n    address aTokenAddress = lendingPool.getReserveData(address(t)).aTokenAddress;\n    liquidity = ERC20(aTokenAddress).balanceOf(address(this));\n  }\n  \n  \n  /// @notice Return first valid tick\n  function getActiveTickIndex() public view returns (uint activeTickIndex) {\n    if (ticks.length >= 5){\n      // looking for index at which the underlying asset differs from the next tick\n      for (activeTickIndex = 0; activeTickIndex < ticks.length - 3; activeTickIndex++){\n        (uint amt0, uint amt1) = ticks[activeTickIndex+1].getTokenAmountsExcludingFees(1e18);\n        (uint amt0n, uint amt1n) = ticks[activeTickIndex+2].getTokenAmountsExcludingFees(1e18);\n        if ( (amt0 == 0 && amt0n > 0) || (amt1 == 0 && amt1n > 0) )\n          break;\n      }\n    }\n  }\n\n\n  /// @notice Get deposit fee\n  /// @param increaseToken0 Whether (token0 added || token1 removed) or not\n  /// @dev Simple linear model: from baseFeeX4 / 2 to baseFeeX4 * 2\n  /// @dev Call before withdrawing from ticks or reserves will both be 0\n  function getAdjustedBaseFee(bool increaseToken0) public view returns (uint adjustedBaseFeeX4) {\n    (uint res0, uint res1) = getReserves();\n    uint value0 = res0 * oracle.getAssetPrice(address(token0)) / 10**token0.decimals();\n    uint value1 = res1 * oracle.getAssetPrice(address(token1)) / 10**token1.decimals();\n\n    if (increaseToken0)\n      adjustedBaseFeeX4 = baseFeeX4 * value0 / (value1 + 1);\n    else\n      adjustedBaseFeeX4 = baseFeeX4 * value1 / (value0 + 1);\n\n    // Adjust from -50% to +50%\n    if (adjustedBaseFeeX4 < baseFeeX4 / 2) adjustedBaseFeeX4 = baseFeeX4 / 2;\n    if (adjustedBaseFeeX4 > baseFeeX4 * 3 / 2) adjustedBaseFeeX4 = baseFeeX4 * 3 / 2;\n  }\n\n\n  /// @notice fallback: deposit unless it's WETH being unwrapped\n  receive() external payable {\n    if(msg.sender != address(WETH)) deposit(address(WETH), msg.value);\n  }\n  \n}"
    },
    {
      "filename": "contracts/RangeManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/IAaveLendingPoolV2.sol\";\nimport \"../interfaces/IAaveOracle.sol\";\nimport \"../interfaces/IUniswapV2Pair.sol\";\nimport \"../interfaces/IUniswapV2Factory.sol\";\nimport \"../interfaces/IUniswapV2Router01.sol\";\nimport \"../interfaces/ISwapRouter.sol\";\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"./TokenisableRange.sol\";\nimport \"./openzeppelin-solidity/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"./openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\n\n\n/// @title Range middleware between ROE lending pool and various ranges\ncontract RangeManager is ReentrancyGuard, Ownable {\n  using SafeERC20 for ERC20;\n  ILendingPool public LENDING_POOL;\n  event Withdraw(address user, address asset, uint amount);\n  event Deposit(address user, address asset, uint amount);\n  event AddRange(uint128 startX10, uint128 endX10, uint step);\n\n  ERC20 public ASSET_0;\n  ERC20 public ASSET_1;\n\n  // Constant across chains - https://docs.uniswap.org/protocol/reference/deployments\n  INonfungiblePositionManager constant public POS_MGR = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);  \n\n  struct Step {\n    uint128 start;\n    uint128 end;\n  }\n\n  Step [] public stepList; \n  TokenisableRange [] public tokenisedRanges;\n  TokenisableRange [] public tokenisedTicker;\n  \n  \n  constructor(ILendingPool lendingPool, ERC20 _asset0, ERC20 _asset1)  {\n    require( address(lendingPool) != address(0x0), \"Invalid address\" );\n    LENDING_POOL = lendingPool;\n    ASSET_0 = _asset0 < _asset1 ? _asset0 : _asset1;\n    ASSET_1 = _asset0 < _asset1 ? _asset1 : _asset0;\n  }\n\n\n  /// @notice Checks validity and non overlap of the price ranges\n  /// @param start range low price bound\n  /// @param end range high price bound\n  function checkNewRange(uint128 start, uint128 end) internal view {\n    require(start < end, \"Range invalid\");\n    uint256 len = stepList.length;\n    for (uint i = 0; i < len; i++) {\n      if (start >= stepList[i].end || end <= stepList[i].start) {\n        continue;\n      }\n      revert(\"Range overlap\");\n    } \n  }\n  \n  /// @notice Generate Ticker and Ranger ranges\n  /// @param startX10 Range lower price scaled by 1e10\n  /// @param endX10 Range high price scaled by 1e10\n  /// @param startName Name of the range lower bound \n  /// @param endName Name of the range higher bound\n  function generateRange(uint128 startX10, uint128 endX10, string memory startName, string memory endName, address beacon) external onlyOwner {\n    require(beacon != address(0x0), \"Invalid beacon\");\n    checkNewRange(startX10, endX10);\n    stepList.push( Step(startX10, endX10) );\n    BeaconProxy trbp = new BeaconProxy(beacon, \"\");\n    tokenisedRanges.push( TokenisableRange(address(trbp)) );\n    trbp = new BeaconProxy(beacon, \"\");\n    tokenisedTicker.push( TokenisableRange(address(trbp)) );\n    IAaveOracle oracle = IAaveOracle(ILendingPoolAddressesProvider( LENDING_POOL.getAddressesProvider() ).getPriceOracle());\n    \n    tokenisedRanges[ tokenisedRanges.length - 1 ].initProxy(oracle, ASSET_0, ASSET_1, startX10, endX10, startName, endName, false);\n    tokenisedTicker[ tokenisedTicker.length - 1 ].initProxy(oracle, ASSET_0, ASSET_1, startX10, endX10, startName, endName, true); \n    emit AddRange(startX10, endX10, tokenisedRanges.length - 1);\n  }\n  \n  \n  /// @notice Initialize a previously created ticker\n  /// @param tr Range address\n  /// @param amount0 Amount of token0\n  /// @param amount1 Amount of token1\n  function initRange(address tr, uint amount0, uint amount1) external onlyOwner {\n    ASSET_0.safeTransferFrom(msg.sender, address(this), amount0);\n    ASSET_0.safeIncreaseAllowance(tr, amount0);\n    ASSET_1.safeTransferFrom(msg.sender, address(this), amount1);\n    ASSET_1.safeIncreaseAllowance(tr, amount1);\n    TokenisableRange(tr).init(amount0, amount1);\n    ERC20(tr).safeTransfer(msg.sender, TokenisableRange(tr).balanceOf(address(this)));\n  }\n\n\n  /// @notice Remove assets from tokenisedRanges\n  /// @param step Id of the range+ticker step from which to remove assets\n  function removeFromStep(uint256 step) internal {\n    require(step < tokenisedRanges.length && step < tokenisedTicker.length, \"Invalid step\");\n    uint256 trAmt;\n    \n    trAmt = ERC20(LENDING_POOL.getReserveData(address(tokenisedRanges[step])).aTokenAddress).balanceOf(msg.sender);   \n    if (trAmt > 0) {       \n        LENDING_POOL.PMTransfer(\n          LENDING_POOL.getReserveData(address(tokenisedRanges[step])).aTokenAddress, \n          msg.sender, \n          trAmt\n        );\n        trAmt = LENDING_POOL.withdraw(address(tokenisedRanges[step]), type(uint256).max, address(this));\n        tokenisedRanges[step].withdraw(trAmt, 0, 0);\n        emit Withdraw(msg.sender, address(tokenisedRanges[step]), trAmt);\n    }        \n\n    trAmt = ERC20(LENDING_POOL.getReserveData(address(tokenisedTicker[step])).aTokenAddress).balanceOf(msg.sender);\n    if (trAmt > 0) {    \n        LENDING_POOL.PMTransfer(\n          LENDING_POOL.getReserveData(address(tokenisedTicker[step])).aTokenAddress, \n          msg.sender, \n          trAmt\n        );\n        uint256 ttAmt = LENDING_POOL.withdraw(address(tokenisedTicker[step]), type(uint256).max, address(this));\n        tokenisedTicker[step].withdraw(ttAmt, 0, 0);\n        emit Withdraw(msg.sender, address(tokenisedTicker[step]), trAmt);\n    }           \n  }\n\n\n  /// @notice Remove assets from tokenisedRanges\n  /// @param step Id of the range+ticker step from which to remove assets\n  function removeAssetsFromStep(uint256 step) nonReentrant external {\n    removeFromStep(step);\n    cleanup();\n  }\n  \n  \n  /// @notice Transfer assets from the lending pool to a tokenizedRange\n  /// @param tr TokenisableRange instance into which to transfer assets\n  /// @param step Id of the range+ticker step from which to remove assets\n  /// @param amount0 Amount of asset0 to transfer in the TR\n  /// @param amount1 Amount of asset1 to transfer in the TR\n  /// @dev Useful to remove from a previous range and deposit into a new TR when price moves\n  function transferAssetsIntoStep(TokenisableRange tr, uint256 step, uint256 amount0, uint256 amount1) internal {\n    removeFromStep(step);\n    if (amount0 > 0) {    \n      LENDING_POOL.PMTransfer( LENDING_POOL.getReserveData(address(ASSET_0)).aTokenAddress, msg.sender, amount0 );\n      LENDING_POOL.withdraw( address(ASSET_0), amount0, address(this) );\n      ASSET_0.safeIncreaseAllowance(address(tr), amount0);\n    }\n    if (amount1 > 0) {\n      LENDING_POOL.PMTransfer( LENDING_POOL.getReserveData(address(ASSET_1)).aTokenAddress, msg.sender, amount1 );\n      LENDING_POOL.withdraw( address(ASSET_1), amount1, address(this) );\n      ASSET_1.safeIncreaseAllowance(address(tr), amount1);\n    }\n    uint256 lpAmt = tr.deposit(amount0, amount1);\n    emit Deposit(msg.sender, address(tr), lpAmt);\n    tr.approve(address(LENDING_POOL), lpAmt);\n    LENDING_POOL.deposit(address(tr), lpAmt, msg.sender, 0);\n    cleanup();\n  }\n\n\n  /// @notice Transfer assets from the lending pool to a Ranger\n  /// @param step Id of the range+ticker step from which to remove assets\n  /// @param amount0 Amount of asset0 to transfer in the Range\n  /// @param amount1 Amount of asset1 to transfer in the Range\n  function transferAssetsIntoRangerStep(uint256 step, uint256 amount0, uint256 amount1) nonReentrant external {\n    transferAssetsIntoStep(tokenisedRanges[step], step, amount0, amount1);\n  }\n\n\n  /// @notice Transfer assets from the lending pool to a Ticker\n  /// @param step Id of the range+ticker step from which to remove assets\n  /// @param amount0 Amount of asset0 to transfer in the Ticker\n  /// @param amount1 Amount of asset1 to transfer in the Ticker\n  function transferAssetsIntoTickerStep(uint256 step, uint256 amount0, uint256 amount1) nonReentrant external {\n    transferAssetsIntoStep(tokenisedTicker[step], step, amount0, amount1);\n  }\n\n\n  /// @notice Check token balances and return assets to the user\n  function cleanup() internal {\n    uint256 asset0_amt = ASSET_0.balanceOf(address(this));\n    uint256 asset1_amt = ASSET_1.balanceOf(address(this));\n    \n    if (asset0_amt > 0) {\n      ASSET_0.safeIncreaseAllowance(address(LENDING_POOL), asset0_amt);\n      LENDING_POOL.deposit(address(ASSET_0), asset0_amt, msg.sender, 0);\n    }\n    \n    if (asset1_amt > 0) {\n      ASSET_1.safeIncreaseAllowance(address(LENDING_POOL), asset1_amt);\n      LENDING_POOL.deposit(address(ASSET_1), asset1_amt, msg.sender, 0);\n    }\n    \n    // Check that health factor is not put into liquidation / with buffer\n    (,,,,,uint256 hf) = LENDING_POOL.getUserAccountData(msg.sender);\n    require(hf > 1.01e18, \"Health factor is too low\");\n  }\n\n\n  /// @notice Get length of stepList\n  /// @return listLength Length\n  function getStepListLength() external view returns (uint256 listLength) {\n    listLength = stepList.length;\n  }\n}"
    },
    {
      "filename": "contracts/RoeRouter.sol",
      "content": "// SPDX-License-Identifier: none\npragma solidity 0.8.19;\n\nimport \"./openzeppelin-solidity/contracts/access/Ownable.sol\";\n\n\n/**\n * Contract RoeRouter holds a list of whitelisted ROE lending pools and important parameters\n */\ncontract RoeRouter is Ownable {\n  /// EVENTS\n  event AddPool(uint poolId, address lendingPoolAddressProvider);\n  event DeprecatePool(uint poolId);\n  event UpdateTreasury(address treasury);\n\n  /// ROE treasury\n  address public treasury;\n\n  /// List of pools\n  RoePool[] public pools;\n\n  /// Lending pool structure\n  struct RoePool {\n    address lendingPoolAddressProvider;\n    address token0;\n    address token1;\n    address ammRouter;\n    bool isDeprecated;\n  }\n  \n  \n  /// @notice constructor\n  constructor (address treasury_) {\n    require(treasury_ != address(0x0), \"Invalid address\");\n    treasury = treasury_;\n  }\n  \n  \n  /// @notice Return pool list length\n  function getPoolsLength() public view returns (uint poolLength) {\n    poolLength = pools.length;\n  }\n  \n  \n  /// @notice Deprecate a pool\n  /// @param poolId pool ID\n  /// @dev isDeprecated is a statement about the pool record, and does not imply anything about the pool itself\n  function deprecatePool(uint poolId) public onlyOwner {\n    pools[poolId].isDeprecated = true;\n    emit DeprecatePool(poolId);\n  }\n  \n  \n  /// @notice Add a new pool parameters\n  /// @param lendingPoolAddressProvider address of a ROE Aave-compatible lending pool address provider\n  /// @param token0 address of the one token of the pair \n  /// @param token1 address of the second token of the pair\n  /// @param ammRouter address of the AMMv2 such that the LP pair ammRouter.factory.getPair(token0, token1) is supported by the lending pool\n  function addPool(\n    address lendingPoolAddressProvider, \n    address token0, \n    address token1, \n    address ammRouter\n  ) \n    public onlyOwner \n    returns (uint poolId)\n  {\n    require (\n      lendingPoolAddressProvider != address(0x0) \n      && token0 != address(0x0) \n      && token1 != address(0x0) \n      && ammRouter != address(0x0), \n      \"Invalid Address\"\n    );\n    require(token0 < token1, \"Invalid Order\");\n    pools.push(RoePool(lendingPoolAddressProvider, token0, token1, ammRouter, false));\n    poolId = pools.length - 1;\n    emit AddPool(poolId, lendingPoolAddressProvider);\n  }\n  \n  /// @notice Modify treaury address\n  /// @param newTreasury New treasury address\n  function setTreasury(address newTreasury) public onlyOwner {\n    require(newTreasury != address(0x0), \"Invalid address\");\n    treasury = newTreasury;\n    emit UpdateTreasury(newTreasury);\n  }\n}"
    },
    {
      "filename": "contracts/TokenisableRange.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport \"../interfaces/INonfungiblePositionManager.sol\";\nimport \"../interfaces/IUniswapV3Factory.sol\";\nimport \"../interfaces/IUniswapV3Pool.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./openzeppelin-solidity/contracts/utils/Strings.sol\";\nimport \"./openzeppelin-solidity/contracts/security/ReentrancyGuard.sol\";\nimport \"./lib/LiquidityAmounts.sol\";\nimport \"./lib/TickMath.sol\";\nimport \"../interfaces/IAaveOracle.sol\";\nimport \"../interfaces/IAaveOracle.sol\";\n\n\n/// @notice Tokenize a Uniswap V3 NFT position\ncontract TokenisableRange is ERC20(\"\", \"\"), ReentrancyGuard {\n  using SafeERC20 for ERC20;\n  /// EVENTS\n  event InitTR(address asset0, address asset1, uint128 startX10, uint128 endX10);\n  event Deposit(address sender, uint trAmount);\n  event Withdraw(address sender, uint trAmount);\n  event ClaimFees(uint fee0, uint fee1);\n  \n  /// VARIABLES\n\n  int24 public lowerTick;\n  int24 public upperTick;\n  uint24 public feeTier;\n  \n  uint256 public tokenId;\n  uint256 public fee0;\n  uint256 public fee1;\n  \n  struct ASSET {\n    ERC20 token;\n    uint8 decimals;\n  }\n  \n  ASSET public TOKEN0;\n  ASSET public TOKEN1;\n  IAaveOracle public ORACLE;\n  \n  string _name;\n  string _symbol;\n  \n  enum ProxyState { INIT_PROXY, INIT_LP, READY }\n  ProxyState public status;\n  address private creator;\n  \n  uint128 public liquidity;\n  // @notice deprecated, keep to avoid beacon storage slot overwriting errors\n  address public TREASURY_DEPRECATED = 0x22Cc3f665ba4C898226353B672c5123c58751692;\n  uint public treasuryFee_deprecated = 20;\n  \n  // These are constant across chains - https://docs.uniswap.org/protocol/reference/deployments\n  INonfungiblePositionManager constant public POS_MGR = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88); \n  IUniswapV3Factory constant public V3_FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984); \n  address constant public treasury = 0x22Cc3f665ba4C898226353B672c5123c58751692;\n  uint constant public treasuryFee = 20;\n\n  /// @notice Babylonian method for sqrt\n  /// @param x sqrt parameter\n  /// @return y Square root\n  function sqrt(uint x) internal pure returns (uint y) {\n      uint z = (x + 1) / 2;\n      y = x;\n      while (z < y) {\n          y = z;\n          z = (x / z + z) / 2;\n      }\n  }\n\n\n  /// @notice Store range parameters\n  /// @param _oracle Address of the IAaveOracle interface of the ROE lending pool\n  /// @param asset0 Quote token address\n  /// @param asset1 Base token address \n  /// @param startX10 Range lower price scaled by 1e10\n  /// @param endX10 Range high price scaled by 1e10\n  /// @param startName Name of the range lower bound \n  /// @param endName Name of the range higher bound\n  /// @param isTicker Range is single tick liquidity around upperTick/startX10/startName\n  function initProxy(IAaveOracle _oracle, ERC20 asset0, ERC20 asset1, uint128 startX10, uint128 endX10, string memory startName, string memory endName, bool isTicker) external {\n    require(address(_oracle) != address(0x0), \"Invalid oracle\");\n    require(status == ProxyState.INIT_PROXY, \"!InitProxy\");\n    creator = msg.sender;\n    status = ProxyState.INIT_LP;\n    ORACLE = _oracle;\n    \n    TOKEN0.token    = asset0;\n    TOKEN0.decimals = asset0.decimals();\n    TOKEN1.token     = asset1;\n    TOKEN1.decimals  = asset1.decimals();\n    string memory quoteSymbol = asset0.symbol();\n    string memory baseSymbol  = asset1.symbol();\n        \n    int24 _upperTick = TickMath.getTickAtSqrtRatio( uint160( 2**48 * sqrt( (2 ** 96 * (10 ** TOKEN1.decimals)) * 1e10 / (uint256(startX10) * 10 ** TOKEN0.decimals) ) ) );\n    int24 _lowerTick = TickMath.getTickAtSqrtRatio( uint160( 2**48 * sqrt( (2 ** 96 * (10 ** TOKEN1.decimals)) * 1e10 / (uint256(endX10  ) * 10 ** TOKEN0.decimals) ) ) );\n    \n    if (isTicker) { \n      feeTier   = 5;\n      int24 midleTick;\n      midleTick = (_upperTick + _lowerTick) / 2;\n      _upperTick = (midleTick + int24(feeTier)) - (midleT"
    }
  ]
}