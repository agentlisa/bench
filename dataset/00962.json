{
  "Title": "Chainlinks oracle feeds are not immutable",
  "Content": "# Chainlinks oracle feeds are not immutable\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/ChainlinkARBOracle.sol#L239\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/ChainlinkARBOracle.sol#L239</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/ChainlinkARBOracle.sol#L65\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/oracles/ChainlinkARBOracle.sol#L65</a>\n\n\n## Summary\n\nThat a chainlink oracle works does not mean it will be supported by chainlink in the future and keeps working, and it could also be possible that the address of the price feed changes. Therefore, it does not make sense to prevent price feed addresses from being updated, or removed, but the protocol prevents that.\n\n## Vulnerability Details\n\nThere is only one function inside ChainlinkARBOracle to update the price feed addresses:\n\n```jsx\nfunction addTokenPriceFeed(address token, address feed) external onlyOwner {\n  if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n  if (feed == address(0)) revert Errors.ZeroAddressNotAllowed();\n  if (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n\n  feeds[token] = feed;\n}\n```\n\nAs we can see it will only allow to set the price feed ones and revert if trying to update, or remove a price feed. Therefore, if chainlink changes something, or the owner accidentally set the wrong address, or the protocol no longer wants to support a price feed, it can not be removed, or updated.\n\n## Impact\n\nIt is not possible to remove price feeds which are no longer supported by chainlink, or update the addresses of price feeds. This can lead to a complete DoS of the underlying token.\n\nAs this feeds mapping is also the only check if it is a valid token when calling the oracle and the feed can not be removed, it will always pass this check even if the protocol no longer wishes to support this token:\n\n```jsx\nfunction consult(address token) public view whenNotPaused returns (int256, uint8) {\n  address _feed = feeds[token];\n\n  if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\t...\n}\n```\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nRemove this line:\n\n```jsx\nif (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/oracles/ChainlinkARBOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\ncontract ChainlinkARBOracle is Ownable2Step, Pausable {\n  using SafeCast for int256;\n\n  /* ======================= STRUCTS ========================= */\n\n  struct ChainlinkResponse {\n    uint80 roundId;\n    int256 answer;\n    uint256 timestamp;\n    bool success;\n    uint8 decimals;\n  }\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant SEQUENCER_GRACE_PERIOD_TIME = 1 hours;\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // Chainlink Arbitrum sequencer feed address\n  AggregatorV3Interface internal sequencerUptimeFeed;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Mapping of token to Chainlink USD price feed\n  mapping(address => address) public feeds;\n  // Mapping of token to maximum delay allowed (in seconds) of last price update\n  mapping(address => uint256) public maxDelays;\n  // Mapping of token to maximum % deviation allowed (in 1e18) of last price update\n  mapping(address => uint256) public maxDeviations;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param sequencerFeed  Chainlink Arbitrum sequencer feed address\n  */\n  constructor(address sequencerFeed) Ownable(msg.sender) {\n    if (sequencerFeed == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    sequencerUptimeFeed = AggregatorV3Interface(sequencerFeed);\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get token price from Chainlink feed\n    * @param token Token address\n    * @return price Asset price in int256\n    * @return decimals Price decimals in uint8\n  */\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n\n  /**\n    * @notice Get token price from Chainlink feed returned in 1e18\n    * @param token Token address\n    * @return price in 1e18\n  */\n  function consultIn18Decimals(address token) external view whenNotPaused returns (uint256) {\n    (int256 _answer, uint8 _decimals) = consult(token);\n\n    return _answer.toUint256() * 1e18 / (10 ** _decimals);\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if Chainlink oracle is not working as expected\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsBroken(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    return _badChainlinkResponse(currentResponse) ||\n           _badChainlinkResponse(prevResponse) ||\n           _badPriceDeviation(currentResponse, prevResponse, token);\n  }\n\n  /**\n    * @notice Checks to see if Chainlink oracle is returning a bad response\n    * @param response Chainlink response\n    * @return Status of check in boolean\n  */\n  function _badChainlinkResponse(ChainlinkResponse memory response) internal view returns (bool) {\n    // Check for response call reverted\n    if (!response.success) { return true; }\n    // Check for an invalid roundId that is 0\n    if (response.roundId == 0) { return true; }\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (response.timestamp == 0 || response.timestamp > block.timestamp) { return true; }\n    // Check for non-positive price\n    if (response.answer == 0) { return true; }\n\n    return false;\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle response is frozen/too stale\n    * @param response Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsFrozen(ChainlinkResponse memory response, address token) internal view returns (bool) {\n    return (block.timestamp - response.timestamp) > maxDelays[token];\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle current response's price price deviation\n    * is too large compared to previous response's price\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _badPriceDeviation(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    // Check for a deviation that is too large\n    uint256 _deviation;\n\n    if (currentResponse.answer > prevResponse.answer) {\n      _deviation = uint256(currentResponse.answer - prevResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    } else {\n      _deviation = uint256(prevResponse.answer - currentResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    }\n\n    return _deviation > maxDeviations[token];\n  }\n\n  /**\n    * @notice Get latest Chainlink response\n    * @param _feed Chainlink oracle feed address\n    * @return ChainlinkResponse\n  */\n  function _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    // Arbitrum sequencer uptime feed\n    (\n      /* uint80 _roundID*/,\n      int256 _answer,\n      uint256 _startedAt,\n      /* uint256 _updatedAt */,\n      /* uint80 _answeredInRound */\n    ) = sequencerUptimeFeed.latestRoundData();\n\n    // Answer == 0: Sequencer is up\n    // Answer == 1: Sequencer is down\n    bool _isSequencerUp = _answer == 0;\n    if (!_isSequencerUp) revert Errors.SequencerDown();\n\n    // Make sure the grace period has passed after the\n    // sequencer is back up.\n    uint256 _timeSinceUp = block.timestamp - _startedAt;\n    if (_timeSinceUp <= SEQUENCER_GRACE_PERIOD_TIME) revert Errors.GracePeriodNotOver();\n\n    (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n  }\n\n  /**\n    * @notice Get previous round's Chainlink response from current round\n    * @param _feed Chainlink oracle feed address\n    * @param _currentRoundId Current roundId from current Chainlink response\n    * @return ChainlinkResponse\n  */\n  function _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n      uint80 _roundId,\n      int256 _answer,\n      /* uint256 _startedAt */,\n      uint256 _timestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Add Chainlink price feed for token\n    * @param token Token address\n    * @param feed Chainlink price feed address\n  */\n  function addTokenPriceFeed(address token, address feed) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feed == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n\n    feeds[token] = feed;\n  }\n\n  /**\n    * @notice Add Chainlink max delay for token\n    * @param token Token address\n    * @param maxDelay  Max delay allowed in seconds\n  */\n  function addTokenMaxDelay(address token, uint256 maxDelay) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDelay < 0) revert Errors.TokenPriceFeedMaxDelayMustBeGreaterOrEqualToZero();\n\n    maxDelays[token] = maxDelay;\n  }\n\n  /**\n    * @notice Add Chainlink max deviation for token\n    * @param token Token address\n    * @param maxDeviation  Max deviation allowed in seconds\n  */\n  function addTokenMaxDeviation(address token, uint256 maxDeviation) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDeviation < 0) revert Errors.TokenPriceFeedMaxDeviationMustBeGreaterOrEqualToZero();\n\n    maxDeviations[token] = maxDeviation;\n  }\n\n  /**\n    * @notice Emergency pause of this oracle\n  */\n  function emergencyPause() external onlyOwner whenNotPaused {\n    _pause();\n  }\n\n  /**\n    * @notice Emergency resume of this oracle\n  */\n  function emergencyResume() external onlyOwner whenPaused {\n    _unpause();\n  }\n}"
    },
    {
      "filename": "contracts/oracles/ChainlinkARBOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\ncontract ChainlinkARBOracle is Ownable2Step, Pausable {\n  using SafeCast for int256;\n\n  /* ======================= STRUCTS ========================= */\n\n  struct ChainlinkResponse {\n    uint80 roundId;\n    int256 answer;\n    uint256 timestamp;\n    bool success;\n    uint8 decimals;\n  }\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant SEQUENCER_GRACE_PERIOD_TIME = 1 hours;\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // Chainlink Arbitrum sequencer feed address\n  AggregatorV3Interface internal sequencerUptimeFeed;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Mapping of token to Chainlink USD price feed\n  mapping(address => address) public feeds;\n  // Mapping of token to maximum delay allowed (in seconds) of last price update\n  mapping(address => uint256) public maxDelays;\n  // Mapping of token to maximum % deviation allowed (in 1e18) of last price update\n  mapping(address => uint256) public maxDeviations;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param sequencerFeed  Chainlink Arbitrum sequencer feed address\n  */\n  constructor(address sequencerFeed) Ownable(msg.sender) {\n    if (sequencerFeed == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    sequencerUptimeFeed = AggregatorV3Interface(sequencerFeed);\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get token price from Chainlink feed\n    * @param token Token address\n    * @return price Asset price in int256\n    * @return decimals Price decimals in uint8\n  */\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n\n  /**\n    * @notice Get token price from Chainlink feed returned in 1e18\n    * @param token Token address\n    * @return price in 1e18\n  */\n  function consultIn18Decimals(address token) external view whenNotPaused returns (uint256) {\n    (int256 _answer, uint8 _decimals) = consult(token);\n\n    return _answer.toUint256() * 1e18 / (10 ** _decimals);\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if Chainlink oracle is not working as expected\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsBroken(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    return _badChainlinkResponse(currentResponse) ||\n           _badChainlinkResponse(prevResponse) ||\n           _badPriceDeviation(currentResponse, prevResponse, token);\n  }\n\n  /**\n    * @notice Checks to see if Chainlink oracle is returning a bad response\n    * @param response Chainlink response\n    * @return Status of check in boolean\n  */\n  function _badChainlinkResponse(ChainlinkResponse memory response) internal view returns (bool) {\n    // Check for response call reverted\n    if (!response.success) { return true; }\n    // Check for an invalid roundId that is 0\n    if (response.roundId == 0) { return true; }\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (response.timestamp == 0 || response.timestamp > block.timestamp) { return true; }\n    // Check for non-positive price\n    if (response.answer == 0) { return true; }\n\n    return false;\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle response is frozen/too stale\n    * @param response Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsFrozen(ChainlinkResponse memory response, address token) internal view returns (bool) {\n    return (block.timestamp - response.timestamp) > maxDelays[token];\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle current response's price price deviation\n    * is too large compared to previous response's price\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _badPriceDeviation(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    // Check for a deviation that is too large\n    uint256 _deviation;\n\n    if (currentResponse.answer > prevResponse.answer) {\n      _deviation = uint256(currentResponse.answer - prevResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    } else {\n      _deviation = uint256(prevResponse.answer - currentResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    }\n\n    return _deviation > maxDeviations[token];\n  }\n\n  /**\n    * @notice Get latest Chainlink response\n    * @param _feed Chainlink oracle feed address\n    * @return ChainlinkResponse\n  */\n  function _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    // Arbitrum sequencer uptime feed\n    (\n      /* uint80 _roundID*/,\n      int256 _answer,\n      uint256 _startedAt,\n      /* uint256 _updatedAt */,\n      /* uint80 _answeredInRound */\n    ) = sequencerUptimeFeed.latestRoundData();\n\n    // Answer == 0: Sequencer is up\n    // Answer == 1: Sequencer is down\n    bool _isSequencerUp = _answer == 0;\n    if (!_isSequencerUp) revert Errors.SequencerDown();\n\n    // Make sure the grace period has passed after the\n    // sequencer is back up.\n    uint256 _timeSinceUp = block.timestamp - _startedAt;\n    if (_timeSinceUp <= SEQUENCER_GRACE_PERIOD_TIME) revert Errors.GracePeriodNotOver();\n\n    (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n  }\n\n  /**\n    * @notice Get previous round's Chainlink response from current round\n    * @param _feed Chainlink oracle feed address\n    * @param _currentRoundId Current roundId from current Chainlink response\n    * @return ChainlinkResponse\n  */\n  function _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n      uint80 _roundId,\n      int256 _answer,\n      /* uint256 _startedAt */,\n      uint256 _timestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Add Chainlink price feed for token\n    * @param token Token address\n    * @param feed Chainlink price feed address\n  */\n  function addTokenPriceFeed(address token, address feed) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feed == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n\n    feeds[token] = feed;\n  }\n\n  /**\n    * @notice Add Chainlink max delay for token\n    * @param token Token address\n    * @param maxDelay  Max delay allowed in seconds\n  */\n  function addTokenMaxDelay(address token, uint256 maxDelay) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDelay < 0) revert Errors.TokenPriceFeedMaxDelayMustBeGreaterOrEqualToZero();\n\n    maxDelays[token] = maxDelay;\n  }\n\n  /**\n    * @notice Add Chainlink max deviation for token\n    * @param token Token address\n    * @param maxDeviation  Max deviation allowed in seconds\n  */\n  function addTokenMaxDeviation(address token, uint256 maxDeviation) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDeviation < 0) revert Errors.TokenPriceFeedMaxDeviationMustBeGreaterOrEqualToZero();\n\n    maxDeviations[token] = maxDeviation;\n  }\n\n  /**\n    * @notice Emergency pause of this oracle\n  */\n  function emergencyPause() external onlyOwner whenNotPaused {\n    _pause();\n  }\n\n  /**\n    * @notice Emergency resume of this oracle\n  */\n  function emergencyResume() external onlyOwner whenPaused {\n    _unpause();\n  }\n}"
    }
  ]
}