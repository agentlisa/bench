{
  "Title": "Gas Limit Exploitation and Order Book Blockage Due to High-Priced Bids",
  "Content": "# Gas Limit Exploitation and Order Book Blockage Due to High-Priced Bids\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/BidOrdersFacet.sol#L39\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/BidOrdersFacet.sol#L39</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/AskOrdersFacet.sol\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/AskOrdersFacet.sol</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOrders.sol#L627\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOrders.sol#L627</a>\n\n\n## Summary:\n\n- In scenarios where there are no existing `asks` or `shorts` in a specific market order book, a malicious user can disrupt the market. By flooding the market with numerous small `bids` at an exceptionally high price, this will lead to :\n prevent new `limit asks` or `limit shorts` from being created below their bid price(which too high) cause the matching algorithm will reach the **gasLimit** matching a bunsh of small `bids` with the incoming `sell order`.also No bids below his price will get matched. and the liquidation process in `primaryMarginCall` will not be possible for `short records`.\n\n\n\n## Vulnerability Details:\n\nThe vulnerability arises cause the way how matching algorithm in function `sellMatchAlgo` in the `LibOrders.sol` library matches incoming `ask` with the highest `bid`. Here's how the problem unfolds:\n\n1. **Matching Algorithm Flaw**:\n\n   - when a new ask is created,it's get created in the `AskOrdersFacet` in function `createAsk` triggering the `sellMatchAlgo()` function.\n\n   ```solidity\n   function createAsk(\n        address asset,\n        uint80 price,\n        uint88 ercAmount,\n        bool isMarketOrder,\n        MTypes.OrderHint[] calldata orderHintArray\n    ) external isNotFrozen(asset) onlyValidAsset(asset) nonReentrant {\n        uint256 eth = price.mul(ercAmount);\n        uint256 minAskEth = LibAsset.minAskEth(asset);\n        if (eth < minAskEth) revert Errors.OrderUnderMinimumSize();\n        ......\n        .......\n        LibOrders.sellMatchAlgo(asset, incomingAsk, orderHintArray, minAskEth);//@audit ..\n    }\n   ```\n\n   - If the `ask` **price** is less than or equal to the highest `bid` **price** and the ask amount is less than the highest bid amount, the ask matches with the bid and doesn't get added to the order book.\n   - The highest `bid` matched stays as the highest bid in the `bids` list with less `amount` .\n     > bidOrder.amount = StartingAmount - MatchedAmount. </br>\n     > and the bidder will get his erc tokens in thier virtual balance in the system. as we see in this snippet code :\n\n   ```solidity\n   // when the  : amount  ask < amount bid\n    else {\n         //update the erc amount of the highest bid ,by sub the ask amount erc\n        s.bids[asset][highestBid.id].ercAmount = highestBid.ercAmount - incomingAsk.ercAmount;\n        updateBidOrdersOnMatch(s.bids, asset, highestBid.id, false);\n       }\n       incomingAsk.ercAmount = 0; // set ask ercAmount to zero.\n       matchIncomingSell(asset, incomingAsk, matchTotal);\n       return;\n       .............................................................\n\n   // match highest bid when amount ask < amount bid :\n   function matchHighestBid(STypes.Order memory incomingSell,STypes.Order memory highestBid,address asset,\n       MTypes.Match memory matchTotal\n   ) internal {\n       ...\n       ...\n       s.assetUser[asset][highestBid.addr].ercEscrowed += fillErc;\n   }\n   ```\n\n2. **Exploitable Scenario**:\n\n   - The vulnerability emerges when there are no existing `asks` or `shorts` in the order book. (or even if there is but the attacker should buy them all).\n   - A malicious user can exploit this by :\n\n   1. creating a `bid` with an exorbitantly high price. Then, they create an `ask` with the same price but slightly less in amount (e.g., 10 wei lower). This left a tiny highest `bid` in the order book.\n\n   2. The user then create another bid with a slightly higher price than the existing highest bid (`1wei`). and another ask that matches with this new highest bid but left a tiny amount again. now E.g. we have :\n      | Bids Price | Bids Amounts |\n      |------------|-------------|\n      | 1 | 100 |\n      | 2 | 340 |\n      | 100 | 0.001 |\n      | 100.01 | 0.001 |\n\n3. repeating this process in a loop. This results in bunsh of tiny bids with disproportionately high prices in the order book.\n\n4. **Gas Limit and Reversion**:\n\n   - When a new regular ask is created with a standard price, due to the existence of these numerous tiny high-priced bids, the matching algorithm starts looping through all these bids to match the incoming ask.\n   - However, because there are many tiny bids, the transaction reaches the **_gas limit_** before the entire ask amount is matched. This premature termination of the transaction leads to a revert,\n   - `NOTICE` that the askers can't create an ask that have tiny amount with the same price of the bidder to match with a Reasonable number of `bids` that not gonna reach the gas limit . that's because there is a `minAmountEth` which is :\n\n     > `price * amount ` > `mintEth` </br>\n\n     assume the following :\n\n     - the Malicious user create **1000** bid. the highest bid is : </br>\n       {price : `1 ether + 1000 wei` , amount : `10 wei`}</br>\n       the price in each previous bid is `1 wei` less . so the first bid is : </br>\n       {price : `1 ether` , amount : `10 wei`}\n     - now let's calculate the minimum amount of erc tokens (pagged asset) that an asker can create ask with it at the highest price (`1 ether` for each asset which too high). </br>\n     - assume `MinEth` is : `0.001 ether` </br>.\n       we have :\n       - **MinEth** = **Price** \\* **ErcAmount**  </br>\n       - **ErcAmount** = **MinEth** / **price** </br>\n         so the min erc amount at the price the malicious user set as the highest bid will be :</br>\n         **ercAmount** = 0.001 ether \\* 1 ether / 1 ether = **_1000000000000_** `wei`.</br>\n\n   - **However**, the sum of all the malicious bid amounts from highest to lowest is: `1000 Ã— 10 = 10000 wei`. Even if an ask attempts to match the highest bid price, the ask still needs to have a large amount, leading to looping through all these tiny bids. This looping process causes the transaction to reach the gas limit, resulting in a premature termination of the transaction.\n  -  The same is applicable for `shorts limits`.\n   - for bidders there is no incentive to create a `bid` that's higher than this price.(which toooo high)\n   - the attack will not cost the malicious user too much , since he is matching with it self. the eth amount will cost him for the example provided around : **10000** `wei`and gas fee.\n - **by doing this an attacker can set above the highest bid price,an ask order with with slitlly higher price but with a larger amount that he buy before . forcing the shorters to buy at his price to close thier debt. or just lose thier collateral in case of secondary call for example**.\n## poc \n- using the same [repo](https://github.com/Cyfrin/2023-09-ditto) setup for testing,this is the POC .\n```solidity \npragma solidity 0.8.21;\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, O} from \"contracts/libraries/DataTypes.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport \"forge-std/console.sol\";\nimport {OBFixture} from \"test/utils/OBFixture.sol\";\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract POC is OBFixture {\n    address[3] private users = [address(435433), address(423432523), address(522366)];\n    address attacker = address(424234234232342);\n    function setUp() public override {\n        super.setUp();\n        vm.label(attacker,\"attacker\");\n        // first create some pagged assets by matching shorts with bids \n        fundLimitBidOpt(DEFAULT_PRICE*3, DEFAULT_AMOUNT * 100, users[0]); \n        fundLimitBidOpt(DEFAULT_PRICE * 2, DEFAULT_AMOUNT * 50, users[0]); \n        fundLimitShortOpt(uint80(DEFAULT_PRICE), DEFAULT_AMOUNT*150, users[0]);\n        // give the attacker some assets : \n        depositEth(attacker,DEFAULT_AMOUNT * 100);\n        depositUsd(attacker, DEFAULT_AMOUNT * 1000);\n    }\n    function attacker_setup() public { \n        // check his balance before the bunsh of bids he will create : \n        uint  balanceZethBefore = diamond.getZethBalance(vault,attacker);\n        uint balanceAssetBefore = diamond.getAssetBalance(asset,attacker);\n        vm.startPrank(attacker);\n        uint16 id;\n        uint80 latestPrice;\n        for (uint i;i<5000;i++){ \n            if(i == 0){\n                latestPrice = DEFAULT_PRICE *50;\n            }\n            // fundLimitBidOpt(latestPrice , DEFAULT_AMOUNT ,attacker);\n            createLimitBid(latestPrice, DEFAULT_AMOUNT);\n            // get highest bid : \n            (, id) = diamond.getBidKey(asset,1);\n             latestPrice = diamond.getBidOrder(asset,id).price;\n            //  console.log(latestPrice);\n            // create ask with same price , and amount less 1 wei: \n            createLimitAsk( latestPrice, DEFAULT_AMOUNT - 80);\n\n            latestPrice += 1;//2wei;\n        }\n        vm.stopPrank();\n        STypes.Order[] memory bids = diamond.getBids(asset);\n        console.log( \"hack cost zeth\",  balanceZethBefore - diamond.getZethBalance(vault,attacker));\n        console.log( \"hack cost asset\", balanceAssetBefore - diamond.getAssetBalance(asset,attacker));\n        console.log(\"bids that attacker create :\",bids.length);\n       console.log(\"amount in each bid \",bids[4].ercAmount);\n\n        \n    }\n\n    function test_reachGasLimit() public {\n       attacker_setup();\n         uint before = gasleft();\n        fundLimitAskOpt(DEFAULT_PRICE*3, DEFAULT_AMOUNT, users[0]); \n        uint afterr = gasleft();\n        console.log(\"gasUsed\" , before - afterr);\n    }\n\n}\n```\n- console after running test : \n```sh\n Compiler run successful!\n\nRunning 1 test for test/poc.sol:POC\n[PASS] test_reachGasLimit() (gas: 723550417)\nLogs:\n  hack cost zeth 9999\n  hack cost asset 0\n  bids that attacker create : 5000\n  amount in each bid  80\n  gasUsed 35013047\n\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 2.50s\n \nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n## Impact\n1 . **shorters can't close thier position**: the shorters will be at risk to not be able to close thier `debt` position . only if they buy the ***ercAsset*** above the price the attacker set. which likelly will be the attacker `ask`.\n2. **Limited Order Creation**: Users are restricted from creating `asks` (both limit and market) and setting `shorts limits` below the price set by the attacker. This restriction significantly hampers market activities since there's no incentive for legitimate bidders to buy the pegged asset at an inflated price.\n\n3. **Blocked Order Book Functionality**: Bids placed below the attacker's price will never match with any asks, effectively blocking the entire order book from functioning below the attacker's specified price. This obstruction disrupts the natural trading process and prevents legitimate buyers and sellers from interacting in the market.\n\n4. **Impaired Liquidation Process**: The primary liquidation mechanism becomes impractical because it relies on creating a `forceBid`, which behaves like a regular bid order. However, these force bids, similar to other bids, won't match due to the artificially inflated price. Consequently, the primary liquidation process is rendered ineffective, preventing the clearing of outstanding positions and increasing the risk of market instability.\n5. users who tried to create an ask or short limit. will pay a high **gas fee** . and the transaction will revert at the end.\n\n## Tool used\n**Manual Review**\n## Recommendation\nI would recommend Adding a limit orders to match in the algorithm. that not exceed the block limit gas.\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/BidOrdersFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, O, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BidOrdersFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n    using {LibOrders.isShort} for STypes.Order;\n\n    /**\n     * @notice Creates bid order in market\n     * @dev IncomingBid created here instead of BidMatchAlgo to prevent stack too deep\n     *\n     * @param asset The market that will be impacted\n     * @param price Unit price in eth for erc\n     * @param ercAmount Amount of erc to buy\n     * @param isMarketOrder Boolean for whether the bid is limit or market\n     * @param orderHintArray Array of hint ID for gas-optimized sorted placement on market\n     * @param shortHintArray Array of hint ID for gas-optimized short matching above oracle price\n     *\n     * @return ethFilled Amount of eth filled\n     * @return ercAmountLeft Amount of erc not matched\n     */\n\n    function createBid(\n        address asset,\n        uint80 price,\n        uint88 ercAmount,\n        bool isMarketOrder,\n        MTypes.OrderHint[] calldata orderHintArray,\n        uint16[] calldata shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        onlyValidAsset(asset)\n        nonReentrant\n        returns (uint88 ethFilled, uint88 ercAmountLeft)\n    {\n        // Update oracle and starting short if last updated more than 1 hour ago\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            asset, OF.OneHour, shortHintArray\n        );\n\n        return _createBid(\n            msg.sender,\n            asset,\n            price,\n            ercAmount,\n            isMarketOrder,\n            orderHintArray,\n            shortHintArray\n        );\n    }\n\n    /**\n     * @notice create a bid order for exiting a short, only callable by specific contracts\n     *\n     * @param sender Address of caller (only for exiting a short)\n     * @param asset The market that will be impacted\n     * @param price Unit price in eth for erc\n     * @param ercAmount Amount of erc to buy\n     * @param shortHintArray Array of hint ID for gas-optimized short matching above oracle price\n     *\n     * @return ethFilled Amount of eth filled\n     * @return ercAmountLeft Amount of erc not matched\n     */\n    function createForcedBid(\n        address sender,\n        address asset,\n        uint80 price,\n        uint88 ercAmount,\n        uint16[] calldata shortHintArray\n    ) external onlyDiamond returns (uint88 ethFilled, uint88 ercAmountLeft) {\n        //@dev leave empty, don't need hint for market buys\n        MTypes.OrderHint[] memory orderHintArray;\n\n        // @dev update oracle in callers\n        return _createBid(\n            sender,\n            asset,\n            price,\n            ercAmount,\n            Constants.MARKET_ORDER,\n            orderHintArray,\n            shortHintArray\n        );\n    }\n\n    function _createBid(\n        address sender,\n        address asset,\n        uint80 price,\n        uint88 ercAmount,\n        bool isMarketOrder,\n        MTypes.OrderHint[] memory orderHintArray,\n        uint16[] memory shortHintArray\n    ) private returns (uint88 ethFilled, uint88 ercAmountLeft) {\n        uint256 eth = ercAmount.mul(price);\n        if (eth < LibAsset.minBidEth(asset)) revert Errors.OrderUnderMinimumSize();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        if (s.vaultUser[Asset.vault][sender].ethEscrowed < eth) {\n            revert Errors.InsufficientETHEscrowed();\n        }\n\n        STypes.Order memory incomingBid;\n        incomingBid.addr = sender;\n        incomingBid.price = price;\n        incomingBid.ercAmount = ercAmount;\n        incomingBid.id = Asset.orderId;\n        incomingBid.orderType = isMarketOrder ? O.MarketBid : O.LimitBid;\n        incomingBid.creationTime = LibOrders.getOffsetTime();\n\n        MTypes.BidMatchAlgo memory b;\n        b.oraclePrice = LibOracle.getPrice(asset);\n        b.askId = s.asks[asset][Constants.HEAD].nextId;\n        //@dev setting initial shortId to match \"backwards\" (See _shortDirectionHandler() below)\n        b.shortHintId = b.shortId = Asset.startingShortId;\n\n        emit Events.CreateBid(asset, sender, incomingBid.id, incomingBid.creationTime);\n\n        STypes.Order memory lowestSell = _getLowestSell(asset, b);\n        if (\n            incomingBid.price >= lowestSell.price\n                && (\n                    lowestSell.orderType == O.LimitAsk || lowestSell.orderType == O.LimitShort\n                )\n        ) {\n            //@dev if match and match price is gt .5% to saved oracle in either direction, update startingShortId\n            LibOrders.updateOracleAndStartingShortViaThreshold(\n                asset, b.oraclePrice, incomingBid, shortHintArray\n            );\n            b.shortHintId = b.shortId = Asset.startingShortId;\n            return bidMatchAlgo(asset, incomingBid, orderHintArray, b);\n        } else {\n            //@dev no match, add to market if limit order\n            LibOrders.addBid(asset, incomingBid, orderHintArray);\n            return (0, ercAmount);\n        }\n    }\n\n    /**\n     * @notice The matching algorithm for bids\n     *\n     * @param asset The market that will be impacted\n     * @param incomingBid Active bid order\n     * @param orderHintArray Array of hint ID for gas-optimized sorted placement on market\n     * @param b Memory struct used throughout bidMatchAlgo\n     *\n     * @return ethFilled Amount of eth filled\n     * @return ercAmountLeft Amount of erc not matched\n     */\n    function bidMatchAlgo(\n        address asset,\n        STypes.Order memory incomingBid,\n        MTypes.OrderHint[] memory orderHintArray,\n        MTypes.BidMatchAlgo memory b\n    ) private returns (uint88 ethFilled, uint88 ercAmountLeft) {\n        uint256 minBidEth = LibAsset.minBidEth(asset);\n        MTypes.Match memory matchTotal;\n\n        while (true) {\n            //@dev Handles scenario when no sells left after partial fill\n            if (b.askId == Constants.TAIL && b.shortId == Constants.TAIL) {\n                if (incomingBid.ercAmount.mul(incomingBid.price) >= minBidEth) {\n                    LibOrders.addBid(asset, incomingBid, orderHintArray);\n                }\n                return matchIncomingBid(asset, incomingBid, matchTotal, b);\n            }\n\n            STypes.Order memory lowestSell = _getLowestSell(asset, b);\n\n            if (incomingBid.price >= lowestSell.price) {\n                // Consider bid filled if only dust amount left\n                if (incomingBid.ercAmount.mul(lowestSell.price) == 0) {\n                    return matchIncomingBid(asset, incomingBid, matchTotal, b);\n                }\n                matchlowestSell(asset, lowestSell, incomingBid, matchTotal);\n                if (incomingBid.ercAmount > lowestSell.ercAmount) {\n                    incomingBid.ercAmount -= lowestSell.ercAmount;\n                    lowestSell.ercAmount = 0;\n                    if (lowestSell.isShort()) {\n                        b.matchedShortId = lowestSell.id;\n                        b.prevShortId = lowestSell.prevId;\n                        LibOrders.matchOrder(s.shorts, asset, lowestSell.id);\n                        _shortDirectionHandler(asset, lowestSell, incomingBid, b);\n                    } else {\n                        b.matchedAskId = lowestSell.id;\n                        LibOrders.matchOrder(s.asks, asset, lowestSell.id);\n                        b.askId = lowestSell.nextId;\n                    }\n                } else {\n                    // If the product of remaining ercAmount and price rounds down to 0 just close the sell order\n                    bool dustErcAmount = (lowestSell.ercAmount - incomingBid.ercAmount)\n                        .mul(lowestSell.price) == 0;\n\n                    if (dustErcAmount || incomingBid.ercAmount == lowestSell.ercAmount) {\n                        if (lowestSell.isShort()) {\n                            b.matchedShortId = lowestSell.id;\n                            b.prevShortId = lowestSell.prevId;\n                            LibOrders.matchOrder(s.shorts, asset, lowestSell.id);\n                        } else {\n                            b.matchedAskId = lowestSell.id;\n                            LibOrders.matchOrder(s.asks, asset, lowestSell.id);\n                        }\n                    } else {\n                        if (lowestSell.isShort()) {\n                            STypes.Order storage lowestShort =\n                                s.shorts[asset][lowestSell.id];\n                            lowestShort.ercAmount =\n                                lowestSell.ercAmount - incomingBid.ercAmount;\n                            lowestShort.shortRecordId = lowestSell.shortRecordId;\n                        } else {\n                            s.asks[asset][lowestSell.id].ercAmount =\n                                lowestSell.ercAmount - incomingBid.ercAmount;\n                        }\n                    }\n                    lowestSell.ercAmount -= incomingBid.ercAmount;\n                    incomingBid.ercAmount = 0;\n                    return matchIncomingBid(asset, incomingBid, matchTotal, b);\n                }\n            } else {\n                if (incomingBid.ercAmount.mul(incomingBid.price) >= minBidEth) {\n                    LibOrders.addBid(asset, incomingBid, orderHintArray);\n                }\n                return matchIncomingBid(asset, incomingBid, matchTotal, b);\n            }\n        }\n    }\n    /**\n     * @notice Settles lowest ask and updates incoming bid\n     * @dev DittoMatchedShares only assigned for asks sitting > 2 weeks of seconds\n     *\n     * @param asset The market that will be impacted\n     * @param lowestSell Lowest sell order (ask or short) on market\n     * @param incomingBid Active bid order\n     * @param matchTotal Struct of the running matched totals\n     */\n\n    function matchlowestSell(\n        address asset,\n        STypes.Order memory lowestSell,\n        STypes.Order memory incomingBid,\n        MTypes.Match memory matchTotal\n    ) private {\n        uint88 fillErc = incomingBid.ercAmount > lowestSell.ercAmount\n            ? lowestSell.ercAmount\n            : incomingBid.ercAmount;\n        uint88 fillEth = lowestSell.price.mulU88(fillErc);\n\n        if (lowestSell.orderType == O.LimitShort) {\n            // Match short\n            uint88 colUsed = fillEth.mulU88(LibOrders.convertCR(lowestSell.initialMargin));\n            LibOrders.increaseSharesOnMatch(asset, lowestSell, matchTotal, colUsed);\n            uint88 shortFillEth = fillEth + colUsed;\n            matchTotal.shortFillEth += shortFillEth;\n            // Saves gas when multiple shorts are matched\n            if (!matchTotal.ratesQueried) {\n                STypes.Asset storage Asset = s.asset[asset];\n                matchTotal.ratesQueried = true;\n                matchTotal.ercDebtRate = Asset.ercDebtRate;\n                matchTotal.zethYieldRate = s.vault[Asset.vault].zethYieldRate;\n            }\n            // Default enum is PartialFill\n            SR status;\n            if (incomingBid.ercAmount >= lowestSell.ercAmount) {\n                status = SR.FullyFilled;\n            }\n            if (lowestSell.shortRecordId > 0) {\n                // shortRecord has been partially filled before\n                LibShortRecord.fillShortRecord(\n                    asset,\n                    lowestSell.addr,\n                    lowestSell.shortRecordId,\n                    status,\n                    shortFillEth,\n                    fillErc,\n                    matchTotal.ercDebtRate,\n                    matchTotal.zethYieldRate\n                );\n            } else {\n                // shortRecord newly created\n                lowestSell.shortRecordId = LibShortRecord.createShortRecord(\n                    asset,\n                    lowestSell.addr,\n                    status,\n                    shortFillEth,\n                    fillErc,\n                    matchTotal.ercDebtRate,\n                    matchTotal.zethYieldRate,\n                    0\n                );\n            }\n        } else {\n            // Match ask\n            s.vaultUser[s.asset[asset].vault][lowestSell.addr].ethEscrowed += fillEth;\n            matchTotal.askFillErc += fillErc;\n        }\n\n        matchTotal.fillErc += fillErc;\n        matchTotal.fillEth += fillEth;\n    }\n\n    /**\n     * @notice Final settlement of incoming bid\n     *\n     * @param asset The market that will be impacted\n     * @param incomingBid Active bid order\n     * @param matchTotal Struct of the running matched totals\n     * @param b Memory struct used throughout bidMatchAlgo\n     *\n     * @return ethFilled Amount of eth filled\n     * @return ercAmountLeft Amount of erc not matched\n     */\n\n    function matchIncomingBid(\n        address asset,\n        STypes.Order memory incomingBid,\n        MTypes.Match memory matchTotal,\n        MTypes.BidMatchAlgo memory b\n    ) private returns (uint88 ethFilled, uint88 ercAmountLeft) {\n        if (matchTotal.fillEth == 0) {\n            return (0, incomingBid.ercAmount);\n        }\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n\n        LibOrders.updateSellOrdersOnMatch(asset, b);\n\n        // If at least one short was matched\n        if (matchTotal.shortFillEth > 0) {\n            STypes.Vault storage Vault = s.vault[vault];\n\n            // Matched Shares\n            Vault.dittoMatchedShares += matchTotal.dittoMatchedShares;\n            // Yield Accounting\n            Vault.zethCollateral += matchTotal.shortFillEth;\n            Asset.zethCollateral += matchTotal.shortFillEth;\n            Asset.ercDebt += matchTotal.fillErc - matchTotal.askFillErc;\n\n            //@dev Approximates the startingShortId after bid is fully executed\n            O shortOrderType = s.shorts[asset][b.shortId].orderType;\n            O prevShortOrderType = s.shorts[asset][b.prevShortId].orderType;\n            uint80 prevShortPrice = s.shorts[asset][b.prevShortId].price;\n\n            if (shortOrderType != O.Cancelled && shortOrderType != O.Matched) {\n                Asset.startingShortId = b.shortId;\n            } else if (\n                prevShortOrderType != O.Cancelled && prevShortOrderType != O.Matched\n                    && prevShortPrice >= b.oraclePrice\n            ) {\n                Asset.startingShortId = b.prevShortId;\n            } else {\n                if (b.isMovingFwd) {\n                    Asset.startingShortId = s.shorts[asset][b.shortId].nextId;\n                } else {\n                    Asset.startingShortId = s.shorts[asset][b.shortHintId].nextId;\n                }\n            }\n        }\n\n        // Match bid\n        s.vaultUser[vault][incomingBid.addr].ethEscrowed -= matchTotal.fillEth;\n        s.assetUser[asset][incomingBid.addr].ercEscrowed += matchTotal.fillErc;\n        return (matchTotal.fillEth, incomingBid.ercAmount);\n    }\n\n    //@dev If neither conditions are true, it returns an empty Order struct\n    function _getLowestSell(address asset, MTypes.BidMatchAlgo memory b)\n        private\n        view\n        returns (STypes.Order memory lowestSell)\n    {\n        if (b.shortId != Constants.HEAD) {\n            //@dev Setting lowestSell after comparing short and ask prices\n            bool noAsks = b.askId == Constants.TAIL;\n            bool shortPriceLessThanAskPrice =\n                s.shorts[asset][b.shortId].price < s.asks[asset][b.askId].price;\n            if (noAsks || shortPriceLessThanAskPrice) {\n                lowestSell = s.shorts[asset][b.shortId];\n                return lowestSell;\n            } else {\n                return s.asks[asset][b.askId];\n            }\n        } else if (b.askId != Constants.TAIL) {\n            //@dev Handles scenario when there are no shorts\n            return s.asks[asset][b.askId];\n        }\n    }\n\n    function _shortDirectionHandler(\n        address asset,\n        STypes.Order memory lowestSell,\n        STypes.Order memory incomingBid,\n        MTypes.BidMatchAlgo memory b\n    ) private view {\n        /*\n        @dev: Table refers to how algo updates the shorts after execution. Refer to updateSellOrdersOnMatch()\n         +----------------+-------------------------+--------------------------+\n         |    Direction   |         First ID        |          Last ID         |\n         +----------------+-------------------------+--------------------------+\n         | Fwd only       | firstShortIdBelowOracle*| matchedShortId           |\n         | Back only      | prevShortId             |shortHintId**             |\n         | Back then fwd  | firstShortIdBelowOracle | shortId                  |\n         +----------------+-------------------------+--------------------------+\n        \n        * firstShortIdBelowOracle directly PRECEDES the first short Id that can be matched.\n        firstShortIdBelowOracle cannot itself be matched since it is below oracle price\n        \n        ** shortHintId will always be first Id matched if valid (within 1% of oracle)\n        As such, it will be used as the last Id matched (if moving backwards ONLY)\n\n        Example:\n        BEFORE: HEAD <-> (ID1)* <-> (ID2) <-> (ID3) <-> (ID4) <-> [ID5] <-> (ID6) <-> NEXT\n\n        Assume (ID1) is under the oracle price, therefore (ID2) is technically first eligible short that can be matched\n        Imagine the user passes in [ID5] as the hint, which corresponds to a price within 1% of the oracle, thus making it valid\n        If the bid matches BACKWARDS ONLY, lets say to (ID2), then the linked list will look like this after execution\n\n        AFTER: HEAD <-> (ID1)* <-> (ID6) <-> NEXT\n        \n        Here, (ID1) becomes the \"First ID\" and the shortHint ID [ID5] was the \"LastID\"\n        */\n\n        if (s.shorts[asset][b.prevShortId].price >= b.oraclePrice && !b.isMovingFwd) {\n            //@dev shortHintId should always be the first thing matched\n            b.isMovingBack = true;\n            b.shortId = b.prevShortId;\n        } else if (s.shorts[asset][b.prevShortId].price < b.oraclePrice && !b.isMovingFwd)\n        {\n            b.firstShortIdBelowOracle = b.prevShortId;\n            b.shortId = s.shorts[asset][b.shortHintId].nextId;\n\n            STypes.Order storage nextShort = s.shorts[asset][lowestSell.nextId];\n            //@dev Only set to true if actually moving forward\n            if (b.shortId != Constants.HEAD && nextShort.price <= incomingBid.price) {\n                b.isMovingFwd = true;\n            }\n        } else if (b.isMovingFwd) {\n            b.shortId = lowestSell.nextId;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOrders.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, Math104, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes, O, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOrders {\n    using LibOracle for address;\n    using U256 for uint256;\n    using Math104 for uint104;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    // @dev in seconds\n    function getOffsetTime() internal view returns (uint32 timeInSeconds) {\n        // shouldn't overflow in 136 years\n        return uint32(block.timestamp - Constants.STARTING_TIME); // @dev(safe-cast)\n    }\n\n    // @dev in hours\n    function getOffsetTimeHours() internal view returns (uint24 timeInHours) {\n        return uint24(getOffsetTime() / 1 hours);\n    }\n\n    function convertCR(uint16 cr) internal pure returns (uint256) {\n        return (uint256(cr) * 1 ether) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // For matched token reward\n    function increaseSharesOnMatch(\n        address asset,\n        STypes.Order memory order,\n        MTypes.Match memory matchTotal,\n        uint88 eth\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        // @dev use the diff to get more time (2159), to prevent overflow at year 2106\n        uint32 timeTillMatch = getOffsetTime() - order.creationTime;\n        if (timeTillMatch > Constants.MIN_DURATION) {\n            // shares in eth-days\n            uint88 shares = eth * (timeTillMatch / 1 days);\n            matchTotal.dittoMatchedShares += shares;\n\n            uint256 vault = s.asset[asset].vault;\n            s.vaultUser[vault][order.addr].dittoMatchedShares += shares;\n        }\n    }\n\n    function currentOrders(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset\n    ) internal view returns (STypes.Order[] memory) {\n        uint16 currentId = orders[asset][Constants.HEAD].nextId;\n        uint256 size;\n\n        while (currentId != Constants.TAIL) {\n            size++;\n            currentId = orders[asset][currentId].nextId;\n        }\n\n        STypes.Order[] memory list = new STypes.Order[](size);\n        currentId = orders[asset][Constants.HEAD].nextId; // reset currentId\n\n        for (uint256 i = 0; i < size; i++) {\n            list[i] = orders[asset][currentId];\n            currentId = orders[asset][currentId].nextId;\n        }\n        return list;\n    }\n\n    function isShort(STypes.Order memory order) internal pure returns (bool) {\n        return order.orderType == O.LimitShort;\n    }\n\n    function addBid(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n\n        if (order.orderType == O.MarketBid) {\n            return;\n        }\n        uint16 nextId = s.bids[asset][Constants.HEAD].nextId;\n        if (order.price > s.bids[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.bids, asset, orderHintArray);\n        }\n\n        addOrder(s.bids, asset, order, hintId);\n\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = order.ercAmount.mulU88(order.price);\n        s.vaultUser[vault][order.addr].ethEscrowed -= eth;\n    }\n\n    function addAsk(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n\n        if (order.orderType == O.MarketAsk) {\n            return;\n        }\n        uint16 nextId = s.asks[asset][Constants.HEAD].nextId;\n        if (order.price < s.asks[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.asks, asset, orderHintArray);\n        }\n        addOrder(s.asks, asset, order, hintId);\n\n        s.assetUser[asset][order.addr].ercEscrowed -= order.ercAmount;\n    }\n\n    /**\n     * @notice Add short struct onto market\n     *\n     * @param asset The market that will be impacted\n     * @param order The short struct passed from shortMatchAlgo\n     * @param orderHintArray array of Id passed in front end for optimized looping\n     */\n\n    function addShort(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n        uint16 nextId = s.shorts[asset][Constants.HEAD].nextId;\n        if (order.price < s.shorts[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.shorts, asset, orderHintArray);\n        }\n\n        //@dev: Only need to set this when placing incomingShort onto market\n        addOrder(s.shorts, asset, order, hintId);\n        updateStartingShortIdViaShort(asset, order);\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = order.ercAmount.mulU88(order.price).mulU88(\n            LibOrders.convertCR(order.initialMargin)\n        );\n        s.vaultUser[vault][order.addr].ethEscrowed -= eth;\n    }\n\n    /**\n     * @notice Add ask/short struct onto market\n     *\n     * @param asset The market that will be impacted\n     * @param incomingOrder The ask or short struct passed from sellMatchAlgo\n     * @param orderHintArray array of Id passed in front end for optimized looping\n     */\n\n    function addSellOrder(\n        STypes.Order memory incomingOrder,\n        address asset,\n        MTypes.OrderHint[] memory orderHintArray\n    ) private {\n        O o = normalizeOrderType(incomingOrder.orderType);\n        if (o == O.LimitShort) {\n            addShort(asset, incomingOrder, orderHintArray);\n        } else if (o == O.LimitAsk) {\n            addAsk(asset, incomingOrder, orderHintArray);\n        }\n    }\n\n    /**\n     * @notice Adds order onto market\n     * @dev Reuses order ids for gas saving and id recycling\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param incomingOrder Bid, Ask, or Short Order\n     * @param hintId Id passed in front end for optimized looping\n     */\n\n    // @dev partial addOrder\n    function addOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        STypes.Order memory incomingOrder,\n        uint16 hintId\n    ) private {\n        AppStorage storage s = appStorage();\n        // hint.prevId <-> hint <-> hint.nextId\n        // set links of incoming to hint\n        uint16 prevId = findPrevOfIncomingId(orders, asset, incomingOrder, hintId);\n        uint16 nextId = orders[asset][prevId].nextId;\n        incomingOrder.prevId = prevId;\n        incomingOrder.nextId = nextId;\n        uint16 id = incomingOrder.id;\n        uint16 canceledID = orders[asset][Constants.HEAD].prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol is re-using (ID) and moving it to [ID]\n        // check if a previously cancelled or matched order exists\n        if (canceledID != Constants.HEAD) {\n            incomingOrder.prevOrderType = orders[asset][canceledID].orderType;\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint16 prevCanceledID = orders[asset][canceledID].prevId;\n            if (prevCanceledID != Constants.HEAD) {\n                orders[asset][Constants.HEAD].prevId = prevCanceledID;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                orders[asset][Constants.HEAD].prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = incomingOrder.id = canceledID;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new order id\n            // and the market grows in height/size\n            s.asset[asset].orderId += 1;\n        }\n        orders[asset][id] = incomingOrder;\n        if (nextId != Constants.TAIL) {\n            orders[asset][nextId].prevId = incomingOrder.id;\n        }\n\n        orders[asset][prevId].nextId = incomingOrder.id;\n    }\n\n    /**\n     * @notice Verifies that bid id is between two id based on price\n     *\n     * @param asset The market that will be impacted\n     * @param _prevId The first id supposedly preceding the new price\n     * @param _newPrice price of prospective order\n     * @param _nextId The first id supposedly following the new price\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n\n    function verifyBidId(address asset, uint16 _prevId, uint256 _newPrice, uint16 _nextId)\n        internal\n        view\n        returns (int256 direction)\n    {\n        AppStorage storage s = appStorage();\n        //@dev: TAIL can't be prevId because it will always be last item in list\n        bool check1 =\n            s.bids[asset][_prevId].price >= _newPrice || _prevId == Constants.HEAD;\n        bool check2 =\n            _newPrice > s.bids[asset][_nextId].price || _nextId == Constants.TAIL;\n\n        if (check1 && check2) {\n            return Constants.EXACT;\n        } else if (!check1) {\n            return Constants.PREV;\n        } else if (!check2) {\n            return Constants.NEXT;\n        }\n    }\n\n    /**\n     * @notice Verifies that short id is between two id based on price\n     *\n     * @param asset The market that will be impacted\n     * @param _prevId The first id supposedly preceding the new price\n     * @param _newPrice price of prospective order\n     * @param _nextId The first id supposedly following the new price\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n    function verifySellId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 _prevId,\n        uint256 _newPrice,\n        uint16 _nextId\n    ) private view returns (int256 direction) {\n        //@dev: TAIL can't be prevId because it will always be last item in list\n        bool check1 =\n            orders[asset][_prevId].price <= _newPrice || _prevId == Constants.HEAD;\n\n        bool check2 =\n            _newPrice < orders[asset][_nextId].price || _nextId == Constants.TAIL;\n\n        if (check1 && check2) {\n            return Constants.EXACT;\n        } else if (!check1) {\n            return Constants.PREV;\n        } else if (!check2) {\n            return Constants.NEXT;\n        }\n    }\n\n    /**\n     * @notice Handles the reordering of market when order is canceled\n     * @dev Reuses order ids for gas saving and id recycling\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param id Id of order\n     */\n\n    function cancelOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id\n    ) internal {\n        // save this since it may be replaced\n        uint16 prevHEAD = orders[asset][Constants.HEAD].prevId;\n\n        // remove the links of ID in the market\n        // @dev (ID) is exiting, [ID] is inserted\n        // BEFORE: PREV <-> (ID) <-> NEXT\n        // AFTER : PREV <----------> NEXT\n        orders[asset][orders[asset][id].nextId].prevId = orders[asset][id].prevId;\n        orders[asset][orders[asset][id].prevId].nextId = orders[asset][id].nextId;\n\n        // create the links using the other side of the HEAD\n        emit Events.CancelOrder(asset, id, orders[asset][id].orderType);\n        _reuseOrderIds(orders, asset, id, prevHEAD, O.Cancelled);\n    }\n\n    /**\n     * @notice moves the matched id to the prev side of HEAD\n     * @dev this is how an id gets re-used\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param id ID of most recent matched order\n     *\n     */\n    function matchOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id\n    ) internal {\n        uint16 prevHEAD = orders[asset][Constants.HEAD].prevId;\n        _reuseOrderIds(orders, asset, id, prevHEAD, O.Matched);\n    }\n\n    // shared function for both canceling and order and matching an order\n    function _reuseOrderIds(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id,\n        uint16 prevHEAD,\n        O cancelledOrMatched\n    ) private {\n        // matching ID1 and ID2\n        // BEFORE: HEAD <- <---------------- HEAD <-> (ID1) <-> (ID2) <-> (ID3) <-> NEXT\n        // AFTER1: HEAD <- [ID1] <---------- HEAD <-----------> (ID2) <-> (ID3) <-> NEXT\n        // AFTER2: HEAD <- [ID1] <- [ID2] <- HEAD <----------"
    }
  ]
}