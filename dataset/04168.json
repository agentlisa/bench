{
  "Title": "[L03][Fixed] Operations are not explicitly casted",
  "Content": "The current lack of explicit casting when handling unsigned integer variables in the codebase, considering the various different types of unsigned integers in use (e.g. uint256, uint64 and uint32), hinders the codeâ€™s readability, making it more error-prone and hard to maintain.\n\n\nSome examples of this issue can be found at:\n\n\n* In [line 101](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/MarginCalculator.sol#L101) from `MarginCalculator.sol`, where an `uint8` is copied to an `uint256` variable. It should be done as in [line 62](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/MarginCalculator.sol#L62).\n* In [line 18](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/OtokenSpawner.sol#L18) from `OtokenSpawner.sol`, where a zero value is implicitly casted into a `bytes32` variable.\n\n\nConsider explicitly casting all integer values to their expected type when sending them as parameters of functions and events. It is advisable to review the entire codebase and apply this recommendation to all segments of code where the issue is found.\n\n\n**Update:** *Fixed in [PR#288](https://github.com/opynfinance/GammaProtocol/pull/288).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MarginCalculator.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {OtokenInterface} from \"./interfaces/OtokenInterface.sol\";\nimport {OracleInterface} from \"./interfaces/OracleInterface.sol\";\nimport {ERC20Interface} from \"./interfaces/ERC20Interface.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\nimport {FixedPointInt256 as FPI} from \"./libs/FixedPointInt256.sol\";\nimport {MarginVault} from \"./libs/MarginVault.sol\";\n\n/**\n * @title MarginCalculator\n * @author Opyn\n * @notice Calculator module that checks if a given vault is valid, calculates margin requirements, and settlement proceeds\n */\ncontract MarginCalculator {\n    using SafeMath for uint256;\n    using FPI for FPI.FixedPointInt;\n\n    address public addressBook;\n\n    uint256 internal constant BASE = 8;\n    FPI.FixedPointInt internal ZERO = FPI.fromScaledUint(0, BASE);\n\n    constructor(address _addressBook) public {\n        require(_addressBook != address(0), \"MarginCalculator: invalid addressbook\");\n\n        addressBook = _addressBook;\n    }\n\n    /**\n     * @notice return the cash value of an expired oToken, denominated in collateral\n     * @param _otoken oToken address\n     * @return how much collateral can be taken out by 1 otoken unit, scaled by 1e8,\n     * or how much collateral can be taken out for 1 (1e8) oToken\n     */\n    function getExpiredPayoutRate(address _otoken) external view returns (uint256) {\n        require(_otoken != address(0), \"MarginCalculator: Invalid token address\");\n        OtokenInterface otoken = OtokenInterface(_otoken);\n        require(now > otoken.expiryTimestamp(), \"MarginCalculator: Otoken not expired yet\");\n\n        FPI.FixedPointInt memory cashValueInStrike = _getExpiredCashValue(_otoken);\n\n        address strike = otoken.strikeAsset();\n        address collateral = otoken.collateralAsset();\n\n        uint256 expiry = otoken.expiryTimestamp();\n\n        FPI.FixedPointInt memory cashValueInCollateral = _convertAmountOnExpiryPrice(\n            cashValueInStrike,\n            strike,\n            collateral,\n            expiry\n        );\n\n        // the exchangeRate was scaled by 1e8, if 1e8 otoken can take out 1 USDC, the exchangeRate is currently 1e8\n        // we want to return: how much USDC units can be taken out by 1 (1e8 units) oToken\n        uint256 collateralDecimals = uint256(ERC20Interface(collateral).decimals());\n        return cashValueInCollateral.toScaledUint(collateralDecimals, true);\n    }\n\n    /**\n     * @notice returns the amount of collateral that can be removed from an actual or a theoretical vault\n     * @dev return amount is denominated in the collateral asset for the oToken in the vault, or the collateral asset in the vault\n     * @param _vault theoretical vault that needs to be checked\n     * @return excessCollateral the amount by which the margin is above or below the required amount\n     * @return isExcess True if there is excess margin in the vault, False if there is a deficit of margin in the vault\n     * if True, collateral can be taken out from the vault, if False, additional collateral needs to be added to vault\n     */\n    function getExcessCollateral(MarginVault.Vault memory _vault) public view returns (uint256, bool) {\n        // include all the checks for to ensure the vault is valid\n        _checkIsValidVault(_vault);\n\n        bool hasCollateral = _isNotEmpty(_vault.collateralAssets);\n        bool hasShort = _isNotEmpty(_vault.shortOtokens);\n        bool hasLong = _isNotEmpty(_vault.longOtokens);\n\n        // if the vault contains no oTokens, return the amount of collateral\n        if (!hasShort && !hasLong) {\n            uint256 amount = hasCollateral ? _vault.collateralAmounts[0] : 0;\n            return (amount, true);\n        }\n\n        FPI.FixedPointInt memory collateralAmount = ZERO;\n        if (hasCollateral) {\n            uint256 colllateralDecimals = ERC20Interface(_vault.collateralAssets[0]).decimals();\n            collateralAmount = FPI.fromScaledUint(_vault.collateralAmounts[0], colllateralDecimals);\n        }\n\n        // get required margin, denominated in collateral\n        FPI.FixedPointInt memory collateralRequired = _getMarginRequired(_vault);\n        FPI.FixedPointInt memory excessCollateral = collateralAmount.sub(collateralRequired);\n\n        bool isExcess = excessCollateral.isGreaterThanOrEqual(ZERO);\n\n        address otoken = hasLong ? _vault.longOtokens[0] : _vault.shortOtokens[0];\n        uint256 collateralDecimals = ERC20Interface(OtokenInterface(otoken).collateralAsset()).decimals();\n        // if is excess, truncate the tailing digits in excessCollateralExternal calculation\n        uint256 excessCollateralExternal = excessCollateral.toScaledUint(collateralDecimals, isExcess);\n        return (excessCollateralExternal, isExcess);\n    }\n\n    /**\n     * @notice return the cash value of an expired oToken, denominated in strike asset\n     * @dev for a call, return Max (0, underlyingPriceInStrike - otoken.strikePrice)\n     * @dev for a put, return Max(0, otoken.strikePrice - underlyingPriceInStrike)\n     * @param _otoken oToken address\n     * @return cash value of an expired otoken, denominated in the strike asset\n     */\n    function _getExpiredCashValue(address _otoken) internal view returns (FPI.FixedPointInt memory) {\n        OtokenInterface otoken = OtokenInterface(_otoken);\n\n        // strike price is denominated in strike asset\n        FPI.FixedPointInt memory strikePrice = FPI.fromScaledUint(otoken.strikePrice(), BASE);\n\n        FPI.FixedPointInt memory one = FPI.fromScaledUint(1, 0);\n\n        // calculate the value of the underlying asset in terms of the strike asset\n        FPI.FixedPointInt memory underlyingPriceInStrike = _convertAmountOnExpiryPrice(\n            one, // underlying price denominated in underlying\n            otoken.underlyingAsset(),\n            otoken.strikeAsset(),\n            otoken.expiryTimestamp()\n        );\n\n        if (otoken.isPut()) {\n            return strikePrice.isGreaterThan(underlyingPriceInStrike) ? strikePrice.sub(underlyingPriceInStrike) : ZERO;\n        } else {\n            return underlyingPriceInStrike.isGreaterThan(strikePrice) ? underlyingPriceInStrike.sub(strikePrice) : ZERO;\n        }\n    }\n\n    /**\n     * @notice calculate the amount of collateral needed for a vault\n     * @dev vault passed in has already passed the checkIsValidVault function\n     * @param _vault theoretical vault that needs to be checked\n     * @return marginRequired the minimal amount of collateral needed in a vault, denominated in collateral\n     */\n    function _getMarginRequired(MarginVault.Vault memory _vault) internal view returns (FPI.FixedPointInt memory) {\n        // vault has either long oTokens or short oTokens in it\n        bool hasShort = _isNotEmpty(_vault.shortOtokens);\n        bool hasLong = _isNotEmpty(_vault.longOtokens);\n\n        FPI.FixedPointInt memory shortAmount = hasShort ? FPI.fromScaledUint(_vault.shortAmounts[0], BASE) : ZERO;\n        FPI.FixedPointInt memory longAmount = hasLong ? FPI.fromScaledUint(_vault.longAmounts[0], BASE) : ZERO;\n\n        OtokenInterface otoken = hasShort\n            ? OtokenInterface(_vault.shortOtokens[0])\n            : OtokenInterface(_vault.longOtokens[0]);\n        bool expired = now > otoken.expiryTimestamp();\n        bool isPut = otoken.isPut();\n\n        if (!expired) {\n            FPI.FixedPointInt memory shortStrike = hasShort\n                ? FPI.fromScaledUint(OtokenInterface(_vault.shortOtokens[0]).strikePrice(), BASE)\n                : ZERO;\n            FPI.FixedPointInt memory longStrike = hasLong\n                ? FPI.fromScaledUint(OtokenInterface(_vault.longOtokens[0]).strikePrice(), BASE)\n                : ZERO;\n\n            if (isPut) {\n                FPI.FixedPointInt memory strikeNeeded = _getPutSpreadMarginRequired(\n                    shortAmount,\n                    longAmount,\n                    shortStrike,\n                    longStrike\n                );\n                // convert amount to be denominated in collateral\n                return _convertAmountOnLivePrice(strikeNeeded, otoken.strikeAsset(), otoken.collateralAsset());\n            } else {\n                FPI.FixedPointInt memory underlyingNeeded = _getCallSpreadMarginRequired(\n                    shortAmount,\n                    longAmount,\n                    shortStrike,\n                    longStrike\n                );\n                // convert amount to be denominated in collateral\n                return _convertAmountOnLivePrice(underlyingNeeded, otoken.underlyingAsset(), otoken.collateralAsset());\n            }\n        } else {\n            FPI.FixedPointInt memory shortCashValue = hasShort ? _getExpiredCashValue(_vault.shortOtokens[0]) : ZERO;\n            FPI.FixedPointInt memory longCashValue = hasLong ? _getExpiredCashValue(_vault.longOtokens[0]) : ZERO;\n\n            FPI.FixedPointInt memory valueInStrike = _getExpiredSpreadCashValue(\n                shortAmount,\n                longAmount,\n                shortCashValue,\n                longCashValue\n            );\n            // convert amount to be denominated in collateral\n            return\n                _convertAmountOnExpiryPrice(\n                    valueInStrike,\n                    otoken.strikeAsset(),\n                    otoken.collateralAsset(),\n                    otoken.expiryTimestamp()\n                );\n        }\n    }\n\n    /**\n     * @dev returns the strike asset amount of margin required for a put or put spread with the given short oTokens, long oTokens and amounts\n     *\n     * marginRequired = max( (short amount * short strike) - (long strike * min (short amount, long amount)) , 0 )\n     *\n     * @return margin requirement denominated in the strike asset\n     */\n    function _getPutSpreadMarginRequired(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortStrike,\n        FPI.FixedPointInt memory _longStrike\n    ) internal view returns (FPI.FixedPointInt memory) {\n        return FPI.max(_shortAmount.mul(_shortStrike).sub(_longStrike.mul(FPI.min(_shortAmount, _longAmount))), ZERO);\n    }\n\n    /**\n     * @dev returns the underlying asset amount required for a call or call spread with the given short oTokens, long oTokens, and amounts\n     *\n     *                           (long strike - short strike) * short amount\n     * marginRequired =  max( ------------------------------------------------- , max (short amount - long amount, 0) )\n     *                                           long strike\n     *\n     * @dev if long strike = 0, return max( short amount - long amount, 0)\n     * @return margin requirement denominated in the underlying asset\n     */\n    function _getCallSpreadMarginRequired(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortStrike,\n        FPI.FixedPointInt memory _longStrike\n    ) internal view returns (FPI.FixedPointInt memory) {\n        // max (short amount - long amount , 0)\n        if (_longStrike.isEqual(ZERO)) {\n            return FPI.max(_shortAmount.sub(_longAmount), ZERO);\n        }\n\n        /**\n         *             (long strike - short strike) * short amount\n         * calculate  ----------------------------------------------\n         *                             long strike\n         */\n        FPI.FixedPointInt memory firstPart = _longStrike.sub(_shortStrike).mul(_shortAmount).div(_longStrike);\n\n        /**\n         * calculate max ( short amount - long amount , 0)\n         */\n        FPI.FixedPointInt memory secondPart = FPI.max(_shortAmount.sub(_longAmount), ZERO);\n\n        return FPI.max(firstPart, secondPart);\n    }\n\n    /**\n     * @dev calculate the cash value obligation for an expired vault, where a positive number is an obligation\n     *\n     * Formula: net = (short cash value * short amount) - ( long cash value * long Amount )\n     *\n     * @return cash value obligation denominated in the strike asset\n     */\n    function _getExpiredSpreadCashValue(\n        FPI.FixedPointInt memory _shortAmount,\n        FPI.FixedPointInt memory _longAmount,\n        FPI.FixedPointInt memory _shortCashValue,\n        FPI.FixedPointInt memory _longCashValue\n    ) internal pure returns (FPI.FixedPointInt memory) {\n        return _shortCashValue.mul(_shortAmount).sub(_longCashValue.mul(_longAmount));\n    }\n\n    /**\n     * @dev ensure that:\n     * a) at most 1 asset type used as collateral\n     * b) at most 1 series of option used as the long option\n     * c) at most 1 series of option used as the short option\n     * d) asset array lengths match for long, short and collateral\n     * e) long option and collateral asset is acceptable for margin with short asset\n     * @param _vault the vault to check\n     */\n    function _checkIsValidVault(MarginVault.Vault memory _vault) internal view {\n        // ensure all the arrays in the vault are valid\n        require(_vault.shortOtokens.length <= 1, \"MarginCalculator: Too many short otokens in the vault\");\n        require(_vault.longOtokens.length <= 1, \"MarginCalculator: Too many long otokens in the vault\");\n        require(_vault.collateralAssets.length <= 1, \"MarginCalculator: Too many collateral assets in the vault\");\n\n        require(\n            _vault.shortOtokens.length == _vault.shortAmounts.length,\n            \"MarginCalculator: Short asset and amount mismatch\"\n        );\n        require(\n            _vault.longOtokens.length == _vault.longAmounts.length,\n            \"MarginCalculator: Long asset and amount mismatch\"\n        );\n        require(\n            _vault.collateralAssets.length == _vault.collateralAmounts.length,\n            \"MarginCalculator: Collateral asset and amount mismatch\"\n        );\n\n        // ensure the long asset is valid for the short asset\n        require(_isMarginableLong(_vault), \"MarginCalculator: long asset not marginable for short asset\");\n\n        // ensure that the collateral asset is valid for the short asset\n        require(_isMarginableCollateral(_vault), \"MarginCalculator: collateral asset not marginable for short asset\");\n    }\n\n    /**\n     * @dev if there is a short option and a long option in the vault, ensure that the long option is able to be used as collateral for the short option\n     * @param _vault the vault to check.\n     */\n    function _isMarginableLong(MarginVault.Vault memory _vault) internal view returns (bool) {\n        bool hasLong = _isNotEmpty(_vault.longOtokens);\n        bool hasShort = _isNotEmpty(_vault.shortOtokens);\n        // if vault is missing a long or a short, return True\n        if (!hasLong || !hasShort) return true;\n\n        OtokenInterface long = OtokenInterface(_vault.longOtokens[0]);\n        OtokenInterface short = OtokenInterface(_vault.shortOtokens[0]);\n\n        return\n            long.underlyingAsset() == short.underlyingAsset() &&\n            long.strikeAsset() == short.strikeAsset() &&\n            long.collateralAsset() == short.collateralAsset() &&\n            long.expiryTimestamp() == short.expiryTimestamp() &&\n            long.isPut() == short.isPut();\n    }\n\n    /**\n     * @dev if there is short option and collateral asset in the vault, ensure that the collateral asset is valid for the short option\n     * @param _vault the vault to check.\n     */\n    function _isMarginableCollateral(MarginVault.Vault memory _vault) internal view returns (bool) {\n        bool isMarginable = true;\n\n        bool hasCollateral = _isNotEmpty(_vault.collateralAssets);\n        if (!hasCollateral) return isMarginable;\n\n        bool hasShort = _isNotEmpty(_vault.shortOtokens);\n        bool hasLong = _isNotEmpty(_vault.longOtokens);\n\n        if (hasShort) {\n            OtokenInterface short = OtokenInterface(_vault.shortOtokens[0]);\n            isMarginable = short.collateralAsset() == _vault.collateralAssets[0];\n        } else if (hasLong) {\n            OtokenInterface long = OtokenInterface(_vault.longOtokens[0]);\n            isMarginable = long.collateralAsset() == _vault.collateralAssets[0];\n        }\n\n        return isMarginable;\n    }\n\n    /**\n     * @notice convert an amount in asset A to equivalent amount of asset B, based on a live price\n     * @dev function includes the amount and applies .mul() first to increase the accuracy\n     * @param _amount amount in asset A\n     * @param _assetA asset A\n     * @param _assetB asset B\n     * @return _amount in asset B\n     */\n    function _convertAmountOnLivePrice(\n        FPI.FixedPointInt memory _amount,\n        address _assetA,\n        address _assetB\n    ) internal view returns (FPI.FixedPointInt memory) {\n        OracleInterface oracle = OracleInterface(AddressBookInterface(addressBook).getOracle());\n        if (_assetA == _assetB) {\n            return _amount;\n        }\n        uint256 priceA = oracle.getPrice(_assetA);\n        uint256 priceB = oracle.getPrice(_assetB);\n        // amount A * price A in USD = amount B * price B in USD\n        // amount B = amount A * price A / price B\n        return _amount.mul(FPI.fromScaledUint(priceA, BASE)).div(FPI.fromScaledUint(priceB, BASE));\n    }\n\n    /**\n     * @notice convert an amount in asset A to equivalent amount of asset B, based on an expiry price\n     * @dev function includes the amount and apply .mul() first to increase the accuracy\n     * @param _amount amount in asset A\n     * @param _assetA asset A\n     * @param _assetB asset B\n     * @return _amount in asset B\n     */\n    function _convertAmountOnExpiryPrice(\n        FPI.FixedPointInt memory _amount,\n        address _assetA,\n        address _assetB,\n        uint256 _expiry\n    ) internal view returns (FPI.FixedPointInt memory) {\n        if (_assetA == _assetB) {\n            return _amount;\n        }\n        OracleInterface oracle = OracleInterface(AddressBookInterface(addressBook).getOracle());\n        (uint256 priceA, bool priceAFinalized) = oracle.getExpiryPrice(_assetA, _expiry);\n        (uint256 priceB, bool priceBFinalized) = oracle.getExpiryPrice(_assetB, _expiry);\n        require(priceAFinalized && priceBFinalized, \"MarginCalculator: price at expiry not finalized yet.\");\n        // amount A * price A in USD = amount B * price B in USD\n        // amount B = amount A * price A / price B\n        return _amount.mul(FPI.fromScaledUint(priceA, BASE)).div(FPI.fromScaledUint(priceB, BASE));\n    }\n\n    /**\n     * @dev check if asset array contain a token address\n     * @return True if the array is not empty\n     */\n    function _isNotEmpty(address[] memory _assets) internal pure returns (bool) {\n        return _assets.length > 0 && _assets[0] != address(0);\n    }\n}"
    },
    {
      "filename": "contracts/OtokenSpawner.sol",
      "content": "/* SPDX-License-Identifier: UNLICENSED */\n\npragma solidity =0.6.10;\n\nimport {Spawn} from \"./packages/Spawn.sol\";\nimport {Create2} from \"./packages/oz/Create2.sol\";\n\n/**\n * @title OtokenSpawner\n * @author Opyn Team\n * @notice This contract spawns and initializes eip-1167 minimal proxies that\n * point to existing logic contracts.\n * @notice This contract was modified from Spawner.sol\n * https://github.com/0age/Spawner/blob/master/contracts/Spawner.sol to fit into OtokenFactory\n */\ncontract OtokenSpawner {\n    // fixed salt value because we will only deploy an oToken with the same init value once\n    bytes32 private constant SALT = 0;\n\n    /**\n     * @notice internal function for spawning an eip-1167 minimal proxy using `CREATE2`\n     * @param logicContract address of the logic contract\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\n     * from the spawned contract to the logic contract during contract creation\n     * @return spawnedContract the address of the newly-spawned contract\n     */\n    function _spawn(address logicContract, bytes memory initializationCalldata) internal returns (address) {\n        // place the creation code and constructor args of the contract to spawn in memory\n        bytes memory initCode = abi.encodePacked(\n            type(Spawn).creationCode,\n            abi.encode(logicContract, initializationCalldata)\n        );\n\n        // spawn the contract using `CREATE2`\n        return Create2.deploy(0, SALT, initCode);\n    }\n\n    /**\n     * @notice internal view function for finding the address of the standard\n     * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n     * and initialization calldata payload\n     * @param logicContract address of the logic contract\n     * @param initializationCalldata calldata that will be supplied to the `DELEGATECALL`\n     * from the spawned contract to the logic contract during contract creation\n     * @return target address of the next spawned minimal proxy contract with the\n     * given parameters.\n     */\n    function _computeAddress(address logicContract, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address target)\n    {\n        // place the creation code and constructor args of the contract to spawn in memory\n        bytes memory initCode = abi.encodePacked(\n            type(Spawn).creationCode,\n            abi.encode(logicContract, initializationCalldata)\n        );\n        // get target address using the constructed initialization code\n        bytes32 initCodeHash = keccak256(initCode);\n\n        target = Create2.computeAddress(SALT, initCodeHash);\n    }\n}"
    }
  ]
}