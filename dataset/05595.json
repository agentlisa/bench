{
  "Title": "[G-04] Variable already cached but in the wrong order - refactor to save 1 SLOAD(100 Gas)",
  "Content": "\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/Vault721.sol#L94-L99\n```solidity\nFile: /src/contracts/proxies/Vault721.sol\n94:  function mint(address _proxy, uint256 _safeId) external {\n95:    require(msg.sender == address(safeManager), 'V721: only safeManager');\n96:    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n97:    address _user = _proxyRegistry[_proxy];\n98:    _safeMint(_user, _safeId);\n99:  }\n```\n\n```diff\n   function mint(address _proxy, uint256 _safeId) external {\n     require(msg.sender == address(safeManager), 'V721: only safeManager');\n-    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n-    address _user = _proxyRegistry[_proxy];\n+     address _user = _proxyRegistry[_proxy];\n+    require(_user != address(0), 'V721: non-native proxy');\n+\n     _safeMint(_user, _safeId);\n   }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/Vault721.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ERC721} from '@openzeppelin/token/ERC721/ERC721.sol';\nimport {ERC721Enumerable} from '@openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol';\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\nimport {NFTRenderer} from '@contracts/proxies/NFTRenderer.sol';\n\n// Open Dollar\n// Version 1.5.5\n\ncontract Vault721 is ERC721Enumerable {\n  error NotGovernor();\n  error ProxyAlreadyExist();\n  error ZeroAddress();\n\n  address public governor;\n  IODSafeManager public safeManager;\n  NFTRenderer public nftRenderer;\n\n  string public contractMetaData =\n    '{\"name\": \"Open Dollar Vaults\",\"description\": \"Tradable Vaults for the Open Dollar stablecoin protocol. Caution! Trading this NFT means trading the ownership of your Vault in the Open Dollar protocol and all of the assets/collateral inside each Vault.\",\"image\": \"https://app.opendollar.com/collectionImage.png\",\"external_link\": \"https://opendollar.com\"}';\n\n  mapping(address proxy => address user) internal _proxyRegistry;\n  mapping(address user => address proxy) internal _userRegistry;\n\n  event CreateProxy(address indexed _user, address _proxy);\n\n  /**\n   * @dev initializes DAO governor contract\n   */\n  constructor(address _governor) ERC721('OpenDollar Vault', 'ODV') {\n    governor = _governor;\n  }\n\n  /**\n   * @dev control access for DAO governor\n   */\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert NotGovernor();\n    _;\n  }\n\n  /**\n   * @dev enforce non-zero address params\n   */\n  modifier nonZero(address _addr) {\n    if (_addr == address(0)) revert ZeroAddress();\n    _;\n  }\n\n  /**\n   * @dev initializes SafeManager contract\n   */\n  function initializeManager() external {\n    if (address(safeManager) == address(0)) _setSafeManager(msg.sender);\n  }\n\n  /**\n   * @dev initializes NFTRenderer contract\n   */\n  function initializeRenderer() external {\n    if (address(nftRenderer) == address(0)) _setNftRenderer(msg.sender);\n  }\n\n  /**\n   * @dev get proxy by user address\n   */\n  function getProxy(address _user) external view returns (address _proxy) {\n    _proxy = _userRegistry[_user];\n  }\n\n  /**\n   * @dev allows msg.sender without an ODProxy to deploy a new ODProxy\n   */\n  function build() external returns (address payable _proxy) {\n    if (!_isNotProxy(msg.sender)) revert ProxyAlreadyExist();\n    _proxy = _build(msg.sender);\n  }\n\n  /**\n   * @dev allows user without an ODProxy to deploy a new ODProxy\n   */\n  function build(address _user) external returns (address payable _proxy) {\n    if (!_isNotProxy(_user)) revert ProxyAlreadyExist();\n    _proxy = _build(_user);\n  }\n\n  /**\n   * @dev mint can only be called by the SafeManager\n   * enforces that only ODProxies call `openSafe` function by checking _proxyRegistry\n   */\n  function mint(address _proxy, uint256 _safeId) external {\n    require(msg.sender == address(safeManager), 'V721: only safeManager');\n    require(_proxyRegistry[_proxy] != address(0), 'V721: non-native proxy');\n    address _user = _proxyRegistry[_proxy];\n    _safeMint(_user, _safeId);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation on NFTRenderer\n   */\n  function updateNftRenderer(\n    address _nftRenderer,\n    address _oracleRelayer,\n    address _taxCollector,\n    address _collateralJoinFactory\n  ) external onlyGovernor nonZero(_oracleRelayer) nonZero(_taxCollector) nonZero(_collateralJoinFactory) {\n    address _safeManager = address(safeManager);\n    require(_safeManager != address(0));\n    _setNftRenderer(_nftRenderer);\n    nftRenderer.setImplementation(_safeManager, _oracleRelayer, _taxCollector, _collateralJoinFactory);\n  }\n\n  /**\n   * @dev update meta data\n   */\n  function updateContractURI(string memory _metaData) external onlyGovernor {\n    contractMetaData = _metaData;\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function setSafeManager(address _safeManager) external onlyGovernor {\n    _setSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function setNftRenderer(address _nftRenderer) external onlyGovernor {\n    _setNftRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev generate URI with updated vault information\n   */\n  function tokenURI(uint256 _safeId) public view override returns (string memory uri) {\n    uri = nftRenderer.render(_safeId);\n  }\n\n  /**\n   * @dev contract level meta data\n   */\n  function contractURI() public view returns (string memory uri) {\n    uri = string.concat('data:application/json;utf8,', contractMetaData);\n  }\n\n  /**\n   * @dev check that proxy does not exist OR that the user does not own proxy\n   */\n  function _isNotProxy(address _user) internal view returns (bool) {\n    return _userRegistry[_user] == address(0) || ODProxy(_userRegistry[_user]).OWNER() != _user;\n  }\n\n  /**\n   * @dev deploys ODProxy for user to interact with protocol\n   * updates _proxyRegistry and _userRegistry mappings for new ODProxy\n   */\n  function _build(address _user) internal returns (address payable _proxy) {\n    _proxy = payable(address(new ODProxy(_user)));\n    _proxyRegistry[_proxy] = _user;\n    _userRegistry[_user] = _proxy;\n    emit CreateProxy(_user, address(_proxy));\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of SafeManager\n   */\n  function _setSafeManager(address _safeManager) internal nonZero(_safeManager) {\n    safeManager = IODSafeManager(_safeManager);\n  }\n\n  /**\n   * @dev allows DAO to update protocol implementation of NFTRenderer\n   */\n  function _setNftRenderer(address _nftRenderer) internal nonZero(_nftRenderer) {\n    nftRenderer = NFTRenderer(_nftRenderer);\n  }\n\n  /**\n   * @dev _transfer calls `transferSAFEOwnership` on SafeManager\n   * enforces that ODProxy exists for transfer or it deploys a new ODProxy for receiver of vault/nft\n   */\n  function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal override {\n    require(to != address(0), 'V721: no burn');\n    if (from != address(0)) {\n      address payable proxy;\n\n      if (_isNotProxy(to)) {\n        proxy = _build(to);\n      } else {\n        proxy = payable(_userRegistry[to]);\n      }\n      IODSafeManager(safeManager).transferSAFEOwnership(firstTokenId, address(proxy));\n    }\n  }\n}"
    }
  ]
}