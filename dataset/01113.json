{
  "Title": "M-5: Incorrect calculations of borrowingCollateral leads to DoS for positions in the current tick range due to underflow",
  "Content": "# Issue M-5: Incorrect calculations of borrowingCollateral leads to DoS for positions in the current tick range due to underflow \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/86 \n\n## Found by \n0xReiAyanami, Bauer, Japy69, ali\\_shehab, lil.eth, lucifero, seeques\nThe `borrowingCollateral` is the amount of collateral a borrower needs to pay for his leverage. It should be calculated as the difference of holdTokenBalance (the amount borrowed + holdTokens received after saleTokens are swapped) and the amount borrowed and checked against user-specified maxCollateral amount which is the maximum the borrower wishes to pay. However, in the current implementation the `borrowingCollateral` calculation is most likely to underflow.\n## Vulnerability Detail\nThis calculation is most likely to underflow\n```solidity\nuint256 borrowingCollateral = cache.borrowedAmount - cache.holdTokenBalance;\n```\nThe `cache.borrowedAmount` is the calculated amount of holdTokens based on the liquidity of a position. `cache.holdTokenBalance` is the balance of holdTokens queried after liquidity extraction and tokens transferred to the `LiquidityBorrowingManager`. If any amounts of the saleToken are transferred as well, these are swapped to holdTokens and added to `cache.holdTokenBalance`. \n\nSo in case when liquidity of a position is in the current tick range, both tokens would be transferred to the contract and saleToken would be swapped for holdToken and then added to `cache.holdTokenBalance`. This would make `cache.holdTokenBalance > cache.borrowedAmount` since `cache.holdTokenBalance == cache.borrowedAmount + amount of sale token swapped` and would make the tx revert due to underflow.\n## Impact\nMany positions would be unavailable to borrowers. For non-volatile positions like that which provide liquidity to stablecoin pools the DoS could last for very long period. For volatile positions that provide liquidity in a wide range this could also be for more than 1 year.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L492-L503\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L470\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/main/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L848-L896\n## Tool used\n\nManual Review\n\n## Recommendation\nThe borrowedAmount should be subtracted from holdTokenBalance\n```solidity\nuint256 borrowingCollateral = cache.holdTokenBalance - cache.borrowedAmount;\n```\n\n\n\n## Discussion\n\n**Ali-Shehab**\n\nEscalate\n\nFirst issue has nothing to do with the other ones. It must not be duplicate\n\n[peanuts - Max collateral check is not done when increasing collateral balance]  https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/37\n\n**sherlock-admin2**\n\n > Escalate\n> \n> First issue has nothing to do with the other ones. It must not be duplicate\n> \n> [peanuts - Max collateral check is not done when increasing collateral balance]  https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/37\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**fann95**\n\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/7937e25a2d344881c7c4fb202ed89965b0fed229\n\n**IAm0x52**\n\nEscalate\n\nThis is a valid issue but it should be medium rather than high. Impact is broken functionality and DOS which doesn't qualify as high.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is a valid issue but it should be medium rather than high. Impact is broken functionality and DOS which doesn't qualify as high.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Ali-Shehab**\n\nSome reports were accepted as high with similar impact: https://solodit.xyz/issues/h-2-possible-dos-in-rollerperiphery-approve-function-sherlock-sense-sense-git I don't know if am missing something.\n\n**IAm0x52**\n\nWhile I acknowledge the similarity of the issues, I have made my escalation based on current Sherlock rules which overrides previous judgments. Loss of functionality is a medium issue. The DOS could be over a year but only for some ranges/LP tokens which is why it is also medium.\n\n**Ali-Shehab**\n\nBut can't we send any token and make it DOS?\n\n**Czar102**\n\nAs I understand, users wouldn't be able to create a borrow position for borrows with the active tick within the borrow tick range. This is a partial loss of the core functionality of the protocol, but doesn't lock any funds for >1 year. There also doesn't seem to be any loss of funds.\n\nCurrent interpretation of the Sherlock rules imply that when there is no loss of funds or funds locked, it is not a high issue. I think it should be downgraded to medium, so will be accepting the escalation if there are not counterarguments.\n\n**Ali-Shehab**\n\nAlso, I want to remind you that there is an issue that doesn't relate to this bug: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/37\n\n**Czar102**\n\nThe first escalation here concerns another issue, #37.\n\nWill be accepting both escalations. This will be downgraded to medium and #37 is not a duplicate. It is invalid.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ali-shehab](https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/86/#issuecomment-1786029646): accepted\n- [IAm0x52](https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/86/#issuecomment-1789413507): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/LiquidityManager.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\n\n/**\n * @title LiquidityBorrowingManager\n * @dev This contract manages the borrowing liquidity functionality for WAGMI Leverage protocol.\n * It inherits from LiquidityManager, OwnerSettings, DailyRateAndCollateral, and ReentrancyGuard contracts.\n */\ncontract LiquidityBorrowingManager is\n    LiquidityManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { Keys.removeKey, Keys.addKeyIfNotExists } for bytes32[];\n    using { ErrLib.revertError } for bool;\n\n    /// @title BorrowParams\n    /// @notice This struct represents the parameters required for borrowing.\n    struct BorrowParams {\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The address of the token that will be sold to obtain the loan currency\n        address saleToken;\n        /// @notice The address of the token that will be held\n        address holdToken;\n        /// @notice The minimum amount of holdToken that must be obtained\n        uint256 minHoldTokenOut;\n        /// @notice The maximum amount of collateral that can be provided for the loan\n        uint256 maxCollateral;\n        /// @notice The SwapParams struct representing the external swap parameters\n        SwapParams externalSwap;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n    }\n    /// @title BorrowingInfo\n    /// @notice This struct represents the borrowing information for a borrower.\n    struct BorrowingInfo {\n        address borrower;\n        address saleToken;\n        address holdToken;\n        /// @notice The amount of fees owed by the creditor\n        uint256 feesOwed;\n        /// @notice The amount borrowed by the borrower\n        uint256 borrowedAmount;\n        /// @notice The amount of liquidation bonus\n        uint256 liquidationBonus;\n        /// @notice The accumulated loan rate per share\n        uint256 accLoanRatePerSeconds;\n        /// @notice The daily rate collateral balance multiplied by COLLATERAL_BALANCE_PRECISION\n        uint256 dailyRateCollateralBalance;\n    }\n    /// @notice This struct used for caching variables inside a function 'borrow'\n    struct BorrowCache {\n        uint256 dailyRateCollateral;\n        uint256 accLoanRatePerSeconds;\n        uint256 borrowedAmount;\n        uint256 holdTokenBalance;\n    }\n    /// @notice Struct representing the extended borrowing information.\n    struct BorrowingInfoExt {\n        /// @notice The main borrowing information.\n        BorrowingInfo info;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n        /// @notice The balance of the collateral.\n        int256 collateralBalance;\n        /// @notice The estimated lifetime of the loan.\n        uint256 estimatedLifeTime;\n        /// borrowing Key\n        bytes32 key;\n    }\n\n    /// @title RepayParams\n    /// @notice This struct represents the parameters required for repaying a loan.\n    struct RepayParams {\n        /// @notice The activation of the emergency liquidity restoration mode (available only to the lender)\n        bool isEmergency;\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The external swap parameters for the repayment transaction\n        SwapParams externalSwap;\n        /// @notice The unique borrowing key associated with the loan\n        bytes32 borrowingKey;\n        /// @notice The slippage allowance for the swap in basis points (1/10th of a percent)\n        uint256 swapSlippageBP1000;\n    }\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) public loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// borrower => BorrowingKeys[]\n    mapping(address => bytes32[]) public userBorrowingKeys;\n    /// NonfungiblePositionManager tokenId => BorrowingKeys[]\n    mapping(uint256 => bytes32[]) public tokenIdToBorrowingKeys;\n\n    ///  token => FeesAmt\n    mapping(address => uint256) private platformsFeesInfo;\n\n    /// Indicates that a borrower has made a new loan\n    event Borrow(\n        address borrower,\n        bytes32 borrowingKey,\n        uint256 borrowedAmount,\n        uint256 borrowingCollateral,\n        uint256 liquidationBonus,\n        uint256 dailyRatePrepayment\n    );\n    /// Indicates that a borrower has repaid their loan, optionally with the help of a liquidator\n    event Repay(address borrower, address liquidator, bytes32 borrowingKey);\n    /// Indicates that a loan has been closed due to an emergency situation\n    event EmergencyLoanClosure(address borrower, address lender, bytes32 borrowingKey);\n    /// Indicates that the protocol has collected fee tokens\n    event CollectProtocol(address recipient, address[] tokens, uint256[] amounts);\n    /// Indicates that the daily interest rate for holding token(for specific pair) has been updated\n    event UpdateHoldTokenDailyRate(address saleToken, address holdToken, uint256 value);\n    /// Indicates that a borrower has increased their collateral balance for a loan\n    event IncreaseCollateralBalance(address borrower, bytes32 borrowingKey, uint256 collateralAmt);\n    /// Indicates that a new borrower has taken over the debt from an old borrower\n    event TakeOverDebt(\n        address oldBorrower,\n        address newBorrower,\n        bytes32 oldBorrowingKey,\n        bytes32 newBorrowingKey\n    );\n\n    error TooLittleReceivedError(uint256 minOut, uint256 out);\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _underlyingQuoterV2,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            if (amount > 0) {\n                platformsFeesInfo[token] = 0;\n                amounts[i] = amount;\n                Vault(VAULT_ADDRESS).transferToken(token, recipient, amount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external {\n        (msg.sender != dailyRateOperator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanInfo[] memory loans) {\n        loans = loansInfo[borrowingKey];\n    }\n\n    /**\n     * @notice Retrieves the borrowing information for a specific NonfungiblePositionManager tokenId.\n     * @param tokenId The unique identifier of the PositionManager token.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getLenderCreditsInfo(\n        uint256 tokenId\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = tokenIdToBorrowingKeys[tokenId];\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @notice Retrieves the debts information for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getBorrowerDebtsInfo(\n        address borrower\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower];\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Returns the number of loans associated with a given NonfungiblePositionManager tokenId.\n     * @param tokenId The ID of the token.\n     * @return count The total number of loans associated with the tokenId.\n     */\n    function getLenderCreditsCount(uint256 tokenId) external view returns (uint256 count) {\n        bytes32[] memory borrowingKeys = tokenIdToBorrowingKeys[tokenId];\n        count = borrowingKeys.length;\n    }\n\n    /**\n     * @dev Returns the number of borrowings for a given borrower.\n     * @param borrower The address of the borrower.\n     * @return count The total number of borrowings for the borrower.\n     */\n    function getBorrowerDebtsCount(address borrower) external view returns (uint256 count) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower];\n        count = borrowingKeys.length;\n    }\n\n    /**\n     * @dev Returns the current daily rate for holding token.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @return currentDailyRate The current daily rate .\n     */\n    function getHoldTokenDailyRateInfo(\n        address saleToken,\n        address holdToken\n    ) external view returns (uint256 currentDailyRate, TokenInfo memory holdTokenRateInfo) {\n        (currentDailyRate, holdTokenRateInfo) = _getHoldTokenRateInfo(saleToken, holdToken);\n    }\n\n    /**\n     * @dev Returns the fees information for multiple tokens in an array.\n     * @param tokens An array of token addresses for which the fees are to be retrieved.\n     * @return fees An array containing the fees for each token.\n     */\n    function getPlatformsFeesInfo(\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        fees = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            fees[i] = amount;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates the collateral amount required for a lifetime in seconds.\n     *\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param lifetimeInSeconds The duration of the borrowing in seconds.\n     * @return collateralAmt The calculated collateral amount that is needed.\n     */\n    function calculateCollateralAmtForLifetime(\n        bytes32 borrowingKey,\n        uint256 lifetimeInSeconds\n    ) external view returns (uint256 collateralAmt) {\n        // Retrieve the BorrowingInfo struct associated with the borrowing key\n        BorrowingInfo memory borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowed position is existing\n        if (borrowing.borrowedAmount > 0) {\n            // Get the current daily rate for the hold token\n            (uint256 currentDailyRate, ) = _getHoldTokenRateInfo(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n            // Calculate the collateral amount per second\n            uint256 everySecond = (\n                FullMath.mulDivRoundingUp(\n                    borrowing.borrowedAmount,\n                    currentDailyRate * Constants.COLLATERAL_BALANCE_PRECISION,\n                    1 days * Constants.BP\n                )\n            );\n            // Calculate the total collateral amount for the borrowing lifetime\n            collateralAmt = FullMath.mulDivRoundingUp(\n                everySecond,\n                lifetimeInSeconds,\n                Constants.COLLATERAL_BALANCE_PRECISION\n            );\n            // Ensure that the collateral amount is at least 1\n            if (collateralAmt == 0) collateralAmt = 1;\n        }\n    }\n\n    /**\n     * @notice This function is used to increase the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param collateralAmt The amount of collateral to be added.\n     */\n    function increaseCollateralBalance(bytes32 borrowingKey, uint256 collateralAmt) external {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists and the borrower is the message sender\n        (borrowing.borrowedAmount == 0 || borrowing.borrower != address(msg.sender)).revertError(\n            ErrLib.ErrorCode.INVALID_BORROWING_KEY\n        );\n        // Increase the daily rate collateral balance by the specified collateral amount\n        borrowing.dailyRateCollateralBalance +=\n            collateralAmt *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        _pay(borrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt);\n        emit IncreaseCollateralBalance(msg.sender, borrowingKey, collateralAmt);\n    }\n\n    /**\n     * @notice Take over debt by transferring ownership of a borrowing to the current caller\n     * @dev This function allows the current caller to take over a debt from another borrower.\n     * The function validates the borrowingKey and checks if the collateral balance is negative.\n     * If the conditions are met, the function transfers ownership of the borrowing to the current caller,\n     * updates the daily rate collateral balance, and pays the collateral amount to the vault.\n     * Emits a `TakeOverDebt` event.\n     * @param borrowingKey The unique key associated with the borrowing to be taken over\n     * @param collateralAmt The amount of collateral to be provided by the new borrower\n     */\n    function takeOverDebt(bytes32 borrowingKey, uint256 collateralAmt) external {\n        BorrowingInfo memory oldBorrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists\n        (oldBorrowing.borrowedAmount == 0).revertError(ErrLib.ErrorCode.INVALID_BORROWING_KEY);\n\n        uint256 accLoanRatePerSeconds;\n        uint256 minPayment;\n        {\n            // Update token rate info and retrieve the accumulated loan rate per second for holdToken\n            (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(\n                oldBorrowing.saleToken,\n                oldBorrowing.holdToken\n            );\n            accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            // Calculate the collateral balance and current fees for the oldBorrowing\n            (int256 collateralBalance, uint256 currentFees) = _calculateCollateralBalance(\n                oldBorrowing.borrowedAmount,\n                oldBorrowing.accLoanRatePerSeconds,\n                oldBorrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n            // Ensure that the collateral balance is greater than or equal to 0\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            // Pick up platform fees from the oldBorrowing's holdToken and add them to the feesOwed\n            currentFees = _pickUpPlatformFees(oldBorrowing.holdToken, currentFees);\n            oldBorrowing.feesOwed += currentFees;\n            // Calculate the minimum payment required based on the collateral balance\n            minPayment = (uint256(-collateralBalance) / Constants.COLLATERAL_BALANCE_PRECISION) + 1;\n            (collateralAmt <= minPayment).revertError(\n                ErrLib.ErrorCode.COLLATERAL_AMOUNT_IS_NOT_ENOUGH\n            );\n        }\n        // Retrieve the old loans associated with the borrowing key and remove them from storage\n        LoanInfo[] memory oldLoans = loansInfo[borrowingKey];\n        _removeKeysAndClearStorage(oldBorrowing.borrower, borrowingKey, oldLoans);\n        // Initialize a new borrowing using the same saleToken, holdToken\n        (\n            uint256 feesDebt,\n            bytes32 newBorrowingKey,\n            BorrowingInfo storage newBorrowing\n        ) = _initOrUpdateBorrowing(\n                oldBorrowing.saleToken,\n                oldBorrowing.holdToken,\n                accLoanRatePerSeconds\n            );\n        // Add the new borrowing key and old loans to the newBorrowing\n        _addKeysAndLoansInfo(newBorrowing.borrowedAmount > 0, borrowingKey, oldLoans);\n        // Increase the borrowed amount, liquidation bonus, and fees owed of the newBorrowing based on the oldBorrowing\n        newBorrowing.borrowedAmount += oldBorrowing.borrowedAmount;\n        newBorrowing.liquidationBonus += oldBorrowing.liquidationBonus;\n        newBorrowing.feesOwed += oldBorrowing.feesOwed;\n        // oldBorrowing.dailyRateCollateralBalance is 0\n        newBorrowing.dailyRateCollateralBalance +=\n            (collateralAmt - minPayment) *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        //newBorrowing.accLoanRatePerSeconds = oldBorrowing.accLoanRatePerSeconds;\n        _pay(oldBorrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt + feesDebt);\n        emit TakeOverDebt(oldBorrowing.borrower, msg.sender, borrowingKey, newBorrowingKey);\n    }\n\n    /**\n     * @notice Borrow function allows a user to borrow tokens by providing collateral and taking out loans.\n     * The trader opens a long position by borrowing the liquidity of Uniswap V3 and extracting it into a pair of tokens,\n     * one of which will be swapped into a desired(holdToken).The tokens will be kept in storage until the position is closed.\n     * The margin is calculated on the basis that liquidity must be restored with any price movement.\n     * The time the position is held is paid by the trader.\n     * @dev Emits a Borrow event upon successful borrowing.\n     * @param params The BorrowParams struct containing the necessary parameters for borrowing.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     */\n    function borrow(\n        BorrowParams calldata params,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) {\n        // Precalculating borrowing details and storing them in cache\n        BorrowCache memory cache = _precalculateBorrowing(params);\n        // Initializing borrowing variables and obtaining borrowing key\n        (\n            uint256 feesDebt,\n            bytes32 borrowingKey,\n            BorrowingInfo storage borrowing\n        ) = _initOrUpdateBorrowing(params.saleToken, params.holdToken, cache.accLoanRatePerSeconds);\n        // Adding borrowing key and loans information to storage\n        _addKeysAndLoansInfo(borrowing.borrowedAmount > 0, borrowingKey, params.loans);\n        // Calculating liquidation bonus based on hold token, borrowed amount, and number of used loans\n        uint256 liquidationBonus = getLiquidationBonus(\n            params.holdToken,\n            cache.borrowedAmount,\n            params.loans.length\n        );\n        // Updating borrowing details\n        borrowing.borrowedAmount += cache.borrowedAmount;\n        borrowing.liquidationBonus += liquidationBonus;\n        borrowing.dailyRateCollateralBalance +=\n            cache.dailyRateCollateral *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        // Checking if borrowing collateral exceeds the maximum allowed collateral\n        uint256 borrowingCollateral = cache.borrowedAmount - cache.holdTokenBalance;\n        (borrowingCollateral > params.maxCollateral).revertError(\n            ErrLib.ErrorCode.TOO_BIG_COLLATERAL\n        );\n\n        // Transfer the required tokens to the VAULT_ADDRESS for collateral and holdTokenBalance\n        _pay(\n            params.holdToken,\n            msg.sender,\n            VAULT_ADDRESS,\n            borrowingCollateral + liquidationBonus + cache.dailyRateCollateral + feesDebt\n        );\n        // Transferring holdTokenBalance to VAULT_ADDRESS\n        _pay(params.holdToken, address(this), VAULT_ADDRESS, cache.holdTokenBalance);\n        // Emit the Borrow event with the borrower, borrowing key, and borrowed amount\n        emit Borrow(\n            msg.sender,\n            borrowingKey,\n            cache.borrowedAmount,\n            borrowingCollateral,\n            liquidationBonus,\n            cache.dailyRateCollateral\n        );\n    }\n\n    /**\n     * @notice This function is used to repay a loan.\n     * The position is closed either by the trader or by the liquidator if the trader has not paid for holding the position\n     * and the moment of liquidation has arrived.The positions borrowed from liquidation providers are restored from the held\n     * token and the remainder is sent to the caller.In the event of liquidation, the liquidity provider\n     * whose liquidity is present in the traderâ€™s position can use the emergency mode and withdraw their liquidity.In this case,\n     * he will receive hold tokens and liquidity will not be restored in the uniswap pool.\n     * @param params The repayment parameters including\n     *  activation of the emergency liquidity restoration mode (available only to the lender)\n     *  internal swap pool fee,\n     *  external swap parameters,\n     *  borrowing key,\n     *  swap slippage allowance.\n     * @param deadline The deadline by which the repayment must be made.\n     */\n    function repay(\n        RepayParams calldata params,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) {\n        BorrowingInfo memory borrowing = borrowingsInfo[params.borrowingKey];\n        // Check if the borrowing key is valid\n        (borrowing.borrowedAmount == 0).revertError(ErrLib.ErrorCode.INVALID_BORROWING_KEY);\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n        uint256 liquidationBonus = borrowing.liquidationBonus;\n        int256 collateralBalance;\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        {\n            // Calculate collateral balance and validate caller\n            uint256 accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            uint256 currentFees;\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n\n            (msg.sender != borrowing.borrower && collateralBalance >= 0).revertError(\n                ErrLib.ErrorCode.INVALID_CALLER\n            );\n\n            // Calculate liquidation bonus and adjust fees owed\n\n            if (\n                collateralBalance > 0 &&\n                (currentFees + borrowing.feesOwed) / Constants.COLLATERAL_BALANCE_PRECISION >\n                Constants.MINIMUM_AMOUNT\n            ) {\n                liquidationBonus +=\n                    uint256(collateralBalance) /\n                    Constants.COLLATERAL_BALANCE_PRECISION;\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance;\n            }\n\n            // Calculate platform fees and adjust fees owed\n            borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        }\n        // Check if it's an emergency repayment\n        if (params.isEmergency) {\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            (\n                uint256 removedAmt,\n                uint256 feesAmt,\n                bool completeRepayment\n            ) = _calculateEmergencyLoanClosure(\n                    zeroForSaleToken,\n                    params.borrowingKey,\n                    borrowing.feesOwed,\n                    borrowing.borrowedAmount\n                );\n            (removedAmt == 0).revertError(ErrLib.ErrorCode.LIQUIDITY_IS_ZERO);\n            // prevent overspent\n            // Subtract the removed amount and fees from borrowedAmount and feesOwed\n            borrowing.borrowedAmount -= removedAmt;\n            borrowing.feesOwed -= feesAmt;\n            feesAmt /= Constants.COLLATERAL_BALANCE_PRECISION;\n            // Deduct the removed amount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= removedAmt;\n            // If loansInfoLength is 0, remove the borrowing key from storage and get the liquidation bonus\n            if (completeRepayment) {\n                LoanInfo[] memory empty;\n                _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, empty);\n                feesAmt += liquidationBonus;\n            } else {\n                BorrowingInfo storage borrowingStorage = borrowingsInfo[params.borrowingKey];\n                borrowingStorage.dailyRateCollateralBalance = 0;\n                borrowingStorage.feesOwed = borrowing.feesOwed;\n                borrowingStorage.borrowedAmount = borrowing.borrowedAmount;\n                // Calculate the updated accLoanRatePerSeconds\n                borrowingStorage.accLoanRatePerSeconds =\n                    holdTokenRateInfo.accLoanRatePerSeconds -\n                    FullMath.mulDiv(\n                        uint256(-collateralBalance),\n                        Constants.BP,\n                        borrowing.borrowedAmount // new amount\n                    );\n            }\n            // Transfer removedAmt + feesAmt to msg.sender and emit EmergencyLoanClosure event\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                msg.sender,\n                removedAmt + feesAmt\n            );\n            emit EmergencyLoanClosure(borrowing.borrower, msg.sender, params.borrowingKey);\n        } else {\n            // Deduct borrowedAmount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= borrowing.borrowedAmount;\n\n            // Transfer the borrowed amount and liquidation bonus from the VAULT to this contract\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n            // Restore liquidity using the borrowed amount and pay a daily rate fee\n            LoanInfo[] memory loans = loansInfo[params.borrowingKey];\n            _maxApproveIfNecessary(\n                borrowing.holdToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n            _maxApproveIfNecessary(\n                borrowing.saleToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n\n            _restoreLiquidity(\n                RestoreLiquidityParams({\n                    zeroForSaleToken: zeroForSaleToken,\n                    fee: params.internalSwapPoolfee,\n                    slippageBP1000: params.swapSlippageBP1000,\n                    totalfeesOwed: borrowing.feesOwed,\n                    totalBorrowedAmount: borrowing.borrowedAmount\n                }),\n                params.externalSwap,\n                loans\n            );\n            // Get the remaining balance of saleToken and holdToken\n            (uint256 saleTokenBalance, uint256 holdTokenBalance) = _getPairBalance(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n            // Remove borrowing key from related data structures\n            _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n            // Pay a profit to a msg.sender\n            _pay(borrowing.holdToken, address(this), msg.sender, holdTokenBalance);\n            _pay(borrowing.saleToken, address(this), msg.sender, saleTokenBalance);\n\n            emit Repay(borrowing.borrower, msg.sender, params.borrowingKey);\n        }\n    }\n\n    /**\n     * @dev Calculates the liquidation bonus for a given token, borrowed amount, and times factor.\n     * @param token The address of the token.\n     * @param borrowedAmount The amount of tokens borrowed.\n     * @param times The times factor to apply to the liquidation bonus calculation.\n     * @return liquidationBonus The calculated liquidation bonus.\n     */\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n\n        if (liq.bonusBP == 0) {\n            // If there is no specific bonus for the token\n            // Use default bonus\n            liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n            liq.bonusBP = dafaultLiquidationBonusBP;\n        }\n        liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n        if (liquidationBonus < liq.minBonusAmount) {\n            liquidationBonus = liq.minBonusAmount;\n        }\n        l"
    }
  ]
}