{
  "Title": "[G-16] Unnecessary variables in `LibMap.sol`",
  "Content": "\n**Function `get`:**\n\nVariables `mapValue` and `bitOffset` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/libraries/LibMap.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/LibMap.sol#L21-L28)\n\n```\nuint256 mapValue = _map.map[_index / 8];\n\n// First three bits of the original `_index` denotes the position of the uint32 in that slot.\n// So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\nuint256 bitOffset = (_index & 7) * 32;\n\n// Shift the bits to the right and retrieve the uint32 value.\nresult = uint32(mapValue >> bitOffset);\n```\n\nTo:\n\n```\nresult = uint32(_map.map[_index / 8] >> ( (_index & 7) * 32));\n```\n\n**Function `set`:**\n\nVariables `oldValue` and `nexValueXorOldValue` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/libraries/LibMap.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/LibMap.sol#L56-L63)\n\n```\n            uint32 oldValue = uint32(mapValue >> bitOffset);\n\n            // Calculate the XOR of the new value and the existing value.\n            uint256 newValueXorOldValue = uint256(oldValue ^ _value);\n\n            // Finally, we XOR the slot with the XOR of the new value and the existing value,\n            // shifted to its proper position. The XOR operation will effectively replace the old value with the new value.\n            _map.map[mapIndex] = (newValueXorOldValue << bitOffset) ^ mapValue;\n```\n\nTo:\n\n```\n            _map.map[mapIndex] = (uint256(uint32(mapValue >> bitOffset) ^ _value) << bitOffset) ^ mapValue;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/zksync/libraries/LibMap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @notice Library for storage of packed unsigned integers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\nlibrary LibMap {\n    /// @dev A uint32 map in storage.\n    struct Uint32Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev Retrieves the uint32 value at a specific index from the Uint32Map.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @return result The uint32 value at the specified index.\n    function get(Uint32Map storage _map, uint256 _index) internal view returns (uint32 result) {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapValue = _map.map[_index / 8];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            result = uint32(mapValue >> bitOffset);\n        }\n    }\n\n    /// @dev Updates the uint32 value at `_index` in `map`.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @param _value The new value at the specified index.\n    function set(\n        Uint32Map storage _map,\n        uint256 _index,\n        uint32 _value\n    ) internal {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapIndex = _index / 8;\n            uint256 mapValue = _map.map[mapIndex];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // XORing a value A with B, and then with A again, gives the original value B.\n            // We will use this property to update the uint32 value in the slot.\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            uint32 oldValue = uint32(mapValue >> bitOffset);\n\n            // Calculate the XOR of the new value and the existing value.\n            uint256 newValueXorOldValue = uint256(oldValue ^ _value);\n\n            // Finally, we XOR the slot with the XOR of the new value and the existing value,\n            // shifted to its proper position. The XOR operation will effectively replace the old value with the new value.\n            _map.map[mapIndex] = (newValueXorOldValue << bitOffset) ^ mapValue;\n        }\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/zksync/libraries/LibMap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/// @notice Library for storage of packed unsigned integers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\nlibrary LibMap {\n    /// @dev A uint32 map in storage.\n    struct Uint32Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev Retrieves the uint32 value at a specific index from the Uint32Map.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @return result The uint32 value at the specified index.\n    function get(Uint32Map storage _map, uint256 _index) internal view returns (uint32 result) {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapValue = _map.map[_index / 8];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            result = uint32(mapValue >> bitOffset);\n        }\n    }\n\n    /// @dev Updates the uint32 value at `_index` in `map`.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @param _value The new value at the specified index.\n    function set(\n        Uint32Map storage _map,\n        uint256 _index,\n        uint32 _value\n    ) internal {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapIndex = _index / 8;\n            uint256 mapValue = _map.map[mapIndex];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // XORing a value A with B, and then with A again, gives the original value B.\n            // We will use this property to update the uint32 value in the slot.\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            uint32 oldValue = uint32(mapValue >> bitOffset);\n\n            // Calculate the XOR of the new value and the existing value.\n            uint256 newValueXorOldValue = uint256(oldValue ^ _value);\n\n            // Finally, we XOR the slot with the XOR of the new value and the existing value,\n            // shifted to its proper position. The XOR operation will effectively replace the old value with the new value.\n            _map.map[mapIndex] = (newValueXorOldValue << bitOffset) ^ mapValue;\n        }\n    }\n}"
    }
  ]
}