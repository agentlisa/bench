{
  "Title": "M-23 The `owner` is a single point of failure and a centralization risk",
  "Content": "\n\n*Note: This finding was reported via the winning [Automated Findings report](https://gist.github.com/itsmetechjay/57d432101e7d8c98f3a061502aa8f327). It was declared out of scope for the audit, but is being included here for completeness.*\n\nHaving a single EOA as the only owner of contracts is a large centralization risk and a single point of failure. A single private key may be taken in a hack, or the sole holder of the key may become unable to retrieve the key when necessary, or the single owner can become malicious and perform a rug-pull. Consider changing to a multi-signature setup, and or having a role-based authorization model.\n\n*There are 24 instances of this issue:*\n\n```solidity\nFile: cache/solpp-generated-contracts/common/AllowList.sol\n\n51:      function setAccessMode(address _target, AccessMode _accessMode) external onlyOwner {\n\n60:      function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessModes) external onlyOwner {\n\n85       function setBatchPermissionToCall(\n86           address[] calldata _callers,\n87           address[] calldata _targets,\n88           bytes4[] calldata _functionSigs,\n89           bool[] calldata _enables\n90:      ) external onlyOwner {\n\n108      function setPermissionToCall(\n109          address _caller,\n110          address _target,\n111          bytes4 _functionSig,\n112          bool _enable\n113:     ) external onlyOwner {\n\n131:     function setDepositLimit(address _l1Token, bool _depositLimitation, uint256 _depositCap) external onlyOwner {\n\n```\n*GitHub*: [51](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L49-L49), [60](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L58-L58), [85](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L83-L88), [108](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L106-L111), [131](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L129-L129)\n\n```solidity\nFile: cache/solpp-generated-contracts/governance/Governance.sol\n\n131:     function scheduleTransparent(Operation calldata _operation, uint256 _delay) external onlyOwner {\n\n144:     function scheduleShadow(bytes32 _id, uint256 _delay) external onlyOwner {\n\n156:     function cancel(bytes32 _id) external onlyOwnerOrSecurityCouncil {\n\n169:     function execute(Operation calldata _operation) external onlyOwnerOrSecurityCouncil {\n\n```\n*GitHub*: [131](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/governance/Governance.sol#L129-L129), [144](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/governance/Governance.sol#L142-L142), [156](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/governance/Governance.sol#L154-L154), [169](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/governance/Governance.sol#L167-L167)\n\n```solidity\nFile: cache/solpp-generated-contracts/zksync/ValidatorTimelock.sol\n\n54:      function setValidator(address _newValidator) external onlyOwner {\n\n61:      function setExecutionDelay(uint32 _executionDelay) external onlyOwner {\n\n```\n*GitHub*: [54](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/ValidatorTimelock.sol#L52-L52), [61](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/ValidatorTimelock.sol#L59-L59)\n\n```solidity\nFile: cache/solpp-generated-contracts/zksync/facets/Admin.sol\n\n22:      function setPendingGovernor(address _newPendingGovernor) external onlyGovernor {\n\n46:      function setPendingAdmin(address _newPendingAdmin) external onlyGovernorOrAdmin {\n\n70:      function setValidator(address _validator, bool _active) external onlyGovernorOrAdmin {\n\n77:      function setPorterAvailability(bool _zkPorterIsAvailable) external onlyGovernor {\n\n85:      function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyGovernor {\n\n100:     function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n\n111:     function freezeDiamond() external onlyGovernor {\n\n122:     function unfreezeDiamond() external onlyGovernorOrAdmin {\n\n```\n*GitHub*: [22](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L20-L20), [46](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L44-L44), [70](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L68-L68), [77](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L75-L75), [85](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L83-L83), [100](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L98-L98), [111](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L109-L109), [122](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L120-L120)\n\n```solidity\nFile: cache-zk/solpp-generated-contracts/NonceHolder.sol\n\n84:      function setValueUnderNonce(uint256 _key, uint256 _value) public onlySystemCall {\n\n```\n*GitHub*: [84](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/NonceHolder.sol#L82-L82)\n\n```solidity\nFile: cache-zk/solpp-generated-contracts/SystemContext.sol\n\n89:      function setTxOrigin(address _newOrigin) external onlyCallFromBootloader {\n\n95:      function setGasPrice(uint256 _gasPrice) external onlyCallFromBootloader {\n\n314      function setL2Block(\n315          uint128 _l2BlockNumber,\n316          uint128 _l2BlockTimestamp,\n317          bytes32 _expectedPrevL2BlockHash,\n318          bool _isFirstInBatch,\n319          uint128 _maxVirtualBlocksToCreate\n320:     ) external onlyCallFromBootloader {\n\n418      function setNewBatch(\n419          bytes32 _prevBatchHash,\n420          uint128 _newTimestamp,\n421          uint128 _expectedNewNumber,\n422          uint256 _baseFee\n423:     ) external onlyCallFromBootloader {\n\n```\n*GitHub*: [89](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/SystemContext.sol#L87-L87), [95](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/SystemContext.sol#L93-L93), [314](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/SystemContext.sol#L312-L318), [418](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/SystemContext.sol#L416-L421)\n\n**[Alex the Entreprenerd (judge) commented](https://gist.github.com/itsmetechjay/57d432101e7d8c98f3a061502aa8f327?permalink_comment_id=4877666#gistcomment-4877666):**\n> I believe it is correct to add to the report. Although, post Supreme Court it would not be accepted, and instead would have had to be added to the Analysis.\n\n**[vladbochok (zkSync) disputed and commented](https://gist.github.com/itsmetechjay/57d432101e7d8c98f3a061502aa8f327?permalink_comment_id=4942620#gistcomment-4942620):**\n> This is not true, the admin role is not an EOA, but a multisig and is a matter of configuration to the different environments - localhost, testnet and mainnet. So we dispute that this is an issue at all. Moreover, the upgradability is intended training wheels for the current state of L2 protocols.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/common/AllowList.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport \"./interfaces/IAllowList.sol\";\nimport \"./libraries/UncheckedMath.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The smart contract that stores the permissions to call the function on different contracts.\n/// @dev The contract is fully controlled by the owner, that can grant and revoke any permissions at any time.\n/// @dev The permission list has three different modes:\n/// - Closed. The contract cannot be called by anyone.\n/// - SpecialAccessOnly. Only some contract functions can be called by specifically granted addresses.\n/// - Public. Access list to call any function from the target contract by any caller\ncontract AllowList is IAllowList, Ownable2Step {\n    using UncheckedMath for uint256;\n\n    /// @notice The Access mode by which it is decided whether the caller has access\n    mapping(address => AccessMode) public getAccessMode;\n\n    /// @notice The mapping that stores permissions to call the function on the target address by the caller\n    /// @dev caller => target => function signature => permission to call target function for the given caller address\n    mapping(address => mapping(address => mapping(bytes4 => bool))) public hasSpecialAccessToCall;\n\n    /// @dev The mapping L1 token address => struct Deposit\n    mapping(address => Deposit) public tokenDeposit;\n\n    constructor(address _initialOwner) {\n        _transferOwnership(_initialOwner);\n    }\n\n    /// @return Whether the caller can call the specific function on the target contract\n    /// @param _caller The caller address, who is granted access\n    /// @param _target The address of the smart contract which is called\n    /// @param _functionSig The function signature (selector), access to which need to check\n    function canCall(address _caller, address _target, bytes4 _functionSig) external view returns (bool) {\n        AccessMode accessMode = getAccessMode[_target];\n        return\n            accessMode == AccessMode.Public ||\n            (accessMode == AccessMode.SpecialAccessOnly && hasSpecialAccessToCall[_caller][_target][_functionSig]);\n    }\n\n    /// @notice Set the permission mode to call the target contract\n    /// @param _target The address of the smart contract, of which access to the call is to be changed\n    /// @param _accessMode Whether no one, any or only some addresses can call the target contract\n    function setAccessMode(address _target, AccessMode _accessMode) external onlyOwner {\n        _setAccessMode(_target, _accessMode);\n    }\n\n    /// @notice Set many permission modes to call the target contracts\n    /// @dev Analogous to function `setAccessMode` but performs a batch of changes\n    /// @param _targets The array of smart contract addresses, of which access to the call is to be changed\n    /// @param _accessModes The array of new permission modes, whether no one, any or only some addresses can call the\n    /// target contract\n    function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessModes) external onlyOwner {\n        uint256 targetsLength = _targets.length;\n        require(targetsLength == _accessModes.length, \"yg\"); // The size of arrays should be equal\n\n        for (uint256 i = 0; i < targetsLength; i = i.uncheckedInc()) {\n            _setAccessMode(_targets[i], _accessModes[i]);\n        }\n    }\n\n    /// @dev Changes access mode and emit the event if the access was changed\n    function _setAccessMode(address _target, AccessMode _accessMode) internal {\n        AccessMode accessMode = getAccessMode[_target];\n\n        if (accessMode != _accessMode) {\n            getAccessMode[_target] = _accessMode;\n            emit UpdateAccessMode(_target, accessMode, _accessMode);\n        }\n    }\n\n    /// @notice Set many permissions to call the function on the contract to the specified caller address\n    /// @param _callers The array of caller addresses, who are granted access\n    /// @param _targets The array of smart contract addresses, of which access to the call are to be changed\n    /// @param _functionSigs The array of function signatures (selectors), access to which need to be changed\n    /// @param _enables The array of boolean flags, whether enable or disable the function access to the corresponding\n    /// target address\n    function setBatchPermissionToCall(\n        address[] calldata _callers,\n        address[] calldata _targets,\n        bytes4[] calldata _functionSigs,\n        bool[] calldata _enables\n    ) external onlyOwner {\n        uint256 callersLength = _callers.length;\n\n        // The size of arrays should be equal\n        require(callersLength == _targets.length, \"yw\");\n        require(callersLength == _functionSigs.length, \"yx\");\n        require(callersLength == _enables.length, \"yy\");\n\n        for (uint256 i = 0; i < callersLength; i = i.uncheckedInc()) {\n            _setPermissionToCall(_callers[i], _targets[i], _functionSigs[i], _enables[i]);\n        }\n    }\n\n    /// @notice Set the permission to call the function on the contract to the specified caller address\n    /// @param _caller The caller address, who is granted access\n    /// @param _target The address of the smart contract, of which access to the call is to be changed\n    /// @param _functionSig The function signature (selector), access to which need to be changed\n    /// @param _enable Whether enable or disable the permission\n    function setPermissionToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig,\n        bool _enable\n    ) external onlyOwner {\n        _setPermissionToCall(_caller, _target, _functionSig, _enable);\n    }\n\n    /// @dev Changes permission to call and emits the event if the permission was changed\n    function _setPermissionToCall(address _caller, address _target, bytes4 _functionSig, bool _enable) internal {\n        bool currentPermission = hasSpecialAccessToCall[_caller][_target][_functionSig];\n\n        if (currentPermission != _enable) {\n            hasSpecialAccessToCall[_caller][_target][_functionSig] = _enable;\n            emit UpdateCallPermission(_caller, _target, _functionSig, _enable);\n        }\n    }\n\n    /// @dev Set deposit limit data for a token\n    /// @param _l1Token The address of L1 token\n    /// @param _depositLimitation deposit limitation is active or not\n    /// @param _depositCap The maximum amount that can be deposited.\n    function setDepositLimit(address _l1Token, bool _depositLimitation, uint256 _depositCap) external onlyOwner {\n        tokenDeposit[_l1Token].depositLimitation = _depositLimitation;\n        tokenDeposit[_l1Token].depositCap = _depositCap;\n    }\n\n    /// @dev Get deposit limit data of a token\n    /// @param _l1Token The address of L1 token\n    function getTokenDepositLimitData(address _l1Token) external view returns (Deposit memory) {\n        return tokenDeposit[_l1Token];\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/governance/Governance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IGovernance} from \"./IGovernance.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Contract design is inspired by OpenZeppelin TimelockController and in-house Diamond Proxy upgrade mechanism.\n/// @notice This contract manages operations (calls with preconditions) for governance tasks.\n/// The contract allows for operations to be scheduled, executed, and canceled with\n/// appropriate permissions and delays. It is used for managing and coordinating upgrades\n/// and changes in all zkSync Era governed contracts.\n///\n/// Operations can be proposed as either fully transparent upgrades with on-chain data,\n/// or \"shadow\" upgrades where upgrade data is not published on-chain before execution. Proposed operations\n/// are subject to a delay before they can be executed, but they can be executed instantly\n/// with the security councilâ€™s permission.\ncontract Governance is IGovernance, Ownable2Step {\n    /// @notice A constant representing the timestamp for completed operations.\n    uint256 internal constant EXECUTED_PROPOSAL_TIMESTAMP = uint256(1);\n\n    /// @notice The address of the security council.\n    /// @dev It is supposed to be multisig contract.\n    address public securityCouncil;\n\n    /// @notice A mapping to store timestamps where each operation will be ready for execution.\n    /// @dev - 0 means the operation is not created.\n    /// @dev - 1 (EXECUTED_PROPOSAL_TIMESTAMP) means the operation is already executed.\n    /// @dev - any other value means timestamp in seconds when the operation will be ready for execution.\n    mapping(bytes32 => uint256) public timestamps;\n\n    /// @notice The minimum delay in seconds for operations to be ready for execution.\n    uint256 public minDelay;\n\n    /// @notice Initializes the contract with the admin address, security council address, and minimum delay.\n    /// @param _admin The address to be assigned as the admin of the contract.\n    /// @param _securityCouncil The address to be assigned as the security council of the contract.\n    /// @param _minDelay The initial minimum delay (in seconds) to be set for operations.\n    constructor(address _admin, address _securityCouncil, uint256 _minDelay) {\n        require(_admin != address(0), \"Admin should be non zero address\");\n\n        _transferOwnership(_admin);\n\n        securityCouncil = _securityCouncil;\n        emit ChangeSecurityCouncil(address(0), _securityCouncil);\n\n        minDelay = _minDelay;\n        emit ChangeMinDelay(0, _minDelay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks that the message sender is contract itself.\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Only governance contract itself allowed to call this function\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active security council.\n    modifier onlySecurityCouncil() {\n        require(msg.sender == securityCouncil, \"Only security council allowed to call this function\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active owner or an active security council.\n    modifier onlyOwnerOrSecurityCouncil() {\n        require(\n            msg.sender == owner() || msg.sender == securityCouncil,\n            \"Only the owner and security council are allowed to call this function\"\n        );\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            OPERATION GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Returns whether an id corresponds to a registered operation. This\n    /// includes both Waiting, Ready, and Done operations.\n    function isOperation(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) != OperationState.Unset;\n    }\n\n    /// @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n    function isOperationPending(bytes32 _id) public view returns (bool) {\n        OperationState state = getOperationState(_id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n    function isOperationReady(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is done or not.\n    function isOperationDone(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Done;\n    }\n\n    /// @dev Returns operation state.\n    function getOperationState(bytes32 _id) public view returns (OperationState) {\n        uint256 timestamp = timestamps[_id];\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == EXECUTED_PROPOSAL_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SCHEDULING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Propose a fully transparent upgrade, providing upgrade data on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function scheduleTransparent(Operation calldata _operation, uint256 _delay) external onlyOwner {\n        bytes32 id = hashOperation(_operation);\n        _schedule(id, _delay);\n        emit TransparentOperationScheduled(id, _delay, _operation);\n    }\n\n    /// @notice Propose \"shadow\" upgrade, upgrade data is not publishing on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade may be executed by the owner.\n    function scheduleShadow(bytes32 _id, uint256 _delay) external onlyOwner {\n        _schedule(_id, _delay);\n        emit ShadowOperationScheduled(_id, _delay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CANCELING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Cancel the scheduled operation.\n    /// @dev Both the owner and security council may cancel an operation.\n    /// @param _id Proposal id value (see `hashOperation`)\n    function cancel(bytes32 _id) external onlyOwnerOrSecurityCouncil {\n        require(isOperationPending(_id), \"Operation must be pending\");\n        delete timestamps[_id];\n        emit OperationCancelled(_id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXECUTING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Executes the scheduled operation after the delay passed.\n    /// @dev Both the owner and security council may execute delayed operations.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function execute(Operation calldata _operation) external onlyOwnerOrSecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is ready to proceed.\n        require(isOperationReady(id), \"Operation must be ready before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still ready after execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationReady(id), \"Operation must be ready after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @notice Executes the scheduled operation with the security council instantly.\n    /// @dev Only the security council may execute an operation instantly.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function executeInstant(Operation calldata _operation) external onlySecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is in a pending state before proceeding.\n        require(isOperationPending(id), \"Operation must be pending before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still pending before execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationPending(id), \"Operation must be pending after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @dev Returns the identifier of an operation.\n    /// @param _operation The operation object to compute the identifier for.\n    function hashOperation(Operation calldata _operation) public pure returns (bytes32) {\n        return keccak256(abi.encode(_operation));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Schedule an operation that is to become valid after a given delay.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function _schedule(bytes32 _id, uint256 _delay) internal {\n        require(!isOperation(_id), \"Operation with this proposal id already exists\");\n        require(_delay >= minDelay, \"Proposed delay is less than minimum delay\");\n\n        timestamps[_id] = block.timestamp + _delay;\n    }\n\n    /// @dev Execute an operation's calls.\n    /// @param _calls The array of calls to be executed.\n    function _execute(Call[] calldata _calls) internal {\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (!success) {\n                // Propage an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n        }\n    }\n\n    /// @notice Verifies if the predecessor operation is completed.\n    /// @param _predecessorId The hash of the operation that should be completed.\n    /// @dev Doesn't check the operation to be complete if the input is zero.\n    function _checkPredecessorDone(bytes32 _predecessorId) internal view {\n        require(_predecessorId == bytes32(0) || isOperationDone(_predecessorId), \"Predecessor operation not completed\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SELF UPGRADES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Changes the minimum timelock duration for future operations.\n    /// @param _newDelay The new minimum delay time (in seconds) for future operations.\n    function updateDelay(uint256 _newDelay) external onlySelf {\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n\n    /// @dev Updates the address of the security council.\n    /// @param _newSecurityCouncil The address of the new security council.\n    function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\n        emit ChangeSecurityCouncil(securityCouncil, _newSecurityCouncil);\n        securityCouncil = _newSecurityCouncil;\n    }\n\n    /// @dev Contract might receive/hold ETH as part of the maintenance process.\n    receive() external payable {}\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/zksync/ValidatorTimelock.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"./libraries/LibMap.sol\";\nimport \"./interfaces/IExecutor.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Intermediate smart contract between the validator EOA account and the zkSync smart contract.\n/// @dev The primary purpose of this contract is to provide a trustless means of delaying batch execution without\n/// modifying the main zkSync contract. As such, even if this contract is compromised, it will not impact the main\n/// contract.\n/// @dev zkSync actively monitors the chain activity and reacts to any suspicious activity by freezing the chain.\n/// This allows time for investigation and mitigation before resuming normal operations.\n/// @dev The contract overloads all of the 4 methods, that are used in state transition. When the batch is committed,\n/// the timestamp is stored for it. Later, when the owner calls the batch execution, the contract checks that batch\n/// was committed not earlier than X time ago.\ncontract ValidatorTimelock is IExecutor, Ownable2Step {\n    using LibMap for LibMap.Uint32Map;\n\n    /// @dev Part of the IBase interface. Not used in this contract.\n    string public constant override getName = \"ValidatorTimelock\";\n\n    /// @notice The delay between committing and executing batches is changed.\n    event NewExecutionDelay(uint256 _newExecutionDelay);\n\n    /// @notice The validator address is changed.\n    event NewValidator(address _oldValidator, address _newValidator);\n\n    /// @dev The main zkSync smart contract.\n    address public immutable zkSyncContract;\n\n    /// @dev The mapping of L2 batch number => timestamp when it was committed.\n    LibMap.Uint32Map internal committedBatchTimestamp;\n\n    /// @dev The address that can commit/revert/validate/execute batches.\n    address public validator;\n\n    /// @dev The delay between committing and executing batches.\n    uint32 public executionDelay;\n\n    constructor(address _initialOwner, address _zkSyncContract, uint32 _executionDelay, address _validator) {\n        _transferOwnership(_initialOwner);\n        zkSyncContract = _zkSyncContract;\n        executionDelay = _executionDelay;\n        validator = _validator;\n    }\n\n    /// @dev Set new validator address.\n    function setValidator(address _newValidator) external onlyOwner {\n        address oldValidator = validator;\n        validator = _newValidator;\n        emit NewValidator(oldValidator, _newValidator);\n    }\n\n    /// @dev Set the delay between committing and executing batches.\n    function setExecutionDelay(uint32 _executionDelay) external onlyOwner {\n        executionDelay = _executionDelay;\n        emit NewExecutionDelay(_executionDelay);\n    }\n\n    /// @notice Checks if the caller is a validator.\n    modifier onlyValidator() {\n        require(msg.sender == validator, \"8h\");\n        _;\n    }\n\n    /// @dev Returns the timestamp when `_l2BatchNumber` was committed.\n    function getCommittedBatchTimestamp(uint256 _l2BatchNumber) external view returns (uint256) {\n        return committedBatchTimestamp.get(_l2BatchNumber);\n    }\n\n    /// @dev Records the timestamp for all provided committed batches and make\n    /// a call to the zkSync contract with the same calldata.\n    function commitBatches(\n        StoredBatchInfo calldata,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external onlyValidator {\n        unchecked {\n            // This contract is only a temporary solution, that hopefully will be disabled until 2106 year, so...\n            // It is safe to cast.\n            uint32 timestamp = uint32(block.timestamp);\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                committedBatchTimestamp.set(_newBatchesData[i].batchNumber, timestamp);\n            }\n        }\n\n        _propagateToZkSync();\n    }\n\n    /// @dev Make a call to the zkSync contract with the same calldata.\n    /// Note: If the batch is reverted, it needs to be committed first before the execution.\n    /// So it's safe to not override the committed batches.\n    function revertBatches(uint256) external onlyValidator {\n        _propagateToZkSync();\n    }\n\n    /// @dev Make a call to the zkSync contract with the same calldata.\n    /// Note: We don't track the time when batches are proven, since all information about\n    /// the batch is known on the commit stage and the proved is not finalized (may be reverted).\n    function proveBatches(\n        StoredBatchInfo calldata,\n        StoredBatchInfo[] calldata,\n        ProofInput calldata\n    ) external onlyValidator {\n        _propagateToZkSync();\n    }\n\n    /// @dev Check that batches were committed at least X time ago and\n    /// make a call to the zkSync contract with the same calldata.\n    function executeBatches(StoredBatchInfo[] calldata _newBatchesData) external onlyValidator {\n        uint256 delay = executionDelay; // uint32\n        unchecked {\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                uint256 commitBatchTimestamp = committedBatchTimestamp.get(_newBatchesData[i].batchNumber);\n\n                // Note: if the `commitBatchTimestamp` is zero, that means either:\n                // * The batch was committed, but not through this contract.\n                // * The batch wasn't committed at all, so execution will fail in the zkSync contract.\n                // We allow executing such batches.\n                require(block.timestamp >= commitBatchTimestamp + delay, \"5c\"); // The delay is not passed\n            }\n        }\n\n        _propagateToZkSync();\n    }\n\n    /// @dev Call the zkSync contract with the same calldata as this contract was called.\n    /// Note: it is called the zkSync contract, not delegatecalled!\n    function _propagateToZkSync() internal {\n        address contractAddress = zkSyncContract;\n        assembly {\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(0, 0, calldatasize())\n            // Call method of the zkSync contract returns 0 on error\n            let result := call(gas(), contractAddress, 0, 0, calldatasize(), 0, 0)\n            // Get the size of the last return data\n            let size := returndatasize()\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(0, 0, size)\n            // Depending on the result value\n            switch result\n            case 0 {\n                // End execution and revert state changes\n                revert(0, size)\n            }\n            default {\n                // Return data with length of size at pointers position\n                return(0, size)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/zksync/facets/Admin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../interfaces/IAdmin.sol\";\nimport \"../libraries/Diamond.sol\";\nimport \"../../common/libraries/L2ContractHelper.sol\";\nimport {L2_TX_MAX_GAS_LIMIT} from \"../Config.sol\";\nimport \"./Base.sol\";\n\n/// @title Admin Contract controls access rights for contract management.\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract AdminFacet is Base, IAdmin {\n    string public constant override getName = \"AdminFacet\";\n\n    /// @notice Starts the transfer of governor rights. Only the current governor can propose a new pending one.\n    /// @notice New governor can accept governor rights by calling `acceptGovernor` function.\n    /// @param _newPendingGovernor Address of the new governor\n    function setPendingGovernor(address _newPendingGovernor) external onlyGovernor {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingGovernor = s.pendingGovernor;\n        // Change pending governor\n        s.pendingGovernor = _newPendingGovernor;\n        emit NewPendingGovernor(oldPendingGovernor, _newPendingGovernor);\n    }\n\n    /// @notice Accepts transfer of governor rights. Only pending governor can accept the role.\n    function acceptGovernor() external {\n        address pendingGovernor = s.pendingGovernor;\n        require(msg.sender == pendingGovernor, \"n4\"); // Only proposed by current governor address can claim the governor rights\n\n        address previousGovernor = s.governor;\n        s.governor = pendingGovernor;\n        delete s.pendingGovernor;\n\n        emit NewPendingGovernor(pendingGovernor, address(0));\n        emit NewGovernor(previousGovernor, pendingGovernor);\n    }\n\n    /// @notice Starts the transfer of admin rights. Only the current governor or admin can propose a new pending one.\n    /// @notice New admin can accept admin rights by calling `acceptAdmin` function.\n    /// @param _newPendingAdmin Address of the new admin\n    function setPendingAdmin(address _newPendingAdmin) external onlyGovernorOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = s.pendingAdmin;\n        // Change pending admin\n        s.pendingAdmin = _newPendingAdmin;\n        emit NewPendingGovernor(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @notice Accepts transfer of admin rights. Only pending admin can accept the role.\n    function acceptAdmin() external {\n        address pendingAdmin = s.pendingAdmin;\n        require(msg.sender == pendingAdmin, \"n4\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = s.admin;\n        s.admin = pendingAdmin;\n        delete s.pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @notice Change validator status (active or not active)\n    /// @param _validator Validator address\n    /// @param _active Active flag\n    function setValidator(address _validator, bool _active) external onlyGovernorOrAdmin {\n        s.validators[_validator] = _active;\n        emit ValidatorStatusUpdate(_validator, _active);\n    }\n\n    /// @notice Change zk porter availability\n    /// @param _zkPorterIsAvailable The availability of zk porter shard\n    function setPorterAvailability(bool _zkPorterIsAvailable) external onlyGovernor {\n        // Change the porter availability\n        s.zkPorterIsAvailable = _zkPorterIsAvailable;\n        emit IsPorterAvailableStatusUpdate(_zkPorterIsAvailable);\n    }\n\n    /// @notice Change the max L2 gas limit for L1 -> L2 transactions\n    /// @param _newPriorityTxMaxGasLimit The maximum number of L2 gas that a user can request for L1 -> L2 transactions\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyGovernor {\n        require(_newPriorityTxMaxGasLimit <= L2_TX_MAX_GAS_LIMIT, \"n5\");\n\n        uint256 oldPriorityTxMaxGasLimit = s.priorityTxMaxGasLimit;\n        s.priorityTxMaxGasLimit = _newPriorityTxMaxGasLimit;\n        emit NewPriorityTxMaxGasLimit(oldPriorityTxMaxGasLimit, _newPriorityTxMaxGasLimit);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UPGRADE EXECUTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Executes a proposed governor upgrade\n    /// @dev Only the current governor can execute the upgrade\n    /// @param _diamondCut The diamond cut parameters to be executed\n    function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT FREEZING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    /// @dev Only the governance mechanism may freeze Diamond Proxy\n    function freezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        diamondStorage.isFrozen = true;\n\n        emit Freeze();\n    }\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    /// @dev Both the governor and its owner can unfreeze Diamond Proxy\n    function unfreezeDiamond() external onlyGovernorOrAdmin {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n        diamondStorage.isFrozen = false;"
    }
  ]
}