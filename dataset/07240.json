{
  "Title": "[G-05] Structs can be packed into fewer storage slots",
  "Content": "Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/interfaces/IGnosis.sol\n\n/// @audit Variable ordering with 11 slots instead of the current 12:\n///           uint256(32):orderCancellationEndDate, uint256(32):auctionEndDate, bytes32(32):initialAuctionOrder, uint256(32):minimumBiddingAmountPerOrder, uint256(32):interimSumBidAmount, bytes32(32):interimOrder, bytes32(32):clearingPriceOrder, uint256(32):feeNumerator, uint256(32):minFundingThreshold, user-defined(20):auctioningToken, uint96(12):volumeClearingPriceOrder, user-defined(20):biddingToken, bool(1):minFundingThresholdNotReached, bool(1):isAtomicClosureAllowed\n6     struct GnosisAuctionData {\n7         IERC20 auctioningToken;\n8         IERC20 biddingToken;\n9         uint256 orderCancellationEndDate;\n10        uint256 auctionEndDate;\n11        bytes32 initialAuctionOrder;\n12        uint256 minimumBiddingAmountPerOrder;\n13        uint256 interimSumBidAmount;\n14        bytes32 interimOrder;\n15        bytes32 clearingPriceOrder;\n16        uint96 volumeClearingPriceOrder;\n17        bool minFundingThresholdNotReached;\n18        bool isAtomicClosureAllowed;\n19        uint256 feeNumerator;\n20        uint256 minFundingThreshold;\n21:   }\n\n```\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/interfaces/IGnosis.sol#L6-L21\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-reserve",
  "Code": [
    {
      "filename": "contracts/interfaces/IGnosis.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nstruct GnosisAuctionData {\n    IERC20 auctioningToken;\n    IERC20 biddingToken;\n    uint256 orderCancellationEndDate;\n    uint256 auctionEndDate;\n    bytes32 initialAuctionOrder;\n    uint256 minimumBiddingAmountPerOrder;\n    uint256 interimSumBidAmount;\n    bytes32 interimOrder;\n    bytes32 clearingPriceOrder;\n    uint96 volumeClearingPriceOrder;\n    bool minFundingThresholdNotReached;\n    bool isAtomicClosureAllowed;\n    uint256 feeNumerator;\n    uint256 minFundingThreshold;\n}\n\n/// The relevant portion of the interface of the live Gnosis EasyAuction contract\n/// https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\ninterface IGnosis {\n    function initiateAuction(\n        IERC20 auctioningToken,\n        IERC20 biddingToken,\n        uint256 orderCancellationEndDate,\n        uint256 auctionEndDate,\n        uint96 auctionedSellAmount,\n        uint96 minBuyAmount,\n        uint256 minimumBiddingAmountPerOrder,\n        uint256 minFundingThreshold,\n        bool isAtomicClosureAllowed,\n        address accessManagerContract,\n        bytes memory accessManagerContractData\n    ) external returns (uint256 auctionId);\n\n    function auctionData(uint256 auctionId) external view returns (GnosisAuctionData memory);\n\n    /// @param auctionId The external auction id\n    /// @dev See here for decoding: https://git.io/JMang\n    /// @return encodedOrder The order, encoded in a bytes 32\n    function settleAuction(uint256 auctionId) external returns (bytes32 encodedOrder);\n\n    /// @return The numerator over a 1000-valued denominator\n    function feeNumerator() external returns (uint256);\n}"
    }
  ]
}