{
  "Title": "[L02] ESD price defaults to one",
  "Content": "In the `StabilizerComptroller` contract, whenever the oracle becomes unhealthy, the protocol [sets immediately the `ema` to 1](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerComptroller.sol#L167).\n\n\nWhether this choice is intended to protect or stabilize the price of the `ESD` to a fixed price, it is not clear and straightforward why that would be the best mitigation to an unhealthy oracle.\n\n\nConsider properly justifying this choice or the assumptions that are taken in place whenever the oracle becomes unhealthy.\n\n\n***Update**: Acknowledged. The EmptySetSquad team statement for this issue:*\n\n\n\n> \n> *Expected behavior since a stablecoinâ€™s neutral price is $1.00.*\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/stabilizer/StabilizerComptroller.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"../lib/Decimal.sol\";\nimport \"../lib/TimeUtils.sol\";\nimport \"./StabilizerState.sol\";\nimport \"./StabilizerToken.sol\";\n\n/**\n * @title StabilizerComptroller\n * @notice Stabilizer core accounting logic supplying, redeeming, and managing ESD.\n * @dev Any ESD that is airdropped into the stabilizer will be automatically become part of the pool\n */\ncontract StabilizerComptroller is StabilizerAccessors, StabilizerToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `account` supplies `amount` ESD to the stabilizer for `mintAmount` sESD\n     */\n    event Supply(address indexed account, uint256 amount, uint256 mintAmount);\n\n    /**\n     * @notice Emitted when `account` redeems `amount` ESD from the stabilizer for `burnAmount` sESD\n     */\n    event Redeem(address indexed account, uint256 amount, uint256 burnAmount);\n\n    /**\n     * @notice Emitted every time the stabilizer borrows `amount` ESD from the reserve to accrue rewards\n     */\n    event Settle(uint256 amount);\n\n    // EXTERNAL\n\n    /**\n     * @notice The total amount of ESD held by the stabilizer\n     * @return Total ESD holdings\n     */\n    function totalUnderlying() public view returns (uint256) {\n        return IERC20(registry().dollar()).balanceOf(address(this));\n    }\n\n    /**\n     * @notice The ESD balance for `account`\n     * @param account Account to retrieve balance information for\n     * @return ESD balance\n     */\n    function balanceOfUnderlying(address account) public view returns (uint256) {\n        return balanceOf(account).mul(totalUnderlying()).div(totalSupply());\n    }\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of ESD to supply\n     */\n    function supply(uint256 amount) external {\n        _settle();\n\n        uint256 mintAmount = totalUnderlying() == 0 ? amount : amount.mul(totalSupply()).div(totalUnderlying());\n\n        _supply(msg.sender, amount, mintAmount);\n    }\n\n    /**\n     * @notice Withdraws ESD from the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of sESD to redeem\n     */\n    function redeem(uint256 amount) external {\n        _settle();\n\n        uint256 redeemAmount = amount.mul(totalUnderlying()).div(totalSupply(), \"StabilizerComptroller: no supply\");\n\n        _redeem(msg.sender, redeemAmount, amount);\n    }\n\n    /**\n     * @notice Withdraws ESD from the stabilizer in exchange for sESD reward-accruing tokens\n     * @param amount Amount of ESD to redeem\n     */\n    function redeemUnderlying(uint256 amount) external {\n        _settle();\n\n        uint256 burnAmount = amount.mul(totalSupply()).div(totalUnderlying(), \"StabilizerComptroller: no underlying\");\n\n        _redeem(msg.sender, amount, burnAmount);\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice The stabilizer's current effective reward rate\n     * @dev In terms of % of the totalUnderlying per day\n     *      Uses EMA floored at the current reserve redemption price and maxed at 1.00\n     * @return Current effective reward rate\n     */\n    function setup() external onlyOwner {\n        IOracle oracle = IOracle(registry().oracle());\n        address dollar = registry().dollar();\n\n        require(!oracle.setupFor(dollar), \"StabilizerComptroller: already setup\");\n\n        oracle.setup(dollar);\n        _state.oracle.ema = Decimal.one();\n    }\n\n    /**\n     * @notice The stabilizer's current effective reward rate\n     * @dev In terms of % of the totalUnderlying per day\n     *      Uses EMA floored at the current reserve redemption price and maxed at 1.00\n     * @return Current effective reward rate\n     */\n    function rate() public view returns (Decimal.D256 memory) {\n        Decimal.D256 memory emaMin = IReserve(registry().reserve()).redeemPrice();\n        Decimal.D256 memory emaMax = Decimal.one();\n        Decimal.D256 memory ema = ema();\n        Decimal.D256 memory emaLimited = Decimal.min(Decimal.max(ema, emaMin), emaMax);\n\n        return Decimal.one().sub(emaLimited).mul(rewardRate());\n    }\n\n    /**\n     * @notice Core flywheel which captures the oracle TWAP, updates the EMA, and borrows the corresponding amount\n     * @dev EMA_1 = (alpha * price) + ((1 - alpha) * EMA_0)\n     *      alpha = decayRate * elapsedDays, maxed out at maxAlpha()\n     *      If oracle becomes unhealthy immediately set EMA to 1\n     *\n     *      Borrows rate() * elapsedDays * totalUnderlying() ESD from the stabilizer\n     *      Uses rate() before EMA update to prevent same-block price manipulation\n     */\n    function _settle() internal {\n\n        // Get current oracle snapshot\n        (Decimal.D256 memory price, uint256 elapsed, bool healthy) =\n            IOracle(registry().oracle()).capture(registry().dollar());\n        Decimal.D256 memory elapsedDays = TimeUtils.secondsToDays(elapsed);\n\n        // Borrow ESD per prior rate\n        uint256 borrowAmount = rate().mul(elapsedDays).mul(totalUnderlying()).asUint256();\n        if (borrowAmount != 0) IReserve(registry().reserve()).borrow(borrowAmount);\n\n        // Update EMA\n        if (healthy) {\n            Decimal.D256 memory alpha = Decimal.min(decayRate().mul(elapsedDays), maxAlpha());\n            _updateEma(alpha.mul(price).add(Decimal.one().sub(alpha).mul(ema())));\n        } else {\n            _updateEma(Decimal.one());\n        }\n\n        emit Settle(borrowAmount);\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @dev Internal only - generic helper\n     * @param account Account that is supplying\n     * @param supplyAmount ESD amount to supply\n     * @param mintAmount sESD amount to mint\n     */\n    function _supply(address account, uint256 supplyAmount, uint256 mintAmount) internal {\n        IERC20(registry().dollar()).safeTransferFrom(account, address(this), supplyAmount);\n        _mint(msg.sender, mintAmount);\n\n        emit Supply(account, supplyAmount, mintAmount);\n    }\n\n    /**\n     * @notice Deposits ESD into the stabilizer in exchange for sESD reward-accruing tokens\n     * @dev Internal only - generic helper\n     * @param account Account that is redeeming\n     * @param redeemAmount ESD amount to redeem\n     * @param burnAmount sESD amount to burn\n     */\n    function _redeem(address account, uint256 redeemAmount, uint256 burnAmount) internal {\n        _burn(msg.sender, burnAmount);\n        IERC20(registry().dollar()).safeTransfer(msg.sender, redeemAmount);\n\n        emit Redeem(account, redeemAmount, burnAmount);\n    }\n}"
    }
  ]
}