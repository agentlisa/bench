{
  "Title": "[M-05] `LSP8CompatibleERC721`'s `approve()` deviates from ERC-721 specification",
  "Content": "\nThe `LSP8CompatibleERC721` contract is a wrapper around LSP8, which is meant to function similarly to ERC-721 tokens. One of its implemented functions is ERC-721's `approve()`:\n\n[LSP8CompatibleERC721.sol#L155-L158](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8CompatibleERC721.sol#L155-L158)\n\n```solidity\n    function approve(address operator, uint256 tokenId) public virtual {\n        authorizeOperator(operator, bytes32(tokenId));\n        emit Approval(tokenOwnerOf(bytes32(tokenId)), operator, tokenId);\n    }\n```\n\nAs `approve()` calls `authorizeOperator()` from the `LSP8IdentifiableDigitalAssetCore` contract, only the owner of `tokenId` is allowed to call `approve()`:\n\n[LSP8IdentifiableDigitalAssetCore.sol#L105-L113](https://github.com/code-423n4/2023-06-lukso/blob/main/contracts/LSP8IdentifiableDigitalAsset/LSP8IdentifiableDigitalAssetCore.sol#L105-L113)\n\n```solidity\n    function authorizeOperator(\n        address operator,\n        bytes32 tokenId\n    ) public virtual {\n        address tokenOwner = tokenOwnerOf(tokenId);\n\n        if (tokenOwner != msg.sender) {\n            revert LSP8NotTokenOwner(tokenOwner, tokenId, msg.sender);\n        }\n```\n\nHowever, the implementation above deviates from the [ERC-721 specification](https://eips.ethereum.org/EIPS/eip-721), which mentions that an \"authorized operator of the current owner\" should also be able to call `approve()`:\n\n```solidity\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n```\n\nThis means, anyone who is an approved operator for `tokenId`'s owner through `setApprovalForAll()` should also be able to grant approvals. An example of such behaviour can be seen in [Openzeppelin's ERC721 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol):\n\n[ERC721.sol#L121-L123](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L121-L123)\n\n```solidity\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert ERC721InvalidApprover(_msgSender());\n        }\n```\n\n### Impact\n\nAs `LSP8CompatibleERC721`'s `approve()` functions differently from ERC-721, protocols that rely on this functionality will be incompatible with LSP8 tokens that inherit from `LSP8CompatibleERC721`.\n\nFor example, in an NFT exchange, users might be required to call `setApprovalForAll()` for the protocol's router contract. The router then approves a swap contract, which transfers the NFT from the user to the recipient using `transferFrom()`.\n\nAdditionally, developers that expect `LSP8CompatibleERC721` to behave exactly like ERC-721 tokens might introduce bugs in their contracts, due to the difference in `approve()`.\n\n### Recommended Mitigation\n\nModify `approve()` to allow approved operators for `tokenId`'s owner to grant approvals:\n\n```solidity\nfunction approve(address operator, uint256 tokenId) public virtual { \n    bytes32 tokenIdBytes = bytes32(tokenId);\n    address tokenOwner = tokenOwnerOf(tokenIdBytes);\n\n    if (tokenOwner != msg.sender && !isApprovedForAll(tokenOwner, msg.sender)) {\n        revert LSP8NotTokenOwner(tokenOwner, tokenIdBytes, msg.sender);\n    }\n\n    if (operator == address(0)) {\n        revert LSP8CannotUseAddressZeroAsOperator();\n    }\n\n    if (tokenOwner == operator) {\n        revert LSP8TokenOwnerCannotBeOperator();\n    }\n\n    bool isAdded = _operators[tokenIdBytes].add(operator);\n    if (!isAdded) revert LSP8OperatorAlreadyAuthorized(operator, tokenIdBytes);\n\n    emit AuthorizedOperator(operator, tokenOwner, tokenIdBytes);\n    emit Approval(tokenOwner, operator, tokenId);\n}\n```\n\n### Assessed type\n\nERC721\n\n**[skimaharvey (LUKSO) disputed and commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/118#issuecomment-1666005147):**\n > > However, the implementation above deviates from the [ERC-721 specification](https://eips.ethereum.org/EIPS/eip-721), which mentions that an \"authorized operator of the current owner\" should also be able to call `approve()`:\n> \n> @MiloTruck - can you please point me to it in the standard because I could not find anything stipulating that?\n\n**[MiloTruck (warden) commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/118#issuecomment-1666015673):**\n > @skimaharvey - It's mentioned in the `@dev` natspec comment above `approve()` in the ERC-721 interface under [specification](https://eips.ethereum.org/EIPS/eip-721#specification):\n> \n> ```\n>     ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n>     ///  operator of the current owner.\n> ```\n> \n> You can refer to the code block in the issue above as well.\n\n**[skimaharvey (LUKSO) confirmed and commented](https://github.com/code-423n4/2023-06-lukso-findings/issues/118#issuecomment-1666033259):**\n > NVM read it too fast. Seems valid ðŸ™. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP8IdentifiableDigitalAsset/extensions/LSP8CompatibleERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {\n    IERC721Receiver\n} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {ILSP8CompatibleERC721} from \"./ILSP8CompatibleERC721.sol\";\nimport {\n    ILSP8IdentifiableDigitalAsset\n} from \"../ILSP8IdentifiableDigitalAsset.sol\";\n\n// libraries\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n// modules\nimport {\n    LSP4Compatibility\n} from \"../../LSP4DigitalAssetMetadata/LSP4Compatibility.sol\";\nimport {\n    LSP8IdentifiableDigitalAsset,\n    LSP4DigitalAssetMetadata,\n    ERC725YCore\n} from \"../LSP8IdentifiableDigitalAsset.sol\";\nimport {\n    LSP8IdentifiableDigitalAssetCore\n} from \"../LSP8IdentifiableDigitalAssetCore.sol\";\n\n// errors\nimport \"../LSP8Errors.sol\";\n\n// constants\nimport {\n    _LSP4_METADATA_KEY\n} from \"../../LSP4DigitalAssetMetadata/LSP4Constants.sol\";\nimport {\n    _INTERFACEID_ERC721,\n    _INTERFACEID_ERC721METADATA\n} from \"././ILSP8CompatibleERC721.sol\";\n\n/**\n * @dev LSP8 extension, for compatibility for clients / tools that expect ERC721.\n */\nabstract contract LSP8CompatibleERC721 is\n    ILSP8CompatibleERC721,\n    LSP4Compatibility,\n    LSP8IdentifiableDigitalAsset\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * Mapping from owner to operator approvals\n     * @dev for backward compatibility with ERC721\n     */\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @notice Sets the name, the symbol and the owner of the token\n     * @param name_ The name of the token\n     * @param symbol_ The symbol of the token\n     * @param newOwner_ The owner of the token\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address newOwner_\n    ) LSP8IdentifiableDigitalAsset(name_, symbol_, newOwner_) {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(IERC165, ERC725YCore, LSP8IdentifiableDigitalAsset)\n        returns (bool)\n    {\n        return\n            interfaceId == _INTERFACEID_ERC721 ||\n            interfaceId == _INTERFACEID_ERC721METADATA ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /*\n     * @inheritdoc ILSP8CompatibleERC721\n     */\n    function tokenURI(\n        uint256 /* tokenId */\n    ) public view virtual returns (string memory) {\n        bytes memory data = _getData(_LSP4_METADATA_KEY);\n\n        // offset = bytes4(hashSig) + bytes32(contentHash) -> 4 + 32 = 36\n        uint256 offset = 36;\n\n        bytes memory uriBytes = BytesLib.slice(\n            data,\n            offset,\n            data.length - offset\n        );\n        return string(uriBytes);\n    }\n\n    /**\n     * @inheritdoc ILSP8CompatibleERC721\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return tokenOwnerOf(bytes32(tokenId));\n    }\n\n    /**\n     * @inheritdoc ILSP8CompatibleERC721\n     */\n    function getApproved(\n        uint256 tokenId\n    ) public view virtual returns (address) {\n        bytes32 tokenIdAsBytes32 = bytes32(tokenId);\n        _existsOrError(tokenIdAsBytes32);\n\n        address[] memory operatorsForTokenId = getOperatorsOf(tokenIdAsBytes32);\n        uint256 operatorListLength = operatorsForTokenId.length;\n\n        if (operatorListLength == 0) {\n            return address(0);\n        } else {\n            // Read the last added operator authorized to provide \"best\" compatibility.\n            // In ERC721 there is one operator address at a time for a tokenId, so multiple calls to\n            // `approve` would cause `getApproved` to return the last added operator. In this\n            // compatibility version the same is true, when the authorized operators were not previously\n            // authorized. If addresses are removed, then `getApproved` returned address can change due\n            // to implementation of `EnumberableSet._remove`.\n            return operatorsForTokenId[operatorListLength - 1];\n        }\n    }\n\n    /*\n     * @inheritdoc ILSP8CompatibleERC721\n     */\n    function isApprovedForAll(\n        address tokenOwner,\n        address operator\n    ) public view virtual returns (bool) {\n        return _operatorApprovals[tokenOwner][operator];\n    }\n\n    /**\n     * @inheritdoc ILSP8CompatibleERC721\n     */\n    function approve(address operator, uint256 tokenId) public virtual {\n        authorizeOperator(operator, bytes32(tokenId));\n        emit Approval(tokenOwnerOf(bytes32(tokenId)), operator, tokenId);\n    }\n\n    /**\n     * @dev See _setApprovalForAll\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @inheritdoc ILSP8CompatibleERC721\n     * @dev Compatible with ERC721 transferFrom.\n     * Using allowNonLSP1Recipient=true so that EOA and any contract may receive the tokenId.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual {\n        _transfer(from, to, bytes32(tokenId), true, \"\");\n    }\n\n    /**\n     * @inheritdoc ILSP8CompatibleERC721\n     * @dev Compatible with ERC721 safeTransferFrom (without optional data).\n     * Using allowNonLSP1Recipient=false so that no EOA and only contracts supporting LSP1 interface may receive the tokenId.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /*\n     * @dev Compatible with ERC721 safeTransferFrom (with optional data).\n     * Using allowNonLSP1Recipient=false so that no EOA and only contracts supporting LSP1 interface may receive the tokenId.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual {\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    // --- Overrides\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function authorizeOperator(\n        address operator,\n        bytes32 tokenId\n    )\n        public\n        virtual\n        override(\n            ILSP8IdentifiableDigitalAsset,\n            LSP8IdentifiableDigitalAssetCore\n        )\n    {\n        super.authorizeOperator(operator, tokenId);\n        emit Approval(tokenOwnerOf(tokenId), operator, uint256(tokenId));\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        bytes32 tokenId,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) internal virtual override {\n        address operator = msg.sender;\n\n        if (\n            !isApprovedForAll(from, operator) &&\n            !_isOperatorOrOwner(operator, tokenId)\n        ) {\n            revert LSP8NotTokenOperator(tokenId, operator);\n        }\n\n        emit Transfer(from, to, uint256(tokenId));\n        super._transfer(from, to, tokenId, allowNonLSP1Recipient, data);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, bytes32(tokenId), true, data);\n        require(\n            _checkOnERC721Received(from, to, tokenId, data),\n            \"LSP8CompatibleERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _mint(\n        address to,\n        bytes32 tokenId,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) internal virtual override {\n        emit Transfer(address(0), to, uint256(tokenId));\n        super._mint(to, tokenId, allowNonLSP1Recipient, data);\n    }\n\n    function _burn(\n        bytes32 tokenId,\n        bytes memory data\n    ) internal virtual override {\n        address tokenOwner = tokenOwnerOf(tokenId);\n\n        emit Transfer(tokenOwner, address(0), uint256(tokenId));\n        super._burn(tokenId, data);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all tokens of `tokensOwner`\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address tokensOwner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(\n            tokensOwner != operator,\n            \"LSP8CompatibleERC721: approve to caller\"\n        );\n        _operatorApprovals[tokensOwner][operator] = approved;\n        emit ApprovalForAll(tokensOwner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the token\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.code.length > 0) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    tokenId,\n                    data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"LSP8CompatibleERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    // solhint-disable no-inline-assembly\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _setData(\n        bytes32 key,\n        bytes memory value\n    ) internal virtual override(LSP4DigitalAssetMetadata, ERC725YCore) {\n        super._setData(key, value);\n    }\n}"
    },
    {
      "filename": "contracts/LSP8IdentifiableDigitalAsset/LSP8IdentifiableDigitalAssetCore.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {\n    ILSP1UniversalReceiver\n} from \"../LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\";\nimport {\n    ILSP8IdentifiableDigitalAsset\n} from \"./ILSP8IdentifiableDigitalAsset.sol\";\n\n// libraries\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {\n    ERC165Checker\n} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\n// errors\nimport \"./LSP8Errors.sol\";\n\n// constants\nimport {_INTERFACEID_LSP1} from \"../LSP1UniversalReceiver/LSP1Constants.sol\";\nimport {\n    _TYPEID_LSP8_TOKENSSENDER,\n    _TYPEID_LSP8_TOKENSRECIPIENT\n} from \"./LSP8Constants.sol\";\n\n/**\n * @title LSP8IdentifiableDigitalAsset contract\n * @author Matthew Stevens\n * @dev Core Implementation of a LSP8 compliant contract.\n */\nabstract contract LSP8IdentifiableDigitalAssetCore is\n    ILSP8IdentifiableDigitalAsset\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // --- Storage\n\n    uint256 private _existingTokens;\n\n    // Mapping from `tokenId` to `tokenOwner`\n    mapping(bytes32 => address) private _tokenOwners;\n\n    // Mapping `tokenOwner` to owned tokenIds\n    mapping(address => EnumerableSet.Bytes32Set) private _ownedTokens;\n\n    // Mapping a `tokenId` to its authorized operator addresses.\n    mapping(bytes32 => EnumerableSet.AddressSet) private _operators;\n\n    mapping(address => EnumerableSet.Bytes32Set) private _tokenIdsForOperator;\n\n    // --- Token queries\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _existingTokens;\n    }\n\n    // --- Token owner queries\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function balanceOf(\n        address tokenOwner\n    ) public view virtual returns (uint256) {\n        return _ownedTokens[tokenOwner].length();\n    }\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function tokenOwnerOf(\n        bytes32 tokenId\n    ) public view virtual returns (address) {\n        address tokenOwner = _tokenOwners[tokenId];\n\n        if (tokenOwner == address(0)) {\n            revert LSP8NonExistentTokenId(tokenId);\n        }\n\n        return tokenOwner;\n    }\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function tokenIdsOf(\n        address tokenOwner\n    ) public view virtual returns (bytes32[] memory) {\n        return _ownedTokens[tokenOwner].values();\n    }\n\n    // --- Operator functionality\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function authorizeOperator(\n        address operator,\n        bytes32 tokenId\n    ) public virtual {\n        address tokenOwner = tokenOwnerOf(tokenId);\n\n        if (tokenOwner != msg.sender) {\n            revert LSP8NotTokenOwner(tokenOwner, tokenId, msg.sender);\n        }\n\n        if (operator == address(0)) {\n            revert LSP8CannotUseAddressZeroAsOperator();\n        }\n\n        if (tokenOwner == operator) {\n            revert LSP8TokenOwnerCannotBeOperator();\n        }\n\n        bool isAdded = _operators[tokenId].add(operator);\n        if (!isAdded) revert LSP8OperatorAlreadyAuthorized(operator, tokenId);\n\n        emit AuthorizedOperator(operator, tokenOwner, tokenId);\n    }\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function revokeOperator(address operator, bytes32 tokenId) public virtual {\n        address tokenOwner = tokenOwnerOf(tokenId);\n\n        if (tokenOwner != msg.sender) {\n            revert LSP8NotTokenOwner(tokenOwner, tokenId, msg.sender);\n        }\n\n        if (operator == address(0)) {\n            revert LSP8CannotUseAddressZeroAsOperator();\n        }\n\n        if (tokenOwner == operator) {\n            revert LSP8TokenOwnerCannotBeOperator();\n        }\n\n        _revokeOperator(operator, tokenOwner, tokenId);\n    }\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function isOperatorFor(\n        address operator,\n        bytes32 tokenId\n    ) public view virtual returns (bool) {\n        _existsOrError(tokenId);\n\n        return _isOperatorOrOwner(operator, tokenId);\n    }\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function getOperatorsOf(\n        bytes32 tokenId\n    ) public view virtual returns (address[] memory) {\n        _existsOrError(tokenId);\n\n        return _operators[tokenId].values();\n    }\n\n    /**\n     * @dev verifies if the `caller` is operator or owner for the `tokenId`\n     * @return true if `caller` is either operator or owner\n     */\n    function _isOperatorOrOwner(\n        address caller,\n        bytes32 tokenId\n    ) internal view virtual returns (bool) {\n        address tokenOwner = tokenOwnerOf(tokenId);\n\n        return (caller == tokenOwner || _operators[tokenId].contains(caller));\n    }\n\n    // --- Transfer functionality\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function transfer(\n        address from,\n        address to,\n        bytes32 tokenId,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) public virtual {\n        address operator = msg.sender;\n\n        if (!_isOperatorOrOwner(operator, tokenId)) {\n            revert LSP8NotTokenOperator(tokenId, operator);\n        }\n\n        _transfer(from, to, tokenId, allowNonLSP1Recipient, data);\n    }\n\n    /**\n     * @inheritdoc ILSP8IdentifiableDigitalAsset\n     */\n    function transferBatch(\n        address[] memory from,\n        address[] memory to,\n        bytes32[] memory tokenId,\n        bool[] memory allowNonLSP1Recipient,\n        bytes[] memory data\n    ) public virtual {\n        uint256 fromLength = from.length;\n        if (\n            fromLength != to.length ||\n            fromLength != tokenId.length ||\n            fromLength != allowNonLSP1Recipient.length ||\n            fromLength != data.length\n        ) {\n            revert LSP8InvalidTransferBatch();\n        }\n\n        for (uint256 i = 0; i < fromLength; ) {\n            transfer(\n                from[i],\n                to[i],\n                tokenId[i],\n                allowNonLSP1Recipient[i],\n                data[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev removes `operator` from the list of operators for the `tokenId`\n     */\n    function _revokeOperator(\n        address operator,\n        address tokenOwner,\n        bytes32 tokenId\n    ) internal virtual {\n        bool isRemoved = _operators[tokenId].remove(operator);\n        if (!isRemoved) revert LSP8NonExistingOperator(operator, tokenId);\n        emit RevokedOperator(operator, tokenOwner, tokenId);\n    }\n\n    /**\n     * @dev clear all the operators for the `tokenId`\n     */\n    function _clearOperators(\n        address tokenOwner,\n        bytes32 tokenId\n    ) internal virtual {\n        // here is a good example of why having multiple operators will be expensive.. we\n        // need to clear them on token transfer\n        //\n        // NOTE: this may cause a tx to fail if there is too many operators to clear, in which case\n        // the tokenOwner needs to call `revokeOperator` until there is less operators to clear and\n        // the desired `transfer` or `burn` call can succeed.\n        EnumerableSet.AddressSet storage operatorsForTokenId = _operators[\n            tokenId\n        ];\n\n        uint256 operatorListLength = operatorsForTokenId.length();\n        for (uint256 i = 0; i < operatorListLength; ) {\n            // we are emptying the list, always remove from index 0\n            address operator = operatorsForTokenId.at(0);\n            _revokeOperator(operator, tokenOwner, tokenId);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens start existing when they are minted (`_mint`), and stop existing when they are burned\n     * (`_burn`).\n     */\n    function _exists(bytes32 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev When `tokenId` does not exist then revert with an error.\n     */\n    function _existsOrError(bytes32 tokenId) internal view virtual {\n        if (!_exists(tokenId)) {\n            revert LSP8NonExistentTokenId(tokenId);\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        address to,\n        bytes32 tokenId,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) internal virtual {\n        if (to == address(0)) {\n            revert LSP8CannotSendToAddressZero();\n        }\n\n        if (_exists(tokenId)) {\n            revert LSP8TokenIdAlreadyMinted(tokenId);\n        }\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        // token being minted\n        _existingTokens += 1;\n\n        _ownedTokens[to].add(tokenId);\n        _tokenOwners[tokenId] = to;\n\n        emit Transfer(\n            operator,\n            address(0),\n            to,\n            tokenId,\n            allowNonLSP1Recipient,\n            data\n        );\n\n        bytes memory lsp1Data = abi.encodePacked(address(0), to, tokenId, data);\n        _notifyTokenReceiver(to, allowNonLSP1Recipient, lsp1Data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`, clearing authorized operators.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(bytes32 tokenId, bytes memory data) internal virtual {\n        address tokenOwner = tokenOwnerOf(tokenId);\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(tokenOwner, address(0), tokenId);\n\n        // token being burned\n        _existingTokens -= 1;\n\n        _clearOperators(tokenOwner, tokenId);\n\n        _ownedTokens[tokenOwner].remove(tokenId);\n        delete _tokenOwners[tokenId];\n\n        emit Transfer(operator, tokenOwner, address(0), tokenId, false, data);\n\n        bytes memory lsp1Data = abi.encodePacked(\n            tokenOwner,\n            address(0),\n            tokenId,\n            data\n        );\n        _notifyTokenSender(tokenOwner, lsp1Data);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        bytes32 tokenId,\n        bool allowNonLSP1Recipient,\n        bytes memory data\n    ) internal virtual {\n        if (from == to) {\n            revert LSP8CannotSendToSelf();\n        }\n\n        address tokenOwner = tokenOwnerOf(tokenId);\n        if (tokenOwner != from) {\n            revert LSP8NotTokenOwner(tokenOwner, tokenId, from);\n        }\n\n        if (to == address(0)) {\n            revert LSP8CannotSendToAddressZero();\n        }\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        _clearOperators(from, tokenId);\n\n        _ownedTokens[from].remove(tokenId);\n        _ownedTokens[to].add(tokenId);\n        _tokenOwners[tokenId] = to;\n\n        emit Transfer(operator, from, to, tokenId, allowNonLSP1Recipient, data);\n\n        bytes memory lsp1Data = abi.encodePacked(from, to, tokenId, data);\n\n        _notifyTokenSender(from, lsp1Data);\n        _notifyTokenReceiver(to, allowNonLSP1Recipient, lsp1Data);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        bytes32 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev An attempt is made to notify the token sender about the `tokenId` changing owners using\n     * LSP1 interface.\n     */\n    function _notifyTokenSender(\n        address from,\n        bytes memory lsp1Data\n    ) internal virtual {\n        if (\n            ERC165Checker.supportsERC165InterfaceUnchecked(\n                from,\n                _INTERFACEID_LSP1\n            )\n        ) {\n            ILSP1UniversalReceiver(from).universalReceiver(\n                _TYPEID_LSP8_TOKENSSENDER,\n                lsp1Data\n            );\n        }\n    }\n\n    /**\n     * @dev An attempt is made to notify the token receiver about the `tokenId` changing owners\n     * using LSP1 interface. When allowNonLSP1Recipient is FALSE the token receiver MUST support LSP1.\n     *\n     * The receiver may revert when the token being sent is not wanted.\n     */\n    function _notifyTokenReceiver(\n        address to,\n        bool allowNonLSP1Recipient,\n        bytes memory lsp1Data\n    ) internal virtual {\n        if (\n            ERC165Checker.supportsERC165InterfaceUnchecked(\n                to,\n                _INTERFACEID_LSP1\n            )\n        ) {\n            ILSP1UniversalReceiver(to).universalReceiver(\n                _TYPEID_LSP8_TOKENSRECIPIENT,\n                lsp1Data\n            );\n        } else if (!allowNonLSP1Recipient) {\n            if (to.code.length > 0) {\n                revert LSP8NotifyTokenReceiverContractMissingLSP1Interface(to);\n            } else {\n                revert LSP8NotifyTokenReceiverIsEOA(to);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC721/ERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"./utils/ERC721Utils.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if:\n     * - `spender` does not have approval from `owner` for `tokenId`.\n     * - `spender` does not have approval to manage all of `owner`'s assets.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {"
    }
  ]
}