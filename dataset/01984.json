{
  "Title": "M-12: rewardTokens removed from WAuraPool/WConvexPools will be lost forever",
  "Content": "# Issue M-12: rewardTokens removed from WAuraPool/WConvexPools will be lost forever \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/128 \n\n## Found by \n0x52\n## Summary\n\npendingRewards pulls a fresh count of reward tokens each time it is called. This is problematic if reward tokens are ever removed from the the underlying Aura/Convex pools because it means that they will no longer be distributed and will be locked in the contract forever.\n\n## Vulnerability Detail\n\n[WAuraPools.sol#L166-L189](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L166-L189)\n\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n\nIn the lines above we can see that only tokens that are currently available on the pool. This means that if tokens are removed then they are no longer claimable and will be lost to those entitled to shares.\n\n## Impact\n\nUsers will lose reward tokens if they are removed\n\n## Code Snippet\n\n[WAuraPools.sol#L152-L190](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L152-L190)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReward tokens should be stored with the tokenID so that it can still be paid out even if it the extra rewardToken is removed.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/wrapper/WAuraPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/aura/IAuraRewarder.sol\";\n\n/**\n * @title WAuraPools\n * @author BlueberryProtocol\n * @notice Wrapped Aura Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank \n *      and do not generate yields. LP Tokens are identified by tokenIds \n *      encoded from lp token address.\n */\ncontract WAuraPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWAuraPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Aura Pools contract\n    IAuraPools public auraPools;\n    /// @dev Address to AURA token\n    IERC20Upgradeable public AURA;\n    /// @dev Mapping from gauge id to accBalPerShare\n    mapping(uint256 => uint256) public accCrvPerShares;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => uint256[]) public accExtPerShare;\n\n    function initialize(\n        address aura_,\n        address auraPools_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WAuraPools\");\n        AURA = IERC20Upgradeable(aura_);\n        auraPools = IAuraPools(auraPools_);\n    }\n\n    /// @notice Encode pid, auraPerShare to ERC1155 token id\n    /// @param pid Pool id (16-bit)\n    /// @param auraPerShare AURA amount per share, multiplied by 1e18 (240-bit)\n    function encodeId(\n        uint256 pid,\n        uint256 auraPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (auraPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(auraPerShare);\n        return (pid << 240) | auraPerShare;\n    }\n\n    /// @notice Decode ERC1155 token id to pid, auraPerShare\n    /// @param id Token id\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 auraPerShare) {\n        gid = id >> 240; // First 16 bits\n        auraPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @notice Get underlying ERC20 token of ERC1155 given token id\n    /// @param id Token id\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    function getVault(address bpt) public view returns (IBalancerVault) {\n        return IBalancerVault(IBalancerPool(bpt).getVault());\n    }\n\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        )\n    {\n        return getVault(bpt).getPoolTokens(IBalancerPool(bpt).getPoolId());\n    }\n\n    function getPool(\n        address bpt,\n        uint256 pid\n    ) external view returns (address, uint256) {\n        return getVault(bpt).getPool(bytes32(pid));\n    }\n\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return auraPools.poolInfo(pid);\n    }\n\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IAuraRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice Return pending rewards from the farming pool\n    /// @dev Reward tokens can be multiple tokens\n    /// @param tokenId Token Id\n    /// @param amount amount of share\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n    }\n\n    /// @notice Mint ERC1155 token for the given LP token\n    /// @param pid Aura Pool id\n    /// @param amount Token amount to wrap\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(auraPools), amount);\n        auraPools.deposit(pid, amount, true);\n\n        uint256 crvRewardPerToken = IAuraRewarder(crvRewarder).rewardPerToken();\n        id = encodeId(pid, crvRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n        // Store extra rewards info\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address extraRewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint rewardPerToken = IAuraRewarder(extraRewarder).rewardPerToken();\n            accExtPerShare[id].push(rewardPerToken);\n        }\n    }\n\n    /// @notice Burn ERC1155 token to redeem ERC20 token back\n    /// @param id Token id to burn\n    /// @param amount Token amount to burn\n    /// @return rewardTokens Reward tokens rewards harvested\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address balRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        // Claim Rewards\n        IAuraRewarder(balRewarder).withdraw(amount, true);\n        // Withdraw LP\n        auraPools.withdraw(pid, amount);\n\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/wrapper/WAuraPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/aura/IAuraRewarder.sol\";\n\n/**\n * @title WAuraPools\n * @author BlueberryProtocol\n * @notice Wrapped Aura Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank \n *      and do not generate yields. LP Tokens are identified by tokenIds \n *      encoded from lp token address.\n */\ncontract WAuraPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWAuraPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Aura Pools contract\n    IAuraPools public auraPools;\n    /// @dev Address to AURA token\n    IERC20Upgradeable public AURA;\n    /// @dev Mapping from gauge id to accBalPerShare\n    mapping(uint256 => uint256) public accCrvPerShares;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => uint256[]) public accExtPerShare;\n\n    function initialize(\n        address aura_,\n        address auraPools_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WAuraPools\");\n        AURA = IERC20Upgradeable(aura_);\n        auraPools = IAuraPools(auraPools_);\n    }\n\n    /// @notice Encode pid, auraPerShare to ERC1155 token id\n    /// @param pid Pool id (16-bit)\n    /// @param auraPerShare AURA amount per share, multiplied by 1e18 (240-bit)\n    function encodeId(\n        uint256 pid,\n        uint256 auraPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (auraPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(auraPerShare);\n        return (pid << 240) | auraPerShare;\n    }\n\n    /// @notice Decode ERC1155 token id to pid, auraPerShare\n    /// @param id Token id\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 auraPerShare) {\n        gid = id >> 240; // First 16 bits\n        auraPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @notice Get underlying ERC20 token of ERC1155 given token id\n    /// @param id Token id\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    function getVault(address bpt) public view returns (IBalancerVault) {\n        return IBalancerVault(IBalancerPool(bpt).getVault());\n    }\n\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        )\n    {\n        return getVault(bpt).getPoolTokens(IBalancerPool(bpt).getPoolId());\n    }\n\n    function getPool(\n        address bpt,\n        uint256 pid\n    ) external view returns (address, uint256) {\n        return getVault(bpt).getPool(bytes32(pid));\n    }\n\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return auraPools.poolInfo(pid);\n    }\n\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IAuraRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice Return pending rewards from the farming pool\n    /// @dev Reward tokens can be multiple tokens\n    /// @param tokenId Token Id\n    /// @param amount amount of share\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n    }\n\n    /// @notice Mint ERC1155 token for the given LP token\n    /// @param pid Aura Pool id\n    /// @param amount Token amount to wrap\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(auraPools), amount);\n        auraPools.deposit(pid, amount, true);\n\n        uint256 crvRewardPerToken = IAuraRewarder(crvRewarder).rewardPerToken();\n        id = encodeId(pid, crvRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n        // Store extra rewards info\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address extraRewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint rewardPerToken = IAuraRewarder(extraRewarder).rewardPerToken();\n            accExtPerShare[id].push(rewardPerToken);\n        }\n    }\n\n    /// @notice Burn ERC1155 token to redeem ERC20 token back\n    /// @param id Token id to burn\n    /// @param amount Token amount to burn\n    /// @return rewardTokens Reward tokens rewards harvested\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address balRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        // Claim Rewards\n        IAuraRewarder(balRewarder).withdraw(amount, true);\n        // Withdraw LP\n        auraPools.withdraw(pid, amount);\n\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n    }\n}"
    }
  ]
}