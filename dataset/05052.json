{
  "Title": "[M-22] `MagnetarHelper.getFractionForAmount` uses the wrong rounding and will yield the wrong result",
  "Content": "\n`MagnetarHelper.getFractionForAmount` is used to determine the `fraction` (shares) that will be received when an `amount` is deposited. The code needs to compute the `totalShares` and then determine what the fraction is going to be.\n\nThe logic is used in `Singularity._removeAsset` and since it's tied to a withdrawal, the rounding will be `down`. However, in `MagnetarHelper` the round is `up`.\n\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/2ddbcb1cde03b548e13421b2dba66435d2ac8eb5/contracts/Magnetar/MagnetarHelper.sol#L208-L219>\n\n```solidity\n    function getFractionForAmount(ISingularity singularity, uint256 amount) external view returns (uint256 fraction) {\n        (uint128 totalAssetShare, uint128 totalAssetBase) = singularity.totalAsset();\n        (uint128 totalBorrowElastic,) = singularity.totalBorrow();\n        uint256 assetId = singularity.assetId();\n\n        IYieldBox yieldBox = IYieldBox(singularity.yieldBox());\n\n        uint256 share = yieldBox.toShare(assetId, amount, false);\n        uint256 allShare = totalAssetShare + yieldBox.toShare(assetId, totalBorrowElastic, true); /// @audit Round UP for Debt\n\n        fraction = allShare == 0 ? share : (share * totalAssetBase) / allShare;\n    }\n```\n\nSee the actual implementation in `Singularity`:\n\n<https://github.com/Tapioca-DAO/Tapioca-bar/blob/c2031ac2e2667ac8f9ac48eaedae3dd52abef559/contracts/markets/singularity/SGLCommon.sol#L199-L216>\n\n```solidity\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n        share = (fraction * allShare) / _totalAsset.base;\n    }\n```\n\nThis will cause issues when calculating how much fraction to withdraw based on the amount required by the withdrawer.\n\n### Mitigation\n\nChange the rounding direction:\n\n```solidity\n        uint256 allShare = totalAssetShare + yieldBox.toShare(assetId, totalBorrowElastic, down);\n```\n\n### Assessed type\n\nMath\n\n**[cryptotechmaker (Tapioca) confirmed and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/94#issuecomment-2037278183):**\n > PR [here](https://github.com/Tapioca-DAO/tapioca-periph/commit/a458eaf5771ca9bb29ba18f4f90205d6bcf6fb79).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/MagnetarHelper.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Tapioca\nimport {IYieldBox, IYieldBoxTokenType} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {ISingularity, IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {IBigBang} from \"tapioca-periph/interfaces/bar/IBigBang.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarHelper\n * @author TapiocaDAO\n * @notice View helper methods\n */\ncontract MagnetarHelper {\n    using SafeERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    struct MarketInfo {\n        address collateral;\n        uint256 collateralId;\n        address asset;\n        uint256 assetId;\n        ITapiocaOracle oracle;\n        bytes oracleData;\n        uint256 totalCollateralShare;\n        uint256 userCollateralShare;\n        Rebase totalBorrow;\n        uint256 userBorrowPart;\n        uint256 currentExchangeRate;\n        uint256 spotExchangeRate;\n        uint256 oracleExchangeRate;\n        uint256 totalBorrowCap;\n        uint256 totalYieldBoxCollateralShare;\n        uint256 totalYieldBoxCollateralAmount;\n        uint256 totalYieldBoxAssetShare;\n        uint256 totalYieldBoxAssetAmount;\n        IYieldBoxTokenType yieldBoxCollateralTokenType;\n        address yieldBoxCollateralContractAddress;\n        address yieldBoxCollateralStrategyAddress;\n        uint256 yieldBoxCollateralTokenId;\n        IYieldBoxTokenType yieldBoxAssetTokenType;\n        address yieldBoxAssetContractAddress;\n        address yieldBoxAssetStrategyAddress;\n        uint256 yieldBoxAssetTokenId;\n        uint256 collateralizationRate;\n    }\n\n    struct SingularityInfo {\n        MarketInfo market;\n        Rebase totalAsset;\n        uint256 userAssetFraction;\n        ISingularity.AccrueInfo accrueInfo;\n        uint256 utilization;\n        uint256 minimumTargetUtilization;\n        uint256 maximumTargetUtilization;\n        uint256 minimumInterestPerSecond;\n        uint256 maximumInterestPerSecond;\n        uint256 interestElasticity;\n        uint256 startingInterestPerSecond;\n    }\n\n    struct BigBangInfo {\n        MarketInfo market;\n        IBigBang.AccrueInfo accrueInfo;\n        uint256 minDebtRate;\n        uint256 maxDebtRate;\n        uint256 debtRateAgainstEthMarket;\n        address mainBBMarket;\n        uint256 mainBBDebtRate;\n        uint256 currentDebtRate;\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n    /**\n     * @notice returns Singularity markets' information.\n     * @param who user to return for.\n     * @param markets the list of Singularity markets to query for.\n     */\n    function singularityMarketInfo(address who, ISingularity[] calldata markets)\n        external\n        view\n        returns (SingularityInfo[] memory)\n    {\n        return _singularityMarketInfo(who, markets);\n    }\n\n    /**\n     * @notice returns BigBang markets' information.\n     * @param who user to return for.\n     * @param markets the list of BigBang markets to query for.\n     */\n    function bigBangMarketInfo(address who, IBigBang[] calldata markets) external view returns (BigBangInfo[] memory) {\n        return _bigBangMarketInfo(who, markets);\n    }\n\n    /**\n     * @notice Calculate the collateral amount off the shares.\n     * @param market the Singularity or BigBang address.\n     * @param share The shares.\n     * @return amount The amount.\n     */\n    function getCollateralAmountForShare(IMarket market, uint256 share) external view returns (uint256 amount) {\n        IYieldBox yieldBox = IYieldBox(market.yieldBox());\n        return yieldBox.toAmount(market.collateralId(), share, false);\n    }\n\n    /**\n     * @notice Calculate the collateral shares that are needed for `borrowPart,\n     *       taking the current exchange rate into account.\n     * @param market the Singularity or BigBang address\n     * @param borrowPart The borrow part.\n     * @return collateralShares The collateral shares.\n     */\n    function getCollateralSharesForBorrowPart(\n        IMarket market,\n        uint256 borrowPart,\n        uint256 collateralizationRatePrecision,\n        uint256 exchangeRatePrecision\n    ) external view returns (uint256 collateralShares) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market.totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        IYieldBox yieldBox = IYieldBox(market.yieldBox());\n        uint256 borrowAmount = _totalBorrowed.toElastic(borrowPart, false);\n\n        uint256 val = (borrowAmount * collateralizationRatePrecision * market.exchangeRate())\n            / (market.collateralizationRate() * exchangeRatePrecision);\n        return yieldBox.toShare(market.collateralId(), val, false);\n    }\n\n    /**\n     * @notice Return the equivalent of borrow part in asset amount.\n     * @param market the Singularity or BigBang address.\n     * @param borrowPart The amount of borrow part to convert.\n     * @return amount The equivalent of borrow part in asset amount.\n     */\n    function getAmountForBorrowPart(IMarket market, uint256 borrowPart) external view returns (uint256 amount) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market.totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        return _totalBorrowed.toElastic(borrowPart, false);\n    }\n\n    /**\n     * @notice Return the equivalent of amount in borrow part.\n     * @param market the Singularity or BigBang address.\n     * @param amount The amount to convert.\n     * @return part The equivalent of amount in borrow part.\n     */\n    function getBorrowPartForAmount(IMarket market, uint256 amount) external view returns (uint256 part) {\n        Rebase memory _totalBorrowed;\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market.totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n\n        return _totalBorrowed.toBase(amount, false);\n    }\n\n    /**\n     * @notice Compute the amount of `singularity.assetId` from `fraction`\n     *       `fraction` can be `singularity.accrueInfo.feeFraction` or `singularity.balanceOf`.\n     * @param singularity the singularity address.\n     * @param fraction The fraction.\n     * @return amount The amount.\n     */\n    function getAmountForAssetFraction(ISingularity singularity, uint256 fraction)\n        external\n        view\n        returns (uint256 amount)\n    {\n        (uint128 totalAssetElastic, uint128 totalAssetBase) = singularity.totalAsset();\n        (uint128 totalBorrowElastic,) = singularity.totalBorrow();\n\n        IYieldBox yieldBox = IYieldBox(singularity.yieldBox());\n\n        uint256 allShare = totalAssetElastic + yieldBox.toShare(singularity.assetId(), totalBorrowElastic, true);\n\n        return yieldBox.toAmount(singularity.assetId(), (fraction * allShare) / totalAssetBase, false);\n    }\n\n    /**\n     * @notice Compute the fraction of `singularity.assetId` from `amount`\n     *       `fraction` can be `singularity.accrueInfo.feeFraction` or `singularity.balanceOf`.\n     * @param singularity the singularity address.\n     * @param amount The amount.\n     * @return fraction The fraction.\n     */\n    function getFractionForAmount(ISingularity singularity, uint256 amount) external view returns (uint256 fraction) {\n        (uint128 totalAssetShare, uint128 totalAssetBase) = singularity.totalAsset();\n        (uint128 totalBorrowElastic,) = singularity.totalBorrow();\n        uint256 assetId = singularity.assetId();\n\n        IYieldBox yieldBox = IYieldBox(singularity.yieldBox());\n\n        uint256 share = yieldBox.toShare(assetId, amount, false);\n        uint256 allShare = totalAssetShare + yieldBox.toShare(assetId, totalBorrowElastic, true);\n\n        fraction = allShare == 0 ? share : (share * totalAssetBase) / allShare;\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n\n    function _singularityMarketInfo(address who, ISingularity[] memory markets)\n        private\n        view\n        returns (SingularityInfo[] memory)\n    {\n        uint256 len = markets.length;\n        SingularityInfo[] memory result = new SingularityInfo[](len);\n\n        Rebase memory _totalAsset;\n        for (uint256 i; i < len; i++) {\n            ISingularity sgl = markets[i];\n\n            result[i].market = _commonInfo(who, IMarket(address(sgl)));\n\n            (uint128 totalAssetElastic, uint128 totalAssetBase) = sgl //\n                .totalAsset();\n            //\n            _totalAsset = Rebase(totalAssetElastic, totalAssetBase);\n            //\n            result[i].totalAsset = _totalAsset;\n            //\n            result[i].userAssetFraction = sgl.balanceOf(who);\n            //\n            (ISingularity.AccrueInfo memory _accrueInfo, uint256 _utilization) = sgl.getInterestDetails();\n\n            result[i].accrueInfo = _accrueInfo;\n            result[i].utilization = _utilization;\n            result[i].minimumTargetUtilization = sgl.minimumTargetUtilization();\n            result[i].maximumTargetUtilization = sgl.maximumTargetUtilization();\n            result[i].minimumInterestPerSecond = sgl.minimumInterestPerSecond();\n            result[i].maximumInterestPerSecond = sgl.maximumInterestPerSecond();\n            result[i].interestElasticity = sgl.interestElasticity();\n            result[i].startingInterestPerSecond = sgl.startingInterestPerSecond();\n        }\n\n        return result;\n    }\n\n    function _bigBangMarketInfo(address who, IBigBang[] memory markets) private view returns (BigBangInfo[] memory) {\n        uint256 len = markets.length;\n        BigBangInfo[] memory result = new BigBangInfo[](len);\n\n        IBigBang.AccrueInfo memory _accrueInfo;\n        for (uint256 i; i < len; i++) {\n            IBigBang bigBang = markets[i];\n            result[i].market = _commonInfo(who, IMarket(address(bigBang)));\n\n            (uint64 debtRate, uint64 lastAccrued) = bigBang.accrueInfo();\n            _accrueInfo = IBigBang.AccrueInfo(debtRate, lastAccrued);\n            result[i].accrueInfo = _accrueInfo;\n            result[i].minDebtRate = bigBang.minDebtRate();\n            result[i].maxDebtRate = bigBang.maxDebtRate();\n            result[i].debtRateAgainstEthMarket = bigBang.debtRateAgainstEthMarket();\n            result[i].currentDebtRate = bigBang.getDebtRate();\n\n            IPenrose penrose = IPenrose(bigBang.penrose());\n            result[i].mainBBMarket = penrose.bigBangEthMarket();\n            result[i].mainBBDebtRate = penrose.bigBangEthDebtRate();\n        }\n\n        return result;\n    }\n\n    function _commonInfo(address who, IMarket market) private view returns (MarketInfo memory) {\n        Rebase memory _totalBorrowed;\n        MarketInfo memory info;\n\n        info.collateral = market.collateral();\n        info.asset = market.asset();\n        info.oracle = ITapiocaOracle(market.oracle());\n        info.oracleData = market.oracleData();\n        info.totalCollateralShare = market.totalCollateralShare();\n        info.userCollateralShare = market.userCollateralShare(who);\n\n        (uint128 totalBorrowElastic, uint128 totalBorrowBase) = market.totalBorrow();\n        _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\n        info.totalBorrow = _totalBorrowed;\n        info.userBorrowPart = market.userBorrowPart(who);\n\n        info.currentExchangeRate = market.exchangeRate();\n        (, info.oracleExchangeRate) = ITapiocaOracle(market.oracle()).peek(market.oracleData());\n        info.spotExchangeRate = ITapiocaOracle(market.oracle()).peekSpot(market.oracleData());\n        info.totalBorrowCap = market.totalBorrowCap();\n        info.assetId = market.assetId();\n        info.collateralId = market.collateralId();\n        info.collateralizationRate = market.collateralizationRate();\n\n        IYieldBox yieldBox = IYieldBox(market.yieldBox());\n\n        (info.totalYieldBoxCollateralShare, info.totalYieldBoxCollateralAmount) =\n            yieldBox.assetTotals(info.collateralId);\n        (info.totalYieldBoxAssetShare, info.totalYieldBoxAssetAmount) = yieldBox.assetTotals(info.assetId);\n\n        (\n            info.yieldBoxCollateralTokenType,\n            info.yieldBoxCollateralContractAddress,\n            info.yieldBoxCollateralStrategyAddress,\n            info.yieldBoxCollateralTokenId\n        ) = yieldBox.assets(info.collateralId);\n        (\n            info.yieldBoxAssetTokenType,\n            info.yieldBoxAssetContractAddress,\n            info.yieldBoxAssetStrategyAddress,\n            info.yieldBoxAssetTokenId\n        ) = yieldBox.assets(info.assetId);\n\n        return info;\n    }\n}"
    },
    {
      "filename": "contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {ISingularity, IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {SGLStorage} from \"./SGLStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error TooMuch();\n    error MinLimit();\n    error TransferFailed();\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (ISingularity.AccrueInfo memory _accrueInfo, uint256 utilization)\n    {\n        (_accrueInfo,,,,, utilization,) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        )\n    {\n        _accrueInfo = accrueInfo;\n        _totalBorrow = totalBorrow;\n        _totalAsset = totalAsset;\n        extraAmount = 0;\n        feeFraction = 0;\n        logStartingInterest = false;\n\n        uint256 fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return (_accrueInfo, totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        if (_totalBorrow.base == 0) {\n            // If there are no borrows, reset the interest rate\n            if (_accrueInfo.interestPerSecond != startingInterestPerSecond) {\n                _accrueInfo.interestPerSecond = startingInterestPerSecond;\n                logStartingInterest = true;\n            }\n            return (_accrueInfo, _totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n\n        // Accrue interest\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.interestPerSecond * elapsedTime) / 1e18;\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        //take accrued values into account\n        fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / (fullAssetAmount - feeAmount);\n        _accrueInfo.feesEarnedFraction += feeFraction.toUint128();\n        _totalAsset.base = _totalAsset.base + feeFraction.toUint128();\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Update interest rate\n        if (utilization < minimumTargetUtilization) {\n            uint256 underFactor =\n                ((minimumTargetUtilization - utilization) * FACTOR_PRECISION) / minimumTargetUtilization;\n            uint256 scale = interestElasticity + (underFactor * underFactor * elapsedTime);\n            _accrueInfo.interestPerSecond =\n                ((uint256(_accrueInfo.interestPerSecond) * interestElasticity) / scale).toUint64();\n            if (_accrueInfo.interestPerSecond < minimumInterestPerSecond) {\n                _accrueInfo.interestPerSecond = minimumInterestPerSecond; // 0.25% APR minimum\n            }\n        } else if (utilization > maximumTargetUtilization) {\n            uint256 overFactor = ((utilization - maximumTargetUtilization) * FACTOR_PRECISION) / fullUtilizationMinusMax;\n            uint256 scale = interestElasticity + (overFactor * overFactor * elapsedTime);\n            uint256 newInterestPerSecond = (uint256(_accrueInfo.interestPerSecond) * scale) / interestElasticity;\n            if (newInterestPerSecond > maximumInterestPerSecond) {\n                newInterestPerSecond = maximumInterestPerSecond; // 1000% APR maximum\n            }\n            _accrueInfo.interestPerSecond = newInterestPerSecond.toUint64();\n        }\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        (, _totalBorrow,,,,,) = _getInterestRate();\n    }\n\n    function _accrue() internal override {\n        (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        ) = _getInterestRate();\n\n        if (logStartingInterest) {\n            emit LogAccrue(0, 0, startingInterestPerSecond, 0);\n        } else {\n            emit LogAccrue(extraAmount, feeFraction, _accrueInfo.interestPerSecond, utilization);\n        }\n        accrueInfo = _accrueInfo;\n        totalBorrow = _totalBorrow;\n        totalAsset = _totalAsset;\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, address, uint256 _assetId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            if (share > yieldBox.balanceOf(address(this), _assetId) - total) {\n                revert TooMuch();\n            }\n        } else {\n            // yieldBox.transfer(from, address(this), _assetId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _assetId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(address from, address to, bool skim, uint256 share) internal returns (uint256 fraction) {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 totalAssetShare = _totalAsset.elastic;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        fraction = allShare == 0 ? share : (share * _totalAsset.base) / allShare;\n        if (_totalAsset.base + fraction.toUint128() < 1000) {\n            return 0;\n        }\n        totalAsset = _totalAsset.add(share, fraction);\n\n        balanceOf[to] += fraction;\n        emit Transfer(address(0), to, fraction);\n\n        _addTokens(from, to, assetId, share, totalAssetShare, skim);\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n        share = (fraction * allShare) / _totalAsset.base;\n\n        _totalAsset.base -= fraction.toUint128();\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= share.toUint128();\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\n    function _getAmountForBorrowPart(uint256 borrowPart) internal view returns (uint256) {\n        return totalBorrow.toElastic(borrowPart, false);\n    }\n\n    function _isWhitelisted(uint16 _chainId, address _contract) internal view returns (bool) {\n        return ICluster(penrose.cluster()).isWhitelisted(_chainId, _contract);\n    }\n\n    struct _ViewLiquidationStruct {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        uint256 exchangeRate;\n        IYieldBox yieldBox;\n        uint256 collateralId;\n        uint256 userCollateralShare;\n        uint256 userBorrowPart;\n        Rebase totalBorrow;\n        uint256 liquidationBonusAmount;\n        uint256 liquidationCollateralizationRate;\n        uint256 liquidationMultiplier;\n        uint256 exchangeRatePrecision;\n        uint256 feeDecimalsPrecision;\n    }\n}"
    }
  ]
}