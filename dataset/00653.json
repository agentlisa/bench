{
  "Title": "Transferring tokens without tainting",
  "Content": "##### Description\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/LpToken.sol#L74\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/LpToken.sol#L81\n\nIf `_minimumTaintedTransferAmount` is large enough, then an attacker can do `deposit`/`withdraw` in a single transaction in small amounts.\n\nFor example:\n- A hacker makes a deposit into `ConicPool`.\n- Transfer several times with small amounts (less than `_minimumTaintedTransferAmount`) to another account.\n- The hacker invokes `withdraw` from the new account.\n\nThis attack is unlikely, but if `_minimumTaintedTransferAmount` is large, it is a possibility.\n\n##### Recommendation\nWe recommend adding a max limit to the `_minimumTaintedTransferAmount`.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/LpToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/pools/ILpToken.sol\";\n\ncontract LpToken is ILpToken, ERC20 {\n    IController public immutable controller;\n\n    address public immutable minter;\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"not authorized\");\n        _;\n    }\n\n    mapping(address => uint256) internal _lastEvent;\n\n    uint8 private __decimals;\n\n    constructor(\n        address _controller,\n        address _minter,\n        uint8 _decimals,\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {\n        controller = IController(_controller);\n        minter = _minter;\n        __decimals = _decimals;\n    }\n\n    function decimals() public view virtual override(ERC20, IERC20Metadata) returns (uint8) {\n        return __decimals;\n    }\n\n    function mint(\n        address _account,\n        uint256 _amount,\n        address ubo\n    ) external override onlyMinter returns (uint256) {\n        _ensureSingleEvent(ubo, _amount);\n        _mint(_account, _amount);\n        return _amount;\n    }\n\n    function burn(\n        address _owner,\n        uint256 _amount,\n        address ubo\n    ) external override onlyMinter returns (uint256) {\n        _ensureSingleEvent(ubo, _amount);\n        _burn(_owner, _amount);\n        return _amount;\n    }\n\n    function taint(address from, address to) external {\n        require(msg.sender == address(controller.lpTokenStaker()), \"not authorized\");\n        _taint(from, to);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        // mint/burn are handled in their respective functions\n        if (from == address(0) || to == address(0)) return;\n\n        // lpTokenStaker calls `taint` as needed\n        address lpTokenStaker = address(controller.lpTokenStaker());\n        if (from == lpTokenStaker || to == lpTokenStaker) return;\n\n        // taint any other type of transfer\n        if (amount > controller.getMinimumTaintedTransferAmount(address(this))) {\n            _taint(from, to);\n        }\n    }\n\n    function _ensureSingleEvent(address ubo, uint256 amount) internal {\n        if (\n            !controller.isAllowedMultipleDepositsWithdraws(ubo) &&\n            amount > controller.getMinimumTaintedTransferAmount(address(this))\n        ) {\n            require(_lastEvent[ubo] != block.number, \"cannot mint/burn twice in a block\");\n            _lastEvent[ubo] = block.number;\n        }\n    }\n\n    function _taint(address from, address to) internal {\n        if (from == to) return;\n        if (_lastEvent[from] == block.number) {\n            _lastEvent[to] = block.number;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/LpToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/pools/ILpToken.sol\";\n\ncontract LpToken is ILpToken, ERC20 {\n    IController public immutable controller;\n\n    address public immutable minter;\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"not authorized\");\n        _;\n    }\n\n    mapping(address => uint256) internal _lastEvent;\n\n    uint8 private __decimals;\n\n    constructor(\n        address _controller,\n        address _minter,\n        uint8 _decimals,\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {\n        controller = IController(_controller);\n        minter = _minter;\n        __decimals = _decimals;\n    }\n\n    function decimals() public view virtual override(ERC20, IERC20Metadata) returns (uint8) {\n        return __decimals;\n    }\n\n    function mint(\n        address _account,\n        uint256 _amount,\n        address ubo\n    ) external override onlyMinter returns (uint256) {\n        _ensureSingleEvent(ubo, _amount);\n        _mint(_account, _amount);\n        return _amount;\n    }\n\n    function burn(\n        address _owner,\n        uint256 _amount,\n        address ubo\n    ) external override onlyMinter returns (uint256) {\n        _ensureSingleEvent(ubo, _amount);\n        _burn(_owner, _amount);\n        return _amount;\n    }\n\n    function taint(address from, address to) external {\n        require(msg.sender == address(controller.lpTokenStaker()), \"not authorized\");\n        _taint(from, to);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        // mint/burn are handled in their respective functions\n        if (from == address(0) || to == address(0)) return;\n\n        // lpTokenStaker calls `taint` as needed\n        address lpTokenStaker = address(controller.lpTokenStaker());\n        if (from == lpTokenStaker || to == lpTokenStaker) return;\n\n        // taint any other type of transfer\n        if (amount > controller.getMinimumTaintedTransferAmount(address(this))) {\n            _taint(from, to);\n        }\n    }\n\n    function _ensureSingleEvent(address ubo, uint256 amount) internal {\n        if (\n            !controller.isAllowedMultipleDepositsWithdraws(ubo) &&\n            amount > controller.getMinimumTaintedTransferAmount(address(this))\n        ) {\n            require(_lastEvent[ubo] != block.number, \"cannot mint/burn twice in a block\");\n            _lastEvent[ubo] = block.number;\n        }\n    }\n\n    function _taint(address from, address to) internal {\n        if (from == to) return;\n        if (_lastEvent[from] == block.number) {\n            _lastEvent[to] = block.number;\n        }\n    }\n}"
    }
  ]
}