{
  "Title": "[M-07] ETH will get stuck if all NFTs do not get sold.",
  "Content": "\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/FixedPrice.sol#L73>\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L81-L88>\n\n### Impact\n\nIn the `buy` function of FixedPrice and LPDA contracts, the transfer of funds to `saleReceiver` only happens when `newId` becomes equal to `finalId`, i.e, when the entire batch of NFTs gets sold completely.\n\nFixedPrice:\n\n```solidity\n        if (newId == sale_.finalId) _end(sale);\n```\n\nLPDA:\n\n```solidity\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n```\n\nThis logic can cause issues if only a subset of NFTs get sold. In that case the ETH collected by contract from the sales of NFTs will get stuck inside the contract.\n\nThere is no function inside those contracts to recover the ETH collected from the partial sale of the NFT batch. There is also no function to send back those ETH to the NFT buyers. This causes the ETH to be in a stuck state as they cannot be pulled from the contracts.\n\nThe only way to recover those ETH is to explicitly buy the entire batch of to-be-sold NFTs so that the contract automatically triggers the sale ending conditions. This recovery method may require a decent amount of upfront capital to buy all unsold NFTs.\n\n### Proof of Concept\n\nConsider this scenario:\n\n*   The sale contract deployer deploys a sale contract (FixedSale) to sell 100 NFTs ranging from id 1 to 100 with price 1 ETH per NFT.\n*   Users only buy the initial 10 NFTs. So the sale contract now has 10 ETH and currently 90 NFTs are unsold.\n*   No more users buy anymore NFTs from the sale contract.\n*   The 10 ETH are in stuck state as the `saleReceiver` cannot pull them out even though some NFTs have been already legitimately sold.\n*   To recover those 10 ETH, the contract deployer or `saleReceiver` has to come up with 90 ETH and buy the unsold 90 NFTs.\n\nThe scenario for the LPDA sale contract is similar. ETH can get stuck for partial batch NFT sales and upfront capital will be needed to recover the ETH.\n\n### Recommended Mitigation Steps\n\nThe contracts can have an additional function to claim the ETH collected from already successful NFT sales.\n\n```solidity\n    function claim() external onlyOwner {\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        sale.saleReceiver.transfer(address(this).balance);\n    }\n```\n\nPlease note, use of `transfer` is not recommended. The above code is just an example mitigation.\n\n**[mehtaculous (Escher) disagreed with severity and commented](https://github.com/code-423n4/2022-12-escher-findings/issues/328#issuecomment-1363168073):**\n > The creator could simply buy the remaining IDs and then receive their ETH in the same transaction, effectively unsticking the sale. Not considered High priority, but do agree there should be a better cancellation pattern for when all the NFTs do not get sold.\n\n**[berndartmueller (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-escher-findings/issues/328#issuecomment-1369186138):**\n > The demonstrated finding has an external requirement (too many token ids, low buy pressure,...), and there exists the possibility for the creator to buy the remaining, unsold IDs (which may or may not be expensive). Therefore, I am downgrading the finding to Medium severity.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "src/minters/FixedPrice.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}"
    },
    {
      "filename": "src/minters/LPDA.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}"
    }
  ]
}