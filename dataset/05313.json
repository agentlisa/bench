{
  "Title": "[G-02]  Pre-calculate equations which contain only constant values in constructor",
  "Content": "For equations, calcuations and computations that only involve constants or immutable values they could be calculated in the contract's constructor and saved to an immutable variable. Using the immutable variable would be cheaper than performing the calculation every time the function is called.\n\n### 3 Instances\n\n1. ### Save `toKeycode(\"STORE\")` computation to an Immutable variable\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L48-#L49\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L73\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L77\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L80-#L81\n\n\nThe free function `toKeycode()` converts a `bytes5` value into a `Keycode` type and returns the `Keycode` value. Calling `toKeycode()` on a constant `bytes5` value would always return the same `Keycode` value therefore calling `toKeycode(\"STORE\")` would always result in the same value. So  having to call `toKeycode(\"STORE\")` multiple times in the `configureDependencies()` and `requestPermissions()` functions isn't gas efficient rather we should make the call in the constructor then save the returned value to an immutable variable then the immutable variable be used in place of `toKeycode(\"STORE\")` in functions that invokes it. The diff below shows howthe code should be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Admin.sol\n\n40:    function configureDependencies()\n41:        external\n42:        override\n43:        onlyKernel\n44:        returns (Keycode[] memory dependencies)\n45:    {\n46:        dependencies = new Keycode[](2);\n47:\n48:        dependencies[0] = toKeycode(\"STORE\");  //@audit toKeycode(\"STORE\")\n49:        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));  //@audit toKeycode(\"STORE\")\n50:\n51:        dependencies[1] = toKeycode(\"ESCRW\");\n52:        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n53:    }\n.\n.\n.\n64:    function requestPermissions()\n65:        external\n66:        view\n67:        override\n68:        onlyKernel\n69:        returns (Permissions[] memory requests)\n70:    {\n71:        requests = new Permissions[](8);\n72:        requests[0] = Permissions(\n73:            toKeycode(\"STORE\"),  //@audit toKeycode(\"STORE\")\n74:            STORE.toggleWhitelistExtension.selector\n75:        );\n76:        requests[1] = Permissions(\n77:            toKeycode(\"STORE\"),  //@audit toKeycode(\"STORE\")\n78:            STORE.toggleWhitelistDelegate.selector\n79:        );\n80:        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);  //@audit toKeycode(\"STORE\")\n81:        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);  //@audit toKeycode(\"STORE\")\n82:\n83:        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n84:        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n85:        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n86:        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n87:    }\n```\n```diff\ndiff --git a/src/policies/Admin.sol b/src/policies/Admin.sol                                \nindex b37d47f..d19a99c 100644                                                               \n--- a/src/policies/Admin.sol                                                                \n+++ b/src/policies/Admin.sol                                                                \n@@ -20,13 +20,16 @@ contract Admin is Policy {                                              \n     // Modules that the policy depends on.                                                 \n     Storage public STORE;                                                                  \n     PaymentEscrow public ESCRW;                                                            \n+    Keycode immutable storeKeycode;                                                        \n                                                                                            \n     /**                                                                                    \n      * @dev Instantiate this contract as a policy.                                         \n      *                                                                                     \n      * @param kernel_ Address of the kernel contract.                                      \n      */                                                                                    \n-    constructor(Kernel kernel_) Policy(kernel_) {}                                         \n+    constructor(Kernel kernel_) Policy(kernel_) {                                          \n+        storeKeycode = toKeycode(\"STORE\");                                                 \n+    }                                                                                      \n                                                                                            \n     /**                                                                                    \n      * @notice Upon policy activation, configures the modules that the policy depends on.  \n@@ -45,8 +48,8 @@ contract Admin is Policy {                                                \n     {                                                                                      \n         dependencies = new Keycode[](2);                                                   \n                                                                                            \n-        dependencies[0] = toKeycode(\"STORE\");                                              \n-        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));                             \n+        dependencies[0] = storeKeycode;                                                    \n+        STORE = Storage(getModuleAddress(storeKeycode));                                   \n                                                                                            \n         dependencies[1] = toKeycode(\"ESCRW\");                                              \n         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));                       \n@@ -70,15 +73,15 @@ contract Admin is Policy {                                              \n     {                                                                                      \n         requests = new Permissions[](8);                                                   \n         requests[0] = Permissions(                                                         \n-            toKeycode(\"STORE\"),                                                            \n+            storeKeycode,                                                                  \n             STORE.toggleWhitelistExtension.selector                                        \n         );                                                                                 \n         requests[1] = Permissions(                                                         \n-            toKeycode(\"STORE\"),                                                            \n+            storeKeycode,\n             STORE.toggleWhitelistDelegate.selector\n         );\n-        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n-        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n+        requests[2] = Permissions(storeKeycode, STORE.upgrade.selector);\n+        requests[3] = Permissions(storeKeycode, STORE.freeze.selector);\n\n         requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n         requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n```\n\n</details>\n\n### Apply the same changes to these Instances in the `Create`, `Factory`, `Guard` and `Stop` Contracts.\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L80-#L81\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L104\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L81-#L82\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L102\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L71-#L72\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L92-#L93\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L71-#L72\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L95-#L96\n\n2. ### Save `toKeycode(\"ESCRW\")` computation to an Immutable variable\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L51-#L52\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L83-#L86\n\nThe free function `toKeycode()` converts a `bytes5` value into a `Keycode` type and returns the `Keycode` value. Calling `toKeycode()` on a constant `bytes5` value would always return the same `Keycode` value therefore calling `toKeycode(\"ESCRW\")` would always result in the same value. So  having to call `toKeycode(\"ESCRW\")` multiple times in the `configureDependencies()` and `requestPermissions()` functions isn't gas efficient rather we should make the call in the constructor then save the returned value to an immutable variable then the immutable variable be used in place of `toKeycode(\"ESCRW\")` in functions that invokes it. The diff below shows howthe code should be refactored:\n\n<Details>\n\n```solidity\nfile: src/policies/Admin.sol\n\n40:    function configureDependencies()\n41:        external\n42:        override\n43:        onlyKernel\n44:        returns (Keycode[] memory dependencies)\n45:    {\n46:        dependencies = new Keycode[](2);\n47:\n48:        dependencies[0] = toKeycode(\"STORE\");  \n49:        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n50:\n51:        dependencies[1] = toKeycode(\"ESCRW\");    //@audit toKeycode(\"ESCRW\")\n52:        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\"))); //@audit toKeycode(\"ESCRW\")\n53:    }\n.\n.\n.\n64:    function requestPermissions()\n65:        external\n66:        view\n67:        override\n68:        onlyKernel\n69:        returns (Permissions[] memory requests)\n70:    {\n71:        requests = new Permissions[](8);\n72:        requests[0] = Permissions(\n73:            toKeycode(\"STORE\"),\n74:            STORE.toggleWhitelistExtension.selector\n75:        );\n76:        requests[1] = Permissions(\n77:            toKeycode(\"STORE\"),\n78:            STORE.toggleWhitelistDelegate.selector\n79:        );\n80:        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n81:        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n82:\n83:        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);  //@audit toKeycode(\"ESCRW\")\n84:        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);  //@audit toKeycode(\"ESCRW\")\n85:        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);  //@audit toKeycode(\"ESCRW\")\n86:        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);  //@audit toKeycode(\"ESCRW\")\n87:    }\n```\n```diff\ndiff --git a/src/policies/Admin.sol b/src/policies/Admin.sol\nindex b37d47f..d2ae37b 100644\n--- a/src/policies/Admin.sol\n+++ b/src/policies/Admin.sol\n@@ -20,13 +20,15 @@ contract Admin is Policy {\n     // Modules that the policy depends on.\n     Storage public STORE;\n     PaymentEscrow public ESCRW;\n-\n+    Keycode immutable escrwKeycode;\n     /**\n      * @dev Instantiate this contract as a policy.\n      *\n      * @param kernel_ Address of the kernel contract.\n      */\n-    constructor(Kernel kernel_) Policy(kernel_) {}\n+    constructor(Kernel kernel_) Policy(kernel_) {\n+        escrwKeycode = toKeycode(\"ESCRW\");\n+    }\n\n     /**\n      * @notice Upon policy activation, configures the modules that the policy depends on.\n@@ -48,8 +50,8 @@ contract Admin is Policy {\n         dependencies[0] = toKeycode(\"STORE\");\n         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n-        dependencies[1] = toKeycode(\"ESCRW\");\n-        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n+        dependencies[1] = escrwKeycode;\n+        ESCRW = PaymentEscrow(getModuleAddress(escrwKeycode));\n     }\n\n     /**\n@@ -80,10 +82,10 @@ contract Admin is Policy {\n         requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n         requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n\n-        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n-        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n-        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n-        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n+        requests[4] = Permissions(escrwKeycode, ESCRW.skim.selector);\n+        requests[5] = Permissions(escrwKeycode, ESCRW.setFee.selector);\n+        requests[6] = Permissions(escrwKeycode, ESCRW.upgrade.selector);\n+        requests[7] = Permissions(escrwKeycode, ESCRW.freeze.selector);\n     }\n```\n</details>\n\n### Apply the same changes to these Instances in the `Create` and `Stop` Contracts.\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L83-#L84\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L105\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L74-#L75\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L97-#L98\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/policies/Admin.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n\n/**\n * @title Admin\n * @notice Acts as an interface for all behavior in the protocol related\n *         admin logic. Admin duties include fee management, proxy management,\n *         and whitelist management.\n */\ncontract Admin is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](8);\n        requests[0] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistExtension.selector\n        );\n        requests[1] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistDelegate.selector\n        );\n        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n\n        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Toggle whether an address can be delegate called by a rental safe.\n     *\n     * @param delegate  Target address for the delegate call.\n     * @param isEnabled Whether the address can be delegate called.\n     */\n    function toggleWhitelistDelegate(\n        address delegate,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistDelegate(delegate, isEnabled);\n    }\n\n    /**\n     * @notice Toggle whether an extension is whitelisted. An extension is any contract\n     *         which can be added to a rental safe as a Safe module.\n     *\n     * @param extension Extension which can be added to a safe.\n     * @param isEnabled Whether the extension is enabled.\n     */\n    function toggleWhitelistExtension(\n        address extension,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistExtension(extension, isEnabled);\n    }\n\n    /**\n     * @notice Upgrades the storage module to a newer implementation. The new\n     *         implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the storage module so that no proxy upgrades can take place. This\n     *         action is non-reversible.\n     */\n    function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.freeze();\n    }\n\n    /**\n     * @notice Upgrades the payment escrow module to a newer implementation.\n     *         The new implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradePaymentEscrow(\n        address newImplementation\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the payment escrow module so that no proxy upgrades can take\n     *         place. This action is non-reversible.\n     */\n    function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.freeze();\n    }\n\n    /**\n     * @notice Skims all protocol fees from the escrow module to the target address.\n     *\n     * @param token Token address which denominates the fee.\n     * @param to    Destination address to send the tokens.\n     */\n    function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.skim(token, to);\n    }\n\n    /**\n     * @notice Sets the protocol fee numerator. Numerator cannot be greater than 10,000.\n     *\n     * @param feeNumerator Numerator for the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.setFee(feeNumerator);\n    }\n}"
    },
    {
      "filename": "src/policies/Admin.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n\n/**\n * @title Admin\n * @notice Acts as an interface for all behavior in the protocol related\n *         admin logic. Admin duties include fee management, proxy management,\n *         and whitelist management.\n */\ncontract Admin is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](8);\n        requests[0] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistExtension.selector\n        );\n        requests[1] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistDelegate.selector\n        );\n        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n\n        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Toggle whether an address can be delegate called by a rental safe.\n     *\n     * @param delegate  Target address for the delegate call.\n     * @param isEnabled Whether the address can be delegate called.\n     */\n    function toggleWhitelistDelegate(\n        address delegate,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistDelegate(delegate, isEnabled);\n    }\n\n    /**\n     * @notice Toggle whether an extension is whitelisted. An extension is any contract\n     *         which can be added to a rental safe as a Safe module.\n     *\n     * @param extension Extension which can be added to a safe.\n     * @param isEnabled Whether the extension is enabled.\n     */\n    function toggleWhitelistExtension(\n        address extension,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistExtension(extension, isEnabled);\n    }\n\n    /**\n     * @notice Upgrades the storage module to a newer implementation. The new\n     *         implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the storage module so that no proxy upgrades can take place. This\n     *         action is non-reversible.\n     */\n    function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.freeze();\n    }\n\n    /**\n     * @notice Upgrades the payment escrow module to a newer implementation.\n     *         The new implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradePaymentEscrow(\n        address newImplementation\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the payment escrow module so that no proxy upgrades can take\n     *         place. This action is non-reversible.\n     */\n    function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.freeze();\n    }\n\n    /**\n     * @notice Skims all protocol fees from the escrow module to the target address.\n     *\n     * @param token Token address which denominates the fee.\n     * @param to    Destination address to send the tokens.\n     */\n    function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.skim(token, to);\n    }\n\n    /**\n     * @notice Sets the protocol fee numerator. Numerator cannot be greater than 10,000.\n     *\n     * @param feeNumerator Numerator for the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.setFee(feeNumerator);\n    }\n}"
    },
    {
      "filename": "src/policies/Admin.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n\n/**\n * @title Admin\n * @notice Acts as an interface for all behavior in the protocol related\n *         admin logic. Admin duties include fee management, proxy management,\n *         and whitelist management.\n */\ncontract Admin is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](8);\n        requests[0] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistExtension.selector\n        );\n        requests[1] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistDelegate.selector\n        );\n        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n\n        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Toggle whether an address can be delegate called by a rental safe.\n     *\n     * @param delegate  Target address for the delegate call.\n     * @param isEnabled Whether the address can be delegate called.\n     */\n    function toggleWhitelistDelegate(\n        address delegate,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistDelegate(delegate, isEnabled);\n    }\n\n    /**\n     * @notice Toggle whether an extension is whitelisted. An extension is any contract\n     *         which can be added to a rental safe as a Safe module.\n     *\n     * @param extension Extension which can be added to a safe.\n     * @param isEnabled Whether the extension is enabled.\n     */\n    function toggleWhitelistExtension(\n        address extension,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistExtension(extension, isEnabled);\n    }\n\n    /**\n     * @notice Upgrades the storage module to a newer implementation. The new\n     *         implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the storage module so that no proxy upgrades can take place. This\n     *         action is non-reversible.\n     */\n    function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.freeze();\n    }\n\n    /**\n     * @notice Upgrades the payment escrow module to a newer implementation.\n     *         The new implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradePaymentEscrow(\n        address newImplementation\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the payment escrow module so that no proxy upgrades can take\n     *         place. This action is non-reversible.\n     */\n    function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.freeze();\n    }\n\n    /**\n     * @notice Skims all protocol fees from the escrow module to the target address.\n     *\n     * @param token Token address which denominates the fee.\n     * @param to    Destination address to send the tokens.\n     */\n    function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.skim(token, to);\n    }\n\n    /**\n     * @notice Sets the protocol fee numerator. Numerator cannot be greater than 10,000.\n     *\n     * @param feeNumerator Numerator for the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.setFee(feeNumerator);\n    }\n}"
    },
    {
      "filename": "src/policies/Admin.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n\n/**\n * @title Admin\n * @notice Acts as an interface for all behavior in the protocol related\n *         admin logic. Admin duties include fee management, proxy management,\n *         and whitelist management.\n */\ncontract Admin is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](8);\n        requests[0] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistExtension.selector\n        );\n        requests[1] = Permissions(\n            toKeycode(\"STORE\"),\n            STORE.toggleWhitelistDelegate.selector\n        );\n        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n\n        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            External Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Toggle whether an address can be delegate called by a rental safe.\n     *\n     * @param delegate  Target address for the delegate call.\n     * @param isEnabled Whether the address can be delegate called.\n     */\n    function toggleWhitelistDelegate(\n        address delegate,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistDelegate(delegate, isEnabled);\n    }\n\n    /**\n     * @notice Toggle whether an extension is whitelisted. An extension is any contract\n     *         which can be added to a rental safe as a Safe module.\n     *\n     * @param extension Extension which can be added to a safe.\n     * @param isEnabled Whether the extension is enabled.\n     */\n    function toggleWhitelistExtension(\n        address extension,\n        bool isEnabled\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.toggleWhitelistExtension(extension, isEnabled);\n    }\n\n    /**\n     * @notice Upgrades the storage module to a newer implementation. The new\n     *         implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradeStorage(address newImplementation) external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the storage module so that no proxy upgrades can take place. This\n     *         action is non-reversible.\n     */\n    function freezeStorage() external onlyRole(\"ADMIN_ADMIN\") {\n        STORE.freeze();\n    }\n\n    /**\n     * @notice Upgrades the payment escrow module to a newer implementation.\n     *         The new implementation contract must adhere to ERC-1822.\n     *\n     * @param newImplementation Address of the new implemention.\n     */\n    function upgradePaymentEscrow(\n        address newImplementation\n    ) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.upgrade(newImplementation);\n    }\n\n    /**\n     * @notice Freezes the payment escrow module so that no proxy upgrades can take\n     *         place. This action is non-reversible.\n     */\n    function freezePaymentEscrow() external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.freeze();\n    }\n\n    /**\n     * @notice Skims all protocol fees from the escrow module to the target address.\n     *\n     * @param token Token address which denominates the fee.\n     * @param to    Destination address to send the tokens.\n     */\n    function skim(address token, address to) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.skim(token, to);\n    }\n\n    /**\n     * @notice Sets the protocol fee numerator. Numerator cannot be greater than 10,000.\n     *\n     * @param feeNumerator Numerator for the fee.\n     */\n    function setFee(uint256 feeNumerator) external onlyRole(\"ADMIN_ADMIN\") {\n        ESCRW.setFee(feeNumerator);\n    }\n}"
    },
    {
      "filename": "src/policies/Create.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {ZoneParameters} from \"@seaport-core/lib/rental/ConsiderationStructs.sol\";\nimport {ReceivedItem, SpentItem} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {ZoneInterface} from \"@src/interfaces/IZone.sol\";\n\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode, toRole} from \"@src/libraries/KernelUtils.sol\";\nimport {RentalUtils} from \"@src/libraries/RentalUtils.sol\";\nimport {Signer} from \"@src/packages/Signer.sol\";\nimport {Zone} from \"@src/packages/Zone.sol\";\nimport {Accumulator} from \"@src/packages/Accumulator.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {\n    RentalOrder,\n    RentPayload,\n    SeaportPayload,\n    Hook,\n    OrderFulfillment,\n    OrderMetadata,\n    OrderType,\n    Item,\n    ItemType,\n    SettleTo,\n    RentalId,\n    RentalAssetUpdate\n} from \"@src/libraries/RentalStructs.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {Events} from \"@src/libraries/Events.sol\";\n\n/**\n * @title Create\n * @notice Acts as an interface for all behavior related to creating a rental.\n */\ncontract Create is Policy, Signer, Zone, Accumulator {\n    using RentalUtils for Item;\n    using RentalUtils for Item[];\n    using RentalUtils for SpentItem;\n    using RentalUtils for ReceivedItem;\n    using RentalUtils for OrderType;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n    PaymentEscrow public ESCRW;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) Signer() Zone() {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](2);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n        dependencies[1] = toKeycode(\"ESCRW\");\n        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.addRentals.selector);\n        requests[1] = Permissions(toKeycode(\"ESCRW\"), ESCRW.increaseDeposit.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                              View Functions                                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Retrieves the domain separator.\n     *\n     * @return The domain separator for the protocol.\n     */\n    function domainSeparator() external view returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    /**\n     * @notice Derives the rental order EIP-712 compliant hash from a `RentalOrder`.\n     *\n     * @param order Rental order converted to a hash.\n     */\n    function getRentalOrderHash(\n        RentalOrder memory order\n    ) external view returns (bytes32) {\n        return _deriveRentalOrderHash(order);\n    }\n\n    /**\n     * @notice Derives the rent payload EIP-712 compliant hash from a `RentPayload`.\n     *\n     * @param payload Rent payload converted to a hash.\n     */\n    function getRentPayloadHash(\n        RentPayload memory payload\n    ) external view returns (bytes32) {\n        return _deriveRentPayloadHash(payload);\n    }\n\n    /**\n     * @notice Derives the order metadata EIP-712 compliant hash from an `OrderMetadata`.\n     *\n     * @param metadata Order metadata converted to a hash.\n     */\n    function getOrderMetadataHash(\n        OrderMetadata memory metadata\n    ) external view returns (bytes32) {\n        return _deriveOrderMetadataHash(metadata);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Helper function to emit an event which signals a rental order has started.\n     *\n     * @param order     Rental order to emit.\n     * @param orderHash Order hash of the seaport order.\n     * @param extraData Any extra data to be emitted which was supplied by the offerer.\n     */\n    function _emitRentalOrderStarted(\n        RentalOrder memory order,\n        bytes32 orderHash,\n        bytes memory extraData\n    ) internal {\n        // Emit the event.\n        emit Events.RentalOrderStarted(\n            orderHash,\n            extraData,\n            order.seaportOrderHash,\n            order.items,\n            order.hooks,\n            order.orderType,\n            order.lender,\n            order.renter,\n            order.rentalWallet,\n            order.startTimestamp,\n            order.endTimestamp\n        );\n    }\n\n    /**\n     * @dev Processes the offer items for inclusion in a BASE order. All offer items must\n     *      adhere to the BASE order format, else execution will revert.\n     *\n     * @param rentalItems Running array of items that comprise the rental order.\n     * @param offers      Array of offer items to include in the the order.\n     * @param startIndex  Index to begin adding the offer items to the\n     *                    `rentalItems` array.\n     */\n    function _pro"
    }
  ]
}