{
  "Title": "No validation of the address parameter value in function before using this parameter in access modifiers",
  "Content": "##### Description\nIt is possible that parameter value will be equal to zero. Then the work of the smart contract will be blocked.\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingRegistry.sol#L33 for the `_wrapped` variable in the`setWrappedToProtocol()` function.\n\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingRegistry.sol#L43 for the variable `_underlying` in the`setWrappedToUnderlying ()` function.\n\nAt the linehttps://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingRegistry.sol#L53 for the `_logic` variable in the`setProtocolToLogic()` function.\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingRegistry.sol#L64 for the variable `_underlying` and` _wrapped` in the `setUnderlyingToProtocolWrapped()` function.\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/factories/PieFactoryContract.sol#L35 for the `_controller` variable in the`setDefaultController ()` function.\n\n##### Recommendation\nIt is necessary to add a check of the parameter value to zero before initializing the variables.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/callManagers/LendingManager/LendingRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\n\n// TODO consider making this contract upgradeable\ncontract LendingRegistry is Ownable {\n\n    // Maps wrapped token to protocol\n    mapping(address => bytes32) public wrappedToProtocol;\n    // Maps wrapped token to underlying\n    mapping(address => address) public wrappedToUnderlying;\n\n    mapping(address => mapping(bytes32 => address)) public underlyingToProtocolWrapped;\n\n    // Maps protocol to addresses containing lend and unlend logic\n    mapping(bytes32 => address) public protocolToLogic;\n\n    event WrappedToProtocolSet(address indexed wrapped, bytes32 indexed protocol);\n    event WrappedToUnderlyingSet(address indexed wrapped, address indexed underlying);\n    event ProtocolToLogicSet(bytes32 indexed protocol, address indexed logic);\n    event UnderlyingToProtocolWrappedSet(address indexed underlying, bytes32 indexed protocol, address indexed wrapped);\n\n    /**\n        @notice Set which protocl a wrapped token belongs to\n        @param _wrapped Address of the wrapped token\n        @param _protocol Bytes32 key of the protocol\n    */\n    function setWrappedToProtocol(address _wrapped, bytes32 _protocol) onlyOwner external {\n        wrappedToProtocol[_wrapped] = _protocol;\n        emit WrappedToProtocolSet(_wrapped, _protocol);\n    }\n\n    /**\n        @notice Set what is the underlying for a wrapped token\n        @param _wrapped Address of the wrapped token\n        @param _underlying Address of the underlying token\n    */\n    function setWrappedToUnderlying(address _wrapped, address _underlying) onlyOwner external {\n        wrappedToUnderlying[_wrapped] = _underlying;\n        emit WrappedToUnderlyingSet(_wrapped, _underlying);\n    }\n\n    /**\n        @notice Set the logic contract for the protocol\n        @param _protocol Bytes32 key of the procol\n        @param _logic Address of the lending logic contract for that protocol\n    */\n    function setProtocolToLogic(bytes32 _protocol, address _logic) onlyOwner external {\n        protocolToLogic[_protocol] = _logic;\n        emit ProtocolToLogicSet(_protocol, _logic);\n    }\n\n    /**\n        @notice Set the wrapped token for the underlying deposited in this protocol\n        @param _underlying Address of the unerlying token\n        @param _protocol Bytes32 key of the protocol\n        @param _wrapped Address of the wrapped token\n    */\n    function setUnderlyingToProtocolWrapped(address _underlying, bytes32 _protocol, address _wrapped) onlyOwner external {\n        underlyingToProtocolWrapped[_underlying][_protocol] = _wrapped;\n        emit UnderlyingToProtocolWrappedSet(_underlying, _protocol, _wrapped);\n    } \n\n    /**\n        @notice Get tx data to lend the underlying amount in a specific protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount to lend\n        @param _protocol Bytes32 key of the protocol\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getLendTXData(address _underlying, uint256 _amount, bytes32 _protocol) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[_protocol]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.lend(_underlying, _amount);\n    }\n\n    /**\n        @notice Get the tx data to unlend the wrapped amount\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of wrapped token to unlend\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getUnlendTXData(address _wrapped, uint256 _amount) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[wrappedToProtocol[_wrapped]]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.unlend(_wrapped, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\n\n// TODO consider making this contract upgradeable\ncontract LendingRegistry is Ownable {\n\n    // Maps wrapped token to protocol\n    mapping(address => bytes32) public wrappedToProtocol;\n    // Maps wrapped token to underlying\n    mapping(address => address) public wrappedToUnderlying;\n\n    mapping(address => mapping(bytes32 => address)) public underlyingToProtocolWrapped;\n\n    // Maps protocol to addresses containing lend and unlend logic\n    mapping(bytes32 => address) public protocolToLogic;\n\n    event WrappedToProtocolSet(address indexed wrapped, bytes32 indexed protocol);\n    event WrappedToUnderlyingSet(address indexed wrapped, address indexed underlying);\n    event ProtocolToLogicSet(bytes32 indexed protocol, address indexed logic);\n    event UnderlyingToProtocolWrappedSet(address indexed underlying, bytes32 indexed protocol, address indexed wrapped);\n\n    /**\n        @notice Set which protocl a wrapped token belongs to\n        @param _wrapped Address of the wrapped token\n        @param _protocol Bytes32 key of the protocol\n    */\n    function setWrappedToProtocol(address _wrapped, bytes32 _protocol) onlyOwner external {\n        wrappedToProtocol[_wrapped] = _protocol;\n        emit WrappedToProtocolSet(_wrapped, _protocol);\n    }\n\n    /**\n        @notice Set what is the underlying for a wrapped token\n        @param _wrapped Address of the wrapped token\n        @param _underlying Address of the underlying token\n    */\n    function setWrappedToUnderlying(address _wrapped, address _underlying) onlyOwner external {\n        wrappedToUnderlying[_wrapped] = _underlying;\n        emit WrappedToUnderlyingSet(_wrapped, _underlying);\n    }\n\n    /**\n        @notice Set the logic contract for the protocol\n        @param _protocol Bytes32 key of the procol\n        @param _logic Address of the lending logic contract for that protocol\n    */\n    function setProtocolToLogic(bytes32 _protocol, address _logic) onlyOwner external {\n        protocolToLogic[_protocol] = _logic;\n        emit ProtocolToLogicSet(_protocol, _logic);\n    }\n\n    /**\n        @notice Set the wrapped token for the underlying deposited in this protocol\n        @param _underlying Address of the unerlying token\n        @param _protocol Bytes32 key of the protocol\n        @param _wrapped Address of the wrapped token\n    */\n    function setUnderlyingToProtocolWrapped(address _underlying, bytes32 _protocol, address _wrapped) onlyOwner external {\n        underlyingToProtocolWrapped[_underlying][_protocol] = _wrapped;\n        emit UnderlyingToProtocolWrappedSet(_underlying, _protocol, _wrapped);\n    } \n\n    /**\n        @notice Get tx data to lend the underlying amount in a specific protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount to lend\n        @param _protocol Bytes32 key of the protocol\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getLendTXData(address _underlying, uint256 _amount, bytes32 _protocol) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[_protocol]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.lend(_underlying, _amount);\n    }\n\n    /**\n        @notice Get the tx data to unlend the wrapped amount\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of wrapped token to unlend\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getUnlendTXData(address _wrapped, uint256 _amount) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[wrappedToProtocol[_wrapped]]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.unlend(_wrapped, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\n\n// TODO consider making this contract upgradeable\ncontract LendingRegistry is Ownable {\n\n    // Maps wrapped token to protocol\n    mapping(address => bytes32) public wrappedToProtocol;\n    // Maps wrapped token to underlying\n    mapping(address => address) public wrappedToUnderlying;\n\n    mapping(address => mapping(bytes32 => address)) public underlyingToProtocolWrapped;\n\n    // Maps protocol to addresses containing lend and unlend logic\n    mapping(bytes32 => address) public protocolToLogic;\n\n    event WrappedToProtocolSet(address indexed wrapped, bytes32 indexed protocol);\n    event WrappedToUnderlyingSet(address indexed wrapped, address indexed underlying);\n    event ProtocolToLogicSet(bytes32 indexed protocol, address indexed logic);\n    event UnderlyingToProtocolWrappedSet(address indexed underlying, bytes32 indexed protocol, address indexed wrapped);\n\n    /**\n        @notice Set which protocl a wrapped token belongs to\n        @param _wrapped Address of the wrapped token\n        @param _protocol Bytes32 key of the protocol\n    */\n    function setWrappedToProtocol(address _wrapped, bytes32 _protocol) onlyOwner external {\n        wrappedToProtocol[_wrapped] = _protocol;\n        emit WrappedToProtocolSet(_wrapped, _protocol);\n    }\n\n    /**\n        @notice Set what is the underlying for a wrapped token\n        @param _wrapped Address of the wrapped token\n        @param _underlying Address of the underlying token\n    */\n    function setWrappedToUnderlying(address _wrapped, address _underlying) onlyOwner external {\n        wrappedToUnderlying[_wrapped] = _underlying;\n        emit WrappedToUnderlyingSet(_wrapped, _underlying);\n    }\n\n    /**\n        @notice Set the logic contract for the protocol\n        @param _protocol Bytes32 key of the procol\n        @param _logic Address of the lending logic contract for that protocol\n    */\n    function setProtocolToLogic(bytes32 _protocol, address _logic) onlyOwner external {\n        protocolToLogic[_protocol] = _logic;\n        emit ProtocolToLogicSet(_protocol, _logic);\n    }\n\n    /**\n        @notice Set the wrapped token for the underlying deposited in this protocol\n        @param _underlying Address of the unerlying token\n        @param _protocol Bytes32 key of the protocol\n        @param _wrapped Address of the wrapped token\n    */\n    function setUnderlyingToProtocolWrapped(address _underlying, bytes32 _protocol, address _wrapped) onlyOwner external {\n        underlyingToProtocolWrapped[_underlying][_protocol] = _wrapped;\n        emit UnderlyingToProtocolWrappedSet(_underlying, _protocol, _wrapped);\n    } \n\n    /**\n        @notice Get tx data to lend the underlying amount in a specific protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount to lend\n        @param _protocol Bytes32 key of the protocol\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getLendTXData(address _underlying, uint256 _amount, bytes32 _protocol) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[_protocol]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.lend(_underlying, _amount);\n    }\n\n    /**\n        @notice Get the tx data to unlend the wrapped amount\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of wrapped token to unlend\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getUnlendTXData(address _wrapped, uint256 _amount) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[wrappedToProtocol[_wrapped]]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.unlend(_wrapped, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\n\n// TODO consider making this contract upgradeable\ncontract LendingRegistry is Ownable {\n\n    // Maps wrapped token to protocol\n    mapping(address => bytes32) public wrappedToProtocol;\n    // Maps wrapped token to underlying\n    mapping(address => address) public wrappedToUnderlying;\n\n    mapping(address => mapping(bytes32 => address)) public underlyingToProtocolWrapped;\n\n    // Maps protocol to addresses containing lend and unlend logic\n    mapping(bytes32 => address) public protocolToLogic;\n\n    event WrappedToProtocolSet(address indexed wrapped, bytes32 indexed protocol);\n    event WrappedToUnderlyingSet(address indexed wrapped, address indexed underlying);\n    event ProtocolToLogicSet(bytes32 indexed protocol, address indexed logic);\n    event UnderlyingToProtocolWrappedSet(address indexed underlying, bytes32 indexed protocol, address indexed wrapped);\n\n    /**\n        @notice Set which protocl a wrapped token belongs to\n        @param _wrapped Address of the wrapped token\n        @param _protocol Bytes32 key of the protocol\n    */\n    function setWrappedToProtocol(address _wrapped, bytes32 _protocol) onlyOwner external {\n        wrappedToProtocol[_wrapped] = _protocol;\n        emit WrappedToProtocolSet(_wrapped, _protocol);\n    }\n\n    /**\n        @notice Set what is the underlying for a wrapped token\n        @param _wrapped Address of the wrapped token\n        @param _underlying Address of the underlying token\n    */\n    function setWrappedToUnderlying(address _wrapped, address _underlying) onlyOwner external {\n        wrappedToUnderlying[_wrapped] = _underlying;\n        emit WrappedToUnderlyingSet(_wrapped, _underlying);\n    }\n\n    /**\n        @notice Set the logic contract for the protocol\n        @param _protocol Bytes32 key of the procol\n        @param _logic Address of the lending logic contract for that protocol\n    */\n    function setProtocolToLogic(bytes32 _protocol, address _logic) onlyOwner external {\n        protocolToLogic[_protocol] = _logic;\n        emit ProtocolToLogicSet(_protocol, _logic);\n    }\n\n    /**\n        @notice Set the wrapped token for the underlying deposited in this protocol\n        @param _underlying Address of the unerlying token\n        @param _protocol Bytes32 key of the protocol\n        @param _wrapped Address of the wrapped token\n    */\n    function setUnderlyingToProtocolWrapped(address _underlying, bytes32 _protocol, address _wrapped) onlyOwner external {\n        underlyingToProtocolWrapped[_underlying][_protocol] = _wrapped;\n        emit UnderlyingToProtocolWrappedSet(_underlying, _protocol, _wrapped);\n    } \n\n    /**\n        @notice Get tx data to lend the underlying amount in a specific protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount to lend\n        @param _protocol Bytes32 key of the protocol\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getLendTXData(address _underlying, uint256 _amount, bytes32 _protocol) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[_protocol]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.lend(_underlying, _amount);\n    }\n\n    /**\n        @notice Get the tx data to unlend the wrapped amount\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of wrapped token to unlend\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getUnlendTXData(address _wrapped, uint256 _amount) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[wrappedToProtocol[_wrapped]]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.unlend(_wrapped, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/factories/PieFactoryContract.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"diamond-2/contracts/Diamond.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IExperiPie.sol\";\n\ncontract PieFactoryContract is Ownable {\n    using SafeERC20 for IERC20;\n\n    address[] public pies;\n    mapping(address => bool) public isPie;\n    address public defaultController;\n\n    IDiamondCut.FacetCut[] public defaultCut;\n\n    event PieCreated(\n        address indexed pieAddress,\n        address indexed deployer,\n        uint256 indexed index\n    );\n\n    event DefaultControllerSet(address indexed controller);\n    event FacetAdded(IDiamondCut.FacetCut);\n    event FacetRemoved(IDiamondCut.FacetCut);\n\n    constructor() {\n        defaultController = msg.sender;\n    }\n\n    function setDefaultController(address _controller) external onlyOwner {\n        defaultController = _controller;\n        emit DefaultControllerSet(_controller);\n    }\n\n    function removeFacet(uint256 _index) external onlyOwner {\n        emit FacetRemoved(defaultCut[_index]);\n        defaultCut[_index] = defaultCut[defaultCut.length - 1];\n        defaultCut.pop();\n    }\n\n    function addFacet(IDiamondCut.FacetCut memory _facet) external onlyOwner {\n        defaultCut.push(_facet);\n        emit FacetAdded(_facet);\n    }\n\n    function bakePie(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _initialSupply,\n        string memory _symbol,\n        string memory _name\n    ) external {\n        Diamond d = new Diamond(defaultCut, address(this));\n\n        pies.push(address(d));\n        isPie[address(d)] = true;\n\n        // emit DiamondCreated(address(d));\n        require(_tokens.length != 0, \"CANNOT_CREATE_ZERO_TOKEN_LENGTH_PIE\");\n        require(_tokens.length == _amounts.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        IExperiPie pie = IExperiPie(address(d));\n\n        // Init erc20 facet\n        pie.initialize(_initialSupply, _name, _symbol);\n\n        // Transfer and add tokens\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            token.safeTransferFrom(msg.sender, address(pie), _amounts[i]);\n            pie.addToken(_tokens[i]);\n        }\n\n        // Unlock pool\n        pie.setLock(1);\n\n        // Uncap pool\n        pie.setCap(uint256(-1));\n\n        // Send minted pie to msg.sender\n        pie.transfer(msg.sender, _initialSupply);\n        pie.transferOwnership(defaultController);\n\n        emit PieCreated(address(d), msg.sender, pies.length - 1);\n    }\n\n    function getDefaultCut()\n        external\n        view\n        returns (IDiamondCut.FacetCut[] memory)\n    {\n        return defaultCut;\n    }\n\n    function getDefaultCutCount() external view returns (uint256) {\n        return defaultCut.length;\n    }\n}"
    }
  ]
}