{
  "Title": "A user with KintoID can create multiple KintoWallets",
  "Content": "##### Description\n\n* https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/wallet/KintoWalletFactory.sol#L86\n\nA user with KintoID can create multiple KintoWallets by calling `KintoWalletFactory.createAccount()` with different values for `salt` and `recoverer`.\n\nThis is not a vulnerability, but developers need to decide whether this is appropriate behavior within the Kinto network.\n\n##### Recommendation\n\nWe recommend coming to a decision on whether a single user with KintoID should be allowed to create multiple KintoWallets or not.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/wallet/KintoWalletFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport '@openzeppelin/contracts/utils/Create2.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport { UpgradeableBeacon } from '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol';\nimport { SafeBeaconProxy } from '../proxy/SafeBeaconProxy.sol';\n\nimport '../interfaces/IKintoID.sol';\nimport '../interfaces/IKintoWalletFactory.sol';\nimport './KintoWallet.sol';\n\n/**\n * @title KintoWalletFactory\n * @dev A kinto wallet factory contract for KintoWallet\n *   Sits behind a proxy. It's upgradeable.\n *   A UserOperations \"initCode\" holds the address of the factory,\n *   and a method call (to createAccount, in this sample factory).\n *   The factory's createAccount returns the target account address even if it is already installed.\n *   This way, the entryPoint.getSenderAddress() can be called either\n *   before or after the account is created.\n */\ncontract KintoWalletFactory is Initializable, UUPSUpgradeable, IKintoWalletFactory {\n\n    /* ============ State Variables ============ */\n    address immutable public override factoryOwner;\n    UpgradeableBeacon public immutable beacon;\n\n    IKintoID public override kintoID;\n    mapping (address => uint256) public override walletTs;\n    uint256 public override factoryWalletVersion;\n    uint256 public override totalWallets;\n\n    /* ============ Events ============ */\n    event KintoWalletFactoryCreation(address indexed account, address indexed owner, uint version);\n    event KintoWalletFactoryUpgraded(address indexed oldImplementation,\n        address indexed newImplementation);\n\n    /* ============ Constructor ============ */\n    constructor(UpgradeableBeacon _beaconp) {\n        factoryOwner = msg.sender;\n        beacon = _beaconp;\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Upgrade calling `upgradeTo()`\n     */\n    function initialize(\n        IKintoID _kintoID\n    ) external virtual initializer {\n        __UUPSUpgradeable_init();\n        factoryWalletVersion = 1;\n        kintoID = _kintoID;\n    }\n\n    /**\n     * @dev Upgrade the wallet implementations using the beacon\n     * @param newImplementationWallet The new implementation\n     */\n    function upgradeAllWalletImplementations(\n        IKintoWallet newImplementationWallet\n    ) external override {\n        require(msg.sender == factoryOwner, 'only owner');\n        require(address(newImplementationWallet) != address(0), 'invalid address');\n        factoryWalletVersion++;\n        emit KintoWalletFactoryUpgraded(address(newImplementationWallet),\n            address(newImplementationWallet));\n        beacon.upgradeTo(address(newImplementationWallet));\n    }\n\n    /**\n     *\n     * @dev Create an account, and return its address.\n     * It returns the address even if the account is already deployed.\n     * Note that during UserOperation execution,\n     * this method is called only if the account is not deployed.\n     * This method returns an existing account address so that entryPoint.getSenderAddress()\n     * would work even after account creation\n     * @param owner The owner address\n     * @param recoverer The recoverer address\n     * @param salt The salt to use for the calculation\n     * @return ret address of the account\n     */\n    function createAccount(address owner, address recoverer, uint256 salt) external override returns (\n        IKintoWallet ret\n    ) {\n        require(kintoID.isKYC(owner), 'KYC required');\n        address addr = getAddress(owner, recoverer, salt);\n        uint codeSize = addr.code.length;\n\n        if (codeSize > 0) {\n            return KintoWallet(payable(addr));\n        }\n\n        ret = KintoWallet(payable(\n            new SafeBeaconProxy{salt : bytes32(salt)}(\n                    address(beacon),\n                    abi.encodeWithSelector(\n                        KintoWallet.initialize.selector,\n                        owner,\n                        recoverer\n                    )\n                )\n        ));\n\n        walletTs[address(ret)] = block.timestamp;\n        totalWallets++;\n        // Emit event\n        emit KintoWalletFactoryCreation(address(ret), owner, factoryWalletVersion);\n    }\n\n    /* ============ Deploy Custom Contract ============ */\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     * -  sender myst be KYC'd\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deployContract(\n        uint amount,\n        bytes memory bytecode,\n        bytes32 salt\n    ) external override returns (address) {\n        require(kintoID.isKYC(msg.sender), 'KYC required');\n        return Create2.deploy(amount, salt, bytecode);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Gets the creation timestamp of a current wallet\n     * @param wallet The wallet address\n     * @return The timestamp of the wallet. 0 if it is not a wallet\n     */\n    function getWalletTimestamp(address wallet) external view override returns (uint256) {\n        return walletTs[wallet];\n    }\n\n    /**\n     * @dev Calculates the counterfactual address of this account\n     * as it would be returned by createAccount()\n     * @param owner The owner address\n     * @param recoverer The address that can recover the account in an emergency\n     * @param salt The salt to use for the calculation\n     * @return The address of the account\n     */\n    function getAddress(address owner, address recoverer, uint256 salt) public view override returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n                type(SafeBeaconProxy).creationCode,\n                abi.encode(\n                    address(beacon),\n                    abi.encodeCall(KintoWallet.initialize, (owner, recoverer))\n                )\n            )));\n    }\n\n    /**\n     * @dev Calculates the counterfactual address of this contract as it\n     * would be returned by deployContract()\n     * @param salt Salt used by CREATE2\n     * @param byteCodeHash The bytecode hash (keccack256) of the contract to deploy\n     * @return address of the contract to deploy\n     */\n    function getContractAddress(\n        bytes32 salt,\n        bytes32 byteCodeHash\n    ) public view override returns (address) {\n        return Create2.computeAddress(salt, byteCodeHash, address(this));\n    }\n\n    /**\n     * @dev Authorize the upgrade. Only by an owner.\n     * @param newImplementation address of the new implementation\n     */\n    // This function is called by the proxy contract when the factory is upgraded\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        require(msg.sender == factoryOwner, 'only owner');\n    }\n}"
    }
  ]
}