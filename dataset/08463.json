{
  "Title": "[M-09] VaultTracker has the wrong admin",
  "Content": "_Submitted by itsmeSTYJ, also found by GimelSec_\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/Marketplace/MarketPlace.sol#L77>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/Creator.sol#L41>\n\n<https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L32>\n\n### Description\n\n`MarketPlace.createMarket()` calls `Creator.create()` which creates an instance of `ZcToken` and a `VaultTracker`. `VaultTracker` takes `msg.sender` as the admin. We know that if contract A calls contract B which calls contract C, `msg.sender` in contract C is the address of B i.e. the `msg.sender` in VaultTracker is the address of the creator contract. However, the creator contract is not able (and not supposed to) interact with the VaultTracker unlike the marketplace contract.\n\n### Recommended Mitigation Steps\n\nModify the constructor of the VaultTracker contract so that the creator contract can pass in msg.sender (MarketPlaceâ€™s address) to be used as admin.\n\n**[JTraversa (Swivel) confirmed](https://github.com/code-423n4/2022-07-swivel-findings/issues/36)** \n\n**[bghughes (judge) commented](https://github.com/code-423n4/2022-07-swivel-findings/issues/36#issuecomment-1205869654):**\n > Using this as the main `admin` constructor issue. Given it is admin related, I believe going with the Medium issue instead of #134 makes sense.\n\n**[robrobbins (Swivel) resolved](https://github.com/code-423n4/2022-07-swivel-findings/issues/36#issuecomment-1209654129):**\n > See [#134](https://github.com/code-423n4/2022-07-swivel-findings/issues/134).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-swivel-v3-contest",
  "Code": [
    {
      "filename": "Marketplace/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './Compounding.sol';\n\ncontract MarketPlace {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Market {\n    address cTokenAddr;\n    address zcToken;\n    address vaultTracker;\n    uint256 maturityRate;\n  }\n\n  mapping (uint8 => mapping (address => mapping (uint256 => Market))) public markets;\n  mapping (uint8 => bool) public paused;\n\n  address public admin;\n  address public swivel;\n  address public immutable creator;\n\n  event Create(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address cToken, address zcToken, address vaultTracker);\n  event Mature(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);\n  event RedeemZcToken(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address sender, uint256 amount);\n  event RedeemVaultInterest(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address sender);\n  event CustodialInitiate(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\n  event CustodialExit(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\n  event P2pZcTokenExchange(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n  event P2pVaultExchange(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n  event TransferVaultNotional(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n\n  constructor(address c) {\n    admin = msg.sender;\n    creator = c;\n  }\n\n  /// @param s Address of the deployed swivel contract\n  /// @notice We only allow this to be set once\n  function setSwivel(address s) external authorized(admin) returns (bool) {\n    if (swivel != address(0)) { revert Exception(20, 0, 0, swivel, address(0));  }\n\n    swivel = s;\n    return true;\n  }\n\n  /// @param a Address of a new admin\n  function setAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n    return true;\n  }\n\n  /// @notice Allows the owner to create new markets\n  /// @param p Protocol associated with the new market\n  /// @param m Maturity timestamp of the new market\n  /// @param c Compounding Token address associated with the new market\n  /// @param n Name of the new market zcToken\n  /// @param s Symbol of the new market zcToken\n  function createMarket(\n    uint8 p,\n    uint256 m,\n    address c,\n    string memory n,\n    string memory s\n  ) external authorized(admin) unpaused(p) returns (bool) {\n    if (swivel == address(0)) { revert Exception(21, 0, 0, address(0), address(0)); }\n\n    address underAddr = Compounding.underlying(p, c);\n\n    if (markets[p][underAddr][m].vaultTracker != address(0)) { revert Exception(22, 0, 0, address(0), address(0)); }\n\n    (address zct, address tracker) = ICreator(creator).create(p, underAddr, m, c, swivel, n, s, IErc20(underAddr).decimals()) ;\n\n    markets[p][underAddr][m] = Market(c, zct, tracker, 0);\n\n    emit Create(p, underAddr, m, c, zct, tracker);\n\n    return true;\n  }\n\n  /// @notice Can be called after maturity, allowing all of the zcTokens to earn floating interest on Compound until they release their funds\n  /// @param p Protocol Enum value associated with the market being matured\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function matureMarket(uint8 p, address u, uint256 m) public unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n\n    if (market.maturityRate != 0) { revert Exception(23, market.maturityRate, 0, address(0), address(0)); }\n\n    if (block.timestamp < m) { revert Exception(24, block.timestamp, m, address(0), address(0)); }\n\n    // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate\n    uint256 exchangeRate = Compounding.exchangeRate(p, market.cTokenAddr);\n    markets[p][u][m].maturityRate = exchangeRate;\n\n    // NOTE we don't check the return of this simple operation\n    IVaultTracker(market.vaultTracker).matureVault(exchangeRate);\n\n    emit Mature(p, u, m, exchangeRate, block.timestamp);\n\n    return true;\n  }\n\n  /// @notice Allows Swivel caller to deposit their underlying, in the process splitting it - minting both zcTokens and vault notional.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the depositing user\n  /// @param a Amount of notional being added\n  function mintZcTokenAddingNotional(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n\n    if (!IZcToken(market.zcToken).mint(t, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).addNotional(t, a)) { revert Exception(25, 0, 0, address(0), address(0)); }\n    \n    return true;\n  }\n\n  /// @notice Allows Swivel caller to deposit/burn both zcTokens + vault notional. This process is \"combining\" the two and redeeming underlying.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the combining/redeeming user\n  /// @param a Amount of zcTokens being burned\n  function burnZcTokenRemovingNotional(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns(bool) {\n    Market memory market = markets[p][u][m];\n\n    if (!IZcToken(market.zcToken).burn(t, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).removeNotional(t, a)) { revert Exception(26, 0, 0, address(0), address(0)); }\n    \n    return true;\n  }\n\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Address of the user having their zcTokens burned\n  /// @param t Address of the user receiving underlying\n  /// @param a Amount of zcTokens being redeemed\n  /// @return underlyingAmount Amount of underlying being withdrawn (needed for 5095 return)\n  function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) {\n    Market memory market = markets[p][u][m];\n    // if the market has not matured, mature it...\n    if (market.maturityRate == 0) {\n      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }\n\n      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, a);\n\n      return (a);\n    } else {\n\n      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n      uint256 amount = calculateReturn(p, u, m, a);\n      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, amount);\n\n      return (amount);\n    }\n  }\n\n  /// @notice Allows (via swivel) zcToken holders to redeem their tokens for underlying tokens after maturity has been reached.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the redeeming user\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns (uint256) {\n    Market memory market = markets[p][u][m];\n\n    // if the market has not matured, mature it and redeem exactly the amount\n    if (market.maturityRate == 0) {\n      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }\n    }\n\n    if (!IZcToken(market.zcToken).burn(t, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    emit RedeemZcToken(p, u, m, t, a);\n\n    if (market.maturityRate == 0) {\n      return a;\n    } else { \n      // if the market was already mature the return should include the amount + marginal floating interest generated on Compound since maturity\n      return calculateReturn(p, u, m, a);\n    }\n  }\n\n  /// @notice Allows Vault owners (via Swivel) to redeem any currently accrued interest\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the redeeming user\n  function redeemVaultInterest(uint8 p, address u, uint256 m, address t) external authorized(swivel) unpaused(p) returns (uint256) {\n    // call to the floating market contract to release the position and calculate the interest generated\n    uint256 interest = IVaultTracker(markets[p][u][m].vaultTracker).redeemInterest(t);\n\n    emit RedeemVaultInterest(p, u, m, t);\n\n    return interest;\n  }\n\n  /// @notice Calculates the total amount of underlying returned including interest generated since the `matureMarket` function has been called\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function calculateReturn(uint8 p, address u, uint256 m, uint256 a) internal view returns (uint256) {\n    Market memory market = markets[p][u][m];\n\n    uint256 exchangeRate = Compounding.exchangeRate(p, market.cTokenAddr);\n\n    return (a * exchangeRate) / market.maturityRate;\n  }\n\n  /// @notice Return the compounding token address for a given market\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function cTokenAddress(uint8 p, address u, uint256 m) external view returns (address) {\n    Market memory market = markets[p][u][m];\n    return market.cTokenAddr;\n  }\n\n  /// @notice Return the exchangeRate for a given protocol's compounding token\n  /// @param p Protocol Enum value associated with this market\n  /// @param c Compounding token address associated with the market\n  function getExchangeRate(uint8 p, address c) external view returns (uint256) {\n      return Compounding.exchangeRate(p, c);\n  }\n\n  /// @notice Called by swivel IVFZI && IZFVI\n  /// @dev Call with protocol, underlying, maturity, mint-target, add-notional-target and an amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param z Recipient of the minted zcToken\n  /// @param n Recipient of the added notional\n  /// @param a Amount of zcToken minted and notional added\n  function custodialInitiate(uint8 p, address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).mint(z, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).addNotional(n, a)) { revert Exception(25, 0, 0, address(0), address(0)); }\n\n    emit CustodialInitiate(p, u, m, z, n, a);\n    return true;\n  }\n\n  /// @notice Called by swivel EVFZE FF EZFVE\n  /// @dev Call with protocol, underlying, maturity, burn-target, remove-notional-target and an amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param z Owner of the zcToken to be burned\n  /// @param n Target to remove notional from\n  /// @param a Amount of zcToken burned and notional removed\n  function custodialExit(uint8 p, address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).burn(z, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).removeNotional(n, a)) { revert Exception(26, 0, 0, address(0), address(0)); }\n\n    emit CustodialExit(p, u, m, z, n, a);\n    return true;\n  }\n\n  /// @notice Called by swivel IZFZE, EZFZI\n  /// @dev Call with underlying, maturity, transfer-from, transfer-to, amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the zcToken to be burned\n  /// @param t Target to be minted to\n  /// @param a Amount of zcToken transfer\n  function p2pZcTokenExchange(uint8 p, address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IZcToken(market.zcToken).mint(t, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    emit P2pZcTokenExchange(p, u, m, f, t, a);\n    return true;\n  }\n\n  /// @notice Called by swivel IVFVE, EVFVI\n  /// @dev Call with protocol, underlying, maturity, remove-from, add-to, amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the notional to be transferred\n  /// @param t Target to be transferred to\n  /// @param a Amount of notional transfer\n  function p2pVaultExchange(uint8 p, address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    if (!IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(f, t, a)) { revert Exception(27, 0, 0, address(0), address(0)); }\n\n    emit P2pVaultExchange(p, u, m, f, t, a);\n    return true;\n  }\n\n  /// @notice External method giving access to this functionality within a given vault\n  /// @dev Note that this method calculates yield and interest as well\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Target to be transferred to\n  /// @param a Amount of notional to be transferred\n  function transferVaultNotional(uint8 p, address u, uint256 m, address t, uint256 a) external unpaused(p) returns (bool) {\n    if (!IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(msg.sender, t, a)) { revert Exception(27, 0, 0, address(0), address(0)); }\n\n    emit TransferVaultNotional(p, u, m, msg.sender, t, a);\n    return true;\n  }\n\n  /// @notice Transfers notional fee to the Swivel contract without recalculating marginal interest for from\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferVaultNotionalFee(uint8 p, address u, uint256 m, address f, uint256 a) external authorized(swivel) returns (bool) {\n    IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFee(f, a);\n    return true;\n  }\n\n  /// @notice Called by admin at any point to pause / unpause market transactions in a specified protocol\n  /// @param p Protocol Enum value of the protocol to be paused\n  /// @param b Boolean which indicates the (protocol) markets paused status\n  function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n    paused[p] = b;\n    return true;\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n\n  modifier unpaused(uint8 p) {\n    if(paused[p]) { revert Exception(1, 0, 0, address(0), address(0)); }\n    _;\n  }\n}"
    },
    {
      "filename": "Creator/Creator.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './ZcToken.sol';\nimport './VaultTracker.sol';\n\ncontract Creator {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  address public admin;\n  address public marketPlace;\n\n  constructor() {\n    admin = msg.sender;\n  }\n\n  /// @notice Allows the owner to create new markets\n  /// @param p Protocol associated with the new market\n  /// @param u Underlying token associated with the new market\n  /// @param m Maturity timestamp of the new market\n  /// @param c Compounding Token address associated with the new market\n  /// @param sw Address of the deployed swivel contract\n  /// @param n Name of the new market zcToken\n  /// @param s Symbol of the new market zcToken\n  /// @param d Decimals of the new market zcToken\n  function create (\n    uint8 p,\n    address u,\n    uint256 m,\n    address c,\n    address sw,\n    string memory n,\n    string memory s,\n    uint8 d\n  ) external authorized(marketPlace) returns (address, address) {\n    address zct = address(new ZcToken(p, u, m, c, marketPlace, n, s, d));\n    address tracker = address(new VaultTracker(p, m, c, sw));\n\n    return (zct, tracker);\n  }\n\n  /// @param a Address of a new admin\n  function setAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n    return true;\n  }\n\n  /// @param m Address of the deployed marketPlace contract\n  /// @notice We only allow this to be set once\n  function setMarketPlace(address m) external authorized(admin) returns (bool) {\n    if (marketPlace != address(0)) {\n      revert Exception(33, 0, 0, marketPlace, address(0)); \n    }\n\n    marketPlace = m;\n    return true;\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n      _;\n  }\n}"
    },
    {
      "filename": "VaultTracker/VaultTracker.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Compounding.sol';\n\ncontract VaultTracker {\n  /// @notice A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Vault {\n    uint256 notional;\n    uint256 redeemable;\n    uint256 exchangeRate;\n  }\n\n  mapping(address => Vault) public vaults;\n\n  address public immutable admin;\n  address public immutable cTokenAddr;\n  address public immutable swivel;\n  uint256 public immutable maturity;\n  uint256 public maturityRate;\n  uint8 public immutable protocol;\n\n  /// @param m Maturity timestamp associated with this vault\n  /// @param c Compounding Token address associated with this vault\n  /// @param s Address of the deployed swivel contract\n  constructor(uint8 p, uint256 m, address c, address s) {\n    admin = msg.sender;\n    protocol = p;\n    maturity = m;\n    cTokenAddr = c;\n    swivel = s;\n\n    // instantiate swivel's vault (unblocking transferNotionalFee)\n    vaults[s] = Vault({\n      notional: 0,\n      redeemable: 0,\n      exchangeRate: Compounding.exchangeRate(p, c)\n    });\n  }\n\n  /// @notice Adds notional to a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional added\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    Vault memory vlt = vaults[o];\n\n    if (vlt.notional > 0) {\n      uint256 yield;\n\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { // Calculate marginal interest\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n      }\n\n      uint256 interest = (yield * vlt.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      vlt.redeemable += interest;\n      vlt.notional += a;\n    } else {\n      vlt.notional = a;\n    }\n\n    vlt.exchangeRate = exchangeRate;\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Removes notional from a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional to remove\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n\n    Vault memory vlt = vaults[o];\n\n    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    vlt.redeemable += interest;\n    vlt.notional -= a;\n    vlt.exchangeRate = exchangeRate;\n\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Redeem's interest accrued by a given address\n  /// @param o Address that owns a vault\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\n\n    Vault memory vlt = vaults[o];\n\n    uint256 redeemable = vlt.redeemable;\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n\n    vlt.exchangeRate = exchangeRate;\n    vlt.redeemable = 0;\n\n    vaults[o] = vlt;\n\n    // return adds marginal interest to previously accrued redeemable interest\n    return (redeemable + interest);\n  }\n\n  /// @notice Matures the vault\n  /// @param c The current cToken exchange rate\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\n    maturityRate = c;\n    return true;\n  }\n\n  /// @notice Transfers notional from one address to another\n  /// @param f Owner of the amount\n  /// @param t Recipient of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\n    if (f == t) { revert Exception(32, 0, 0, f, t); }\n\n    Vault memory from = vaults[f];\n    Vault memory to = vaults[t];\n\n    if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { \n      // calculate marginal interest\n      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;\n    } else {\n      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * from.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    from.redeemable += interest;\n    from.notional -= a;\n    from.exchangeRate = exchangeRate;\n\n    vaults[f] = from;\n\n    // transfer notional to address \"t\", calculate interest if necessary\n    if (to.notional > 0) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;\n      }\n\n      uint256 newVaultInterest = (yield * to.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      to.redeemable += newVaultInterest;\n      to.notional += a;\n    } else {\n      to.notional = a;\n    }\n\n    to.exchangeRate = exchangeRate;\n    vaults[t] = to;\n\n    return true;\n  }\n\n  /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {\n    Vault memory oVault = vaults[f];\n    Vault memory sVault = vaults[swivel];\n\n    // remove notional from its owner\n    oVault.notional -= a;\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\n    uint256 yield;\n    if (sVault.exchangeRate != exchangeRate) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;\n      } else {\n          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;\n      }\n      uint256 interest = (yield * sVault.notional) / 1e26;\n      // add interest and amount, reset cToken exchange rate\n      sVault.redeemable += interest;\n      sVault.exchangeRate = exchangeRate;\n    }\n    // add notional to swivel's vault\n    sVault.notional += a;\n    // store the adjusted vaults\n    vaults[swivel] = sVault;\n    vaults[f] = oVault;\n    return true;\n  }\n\n  /// @notice Returns both relevant balances for a given user's vault\n  /// @param o Address that owns a vault\n  function balancesOf(address o) external view returns (uint256, uint256) {\n    Vault memory vault = vaults[o];\n    return (vault.notional, vault.redeemable);\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}"
    }
  ]
}