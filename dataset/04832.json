{
  "Title": "[54] Wrong error message in `BaseZkSyncUpgradeGenesis::_setNewProtocolVersion`",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L20-L41\n\n```solidity\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal override {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            // Genesis Upgrade difference: Note this is the only thing change > to >=\n            _newProtocolVersion >= previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n```\n\nThis function is used to change the protocol version, only case atttached here is the fact that if `_newProtocolVersion >= previousProtocolVersion,` does not hold true, the execution errors out with \"New protocol version is not greater than the current one\" instead of \"New protocol version is **not greater than or equal to** the current one\".\n\n### Impact\n\nInaccurate error messages, code confusion.\n\n### Recommended Mitigation Steps\n\nApply these changes to https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L20-L41\n\n```diff\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal override {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            // Genesis Upgrade difference: Note this is the only thing change > to >=\n            _newProtocolVersion >= previousProtocolVersion,\n            \"New protocol version is not greater than or equal to the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n```\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"../state-transition/chain-deps/facets/ZkSyncStateTransitionBase.sol\";\nimport \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport \"../common/Messaging.sol\";\nimport \"../state-transition/libraries/TransactionValidator.sol\";\nimport {MAX_NEW_FACTORY_DEPS, SYSTEM_UPGRADE_L2_TX_TYPE, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../common/Config.sol\";\nimport {ProposedUpgrade, BaseZkSyncUpgrade} from \"./BaseZkSyncUpgrade.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgradeGenesis is BaseZkSyncUpgrade {\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal override {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            // Genesis Upgrade difference: Note this is the only thing change > to >=\n            _newProtocolVersion >= previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    /// @dev This is a virtual function and should be overridden by custom upgrade implementations.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @return The hash of the L2 system contract upgrade transaction.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual override returns (bytes32) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        bytes32 txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"../state-transition/chain-deps/facets/ZkSyncStateTransitionBase.sol\";\nimport \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport \"../common/Messaging.sol\";\nimport \"../state-transition/libraries/TransactionValidator.sol\";\nimport {MAX_NEW_FACTORY_DEPS, SYSTEM_UPGRADE_L2_TX_TYPE, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../common/Config.sol\";\nimport {ProposedUpgrade, BaseZkSyncUpgrade} from \"./BaseZkSyncUpgrade.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgradeGenesis is BaseZkSyncUpgrade {\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal override {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            // Genesis Upgrade difference: Note this is the only thing change > to >=\n            _newProtocolVersion >= previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    /// @dev This is a virtual function and should be overridden by custom upgrade implementations.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @return The hash of the L2 system contract upgrade transaction.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual override returns (bytes32) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        bytes32 txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n}"
    }
  ]
}