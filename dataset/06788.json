{
  "Title": "[M-08] `ETHCrowdfundBase.sol`: All funds are lost when fee recipient cannot receive ETH",
  "Content": "\nIn the [`ETHCrowdfundBase`](https://github.com/code-423n4/2023-04-party/blob/main/contracts/crowdfund/ETHCrowdfundBase.sol) contract a [`fundingSplitRecipient`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L142) address is configured which receives a percentage of the funds in case the crowdfund is won.\n\nNeither the `fundingSplitRecipient` address nor the `fundingSplitBps` percentage can be changed.\n\nThe issue is that the `_finalize` function can only succeed when the fees can be transferred to the recipient.\n\nHowever the recipient contract may revert when it receives ETH. This causes all ETH in the `ETHCrowdfundBase` contract to be stuck.\n\n### Proof of Concept\n\nWhen the crowdfund is won the `finalize` function needs to be called which calls `_finalize`:\n\n[Link](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273-L292)\n\n```solidity\nfunction _finalize(uint96 totalContributions_) internal {\n    // Finalize the crowdfund.\n    delete expiry;\n\n\n    // Update the party's total voting power.\n    uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n    party.increaseTotalVotingPower(newVotingPower);\n\n\n    // Transfer fee to recipient if applicable.\n    address payable fundingSplitRecipient_ = fundingSplitRecipient;\n    uint16 fundingSplitBps_ = fundingSplitBps;\n    if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n        uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;\n        totalContributions_ -= feeAmount;\n        fundingSplitRecipient_.transferEth(feeAmount);\n    }\n\n\n    // Transfer ETH to the party.\n    payable(address(party)).transferEth(totalContributions_);\n}\n```\n\nHere you can see that the `feeAmount` is transferred to the `fundingSplitRecipient`:\n\n```solidity\nfundingSplitRecipient_.transferEth(feeAmount);\n```\n\nIf the recipient contract reverts, the ETH cannot be transferred and the crowdfund cannot be finalized.\n\nBut the users can also not get a refund because the crowdfund is in the `Won` state. So there is no way to get the funds out of the contract which means they are lost. Also the users don't get the voting power that they are supposed to get from the crowdfund.\n\nThis could be used in a griefing attack where the `fundingSplitRecipient` is set such that it can be made to revert.\n\nUsers that fall into this \"trap\" will lose all their funds. It can also just happen by mistake that a bad `fundingSplitRecipient` is set.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nI recommend to pay the fees in a separate function such that it is separated from the `_finalize` function.\n\n```diff\ndiff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.sol\nindex 4392655..5f68406 100644\n--- a/contracts/crowdfund/ETHCrowdfundBase.sol\n+++ b/contracts/crowdfund/ETHCrowdfundBase.sol\n@@ -62,6 +62,8 @@ contract ETHCrowdfundBase is Implementation {\n     error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\n     error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\n     error ContributingForExistingCardDisabledError();\n+    error NotFinalizedError();\n+    error FundingFeesAlreadyPaidError();\n \n     event Contributed(\n         address indexed sender,\n@@ -109,6 +111,8 @@ contract ETHCrowdfundBase is Implementation {\n     /// @notice The address a contributor is delegating their voting power to.\n     mapping(address => address) public delegationsByContributor;\n \n+    bool public fundingFeesPaid;\n+\n     // Initialize storage for proxy contracts, credit initial contribution (if\n     // any), and setup gatekeeper.\n     function _initialize(ETHCrowdfundOptions memory opts) internal {\n@@ -278,7 +282,20 @@ contract ETHCrowdfundBase is Implementation {\n         uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n         party.increaseTotalVotingPower(newVotingPower);\n \n+        // Transfer ETH to the party.\n+        payable(address(party)).transferEth(totalContributions_);\n+    }\n+\n+    function sendFundingFees() external {\n+        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n+        \n+        if (lc != CrowdfundLifecycle.Finalized) revert NotFinalizedError();\n+        if (fundingFeesPaid) revert FundingFeesAlreadyPaidError();\n+\n+        fundingFeesPaid = true;\n+\n         // Transfer fee to recipient if applicable.\n+        uint96 totalContributions_ = totalContributions;\n         address payable fundingSplitRecipient_ = fundingSplitRecipient;\n         uint16 fundingSplitBps_ = fundingSplitBps;\n         if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n@@ -286,8 +303,5 @@ contract ETHCrowdfundBase is Implementation {\n             totalContributions_ -= feeAmount;\n             fundingSplitRecipient_.transferEth(feeAmount);\n         }\n-\n-        // Transfer ETH to the party.\n-        payable(address(party)).transferEth(totalContributions_);\n     }\n }\n```\n\nAlternatively it may also be an option to just send the fees to the party in case the transfer to the recipient fails.\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-04-party-findings/issues/8#issuecomment-1512082533)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/ETHCrowdfundBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../party/Party.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\ncontract ETHCrowdfundBase is Implementation {\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        // In practice, this state is never used. If the crowdfund is ever in\n        // this stage, something is wrong (e.g. crowdfund was never initialized).\n        Invalid,\n        // Ready to accept contributions to reach contribution targets\n        // until a deadline or the minimum contribution target is reached and\n        // host finalizes.\n        Active,\n        // Expired and the minimum contribution target was not reached.\n        Lost,\n        // The crowdfund has expired and reached the minimum contribution\n        // target. It is now ready to finalize.\n        Won,\n        // A won crowdfund has been finalized, with funds transferred to the\n        // party and voting power successfully updated.\n        Finalized\n    }\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct ETHCrowdfundOptions {\n        Party party;\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error NotAllowedByGateKeeperError(\n        address contributor,\n        IGateKeeper gateKeeper,\n        bytes12 gateKeeperId,\n        bytes gateData\n    );\n    error OnlyPartyHostError();\n    error NotOwnerError();\n    error InvalidDelegateError();\n    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);\n    error MinGreaterThanMaxError(uint96 min, uint96 max);\n    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\n    error ContributingForExistingCardDisabledError();\n\n    event Contributed(\n        address indexed sender,\n        address indexed contributor,\n        uint256 amount,\n        address delegate\n    );\n\n    /// @notice The address of the `Party` contract instance associated\n    ///         with the crowdfund.\n    Party public party;\n    /// @notice The minimum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund.\n    uint96 public minContribution;\n    /// @notice The maximum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund per address.\n    uint96 public maxContribution;\n    /// @notice A boolean flag that determines whether contributors are allowed\n    ///         to increase the voting power of their existing party cards.\n    bool public disableContributingForExistingCard;\n    /// @notice The minimum amount of total ETH contributions required for the\n    ///         crowdfund to be considered successful.\n    uint96 public minTotalContributions;\n    /// @notice The maximum amount of total ETH contributions allowed for the\n    ///         crowdfund.\n    uint96 public maxTotalContributions;\n    /// @notice The total amount of ETH contributed to the crowdfund so far.\n    uint96 public totalContributions;\n    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the\n    ///         crowdfund has finalized.\n    uint40 public expiry;\n    /// @notice The exchange rate to use for converting ETH contributions to\n    ///         voting power in basis points (e.g. 10000 = 1:1).\n    uint16 public exchangeRateBps;\n    /// @notice The portion of contributions to send to the funding recipient in\n    ///         basis points (e.g. 100 = 1%).\n    uint16 public fundingSplitBps;\n    /// @notice The address to which a portion of the contributions is sent as a\n    ///         fee if set.\n    address payable public fundingSplitRecipient;\n    /// @notice The gatekeeper contract used to restrict who can contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.\n    bytes12 public gateKeeperId;\n    /// @notice The address a contributor is delegating their voting power to.\n    mapping(address => address) public delegationsByContributor;\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(ETHCrowdfundOptions memory opts) internal {\n        // Set the minimum and maximum contribution amounts.\n        if (opts.minContribution > opts.maxContribution) {\n            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);\n        }\n        minContribution = opts.minContribution;\n        maxContribution = opts.maxContribution;\n        // Set the min total contributions.\n        if (opts.minTotalContributions > opts.maxTotalContributions) {\n            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);\n        }\n        minTotalContributions = opts.minTotalContributions;\n        // Set the max total contributions.\n        if (opts.maxTotalContributions == 0) {\n            // Prevent this because when `maxTotalContributions` is 0 the\n            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has\n            // never been initialized.\n            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);\n        }\n        maxTotalContributions = opts.maxTotalContributions;\n        // Set the party crowdfund is for.\n        party = opts.party;\n        // Set the crowdfund start and end timestamps.\n        expiry = uint40(block.timestamp + opts.duration);\n        // Set the exchange rate.\n        exchangeRateBps = opts.exchangeRateBps;\n        // Set the funding split and its recipient.\n        fundingSplitBps = opts.fundingSplitBps;\n        fundingSplitRecipient = opts.fundingSplitRecipient;\n        // Set whether to disable contributing for existing card.\n        disableContributingForExistingCard = opts.disableContributingForExistingCard;\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {\n        if (maxTotalContributions == 0) {\n            return CrowdfundLifecycle.Invalid;\n        }\n\n        uint256 expiry_ = expiry;\n        if (expiry_ == 0) {\n            return CrowdfundLifecycle.Finalized;\n        }\n\n        if (block.timestamp >= expiry_) {\n            if (totalContributions >= minTotalContributions) {\n                return CrowdfundLifecycle.Won;\n            } else {\n                return CrowdfundLifecycle.Lost;\n            }\n        }\n\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _processContribution(\n        address payable contributor,\n        address delegate,\n        uint96 amount\n    ) internal returns (uint96 votingPower) {\n        address oldDelegate = delegationsByContributor[contributor];\n        if (msg.sender == contributor || oldDelegate == address(0)) {\n            // Update delegate.\n            delegationsByContributor[contributor] = delegate;\n        } else {\n            // Prevent changing another's delegate if already delegated.\n            delegate = oldDelegate;\n        }\n\n        emit Contributed(msg.sender, contributor, amount, delegate);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        // Only allow contributions while the crowdfund is active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n\n        // Check that the contribution amount is within the allowed range.\n        uint96 minContribution_ = minContribution;\n        if (amount < minContribution_) {\n            revert BelowMinimumContributionsError(amount, minContribution_);\n        }\n        uint96 maxContribution_ = maxContribution;\n        if (amount > maxContribution_) {\n            revert AboveMaximumContributionsError(amount, maxContribution_);\n        }\n\n        uint96 newTotalContributions = totalContributions + amount;\n        uint96 maxTotalContributions_ = maxTotalContributions;\n        if (newTotalContributions >= maxTotalContributions_) {\n            totalContributions = maxTotalContributions_;\n\n            // Finalize the crowdfund.\n            // This occurs before refunding excess contribution to act as a\n            // reentrancy guard.\n            _finalize(maxTotalContributions_);\n\n            // Refund excess contribution.\n            uint96 refundAmount = newTotalContributions - maxTotalContributions;\n            if (refundAmount > 0) {\n                amount -= refundAmount;\n                payable(msg.sender).transferEth(refundAmount);\n            }\n        } else {\n            totalContributions = newTotalContributions;\n        }\n\n        // Subtract fee from contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            uint96 feeAmount = (amount * fundingSplitBps_) / 1e4;\n            amount -= feeAmount;\n        }\n\n        // Calculate voting power.\n        votingPower = (amount * exchangeRateBps) / 1e4;\n    }\n\n    function _calculateRefundAmount(uint96 votingPower) internal view returns (uint96 amount) {\n        amount = (votingPower * 1e4) / exchangeRateBps;\n\n        // Add back fee to contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);\n        }\n    }\n\n    function finalize() external {\n        uint96 totalContributions_ = totalContributions;\n\n        // Check that the crowdfund is not already finalized.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc == CrowdfundLifecycle.Active) {\n            // Allow host to finalize crowdfund early if it has reached its minimum goal.\n            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();\n\n            // Check that the crowdfund has reached its minimum goal.\n            uint96 minTotalContributions_ = minTotalContributions;\n            if (totalContributions_ < minTotalContributions_) {\n                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);\n            }\n        } else {\n            // Otherwise only allow finalization if the crowdfund has expired\n            // and been won. Can be finalized by anyone.\n            if (lc != CrowdfundLifecycle.Won) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Finalize the crowdfund.\n        _finalize(totalContributions_);\n    }\n\n    function _finalize(uint96 totalContributions_) internal {\n        // Finalize the crowdfund.\n        delete expiry;\n\n        // Update the party's total voting power.\n        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n        party.increaseTotalVotingPower(newVotingPower);\n\n        // Transfer fee to recipient if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            uint96 feeAmount = (totalContributions_ * fundingSplitBps_) / 1e4;\n            totalContributions_ -= feeAmount;\n            fundingSplitRecipient_.transferEth(feeAmount);\n        }\n\n        // Transfer ETH to the party.\n        payable(address(party)).transferEth(totalContributions_);\n    }\n}"
    }
  ]
}