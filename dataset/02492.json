{
  "Title": "M-17: If borrower or kicker got blacklisted by asset contract their collateral or bond funds can be permanently frozen with the pool",
  "Content": "# Issue M-17: If borrower or kicker got blacklisted by asset contract their collateral or bond funds can be permanently frozen with the pool \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/75 \n\n## Found by \nhyh\n\n## Summary\n\nIt's impossible for borrower or kicker to transfer their otherwise withdraw-able funds to another address. If for some reason borrower or kicker got blacklisted by collateral or quote token contract (correspondingly), these funds will be permanently frozen as now there is no mechanics to move them to another address or specify the recipient for the transfer.\n\n## Vulnerability Detail\n\nIf during the duration of a loan the borrower got blacklisted by collateral asset contract, let's say it is USDC, there is no way to retrieve the collateral. These collateral funds will be permanently locked at the Pool contract balance.\n\nSimilar, although less dangerous as both duration and exposure is less, situation takes place with kicker's balance, that is referenced by `msg.sender` only and so bonds due will be frozen with the pool if that address be blacklisted.\n\nFor lender's case there is a position managing possibility via Pool's transferLPs() and PositionManager's memorializePositions() and reedemPositions(), but for a borrower and a kicker there is no way to transfer funds due ownership or even specify transfer recipient, so the corresponding collateral and bond funds will be frozen with the pool if current beneficiary be blacklisted.\n\n## Impact\n\nPrincipal funds of borrower or kicker being permanently frozen in full, but backlisting is a low probability event, so setting the severity to be medium.\n\n## Code Snippet\n\nWhen it is `vars.pull` BorrowerActions's repayDebt() require `borrowerAddress_ == msg.sender`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/BorrowerActions.sol#L237-L330\n\n```solidity\n    function repayDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_\n    ) external returns (\n        RepayDebtResult memory result_\n    ) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        ...\n\n        if (vars.pull) {\n            // only intended recipient can pull collateral\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // calculate LUP only if it wasn't calculated by repay action\n            if (!vars.repay) result_.newLup = _lup(deposits_, result_.poolDebt);\n\n            uint256 encumberedCollateral = borrower.t0Debt != 0 ? Maths.wdiv(vars.borrowerDebt, result_.newLup) : 0;\n\n            if (borrower.collateral - encumberedCollateral < collateralAmountToPull_) revert InsufficientCollateral();\n\n            // stamp borrower t0Np when pull collateral action\n            vars.stampT0Np = true;\n\n            borrower.collateral    -= collateralAmountToPull_;\n            result_.poolCollateral -= collateralAmountToPull_;\n        }\n```\n\nThen funds are being sent in ERC20Pool and ERC721Pool to `msg.sender` with no option to specify another address:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC20Pool.sol#L184-L230\n\n```solidity\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        ...\n        collateralAmountToPull_     = _roundToScale(collateralAmountToPull_,     _bucketCollateralDust(0));\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            ...\n        );\n\n        ...\n        if (collateralAmountToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferCollateral(msg.sender, collateralAmountToPull_);\n        }\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L194-L238\n\n```solidity\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 noOfNFTsToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            ...\n        );\n\n        ...\n        if (noOfNFTsToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferFromPoolToAddress(msg.sender, borrowerTokenIds[msg.sender], noOfNFTsToPull_);\n        }\n    }\n```\n\nThe same issue takes place in withdrawBonds() as `msg.sender` can be blacklisted in between kicking and withdrawing:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L318-L327\n\n```solidity\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - reset kicker's claimable accumulator\n     */\n    function withdrawBonds() external {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n        auctions.kickers[msg.sender].claimable = 0;\n        _transferQuoteToken(msg.sender, claimable);\n    }\n```\n\nI.e. if as of time of kicking `msg.sender` wasn't blacklisted, but they were added to blacklist before `auctions.kickers[msg.sender].claimable` were withdrawn, it will be permanently locked on the Pool's balance.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding the `recipient` argument to the repayDebt() and withdrawBonds() functions, so the balance beneficiary `msg.sender` can specify what address should receive the funds, for example:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L318-L327\n\n```solidity\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - reset kicker's claimable accumulator\n     */\n-   function withdrawBonds() external {\n+   function withdrawBonds(address recipient) external {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n        auctions.kickers[msg.sender].claimable = 0;\n-       _transferQuoteToken(msg.sender, claimable);\n+       _transferQuoteToken(recipient, claimable);\n    }\n```\n\nThis will also help for the situation when NFT collateral was put in by a contract borrower without `onERC721Received` implementation, so repayDebt() initiated `_transferNFT() -> safeTransferFrom()` call will fail for `msg.sender` and the ability to use a recipient become crucial.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/libraries/external/BorrowerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    LoansState,\n    PoolState\n}                   from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    DrawDebtResult,\n    RepayDebtResult\n}                   from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _feeRate,\n    _priceAt,\n    _isCollateralized\n}                           from '../helpers/PoolHelper.sol';\nimport { _revertOnMinDebt } from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\nimport { Auctions } from './Auctions.sol';\n\n/**\n    @title  BorrowerActions library\n    @notice External library containing logic for for pool actors:\n            - Borrowers: pledge collateral and draw debt; repay debt and pull collateral\n */\nlibrary BorrowerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    struct DrawDebtLocalVars {\n        uint256 borrowerDebt; // [WAD] borrower's accrued debt\n        uint256 debtChange;   // [WAD] additional debt resulted from draw debt action\n        bool    inAuction;    // true if loan is auctioned\n        uint256 lupId;        // id of new LUP\n        bool    stampT0Np;    // true if loan's t0 neutral price should be restamped (when drawing debt or pledge settles auction)\n    }\n    struct RepayDebtLocalVars {\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        bool    inAuction;             // true if loan still in auction after repay, false otherwise\n        uint256 newLup;                // [WAD] LUP after repay debt action\n        bool    pull;                  // true if pull action\n        bool    repay;                 // true if repay action\n        bool    stampT0Np;             // true if loan's t0 neutral price should be restamped (when repay settles auction or pull collateral)\n        uint256 t0DebtInAuctionChange; // [WAD] t0 change amount of debt after repayment\n        uint256 t0RepaidDebt;          // [WAD] t0 debt repaid\n    }\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error BorrowerNotSender();\n    error BorrowerUnderCollateralized();\n    error InsufficientCollateral();\n    error LimitIndexReached();\n    error NoDebt();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolBorrowerActions` and `IERC721PoolBorrowerActions` for descriptions\n     *  @dev    write state:\n     *              - Auctions._settleAuction:\n     *                  - _removeAuction:\n     *                      - decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *                      - decrement auctions count accumulator\n     *                      - decrement auctions.totalBondEscrowed accumulator\n     *                      - update auction queue state\n     *              - Loans.update:\n     *                  - _upsert:\n     *                      - insert or update loan in loans array\n     *                  - remove:\n     *                      - remove loan from loans array\n     *                  - update borrower in address => borrower mapping\n     *  @dev    reverts on:\n     *              - borrower not sender BorrowerNotSender()\n     *              - borrower debt less than pool min debt AmountLTMinDebt()\n     *              - limit price reached LimitIndexReached()\n     *              - borrower cannot draw more debt BorrowerUnderCollateralized()\n     *  @dev    emit events:\n     *              - Auctions._settleAuction:\n     *                  - AuctionNFTSettle or AuctionSettle\n     */\n    function drawDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external returns (\n        DrawDebtResult memory result_\n    ) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        result_.poolDebt       = poolState_.debt;\n        result_.newLup         = _lup(deposits_, result_.poolDebt);\n        result_.poolCollateral = poolState_.collateral;\n\n        DrawDebtLocalVars memory vars;\n\n        vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n        // pledge collateral to pool\n        if (collateralToPledge_ != 0) {\n            // add new amount of collateral to pledge to borrower balance\n            borrower.collateral  += collateralToPledge_;\n\n            // load loan's auction state\n            vars.inAuction = _inAuction(auctions_, borrowerAddress_);\n            // if loan is auctioned and becomes collateralized by newly pledged collateral then settle auction\n            if (\n                vars.inAuction &&\n                _isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)\n            ) {\n                // borrower becomes collateralized\n                vars.inAuction = false;\n                vars.stampT0Np = true;  // stamp borrower t0Np when exiting from auction\n\n                result_.settledAuction = true;\n\n                // remove debt from pool accumulator and settle auction\n                result_.t0DebtInAuctionChange = borrower.t0Debt;\n\n                // settle auction and update borrower's collateral with value after settlement\n                result_.remainingCollateral = Auctions._settleAuction(\n                    auctions_,\n                    buckets_,\n                    deposits_,\n                    borrowerAddress_,\n                    borrower.collateral,\n                    poolState_.poolType\n                );\n\n                borrower.collateral = result_.remainingCollateral;\n            }\n\n            // add new amount of collateral to pledge to pool balance\n            result_.poolCollateral += collateralToPledge_;\n        }\n\n        // borrow against pledged collateral\n        // check both values to enable an intentional 0 borrow loan call to update borrower's loan state\n        if (amountToBorrow_ != 0 || limitIndex_ != 0) {\n            // only intended recipient can borrow quote\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // add origination fee to the amount to borrow and add to borrower's debt\n            vars.debtChange = Maths.wmul(amountToBorrow_, _feeRate(poolState_.rate) + Maths.WAD);\n\n            vars.borrowerDebt += vars.debtChange;\n\n            // check that drawing debt doesn't leave borrower debt under min debt amount\n            _revertOnMinDebt(loans_, result_.poolDebt, vars.borrowerDebt, poolState_.quoteDustLimit);\n\n            // add debt change to pool's debt\n            result_.poolDebt += vars.debtChange;\n\n            // determine new lup index and revert if borrow happens at a price higher than the specified limit (lower index than lup index)\n            vars.lupId = _lupIndex(deposits_, result_.poolDebt);\n            if (vars.lupId > limitIndex_) revert LimitIndexReached();\n\n            // calculate new lup and check borrow action won't push borrower into a state of under-collateralization\n            // this check also covers the scenario when loan is already auctioned\n            result_.newLup = _priceAt(vars.lupId);\n\n            if (!_isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)) {\n                revert BorrowerUnderCollateralized();\n            }\n\n            // stamp borrower t0Np when draw debt\n            vars.stampT0Np = true;\n\n            result_.t0DebtChange = Maths.wdiv(vars.debtChange, poolState_.inflator);\n\n            borrower.t0Debt += result_.t0DebtChange;\n        }\n\n        // update loan state\n        Loans.update(\n            loans_,\n            auctions_,\n            deposits_,\n            borrower,\n            borrowerAddress_,\n            vars.borrowerDebt,\n            poolState_.rate,\n            result_.newLup,\n            vars.inAuction,\n            vars.stampT0Np\n        );\n    }\n\n    /**\n     *  @notice See `IERC20PoolBorrowerActions` and `IERC721PoolBorrowerActions` for descriptions\n     *  @dev    write state:\n     *              - Auctions._settleAuction:\n     *                  - _removeAuction:\n     *                      - decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *                      - decrement auctions count accumulator\n     *                      - decrement auctions.totalBondEscrowed accumulator\n     *                      - update auction queue state\n     *              - Loans.update:\n     *                  - _upsert:\n     *                      - insert or update loan in loans array\n     *                  - remove:\n     *                      - remove loan from loans array\n     *                  - update borrower in address => borrower mapping\n     *  @dev    reverts on:\n     *              - no debt to repay NoDebt()\n     *              - borrower debt less than pool min debt AmountLTMinDebt()\n     *              - borrower not sender BorrowerNotSender()\n     *              - not enough collateral to pull InsufficientCollateral()\n     *  @dev    emit events:\n     *              - Auctions._settleAuction:\n     *                  - AuctionNFTSettle or AuctionSettle\n     */\n    function repayDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_\n    ) external returns (\n        RepayDebtResult memory result_\n    ) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        RepayDebtLocalVars memory vars;\n\n        vars.repay        = maxQuoteTokenAmountToRepay_ != 0;\n        vars.pull         = collateralAmountToPull_ != 0;\n        vars.borrowerDebt = Maths.wmul(borrower.t0Debt, poolState_.inflator);\n\n        result_.poolDebt       = poolState_.debt;\n        result_.poolCollateral = poolState_.collateral;\n\n        if (vars.repay) {\n            if (borrower.t0Debt == 0) revert NoDebt();\n\n            if (maxQuoteTokenAmountToRepay_ == type(uint256).max) {\n                result_.t0RepaidDebt = borrower.t0Debt;\n            } else {\n                result_.t0RepaidDebt = Maths.min(\n                    borrower.t0Debt,\n                    Maths.wdiv(maxQuoteTokenAmountToRepay_, poolState_.inflator)\n                );\n            }\n\n            result_.quoteTokenToRepay = Maths.wmul(result_.t0RepaidDebt, poolState_.inflator);\n\n            result_.poolDebt -= result_.quoteTokenToRepay;\n            vars.borrowerDebt -= result_.quoteTokenToRepay;\n\n            // check that paying the loan doesn't leave borrower debt under min debt amount\n            _revertOnMinDebt(loans_, result_.poolDebt, vars.borrowerDebt, poolState_.quoteDustLimit);\n\n            result_.newLup = _lup(deposits_, result_.poolDebt);\n            vars.inAuction = _inAuction(auctions_, borrowerAddress_);\n\n            if (vars.inAuction) {\n                if (_isCollateralized(vars.borrowerDebt, borrower.collateral, result_.newLup, poolState_.poolType)) {\n                    // borrower becomes re-collateralized\n                    vars.inAuction = false;\n                    vars.stampT0Np = true;  // stamp borrower t0Np when exiting from auction\n\n                    result_.settledAuction = true;\n\n                    // remove entire borrower debt from pool auctions debt accumulator\n                    result_.t0DebtInAuctionChange = borrower.t0Debt;\n\n                    // settle auction and update borrower's collateral with value after settlement\n                    result_.remainingCollateral = Auctions._settleAuction(\n                        auctions_,\n                        buckets_,\n                        deposits_,\n                        borrowerAddress_,\n                        borrower.collateral,\n                        poolState_.poolType\n                    );\n\n                    borrower.collateral = result_.remainingCollateral;\n                } else {\n                    // partial repay, remove only the paid debt from pool auctions debt accumulator\n                    result_.t0DebtInAuctionChange = result_.t0RepaidDebt;\n                }\n            }\n\n            borrower.t0Debt -= result_.t0RepaidDebt;\n        }\n\n        if (vars.pull) {\n            // only intended recipient can pull collateral\n            if (borrowerAddress_ != msg.sender) revert BorrowerNotSender();\n\n            // calculate LUP only if it wasn't calculated by repay action\n            if (!vars.repay) result_.newLup = _lup(deposits_, result_.poolDebt);\n\n            uint256 encumberedCollateral = borrower.t0Debt != 0 ? Maths.wdiv(vars.borrowerDebt, result_.newLup) : 0;\n\n            if (borrower.collateral - encumberedCollateral < collateralAmountToPull_) revert InsufficientCollateral();\n\n            // stamp borrower t0Np when pull collateral action\n            vars.stampT0Np = true;\n\n            borrower.collateral    -= collateralAmountToPull_;\n            result_.poolCollateral -= collateralAmountToPull_;\n        }\n\n        // calculate LUP if repay is called with 0 amount\n        if (!vars.repay && !vars.pull) {\n            result_.newLup = _lup(deposits_, result_.poolDebt);\n        }\n\n        // update loan state\n        Loans.update(\n            loans_,\n            auctions_,\n            deposits_,\n            borrower,\n            borrowerAddress_,\n            vars.borrowerDebt,\n            poolState_.rate,\n            result_.newLup,\n            vars.inAuction,\n            vars.stampT0Np\n        );\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     *  @notice Returns true if borrower is in auction.\n     *  @dev    Used to accuratley increment and decrement t0DebtInAuction.\n     *  @param  borrower_ Borrower address to check auction status for.\n     *  @return  active_ Boolean, based on if borrower is in auction.\n     */\n    function _inAuction(\n        AuctionsState storage auctions_,\n        address borrower_\n    ) internal view returns (bool) {\n        return auctions_.liquidations[borrower_].kickTime != 0;\n    }\n\n    function _lupIndex(\n        DepositsState storage deposits_,\n        uint256 debt_\n    ) internal view returns (uint256) {\n        return Deposits.findIndexOfSum(deposits_, debt_);\n    }\n\n    function _lup(\n        DepositsState storage deposits_,\n        uint256 debt_\n    ) internal view returns (uint256) {\n        return _priceAt(_lupIndex(deposits_, debt_));\n    }\n\n}"
    },
    {
      "filename": "contracts/src/ERC20Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }    from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { \n    IERC20Pool,\n    IERC20PoolBorrowerActions,\n    IERC20PoolImmutables,\n    IERC20PoolLenderActions\n}                              from './interfaces/pool/erc20/IERC20Pool.sol';\nimport { IERC20Taker }         from './interfaces/pool/erc20/IERC20Taker.sol';\n\nimport {\n    IPoolLenderActions,\n    IPoolLiquidationActions,\n    IERC20Token\n}                            from './interfaces/pool/IPool.sol';\nimport {\n    IERC3156FlashBorrower,\n    IERC3156FlashLender\n}                            from './interfaces/pool/IERC3156FlashLender.sol';\n\nimport {\n    DrawDebtResult,\n    BucketTakeResult,\n    RepayDebtResult,\n    SettleParams,\n    TakeResult\n}                    from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState } from './interfaces/pool/commons/IPoolState.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport {\n    _getCollateralDustPricePrecisionAdjustment,\n    _roundToScale,\n    _roundUpToScale\n}                                               from './libraries/helpers/PoolHelper.sol';\nimport { _revertIfAuctionClearable }            from './libraries/helpers/RevertsHelper.sol';\n\nimport { Loans }    from './libraries/internal/Loans.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Maths }    from './libraries/internal/Maths.sol';\n\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { Auctions }        from './libraries/external/Auctions.sol';\n\n/**\n *  @title  ERC20 Pool contract\n *  @notice Entrypoint of ERC20 Pool actions for pool actors:\n *          - Lenders: add, remove and move quote tokens; transfer LPs\n *          - Borrowers: draw and repay debt\n *          - Traders: add, remove and move quote tokens; add and remove collateral\n *          - Kickers: kick undercollateralized loans; settle auctions; claim bond rewards\n *          - Bidders: take auctioned collateral\n *          - Reserve purchasers: start auctions; take reserves\n *          - Flash borrowers: initiate flash loans on quote tokens and collateral\n *  @dev    Contract is FlashloanablePool with flash loan logic.\n *  @dev    Contract is base Pool with logic to handle ERC20 collateral.\n *  @dev    Calls logic from external PoolCommons, LenderActions, BorrowerActions and Auctions libraries.\n */\ncontract ERC20Pool is FlashloanablePool, IERC20Pool {\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant COLLATERAL_SCALE = 93;\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC20Pool\n    function initialize(\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC20PoolImmutables\n    function collateralScale() external pure override returns (uint256) {\n        return _getArgUint256(COLLATERAL_SCALE);\n    }\n\n    /// @inheritdoc IERC20Pool\n    function bucketCollateralDust(uint256 bucketIndex) external pure override returns (uint256) {\n        return _bucketCollateralDust(bucketIndex);\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - increment poolBalances.pledgedCollateral accumulator\n     *          - increment poolBalances.t0Debt accumulator\n     *  @dev emit events:\n     *          - DrawDebt\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure the borrower is not credited with a fractional amount of collateral smaller than the token scale\n        collateralToPledge_ = _roundToScale(collateralToPledge_, _bucketCollateralDust(0));\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            collateralToPledge_\n        );\n\n        emit DrawDebt(borrowerAddress_, amountToBorrow_, collateralToPledge_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (collateralToPledge_ != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n            poolBalances.pledgedCollateral += collateralToPledge_;\n\n            // move collateral from sender to pool\n            _transferCollateralFrom(msg.sender, collateralToPledge_);\n        }\n\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt += result.t0DebtChange;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC20PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     *  @dev emit events:\n     *          - RepayDebt\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 collateralAmountToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // ensure accounting is performed using the appropriate token scale\n        maxQuoteTokenAmountToRepay_ = _roundToScale(maxQuoteTokenAmountToRepay_, _getArgUint256(QUOTE_SCALE));\n        collateralAmountToPull_     = _roundToScale(collateralAmountToPull_,     _bucketCollateralDust(0));\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            collateralAmountToPull_\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, collateralAmountToPull_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt -= result.t0RepaidDebt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (collateralAmountToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferCollateral(msg.sender, collateralAmountToPull_);\n        }\n    }\n\n    /************************************/\n    /*** Flashloan External Functions ***/\n    /************************************/\n\n    /// @inheritdoc FlashloanablePool\n    function flashLoan(\n        IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external override(IERC3156FlashLender, FlashloanablePool) nonReentrant returns (bool) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS)) return _flashLoanQuoteToken(receiver_, token_, amount_, data_);\n\n        if (token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            _transferCollateral(address(receiver_), amount_);\n\n            if (receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) !=\n                keccak256(\"ERC3156FlashBorrower.onFlashLoan\")) revert FlashloanCallbackFailed();\n\n            _transferCollateralFrom(address(receiver_), amount_);\n            return true;\n        }\n\n        revert FlashloanUnavailableForToken();\n    }\n\n    /// @inheritdoc FlashloanablePool\n    function flashFee(\n        address token_,\n        uint256\n    ) external pure override(IERC3156FlashLender, FlashloanablePool) returns (uint256) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS)) return 0;\n        revert FlashloanUnavailableForToken();\n    }\n\n    /// @inheritdoc FlashloanablePool\n    function maxFlashLoan(\n        address token_\n    ) external view override(IERC3156FlashLender, FlashloanablePool) returns (uint256 maxLoan_) {\n        if (token_ == _getArgAddress(QUOTE_ADDRESS) || token_ == _getArgAddress(COLLATERAL_ADDRESS)) {\n            maxLoan_ = IERC20Token(token_).balanceOf(address(this));\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC20PoolLenderActions\n     *  @dev reverts on:\n     *          - DustAmountNotExceeded()\n     *  @dev emit events:\n     *          - AddCollateral\n     */\n    function addCollateral(\n        uint256 amountToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // revert if the dust amount was not exceeded, but round on the scale amount\n        if (amountToAdd_ != 0 && amountToAdd_ < _bucketCollateralDust(index_)) revert DustAmountNotExceeded();\n        amountToAdd_ = _roundToScale(amountToAdd_, _getArgUint256(COLLATERAL_SCALE));\n\n        bucketLPs_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            amountToAdd_,\n            index_\n        );\n\n        emit AddCollateral(msg.sender, index_, amountToAdd_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferCollateralFrom(msg.sender, amountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev emit events:\n     *          - RemoveCollateral\n     */\n    function removeCollateral(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round the collateral amount appropriately based on token precision\n        maxAmount_ = _roundToScale(maxAmount_, _getArgUint256(COLLATERAL_SCALE));\n\n        (collateralAmount_, lpAmount_) = LenderActions.removeMaxCollateral(\n            buckets,\n            deposits,\n            maxAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, collateralAmount_, lpAmount_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move collateral from pool to lender\n        _transferCollateral(msg.sender, collateralAmount_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();\n\n        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        (\n            ,\n            ,\n            uint256 collateralSettled,\n            uint256 t0DebtSettled\n        ) = Auctions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            SettleParams({\n                borrower:    borrowerAddress_,\n                reserves:    (assets > liabilities) ? (assets - liabilities) : 0,\n                inflator:    poolState.inflator,\n                bucketDepth: maxDepth_,\n                poolType:    poolState.poolType\n            })\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt            -= t0DebtSettled;\n        poolBalances.t0DebtInAuction   -= t0DebtSettled;\n        poolBalances.pledgedCollateral -= collateralSettled;\n\n        // update pool interest rate state\n        poolState.debt       -= Maths.wmul(t0DebtSettled, poolState.inflator);\n        poolState.collateral -= collateralSettled;\n        _updateInterestState(poolState, _lup(poolState.debt));\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function take(\n        address        borrowerAddress_,\n        uint256        collateral_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 collateralDust = _bucketCollateralDust(0);\n\n        // round requested collateral to an amount which can actually be transferred\n        collateral_ = _roundToScale(collateral_, collateralDust);\n\n        TakeResult memory result = Auctions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            collateral_,\n            collateralDust\n        );\n        // round quote token up to cover the cost of purchasing the collateral\n        result.quoteTokenAmount = _roundUpToScale(result.quoteTokenAmount, _getArgUint256(QUOTE_SCALE));\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       =  result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        _transferCollateral(callee_, result.collateralAmount);\n\n        if (data_.length != 0) {\n            IERC20Taker(callee_).atomicSwapCallback(\n                result.collateralAmount / _getArgUint256(COLLATERAL_SCALE), \n                result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        _transferQuoteTokenFrom(callee_, result.quoteTokenAmount);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        BucketTakeResult memory result = Auctions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            _bucketCollateralDust(0)\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;"
    }
  ]
}