{
  "Title": "[M-02] Users can use the protocol freely without paying any fees by calling the `DecentEthRouter::bridgeWithPayload()` function directly.",
  "Content": "\n### The execution flow of `bridgeAndExecute` function\n\nTo understand the vulnerability, we need to understand the execution flow of the [`bridgeAndExecute()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L259-L274) function, at least a small portion of it.\n\nWhen the user wants to bridge tokens of him and execute an action on another chain, he will need to execute the [`UTB::bridgeAndExecute()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L259-L274) function.\n\nSuppose the user exists in Polygon, he has USDC and he wants to mint an NFT in Optimism which costs 1000 DAI. What will happen is that the protocol will first, in polygon, swap the user's USDC with WETH, then bridge the WETH to Optimism, then swap the WETH with DAI and then execute the arbitrary call the user wants to execute, which will be to mint the NFT in exchange for the resulting 1000 DAI from the post-bridge swap operation.\n\nWhen this function is called, the following will happen:\n\n1.  Step 1: When the user calls the [`UTB::bridgeAndExecute()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L259-L274) function, it will do three things: first, it will collect the fees by calling the [`UTBFeeCollector:collectFees()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L228-L251) function, secondly, it will conduct the pre-bridge swap operation (occurs in the source destination), it will swap the user's USDC to WETH. thirdly, it will modify the `swapInstructions` which the user supplied to prepare for the post-bridge swap. Then after all of the 3 operations take place, it will invoke the [`UTB::callBridge()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L282-L301) function.\n\n2.  Step 2: In the [`UTB::callBridge()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L282-L301) function, some approvals are granted to the `DecentBridgeAdapter` contract, and then the it will invoke the function [`DecentBridgeAdapter::bridge()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/bridge_adapters/DecentBridgeAdapter.sol#L81-L125) in the `DecentBridgeAdapter` contract.\n\n3.  Step 3: In the [`DecentBridgeAdapter::bridge()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/bridge_adapters/DecentBridgeAdapter.sol#L81-L125) function, some data like the post-bridge swap payload and bridge payload (what to execute when the TX reaches destination) will be encoded, then it will reach out to the [`DecentEthRouter`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol) contract and invoke the function [`DecentEthRouter::bridgeWithPayload`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L197-L215)\n\n4.  Step 4: When the execution reaches the [`DecentEthRouter::bridgeWithPayload`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L197-L215) function, an internal function containing the actual logic, with the same name will also be called: [`DecentEthRouter::_bridgeWithPayload`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L148-L194)\n\n    **Note: Notice that the \\`DecentEthRouter::bridgeWithPayload() function isn't protected by any modifiers, any body can call it directly**\n\n5.  Step 5: When the execution gets inside the [`DecentEthRouter::_bridgeWithPayload`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L148-L194) function, the function will prepare the `LzCallParams` for the layerzero call and the actual bridging will happen when the [`dcntEth::sendAndCall`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L185) function is actually invoked.\n\n6.  Step 6: The bridging process kickstarts and the execution flow is continued in the destination chain.\n\nHere is a graph of the execution flow\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2024-01-decent-findings/issues/647).*\n\n### The vulnerability & PoC\n\nThe vulnerability is that any user can conduct the pre-bridge swap operation using uniswap by himself, prepare the right calldata and call the function [`DecentEthRouter::bridgeWithPayload`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L197-L215) directly (since anybody can call it), doing so will allow the user to bypass the fee collection process completely.\n\nThe fee collection as mentioned in the previously detailed execution flow, happens when the user first calls the [`bridgeAndExecute()`](https://github.com/code-423n4/2024-01-decent/blob/main/src/UTB.sol#L259-L274) function. But as I mentioned, nothing really forces him to start execution from there. All that function does is collect the fees, conduct the pre-bridge swap operation and prepare the proper call data. The user can conduct the pre-bridge swap operation himself, prepare the proper calldata and talk directly to the [`DecentEthRouter::bridgeWithPayload`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L197-L215) function, effecitvely bypassing fee collection.\n\nAnybody can call the [`DecentEthRouter::bridgeWithPayload`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L197-L215) directly, and the protocol has no mechanism of determining whether or not the user is using the protocol with or without paying fees.\n\n### Impact\n\nUsers can use the protocol without paying any fees.\n\n### Recommended Mitigation Steps\n\nTighten up the access control on the [`DecentEthRouter::bridgeWithPayload`](https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L197-L215) function. Allow only the DecentBridgeAdapter to call the bridgeWithPayload() function.\n\n***\n\nFound & reported by: sin1st3r\\_\\_\n\nTeam: NPCsCorp\n\n**[0xsomeone (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-decent-findings/issues/647#issuecomment-1924205171):**\n > The Warden has demonstrated that it is possible to bypass Decent fees when performing bridging operations by directly interacting with the `DecentEthRouter`. This is indeed a valid concern and has been confirmed by the Sponsor.\n> \n> I believe a severity of medium is more appropriate given that uncaptured profit is solely affected.\n\n**[wkantaros (Decent) confirmed](https://github.com/code-423n4/2024-01-decent-findings/issues/647#issuecomment-1942666822)**\n\n_Note: For full discussion, see [here](https://github.com/code-423n4/2024-01-decent-findings/issues/647)._\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/UTB.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SwapParams} from \"./swappers/SwapParams.sol\";\nimport {IUTBExecutor} from \"./interfaces/IUTBExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {IUTBFeeCollector} from \"./interfaces/IUTBFeeCollector.sol\";\nimport {IBridgeAdapter} from \"./interfaces/IBridgeAdapter.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport {SwapInstructions, FeeStructure, BridgeInstructions, SwapAndExecuteInstructions} from \"./CommonTypes.sol\";\n\n\ncontract UTB is Owned {\n    constructor() Owned(msg.sender) {}\n\n    IUTBExecutor executor;\n    IUTBFeeCollector feeCollector;\n    IWETH wrapped;\n    mapping(uint8 => address) public swappers;\n    mapping(uint8 => address) public bridgeAdapters;\n\n    /**\n     * @dev Sets the executor.\n     * @param _executor The address of the executor.\n     */\n    function setExecutor(address _executor) public onlyOwner {\n        executor = IUTBExecutor(_executor);\n    }\n\n    /**\n     * @dev Sets the wrapped native token.\n     * @param _wrapped The address of the wrapped token.\n     */\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = IWETH(_wrapped);\n    }\n\n    /**\n     * @dev Sets the fee collector.\n     * @param _feeCollector The address of the fee collector.\n     */\n    function setFeeCollector(address payable _feeCollector) public onlyOwner {\n        feeCollector = IUTBFeeCollector(_feeCollector);\n    }\n\n    /**\n     * @dev Performs a swap with a default setting to retrieve ERC20.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions\n    ) private returns (address tokenOut, uint256 amountOut) {\n        return performSwap(swapInstructions, true);\n    }\n\n    /**\n     * @dev Performs a swap with the requested swapper and swap calldata.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param retrieveTokenIn Flag indicating whether to transfer ERC20 for the swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions,\n        bool retrieveTokenIn\n    ) private returns (address tokenOut, uint256 amountOut) {\n        ISwapper swapper = ISwapper(swappers[swapInstructions.swapperId]);\n\n        SwapParams memory swapParams = abi.decode(\n            swapInstructions.swapPayload,\n            (SwapParams)\n        );\n\n        if (swapParams.tokenIn == address(0)) {\n            require(msg.value >= swapParams.amountIn, \"not enough native\");\n            wrapped.deposit{value: swapParams.amountIn}();\n            swapParams.tokenIn = address(wrapped);\n            swapInstructions.swapPayload = swapper.updateSwapParams(\n                swapParams,\n                swapInstructions.swapPayload\n            );\n        } else if (retrieveTokenIn) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n        }\n\n        IERC20(swapParams.tokenIn).approve(\n            address(swapper),\n            swapParams.amountIn\n        );\n\n        (tokenOut, amountOut) = swapper.swap(swapInstructions.swapPayload);\n\n        if (tokenOut == address(0)) {\n            wrapped.withdraw(amountOut);\n        }\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param instructions The token swap data and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function swapAndExecute(\n        SwapAndExecuteInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n    {\n        _swapAndExecute(\n            instructions.swapInstructions,\n            instructions.target,\n            instructions.paymentOperator,\n            instructions.payload,\n            instructions.refund\n        );\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function _swapAndExecute(\n        SwapInstructions memory swapInstructions,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) private {\n        (address tokenOut, uint256 amountOut) = performSwap(swapInstructions);\n        if (tokenOut == address(0)) {\n            executor.execute{value: amountOut}(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        } else {\n            IERC20(tokenOut).approve(address(executor), amountOut);\n            executor.execute(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        }\n    }\n\n    /**\n     * @dev Performs the pre bridge swap and modifies the post bridge swap to utilize the bridged amount.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function swapAndModifyPostBridge(\n        BridgeInstructions memory instructions\n    )\n        private\n        returns (\n            uint256 amount2Bridge,\n            BridgeInstructions memory updatedInstructions\n        )\n    {\n        (address tokenOut, uint256 amountOut) = performSwap(\n            instructions.preBridge\n        );\n\n        SwapParams memory newPostSwapParams = abi.decode(\n            instructions.postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        newPostSwapParams.amountIn = IBridgeAdapter(\n            bridgeAdapters[instructions.bridgeId]\n        ).getBridgedAmount(amountOut, tokenOut, newPostSwapParams.tokenIn);\n\n        updatedInstructions = instructions;\n\n        updatedInstructions.postBridge.swapPayload = ISwapper(swappers[\n            instructions.postBridge.swapperId\n        ]).updateSwapParams(\n            newPostSwapParams,\n            instructions.postBridge.swapPayload\n        );\n\n        amount2Bridge = amountOut;\n    }\n\n    /**\n     * @dev Checks if the bridge token is native, and approves the bridge adapter to transfer ERC20 if required.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param amt2Bridge The amount of the bridge token being transferred to the bridge adapter.\n     */\n    function approveAndCheckIfNative(\n        BridgeInstructions memory instructions,\n        uint256 amt2Bridge\n    ) private returns (bool) {\n        IBridgeAdapter bridgeAdapter = IBridgeAdapter(bridgeAdapters[instructions.bridgeId]);\n        address bridgeToken = bridgeAdapter.getBridgeToken(\n            instructions.additionalArgs\n        );\n        if (bridgeToken != address(0)) {\n            IERC20(bridgeToken).approve(address(bridgeAdapter), amt2Bridge);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Transfers fees from the sender to UTB, and finally to the Fee Collector.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param packedInfo The fees and swap instructions which were used to generate the signature.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    modifier retrieveAndCollectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes calldata signature\n    ) {\n        if (address(feeCollector) != address(0)) {\n            uint value = 0;\n            if (fees.feeToken != address(0)) {\n                IERC20(fees.feeToken).transferFrom(\n                    msg.sender,\n                    address(this),\n                    fees.feeAmount\n                );\n                IERC20(fees.feeToken).approve(\n                    address(feeCollector),\n                    fees.feeAmount\n                );\n            } else {\n                value = fees.feeAmount;\n            }\n            feeCollector.collectFees{value: value}(fees, packedInfo, signature);\n        }\n        _;\n    }\n\n    /**\n     * @dev Bridges funds in native or ERC20 and a payment transaction payload to the destination chain\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function bridgeAndExecute(\n        BridgeInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n        returns (bytes memory)\n    {\n        (\n            uint256 amt2Bridge,\n            BridgeInstructions memory updatedInstructions\n        ) = swapAndModifyPostBridge(instructions);\n        return callBridge(amt2Bridge, fees.bridgeFee, updatedInstructions);\n    }\n\n    /**\n     * @dev Calls the bridge adapter to bridge funds, and approves the bridge adapter to transfer ERC20 if required.\n     * @param amt2Bridge The amount of the bridge token being bridged via the bridge adapter.\n     * @param bridgeFee The fee being transferred to the bridge adapter and finally to the bridge.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function callBridge(\n        uint256 amt2Bridge,\n        uint bridgeFee,\n        BridgeInstructions memory instructions\n    ) private returns (bytes memory) {\n        bool native = approveAndCheckIfNative(instructions, amt2Bridge);\n        return\n            IBridgeAdapter(bridgeAdapters[instructions.bridgeId]).bridge{\n                value: bridgeFee + (native ? amt2Bridge : 0)\n            }(\n                amt2Bridge,\n                instructions.postBridge,\n                instructions.dstChainId,\n                instructions.target,\n                instructions.paymentOperator,\n                instructions.payload,\n                instructions.additionalArgs,\n                instructions.refund\n            );\n    }\n\n    /**\n     * @dev Receives funds from the bridge adapter, executes a swap, and executes a payment transaction.\n     * @param postBridge The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function receiveFromBridge(\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) public {\n        _swapAndExecute(postBridge, target, paymentOperator, payload, refund);\n    }\n\n    /**\n     * @dev Registers and maps a swapper to a swapper ID.\n     * @param swapper The address of the swapper.\n     */\n    function registerSwapper(address swapper) public onlyOwner {\n        ISwapper s = ISwapper(swapper);\n        swappers[s.getId()] = swapper;\n    }\n\n    /**\n     * @dev Registers and maps a bridge adapter to a bridge adapter ID.\n     * @param bridge The address of the bridge adapter.\n     */\n    function registerBridge(address bridge) public onlyOwner {\n        IBridgeAdapter b = IBridgeAdapter(bridge);\n        bridgeAdapters[b.getId()] = bridge;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/UTB.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SwapParams} from \"./swappers/SwapParams.sol\";\nimport {IUTBExecutor} from \"./interfaces/IUTBExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {IUTBFeeCollector} from \"./interfaces/IUTBFeeCollector.sol\";\nimport {IBridgeAdapter} from \"./interfaces/IBridgeAdapter.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport {SwapInstructions, FeeStructure, BridgeInstructions, SwapAndExecuteInstructions} from \"./CommonTypes.sol\";\n\n\ncontract UTB is Owned {\n    constructor() Owned(msg.sender) {}\n\n    IUTBExecutor executor;\n    IUTBFeeCollector feeCollector;\n    IWETH wrapped;\n    mapping(uint8 => address) public swappers;\n    mapping(uint8 => address) public bridgeAdapters;\n\n    /**\n     * @dev Sets the executor.\n     * @param _executor The address of the executor.\n     */\n    function setExecutor(address _executor) public onlyOwner {\n        executor = IUTBExecutor(_executor);\n    }\n\n    /**\n     * @dev Sets the wrapped native token.\n     * @param _wrapped The address of the wrapped token.\n     */\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = IWETH(_wrapped);\n    }\n\n    /**\n     * @dev Sets the fee collector.\n     * @param _feeCollector The address of the fee collector.\n     */\n    function setFeeCollector(address payable _feeCollector) public onlyOwner {\n        feeCollector = IUTBFeeCollector(_feeCollector);\n    }\n\n    /**\n     * @dev Performs a swap with a default setting to retrieve ERC20.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions\n    ) private returns (address tokenOut, uint256 amountOut) {\n        return performSwap(swapInstructions, true);\n    }\n\n    /**\n     * @dev Performs a swap with the requested swapper and swap calldata.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param retrieveTokenIn Flag indicating whether to transfer ERC20 for the swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions,\n        bool retrieveTokenIn\n    ) private returns (address tokenOut, uint256 amountOut) {\n        ISwapper swapper = ISwapper(swappers[swapInstructions.swapperId]);\n\n        SwapParams memory swapParams = abi.decode(\n            swapInstructions.swapPayload,\n            (SwapParams)\n        );\n\n        if (swapParams.tokenIn == address(0)) {\n            require(msg.value >= swapParams.amountIn, \"not enough native\");\n            wrapped.deposit{value: swapParams.amountIn}();\n            swapParams.tokenIn = address(wrapped);\n            swapInstructions.swapPayload = swapper.updateSwapParams(\n                swapParams,\n                swapInstructions.swapPayload\n            );\n        } else if (retrieveTokenIn) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n        }\n\n        IERC20(swapParams.tokenIn).approve(\n            address(swapper),\n            swapParams.amountIn\n        );\n\n        (tokenOut, amountOut) = swapper.swap(swapInstructions.swapPayload);\n\n        if (tokenOut == address(0)) {\n            wrapped.withdraw(amountOut);\n        }\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param instructions The token swap data and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function swapAndExecute(\n        SwapAndExecuteInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n    {\n        _swapAndExecute(\n            instructions.swapInstructions,\n            instructions.target,\n            instructions.paymentOperator,\n            instructions.payload,\n            instructions.refund\n        );\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function _swapAndExecute(\n        SwapInstructions memory swapInstructions,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) private {\n        (address tokenOut, uint256 amountOut) = performSwap(swapInstructions);\n        if (tokenOut == address(0)) {\n            executor.execute{value: amountOut}(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        } else {\n            IERC20(tokenOut).approve(address(executor), amountOut);\n            executor.execute(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        }\n    }\n\n    /**\n     * @dev Performs the pre bridge swap and modifies the post bridge swap to utilize the bridged amount.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function swapAndModifyPostBridge(\n        BridgeInstructions memory instructions\n    )\n        private\n        returns (\n            uint256 amount2Bridge,\n            BridgeInstructions memory updatedInstructions\n        )\n    {\n        (address tokenOut, uint256 amountOut) = performSwap(\n            instructions.preBridge\n        );\n\n        SwapParams memory newPostSwapParams = abi.decode(\n            instructions.postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        newPostSwapParams.amountIn = IBridgeAdapter(\n            bridgeAdapters[instructions.bridgeId]\n        ).getBridgedAmount(amountOut, tokenOut, newPostSwapParams.tokenIn);\n\n        updatedInstructions = instructions;\n\n        updatedInstructions.postBridge.swapPayload = ISwapper(swappers[\n            instructions.postBridge.swapperId\n        ]).updateSwapParams(\n            newPostSwapParams,\n            instructions.postBridge.swapPayload\n        );\n\n        amount2Bridge = amountOut;\n    }\n\n    /**\n     * @dev Checks if the bridge token is native, and approves the bridge adapter to transfer ERC20 if required.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param amt2Bridge The amount of the bridge token being transferred to the bridge adapter.\n     */\n    function approveAndCheckIfNative(\n        BridgeInstructions memory instructions,\n        uint256 amt2Bridge\n    ) private returns (bool) {\n        IBridgeAdapter bridgeAdapter = IBridgeAdapter(bridgeAdapters[instructions.bridgeId]);\n        address bridgeToken = bridgeAdapter.getBridgeToken(\n            instructions.additionalArgs\n        );\n        if (bridgeToken != address(0)) {\n            IERC20(bridgeToken).approve(address(bridgeAdapter), amt2Bridge);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Transfers fees from the sender to UTB, and finally to the Fee Collector.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param packedInfo The fees and swap instructions which were used to generate the signature.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    modifier retrieveAndCollectFees(\n        FeeStructure calldata fees,\n        bytes memory packedInfo,\n        bytes calldata signature\n    ) {\n        if (address(feeCollector) != address(0)) {\n            uint value = 0;\n            if (fees.feeToken != address(0)) {\n                IERC20(fees.feeToken).transferFrom(\n                    msg.sender,\n                    address(this),\n                    fees.feeAmount\n                );\n                IERC20(fees.feeToken).approve(\n                    address(feeCollector),\n                    fees.feeAmount\n                );\n            } else {\n                value = fees.feeAmount;\n            }\n            feeCollector.collectFees{value: value}(fees, packedInfo, signature);\n        }\n        _;\n    }\n\n    /**\n     * @dev Bridges funds in native or ERC20 and a payment transaction payload to the destination chain\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function bridgeAndExecute(\n        BridgeInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n        returns (bytes memory)\n    {\n        (\n            uint256 amt2Bridge,\n            BridgeInstructions memory updatedInstructions\n        ) = swapAndModifyPostBridge(instructions);\n        return callBridge(amt2Bridge, fees.bridgeFee, updatedInstructions);\n    }\n\n    /**\n     * @dev Calls the bridge adapter to bridge funds, and approves the bridge adapter to transfer ERC20 if required.\n     * @param amt2Bridge The amount of the bridge token being bridged via the bridge adapter.\n     * @param bridgeFee The fee being transferred to the bridge adapter and finally to the bridge.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function callBridge(\n        uint256 amt2Bridge,\n        uint bridgeFee,\n        BridgeInstructions memory instructions\n    ) private returns (bytes memory) {\n        bool native = approveAndCheckIfNative(instructions, amt2Bridge);\n        return\n            IBridgeAdapter(bridgeAdapters[instructions.bridgeId]).bridge{\n                value: bridgeFee + (native ? amt2Bridge : 0)\n            }(\n                amt2Bridge,\n                instructions.postBridge,\n                instructions.dstChainId,\n                instructions.target,\n                instructions.paymentOperator,\n                instructions.payload,\n                instructions.additionalArgs,\n                instructions.refund\n            );\n    }\n\n    /**\n     * @dev Receives funds from the bridge adapter, executes a swap, and executes a payment transaction.\n     * @param postBridge The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function receiveFromBridge(\n        SwapInstructions memory postBridge,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) public {\n        _swapAndExecute(postBridge, target, paymentOperator, payload, refund);\n    }\n\n    /**\n     * @dev Registers and maps a swapper to a swapper ID.\n     * @param swapper The address of the swapper.\n     */\n    function registerSwapper(address swapper) public onlyOwner {\n        ISwapper s = ISwapper(swapper);\n        swappers[s.getId()] = swapper;\n    }\n\n    /**\n     * @dev Registers and maps a bridge adapter to a bridge adapter ID.\n     * @param bridge The address of the bridge adapter.\n     */\n    function registerBridge(address bridge) public onlyOwner {\n        IBridgeAdapter b = IBridgeAdapter(bridge);\n        bridgeAdapters[b.getId()] = bridge;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/UTB.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SwapParams} from \"./swappers/SwapParams.sol\";\nimport {IUTBExecutor} from \"./interfaces/IUTBExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {IUTBFeeCollector} from \"./interfaces/IUTBFeeCollector.sol\";\nimport {IBridgeAdapter} from \"./interfaces/IBridgeAdapter.sol\";\nimport {ISwapper} from \"./interfaces/ISwapper.sol\";\nimport {SwapInstructions, FeeStructure, BridgeInstructions, SwapAndExecuteInstructions} from \"./CommonTypes.sol\";\n\n\ncontract UTB is Owned {\n    constructor() Owned(msg.sender) {}\n\n    IUTBExecutor executor;\n    IUTBFeeCollector feeCollector;\n    IWETH wrapped;\n    mapping(uint8 => address) public swappers;\n    mapping(uint8 => address) public bridgeAdapters;\n\n    /**\n     * @dev Sets the executor.\n     * @param _executor The address of the executor.\n     */\n    function setExecutor(address _executor) public onlyOwner {\n        executor = IUTBExecutor(_executor);\n    }\n\n    /**\n     * @dev Sets the wrapped native token.\n     * @param _wrapped The address of the wrapped token.\n     */\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = IWETH(_wrapped);\n    }\n\n    /**\n     * @dev Sets the fee collector.\n     * @param _feeCollector The address of the fee collector.\n     */\n    function setFeeCollector(address payable _feeCollector) public onlyOwner {\n        feeCollector = IUTBFeeCollector(_feeCollector);\n    }\n\n    /**\n     * @dev Performs a swap with a default setting to retrieve ERC20.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions\n    ) private returns (address tokenOut, uint256 amountOut) {\n        return performSwap(swapInstructions, true);\n    }\n\n    /**\n     * @dev Performs a swap with the requested swapper and swap calldata.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param retrieveTokenIn Flag indicating whether to transfer ERC20 for the swap.\n     */\n    function performSwap(\n        SwapInstructions memory swapInstructions,\n        bool retrieveTokenIn\n    ) private returns (address tokenOut, uint256 amountOut) {\n        ISwapper swapper = ISwapper(swappers[swapInstructions.swapperId]);\n\n        SwapParams memory swapParams = abi.decode(\n            swapInstructions.swapPayload,\n            (SwapParams)\n        );\n\n        if (swapParams.tokenIn == address(0)) {\n            require(msg.value >= swapParams.amountIn, \"not enough native\");\n            wrapped.deposit{value: swapParams.amountIn}();\n            swapParams.tokenIn = address(wrapped);\n            swapInstructions.swapPayload = swapper.updateSwapParams(\n                swapParams,\n                swapInstructions.swapPayload\n            );\n        } else if (retrieveTokenIn) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n        }\n\n        IERC20(swapParams.tokenIn).approve(\n            address(swapper),\n            swapParams.amountIn\n        );\n\n        (tokenOut, amountOut) = swapper.swap(swapInstructions.swapPayload);\n\n        if (tokenOut == address(0)) {\n            wrapped.withdraw(amountOut);\n        }\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param instructions The token swap data and payment transaction payload.\n     * @param fees The bridge fee in native, as well as utb fee token and amount.\n     * @param signature The ECDSA signature to verify the fee structure.\n     */\n    function swapAndExecute(\n        SwapAndExecuteInstructions calldata instructions,\n        FeeStructure calldata fees,\n        bytes calldata signature\n    )\n        public\n        payable\n        retrieveAndCollectFees(fees, abi.encode(instructions, fees), signature)\n    {\n        _swapAndExecute(\n            instructions.swapInstructions,\n            instructions.target,\n            instructions.paymentOperator,\n            instructions.payload,\n            instructions.refund\n        );\n    }\n\n    /**\n     * @dev Swaps currency from the incoming to the outgoing token and executes a transaction with payment.\n     * @param swapInstructions The swapper ID and calldata to execute a swap.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA which initiated the transaction.\n     */\n    function _swapAndExecute(\n        SwapInstructions memory swapInstructions,\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address payable refund\n    ) private {\n        (address tokenOut, uint256 amountOut) = performSwap(swapInstructions);\n        if (tokenOut == address(0)) {\n            executor.execute{value: amountOut}(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        } else {\n            IERC20(tokenOut).approve(address(executor), amountOut);\n            executor.execute(\n                target,\n                paymentOperator,\n                payload,\n                tokenOut,\n                amountOut,\n                refund\n            );\n        }\n    }\n\n    /**\n     * @dev Performs the pre bridge swap and modifies the post bridge swap to utilize the bridged amount.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     */\n    function swapAndModifyPostBridge(\n        BridgeInstructions memory instructions\n    )\n        private\n        returns (\n            uint256 amount2Bridge,\n            BridgeInstructions memory updatedInstructions\n        )\n    {\n        (address tokenOut, uint256 amountOut) = performSwap(\n            instructions.preBridge\n        );\n\n        SwapParams memory newPostSwapParams = abi.decode(\n            instructions.postBridge.swapPayload,\n            (SwapParams)\n        );\n\n        newPostSwapParams.amountIn = IBridgeAdapter(\n            bridgeAdapters[instructions.bridgeId]\n        ).getBridgedAmount(amountOut, tokenOut, newPostSwapParams.tokenIn);\n\n        updatedInstructions = instructions;\n\n        updatedInstructions.postBridge.swapPayload = ISwapper(swappers[\n            instructions.postBridge.swapperId\n        ]).updateSwapParams(\n            newPostSwapParams,\n            instructions.postBridge.swapPayload\n        );\n\n        amount2Bridge = amountOut;\n    }\n\n    /**\n     * @dev Checks if the bridge token is native, and approves the bridge adapter to transfer ERC20 if required.\n     * @param instructions The bridge data, token swap data, and payment transaction payload.\n     * @param amt2Bridge The amount of the bridge token being transferred to the bridge adapter.\n     */\n    function approveAndCheckIfNative(\n        BridgeInstructions memory instructions,\n        uint256 amt2Bridge\n    ) private returns (bool) {\n        IBridgeAdapter bridgeAdapter = IBridgeAdapter(bridgeAdapters[instructions.bridgeId]);\n        address bridgeToken = bridgeAdapter.getBridgeToken(\n            instructions.additionalArgs\n        );\n        if (bridgeToken != address(0)) {\n            IERC20"
    }
  ]
}