{
  "Title": "[H-08] `MasterChef.sol` Users won't be able to receive the `concur` rewards",
  "Content": "_Submitted by WatchPug, also found by hickuphh3 and leastwood_\n\nAccording to:\n\n*   [README](https://github.com/code-423n4/2022-02-concur#-masterchef)\n*   Implementation of `deposit()`: [/contracts/MasterChef.sol#L157-L180](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L157-L180)\n\nMasterChef is only recording the deposited amount in the states, it's not actually holding the `depositToken`.\n\n`depositToken` won't be transferred from `_msgSender()` to the MasterChef contract.\n\nTherefore, in `updatePool()` L140 `lpSupply = pool.depositToken.balanceOf(address(this))` will always be `0`. And the `updatePool()` will be returned at L147.\n\n[MasterChef.sol#L135-L154](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154)\n\n```solidity\nfunction updatePool(uint _pid) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    if (block.number <= pool.lastRewardBlock) {\n        return;\n    }\n    uint lpSupply = pool.depositToken.balanceOf(address(this));\n    if (lpSupply == 0 || pool.allocPoint == 0) {\n        pool.lastRewardBlock = block.number;\n        return;\n    }\n    if(block.number >= endBlock) {\n        pool.lastRewardBlock = block.number;\n        return;\n    }        \n\n    uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n    uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n    pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n    pool.lastRewardBlock = block.number;\n}\n```\n\n### Impact\n\n*   The MasterChef contract fail to implement the most essential function;\n*   Users won't be able to receive any `Concur` rewards from MasterChef;\n\n### Recommended Mitigation Steps\n\nConsider creating a receipt token to represent the invested token and use the receipt tokens in MasterChef.\n\nSee: <https://github.com/convex-eth/platform/blob/883ffd4ebcaee12e64d18f75bdfe404bcd900616/contracts/contracts/Booster.sol#L272-L277>\n\n**[ryuheimat (Concur) confirmed](https://github.com/code-423n4/2022-02-concur-findings/issues/200)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-concur-findings/issues/200#issuecomment-1100908295):**\n > The warden has identified a logical flaw in the `Masterchef` contract.\n> \n> The contract is expecting `lpTokens` (deposited in another depositor contract) to be in the `Masterchef` at the time in which `updatePool` is called.\n> \n> However, due to the fact that the `lpToken` will be somewhere else, a more appropriate check would be to ask the depositor contract for the total supply.\n> \n> Given this finding, the Masterchef contract will always reward 0 tokens.\n> \n> This should classify the finding as Medium Severity (loss of Yield).\n> \n> However, because the finding shows how this can happen reliably, and effectively breaks the purpose of the contract, I believe High Severity to be more appropriate.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-02-concur-finance-contest",
  "Code": [
    {
      "filename": "contracts/MasterChef.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount; // How many tokens the user has provided.\n        uint128 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of RADSs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.\n        uint lastRewardBlock; // Last block number that distribution occurs.\n        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.\n        uint16 depositFeeBP; // Deposit fee in basis points\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid; // pid mapped to token\n    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block\n    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint public startBlock;\n    uint public endBlock; // The block number when mining starts.\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function addDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = true;\n    }\n\n    function removeDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = false;\n    }\n\n    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {\n        require(_token != address(0), \"zero address\");\n        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocationPoints);\n        require(pid[_token] == 0, \"already registered\"); // pid starts from 0\n        poolInfo.push(\n            PoolInfo({\n                depositToken: IERC20(_token),\n                allocPoint: _allocationPoints,\n                lastRewardBlock: lastRewardBlock,\n                accConcurPerShare: 0,\n                depositFeeBP: _depositFee\n            })\n        );\n        pid[_token] = poolInfo.length - 1;\n    }\n\n    function poolLength() external view returns (uint) {\n        return poolInfo.length;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    // View function to see pending [concur] on frontend.\n    function pendingConcur(uint _pid, address _user) external view returns (uint) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint accConcurPerShare = pool.accConcurPerShare;\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        }\n        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint length = poolInfo.length;\n        for (uint _pid = 0; _pid < length; ++_pid) {\n            updatePool(_pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit tokens for [concur] allocation.  \n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    // Withdraw tokens\n    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        require(user.amount > 0, \"MasterChef: nothing to withdraw\");\n        require(user.amount >= _amount, \"MasterChef: withdraw not allowed\");\n        updatePool(_pid);\n\n        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n        if(pending > 0) {\n            safeConcurTransfer(_recipient, pending);\n        }\n        if (_amount > 0) {\n            user.amount = SafeCast.toUint128(user.amount - _amount);\n        }\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Withdraw(_recipient, _pid, _amount);\n    }\n\n    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}"
    },
    {
      "filename": "contracts/MasterChef.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\ncontract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount; // How many tokens the user has provided.\n        uint128 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of RADSs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.\n        uint lastRewardBlock; // Last block number that distribution occurs.\n        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.\n        uint16 depositFeeBP; // Deposit fee in basis points\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid; // pid mapped to token\n    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block\n    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint public startBlock;\n    uint public endBlock; // The block number when mining starts.\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function addDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = true;\n    }\n\n    function removeDepositor(address _depositor) external onlyOwner {\n        isDepositor[_depositor] = false;\n    }\n\n    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {\n        require(_token != address(0), \"zero address\");\n        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocationPoints);\n        require(pid[_token] == 0, \"already registered\"); // pid starts from 0\n        poolInfo.push(\n            PoolInfo({\n                depositToken: IERC20(_token),\n                allocPoint: _allocationPoints,\n                lastRewardBlock: lastRewardBlock,\n                accConcurPerShare: 0,\n                depositFeeBP: _depositFee\n            })\n        );\n        pid[_token] = poolInfo.length - 1;\n    }\n\n    function poolLength() external view returns (uint) {\n        return poolInfo.length;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    // View function to see pending [concur] on frontend.\n    function pendingConcur(uint _pid, address _user) external view returns (uint) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint accConcurPerShare = pool.accConcurPerShare;\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        }\n        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint length = poolInfo.length;\n        for (uint _pid = 0; _pid < length; ++_pid) {\n            updatePool(_pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit tokens for [concur] allocation.  \n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    // Withdraw tokens\n    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        require(user.amount > 0, \"MasterChef: nothing to withdraw\");\n        require(user.amount >= _amount, \"MasterChef: withdraw not allowed\");\n        updatePool(_pid);\n\n        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n        if(pending > 0) {\n            safeConcurTransfer(_recipient, pending);\n        }\n        if (_amount > 0) {\n            user.amount = SafeCast.toUint128(user.amount - _amount);\n        }\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Withdraw(_recipient, _pid, _amount);\n    }\n\n    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Booster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\ncontract Booster{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant registry = address(0x0000000022D53366457F9d5E68Ec105046FC4383);\n    uint256 public constant distributionAddressId = 4;\n    address public constant voteOwnership = address(0xE478de485ad2fe566d49342Cbd03E49ed7DB3356);\n    address public constant voteParameter = address(0xBCfF8B0b9419b9A88c44546519b1e909cF330399);\n\n    uint256 public lockIncentive = 1000; //incentive to crv stakers\n    uint256 public stakerIncentive = 450; //incentive to native token stakers\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    uint256 public platformFee = 0; //possible fee to build treasury\n    uint256 public constant MaxFees = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //cvx rewards\n    address public lockRewards; //cvxCrv rewards(crv)\n    address public lockFees; //cvxCrv vecrv fees\n    address public feeDistro;\n    address public feeToken;\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n\n    constructor(address _staker, address _minter) public {\n        isShutdown = false;\n        staker = _staker;\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        feeDistro = address(0); //address(0xA464e6DCda8AC41e03616F95f4BC98a13b8922Dc);\n        feeToken = address(0); //address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        treasury = address(0);\n        minter = _minter;\n    }\n\n\n    /// SETTER SECTION ///\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n    }\n\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n    }\n\n    function setFactories(address _rfactory, address _sfactory, address _tfactory) external {\n        require(msg.sender == owner, \"!auth\");\n        \n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if(rewardFactory == address(0)){\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n        }\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n    }\n\n    function setArbitrator(address _arb) external {\n        require(msg.sender==owner, \"!auth\");\n        rewardArbitrator = _arb;\n    }\n\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender==voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n    }\n\n    function setRewardContracts(address _rewards, address _stakerRewards) external {\n        require(msg.sender == owner, \"!auth\");\n        \n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if(lockRewards == address(0)){\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n        }\n    }\n\n    // Set reward token and claim contract, get from Curve's registry\n    function setFeeInfo() external {\n        require(msg.sender==feeManager, \"!auth\");\n        \n        feeDistro = IRegistry(registry).get_address(distributionAddressId);\n        address _feeToken = IFeeDistro(feeDistro).token();\n        if(feeToken != _feeToken){\n            //create a new reward contract for the new token\n            lockFees = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken,lockRewards,address(this));\n            feeToken = _feeToken;\n        }\n    }\n\n    function setFees(uint256 _lockFees, uint256 _stakerFees, uint256 _callerFees, uint256 _platform) external{\n        require(msg.sender==feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform);\n        require(total <= MaxFees, \">MaxFees\");\n\n        //values must be within certain ranges     \n        if(_lockFees >= 1000 && _lockFees <= 1500\n            && _stakerFees >= 300 && _stakerFees <= 600\n            && _callerFees >= 10 && _callerFees <= 100\n            && _platform <= 200){\n            lockIncentive = _lockFees;\n            stakerIncentive = _stakerFees;\n            earmarkIncentive = _callerFees;\n            platformFee = _platform;\n        }\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender==feeManager, \"!auth\");\n        treasury = _treasury;\n    }\n\n    /// END SETTER SECTION ///\n\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool){\n        require(msg.sender==poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0),\"!param\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for crv rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateCrvRewards(pid,token);\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(pid,_gauge,staker,_stashVersion);\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                crvRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if(stash != address(0)){\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash,true);\n            IRewardFactory(rewardFactory).setAccess(stash,true);\n        }\n        return true;\n    }\n\n    //shutdown pool\n    function shutdownPool(uint256 _pid) external returns(bool){\n        require(msg.sender==poolManager, \"!auth\");\n        PoolInfo storage pool = poolInfo[_pid];\n\n        //withdraw from gauge\n        try IStaker(staker).withdrawAll(pool.lptoken,pool.gauge){\n        }catch{}\n\n        pool.shutdown = true;\n        gaugeMap[pool.gauge] = false;\n        return true;\n    }\n\n    //shutdown this contract.\n    //  unstake and pull all lp tokens to this address\n    //  only allow withdrawals\n    function shutdownSystem() external{\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for(uint i=0; i < poolInfo.length; i++){\n            PoolInfo storage pool = poolInfo[i];\n            if (pool.shutdown) continue;\n\n            address token = pool.lptoken;\n            address gauge = pool.gauge;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token,gauge){\n                pool.shutdown = true;\n            }catch{}\n        }\n    }\n\n\n    //deposit lp tokens and stake\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){\n        require(!isShutdown,\"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);\n\n        //stake\n        address gauge = pool.gauge;\n        require(gauge != address(0),\"!gauge setting\");\n        IStaker(staker).deposit(lptoken,gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = pool.stash;\n        if(stash != address(0)){\n            IStash(stash).stashRewards();\n        }\n\n        address token = pool.token;\n        if(_stake){\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this),_amount);\n            address rewardContract = pool.crvRewards;\n            IERC20(token).safeApprove(rewardContract,0);\n            IERC20(token).safeApprove(rewardContract,_amount);\n            IRewards(rewardContract).stakeFor(msg.sender,_amount);\n        }else{\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender,_amount);\n        }\n\n        \n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns(bool){\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid,balance,_stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n        address gauge = pool.gauge;\n\n        //remove lp balance\n        address token = pool.token;\n        ITokenMinter(token).burn(_from,_amount);\n\n        //pull from gauge if not shutdown\n        // if shutdown tokens will be in this contract\n        if (!pool.shutdown) {\n            IStaker(staker).withdraw(lptoken,gauge, _amount);\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown since stashes wont have access\n        address stash = pool.stash;\n        if(stash != address(0) && !isShutdown && !pool.shutdown){\n            IStash(stash).stashRewards();\n        }\n        \n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns(bool){\n        _withdraw(_pid,_amount,msg.sender,msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns(bool){\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    //allow reward contracts to send here and withdraw to user\n    function withdrawTo(uint256 _pid, uint256 _amount, address _to) external returns(bool){\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == rewardContract,\"!auth\");\n\n        _withdraw(_pid,_amount,msg.sender,_to);\n        return true;\n    }\n\n\n    //delegate address votes on dao\n    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool){\n        require(msg.sender == voteDelegate, \"!auth\");\n        require(_votingAddress == voteOwnership || _votingAddress == voteParameter, \"!voteAddr\");\n        \n        IStaker(staker).vote(_voteId,_votingAddress,_support);\n        return true;\n    }\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool){\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        for(uint256 i = 0; i < _gauge.length; i++){\n            IStaker(staker).voteGaugeWeight(_gauge[i],_weight[i]);\n        }\n        return true;\n    }\n\n    function claimRewards(uint256 _pid, address _gauge) external returns(bool){\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash,\"!auth\");\n\n        IStaker(staker).claimRewards(_gauge);\n        return true;\n    }\n\n    function setGaugeRedirect(uint256 _pid) external returns(bool){\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash,\"!auth\");\n        address gauge = poolInfo[_pid].gauge;\n        bytes memory data = abi.encodeWithSelector(bytes4(keccak256(\"set_rewards_receiver(address)\")), stash);\n        IStaker(staker).execute(gauge,uint256(0),data);\n        return true;\n    }\n\n    //claim crv and extra rewards and disperse to reward contracts\n    function _earmarkRewards(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        address gauge = pool.gauge;\n\n        //claim crv\n        IStaker(staker).claimCrv(gauge);\n\n        //check if there are extra rewards\n        address stash = pool.stash;\n        if(stash != address(0)){\n            //claim extra rewards\n            IStash(stash).claimRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\n        //crv balance\n        uint256 crvBal = IERC20(crv).balanceOf(address(this));\n\n        if (crvBal > 0) {\n            uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);\n            uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);\n            \n            //send treasury\n            if(treasury != address(0) && treasury != address(this) && platformFee > 0){"
    }
  ]
}