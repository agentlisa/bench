{
  "Title": "[05] Empty/Unused Function Parameters",
  "Content": "\nEmpty or unused function parameters should be commented out as a better and declarative way to silence runtime warning messages. As an example, the following function may have these parameters refactored to:\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/LooksRareProxy.sol#L50-L58\n\n```\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes memory /* extraData */,\n        address recipient,\n        bool isAtomic,\n        uint256 /* feeBp */,\n        address /* feeRecipient */\n    ) external payable override {\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/proxies/LooksRareProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {SignatureChecker} from \"../SignatureChecker.sol\";\nimport {IERC721} from \"../../contracts/interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../contracts/interfaces/IERC1155.sol\";\nimport {ILooksRareExchange} from \"@looksrare/contracts-exchange-v1/contracts/interfaces/ILooksRareExchange.sol\";\nimport {OrderTypes} from \"@looksrare/contracts-exchange-v1/contracts/libraries/OrderTypes.sol\";\n\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\nimport {TokenTransferrer} from \"../TokenTransferrer.sol\";\n\n/**\n * @title LooksRareProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from LooksRare\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareProxy is IProxy, TokenRescuer, TokenTransferrer, SignatureChecker {\n    struct OrderExtraData {\n        uint256 makerAskPrice; // Maker ask price, which is not necessarily equal to the taker bid price\n        uint256 minPercentageToAsk; // The maker's minimum % to receive from the sale\n        uint256 nonce; // The maker's nonce\n        address strategy; // LooksRare execution strategy\n    }\n\n    ILooksRareExchange public immutable marketplace;\n    address public immutable aggregator;\n\n    /**\n     * @param _marketplace LooksRareExchange's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = ILooksRareExchange(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute LooksRare NFT sweeps in a single transaction\n     * @dev extraData, feeBp and feeRecipient are not used\n     * @param orders Orders to be executed by LooksRare\n     * @param ordersExtraData Extra data for each order\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes memory,\n        address recipient,\n        bool isAtomic,\n        uint256,\n        address\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        for (uint256 i; i < ordersLength; ) {\n            BasicOrder memory order = orders[i];\n\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n\n            OrderTypes.MakerOrder memory makerAsk;\n            {\n                makerAsk.isOrderAsk = true;\n                makerAsk.signer = order.signer;\n                makerAsk.collection = order.collection;\n                makerAsk.tokenId = order.tokenIds[0];\n                makerAsk.price = orderExtraData.makerAskPrice;\n                makerAsk.amount = order.amounts[0];\n                makerAsk.strategy = orderExtraData.strategy;\n                makerAsk.nonce = orderExtraData.nonce;\n                makerAsk.minPercentageToAsk = orderExtraData.minPercentageToAsk;\n                makerAsk.currency = order.currency;\n                makerAsk.startTime = order.startTime;\n                makerAsk.endTime = order.endTime;\n\n                (bytes32 r, bytes32 s, uint8 v) = _splitSignature(order.signature);\n                makerAsk.v = v;\n                makerAsk.r = r;\n                makerAsk.s = s;\n            }\n\n            OrderTypes.TakerOrder memory takerBid;\n            {\n                takerBid.isOrderAsk = false;\n                takerBid.taker = address(this);\n                takerBid.price = order.price;\n                takerBid.tokenId = makerAsk.tokenId;\n                takerBid.minPercentageToAsk = makerAsk.minPercentageToAsk;\n            }\n\n            _executeSingleOrder(takerBid, makerAsk, recipient, order.collectionType, isAtomic);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _executeSingleOrder(\n        OrderTypes.TakerOrder memory takerBid,\n        OrderTypes.MakerOrder memory makerAsk,\n        address recipient,\n        CollectionType collectionType,\n        bool isAtomic\n    ) private {\n        if (isAtomic) {\n            marketplace.matchAskWithTakerBidUsingETHAndWETH{value: takerBid.price}(takerBid, makerAsk);\n            _transferTokenToRecipient(\n                collectionType,\n                recipient,\n                makerAsk.collection,\n                makerAsk.tokenId,\n                makerAsk.amount\n            );\n        } else {\n            try marketplace.matchAskWithTakerBidUsingETHAndWETH{value: takerBid.price}(takerBid, makerAsk) {\n                _transferTokenToRecipient(\n                    collectionType,\n                    recipient,\n                    makerAsk.collection,\n                    makerAsk.tokenId,\n                    makerAsk.amount\n                );\n            } catch {}\n        }\n    }\n}"
    }
  ]
}