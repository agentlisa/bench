{
  "Title": "[M-06] DoS  due to external call failure",
  "Content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L71-L91><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L113-L119><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L140-L153><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L66-L127><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L60-L106><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/WstEth.sol#L61>\n\n### Impact\n\nWhen `stake()/unstake()/rebalanceToWeights()`, if any one of the derivatives fails to `deposit()/withdraw()`, the whole function will revert, causing DoS. The impacts include:\n\n*   users' fund would be locked for a period.\n*   contract become inoperable until the external call resumes\n\n### Proof of Concept\n\nIn `stake()`, each derivative iteration, `ethPerDerivative()` and `deposit()` will be called:\n\n```solidity\nFile: contracts/SafEth/SafEth.sol\n63:     function stake() external payable {\n\n71:         for (uint i = 0; i < derivativeCount; i++)\n72:             underlyingValue +=\n73:                 (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n74:                     derivatives[i].balance()) /\n75:                 10 ** 18;\n\n84:         for (uint i = 0; i < derivativeCount; i++) {\n\n91:             uint256 depositAmount = derivative.deposit{value: ethAmount}();\n\n```\n\nIn `unstake()`, each derivative is iterated to `withdraw()`:\n\n```solidity\nFile: contracts/SafEth/SafEth.sol\n108:     function unstake(uint256 _safEthAmount) external {\n\n113:         for (uint256 i = 0; i < derivativeCount; i++) {\n\n118:             derivatives[i].withdraw(derivativeAmount);\n119:         }\n```\n\nIn `rebalanceToWeights()`, each derivative is iterated to `withdraw()` and then `deposit()`:\n\n```solidity\n138:     function rebalanceToWeights() external onlyOwner {\n139:         uint256 ethAmountBefore = address(this).balance;\n140:         for (uint i = 0; i < derivativeCount; i++) {\n141:             if (derivatives[i].balance() > 0)\n142:                 derivatives[i].withdraw(derivatives[i].balance());\n143:         }\n\n147:         for (uint i = 0; i < derivativeCount; i++) {\n148:             if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n149:             uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n150:                 totalWeight;\n151:             // Price will change due to slippage\n152:             derivatives[i].deposit{value: ethAmount}();\n153:         }\n\n```\n\nFor each of the current derivatives, there are several different scenarios where the `ethPerDerivative()/deposit()/withdraw()` could fail.\n\n**SfrxEth.sol**\n\n*   `redeem()` could fail due to not enough allowance.\n\n```solidity\nFile: contracts/SafEth/derivatives/SfrxEth.sol\n60:     function withdraw(uint256 _amount) external onlyOwner {\n\n61:         IsFrxEth(SFRX_ETH_ADDRESS).redeem(\n62:             _amount,\n63:             address(this),\n64:             address(this)\n65:         );\n```\n\nBelow is sFrxEth contract code:\n\n```solidity\n// https://etherscan.io/address/0xac3E018457B222d93114458476f3E3416Abbe38F\n// line 691-700\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n```\n\n*   FrxEthEthPool `exchange()` could fail due to `minOut` requirement.\n\n```solidity\nFile: contracts/SafEth/derivatives/SfrxEth.sol\n60:     function withdraw(uint256 _amount) external onlyOwner {\n\n77:         IFrxEthEthPool(FRX_ETH_CRV_POOL_ADDRESS).exchange(\n78:             1,\n79:             0,\n80:             frxEthBalance,\n81:             minOut\n82:         );\n```\n\n*   `deposit()` could fail because `submitAndDeposit()` -> `_submit()` can be paused.\n\n```solidity\nFile: contracts/SafEth/derivatives/SfrxEth.sol\n094:     function deposit() external payable onlyOwner returns \n\n101:         frxETHMinterContract.submitAndDeposit{value: msg.value}(address(this));\n```\n\nBelow is the frxETHMinter contract:\n\n```solidity\n// https://etherscan.io/address/0xbAFA44EFE7901E04E39Dad13167D089C559c1138\n// frxETHMinter.sol: 70-101\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n\n        _submit(address(this));\n\n    }\n\n    function _submit(address recipient) internal nonReentrant {\n\n        require(!submitPaused, \"Submit is paused\");\n\n    }\n\n```\n\nIf `submitPaused` is turned on, this deposit function will revert.\n\n**Reth.sol**\n\n*   `rethAddress()` and `getAddress()`\n\n`rethAddress()` is called in multiple places:\n\n```solidity\nFile: contracts/SafEth/derivatives/Reth.sol\n66:     function rethAddress() private view returns (address) {\n67:         return\n68:             RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(\n69:                 keccak256(\n70:                     abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n71:                 )\n72:             );\n73:     }\n```\n\nBut it could return wrong address or `addr(0)`, since the referred `getAddress()` could return unexpected result. `addressStorage[_key]` can be reset or deleted. Then the whole function call will revert.\n\nBelow is the RocketStorage.sol:\n\n```solidity\n// https://etherscan.io/address/0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46\n// 179-181\n    function getAddress(bytes32 _key) override external view returns (address r) {\n        return addressStorage[_key];\n    }\n\n// 215-217\n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        addressStorage[_key] = _value;\n    }\n\n// 251-253\n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete addressStorage[_key];\n    }    \n```\n\n`rethAddress()` is referred in `withdraw()/deposit()/ethPerDerivative()/balance()`:\n\n```solidity\nFile: contracts/SafEth/derivatives/Reth.sol\n107:     function withdraw(uint256 amount) external onlyOwner {\n108:         RocketTokenRETHInterface(rethAddress()).burn(amount);\n\n156:     function deposit() external payable onlyOwner returns (uint256) {\n\n176:             IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n177:             uint256 amountSwapped = swapExactInputSingleHop(\n178:                 W_ETH_ADDRESS,\n179:                 rethAddress(),\n180:                 500,\n181:                 msg.value,\n182:                 minOut\n183:             );\n\n211:     function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n212:         if (poolCanDeposit(_amount))\n213:             return\n214:                 RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n215:         else return (poolPrice() * 10 ** 18) / (10 ** 18);\n216:     }\n\n221:     function balance() public view returns (uint256) {\n222:         return IERC20(rethAddress()).balanceOf(address(this));\n223:     }\n```\n\n`getAddress()` will also influence `poolCanDeposit()`, which could revert `deposit()` and the view function `ethPerDerivative()`:\n\n```solidity\n120:     function poolCanDeposit(uint256 _amount) private view returns (bool) {\n121:         address rocketDepositPoolAddress = RocketStorageInterface(\n122:             ROCKET_STORAGE_ADDRESS\n123:         ).getAddress(\n124:                 keccak256(\n125:                     abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n126:                 )\n127:             );\n\n156:     function deposit() external payable onlyOwner returns (uint256) {\n\n170:         if (!poolCanDeposit(msg.value)) {\n\n211:     function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n212:         if (poolCanDeposit(_amount))\n```\n\n*   `burn()`\n\nThere is no guarantee that the function `burn()` will succeed.\n\n```solidity\nFile: contracts/SafEth/derivatives/Reth.sol\n107:     function withdraw(uint256 amount) external onlyOwner {\n108:         RocketTokenRETHInterface(rethAddress()).burn(amount);\n```\n\nBecause in Reth contract code below, the execution may fail in several cases:\n\n*   `burn()` -> `getTotalCollateral()` -> `getContractAddress()` -> `getAddress()` might fail due to the same reason above\n*   the `require(ethBalance >= ethAmount)` could fail due to low balance\n*   `burn()` -> `withdrawDepositCollateral()` -> `getContractAddress()`, `withdrawExcessBalance()` both could fail for same reason as above\n*   `msg.sender.transfer()` could fail due to not enough gas (2300 limit)\n\n```solidity\n// https://etherscan.io/address/0xae78736Cd615f374D3085123A210448E74Fc6393\n// RocketTokenRETH.sol: 131-146\n    // Burn rETH for ETH\n    function burn(uint256 _rethAmount) override external {\n        // Check rETH amount\n        require(_rethAmount > 0, \"Invalid token burn amount\");\n        require(balanceOf(msg.sender) >= _rethAmount, \"Insufficient rETH balance\");\n        // Get ETH amount\n        uint256 ethAmount = getEthValue(_rethAmount);\n        // Get & check ETH balance\n        uint256 ethBalance = getTotalCollateral();\n        require(ethBalance >= ethAmount, \"Insufficient ETH balance for exchange\");\n        // Update balance & supply\n        _burn(msg.sender, _rethAmount);\n        // Withdraw ETH from deposit pool if required\n        withdrawDepositCollateral(ethAmount);\n        // Transfer ETH to sender\n        msg.sender.transfer(ethAmount);\n        // Emit tokens burned event\n        emit TokensBurned(msg.sender, _rethAmount, ethAmount, block.timestamp);\n    }\n\n// RocketTokenRETH.sol: 98-101\n    function getTotalCollateral() override public view returns (uint256) {\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        return rocketDepositPool.getExcessBalance().add(address(this).balance);\n    }\n\n// RocketBase.sol: 112-119\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n// RocketTokenRETH.sol: 152-159\n    function withdrawDepositCollateral(uint256 _ethRequired) private {\n        // Check rETH contract balance\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance >= _ethRequired) { return; }\n        // Withdraw\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance));\n    }\n```\n\n**WstEth.sol**\n\nStEthEthPool function `exchange()` could fail due to `minOut` requirement.\n\n```solidity\nFile: contracts/SafEth/derivatives/WstEth.sol\n56:     function withdraw(uint256 _amount) external onlyOwner {\n\n60:         uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n```\n\nAs long as any one of the above code failed, the whole `stake()/unstake()/rebalanceToWeights()` will revert, and users' fund would be locked until the external dependency is resolved, the contract will lose the core functionality.\n\n### Recommended Mitigation Steps\n\nUse `try/catch` to skip the failed function call, then the contract will be more robust to unexpected situations. In case of `deposit()`, redistribute the fund into the other derivatives according to the weights might be an option, since re-balance will be done regularly. For `withdraw()`, maybe temporarily record the missed amount, and give the user opportunity to retrieve later.\n\n**[toshiSat (Asymmetry) acknowledged](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/770#issuecomment-1500378678)**\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/770#issuecomment-1500380114):**\n > This is known and expected behavior. We feel like having all-or-nothing failures like this simplify the logic overall and make things safer at the expense of some edge cases where deposit can fail. We can always upgrade the contract if it becomes a problem.\n\n**[Asymmetry commented](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#out-of-scope):**\n> Out of scope for mitigation review. This is as expected.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-03-asymmetry",
  "Code": [
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/SafEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/uniswap/ISwapRouter.sol\";\nimport \"../interfaces/lido/IWStETH.sol\";\nimport \"../interfaces/lido/IstETH.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./SafEthStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Contract that mints/burns and provides owner functions for safETH\n/// @author Asymmetry Finance\ncontract SafEth is\n    Initializable,\n    ERC20Upgradeable,\n    OwnableUpgradeable,\n    SafEthStorage\n{\n    event ChangeMinAmount(uint256 indexed minAmount);\n    event ChangeMaxAmount(uint256 indexed maxAmount);\n    event StakingPaused(bool indexed paused);\n    event UnstakingPaused(bool indexed paused);\n    event SetMaxSlippage(uint256 indexed index, uint256 slippage);\n    event Staked(address indexed recipient, uint ethIn, uint safEthOut);\n    event Unstaked(address indexed recipient, uint ethOut, uint safEthIn);\n    event WeightChange(uint indexed index, uint weight);\n    event DerivativeAdded(\n        address indexed contractAddress,\n        uint weight,\n        uint index\n    );\n    event Rebalanced();\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _tokenName - name of erc20\n        @param _tokenSymbol - symbol of erc20\n    */\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol\n    ) external initializer {\n        ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n        _transferOwnership(msg.sender);\n        minAmount = 5 * 10 ** 17; // initializing with .5 ETH as minimum\n        maxAmount = 200 * 10 ** 18; // initializing with 200 ETH as maximum\n    }\n\n    /**\n        @notice - Stake your ETH into safETH\n        @dev - Deposits into each derivative based on its weight\n        @dev - Mints safEth in a redeemable value which equals to the correct percentage of the total staked value\n    */\n    function stake() external payable {\n        require(pauseStaking == false, \"staking is paused\");\n        require(msg.value >= minAmount, \"amount too low\");\n        require(msg.value <= maxAmount, \"amount too high\");\n\n        uint256 underlyingValue = 0;\n\n        // Getting underlying value in terms of ETH for each derivative\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n        uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n        for (uint i = 0; i < derivativeCount; i++) {\n            uint256 weight = weights[i];\n            IDerivative derivative = derivatives[i];\n            if (weight == 0) continue;\n            uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n            // This is slightly less than ethAmount because slippage\n            uint256 depositAmount = derivative.deposit{value: ethAmount}();\n            uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n            totalStakeValueEth += derivativeReceivedEthValue;\n        }\n        // mintAmount represents a percentage of the total assets in the system\n        uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n        _mint(msg.sender, mintAmount);\n        emit Staked(msg.sender, msg.value, mintAmount);\n    }\n\n    /**\n        @notice - Unstake your safETH into ETH\n        @dev - unstakes a percentage of safEth based on its total value\n        @param _safEthAmount - amount of safETH to unstake into ETH\n    */\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        _burn(msg.sender, _safEthAmount);\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n        // solhint-disable-next-line\n        (bool sent, ) = address(msg.sender).call{value: ethAmountToWithdraw}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n        emit Unstaked(msg.sender, ethAmountToWithdraw, _safEthAmount);\n    }\n\n    /**\n        @notice - Rebalance each derivative to resemble the weight set for it\n        @dev - Withdraws all derivative and re-deposit them to have the correct weights\n        @dev - Depending on the balance of the derivative this could cause bad slippage\n        @dev - If weights are updated then it will slowly change over time to the correct weight distribution\n        @dev - Probably not going to be used often, if at all\n    */\n    function rebalanceToWeights() external onlyOwner {\n        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n        uint256 ethAmountAfter = address(this).balance;\n        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @dev - Weights are only in regards to each other, total weight changes with this function\n        @dev - If you want exact weights either do the math off chain or reset all existing derivates to the weights you want\n        @dev - Weights are approximate as it will slowly change as people stake\n        @param _derivativeIndex - index of the derivative you want to update the weight\n        @param _weight - new weight for this derivative.\n    */\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n\n    /**\n        @notice - Adds new derivative to the index fund\n        @param _contractAddress - Address of the derivative contract launched by AF\n        @param _weight - new weight for this derivative. \n    */\n    function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n        derivatives[derivativeCount] = IDerivative(_contractAddress);\n        weights[derivativeCount] = _weight;\n        derivativeCount++;\n\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit DerivativeAdded(_contractAddress, _weight, derivativeCount);\n    }\n\n    /**\n        @notice - Sets the max slippage for a certain derivative index\n        @param _derivativeIndex - index of the derivative you want to update the slippage\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n        derivatives[_derivativeIndex].setMaxSlippage(_slippage);\n        emit SetMaxSlippage(_derivativeIndex, _slippage);\n    }\n\n    /**\n        @notice - Sets the minimum amount a user is allowed to stake\n        @param _minAmount - amount to set as minimum stake value\n    */\n    function setMinAmount(uint256 _minAmount) external onlyOwner {\n        minAmount = _minAmount;\n        emit ChangeMinAmount(minAmount);\n    }\n\n    /**\n        @notice - Owner only function that sets the maximum amount a user is allowed to stake\n        @param _maxAmount - amount to set as maximum stake value\n    */\n    function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n        maxAmount = _maxAmount;\n        emit ChangeMaxAmount(maxAmount);\n    }\n\n    /**\n        @notice - Owner only function that Enables/Disables the stake function\n        @param _pause - true disables staking / false enables staking\n    */\n    function setPauseStaking(bool _pause) external onlyOwner {\n        pauseStaking = _pause;\n        emit StakingPaused(pauseStaking);\n    }\n\n    /**\n        @notice - Owner only function that enables/disables the unstake function\n        @param _pause - true disables unstaking / false enables unstaking\n    */\n    function setPauseUnstaking(bool _pause) external onlyOwner {\n        pauseUnstaking = _pause;\n        emit UnstakingPaused(pauseUnstaking);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/SafEth/derivatives/Reth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../interfaces/IDerivative.sol\";\nimport \"../../interfaces/frax/IsFrxEth.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/rocketpool/RocketStorageInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketTokenRETHInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDepositPoolInterface.sol\";\nimport \"../../interfaces/rocketpool/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../interfaces/uniswap/ISwapRouter.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Factory.sol\";\nimport \"../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\n/// @title Derivative contract for rETH\n/// @author Asymmetry Finance\ncontract Reth is IDerivative, Initializable, OwnableUpgradeable {\n    address public constant ROCKET_STORAGE_ADDRESS =\n        0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46;\n    address public constant W_ETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant UNISWAP_ROUTER =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address public constant UNI_V3_FACTORY =\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    uint256 public maxSlippage;\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Function to initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n        @param _owner - owner of the contract which handles stake/unstake\n    */\n    function initialize(address _owner) external initializer {\n        _transferOwnership(_owner);\n        maxSlippage = (1 * 10 ** 16); // 1%\n    }\n\n    /**\n        @notice - Return derivative name\n    */\n    function name() public pure returns (string memory) {\n        return \"RocketPool\";\n    }\n\n    /**\n        @notice - Owner only function to set max slippage for derivative\n        @param _slippage - new slippage amount in wei\n    */\n    function setMaxSlippage(uint256 _slippage) external onlyOwner {\n        maxSlippage = _slippage;\n    }\n\n    /**\n        @notice - Get rETH addre"
    }
  ]
}