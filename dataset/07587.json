{
  "Title": "[M-01] evm_hooks ignores some important errors",
  "Content": "\n<https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L49>\n\n<https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L101-L135>\n\n### Impact\n\nSome contracts and some Turnstile tokens (NFTs) will not be able to receive CSR fees forever.\n\n### Proof of Concept\n\nIn evm_hooks.go, the [PostTxProcessing](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L49) will call `h.processEvents(ctx, receipt)` to handle `Register` and `Assign` events from Turnstile contract first:\n\n    h.processEvents(ctx, receipt)\n\nNotice that the `processEvents` function does not return any error.\n\nHowever, it is possible for [processEvents](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1bee73a6871c6243f92a007a0b80e4c61/Canto/x/csr/keeper/evm_hooks.go#L101-L135) to encounter an error:\n\n    func (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n      ...\n      for _, log := range receipt.Logs {\n        ...\n        if log.Address == turnstileAddress {\n          ...\n          switch event.Name {\n          case types.TurnstileEventRegister:\n            err = h.k.RegisterEvent(ctx, log.Data)\n          case types.TurnstileEventUpdate:\n            err = h.k.UpdateEvent(ctx, log.Data)\n          }\n          if err != nil {\n            h.k.Logger(ctx).Error(err.Error())\n            return\n          }\n        }\n      }\n    }\n\nAccording to the above implementation of `processEvents`, it will process all the events emitted by the transaction one by one. If one of them encounters an error, it will return directly without any error, and any subsequent unprocessed events will be ignored.\n\nSuppose we have a transaction containing the following events (by contract calls):\n\n1.  Register C1 with token1\n2.  Register C2 with token2\n3.  Assign C3 with token1\n\nIf `RegisterEvent()` returns an error when handling the first event, then all of the events will not be handled because `processEvents()` will return after logging the error.\n\nAnd `PostTxProcessing()` continues to execute normally because it is unaware of the error.\n\nAccording to the current implementation of [`RegisterEvent()`](https://github.com/code-423n4/2022-11-canto/blob/main/Canto/x/csr/keeper/event_handler.go#L16) and [`UpdateEvent`](https://github.com/code-423n4/2022-11-canto/blob/main/Canto/x/csr/keeper/event_handler.go#L62), they are both easy to encounter an error. Like `register()` using a recipient that doesn't exist yet.\n\nAs a result, none of the C1, C2, C3 contracts will be able to receive any CSR fee because they are not recorded in csr store.\n\nContracts C1, C2, C3 will never be able to register for CSR because they are marked registered in Turnstile contract (evm store) and will be reverted by `onlyUnregistered` when calling `register()` or `assign()`.\n\nAnd all other contracts calling `assign(token1)` or `assign(token2)` will enter the same state as C1/C2/C3, because the `assign()` will succeed in Turnstile contract but fail in [`UpdateEvent()`](https://github.com/code-423n4/2022-11-canto/blob/2733fdd1be/Canto/x/csr/keeper/event_handler.go#L75-L80) (because the store can not find token1 or token2):\n\n      // Check if the NFT that is being updated exists in the CSR store\n      nftID := event.TokenId.Uint64()\n      csr, found := k.GetCSR(ctx, nftID)\n      if !found {\n      \treturn sdkerrors.Wrapf(ErrNFTNotFound, \"EventHandler::UpdateEvent the nft entered does not currently exist: %d\", nftID)\n      }\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n`processEvents()` should return the error it encounters, and `PostTxProcessing()` should return that error too.\n\n**[tkkwon1998 (Canto) confirmed and commented](https://github.com/code-423n4/2022-11-canto-findings/issues/55#issuecomment-1360847245):**\n > If there are multiple TXs registering contracts, but one of them fails, all of them will fail without much of a warning, so issue confirmed. Although, instead of returning the error to revert the TX, the error should be logged and the for loop inside of processEvents should be allowed to continue. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-11-canto",
  "Code": [
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/event_handler.go",
      "content": "package keeper\n\nimport (\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n)\n\n// Register events occur in the Turnstile Contract when a user is attempting to create a new\n// NFT with a smart contract that was just deployed. This event handler will unpack the\n// event data, validate that the smart contract address, check that the receiver address is not null,\n// and validate that this NFT is new. Only register can create new NFTs. Returns an error if the\n// register event fails.\nfunc (k Keeper) RegisterEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.RegisterCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventRegister, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check that the receiver account  exists in the evm store\n\tif acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient)\n\t}\n\n\t// Set the NFTID in the store if it has not been registered yet\n\tnftID := event.TokenId.Uint64()\n\t_, found := k.GetCSR(ctx, nftID)\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrDuplicateNFTID, \"EventHandler::RegisterEvent this NFT id has already been registered: %d\", nftID)\n\t}\n\n\t// Create CSR object and perform stateless validation\n\tcsr := types.NewCSR(\n\t\t[]string{event.SmartContract.String()},\n\t\tnftID,\n\t)\n\tif err := csr.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Set the CSR in the store\n\tk.SetCSR(ctx, csr)\n\n\treturn nil\n}\n\n// Update events occur in the Turnstile contract when a user is attempting to assign their newly\n// deployed smart contract to an existing NFT. This event handler will unpack the data, validate\n// that the smart contract to be assigned is valid, check that NFT id exists, and append the smart contract\n// to the NFT id entered. Update is permissionless in the sense that you do not have to be the owner\n// of the NFT to be able to add new smart contracts to it.\nfunc (k Keeper) UpdateEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.UpdateCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventUpdate, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the NFT that is being updated exists in the CSR store\n\tnftID := event.TokenId.Uint64()\n\tcsr, found := k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNFTNotFound, \"EventHandler::UpdateEvent the nft entered does not currently exist: %d\", nftID)\n\t}\n\t// Add the new smart contract to the CSR NFT and validate\n\tcsr.Contracts = append(csr.Contracts, event.SmartContract.String())\n\terr = csr.Validate()\n\tif err != nil {\n\t\treturn err\n\t}\n\tk.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\n// ValidateContract checks if the smart contract can be registered to a CSR. It checks\n// if the address is a smart contract address, whether the smart contract has code, and\n// whether the contract is already assigned to some other NFT.\nfunc (k Keeper) ValidateContract(ctx sdk.Context, contract common.Address) error {\n\t// Check if the smart contract is already registered -> prevent double registration\n\tnftID, found := k.GetNFTByContract(ctx, contract.String())\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrPrevRegisteredSmartContract,\n\t\t\t\"EventHandler::ValidateContract this smart contract is already registered to an existing NFT: %d\", nftID)\n\t}\n\n\t// Check if the user is attempting to register a non-smart contract address (i.e. an EOA or non-existent address)\n\taccount := k.evmKeeper.GetAccount(ctx, contract)\n\tif account == nil || !account.IsContract() {\n\t\treturn sdkerrors.Wrapf(ErrRegisterInvalidContract,\n\t\t\t\"EventHandler::ValidateContract user is attempting to register/assign a nil or non-smart contract address\")\n\t}\n\treturn nil\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/event_handler.go",
      "content": "package keeper\n\nimport (\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n)\n\n// Register events occur in the Turnstile Contract when a user is attempting to create a new\n// NFT with a smart contract that was just deployed. This event handler will unpack the\n// event data, validate that the smart contract address, check that the receiver address is not null,\n// and validate that this NFT is new. Only register can create new NFTs. Returns an error if the\n// register event fails.\nfunc (k Keeper) RegisterEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.RegisterCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventRegister, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check that the receiver account  exists in the evm store\n\tif acct := k.evmKeeper.GetAccount(ctx, event.Recipient); acct == nil {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentAcct, \"EventHandler::RegisterEvent account does not exist: %s\", event.Recipient)\n\t}\n\n\t// Set the NFTID in the store if it has not been registered yet\n\tnftID := event.TokenId.Uint64()\n\t_, found := k.GetCSR(ctx, nftID)\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrDuplicateNFTID, \"EventHandler::RegisterEvent this NFT id has already been registered: %d\", nftID)\n\t}\n\n\t// Create CSR object and perform stateless validation\n\tcsr := types.NewCSR(\n\t\t[]string{event.SmartContract.String()},\n\t\tnftID,\n\t)\n\tif err := csr.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\t// Set the CSR in the store\n\tk.SetCSR(ctx, csr)\n\n\treturn nil\n}\n\n// Update events occur in the Turnstile contract when a user is attempting to assign their newly\n// deployed smart contract to an existing NFT. This event handler will unpack the data, validate\n// that the smart contract to be assigned is valid, check that NFT id exists, and append the smart contract\n// to the NFT id entered. Update is permissionless in the sense that you do not have to be the owner\n// of the NFT to be able to add new smart contracts to it.\nfunc (k Keeper) UpdateEvent(ctx sdk.Context, data []byte) error {\n\tvar event types.UpdateCSREvent\n\t// Unpack the data\n\terr := TurnstileContract.UnpackIntoInterface(&event, types.TurnstileEventUpdate, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Validate that the contract entered can be registered\n\terr = k.ValidateContract(ctx, event.SmartContract)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the NFT that is being updated exists in the CSR store\n\tnftID := event.TokenId.Uint64()\n\tcsr, found := k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNFTNotFound, \"EventHandler::UpdateEvent the nft entered does not currently exist: %d\", nftID)\n\t}\n\t// Add the new smart contract to the CSR NFT and validate\n\tcsr.Contracts = append(csr.Contracts, event.SmartContract.String())\n\terr = csr.Validate()\n\tif err != nil {\n\t\treturn err\n\t}\n\tk.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\n// ValidateContract checks if the smart contract can be registered to a CSR. It checks\n// if the address is a smart contract address, whether the smart contract has code, and\n// whether the contract is already assigned to some other NFT.\nfunc (k Keeper) ValidateContract(ctx sdk.Context, contract common.Address) error {\n\t// Check if the smart contract is already registered -> prevent double registration\n\tnftID, found := k.GetNFTByContract(ctx, contract.String())\n\tif found {\n\t\treturn sdkerrors.Wrapf(ErrPrevRegisteredSmartContract,\n\t\t\t\"EventHandler::ValidateContract this smart contract is already registered to an existing NFT: %d\", nftID)\n\t}\n\n\t// Check if the user is attempting to register a non-smart contract address (i.e. an EOA or non-existent address)\n\taccount := k.evmKeeper.GetAccount(ctx, contract)\n\tif account == nil || !account.IsContract() {\n\t\treturn sdkerrors.Wrapf(ErrRegisterInvalidContract,\n\t\t\t\"EventHandler::ValidateContract user is attempting to register/assign a nil or non-smart contract address\")\n\t}\n\treturn nil\n}"
    }
  ]
}