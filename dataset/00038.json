{
  "Title": "Makers May Profit off of Takers via Malicious makerPermit Extension",
  "Content": "Makers have the option of giving allowance via permit, in which case the [`HAS_EXTENSION_FLAG`](https://github.com/1inch/limit-order-protocol/blob/aab3364577fd22d5baf5bc07cb9f8feb1511de55/contracts/libraries/MakerTraitsLib.sol#L18) from the `MarketTraitsLib` library would need to be set and the `extension` should contain the [`makerPermit`](https://github.com/1inch/limit-order-protocol/blob/aab3364577fd22d5baf5bc07cb9f8feb1511de55/contracts/libraries/ExtensionLib.sol#L78-L80) payload.\n\n\nWhen takers fill such an order, if no prior allowance exists, the [`SKIP_ORDER_PERMIT_FLAG`](https://github.com/1inch/limit-order-protocol/blob/aab3364577fd22d5baf5bc07cb9f8feb1511de55/contracts/libraries/TakerTraitsLib.sol#L14) needs to be set to zero in order to [ensure](https://github.com/1inch/limit-order-protocol/blob/aab3364577fd22d5baf5bc07cb9f8feb1511de55/contracts/OrderMixin.sol#L191) the permit will be consumed right after verifying the signature.\n\n\nIn order to consume the permit, both the target address and the permit payload need to be [extracted](https://github.com/1inch/limit-order-protocol/blob/aab3364577fd22d5baf5bc07cb9f8feb1511de55/contracts/OrderMixin.sol#L195) from the `extension` bytes. The first 20 bytes of the maker permit will be used as the target address, while the remaining bytes will be used as the payload.\n\n\nDepending on the permit length, the call will be managed differently, always respecting the first 20 bytes of the `makerPermit` as the address to call, except when the payload indicates that it is a `Permit2`, in which case the proper contract will be called.\n\n\nMalicious makers can inject a malicious `makerPermit` bytes parameter encoded within the order `extension` so that the `tryPermit` function calls a contract owned by them. When called, this contract can perform arbitrary actions at the expense of the taker, since they are the ones funding the gas fees. Potential gas-heavy actions that could be run for free include:\n\n\n* Contract deployment\n* Filling another limit order\n* Minting gas tokens on chains where they are still available in order to later sell them for a profit\n\n\nThis attack will be possible as long as:\n\n\n* The malicious contract actually ends up consuming the permit or giving the necessary allowance for the order filling to go through.\n* The expected profit for the taker will still be positive, even after accounting for the extra gas. This assumes that the takers are considering the total gas spent before the end of the transaction and reverting if a net profit cannot be achieved.\n\n\nIn order to mitigate this attack vector, consider disabling makers from being able to specify the target address within the `makerPermit` bytes. If makers want to use `Permit2`, the `SafeERC20` library is already overriding the target value. For ERC-2612-compatible permits, or exotic permit structures such as with the DAI token, the target address should be the [`makerAsset`](https://github.com/1inch/limit-order-protocol/blob/aab3364577fd22d5baf5bc07cb9f8feb1511de55/contracts/interfaces/IOrderMixin.sol#L14). This will also help optimize gas consumption when using permits since extensions will use 20 bytes less of `calldata`.\n\n\nEven though `takers` will still make a profit and this technique could be considered within the \"rules of the game\", consider following this recommendation in order to make the service fairer to all `takers` while also making the protocol slightly more gas efficient.\n\n\n***Update:** Acknowledged, not resolved. The 1inch team stated:*\n\n\n\n> *We can't be sure that `makerAsset` is actually the token. When using proxies, [for example](https://github.com/1inch/limit-order-protocol/blob/c454e0f1ec1cddd13d57a6cc3e4ba65b46af1589/test/LimitOrderProtocol.js#L266), `makerAsset` is the address of the proxy and not the asset itself. And also, in that case, `maker` sets the allowance to the proxy address, not to the `LimitOrderProtocol` address.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/MakerTraitsLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype MakerTraits is uint256;\n\n/**\n * @title MakerTraitsLib\n * @notice A library to manage and check MakerTraits, which are used to encode the maker's preferences for an order in a single uint256.\n * @dev\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\n * High bits are used for flags\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\n\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\n * uint80 last 10 bytes of allowed sender address (0 if any)\n * uint40 expiration timestamp (0 if none)\n * uint40 nonce or epoch\n * uint40 series\n */\nlibrary MakerTraitsLib {\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\n    uint256 private constant _EXPIRATION_OFFSET = 80;\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\n    uint256 private constant _SERIES_OFFSET = 160;\n    uint256 private constant _SERIES_MASK = type(uint40).max;\n\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\n\n    /**\n     * @notice Checks if the order has the extension flag set.\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the flag is set.\n     */\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker allows a specific taker to fill the order.\n     * @param makerTraits The traits of the maker.\n     * @param sender The address of the taker to be checked.\n     * @return result A boolean indicating whether the taker is allowed.\n     */\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\n    }\n\n    /**\n     * @notice Checks if the order has expired.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the order has expired.\n     */\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\n        uint256 expiration = (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * @notice Returns the nonce or epoch of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The nonce or epoch of the order.\n     */\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\n    }\n\n    /**\n     * @notice Returns the series of the order.\n     * @param makerTraits The traits of the maker.\n     * @return result The series of the order.\n     */\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\n    }\n\n    /**\n      * @notice Determines if the order allows partial fills.\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the maker allows partial fills.\n      */\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs pre-interaction call.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\n     */\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs post-interaction call.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\n     */\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\n    }\n\n    /**\n      * @notice Determines if the order allows multiple fills.\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the maker allows multiple fills.\n      */\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\n    }\n\n    /**\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\n      * @return result A boolean indicating whether the bit invalidator should be used.\n      * True if the order requires the use of the bit invalidator.\n      */\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\n    }\n\n    /**\n     * @notice Checks if the maker needs to check the epoch.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\n     */\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the maker uses permit2.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker uses permit2.\n     */\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\n    }\n\n    /**\n     * @notice Checks if the maker needs to unwraps WETH.\n     * @param makerTraits The traits of the maker.\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\n     */\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/TakerTraitsLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ntype TakerTraits is uint256;\n\n/**\n * @title TakerTraitsLib\n * @notice This library to manage and check TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.\n * @dev The TakerTraits are structured as follows:\n * High bits are used for flags\n * 255 bit `_MAKER_AMOUNT_FLAG`         - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\n * 254 bit `_UNWRAP_WETH_FLAG`          - If set, the WETH will be unwrapped into ETH before sending to taker.\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`    - If set, the order skips maker's permit execution.\n * 252 bit `_USE_PERMIT2_FLAG`          - If set, the order uses the permit2 function for authorization.\n * The remaining bits are used to store the threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\n */\nlibrary TakerTraitsLib {\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\n\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\n\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\n\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\n    }\n\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\n    }\n\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\n    }\n\n    /**\n     * @notice Checks if the taking amount should be calculated based on making amount.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\n     */\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order should unwrap WETH.\n     */\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order should skip maker's permit execution.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order don't apply permit.\n     */\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\n    }\n\n    /**\n     * @notice Checks if the order uses the permit2 instead of permit.\n     * @param takerTraits The traits of the taker.\n     * @return result A boolean indicating whether the order uses the permit2.\n     */\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\n    }\n\n    /**\n     * @notice Retrieves the threshold amount from the takerTraits.\n     * The maximum amount a taker agrees to give in exchange for a making amount.\n     * @param takerTraits The traits of the taker.\n     * @return result The threshold amount encoded in the takerTraits.\n     */\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\n    }\n}"
    },
    {
      "filename": "contracts/OrderMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/OnlyWethReceiver.sol\";\n\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./helpers/SeriesEpochManager.sol\";\nimport \"./interfaces/ITakerInteraction.sol\";\nimport \"./interfaces/IPreInteraction.sol\";\nimport \"./interfaces/IPostInteraction.sol\";\nimport \"./interfaces/IOrderMixin.sol\";\nimport \"./libraries/Errors.sol\";\nimport \"./libraries/TakerTraitsLib.sol\";\nimport \"./libraries/BitInvalidatorLib.sol\";\nimport \"./libraries/RemainingInvalidatorLib.sol\";\nimport \"./OrderLib.sol\";\n\n/// @title Limit Order mixin\nabstract contract OrderMixin is IOrderMixin, EIP712, OnlyWethReceiver, PredicateHelper, SeriesEpochManager {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n    using OrderLib for IOrderMixin.Order;\n    using ExtensionLib for bytes;\n    using AddressLib for Address;\n    using MakerTraitsLib for MakerTraits;\n    using TakerTraitsLib for TakerTraits;\n    using BitInvalidatorLib for BitInvalidatorLib.Data;\n    using RemainingInvalidatorLib for RemainingInvalidator;\n\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase\n    mapping(address => BitInvalidatorLib.Data) private _bitInvalidator;\n    mapping(address => mapping(bytes32 => RemainingInvalidator)) private _remainingInvalidator;\n\n    constructor(IWETH weth) OnlyWethReceiver(address(weth)) {\n        _WETH = weth;\n    }\n\n    function permitAndCall(bytes calldata permit, bytes calldata action) external {\n        IERC20(address(bytes20(permit))).tryPermit(msg.sender, address(this), permit[20:]);\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, action.offset, action.length)\n            let success := delegatecall(gas(), address(), ptr, action.length, 0, 0)\n            returndatacopy(ptr, 0, returndatasize())\n            switch success\n            case 0 {\n                revert(ptr, returndatasize())\n            }\n            default {\n                return(ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice See {IOrderMixin-bitInvalidatorForOrder}.\n     */\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 /* result */) {\n        return _bitInvalidator[maker].checkSlot(slot);\n    }\n\n    /**\n     * @notice See {IOrderMixin-remainingInvalidatorForOrder}.\n     */\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 /* remaining */) {\n        return _remainingInvalidator[maker][orderHash].remaining();\n    }\n\n    /**\n     * @notice See {IOrderMixin-rawRemainingInvalidatorForOrder}.\n     */\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 /* remainingRaw */) {\n        return RemainingInvalidator.unwrap(_remainingInvalidator[maker][orderHash]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-simulate}.\n     */\n    function simulate(address target, bytes calldata data) external {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory result) = target.delegatecall(data);\n        revert SimulationResults(success, result);\n    }\n\n    /**\n     * @notice See {IOrderMixin-cancelOrder}.\n     */\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) public {\n        if (makerTraits.useBitInvalidator()) {\n            _bitInvalidator[msg.sender].massInvalidate(makerTraits.nonceOrEpoch(), 0);\n        } else {\n            _remainingInvalidator[msg.sender][orderHash] = RemainingInvalidatorLib.fullyFilled();\n        }\n        emit OrderCancelled(orderHash);\n    }\n\n    /**\n     * @notice See {IOrderMixin-cancelOrders}.\n     */\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external {\n        if (makerTraits.length != orderHashes.length) revert MismatchArraysLengths();\n        unchecked {\n            for (uint256 i = 0; i < makerTraits.length; i++) {\n                cancelOrder(makerTraits[i], orderHashes[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice See {IOrderMixin-bitsInvalidateForOrder}.\n     */\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external {\n        if (!makerTraits.useBitInvalidator()) revert OrderIsNotSuitableForMassInvalidation();\n        _bitInvalidator[msg.sender].massInvalidate(makerTraits.nonceOrEpoch(), additionalMask);\n    }\n\n     /**\n     * @notice See {IOrderMixin-hashOrder}.\n     */\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32) {\n        return order.hash(_domainSeparatorV4());\n    }\n\n    /**\n     * @notice See {IOrderMixin-checkPredicate}.\n     */\n    function checkPredicate(bytes calldata predicate) public view returns(bool) {\n        (bool success, uint256 res) = _staticcallForUint(address(this), predicate);\n        return success && res == 1;\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillOrder}.\n     */\n    function fillOrder(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external payable returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        return _fillOrder(order, r, vs, amount, takerTraits, msg.sender, msg.data[:0], msg.data[:0]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillOrderArgs}.\n     */\n    function fillOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external payable returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        (\n            address target,\n            bytes calldata extension,\n            bytes calldata interaction\n        ) = _parseArgs(takerTraits, args);\n\n        return _fillOrder(order, r, vs, amount, takerTraits, target, extension, interaction);\n    }\n\n    function _fillOrder(\n        IOrderMixin.Order calldata order,\n        bytes32 r,\n        bytes32 vs,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) {\n        // Check signature and apply order/maker permit only on the first fill\n        orderHash = order.hash(_domainSeparatorV4());\n        uint256 remainingMakingAmount = _checkRemainingMakingAmount(order, orderHash);\n        if (remainingMakingAmount == order.makingAmount) {\n            address maker = order.maker.get();\n            if (maker == address(0) || maker != ECDSA.recover(orderHash, r, vs)) revert BadSignature();\n            if (!takerTraits.skipMakerPermit()) {\n                bytes calldata makerPermit = extension.makerPermit();\n                if (makerPermit.length >= 20) {\n                    // proceed only if taker is willing to execute permit and its length is enough to store address\n                    IERC20(address(bytes20(makerPermit))).tryPermit(maker, address(this), makerPermit[20:]);\n                    if (!order.makerTraits.useBitInvalidator()) {\n                        // Bit orders are not subjects for reentrancy, but we still need to check remaining-based orders for reentrancy\n                        if (!_remainingInvalidator[order.maker.get()][orderHash].isNewOrder()) revert ReentrancyDetected();\n                    }\n                }\n            }\n        }\n\n        (makingAmount, takingAmount) = _fill(order, orderHash, remainingMakingAmount, amount, takerTraits, target, extension, interaction);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillContractOrder}.\n     */\n    function fillContractOrder(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits\n    ) external returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        return _fillContractOrder(order, signature, amount, takerTraits, msg.sender, msg.data[:0], msg.data[:0]);\n    }\n\n    /**\n     * @notice See {IOrderMixin-fillContractOrderArgs}.\n     */\n    function fillContractOrderArgs(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        bytes calldata args\n    ) external returns(uint256 /* makingAmount */, uint256 /* takingAmount */, bytes32 /* orderHash */) {\n        (\n            address target,\n            bytes calldata extension,\n            bytes calldata interaction\n        ) = _parseArgs(takerTraits, args);\n\n        return _fillContractOrder(order, signature, amount, takerTraits, target, extension, interaction);\n    }\n\n    function _fillContractOrder(\n        IOrderMixin.Order calldata order,\n        bytes calldata signature,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) {\n        // Check signature and apply order permit only on the first fill\n        orderHash = order.hash(_domainSeparatorV4());\n        uint256 remainingMakingAmount = _checkRemainingMakingAmount(order, orderHash);\n        if (remainingMakingAmount == order.makingAmount) {\n            if (!ECDSA.isValidSignature(order.maker.get(), orderHash, signature)) revert BadSignature();\n        }\n\n        (makingAmount, takingAmount) = _fill(order, orderHash, remainingMakingAmount, amount, takerTraits, target, extension, interaction);\n    }\n\n    /**\n      * @notice Fills an order and transfers making amount to a specified target.\n      * @dev If the target is zero assigns it the caller's address.\n      * The function flow is as follows:\n      * 1. Validate order\n      * 2. Call maker pre-interaction\n      * 3. Transfer maker asset to taker\n      * 4. Call taker interaction\n      * 5. Transfer taker asset to maker\n      * 5. Call maker post-interaction\n      * 6. Emit OrderFilled event\n      * @param order The order details.\n      * @param orderHash The hash of the order.\n      * @param extension The extension calldata of the order.\n      * @param remainingMakingAmount The remaining amount to be filled.\n      * @param amount The order amount.\n      * @param takerTraits The taker preferences for the order.\n      * @param target The address to which the order is filled.\n      * @param interaction The interaction calldata.\n      * @return makingAmount The computed amount that the maker will get.\n      * @return takingAmount The computed amount that the taker will send.\n      */\n    function _fill(\n        IOrderMixin.Order calldata order,\n        bytes32 orderHash,\n        uint256 remainingMakingAmount,\n        uint256 amount,\n        TakerTraits takerTraits,\n        address target,\n        bytes calldata extension,\n        bytes calldata interaction\n    ) private returns(uint256 makingAmount, uint256 takingAmount) {\n        // Validate order\n        {\n            (bool valid, bytes4 validationResult) = order.isValidExtension(extension);\n            if (!valid) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly (\"memory-safe\") {\n                    mstore(0, validationResult)\n                    revert(0, 4)\n                }\n            }\n        }\n        if (!order.makerTraits.isAllowedSender(msg.sender)) revert PrivateOrder();\n        if (order.makerTraits.isExpired()) revert OrderExpired();\n        if (order.makerTraits.needCheckEpochManager()) {\n            if (order.makerTraits.useBitInvalidator()) revert EpochManagerAndBitInvalidatorsAreIncompatible();\n            if (!epochEquals(order.maker.get(), order.makerTraits.series(), order.makerTraits.nonceOrEpoch())) revert WrongSeriesNonce();\n        }\n\n        // Check if orders predicate allows filling\n        if (extension.length > 0) {\n            bytes calldata predicate = extension.predicate();\n            if (predicate.length > 0) {\n                if (!checkPredicate(predicate)) revert PredicateIsNotTrue();\n            }\n        }\n\n        // Compute maker and taker assets amount\n        if (takerTraits.isMakingAmount()) {\n            makingAmount = Math.min(amount, remainingMakingAmount);\n            takingAmount = order.calculateTakingAmount(extension, makingAmount, remainingMakingAmount, orderHash);\n\n            uint256 threshold = takerTraits.threshold();\n            if (threshold > 0) {\n                // Check rate: takingAmount / makingAmount <= threshold / amount\n                if (amount == makingAmount) {  // Gas optimization, no SafeMath.mul()\n                    if (takingAmount > threshold) revert TakingAmountTooHigh();\n                } else {\n                    if (takingAmount * amount > threshold * makingAmount) revert TakingAmountTooHigh();\n                }\n            }\n        }\n        else {\n            takingAmount = amount;\n            makingAmount = order.calculateMakingAmount(extension, takingAmount, remainingMakingAmount, orderHash);\n            if (makingAmount > remainingMakingAmount) {\n                // Try to decrease taking amount because computed making amount exceeds remaining amount\n                makingAmount = remainingMakingAmount;\n                takingAmount = order.calculateTakingAmount(extension, makingAmount, remainingMakingAmount, orderHash);\n                if (takingAmount > amount) revert TakingAmountExceeded();\n            }\n\n            uint256 threshold = takerTraits.threshold();\n            if (threshold > 0) {\n                // Check rate: makingAmount / takingAmount >= threshold / amount\n                if (amount == takingAmount) { // Gas optimization, no SafeMath.mul()\n                    if (makingAmount < threshold) revert MakingAmountTooLow();\n                } else {\n                    if (makingAmount * amount < threshold * takingAmount) revert MakingAmountTooLow();\n                }\n            }\n        }\n        if (!order.makerTraits.allowPartialFills() && makingAmount != order.makingAmount) revert PartialFillNotAllowed();\n        unchecked { if (makingAmount * takingAmount == 0) revert SwapWithZeroAmount(); }\n\n        // Invalidate order depending on makerTraits\n        if (order.makerTraits.useBitInvalidator()) {\n            _bitInvalidator[order.maker.get()].checkAndInvalidate(order.makerTraits.nonceOrEpoch());\n        } else {\n            _remainingInvalidator[order.maker.get()][orderHash] = RemainingInvalidatorLib.remains(remainingMakingAmount, makingAmount);\n        }\n\n        // Pre interaction, where maker can prepare funds interactively\n        if (order.makerTraits.needPreInteractionCall()) {\n            bytes calldata data = extension.preInteractionTargetAndData();\n            address listener = order.maker.get();\n            if (data.length > 19) {\n                listener = address(bytes20(data));\n                data = data[20:];\n            }\n            IPreInteraction(listener).preInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, data\n            );\n        }\n\n        // Maker => Taker\n        {\n            bool needUnwrap = order.makerAsset.get() == address(_WETH) && takerTraits.unwrapWeth();\n            address receiver = needUnwrap ? address(this) : target;\n            if (order.makerTraits.usePermit2()) {\n                if (extension.makerAssetSuffix().length > 0) revert InvalidPermit2Transfer();\n                IERC20(order.makerAsset.get()).safeTransferFromPermit2(order.maker.get(), receiver, makingAmount);\n            } else {\n                if (!_callTransferFromWithSuffix(\n                    order.makerAsset.get(),\n                    order.maker.get(),\n                    receiver,\n                    makingAmount,\n                    extension.makerAssetSuffix()\n                )) revert TransferFromMakerToTakerFailed();\n            }\n            if (needUnwrap) {\n                _WETH.safeWithdrawTo(makingAmount, target);\n            }\n        }\n\n        if (interaction.length > 19) {\n            // proceed only if interaction length is enough to store address\n            ITakerInteraction(address(bytes20(interaction))).takerInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, interaction[20:]\n            );\n        }\n\n        // Taker => Maker\n        if (order.takerAsset.get() == address(_WETH) && msg.value > 0) {\n            if (msg.value < takingAmount) revert Errors.InvalidMsgValue();\n            if (msg.value > takingAmount) {\n                unchecked {\n                    // solhint-disable-next-line avoid-low-level-calls\n                    (bool success, ) = msg.sender.call{value: msg.value - takingAmount, gas: _RAW_CALL_GAS_LIMIT}(\"\");\n                    if (!success) revert Errors.ETHTransferFailed();\n                }\n            }\n\n            if (order.makerTraits.unwrapWeth()) {\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool success, ) = order.getReceiver().call{value: takingAmount, gas: _RAW_CALL_GAS_LIMIT}(\"\");\n                if (!success) revert Errors.ETHTransferFailed();\n            } else {\n                _WETH.safeDeposit(takingAmount);\n                _WETH.safeTransfer(order.getReceiver(), takingAmount);\n            }\n        } else {\n            if (msg.value != 0) revert Errors.InvalidMsgValue();\n\n            bool needUnwrap = order.takerAsset.get() == address(_WETH) && order.makerTraits.unwrapWeth();\n            address receiver = needUnwrap ? address(this) : order.getReceiver();\n            if (takerTraits.usePermit2()) {\n                if (extension.takerAssetSuffix().length > 0) revert InvalidPermit2Transfer();\n                IERC20(order.takerAsset.get()).safeTransferFromPermit2(msg.sender, receiver, takingAmount);\n            } else {\n                if (!_callTransferFromWithSuffix(\n                    order.takerAsset.get(),\n                    msg.sender,\n                    receiver,\n                    takingAmount,\n                    extension.takerAssetSuffix()\n                )) revert TransferFromTakerToMakerFailed();\n            }\n\n            if (needUnwrap) {\n                _WETH.safeWithdrawTo(takingAmount, order.getReceiver());\n            }\n        }\n\n        // Post interaction, where maker can handle funds interactively\n        if (order.makerTraits.needPostInteractionCall()) {\n            bytes calldata data = extension.postInteractionTargetAndData();\n            address listener = order.maker.get();\n            if (data.length > 19) {\n                listener = address(bytes20(data));\n                data = data[20:];\n            }\n            IPostInteraction(listener).postInteraction(\n                order, extension, orderHash, msg.sender, makingAmount, takingAmount, remainingMakingAmount, data\n            );\n        }\n\n        emit OrderFilled(orderHash, remainingMakingAmount - makingAmount);\n    }\n\n    /**\n      * @notice Processes the taker interaction arguments.\n      * @dev The function will revert if the taker permit is invalid.\n      * @param takerTraits The taker preferences for the order.\n      * @param args The taker interaction arguments.\n      * @return t"
    }
  ]
}