{
  "Title": "M-5: `KeeperOracle.commit` will revert and won't work for all markets if any single `Market` is paused.",
  "Content": "# Issue M-5: `KeeperOracle.commit` will revert and won't work for all markets if any single `Market` is paused. \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/26 \n\n## Found by \npanprog\n## Summary\n\nAccording to protocol design (from KeeperOracle comments), multiple markets may use the same KeeperOracle instance:\n```solidity\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\n```\n\nHowever, if `KeeperOracle` is used by several `Market` instances, and one of them makes a request and is then paused before the settlement, `KeeperOracle` will be temporarily bricked until `Market` is unpaused. This happens, because `KeeperOracle.commit` will revert in market callback, as `commit` iterates through all requested markets and calls `update` on all of them, and `update` reverts if the market is paused.\n\nThis means that pausing of just 1 market will basically stop trading in all the other markets which use the same `KeeperOracle`, disrupting protocol usage. When `KeeperOracle.commit` always reverts, it's also impossible to switch oracle provider from upstream `OracleFactory`, because provider switch still requires the latest version of previous oracle to be commited, and it will be impossible to commit it (both valid or invalid, requested or unrequested).\n\nAdditionally, the market's `update` can also revert for some other reasons, for example if maker exceeds the maker limit after invalid oracle as described in the other issue.\n\nAnd for another problem (although a low severity, but caused in the same lines), if too many markets are authorized to call `KeeperOracle.request`, the markets callback gas usage might exceed block limit, making it impossible to call `commit` due to not enough gas. Currently there is no limit of the amount of Markets which can be added to callback queue.\n\n## Vulnerability Detail\n\n`KeeperOracle.commit` calls back `update` in all markets which called `request` in the oracle version:\n```solidity\nfor (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\n    _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n...\nfunction _settle(IMarket market, address account) private {\n    market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n}\n```\n\nIf any `Market` is paused, its `update` function will revert (notice the `whenNotPaused` modifier):\n```solidity\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external nonReentrant whenNotPaused {\n```\n\nThis means that if any `Market` is paused, all the other markets will be unable to continue trading since `commit` in their oracle provider will revert. It will also be impossible to successfully switch to a new provider for these markets, because previous oracle provider must still commit its latest request before fully switching to a new oracle provider:\n```solidity\nfunction _latestStale(OracleVersion memory currentOracleLatestVersion) private view returns (bool) {\n    if (global.current == global.latest) return false;\n    if (global.latest == 0) return true;\n\n@@@ if (uint256(oracles[global.latest].timestamp) > oracles[global.latest].provider.latest().timestamp) return false;\n    if (uint256(oracles[global.latest].timestamp) >= currentOracleLatestVersion.timestamp) return false;\n\n    return true;\n}\n```\n\n## Impact\n\nOne paused market will stop trading in all the markets which use the same oracle provider (`KeeperOracle`).\n\n## Code Snippet\n\n`KeeperOracle.commit` iterates all requested markets and settles them:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L123-L124\n\n`_settle` calls `update` on the market:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol#L176-L178\n\n`Market.update` has `whenNotPaused` modifier, making it revert when paused:\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial/contracts/Market.sol#L87\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Consider catching and ignoring revert, when calling `update` for the market in the `_settle` (wrap in try .. catch).\n2. Consider adding a limit of the number of markets which are added to callback queue in each oracle version, or alternatively limit the number of authorized markets to call `request`.\n\n\n\n## Discussion\n\n**kbrizzle**\n\nMarkets are currently only pausable Factory-wide, which means this cannot happen unless there is a multi-MarketFactory setup pointing at the same Oracle instance.\n\nWhile valid, we currently do not support this usage pattern, and this would be among many improvements we'd need to make to.\n\n**panprog**\n\nThis issue is not limited to paused markets, but can happen for any reasons when market.update reverts, for example in the current codebase this can happen if maker exceeds makerLimit (issue #24), which will revert all update calls, subsequently bricking oracle update for all markets. This is mentioned in the issue description:\n> Additionally, the market's `update` can also revert for some other reasons, for example if maker exceeds the maker limit after invalid oracle as described in the other issue.\n\nI think this should be medium. It is still valid with paused markets (even if not considered supported setup by sponsor), but also valid if any other issue causes market to revert updates. This issue will make #24 more severe (#24 bricks 1 market, #26 makes it brick oracle commit and all markets using the same oracle)\n\n**kbrizzle**\n\nThanks for the additional color.\n\nWe'd like to preserve the guarantee that each posted price will atomically settle the attached market(s) (globally / async for locally) to that version. This is important for a number of parameter improvements and future upgrades we have planned.\n\nIf there are settlement-revert cases that are possible given this paradigm, we'd like to address those as if they are market-bricking issues.\n\nWe're open to however you think this is fair to judge on a severity basis, but we will only be resolving actual revert issues versus making the settlement callback `try...catch`.\n\n**panprog**\n\nThese are the planned future upgrades, but according to Sherlock rules it should be judged based on current code. In the current code there are no problems if market is not settled, but there are problems if due to some other issues (such as #24) the issue described here makes single market failure cause all the markets using the same oracle revert.\n\nI'd like to add that while multi-factory setup is not supported, multi markets (from the same factory) pointing to the same oracle instance is supported. So the following setup is supported:\n\n- MarketFactory1 deploys Market1 and Market2\n- OracleFactory1 deploys Oracle1\n- Market1 oracle is set to Oracle1 (say, it uses no payoff)\n- Market2 oracle is set to Oracle1 (say, it uses 2x payoff - so a 2x market for the same underlying oracle)\n\nIn such setup, if Market1 is paused, then Market2 is paused too (because they're paused via MarketFactory1, markets don't have pause function by themselves). However, if Market1 maker exceeds makerLimit due to #24, then not only Market1 is bricked (reverts all updates), but also both Oracle1 and Market2 are bricked too (revert all commit and update transactions).\n\nSo while most of this issue description is about pause function (since I didn't know about multi-factory setup not being supported), which can be considered invalid due to not being supported, the description also does mention the other reasons for the issue to happen, including making the maker > makerLimit issue more severe (possibly some other issues which can revert update too). So this part is valid, so I believe it should be medium\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\n\n/// @title KeeperOracle\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract KeeperOracle is IKeeperOracle, Instance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 public immutable timeout;\n\n    /// @dev List of all requested oracle versions\n    mapping(uint256 => uint256) public versions;\n\n    /// @dev The global state of the oracle\n    Global private _global;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from version to a set of registered markets for settlement callback\n    mapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\n    mapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n\n    /// @notice Constructs the contract\n    /// @param timeout_ The timeout for a version to be committed\n    constructor(uint256 timeout_)  {\n        timeout = timeout_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Instance__initialize();\n    }\n\n    /// @notice Returns the global state of the oracle\n    /// @return The global state of the oracle\n    function global() external view returns (Global memory) { return _global; }\n\n    /// @notice Returns the global oracle callback set for a version\n    /// @param version The version to lookup\n    /// @return The global oracle callback set for the version\n    function globalCallbacks(uint256 version) external view returns (address[] memory) {\n        return _globalCallbacks[version].values();\n    }\n\n    /// @notice Returns the local oracle callback set for a version and market\n    /// @param version The version to lookup\n    /// @param market The market to lookup\n    /// @return The local oracle callback set for the version and market\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory) {\n        return _localCallbacks[version][market].values();\n    }\n\n    /// @notice Returns the next requested oracle version\n    /// @dev Returns 0 if no next version is requested\n    /// @return The next requested oracle version\n    function next() public view returns (uint256) {\n        return versions[_global.latestIndex + 1];\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @param market The market to callback to\n    /// @param account The account to callback to\n    function request(IMarket market, address account) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n        if (versions[_global.currentIndex] == currentTimestamp) return;\n\n        versions[++_global.currentIndex] = currentTimestamp;\n        emit OracleProviderVersionRequested(currentTimestamp);\n\n        _globalCallbacks[currentTimestamp].add(address(market));\n        _localCallbacks[currentTimestamp][market].add(account);\n        emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return Latest oracle version\n    function latest() public view returns (OracleVersion memory) {\n        return at(_global.latestVersion);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IKeeperFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n        oracleVersion.valid = !oracleVersion.price.isZero();\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Verification of price happens in the oracle's factory\n    /// @param version The oracle version to commit\n    /// @return requested Whether the commit was requested\n    function commit(OracleVersion memory version) external onlyFactory returns (bool requested) {\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\n        requested = (version.timestamp == next()) ? _commitRequested(version) : _commitUnrequested(version);\n        _global.latestVersion = uint64(version.timestamp);\n\n        for (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\n            _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n\n        emit OracleProviderVersionFulfilled(version);\n    }\n\n    /// @notice Performs an asynchronous local settlement callback\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\n    /// @param market The market to settle\n    /// @param version The version to settle\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\n    function settle(IMarket market, uint256 version, uint256 maxCount) external onlyFactory {\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version][market];\n\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\n\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\n            address account = callbacks.at(0);\n            _settle(market, account);\n            callbacks.remove(account);\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\n        }\n    }\n\n    /// @notice Commits the price to a requested version\n    /// @dev This commit function will pay out a keeper reward if the committed version is valid\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitRequested(OracleVersion memory version) private returns (bool) {\n        if (block.timestamp <= (next() + timeout)) {\n            if (!version.valid) revert KeeperOracleInvalidPriceError();\n            _prices[version.timestamp] = version.price;\n        }\n        _global.latestIndex++;\n        return true;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitUnrequested(OracleVersion memory version) private returns (bool) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        if (version.timestamp <= _global.latestVersion || (next() != 0 && version.timestamp >= next()))\n            revert KeeperOracleVersionOutsideRangeError();\n        _prices[version.timestamp] = version.price;\n        return false;\n    }\n\n    /// @notice Performs a settlement callback for the account on the market\n    /// @param market The market to settle\n    /// @param account The account to settle\n    function _settle(IMarket market, address account) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/keeper/KeeperOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\n\n/// @title KeeperOracle\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract KeeperOracle is IKeeperOracle, Instance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 public immutable timeout;\n\n    /// @dev List of all requested oracle versions\n    mapping(uint256 => uint256) public versions;\n\n    /// @dev The global state of the oracle\n    Global private _global;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from version to a set of registered markets for settlement callback\n    mapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\n    mapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n\n    /// @notice Constructs the contract\n    /// @param timeout_ The timeout for a version to be committed\n    constructor(uint256 timeout_)  {\n        timeout = timeout_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Instance__initialize();\n    }\n\n    /// @notice Returns the global state of the oracle\n    /// @return The global state of the oracle\n    function global() external view returns (Global memory) { return _global; }\n\n    /// @notice Returns the global oracle callback set for a version\n    /// @param version The version to lookup\n    /// @return The global oracle callback set for the version\n    function globalCallbacks(uint256 version) external view returns (address[] memory) {\n        return _globalCallbacks[version].values();\n    }\n\n    /// @notice Returns the local oracle callback set for a version and market\n    /// @param version The version to lookup\n    /// @param market The market to lookup\n    /// @return The local oracle callback set for the version and market\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory) {\n        return _localCallbacks[version][market].values();\n    }\n\n    /// @notice Returns the next requested oracle version\n    /// @dev Returns 0 if no next version is requested\n    /// @return The next requested oracle version\n    function next() public view returns (uint256) {\n        return versions[_global.latestIndex + 1];\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @param market The market to callback to\n    /// @param account The account to callback to\n    function request(IMarket market, address account) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n        if (versions[_global.currentIndex] == currentTimestamp) return;\n\n        versions[++_global.currentIndex] = currentTimestamp;\n        emit OracleProviderVersionRequested(currentTimestamp);\n\n        _globalCallbacks[currentTimestamp].add(address(market));\n        _localCallbacks[currentTimestamp][market].add(account);\n        emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return Latest oracle version\n    function latest() public view returns (OracleVersion memory) {\n        return at(_global.latestVersion);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IKeeperFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\n        oracleVersion.valid = !oracleVersion.price.isZero();\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Verification of price happens in the oracle's factory\n    /// @param version The oracle version to commit\n    /// @return requested Whether the commit was requested\n    function commit(OracleVersion memory version) external onlyFactory returns (bool requested) {\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\n        requested = (version.timestamp == next()) ? _commitRequested(version) : _commitUnrequested(version);\n        _global.latestVersion = uint64(version.timestamp);\n\n        for (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\n            _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n\n        emit OracleProviderVersionFulfilled(version);\n    }\n\n    /// @notice Performs an asynchronous local settlement callback\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\n    /// @param market The market to settle\n    /// @param version The version to settle\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\n    function settle(IMarket market, uint256 version, uint256 maxCount) external onlyFactory {\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version][market];\n\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\n\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\n            address account = callbacks.at(0);\n            _settle(market, account);\n            callbacks.remove(account);\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\n        }\n    }\n\n    /// @notice Commits the price to a requested version\n    /// @dev This commit function will pay out a keeper reward if the committed version is valid\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitRequested(OracleVersion memory version) private returns (bool) {\n        if (block.timestamp <= (next() + timeout)) {\n            if (!version.valid) revert KeeperOracleInvalidPriceError();\n            _prices[version.timestamp] = version.price;\n        }\n        _global.latestIndex++;\n        return true;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitUnrequested(OracleVersion memory version) private returns (bool) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        if (version.timestamp <= _global.latestVersion || (next() != 0 && version.timestamp >= next()))\n            revert KeeperOracleVersionOutsideRangeError();\n        _prices[version.timestamp] = version.price;\n        return false;\n    }\n\n    /// @notice Performs a settlement callback for the account on the market\n    /// @param market The market to settle\n    /// @param account The account to settle\n    function _settle(IMarket market, address account) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    Fixed6 private constant MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL = Fixed6.wrap(type(int256).min);\n    UFixed6 private constant MAGIC_VALUE_UNCHANGED_POSITION = UFixed6.wrap(type(uint256).max);\n    UFixed6 private constant MAGIC_VALUE_FULLY_CLOSED_POSITION = UFixed6.wrap(type(uint256).max - 1);\n\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev The token that incentive rewards are paid in\n    Token18 public reward;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev The payoff function over the underlying oracle\n    IPayoffProvider public payoff;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev The global pending versions for each id\n    mapping(uint256 => PositionStorageGlobal) private _pendingPosition;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev The local pending versions for each id for each account\n    mapping(address => mapping(uint256 => PositionStorageLocal)) private _pendingPositions;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __ReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n        payoff = definition_.payoff;\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates the beneficiary of the market\n    /// @param newBeneficiary The new beneficiary address\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the coordinator of the market\n    /// @param newCoordinator The new coordinator address\n    function updateCoordinator(address newCoordinator) external onlyOwner {\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n    }\n\n    /// @notice Updates the parameter set of the market\n    /// @param newParameter The new parameter set\n    function updateParameter(MarketParameter memory newParameter) external onlyOwner {\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter(), reward);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Updates the reward token of the market\n    /// @param newReward The new reward token\n    function updateReward(Token18 newReward) public onlyOwner {\n        if (!reward.eq(Token18Lib.ZERO)) revert MarketRewardAlreadySetError();\n        if (newReward.eq(token)) revert MarketInvalidRewardError();\n\n        reward = newReward;\n        emit RewardUpdated(newReward);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, and donation\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n\n        if (_claimFee(factory().owner(), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donation)) newGlobal.donation = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n    }\n\n    /// @notice Helper function to handle a singular fee claim.\n    /// @param receiver The address to receive the fee\n    /// @param fee The amount of the fee to claim\n    function _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n        if (msg.sender != receiver) return false;\n\n        token.push(receiver, UFixed18Lib.from(fee));\n        emit FeeClaimed(receiver, fee);\n        return true;\n    }\n\n    /// @notice Claims any available reward that the sender has accrued\n    function claimReward() external {\n        Local memory newLocal = _locals[msg.sender].read();\n\n        reward.push(msg.sender, UFixed18Lib.from(newLocal.reward));\n        emit RewardClaimed(msg.sender, newLocal.reward);\n\n        newLocal.reward = UFixed6Lib.ZERO;\n        _locals[msg.sender].store(newLocal);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending position for the given id\n    /// @param id The id to query\n    function pendingPosition(uint256 id) external view returns (Position memory) {\n        return _pendingPosition[id].read();\n    }\n\n    /// @notice Returns the local pending position for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingPositions(address account, uint256 id) external view returns (Position memory) {\n        return _pendingPositions[account][id].read();\n    }\n\n    /// @notice Loads the specified global pending position from state and adjusts it\n    /// @param context The context to use\n    /// @param id The position id to load\n    /// @return newPendingPosition The loaded and global adjusted position\n    function _loadPendingPositionGlobal(\n        Context memory context,\n        uint256 id\n    ) private view returns (Position memory newPendingPosition) {\n        newPendingPosition = _pendingPosition[id].read();\n        newPendingPosition.adjust(context.latestPosition.global);\n    }\n\n    /// @notice Loads the specified local pending position from state and adjusts it\n    /// @param context The context to use\n    /// @param id The position id to load\n    /// @return newPendingPosition The loaded and local adjusted position\n    function _loadPendingPositionLocal(\n        Context memory context,\n        address account,\n        uint256 id\n    ) private view returns (Position memory newPendingPosition) {\n        newPendingPosition = _pendingPositions[account][id].read();\n        newPendingPosition.adjust(context.latestPosition.local);\n    }\n\n    /// @notice Loads the context information of a pending position\n    /// @dev Must process pending position in order from latest + 1 to current (post update)\n    /// @param context The context to use\n    /// @param newPendingPosition The pending position to process\n    function _processPendingPosition(Context memory context, Position memory newPendingPosition) private pure {\n        context.pendingCollateral = context.pendingCollateral\n            .sub(newPendingPosition.fee)\n            .sub(Fixed6Lib.from(newPendingPosition.keeper));\n\n        context.closable = context.closable\n            .sub(context.previousPendingMagnitude\n                .sub(newPendingPosition.magnitude().min(context.previousPendingMagnitude)));\n        context.previousPendingMagnitude = newPendingPosition.magnitude();\n\n        if (context.previousPendingMagnitude.gt(context.maxPendingMagnitude))\n            context.maxPendingMagnitude = newPendingPosition.magnitude();\n    }\n\n    /// @notice Loads the context for the update process\n    /// @param context The context to load to\n    /// @param account The account to query\n    function _loadUpdateContext(Context memory context, address account) private view {\n        // load latest position\n        context.pendingCollateral = context.local.collateral;\n        context.maxPendingMagnitude = context.previousPendingMagnitude = context.closable =\n            context.latestPosition.local.magnitude();\n\n        // load current position\n        context.currentPosition.global = _loadPendingPositionGlobal(context, context.global.currentId);\n        context.currentPosition.global.invalidation.update(context.latestPosition.global.invalidation);\n        context.currentPosition.local = _loadPendingPositionLocal(context, account, context.local.currentId);\n        context.currentPosition.local.invalidation.update(context.latestPosition.local.invalidation);\n\n        // advance to next id if applicable\n        if (context.currentTimestamp > context.currentPosition.local.timestamp) {\n            context.local.currentId++;\n            context.currentPosition.local.prepare();\n        }\n        if (context.currentTimestamp > context.currentPosition.global.timestamp) {\n            context.global.currentId++;\n            context.currentPosition.global.prepare();\n        }\n\n        // load pending positions\n        for (uint256 id = context.local.latestId + 1; id < context.local.currentId; id++)\n            _processPendingPosition(context, _loadPendingPositionLocal(context, account, id));\n    }\n\n    /// @notice Modifies the collateral input per magic values\n    /// @param context The context to use\n    /// @param collateral The collateral to process\n    /// @return The resulting collateral value\n    function _processCollateralMagicValue(Context memory context, Fixed6 collateral) private pure returns (Fixed6) {\n        if (collateral.eq(MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL))\n            return context.local.collateral.mul(Fixed6Lib.NEG_ONE);\n        return collateral;\n    }\n\n    /// @notice Modifies the position input per magic values\n    /// @param context The context to use\n    /// @param currentPosition The current position prior to update\n    /// @param newPosition The position to process\n    /// @return The resulting position value\n    function _processPositionMagicValue(\n        Context memory context,\n        UFixed6 currentPosition,\n        UFixed6 newPosition\n    ) private pure returns (UFixed6) {\n        if (newPosition.eq(MAGIC_VALUE_UNCHANGED_POSITION))\n            return currentPosition;\n        if (newPosition.eq(MAGIC_VALUE_FULLY_CLOSED_POSITION)) {\n            if (currentPosition.isZero()) return currentPosition;\n            return context.previousPendingMagnitude.sub(context.closable.min(context.previousPendingMagnitude));\n        }\n        return newPosition;\n    }\n\n    /// @notice Updates the current position\n    /// @param context The context to use\n    /// @param account The account to update\n    /// @param newMaker The new maker position size\n    /// @param newLong The new long position size\n    /// @param newShort The new short position size\n    /// @param collateral The change in collateral\n    /// @param protect Whether to protect the position for liquidation\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) private {\n        // load\n        _loadUpdateContext(context, account);\n\n        // magic values\n        collateral = _processCollateralMagicValue(context, collateral);\n        newMaker = _processPositionMagicValue(context, context.currentPosition.local.maker, newMaker);\n        newLong = _processPositionMagicValue(context, context.currentPosition.local.long, newLong);\n        newShort = _processPositionMagicValue(context, context.currentPosition.local.short, newShort);\n\n        // update position\n        Order memory newOrder =\n            context.currentPosition.local.update(context.currentTimestamp, newMaker, newLong, newShort);\n        context.currentPosition.global.update(context.currentTimestamp, newOrder, context.riskParameter);\n\n        // update fee\n        newOrder.registerFee(context.latestVersion, context.marketParameter, context.riskParameter);\n        context.currentPosition.local.registerFee(newOrder);\n        context.currentPosition.global.registerFee(newOrder);\n\n        // update collateral\n        context.local.update(collateral);\n        context.currentPosition.local.update(collateral);\n        context.pendingCollatera"
    }
  ]
}