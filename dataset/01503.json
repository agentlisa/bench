{
  "Title": "M-11: WConvexPool.sol will be broken on Arbitrum due to improper integration with Convex Arbitrum contracts",
  "Content": "# Issue M-11: WConvexPool.sol will be broken on Arbitrum due to improper integration with Convex Arbitrum contracts \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/119 \n\n## Found by \nKow\nWConvexPool (and consequently ConvexSpell) will be completely broken on Arbitrum due to not accounting for implementation differences in Convex Arbitrum contracts.\n\n## Vulnerability Detail\nWConvexPool.sol is the contract expected to be deployed to both mainnet and Arbitrum (sponsor confirmed). While it does integrate with mainnet Convex contracts, it does not account for implementation differences in Arbitrum Convex contracts (briefly mentioned in their [docs](https://docs.convexfinance.com/convexfinanceintegration/side-chain-implemention) with the Arbitrum version of the Booster contract that Blueberry integrates with found [here](https://arbiscan.io/address/0xF403C135812408BFbE8713b5A23a04b3D48AAE31#readContract)). The primary issue is the change in arguments returned from ``cvxPools.poolInfo()`` when calling [``getPoolInfoFromPoolId``](https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L103-L126). Since the return signature expects 6 values (through destructuring) while the Arbitrum Booster contract's getter only returns 5 (due to a slight change in the [PoolInfo struct](https://github.com/convex-eth/sidechain-platform/blob/b9525005549c8f2d364d092bfd902b8eb05d7079/contracts/contracts/Booster.sol#L36-L43) - mainnet struct [here](https://github.com/convex-eth/platform/blob/a5da3f127a321467a97a684c57970d2586520172/contracts/contracts/Booster.sol#L48-L55)), all attempts to call it will revert. This is called in [``pendingRewards``](https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L179-L191), [``mint``](https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L235-L241), and [``burn``](https://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L276-L292), 3 of the main functions in WConvexPool, and will consequently disable any interaction with it (this includes ConvexSpell which also uses this function and also attempts to call mint/burn for position management).\n\nOther issues include the use of ``cvxPools.deposit(...)`` and ``cvxPools.withdraw(...)`` which do not match any function signatures in the Arbitrum Booster contract (``withdraw`` has been changed to ``withdrawTo`` with different arguments and ``deposit`` no longer includes the 3rd argument).\n\n## Impact\nConvex integration will be completely broken on Arbitrum due to unaccounted for implementation differences.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L103-L126\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L179-L191\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L235-L241\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/7c7e1c4a8f3012d1afd2e598b656010bb9127836/blueberry-core/contracts/wrapper/WConvexPools.sol#L276-L292\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider creating a separate contract for WConvexPools for Arbitrum that correctly accounts for the Convex Booster implementation changes.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/wrapper/WConvexPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\nimport \"../interfaces/convex/ICvxExtraRewarder.sol\";\nimport \"../interfaces/convex/IConvex.sol\";\n\n/// @title WConvexPools\n/// @author BlueberryProtocol\n/// @notice Wrapped Convex Pools is the wrapper of LP positions.\n/// @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n///      and do not generate yields. LP Tokens are identified by tokenIds\n///      encoded from lp token address.\ncontract WConvexPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWConvexPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Convex Pools contract\n    ICvxPools public cvxPools;\n    /// @dev Address to CVX token\n    IConvex public CVX;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    /// @dev Initialize the smart contract references.\n    /// @param cvx_ Address of the CVX token.\n    /// @param cvxPools_ Address of the Convex Pools.\n    function initialize(address cvx_, address cvxPools_) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WConvexPools\");\n        CVX = IConvex(cvx_);\n        cvxPools = ICvxPools(cvxPools_);\n    }\n\n    /// @notice Encode pid and cvxPerShare into an ERC1155 token id.\n    /// @param pid Pool id which is the first 16 bits.\n    /// @param cvxPerShare CVX amount per share, which should be multiplied by 1e18 and is the last 240 bits.\n    /// @return id The encoded token id.\n    function encodeId(\n        uint256 pid,\n        uint256 cvxPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (cvxPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(cvxPerShare);\n        return (pid << 240) | cvxPerShare;\n    }\n\n    /// @notice Decode an ERC1155 token id into its pid and cvxPerShare components.\n    /// @param id Token id.\n    /// @return pid The decoded pool id.\n    /// @return cvxPerShare The decoded CVX amount per share.\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 pid, uint256 cvxPerShare) {\n        pid = id >> 240; // Extract the first 16 bits\n        cvxPerShare = id & ((1 << 240) - 1); // Extract the last 240 bits\n    }\n\n    /// @notice Fetch the underlying ERC20 token of the given ERC1155 token id.\n    /// @param id Token id.\n    /// @return uToken Address of the underlying ERC20 token.\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Fetch pool information from the Convex Booster.\n    /// @param pid Convex pool id.\n    /// @return lptoken Address of the liquidity provider token.\n    /// @return token Address of the reward token.\n    /// @return gauge Address of the gauge contract.\n    /// @return crvRewards Address of the Curve rewards contract.\n    /// @return stash Address of the stash contract.\n    /// @return shutdown Indicates if the pool is shutdown.\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return cvxPools.poolInfo(pid);\n    }\n\n    /// @notice Get pending reward amount\n    /// @param stRewardPerShare reward per share\n    /// @param rewarder Address of rewarder contract\n    /// @param amount lp amount\n    /// @param lpDecimals lp decimals\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// Calculates the CVX pending reward based on CRV reward\n    /// @param crvAmount Amount of CRV reward\n    /// @return mintAmount The pending CVX reward\n    function _getCvxPendingReward(\n        uint256 crvAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// CVX token mint logic\n        uint256 totalCliffs = CVX.totalCliffs();\n        uint256 totalSupply = CVX.totalSupply();\n        uint256 maxSupply = CVX.maxSupply();\n        uint256 reductionPerCliff = CVX.reductionPerCliff();\n        uint256 cliff = totalSupply / reductionPerCliff;\n\n        if (totalSupply == 0) {\n            mintAmount = crvAmount;\n        }\n\n        if (cliff < totalCliffs) {\n            uint256 reduction = totalCliffs - cliff;\n            mintAmount = (crvAmount * reduction) / totalCliffs;\n            uint256 amtTillMax = maxSupply - totalSupply;\n\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// Returns pending rewards from the farming pool\n    /// @param tokenId Token Id\n    /// @param amount Amount of share\n    /// @return tokens An array of token addresses for rewards\n    /// @return rewards An array of pending rewards corresponding to the tokens\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// CRV reward\n        tokens[0] = IRewarder(cvxRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            cvxRewarder,\n            amount,\n            lpDecimals\n        );\n\n        /// CVX reward\n        tokens[1] = address(CVX);\n        rewards[1] = _getCvxPendingReward(rewards[0]);\n\n        for (uint i = 0; i < extraRewardsCount; ) {\n            address rewarder = extraRewards[i];\n            uint256 stRewardPerShare = accExtPerShare[tokenId][rewarder];\n            tokens[i + 2] = IRewarder(rewarder).rewardToken();\n            if (stRewardPerShare == 0) {\n                rewards[i + 2] = 0;\n            } else {\n                rewards[i + 2] = _getPendingReward(\n                    stRewardPerShare == type(uint).max ? 0 : stRewardPerShare,\n                    rewarder,\n                    amount,\n                    lpDecimals\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Mints ERC1155 token for the given LP token\n    /// @param pid Convex Pool id\n    /// @param amount Token amount to wrap\n    /// @return id The minted token ID\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(cvxPools), amount);\n        cvxPools.deposit(pid, amount, true);\n\n        uint256 crvRewardPerToken = IRewarder(cvxRewarder).rewardPerToken();\n        id = encodeId(pid, crvRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n        /// Store extra rewards info\n        uint extraRewardsCount = IRewarder(cvxRewarder).extraRewardsLength();\n        for (uint i; i < extraRewardsCount; ) {\n            address extraRewarder = IRewarder(cvxRewarder).extraRewards(i);\n            uint rewardPerToken = IRewarder(extraRewarder).rewardPerToken();\n            accExtPerShare[id][extraRewarder] = rewardPerToken == 0\n                ? type(uint).max\n                : rewardPerToken;\n\n            _syncExtraReward(extraRewarder);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Burns ERC1155 token to redeem ERC20 token back and harvest rewards\n    /// @param id Token id to burn\n    /// @param amount Token amount to burn\n    /// @return rewardTokens The array of reward token addresses\n    /// @return rewards The array of harvested reward amounts\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        /// Claim Rewards\n        IRewarder(cvxRewarder).withdraw(amount, true);\n        /// Withdraw LP\n        cvxPools.withdraw(pid, amount);\n\n        /// Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        uint extraRewardsCount = IRewarder(cvxRewarder).extraRewardsLength();\n\n        for (uint i; i < extraRewardsCount; ) {\n            _syncExtraReward(IRewarder(cvxRewarder).extraRewards(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint storedExtraRewardLength = extraRewards.length;\n        bool hasDiffExtraRewards = extraRewardsCount != storedExtraRewardLength;\n\n        /// Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        /// Withdraw manually\n        if (hasDiffExtraRewards) {\n            for (uint i; i < storedExtraRewardLength; ) {\n                ICvxExtraRewarder(extraRewards[i]).getReward();\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint rewardLen = rewardTokens.length;\n        for (uint i; i < rewardLen; ) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Gets the length of the extra rewards array\n    /// @return Length of the extra rewards array\n    function extraRewardsLength() external view returns (uint) {\n        return extraRewards.length;\n    }\n\n    /// Internal function to synchronize extra rewards\n    function _syncExtraReward(address extraReward) private {\n        if (extraRewardsIdx[extraReward] == 0) {\n            extraRewards.push(extraReward);\n            extraRewardsIdx[extraReward] = extraRewards.length;\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/wrapper/WConvexPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\nimport \"../interfaces/convex/ICvxExtraRewarder.sol\";\nimport \"../interfaces/convex/IConvex.sol\";\n\n/// @title WConvexPools\n/// @author BlueberryProtocol\n/// @notice Wrapped Convex Pools is the wrapper of LP positions.\n/// @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n///      and do not generate yields. LP Tokens are identified by tokenIds\n///      encoded from lp token address.\ncontract WConvexPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWConvexPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Convex Pools contract\n    ICvxPools public cvxPools;\n    /// @dev Address to CVX token\n    IConvex public CVX;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    /// @dev Initialize the smart contract references.\n    /// @param cvx_ Address of the CVX token.\n    /// @param cvxPools_ Address of the Convex Pools.\n    function initialize(address cvx_, address cvxPools_) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WConvexPools\");\n        CVX = IConvex(cvx_);\n        cvxPools = ICvxPools(cvxPools_);\n    }\n\n    /// @notice Encode pid and cvxPerShare into an ERC1155 token id.\n    /// @param pid Pool id which is the first 16 bits.\n    /// @param cvxPerShare CVX amount per share, which should be multiplied by 1e18 and is the last 240 bits.\n    /// @return id The encoded token id.\n    function encodeId(\n        uint256 pid,\n        uint256 cvxPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (cvxPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(cvxPerShare);\n        return (pid << 240) | cvxPerShare;\n    }\n\n    /// @notice Decode an ERC1155 token id into its pid and cvxPerShare components.\n    /// @param id Token id.\n    /// @return pid The decoded pool id.\n    /// @return cvxPerShare The decoded CVX amount per share.\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 pid, uint256 cvxPerShare) {\n        pid = id >> 240; // Extract the first 16 bits\n        cvxPerShare = id & ((1 << 240) - 1); // Extract the last 240 bits\n    }\n\n    /// @notice Fetch the underlying ERC20 token of the given ERC1155 token id.\n    /// @param id Token id.\n    /// @return uToken Address of the underlying ERC20 token.\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Fetch pool information from the Convex Booster.\n    /// @param pid Convex pool id.\n    /// @return lptoken Address of the liquidity provider token.\n    /// @return token Address of the reward token.\n    /// @return gauge Address of the gauge contract.\n    /// @return crvRewards Address of the Curve rewards contract.\n    /// @return stash Address of the stash contract.\n    /// @return shutdown Indicates if the pool is shutdown.\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return cvxPools.poolInfo(pid);\n    }\n\n    /// @notice Get pending reward amount\n    /// @param stRewardPerShare reward per share\n    /// @param rewarder Address of rewarder contract\n    /// @param amount lp amount\n    /// @param lpDecimals lp decimals\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// Calculates the CVX pending reward based on CRV reward\n    /// @param crvAmount Amount of CRV reward\n    /// @return mintAmount The pending CVX reward\n    function _getCvxPendingReward(\n        uint256 crvAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// CVX token mint logic\n        uint256 totalCliffs = CVX.totalCliffs();\n        uint256 totalSupply = CVX.totalSupply();\n        uint256 maxSupply = CVX.maxSupply();\n        uint256 reductionPerCliff = CVX.reductionPerCliff();\n        uint256 cliff = totalSupply / reductionPerCliff;\n\n        if (totalSupply == 0) {\n            mintAmount = crvAmount;\n        }\n\n        if (cliff < totalCliffs) {\n            uint256 reduction = totalCliffs - cliff;\n            mintAmount = (crvAmount * reduction) / totalCliffs;\n            uint256 amtTillMax = maxSupply - totalSupply;\n\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// Returns pending rewards from the farming pool\n    /// @param tokenId Token Id\n    /// @param amount Amount of share\n    /// @return tokens An array of token addresses for rewards\n    /// @return rewards An array of pending rewards corresponding to the tokens\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// CRV reward\n        tokens[0] = IRewarder(cvxRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            cvxRewarder,\n            amount,\n            lpDecimals\n        );\n\n        /// CVX reward\n        tokens[1] = address(CVX);\n        rewards[1] = _getCvxPendingReward(rewards[0]);\n\n        for (uint i = 0; i < extraRewardsCount; ) {\n            address rewarder = extraRewards[i];\n            uint256 stRewardPerShare = accExtPerShare[tokenId][rewarder];\n            tokens[i + 2] = IRewarder(rewarder).rewardToken();\n            if (stRewardPerShare == 0) {\n                rewards[i + 2] = 0;\n            } else {\n                rewards[i + 2] = _getPendingReward(\n                    stRewardPerShare == type(uint).max ? 0 : stRewardPerShare,\n                    rewarder,\n                    amount,\n                    lpDecimals\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Mints ERC1155 token for the given LP token\n    /// @param pid Convex Pool id\n    /// @param amount Token amount to wrap\n    /// @return id The minted token ID\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(cvxPools), amount);\n        cvxPools.deposit(pid, amount, true);\n\n        uint256 crvRewardPerToken = IRewarder(cvxRewarder).rewardPerToken();\n        id = encodeId(pid, crvRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n        /// Store extra rewards info\n        uint extraRewardsCount = IRewarder(cvxRewarder).extraRewardsLength();\n        for (uint i; i < extraRewardsCount; ) {\n            address extraRewarder = IRewarder(cvxRewarder).extraRewards(i);\n            uint rewardPerToken = IRewarder(extraRewarder).rewardPerToken();\n            accExtPerShare[id][extraRewarder] = rewardPerToken == 0\n                ? type(uint).max\n                : rewardPerToken;\n\n            _syncExtraReward(extraRewarder);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Burns ERC1155 token to redeem ERC20 token back and harvest rewards\n    /// @param id Token id to burn\n    /// @param amount Token amount to burn\n    /// @return rewardTokens The array of reward token addresses\n    /// @return rewards The array of harvested reward amounts\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        /// Claim Rewards\n        IRewarder(cvxRewarder).withdraw(amount, true);\n        /// Withdraw LP\n        cvxPools.withdraw(pid, amount);\n\n        /// Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        uint extraRewardsCount = IRewarder(cvxRewarder).extraRewardsLength();\n\n        for (uint i; i < extraRewardsCount; ) {\n            _syncExtraReward(IRewarder(cvxRewarder).extraRewards(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint storedExtraRewardLength = extraRewards.length;\n        bool hasDiffExtraRewards = extraRewardsCount != storedExtraRewardLength;\n\n        /// Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        /// Withdraw manually\n        if (hasDiffExtraRewards) {\n            for (uint i; i < storedExtraRewardLength; ) {\n                ICvxExtraRewarder(extraRewards[i]).getReward();\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint rewardLen = rewardTokens.length;\n        for (uint i; i < rewardLen; ) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Gets the length of the extra rewards array\n    /// @return Length of the extra rewards array\n    function extraRewardsLength() external view returns (uint) {\n        return extraRewards.length;\n    }\n\n    /// Internal function to synchronize extra rewards\n    function _syncExtraReward(address extraReward) private {\n        if (extraRewardsIdx[extraReward] == 0) {\n            extraRewards.push(extraReward);\n            extraRewardsIdx[extraReward] = extraRewards.length;\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/wrapper/WConvexPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\nimport \"../interfaces/convex/ICvxExtraRewarder.sol\";\nimport \"../interfaces/convex/IConvex.sol\";\n\n/// @title WConvexPools\n/// @author BlueberryProtocol\n/// @notice Wrapped Convex Pools is the wrapper of LP positions.\n/// @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n///      and do not generate yields. LP Tokens are identified by tokenIds\n///      encoded from lp token address.\ncontract WConvexPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWConvexPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Convex Pools contract\n    ICvxPools public cvxPools;\n    /// @dev Address to CVX token\n    IConvex public CVX;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    /// @dev Initialize the smart contract references.\n    /// @param cvx_ Address of the CVX token.\n    /// @param cvxPools_ Address of the Convex Pools.\n    function initialize(address cvx_, address cvxPools_) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WConvexPools\");\n        CVX = IConvex(cvx_);\n        cvxPools = ICvxPools(cvxPools_);\n    }\n\n    /// @notice Encode pid and cvxPerShare into an ERC1155 token id.\n    /// @param pid Pool id which is the first 16 bits.\n    /// @param cvxPerShare CVX amount per share, which should be multiplied by 1e18 and is the last 240 bits.\n    /// @return id The encoded token id.\n    function encodeId(\n        uint256 pid,\n        uint256 cvxPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (cvxPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(cvxPerShare);\n        return (pid << 240) | cvxPerShare;\n    }\n\n    /// @notice Decode an ERC1155 token id into its pid and cvxPerShare components.\n    /// @param id Token id.\n    /// @return pid The decoded pool id.\n    /// @return cvxPerShare The decoded CVX amount per share.\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 pid, uint256 cvxPerShare) {\n        pid = id >> 240; // Extract the first 16 bits\n        cvxPerShare = id & ((1 << 240) - 1); // Extract the last 240 bits\n    }\n\n    /// @notice Fetch the underlying ERC20 token of the given ERC1155 token id.\n    /// @param id Token id.\n    /// @return uToken Address of the underlying ERC20 token.\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Fetch pool information from the Convex Booster.\n    /// @param pid Convex pool id.\n    /// @return lptoken Address of the liquidity provider token.\n    /// @return token Address of the reward token.\n    /// @return gauge Address of the gauge contract.\n    /// @return crvRewards Address of the Curve rewards contract.\n    /// @return stash Address of the stash contract.\n    /// @return shutdown Indicates if the pool is shutdown.\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return cvxPools.poolInfo(pid);\n    }\n\n    /// @notice Get pending reward amount\n    /// @param stRewardPerShare reward per share\n    /// @param rewarder Address of rewarder contract\n    /// @param amount lp amount\n    /// @param lpDecimals lp decimals\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// Calculates the CVX pending reward based on CRV reward\n    /// @param crvAmount Amount of CRV reward\n    /// @return mintAmount The pending CVX reward\n    function _getCvxPendingReward(\n        uint256 crvAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// CVX token mint logic\n        uint256 totalCliffs = CVX.totalCliffs();\n        uint256 totalSupply = CVX.totalSupply();\n        uint256 maxSupply = CVX.maxSupply();\n        uint256 reductionPerCliff = CVX.reductionPerCliff();\n        uint256 cliff = totalSupply / reductionPerCliff;\n\n        if (totalSupply == 0) {\n            mintAmount = crvAmount;\n        }\n\n        if (cliff < totalCliffs) {\n            uint256 reduction = totalCliffs - cliff;\n            mintAmount = (crvAmount * reduction) / totalCliffs;\n            uint256 amtTillMax = maxSupply - totalSupply;\n\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// Returns pending rewards from the farming pool\n    /// @param tokenId Token Id\n    /// @param amount Amount of share\n    /// @return tokens An array of token addresses for rewards\n    /// @return rewards An array of pending rewards corresponding to the tokens\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// CRV reward\n        tokens[0] = IR"
    }
  ]
}