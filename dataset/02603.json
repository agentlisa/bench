{
  "Title": "Use of deprecated function for setting token allowances",
  "Content": "Throughout the [codebase](https://github.com/pods-finance/yield-contracts/tree/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts) there were multiple locations where the deprecated [`safeApprove`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/token/ERC20/utils/SafeERC20.sol#L40-L44) function was used to set allowances:\n\n\n* [Line 352](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/BaseVault.sol#L352) in `BaseVault`\n* [Line 35](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/Migration.sol#L35) in `Migration`\n* [Line 57](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/Migration.sol#L57) in `Migration`\n* [Line 43](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L43) in `ETHAdapter`\n* [Line 112](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/proxy/ETHAdapter.sol#L112) in `ETHAdapter`\n\n\nIf in any of these locations an allowance is carried over for more than the duration of a transaction, `safeApprove` may [revert](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/token/ERC20/utils/SafeERC20.sol#L54-L56) in subsequent transactions. Consider replacing the instances of `safeApprove` with the recommended [`safeIncreaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/token/ERC20/utils/SafeERC20.sol#L61) or [`safeDecreaseAllowance`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/token/ERC20/utils/SafeERC20.sol#L70) instead.\n\n\n**Update:** *Resolved in [PR#105](https://github.com/pods-finance/yield-contracts/pull/105), with commit `7e6bdbcb3d1fff657c81810750521fa0278e4a07` being the last one added.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { EnumerableMap } from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { CastUint } from \"../libs/CastUint.sol\";\nimport { Capped } from \"../mixins/Capped.sol\";\n\n/**\n * @title BaseVault\n * @notice A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, ERC4626, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n    using CastUint for uint256;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    /**\n     * @dev DENOMINATOR represents the precision for the following system variables:\n     * - MAX_WITHDRAW_FEE\n     * - INVESTOR_RATIO\n     */\n    uint256 public constant DENOMINATOR = 10000;\n    /**\n     * @dev MAX_WITHDRAW_FEE is a safe check in case the ConfigurationManager sets\n     * a fee high enough that can be used as a way to drain funds.\n     * The precision of this number is set by constant DENOMINATOR.\n     */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    /**\n     * @notice Minimum asset amount for the first deposit\n     * @dev This amount that prevents the first depositor to steal funds from subsequent depositors.\n     * See https://code4rena.com/reports/2022-01-sherlock/#h-01-first-user-can-steal-everyone-elses-tokens\n     */\n    uint256 public immutable MIN_INITIAL_ASSETS;\n\n    IConfigurationManager public immutable configuration;\n    VaultState internal vaultState;\n    EnumerableMap.AddressToUintMap internal depositQueue;\n\n    constructor(\n        IConfigurationManager configuration_,\n        IERC20Metadata asset_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) ERC20Permit(name_) ERC4626(asset_) Capped(configuration_) {\n        configuration = configuration_;\n\n        // Vault starts in `start` state\n        emit RoundStarted(vaultState.currentRoundId, 0);\n        vaultState.lastEndRoundTimestamp = uint32(block.timestamp);\n\n        MIN_INITIAL_ASSETS = 10**uint256(asset_.decimals());\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= vaultState.lastEndRoundTimestamp + 1 weeks;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    modifier whenNotProcessingDeposits() {\n        if (vaultState.isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        _;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function currentRoundId() external view returns (uint32) {\n        return vaultState.currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function isProcessingDeposits() external view returns (bool) {\n        return vaultState.isProcessingDeposits;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processedDeposits() external view returns (uint256) {\n        return vaultState.processedDeposits;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        whenNotProcessingDeposits\n        returns (uint256)\n    {\n        return super.deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override whenNotProcessingDeposits returns (uint256) {\n        IERC20Permit(asset()).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        return super.deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        whenNotProcessingDeposits\n        returns (uint256)\n    {\n        return super.mint(shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override whenNotProcessingDeposits returns (uint256) {\n        uint256 assets = previewMint(shares);\n        IERC20Permit(asset()).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        return super.mint(shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override(ERC4626, IERC4626) whenNotProcessingDeposits returns (uint256 assets) {\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdrawWithFees(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override(ERC4626, IERC4626) whenNotProcessingDeposits returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n        (, shares) = _withdrawWithFees(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n        uint256 assets = _convertToAssets(shares, Math.Rounding.Down);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        uint256 _availableCap = availableCap();\n        if (_availableCap != type(uint256).max) {\n            return previewMint(_availableCap);\n        }\n        return _availableCap;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        return availableCap();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function getWithdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return Math.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        (, uint256 assets) = depositQueue.tryGet(owner);\n        return assets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) external view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0\n            ? 0\n            : shares.mulDiv(IERC20Metadata(asset()).balanceOf(address(this)), supply, Math.Rounding.Down);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return vaultState.totalIdleAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.length();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function queuedDeposits() public view returns (address[] memory) {\n        address[] memory addresses = new address[](depositQueue.length());\n        for (uint256 i = 0; i < addresses.length; i++) {\n            (address owner, ) = depositQueue.at(i);\n            addresses[i] = owner;\n        }\n        return addresses;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint32) {\n        if (!vaultState.isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        vaultState.isProcessingDeposits = false;\n\n        _afterRoundStart();\n        emit RoundStarted(vaultState.currentRoundId, vaultState.processedDeposits);\n        vaultState.processedDeposits = 0;\n\n        return vaultState.currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (vaultState.isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        vaultState.isProcessingDeposits = true;\n        _afterRoundEnd();\n        vaultState.lastEndRoundTimestamp = uint32(block.timestamp);\n\n        emit RoundEnded(vaultState.currentRoundId);\n\n        vaultState.currentRoundId += 1;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        (, assets) = depositQueue.tryGet(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        if (depositQueue.remove(msg.sender)) {\n            vaultState.totalIdleAssets -= assets;\n            _restoreCap(convertToShares(assets));\n        }\n\n        emit DepositRefunded(msg.sender, vaultState.currentRoundId, assets);\n        IERC20Metadata(asset()).safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (!configuration.isVaultMigrationAllowed(address(this), address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        IERC20Metadata(asset()).safeApprove(address(newVault), assets);\n        newVault.handleMigration(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function handleMigration(uint256 assets, address receiver) external override returns (uint256) {\n        if (!configuration.isVaultMigrationAllowed(msg.sender, address(this))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        return deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(address[] calldata depositors) external {\n        if (!vaultState.isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        for (uint256 i = 0; i < depositors.length; i++) {\n            if (depositQueue.contains(depositors[i])) {\n                vaultState.processedDeposits += _processDeposit(depositors[i]);\n            }\n        }\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(address depositor) internal virtual returns (uint256) {\n        uint256 currentAssets = totalAssets();\n        uint256 supply = totalSupply();\n        uint256 assets = depositQueue.get(depositor);\n        uint256 shares = currentAssets == 0 || supply == 0\n            ? assets\n            : assets.mulDiv(supply, currentAssets, Math.Rounding.Down);\n\n        if (supply == 0 && assets < MIN_INITIAL_ASSETS) {\n            revert IVault__AssetsUnderMinimumAmount(assets);\n        }\n\n        depositQueue.remove(depositor);\n        vaultState.totalIdleAssets -= assets;\n        _mint(depositor, shares);\n        emit DepositProcessed(depositor, vaultState.currentRoundId, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Add a new entry to the deposit to queue\n     */\n    function _addToDepositQueue(address receiver, uint256 assets) internal {\n        (, uint256 previous) = depositQueue.tryGet(receiver);\n        vaultState.totalIdleAssets += assets;\n        depositQueue.set(receiver, previous + assets);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDiv(getWithdrawFeeRatio(), DENOMINATOR, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev Pull assets from the caller and add it to the deposit queue\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        IERC20Metadata(asset()).safeTransferFrom(caller, address(this), assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        IERC20Metadata(asset()).safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            IERC20Metadata(asset()).safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    /* solhint-disable no-empty-blocks */\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after the shares were burned\n     */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after setting isProcessingDeposits to false\n     */\n    function _afterRoundStart() internal virtual {}\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after setting isProcessingDeposits to true\n     */\n    function _afterRoundEnd() internal virtual {}\n\n    /* solhint-enable no-empty-blocks */\n}"
    },
    {
      "filename": "contracts/proxy/Migration.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract Migration {\n    using SafeERC20 for IERC20;\n\n    IConfigurationManager public immutable configuration;\n\n    error Migration__MigrationNotAllowed();\n\n    constructor(IConfigurationManager _configuration) {\n        configuration = _configuration;\n    }\n\n    function migrate(\n        IVault from,\n        IVault to,\n        uint256 shares\n    ) external returns (uint256) {\n        if (!configuration.isVaultMigrationAllowed(address(from), address(to))) {\n            revert Migration__MigrationNotAllowed();\n        }\n\n        from.redeem(shares, address(this), msg.sender);\n\n        IERC20 asset = IERC20(from.asset());\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(to), balance);\n        return to.deposit(balance, msg.sender);\n    }\n\n    function migrateWithPermit(\n        IVault from,\n        IVault to,\n        uint256 shares,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        if (!configuration.isVaultMigrationAllowed(address(from), address(to))) {\n            revert Migration__MigrationNotAllowed();\n        }\n\n        IERC20Permit(address(from)).permit(msg.sender, address(this), shares, deadline, v, r, s);\n        from.redeem(shares, address(this), msg.sender);\n\n        IERC20 asset = IERC20(from.asset());\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(to), balance);\n        return to.deposit(balance, msg.sender);\n    }\n}"
    },
    {
      "filename": "contracts/proxy/Migration.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract Migration {\n    using SafeERC20 for IERC20;\n\n    IConfigurationManager public immutable configuration;\n\n    error Migration__MigrationNotAllowed();\n\n    constructor(IConfigurationManager _configuration) {\n        configuration = _configuration;\n    }\n\n    function migrate(\n        IVault from,\n        IVault to,\n        uint256 shares\n    ) external returns (uint256) {\n        if (!configuration.isVaultMigrationAllowed(address(from), address(to))) {\n            revert Migration__MigrationNotAllowed();\n        }\n\n        from.redeem(shares, address(this), msg.sender);\n\n        IERC20 asset = IERC20(from.asset());\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(to), balance);\n        return to.deposit(balance, msg.sender);\n    }\n\n    function migrateWithPermit(\n        IVault from,\n        IVault to,\n        uint256 shares,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        if (!configuration.isVaultMigrationAllowed(address(from), address(to))) {\n            revert Migration__MigrationNotAllowed();\n        }\n\n        IERC20Permit(address(from)).permit(msg.sender, address(this), shares, deadline, v, r, s);\n        from.redeem(shares, address(this), msg.sender);\n\n        IERC20 asset = IERC20(from.asset());\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(to), balance);\n        return to.deposit(balance, msg.sender);\n    }\n}"
    },
    {
      "filename": "contracts/proxy/ETHAdapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ICurvePool } from \"../interfaces/ICurvePool.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ETHAdapter {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    ICurvePool public immutable pool;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant STETH_ADDRESS = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    error ETHAdapter__IncompatibleVault();\n    error ETHAdapter__IncompatiblePool();\n\n    constructor(ICurvePool _pool) {\n        if (_pool.coins(0) != ETH_ADDRESS || _pool.coins(1) != STETH_ADDRESS) revert ETHAdapter__IncompatiblePool();\n        pool = _pool;\n    }\n\n    function convertToSTETH(uint256 ethAmount) external view returns (uint256) {\n        return pool.get_dy(0, 1, ethAmount);\n    }\n\n    function convertToETH(uint256 stETHAmount) external view returns (uint256) {\n        return pool.get_dy(1, 0, stETHAmount);\n    }\n\n    function deposit(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) external payable returns (uint256 shares) {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        uint256 assets = pool.exchange{ value: msg.value }(0, 1, msg.value, minOutput);\n        IERC20(vault.asset()).safeApprove(address(vault), assets);\n        return vault.deposit(assets, receiver);\n    }\n\n    function redeem(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 assets) {\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function redeemWithPermit(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 assets) {\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdraw(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 shares) {\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdrawWithPermit(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        shares = vault.convertToShares(assets);\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    /* We need this default function because this contract will\n        receive ETH from the Curve pool\n    */\n    receive() external payable {}\n\n    function _returnETH(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) internal {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        IERC20 asset = IERC20(vault.asset());\n\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(pool), balance);\n        pool.exchange(1, 0, balance, minOutput);\n\n        payable(receiver).sendValue(address(this).balance);\n    }\n}"
    },
    {
      "filename": "contracts/proxy/ETHAdapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ICurvePool } from \"../interfaces/ICurvePool.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\n\ncontract ETHAdapter {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    ICurvePool public immutable pool;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant STETH_ADDRESS = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    error ETHAdapter__IncompatibleVault();\n    error ETHAdapter__IncompatiblePool();\n\n    constructor(ICurvePool _pool) {\n        if (_pool.coins(0) != ETH_ADDRESS || _pool.coins(1) != STETH_ADDRESS) revert ETHAdapter__IncompatiblePool();\n        pool = _pool;\n    }\n\n    function convertToSTETH(uint256 ethAmount) external view returns (uint256) {\n        return pool.get_dy(0, 1, ethAmount);\n    }\n\n    function convertToETH(uint256 stETHAmount) external view returns (uint256) {\n        return pool.get_dy(1, 0, stETHAmount);\n    }\n\n    function deposit(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) external payable returns (uint256 shares) {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        uint256 assets = pool.exchange{ value: msg.value }(0, 1, msg.value, minOutput);\n        IERC20(vault.asset()).safeApprove(address(vault), assets);\n        return vault.deposit(assets, receiver);\n    }\n\n    function redeem(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 assets) {\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function redeemWithPermit(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 assets) {\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdraw(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 shares) {\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdrawWithPermit(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        shares = vault.convertToShares(assets);\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    /* We need this default function because this contract will\n        receive ETH from the Curve pool\n    */\n    receive() external payable {}\n\n    function _returnETH(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) internal {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        IERC20 asset = IERC20(vault.asset());\n\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(pool), balance);\n        pool.exchange(1, 0, balance, minOutput);\n\n        payable(receiver).sendValue(address(this).balance);\n    }\n}"
    },
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    }
  ]
}