{
  "Title": "M-2: Expired locks should not continue to earn rewards at the original high multiplier rate",
  "Content": "# Issue M-2: Expired locks should not continue to earn rewards at the original high multiplier rate \n\nSource: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/108 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nExpired locks should be considered as same as the deposits with no lock.\n\n## Vulnerability Detail\n\nThe current implementation allows the deposits with expired locks to continue to enjoy the original high multiplier rate, while they can withdraw anytime they want.\n\nThe multiplier of shares amount is essentially a higher reward rate (APR) for longer period of locks.\n\nFor example:\n\nIf the regular APR is 2%; Locking for 4 years will boost the APR to 10%.\n\n- Alice deposited 1M $MC tokens and got 10% APR;\n- 4 years later, Alice's deposit's lock was expired.\n\nExpected result:\n\nThe new APR for Alice's deposit is 2%;\n\nActual result:\n\nAlice can continue to enjoy a 10% APR while she can withdraw anytime.\n\n## Impact\n\nUsers with expired locks will take more rewards than expected, which means fewer rewards for other users.\n\n## Code Snippet\n\nhttps://github.com/Merit-Circle/merit-liquidity-mining/blob/ce5feaae19126079d309ac8dd9a81372648437f1/contracts/TimeLockPool.sol#L116-L135\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCurve's Gauge system introduced a method called `kick()` which allows the expired (zeroed) veCRV users to be kicked from the rewards.\n\nSee: https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/gauges/LiquidityGaugeV5.vy#L430-L446\n\nA similar method can be added to solve this issue:\n\n```solidity\nfunction kick(uint256 _depositId, address _user) external {\n    if (_depositId >= depositsOf[_user].length) {\n        revert NonExistingDepositError();\n    }\n    Deposit memory userDeposit = depositsOf[_user][_depositId];\n    if (block.timestamp < userDeposit.end) {\n        revert TooSoonError();\n    }\n\n    // burn pool shares\n    _burn(_user, userDeposit.shareAmount - userDeposit.amount);\n}\n```\n\n## Discussion\n\n**federava**\n\nAgree on the recommendation, will implement kick function. Noticing that shares go back to a 1:1 ratio and that the function can be called by anyone is a good design choice.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/16) from this issue\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/9",
  "Code": [
    {
      "filename": "contracts/TimeLockPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./base/BasePool.sol\";\nimport \"./interfaces/ITimeLockPool.sol\";\n\ncontract TimeLockPool is BasePool, ITimeLockPool {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    error SmallMaxLockDuration();\n    error NonExistingDepositError();\n    error TooSoonError();\n    error MaxBonusError();\n\n    uint256 public maxBonus;\n    uint256 public maxLockDuration;\n    uint256 public constant MIN_LOCK_DURATION = 10 minutes;\n    \n    uint256[] public curve;\n    uint256 public unit;\n\n    mapping(address => Deposit[]) public depositsOf;\n\n    struct Deposit {\n        uint256 amount;\n        uint256 shareAmount;\n        uint64 start;\n        uint64 end;\n    }\n    function __TimeLockPool_init(\n        string memory _name,\n        string memory _symbol,\n        address _depositToken,\n        address _rewardToken,\n        address _escrowPool,\n        uint256 _escrowPortion,\n        uint256 _escrowDuration,\n        uint256 _maxBonus,\n        uint256 _maxLockDuration,\n        uint256[] memory _curve\n    ) internal onlyInitializing {\n        __BasePool_init(_name, _symbol, _depositToken, _rewardToken, _escrowPool, _escrowPortion, _escrowDuration);\n        if (_maxLockDuration < MIN_LOCK_DURATION) {\n            revert SmallMaxLockDuration();\n        }\n        if (_curve.length < 2) {\n            revert ShortCurveError();\n        }\n        for (uint i=0; i < _curve.length; i++) {\n            if (_curve[i] > _maxBonus) {\n                revert MaxBonusError();\n            }\n            curve.push(_curve[i]);\n        }\n        maxBonus = _maxBonus;\n        maxLockDuration = _maxLockDuration;\n        unit = _maxLockDuration / (curve.length - 1);\n    }\n\n    error DepositExpiredError();\n    error ZeroDurationError();\n    error ZeroAmountError();\n    error ShortCurveError();\n\n    event Deposited(uint256 amount, uint256 duration, address indexed receiver, address indexed from);\n    event Withdrawn(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);\n    event LockExtended(uint256 indexed depositId, uint256 duration, address indexed from);\n    event LockIncreased(uint256 indexed depositId, address indexed receiver, address indexed from, uint256 amount);\n    event CurveChanged(address indexed sender);\n\n    /**\n     * @notice Creates a lock with an amount of tokens and mint the corresponding shares.\n     * @dev The function forces the duration to be in between the minimum and maximum\n     * duration if it the duration parameter is outside of those bounds. Uses the multiplier\n     * function to get the amount of shares to mint.\n     * @param _amount uint256 amount of tokens to be deposited\n     * @param _duration uint256 time that the deposit will be locked.\n     * @param _receiver uint256 owner of the lock\n     */\n    function deposit(uint256 _amount, uint256 _duration, address _receiver) external override {\n        if (_amount == 0) {\n            revert ZeroAmountError();\n        }\n        // Don't allow locking > maxLockDuration\n        uint256 duration = _duration.min(maxLockDuration);\n        // Enforce min lockup duration to prevent flash loan or MEV transaction ordering\n        duration = duration.max(MIN_LOCK_DURATION);\n\n        depositToken.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        uint256 mintAmount = _amount * getMultiplier(duration) / 1e18;\n\n        depositsOf[_receiver].push(Deposit({\n            amount: _amount,\n            shareAmount: mintAmount,\n            start: uint64(block.timestamp),\n            end: uint64(block.timestamp) + uint64(duration)\n        }));\n\n        _mint(_receiver, mintAmount);\n        emit Deposited(_amount, duration, _receiver, _msgSender());\n    }\n\n    /**\n     * @notice Withdraws all the tokens from the lock\n     * @dev The lock has to be expired to withdraw the tokens. When the withdrawl happens\n     * the shares minted on the deposit are burnt.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _receiver uint256 owner of the lock\n     */\n    function withdraw(uint256 _depositId, address _receiver) external {\n        if (_depositId >= depositsOf[_msgSender()].length) {\n            revert NonExistingDepositError();\n        }\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n        if (block.timestamp < userDeposit.end) {\n            revert TooSoonError();\n        }\n\n        // remove Deposit\n        depositsOf[_msgSender()][_depositId] = depositsOf[_msgSender()][depositsOf[_msgSender()].length - 1];\n        depositsOf[_msgSender()].pop();\n\n        // burn pool shares\n        _burn(_msgSender(), userDeposit.shareAmount);\n        \n        // return tokens\n        depositToken.safeTransfer(_receiver, userDeposit.amount);\n        emit Withdrawn(_depositId, _receiver, _msgSender(), userDeposit.amount);\n    }\n\n    /**\n     * @notice Adds more time to current lock.\n     * @dev This function extends the duration of a specific lock -deposit- of the sender.\n     * While doing so, it uses the timestamp of the current block and calculates the remaining\n     * time to the end of the lock, and adds the increase duration. This results is a new\n     * duration that can be different to the original duration from the lock one (>, = or <), \n     * and gets multiplied by the correspondant multiplier. The final result can be more, same,\n     * or less shares, which will be minted/burned accordingly.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _increaseDuration uint256 time to be added to the lock meassured from the end of the lock\n     */\n    function extendLock(uint256 _depositId, uint256 _increaseDuration) external {\n        // Check if actually increasing\n        if (_increaseDuration == 0) {\n            revert ZeroDurationError();\n        }\n\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n\n        // Only can extend if it has not expired\n        if (block.timestamp >= userDeposit.end) {\n            revert DepositExpiredError();\n        }\n        \n        // Enforce min increase to prevent flash loan or MEV transaction ordering\n        uint256 increaseDuration = _increaseDuration.max(MIN_LOCK_DURATION);\n        \n        // New duration is the time expiration plus the increase\n        uint256 duration = maxLockDuration.min(uint256(userDeposit.end - block.timestamp) + increaseDuration);\n\n        uint256 mintAmount = userDeposit.amount * getMultiplier(duration) / 1e18;\n\n        // Multiplier curve changes with time, need to check if the mint amount is bigger, equal or smaller than the already minted\n        \n        // If the new amount if bigger mint the difference\n        if (mintAmount > userDeposit.shareAmount) {\n            depositsOf[_msgSender()][_depositId].shareAmount =  mintAmount;\n            _mint(_msgSender(), mintAmount - userDeposit.shareAmount);\n        // If the new amount is less then burn that difference\n        } else if (mintAmount < userDeposit.shareAmount) {\n            depositsOf[_msgSender()][_depositId].shareAmount =  mintAmount;\n            _burn(_msgSender(), userDeposit.shareAmount - mintAmount);\n        }\n\n        depositsOf[_msgSender()][_depositId].start = uint64(block.timestamp);\n        depositsOf[_msgSender()][_depositId].end = uint64(block.timestamp) + uint64(duration);\n        emit LockExtended(_depositId, _increaseDuration, _msgSender());\n    }\n\n    /**\n     * @notice Adds more deposits to current lock.\n     * @dev This function increases the deposit amount of a specific lock -deposit- of the sender.\n     * While doing so, it uses the timestamp of the current block and calculates the remaining\n     * time to the end of the lock. Then it uses this time duration to mint the shares that correspond\n     * to the multiplier of that time and the increase amount being deposited. The result is an increase\n     * both in deposit amount and share amount of the deposit.\n     * @param _depositId uint256 id of the deposit to be increased.\n     * @param _receiver address owner of the lock\n     * @param _increaseAmount uint256 amount of tokens to add to the lock.\n     */\n    function increaseLock(uint256 _depositId, address _receiver, uint256 _increaseAmount) external {\n        // Check if actually increasing\n        if (_increaseAmount == 0) {\n            revert ZeroAmountError();\n        }\n\n        Deposit memory userDeposit = depositsOf[_msgSender()][_depositId];\n\n        // Only can extend if it has not expired\n        if (block.timestamp >= userDeposit.end) {\n            revert DepositExpiredError();\n        }\n\n        depositToken.safeTransferFrom(_msgSender(), address(this), _increaseAmount);\n\n        // Multiplier should be acording the remaining time to the deposit to end\n        uint256 remainingDuration = uint256(userDeposit.end - block.timestamp);\n\n        uint256 mintAmount = _increaseAmount * getMultiplier(remainingDuration) / 1e18;\n\n        depositsOf[_receiver][_depositId].amount += _increaseAmount;\n        depositsOf[_receiver][_depositId].shareAmount += mintAmount;\n\n        _mint(_receiver, mintAmount);\n        emit LockIncreased(_depositId, _receiver, _msgSender(), _increaseAmount);\n    }\n\n    /**\n     * @notice Gets the multiplier from the curve given a duration.\n     * @dev This function calculates a multiplier by fetching the points in the curve given a duration.\n     * It can achieve this by linearly interpolating between the points of the curve to get a much more\n     * precise result. The unit parameter is related to the maximum possible duration of the deposits \n     * and the amount of points in the curve.\n     * @param _lockDuration uint256 time that the deposit will be locked.\n     * @return uint256 number used to multiply and get amount of shares.\n     */\n    function getMultiplier(uint256 _lockDuration) public view returns(uint256) {\n        // There is no need to check _lockDuration amount, it is always checked before\n        // in the functions that call this function\n\n        // n is the time unit where the lockDuration stands\n        uint n = _lockDuration / unit;\n        // if last point no need to interpolate\n        // trim de curve if it exceedes the maxBonus // TODO check if this is needed\n        if (n == curve.length - 1) {\n            return 1e18 + curve[n];\n        }\n        // linear interpolation between points\n        return 1e18 + curve[n] + (_lockDuration - n * unit) * (curve[n + 1] - curve[n]) / unit;\n    }\n\n    function getTotalDeposit(address _account) public view returns(uint256) {\n        uint256 total;\n        for(uint256 i = 0; i < depositsOf[_account].length; i++) {\n            total += depositsOf[_account][i].amount;\n        }\n\n        return total;\n    }\n\n    function getDepositsOf(address _account) public view returns(Deposit[] memory) {\n        return depositsOf[_account];\n    }\n\n    function getDepositsOfLength(address _account) public view returns(uint256) {\n        return depositsOf[_account].length;\n    }\n\n    function maxBonusError(uint256 _point) internal returns(uint256) {\n        if (_point > maxBonus) {\n            revert MaxBonusError();\n        } else {\n            return _point;\n        }\n    }\n\n    /**\n     * @notice Can set an entire new curve.\n     * @dev This function can change current curve by a completely new. For doing so, it does not\n     * matter if the new curve's length is larger, equal, or shorter because the function manages\n     * all of those cases.\n     * @param _curve uint256 array of the points that compose the curve.\n     */\n    function setCurve(uint256[] calldata _curve) external onlyGov {\n        if (_curve.length < 2) {\n            revert ShortCurveError();\n        }\n        // same length curves\n        if (curve.length == _curve.length) {\n            for (uint i=0; i < curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n        // replacing with a shorter curve\n        } else if (curve.length > _curve.length) {\n            for (uint i=0; i < _curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n            uint initialLength = curve.length;\n            for (uint j=0; j < initialLength - _curve.length; j++) {\n                curve.pop();\n            }\n            unit = maxLockDuration / (curve.length - 1);\n        // replacing with a longer curve\n        } else {\n            for (uint i=0; i < curve.length; i++) {\n                curve[i] = maxBonusError(_curve[i]);\n            }\n            uint initialLength = curve.length;\n            for (uint j=0; j < _curve.length - initialLength; j++) {\n                curve.push(maxBonusError(_curve[initialLength + j]));\n            }\n            unit = maxLockDuration / (curve.length - 1);\n        }\n        emit CurveChanged(_msgSender());\n    }\n\n    /**\n     * @notice Can set a point of the curve.\n     * @dev This function can replace any point in the curve by inputing the existing index,\n     * add a point to the curve by using the index that equals the amount of points of the curve,\n     * and remove the last point of the curve if an index greated than the length is used. The first\n     * point of the curve index is zero.\n     * @param _newPoint uint256 point to be set.\n     * @param _position uint256 position of the array to be set (zero-based indexing convention).\n     */\n    function setCurvePoint(uint256 _newPoint, uint256 _position) external onlyGov {\n        if (_newPoint > maxBonus) {\n            revert MaxBonusError();\n        }\n        if (_position < curve.length) {\n            curve[_position] = _newPoint;\n        } else if (_position == curve.length) {\n            curve.push(_newPoint);\n        } else {\n            if (curve.length - 1 < 2) {\n                revert ShortCurveError();\n            }\n            curve.pop();\n        }\n        emit CurveChanged(_msgSender());\n    }\n}"
    },
    {
      "filename": "contracts/gauges/LiquidityGaugeV5.vy",
      "content": "# @version 0.3.1\n\"\"\"\n@title Liquidity Gauge v5\n@author Curve Finance\n@license MIT\n\"\"\"\nfrom vyper.interfaces import ERC20\n\nimplements: ERC20\n\n\ninterface CRV20:\n    def future_epoch_time_write() -> uint256: nonpayable\n    def rate() -> uint256: view\n\ninterface Controller:\n    def period() -> int128: view\n    def period_write() -> int128: nonpayable\n    def period_timestamp(p: int128) -> uint256: view\n    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\n    def voting_escrow() -> address: view\n    def checkpoint(): nonpayable\n    def checkpoint_gauge(addr: address): nonpayable\n\ninterface Minter:\n    def token() -> address: view\n    def controller() -> address: view\n    def minted(user: address, gauge: address) -> uint256: view\n\ninterface VotingEscrow:\n    def user_point_epoch(addr: address) -> uint256: view\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\n\ninterface VotingEscrowBoost:\n    def adjusted_balance_of(_account: address) -> uint256: view\n\ninterface ERC20Extended:\n    def symbol() -> String[26]: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes32: view\n\n\nevent Deposit:\n    provider: indexed(address)\n    value: uint256\n\nevent Withdraw:\n    provider: indexed(address)\n    value: uint256\n\nevent UpdateLiquidityLimit:\n    user: address\n    original_balance: uint256\n    original_supply: uint256\n    working_balance: uint256\n    working_supply: uint256\n\nevent CommitOwnership:\n    admin: address\n\nevent ApplyOwnership:\n    admin: address\n\nevent Transfer:\n    _from: indexed(address)\n    _to: indexed(address)\n    _value: uint256\n\nevent Approval:\n    _owner: indexed(address)\n    _spender: indexed(address)\n    _value: uint256\n\n\nstruct Reward:\n    token: address\n    distributor: address\n    period_finish: uint256\n    rate: uint256\n    last_update: uint256\n    integral: uint256\n\n\n# keccak256(\"isValidSignature(bytes32,bytes)\")[:4] << 224\nERC1271_MAGIC_VAL: constant(bytes32) = 0x1626ba7e00000000000000000000000000000000000000000000000000000000\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nPERMIT_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nVERSION: constant(String[8]) = \"v5.0.0\"\n\nMAX_REWARDS: constant(uint256) = 8\nTOKENLESS_PRODUCTION: constant(uint256) = 40\nWEEK: constant(uint256) = 604800\n\nMINTER: constant(address) = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0\nCRV: constant(address) = 0xD533a949740bb3306d119CC777fa900bA034cd52\nVOTING_ESCROW: constant(address) = 0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2\nGAUGE_CONTROLLER: constant(address) = 0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB\nVEBOOST_PROXY: constant(address) = 0x8E0c00ed546602fD9927DF742bbAbF726D5B0d16\n\n\nNAME: immutable(String[64])\nSYMBOL: immutable(String[32])\nDOMAIN_SEPARATOR: immutable(bytes32)\n\nLP_TOKEN: immutable(address)\n\n\nnonces: public(HashMap[address, uint256])\n\nfuture_epoch_time: public(uint256)\n\nbalanceOf: public(HashMap[address, uint256])\ntotalSupply: public(uint256)\nallowance: public(HashMap[address, HashMap[address, uint256]])\n\nworking_balances: public(HashMap[address, uint256])\nworking_supply: public(uint256)\n\n# For tracking external rewards\nreward_count: public(uint256)\nreward_tokens: public(address[MAX_REWARDS])\n\nreward_data: public(HashMap[address, Reward])\n\n# claimant -> default reward receiver\nrewards_receiver: public(HashMap[address, address])\n\n# reward token -> claiming address -> integral\nreward_integral_for: public(HashMap[address, HashMap[address, uint256]])\n\n# user -> [uint128 claimable amount][uint128 claimed amount]\nclaim_data: HashMap[address, HashMap[address, uint256]]\n\nadmin: public(address)\nfuture_admin: public(address)\nis_killed: public(bool)\n\n# 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\nintegrate_inv_supply_of: public(HashMap[address, uint256])\nintegrate_checkpoint_of: public(HashMap[address, uint256])\n\n# ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n# Units: rate * t = already number of coins per address to issue\nintegrate_fraction: public(HashMap[address, uint256])\n\ninflation_rate: public(uint256)\n\n# The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\n# All values are kept in units of being multiplied by 1e18\nperiod: public(int128)\nperiod_timestamp: public(uint256[100000000000000000000000000000])\n\n# 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\nintegrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\n\n\n@external\ndef __init__(_lp_token: address, _admin: address):\n    \"\"\"\n    @notice Contract constructor\n    @param _lp_token Liquidity Pool contract address\n    @param _admin Admin who can kill the gauge\n    \"\"\"\n\n    self.admin = _admin\n\n    self.period_timestamp[0] = block.timestamp\n    self.inflation_rate = CRV20(CRV).rate()\n    self.future_epoch_time = CRV20(CRV).future_epoch_time_write()\n\n    lp_symbol: String[26] = ERC20Extended(_lp_token).symbol()\n    name: String[64] = concat(\"Curve.fi \", lp_symbol, \" Gauge Deposit\")\n\n    NAME = name\n    SYMBOL = concat(lp_symbol, \"-gauge\")\n    DOMAIN_SEPARATOR = keccak256(\n        _abi_encode(EIP712_TYPEHASH, keccak256(name), keccak256(VERSION), chain.id, self)\n    )\n\n    LP_TOKEN = _lp_token\n\n\n@view\n@external\ndef integrate_checkpoint() -> uint256:\n    return self.period_timestamp[self.period]\n\n\n@internal\ndef _update_liquidity_limit(addr: address, l: uint256, L: uint256):\n    \"\"\"\n    @notice Calculate limits which depend on the amount of CRV token per-user.\n            Effectively it calculates working balances to apply amplification\n            of CRV production by CRV\n    @param addr User address\n    @param l User's amount of liquidity (LP tokens)\n    @param L Total amount of liquidity (LP tokens)\n    \"\"\"\n    # To be called after totalSupply is updated\n    voting_balance: uint256 = VotingEscrowBoost(VEBOOST_PROXY).adjusted_balance_of(addr)\n    voting_total: uint256 = ERC20(VOTING_ESCROW).totalSupply()\n\n    lim: uint256 = l * TOKENLESS_PRODUCTION / 100\n    if voting_total > 0:\n        lim += L * voting_balance / voting_total * (100 - TOKENLESS_PRODUCTION) / 100\n\n    lim = min(l, lim)\n    old_bal: uint256 = self.working_balances[addr]\n    self.working_balances[addr] = lim\n    _working_supply: uint256 = self.working_supply + lim - old_bal\n    self.working_supply = _working_supply\n\n    log UpdateLiquidityLimit(addr, l, L, lim, _working_supply)\n\n\n@internal\ndef _checkpoint_rewards(_user: address, _total_supply: uint256, _claim: bool, _receiver: address):\n    \"\"\"\n    @notice Claim pending rewards and checkpoint rewards for a user\n    \"\"\"\n\n    user_balance: uint256 = 0\n    receiver: address = _receiver\n    if _user != ZERO_ADDRESS:\n        user_balance = self.balanceOf[_user]\n        if _claim and _receiver == ZERO_ADDRESS:\n            # if receiver is not explicitly declared, check if a default receiver is set\n            receiver = self.rewards_receiver[_user]\n            if receiver == ZERO_ADDRESS:\n                # if no default receiver is set, direct claims to the user\n                receiver = _user\n\n    reward_count: uint256 = self.reward_count\n    for i in range(MAX_REWARDS):\n        if i == reward_count:\n            break\n        token: address = self.reward_tokens[i]\n\n        integral: uint256 = self.reward_data[token].integral\n        last_update: uint256 = min(block.timestamp, self.reward_data[token].period_finish)\n        duration: uint256 = last_update - self.reward_data[token].last_update\n        if duration != 0:\n            self.reward_data[token].last_update = last_update\n            if _total_supply != 0:\n                integral += duration * self.reward_data[token].rate * 10**18 / _total_supply\n                self.reward_data[token].integral = integral\n\n        if _user != ZERO_ADDRESS:\n            integral_for: uint256 = self.reward_integral_for[token][_user]\n            new_claimable: uint256 = 0\n\n            if integral_for < integral:\n                self.reward_integral_for[token][_user] = integral\n                new_claimable = user_balance * (integral - integral_for) / 10**18\n\n            claim_data: uint256 = self.claim_data[_user][token]\n            total_claimable: uint256 = shift(claim_data, -128) + new_claimable\n            if total_claimable > 0:\n                total_claimed: uint256 = claim_data % 2**128\n                if _claim:\n                    response: Bytes[32] = raw_call(\n                        token,\n                        concat(\n                            method_id(\"transfer(address,uint256)\"),\n                            convert(receiver, bytes32),\n                            convert(total_claimable, bytes32),\n                        ),\n                        max_outsize=32,\n                    )\n                    if len(response) != 0:\n                        assert convert(response, bool)\n                    self.claim_data[_user][token] = total_claimed + total_claimable\n                elif new_claimable > 0:\n                    self.claim_data[_user][token] = total_claimed + shift(total_claimable, 128)\n\n\n@internal\ndef _checkpoint(addr: address):\n    \"\"\"\n    @notice Checkpoint for a user\n    @param addr User address\n    \"\"\"\n    _period: int128 = self.period\n    _period_time: uint256 = self.period_timestamp[_period]\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\n    rate: uint256 = self.inflation_rate\n    new_rate: uint256 = rate\n    prev_future_epoch: uint256 = self.future_epoch_time\n    if prev_future_epoch >= _period_time:\n        self.future_epoch_time = CRV20(CRV).future_epoch_time_write()\n        new_rate = CRV20(CRV).rate()\n        self.inflation_rate = new_rate\n\n    if self.is_killed:\n        # Stop distributing inflation as soon as killed\n        rate = 0\n\n    # Update integral of 1/supply\n    if block.timestamp > _period_time:\n        _working_supply: uint256 = self.working_supply\n        Controller(GAUGE_CONTROLLER).checkpoint_gauge(self)\n        prev_week_time: uint256 = _period_time\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\n\n        for i in range(500):\n            dt: uint256 = week_time - prev_week_time\n            w: uint256 = Controller(GAUGE_CONTROLLER).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\n\n            if _working_supply > 0:\n                if prev_future_epoch >= prev_week_time and prev_future_epoch < week_time:\n                    # If we went across one or multiple epochs, apply the rate\n                    # of the first epoch until it ends, and then the rate of\n                    # the last epoch.\n                    # If more than one epoch is crossed - the gauge gets less,\n                    # but that'd meen it wasn't called for more than 1 year\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\n                    rate = new_rate\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\n                else:\n                    _integrate_inv_supply += rate * w * dt / _working_supply\n                # On precisions of the calculation\n                # rate ~= 10e18\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n                # The largest loss is at dt = 1\n                # Loss is 1e-9 - acceptable\n\n            if week_time == block.timestamp:\n                break\n            prev_week_time = week_time\n            week_time = min(week_time + WEEK, block.timestamp)\n\n    _period += 1\n    self.period = _period\n    self.period_timestamp[_period] = block.timestamp\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\n\n    # Update user-specific integrals\n    _working_balance: uint256 = self.working_balances[addr]\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\n    self.integrate_checkpoint_of[addr] = block.timestamp\n\n\n@external\ndef user_checkpoint(addr: address) -> bool:\n    \"\"\"\n    @notice Record a checkpoint for `addr`\n    @param addr User address\n    @return bool success\n    \"\"\"\n    assert msg.sender in [addr, MINTER]  # dev: unauthorized\n    self._checkpoint(addr)\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n    return True\n\n\n@external\ndef claimable_tokens(addr: address) -> uint256:\n    \"\"\"\n    @notice Get the number of claimable tokens per user\n    @dev This function should be manually changed to \"view\" in the ABI\n    @return uint256 number of claimable tokens per user\n    \"\"\"\n    self._checkpoint(addr)\n    return self.integrate_fraction[addr] - Minter(MINTER).minted(addr, self)\n\n\n@view\n@external\ndef claimed_reward(_addr: address, _token: address) -> uint256:\n    \"\"\"\n    @notice Get the number of already-claimed reward tokens for a user\n    @param _addr Account to get reward amount for\n    @param _token Token to get reward amount for\n    @return uint256 Total amount of `_token` already claimed by `_addr`\n    \"\"\"\n    return self.claim_data[_addr][_token] % 2**128\n\n\n@view\n@external\ndef claimable_reward(_user: address, _reward_token: address) -> uint256:\n    \"\"\"\n    @notice Get the number of claimable reward tokens for a user\n    @param _user Account to get reward amount for\n    @param _reward_token Token to get reward amount for\n    @return uint256 Claimable reward token amount\n    \"\"\"\n    integral: uint256 = self.reward_data[_reward_token].integral\n    total_supply: uint256 = self.totalSupply\n    if total_supply != 0:\n        last_update: uint256 = min(block.timestamp, self.reward_data[_reward_token].period_finish)\n        duration: uint256 = last_update - self.reward_data[_reward_token].last_update\n        integral += (duration * self.reward_data[_reward_token].rate * 10**18 / total_supply)\n\n    integral_for: uint256 = self.reward_integral_for[_reward_token][_user]\n    new_claimable: uint256 = self.balanceOf[_user] * (integral - integral_for) / 10**18\n\n    return shift(self.claim_data[_user][_reward_token], -128) + new_claimable\n\n\n@external\ndef set_rewards_receiver(_receiver: address):\n    \"\"\"\n    @notice Set the default reward receiver for the caller.\n    @dev When set to ZERO_ADDRESS, rewards are sent to the caller\n    @param _receiver Receiver address for any rewards claimed via `claim_rewards`\n    \"\"\"\n    self.rewards_receiver[msg.sender] = _receiver\n\n\n@external\n@nonreentrant('lock')\ndef claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):\n    \"\"\"\n    @notice Claim available reward tokens for `_addr`\n    @param _addr Address to claim for\n    @param _receiver Address to transfer rewards to - if set to\n                     ZERO_ADDRESS, uses the default reward receiver\n                     for the caller\n    \"\"\"\n    if _receiver != ZERO_ADDRESS:\n        assert _addr == msg.sender  # dev: cannot redirect when claiming for another user\n    self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver)\n\n\n@external\ndef kick(addr: address):\n    \"\"\"\n    @notice Kick `addr` for abusing their boost\n    @dev Only if either they had another voting event, or their voting escrow lock expired\n    @param addr Address to kick\n    \"\"\"\n    t_last: uint256 = self.integrate_checkpoint_of[addr]\n    t_ve: uint256 = VotingEscrow(VOTING_ESCROW).user_point_history__ts(\n        addr, VotingEscrow(VOTING_ESCROW).user_point_epoch(addr)\n    )\n    _balance: uint256 = self.balanceOf[addr]\n\n    assert ERC20(VOTING_ESCROW).balanceOf(addr) == 0 or t_ve > t_last # dev: kick not allowed\n    assert self.working_balances[addr] > _balance * TOKENLESS_PRODUCTION / 100  # dev: kick not needed\n\n    self._checkpoint(addr)\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n\n\n@external\n@nonreentrant('lock')\ndef deposit(_value: uint256, _addr: address = msg.sender, _claim_rewards: bool = False):\n    \"\"\"\n    @notice Deposit `_value` LP tokens\n    @dev Depositting also claims pending reward tokens\n    @param _value Number of tokens to deposit\n    @param _addr Address to deposit for\n    \"\"\"\n\n    self._checkpoint(_addr)\n\n    if _value != 0:\n        is_rewards: bool = self.reward_count != 0\n        total_supply: uint256 = self.totalSupply\n        if is_rewards:\n            self._checkpoint_rewards(_addr, total_supply, _claim_rewards, ZERO_ADDRESS)\n\n        total_supply += _value\n        new_balance: uint256 = self.balanceOf[_addr] + _value\n        self.balanceOf[_addr] = new_balance\n        self.totalSupply = total_supply\n\n        self._update_liquidity_limit(_addr, new_balance, total_supply)\n\n        ERC20(LP_TOKEN).transferFrom(msg.sender, self, _value)\n\n    log Deposit(_addr, _value)\n    log Transfer(ZERO_ADDRESS, _addr, _value)\n\n\n@external\n@nonreentrant('lock')\ndef withdraw(_value: uint256, _claim_rewards: bool = False):\n    \"\"\"\n    @notice Withdraw `_value` LP tokens\n    @dev Withdrawing also claims pending reward tokens\n    @param _value Number of tokens to withdraw\n    \"\"\"\n    self._checkpoint(msg.sender)\n\n    if _value != 0:\n        is_rewards: bool = self.reward_count != 0\n        total_supply: uint256 = self.totalSupply\n        if is_rewards:\n            self._checkpoint_rewards(msg.sender, total_supply, _claim_rewards, ZERO_ADDRESS)\n\n        total_supply -= _value\n        new_balance: uint256 = self.balanceOf[msg.sender] - _value\n        self.balanceOf[msg.sender] = new_balance\n        self.totalSupply = total_supply\n\n        self._update_liquidity_limit(msg.sender, new_balance, total_supply)\n\n        ERC20(LP_TOKEN).transfer(msg.sender, _value)\n\n    log Withdraw(msg.sender, _value)\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\n\n\n@internal\ndef _transfer(_from: address, _to: address, _value: uint256):\n    self._checkpoint(_from)\n    self._checkpoint(_to)\n\n    if _value != 0:\n        total_supply: uint256 = self.totalSupply\n        is_rewards: bool = self.reward_count != 0\n        if is_rewards:\n            self._checkpoint_rewards(_from, total_supply, False, ZERO_ADDRESS)\n        new_balance: uint256 = self.balanceOf"
    }
  ]
}