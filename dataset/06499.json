{
  "Title": "[G-09] Expressions for constant values, such as a call toÂ `keccak256()`, should use immutable rather than constant",
  "Content": "\nThe reason for this, is that constant variables are evaluated at runtime and their value is included in the bytecode of the contract. This means, any expensive operations performed as part of the constant expression, such as a call to `keccak256()`, will be executed every time the contract is deployed, even if the result is always the same. This can result in higher gas costs.\n\nIn contrast, immutable variables are evaluated at compilation time and their values are included in the bytecode of the contract as constants. This means, any expensive operations performed as part of the immutable expression are only executed once when the contract is compiled and the result is reused every time the contract is deployed. This can result in lower gas costs compared to using constant variables.\n\nLet's consider an example to illustrate this. Suppose we want to store the hash of a string as a constant value in our contract. We could do this using a constant variable, like so:\n\n```\nbytes32 constant MY_HASH = keccak256(\"my string\");\n```\n\nAlternatively, we could use an immutable variable, like so:\n\n```\nbytes32 immutable MY_HASH = keccak256(\"my string\");\n```\n\n```solidity\nFile:   src/erc-20/ERC20MultiVotes.sol\n360   bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20MultiVotes.sol#L360\n\n```solidity\nFile:   src/governance/GovernorBravoDelegateMaia.sol\n42    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\n46    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/governance/GovernorBravoDelegateMaia.sol#L42\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20MultiVotes.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Voting logic inspired by OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20MultiVotes} from \"./interfaces/IERC20MultiVotes.sol\";\n\n/// @title ERC20 Multi-Delegation Voting contract\nabstract contract ERC20MultiVotes is ERC20, Ownable, IERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTE CALCULATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice votes checkpoint list per user.\n    mapping(address => Checkpoint[]) private _checkpoints;\n\n    /// @inheritdoc IERC20MultiVotes\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _checkpoints[account].length.toUint32();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function freeVotes(address account) public view virtual returns (uint256) {\n        return balanceOf[account] - userDelegatedVotes[account];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function getVotes(address account) public view virtual returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function userUnusedVotes(address user) public view virtual returns (uint256) {\n        return getVotes(user);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function getPriorVotes(address account, uint256 blockNumber) public view virtual returns (uint256) {\n        if (blockNumber >= block.number) revert BlockError();\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /// @dev Lookup a value in a list of (sorted) checkpoints.\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20MultiVotes\n    uint256 public override maxDelegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    mapping(address => bool) public override canContractExceedMaxDelegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    function setMaxDelegates(uint256 newMax) external onlyOwner {\n        uint256 oldMax = maxDelegates;\n        maxDelegates = newMax;\n\n        emit MaxDelegatesUpdate(oldMax, newMax);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function setContractExceedMaxDelegates(address account, bool canExceedMax) external onlyOwner {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxDelegates[account] = canExceedMax;\n\n        emit CanContractExceedMaxDelegatesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice How many votes a user has delegated to a delegatee.\n    mapping(address => mapping(address => uint256)) private _delegatesVotesCount;\n\n    /// @notice How many votes a user has delegated to him.\n    mapping(address => uint256) public userDelegatedVotes;\n\n    /// @notice The delegatees of a user.\n    mapping(address => EnumerableSet.AddressSet) private _delegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegatesVotesCount(address delegator, address delegatee) public view virtual returns (uint256) {\n        return _delegatesVotesCount[delegator][delegatee];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegates(address delegator) public view returns (address[] memory) {\n        return _delegates[delegator].values();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegateCount(address delegator) public view returns (uint256) {\n        return _delegates[delegator].length();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function incrementDelegation(address delegatee, uint256 amount) public virtual {\n        _incrementDelegation(msg.sender, delegatee, amount);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function undelegate(address delegatee, uint256 amount) public virtual {\n        _undelegate(msg.sender, delegatee, amount);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegate(address newDelegatee) external virtual {\n        _delegate(msg.sender, newDelegatee);\n    }\n\n    /**\n     * @notice Delegates all votes from `delegator` to `delegatee`\n     * @dev Reverts if delegateCount > 1\n     * @param delegator The address to delegate votes from\n     * @param newDelegatee The address to delegate votes to\n     */\n    function _delegate(address delegator, address newDelegatee) internal virtual {\n        uint256 count = delegateCount(delegator);\n\n        // undefined behavior for delegateCount > 1\n        if (count > 1) revert DelegationError();\n\n        address oldDelegatee;\n        // if already delegated, undelegate first\n        if (count == 1) {\n            oldDelegatee = _delegates[delegator].at(0);\n            _undelegate(delegator, oldDelegatee, _delegatesVotesCount[delegator][oldDelegatee]);\n        }\n\n        // redelegate only if newDelegatee is not empty\n        if (newDelegatee != address(0)) {\n            _incrementDelegation(delegator, newDelegatee, freeVotes(delegator));\n        }\n        emit DelegateChanged(delegator, oldDelegatee, newDelegatee);\n    }\n\n    /**\n     * @notice Delegates votes from `delegator` to `delegatee`\n     * @dev Reverts if delegator is not approved and exceeds maxDelegates\n     * @param delegator The address to delegate votes from\n     * @param delegatee The address to delegate votes to\n     * @param amount The amount of votes to delegate\n     */\n    function _incrementDelegation(address delegator, address delegatee, uint256 amount) internal virtual {\n        // Require freeVotes exceed the delegation size\n        uint256 free = freeVotes(delegator);\n        if (delegatee == address(0) || free < amount || amount == 0) revert DelegationError();\n\n        bool newDelegate = _delegates[delegator].add(delegatee); // idempotent add\n        if (newDelegate && delegateCount(delegator) > maxDelegates && !canContractExceedMaxDelegates[delegator]) {\n            // if is a new delegate, exceeds max and is not approved to exceed, revert\n            revert DelegationError();\n        }\n\n        _delegatesVotesCount[delegator][delegatee] += amount;\n        userDelegatedVotes[delegator] += amount;\n\n        emit Delegation(delegator, delegatee, amount);\n        _writeCheckpoint(delegatee, _add, amount);\n    }\n\n    /**\n     * @notice Undelegates votes from `delegator` to `delegatee`\n     * @dev Reverts if delegatee does not have enough free votes\n     * @param delegator The address to undelegate votes from\n     * @param delegatee The address to undelegate votes to\n     * @param amount The amount of votes to undelegate\n     */\n    function _undelegate(address delegator, address delegatee, uint256 amount) internal virtual {\n        /**\n         * @dev delegatee needs to have sufficient free votes for delegator to undelegate.\n         *         Delegatee needs to be trusted, can be either a contract or an EOA.\n         *         If delegatee does not have any free votes and doesn't change their vote delegator won't be able to undelegate.\n         *         If it is a contract, a possible safety measure is to have an emergency clear votes.\n         */\n        if (userUnusedVotes(delegatee) < amount) revert UndelegationVoteError();\n\n        uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;\n\n        if (newDelegates == 0) {\n            require(_delegates[delegator].remove(delegatee));\n        }\n\n        _delegatesVotesCount[delegator][delegatee] = newDelegates;\n        userDelegatedVotes[delegator] -= amount;\n\n        emit Undelegation(delegator, delegatee, amount);\n        _writeCheckpoint(delegatee, _subtract, amount);\n    }\n\n    /**\n     * @notice Writes a checkpoint for `delegatee` with `delta` votes\n     * @param delegatee The address to write a checkpoint for\n     * @param op The operation to perform on the checkpoint\n     * @param delta The difference in votes to write\n     */\n    function _writeCheckpoint(address delegatee, function(uint256, uint256) view returns (uint256) op, uint256 delta)\n        private\n    {\n        Checkpoint[] storage ckpts = _checkpoints[delegatee];\n\n        uint256 pos = ckpts.length;\n        uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        uint256 newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = newWeight.toUint224();\n        } else {\n            ckpts.push(Checkpoint({fromBlock: block.number.toUint32(), votes: newWeight.toUint224()}));\n        }\n        emit DelegateVotesChanged(delegatee, oldWeight, newWeight);\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires freeVotes(user) < amount.\n    /// _decrementVotesUntilFree is called as a greedy algorithm to free up votes.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev Frees votes with a greedy algorithm if needed to burn tokens\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementVotesUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev Frees votes with a greedy algorithm if needed to burn tokens\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementVotesUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev Frees votes with a greedy algorithm if needed to burn tokens\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _decrementVotesUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice A greedy algorithm for freeing votes before a token burn/transfer\n     * @dev Frees up entire delegates, so likely will free more than `votes`\n     * @param user The address to free votes from.\n     * @param votes The amount of votes to free.\n     */\n    function _decrementVotesUntilFree(address user, uint256 votes) internal {\n        uint256 userFreeVotes = freeVotes(user);\n\n        // early return if already free\n        if (userFreeVotes >= votes) return;\n\n        // cache total for batch updates\n        uint256 totalFreed;\n\n        // Loop through all delegates\n        address[] memory delegateList = _delegates[user].values();\n\n        // Free gauges through the entire list or until underweight\n        uint256 size = delegateList.length;\n        for (uint256 i = 0; i < size && (userFreeVotes + totalFreed) < votes; i++) {\n            address delegatee = delegateList[i];\n            uint256 delegateVotes = _delegatesVotesCount[user][delegatee];\n            // Minimum of votes delegated to delegatee and unused votes of delegatee\n            uint256 votesToFree = FixedPointMathLib.min(delegateVotes, userUnusedVotes(delegatee));\n            // Skip if votesToFree is zero\n            if (votesToFree != 0) {\n                totalFreed += votesToFree;\n\n                if (delegateVotes == votesToFree) {\n                    // If all votes are freed, remove delegatee from list\n                    require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.\n                    _delegatesVotesCount[user][delegatee] = 0;\n                } else {\n                    // If not all votes are freed, update the votes count\n                    _delegatesVotesCount[user][delegatee] -= votesToFree;\n                }\n\n                _writeCheckpoint(delegatee, _subtract, votesToFree);\n                emit Undelegation(user, delegatee, votesToFree);\n            }\n        }\n\n        if ((userFreeVotes + totalFreed) < votes) revert UndelegationVoteError();\n\n        userDelegatedVotes[user] -= totalFreed;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-712 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) public {\n        require(block.timestamp <= expiry, \"ERC20MultiVotes: signature expired\");\n        address signer = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))\n                )\n            ),\n            v,\n            r,\n            s\n        );\n        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n        require(signer != address(0));\n        _delegate(signer, delegatee);\n    }\n}"
    },
    {
      "filename": "src/governance/GovernorBravoDelegateMaia.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./GovernorBravoInterfaces.sol\";\n\n/// @title Governor Bravo Constants Contract\ncontract GovernorBravoConstants {\n    /// @notice The name of this contract\n    string public constant name = \"vMaia Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD = 0.005 ether; // 0.5% of GovToken\n\n    /// @notice The maximum setable proposal threshold\n    uint256 public constant MAX_PROPOSAL_THRESHOLD = 0.05 ether; // 5% of GovToken\n\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 80640; // About 2 weeks\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 161280; // About 4 weeks\n\n    /// @notice The min setable voting delay\n    uint256 public constant MIN_VOTING_DELAY = 40320; // About 1 weeks\n\n    /// @notice The max setable voting delay\n    uint256 public constant MAX_VOTING_DELAY = 80640; // About 2 weeks\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    uint256 public constant quorumVotes = 0.35 ether; // 35% of GovToken\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n    /// @notice The divisor value used in percentage calculations\n    uint256 public constant DIVISIONER = 1 ether;\n}\n\n/// @title Governor Bravo Delegate Contract\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV2, GovernorBravoEvents, GovernorBravoConstants {\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    /**\n     * @notice Used to initialize the contract during delegator constructor\n     * @param timelock_ The address of the Timelock\n     * @param govToken_ The address of the GOV token\n     * @param votingPeriod_ The initial voting period\n     * @param votingDelay_ The initial voting delay\n     * @param proposalThreshold_ The initial proposal threshold\n     */\n    function initialize(\n        address timelock_,\n        address govToken_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThreshold_\n    ) public virtual {\n        require(address(timelock) == address(0), \"GovernorBravo::initialize: can only initialize once\");\n        require(msg.sender == admin, \"GovernorBravo::initialize: admin only\");\n        require(timelock_ != address(0), \"GovernorBravo::initialize: invalid timelock address\");\n        require(govToken_ != address(0), \"GovernorBravo::initialize: invalid govToken address\");\n        require(\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n            \"GovernorBravo::initialize: invalid voting period\"\n        );\n        require(\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n            \"GovernorBravo::initialize: invalid voting delay\"\n        );\n        require(\n            proposalThreshold_ >= MIN_PROPOSAL_THRESHOLD && proposalThreshold_ <= MAX_PROPOSAL_THRESHOLD,\n            \"GovernorBravo::initialize: invalid proposal threshold\"\n        );\n\n        timelock = TimelockInterface(timelock_);\n        govToken = GovTokenInterface(govToken_);\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThreshold = proposalThreshold_;\n    }\n\n    function getProposalThresholdAmount() public view returns (uint256) {\n        return govToken.totalSupply() * proposalThreshold / DIVISIONER;\n    }\n\n    function getQuorumVotesAmount() public view returns (uint256) {\n        return govToken.totalSupply() * quorumVotes / DIVISIONER;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param targets Target addresses for proposal calls\n     * @param values Eth values for proposal calls\n     * @param signatures Function signatures for proposal calls\n     * @param calldatas Calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Reject proposals before initiating as Governor\n        require(initialProposalId != 0, \"GovernorBravo::propose: Governor Bravo not active\");\n        // Allow addresses above proposal threshold and whitelisted addresses to propose\n        require(\n            govToken.getPriorVotes(msg.sender, sub256(block.number, 1)) > getProposalThresholdAmount()\n                || isWhitelisted(msg.sender),\n            \"GovernorBravo::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n            \"GovernorBravo::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorBravo::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations, \"GovernorBravo::propose: too many actions\");\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay);\n        uint256 endBlock = add256(startBlock, votingPeriod);\n\n        proposalCount++;\n        uint256 newProposalID = proposalCount;\n        Proposal storage newProposal = proposals[newProposalID];\n        // This should never happen but add a check in case.\n        require(newProposal.id == 0, \"GovernorBravo::propose: ProposalID collsion\");\n        newProposal.id = newProposalID;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description\n        );\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(uint256 proposalId) external {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"GovernorBravo::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = add256(block.timestamp, timelock.delay());\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            \"GovernorBravo::queueOrRevertInternal: identical proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(uint256 proposalId) external payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"GovernorBravo::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, \"GovernorBravo::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        // Proposer can cancel\n        // admin is Emergency DAO and can cancel any proposal\n        if (msg.sender != proposal.proposer && msg.sender != admin) {\n            // Whitelisted proposers can't be canceled for falling below proposal threshold\n            if (isWhitelisted(proposal.proposer)) {\n                require(\n                    (govToken.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < getProposalThresholdAmount())\n                        && msg.sender == whitelistGuardian,\n                    \"GovernorBravo::cancel: whitelisted proposer\"\n                );\n            } else {\n                require(\n                    (govToken.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < getProposalThresholdAmount()),\n                    \"GovernorBravo::cancel: proposer above threshold\"\n                );\n            }\n        }\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets of the proposal actions\n     * @return values of the proposal actions\n     * @return signatures of the proposal actions\n     * @return calldatas of the proposal actions\n     */\n    function getActions(uint256 proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > initialProposalId, \"GovernorBravo::state: invalid proposal id\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < getQuorumVotesAmount()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Cast a vote for a proposal\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     */\n    function castVote(uint256 proposalId, uint8 support) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), \"\");\n    }\n\n    /**\n     * @notice Cast a vote for a proposal with a reason\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @param reason The reason given for the vote by the voter\n     */\n    function castVoteWithReason(uint256 proposalId, uint8 support, string calldata reason) external {\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n    }\n\n    /**\n     * @notice Cast a vote for a proposal by signature\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n     */\n    function castVoteBySig(uint256 proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external {\n        bytes32 domainSeparator =\n            keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorBravo::castVoteBySig: invalid signature\");\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), \"\");\n    }\n\n    /**\n     * @notice Internal function that caries out voting logic\n     * @param voter The voter that is casting their vote\n     * @param proposalId The id of the proposal to vote on\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n     * @return The number of votes cast\n     */\n    function castVoteInternal(address voter, uint256 proposalId, uint8 support) internal returns (uint96) {\n        require(state(proposalId) == ProposalState.Active, \"GovernorBravo::castVoteInternal: voting is closed\");\n        require(support <= 2, \"GovernorBravo::castVoteInternal: invalid vote type\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorBravo::castVoteInternal: voter already voted\");\n        uint96 votes = govToken.getPriorVotes(voter, proposal.startBlock);\n\n        if (support == 0) {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        } else if (support == 1) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else if (support == 2) {\n            proposal.abstainVotes = add256(proposal.abstainVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    }\n\n    /**\n     * @notice View function which returns if an account is whitelisted\n     * @param account Account to check white list status of\n     * @return If the account is whitelisted\n     */\n    function isWhitelisted(address account) public view returns (bool) {\n        return (whitelistAccountExpirations[account] > block.timestamp);\n    }\n\n    /**\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint256 newVotingDelay) external {\n        require(msg.sender == admin, \"GovernorBravo::_setVotingDelay: admin only\");\n        require(\n            newVotingDelay >= MIN_VO"
    }
  ]
}