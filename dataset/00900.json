{
  "Title": "M-7: ETH can be sold during reinvestment",
  "Content": "# Issue M-7: ETH can be sold during reinvestment \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/74 \n\n## Found by \nlemonmon, xiaoming90\n## Summary\n\nThe existing control to prevent ETH from being sold during reinvestment can be bypassed, allowing the bots to accidentally or maliciously sell off the non-reward assets of the vault.\n\n## Vulnerability Detail\n\nMultiple instances of this issue were found:\n\n**Instance 1 - Curve's Implementation**\n\nThe `_isInvalidRewardToken` function attempts to prevent the callers from selling away ETH during reinvestment.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/curve/ConvexStakingMixin.sol#L60\n\n```solidity\nFile: ConvexStakingMixin.sol\n60:     function _isInvalidRewardToken(address token) internal override view returns (bool) {\n61:         return (\n62:             token == TOKEN_1 ||\n63:             token == TOKEN_2 ||\n64:             token == address(CURVE_POOL_TOKEN) ||\n65:             token == address(CONVEX_REWARD_POOL) ||\n66:             token == address(CONVEX_BOOSTER) ||\n67:             token == Deployments.ALT_ETH_ADDRESS\n68:         );\n69:     }\n```\n\nHowever, the code at Line 67 above will not achieve the intended outcome as `Deployments.ALT_ETH_ADDRESS` is not a valid token address in the first place.\n\n```solidity\naddress internal constant ALT_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n```\n\nWhen the caller is executing a trade with ETH, the address for ETH used is either `Deployments.WETH` or `Deployments.ETH_ADDRESS` (`address(0)`) as shown in the TradingUtils's source code, not the `Deployments.ALT_ETH_ADDRESS`. \n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/trading/TradingUtils.sol#L128\n\n```solidity\nFile: TradingUtils.sol\n128:     function _executeTrade(\n129:         address target,\n130:         uint256 msgValue,\n131:         bytes memory params,\n132:         address spender,\n133:         Trade memory trade\n134:     ) private {\n135:         uint256 preTradeBalance;\n136:  \n137:         if (trade.buyToken == address(Deployments.WETH)) {\n138:             preTradeBalance = address(this).balance;\n139:         } else if (trade.buyToken == Deployments.ETH_ADDRESS || _needsToUnwrapExcessWETH(trade, spender)) {\n140:             preTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n141:         }\n```\n\nAs a result, the caller (bot) of the reinvestment function could still sell off the ETH from the vault, bypassing the requirement.\n\n**Instance 2 - Balancer's Implementation**\n\nWhen the caller is executing a trade with ETH, the address for ETH used is either `Deployments.WETH` or `Deployments.ETH_ADDRESS` (`address(0)`), as mentioned earlier. However, the `AuraStakingMixin._isInvalidRewardToken` function only blocks `Deployments.WETH` but not `Deployments.ETH`, thus allowing the caller (bot) of the reinvestment function, could still sell off the ETH from the vault, bypassing the requirement.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol#L38\n\n```solidity\nFile: AuraStakingMixin.sol\n38:     function _isInvalidRewardToken(address token) internal override view returns (bool) {\n39:         return (\n40:             token == TOKEN_1 ||\n41:             token == TOKEN_2 ||\n42:             token == TOKEN_3 ||\n43:             token == TOKEN_4 ||\n44:             token == TOKEN_5 ||\n45:             token == address(AURA_BOOSTER) ||\n46:             token == address(AURA_REWARD_POOL) ||\n47:             token == address(Deployments.WETH)\n48:         );\n49:     }\n```\n\nPer the sponsor's clarification below, the contracts should protect against the bot doing unintended things (including acting maliciously) due to coding errors, which is one of the main reasons for having the `_isInvalidRewardToken` function. Thus, this issue is a valid bug in the context of this audit contest.\n\nhttps://discord.com/channels/812037309376495636/1175450365395751023/1175781082336067655\n\n![](https://user-images.githubusercontent.com/102820284/285566722-10739ec2-fc8f-43f5-b681-459494d1b6dc.png)\n\n## Impact\n\nThe existing control to prevent ETH from being sold during reinvestment can be bypassed, allowing the bots to accidentally or maliciously sell off the non-reward assets of the vault.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/curve/ConvexStakingMixin.sol#L60\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol#L38\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo ensure that ETH cannot be sold off during reinvestment, consider the following changes:\n\n**Curve**\n\n```diff\nFile: ConvexStakingMixin.sol\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == address(CURVE_POOL_TOKEN) ||\n        token == address(CONVEX_REWARD_POOL) ||\n        token == address(CONVEX_BOOSTER) ||\n+       token == Deployments.ETH ||\n+       token == Deployments.WETH ||\n        token == Deployments.ALT_ETH_ADDRESS\n    );\n}\n```\n\n**Balancer**\n\n```diff\nFile: AuraStakingMixin.sol\nfunction _isInvalidRewardToken(address token) internal override view returns (bool) {\n    return (\n        token == TOKEN_1 ||\n        token == TOKEN_2 ||\n        token == TOKEN_3 ||\n        token == TOKEN_4 ||\n        token == TOKEN_5 ||\n        token == address(AURA_BOOSTER) ||\n        token == address(AURA_REWARD_POOL) ||\n+\t\ttoken == address(Deployments.ETH)        \n        token == address(Deployments.WETH)\n    );\n}\n```\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid report.\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/67\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/ConvexStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {TokenUtils, IERC20} from \"../../utils/TokenUtils.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {IConvexBooster} from \"../../../interfaces/convex/IConvexBooster.sol\";\nimport {IConvexRewardToken} from \"../../../interfaces/convex/IConvexRewardToken.sol\";\nimport {IConvexRewardPool, IConvexRewardPoolArbitrum} from \"../../../interfaces/convex/IConvexRewardPool.sol\";\nimport {Curve2TokenPoolMixin, DeploymentParams} from \"./Curve2TokenPoolMixin.sol\";\n\nstruct ConvexVaultDeploymentParams {\n    address rewardPool;\n    DeploymentParams baseParams;\n}\n\nabstract contract ConvexStakingMixin is Curve2TokenPoolMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Convex booster contract used for staking BPT\n    address internal immutable CONVEX_BOOSTER;\n    /// @notice Convex reward pool contract used for unstaking and claiming reward tokens\n    address internal immutable CONVEX_REWARD_POOL;\n    uint256 internal immutable CONVEX_POOL_ID;\n\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        Curve2TokenPoolMixin(notional_, params.baseParams) {\n        CONVEX_REWARD_POOL = params.rewardPool;\n\n        address convexBooster;\n        uint256 poolId;\n\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            IConvexRewardPool rewardPool = IConvexRewardPool(CONVEX_REWARD_POOL);\n\n            convexBooster = rewardPool.operator();\n            poolId = rewardPool.pid();\n\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            IConvexRewardPoolArbitrum rewardPool = IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL);\n\n            convexBooster = rewardPool.convexBooster();\n            poolId = rewardPool.convexPoolId();\n        } else {\n            revert(\"Unsupported chain\");\n        }\n\n        CONVEX_POOL_ID = poolId;\n        CONVEX_BOOSTER = convexBooster;\n    }\n\n    function _initialApproveTokens() internal override {\n        // If either token is Deployments.ETH_ADDRESS the check approve will short circuit\n        IERC20(TOKEN_1).checkApprove(address(CURVE_POOL), type(uint256).max);\n        IERC20(TOKEN_2).checkApprove(address(CURVE_POOL), type(uint256).max);\n        CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n    }\n\n    function _isInvalidRewardToken(address token) internal override view returns (bool) {\n        return (\n            token == TOKEN_1 ||\n            token == TOKEN_2 ||\n            token == address(CURVE_POOL_TOKEN) ||\n            token == address(CONVEX_REWARD_POOL) ||\n            token == address(CONVEX_BOOSTER) ||\n            token == Deployments.ALT_ETH_ADDRESS\n        );\n    }\n\n    function _claimRewardTokens() internal override {\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            require(IConvexRewardPool(CONVEX_REWARD_POOL).getReward(address(this), true));\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL).getReward(address(this));\n        } else {\n            revert();\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/TradingUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {TokenUtils, IERC20} from \"../utils/TokenUtils.sol\";\nimport \"../../interfaces/trading/ITradingModule.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\n\n/// @notice Utility library used by the trading module\nlibrary TradingUtils {\n    using TokenUtils for IERC20;\n\n    error ERC20Error();\n    error TradeExecution(bytes returnData);\n    error PreValidationExactIn(uint256 maxAmountIn, uint256 preTradeSellBalance);\n    error PreValidationExactOut(uint256 maxAmountIn, uint256 preTradeSellBalance);\n    error PostValidationExactIn(uint256 minAmountOut, uint256 amountReceived);\n    error PostValidationExactOut(uint256 exactAmountOut, uint256 amountReceived);\n\n    event TradeExecuted(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    );\n\n    function _executeInternal(\n        Trade memory trade,\n        uint16 dexId,\n        address spender,\n        address target,\n        uint256 msgValue,\n        bytes memory executionData\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        // Get pre-trade token balances\n        (uint256 preTradeSellBalance, uint256 preTradeBuyBalance) = _getBalances(trade);\n\n        // Make sure we have enough tokens to sell\n        _preValidate(trade, preTradeSellBalance);\n\n        // No need to approve ETH trades\n        if (spender != Deployments.ETH_ADDRESS && DexId(dexId) != DexId.NOTIONAL_VAULT) {\n            _approve(trade, spender);\n        }\n\n        _executeTrade(target, msgValue, executionData, spender, trade);\n\n        // Get post-trade token balances\n        (uint256 postTradeSellBalance, uint256 postTradeBuyBalance) = _getBalances(trade);\n\n        _postValidate(trade, postTradeBuyBalance - preTradeBuyBalance);\n\n        // No need to revoke ETH trades\n        if (spender != Deployments.ETH_ADDRESS && DexId(dexId) != DexId.NOTIONAL_VAULT) {\n            IERC20(trade.sellToken).checkRevoke(spender);\n        }\n\n        amountSold = preTradeSellBalance - postTradeSellBalance;\n        amountBought = postTradeBuyBalance - preTradeBuyBalance;\n\n        emit TradeExecuted(trade.sellToken, trade.buyToken, amountSold, amountBought);\n    }\n\n    function _getBalances(Trade memory trade) private view returns (uint256, uint256) {\n        return (\n            trade.sellToken == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(trade.sellToken).balanceOf(address(this)),\n            trade.buyToken == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(trade.buyToken).balanceOf(address(this))\n        );\n    }\n\n    function _isExactIn(Trade memory trade) private pure returns (bool) {\n        return\n            trade.tradeType == TradeType.EXACT_IN_SINGLE ||\n            trade.tradeType == TradeType.EXACT_IN_BATCH;\n    }\n\n    function _isExactOut(Trade memory trade) private pure returns (bool) {\n        return\n            trade.tradeType == TradeType.EXACT_OUT_SINGLE ||\n            trade.tradeType == TradeType.EXACT_OUT_BATCH;\n    }\n\n    /// @notice we may need to unwrap excess WETH for exact out trades\n    function _needsToUnwrapExcessWETH(Trade memory trade, address spender) private pure returns (bool) {\n        return trade.sellToken == Deployments.ETH_ADDRESS && spender != Deployments.ETH_ADDRESS && _isExactOut(trade);\n    }\n\n    function _preValidate(Trade memory trade, uint256 preTradeSellBalance) private pure {\n        if (_isExactIn(trade) && preTradeSellBalance < trade.amount) {\n            revert PreValidationExactIn(trade.amount, preTradeSellBalance);\n        } \n        \n        if (_isExactOut(trade) && preTradeSellBalance < trade.limit) {\n            // NOTE: this implies that vaults cannot execute market trades on exact out\n            revert PreValidationExactOut(trade.limit, preTradeSellBalance);\n        }\n    }\n\n    function _postValidate(Trade memory trade, uint256 amountReceived) private pure {\n        if (_isExactIn(trade) && amountReceived < trade.limit) {\n            revert PostValidationExactIn(trade.limit, amountReceived);\n        }\n\n        if (_isExactOut(trade) && amountReceived < trade.amount) {\n            revert PostValidationExactOut(trade.amount, amountReceived);\n        }\n    }\n\n    /// @notice Approve exchange to pull from this contract\n    /// @dev approve up to trade.amount for EXACT_IN trades and up to trade.limit\n    /// for EXACT_OUT trades\n    function _approve(Trade memory trade, address spender) private {\n        uint256 allowance = _isExactIn(trade) ? trade.amount : trade.limit;\n        address sellToken = trade.sellToken;\n        // approve WETH instead of ETH for ETH trades if\n        // spender != address(0) (checked by the caller)\n        if (sellToken == Constants.ETH_ADDRESS) {\n            sellToken = address(Deployments.WETH);\n        }\n        IERC20(sellToken).checkApprove(spender, allowance);\n    }\n\n    function _executeTrade(\n        address target,\n        uint256 msgValue,\n        bytes memory params,\n        address spender,\n        Trade memory trade\n    ) private {\n        uint256 preTradeBalance;\n \n        if (trade.buyToken == address(Deployments.WETH)) {\n            preTradeBalance = address(this).balance;\n        } else if (trade.buyToken == Deployments.ETH_ADDRESS || _needsToUnwrapExcessWETH(trade, spender)) {\n            preTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n        }\n\n        if (trade.sellToken == address(Deployments.WETH) && spender == Deployments.ETH_ADDRESS) {\n            // Curve doesn't support Deployments.WETH (spender == address(0))\n            uint256 withdrawAmount = _isExactIn(trade) ? trade.amount : trade.limit;\n            Deployments.WETH.withdraw(withdrawAmount);\n        } else if (trade.sellToken == Deployments.ETH_ADDRESS && spender != Deployments.ETH_ADDRESS) {\n            // UniswapV3 doesn't support ETH (spender != address(0))\n            uint256 depositAmount = _isExactIn(trade) ? trade.amount : trade.limit;\n            Deployments.WETH.deposit{value: depositAmount }();\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: msgValue}(params);\n        if (!success) revert TradeExecution(returnData);\n\n        if (trade.buyToken == address(Deployments.WETH)) {\n            if (address(this).balance > preTradeBalance) {\n                // If the caller specifies that they want to receive Deployments.WETH but we have received ETH,\n                // wrap the ETH to Deployments.WETH.\n                uint256 depositAmount;\n                unchecked { depositAmount = address(this).balance - preTradeBalance; }\n                Deployments.WETH.deposit{value: depositAmount}();\n            }\n        } else if (trade.buyToken == Deployments.ETH_ADDRESS || _needsToUnwrapExcessWETH(trade, spender)) {\n            uint256 postTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n            if (postTradeBalance > preTradeBalance) {\n                // If the caller specifies that they want to receive ETH but we have received Deployments.WETH,\n                // unwrap the Deployments.WETH to ETH.\n                uint256 withdrawAmount;\n                unchecked { withdrawAmount = postTradeBalance - preTradeBalance; }\n                Deployments.WETH.withdraw(withdrawAmount);\n            }\n        }\n    }\n\n    function _getLimitAmount(\n        address from,\n        TradeType tradeType,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        uint32 slippageLimit,\n        uint256 oraclePrice,\n        uint256 oracleDecimals\n    ) internal view returns (uint256 limitAmount) {\n        uint256 sellTokenDecimals = 10 **\n            (\n                sellToken == Deployments.ETH_ADDRESS\n                    ? 18\n                    : IERC20(sellToken).decimals()\n            );\n        uint256 buyTokenDecimals = 10 **\n            (\n                buyToken == Deployments.ETH_ADDRESS\n                    ? 18\n                    : IERC20(buyToken).decimals()\n            );\n\n        if (tradeType == TradeType.EXACT_OUT_SINGLE || tradeType == TradeType.EXACT_OUT_BATCH) {\n            // type(uint32).max means no slippage limit\n            if (slippageLimit == type(uint32).max) {\n                return sellToken == Deployments.ETH_ADDRESS\n                    ? address(from).balance\n                    : IERC20(sellToken).balanceOf(from);\n            }\n            // For exact out trades, we need to invert the oracle price (1 / oraclePrice)\n            // We increase the precision before we divide because oraclePrice is in\n            // oracle decimals\n            oraclePrice = (oracleDecimals * oracleDecimals) / oraclePrice;\n            // For exact out trades, limitAmount is the max amount of sellToken the DEX can\n            // pull from the contract\n            limitAmount =\n                ((oraclePrice + \n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) / \n                oracleDecimals;\n\n            // limitAmount is in buyToken precision after the previous calculation,\n            // convert it to sellToken precision\n            limitAmount = (limitAmount * sellTokenDecimals) / buyTokenDecimals;\n        } else {\n            // type(uint32).max means no slippage limit\n            if (slippageLimit == type(uint32).max) {\n                return 0;\n            }\n            // For exact in trades, limitAmount is the min amount of buyToken the contract\n            // expects from the DEX\n            limitAmount =\n                ((oraclePrice -\n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) /\n                oracleDecimals;\n\n            // limitAmount is in sellToken precision after the previous calculation,\n            // convert it to buyToken precision\n            limitAmount = (limitAmount * buyTokenDecimals) / sellTokenDecimals;\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {IAuraBooster, IAuraBoosterLite} from \"../../../../interfaces/aura/IAuraBooster.sol\";\nimport {IAuraRewardPool} from \"../../../../interfaces/aura/IAuraRewardPool.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerPoolMixin, DeploymentParams} from \"./BalancerPoolMixin.sol\";\nimport {TokenUtils} from \"../../../utils/TokenUtils.sol\";\n\n/// @notice Deployment parameters with Aura staking\nstruct AuraVaultDeploymentParams {\n    /// @notice Aura reward pool address\n    IAuraRewardPool rewardPool;\n    /// @notice Base deployment parameters\n    DeploymentParams baseParams;\n}\n\nabstract contract AuraStakingMixin is BalancerPoolMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Aura booster contract used for staking BPT\n    IAuraBooster internal immutable AURA_BOOSTER;\n    /// @notice Aura reward pool contract used for unstaking and claiming reward tokens\n    IAuraRewardPool internal immutable AURA_REWARD_POOL;\n    /// @notice Aura pool ID used for staking\n    uint256 internal immutable AURA_POOL_ID;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params)\n        BalancerPoolMixin(notional_, params.baseParams) {\n        AURA_REWARD_POOL = params.rewardPool;\n\n        AURA_BOOSTER = IAuraBooster(AURA_REWARD_POOL.operator());\n        AURA_POOL_ID = AURA_REWARD_POOL.pid();\n    }\n\n    function _isInvalidRewardToken(address token) internal override view returns (bool) {\n        return (\n            token == TOKEN_1 ||\n            token == TOKEN_2 ||\n            token == TOKEN_3 ||\n            token == TOKEN_4 ||\n            token == TOKEN_5 ||\n            token == address(AURA_BOOSTER) ||\n            token == address(AURA_REWARD_POOL) ||\n            token == address(Deployments.WETH)\n        );\n    }\n\n    /// @notice Called once on initialization to set token approvals\n    function _initialApproveTokens() internal override {\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            tokens[i].checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        }\n\n        // Approve Aura to transfer pool tokens for staking\n        POOL_TOKEN().checkApprove(address(AURA_BOOSTER), type(uint256).max);\n    }\n\n    /// @notice Claim reward tokens\n    function _claimRewardTokens() internal override {\n        // Claim all reward tokens including extra tokens\n        bool success = AURA_REWARD_POOL.getReward(address(this), true); // claimExtraRewards = true\n        require(success);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/ConvexStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {TokenUtils, IERC20} from \"../../utils/TokenUtils.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {IConvexBooster} from \"../../../interfaces/convex/IConvexBooster.sol\";\nimport {IConvexRewardToken} from \"../../../interfaces/convex/IConvexRewardToken.sol\";\nimport {IConvexRewardPool, IConvexRewardPoolArbitrum} from \"../../../interfaces/convex/IConvexRewardPool.sol\";\nimport {Curve2TokenPoolMixin, DeploymentParams} from \"./Curve2TokenPoolMixin.sol\";\n\nstruct ConvexVaultDeploymentParams {\n    address rewardPool;\n    DeploymentParams baseParams;\n}\n\nabstract contract ConvexStakingMixin is Curve2TokenPoolMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Convex booster contract used for staking BPT\n    address internal immutable CONVEX_BOOSTER;\n    /// @notice Convex reward pool contract used for unstaking and claiming reward tokens\n    address internal immutable CONVEX_REWARD_POOL;\n    uint256 internal immutable CONVEX_POOL_ID;\n\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        Curve2TokenPoolMixin(notional_, params.baseParams) {\n        CONVEX_REWARD_POOL = params.rewardPool;\n\n        address convexBooster;\n        uint256 poolId;\n\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            IConvexRewardPool rewardPool = IConvexRewardPool(CONVEX_REWARD_POOL);\n\n            convexBooster = rewardPool.operator();\n            poolId = rewardPool.pid();\n\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            IConvexRewardPoolArbitrum rewardPool = IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL);\n\n            convexBooster = rewardPool.convexBooster();\n            poolId = rewardPool.convexPoolId();\n        } else {\n            revert(\"Unsupported chain\");\n        }\n\n        CONVEX_POOL_ID = poolId;\n        CONVEX_BOOSTER = convexBooster;\n    }\n\n    function _initialApproveTokens() internal override {\n        // If either token is Deployments.ETH_ADDRESS the check approve will short circuit\n        IERC20(TOKEN_1).checkApprove(address(CURVE_POOL), type(uint256).max);\n        IERC20(TOKEN_2).checkApprove(address(CURVE_POOL), type(uint256).max);\n        CURVE_POOL_TOKEN.checkApprove(address(CONVEX_BOOSTER), type(uint256).max);\n    }\n\n    function _isInvalidRewardToken(address token) internal override view returns (bool) {\n        return (\n            token == TOKEN_1 ||\n            token == TOKEN_2 ||\n            token == address(CURVE_POOL_TOKEN) ||\n            token == address(CONVEX_REWARD_POOL) ||\n            token == address(CONVEX_BOOSTER) ||\n            token == Deployments.ALT_ETH_ADDRESS\n        );\n    }\n\n    function _claimRewardTokens() internal override {\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            require(IConvexRewardPool(CONVEX_REWARD_POOL).getReward(address(this), true));\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL).getReward(address(this));\n        } else {\n            revert();\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {IAuraBooster, IAuraBoosterLite} from \"../../../../interfaces/aura/IAuraBooster.sol\";\nimport {IAuraRewardPool} from \"../../../../interfaces/aura/IAuraRewardPool.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {BalancerPoolMixin, DeploymentParams} from \"./BalancerPoolMixin.sol\";\nimport {TokenUtils} from \"../../../utils/TokenUtils.sol\";\n\n/// @notice Deployment parameters with Aura staking\nstruct AuraVaultDeploymentParams {\n    /// @notice Aura reward pool address\n    IAuraRewardPool rewardPool;\n    /// @notice Base deployment parameters\n    DeploymentParams baseParams;\n}\n\nabstract contract AuraStakingMixin is BalancerPoolMixin {\n    using TokenUtils for IERC20;\n\n    /// @notice Aura booster contract used for staking BPT\n    IAuraBooster internal immutable AURA_BOOSTER;\n    /// @notice Aura reward pool contract used for unstaking and claiming reward tokens\n    IAuraRewardPool internal immutable AURA_REWARD_POOL;\n    /// @notice Aura pool ID used for staking\n    uint256 internal immutable AURA_POOL_ID;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params)\n        BalancerPoolMixin(notional_, params.baseParams) {\n        AURA_REWARD_POOL = params.rewardPool;\n\n        AURA_BOOSTER = IAuraBooster(AURA_REWARD_POOL.operator());\n        AURA_POOL_ID = AURA_REWARD_POOL.pid();\n    }\n\n    function _isInvalidRewardToken(address token) internal override view returns (bool) {\n        return (\n            token == TOKEN_1 ||\n            token == TOKEN_2 ||\n            token == TOKEN_3 ||\n            token == TOKEN_4 ||\n            token == TOKEN_5 ||\n            token == address(AURA_BOOSTER) ||\n            token == address(AURA_REWARD_POOL) ||\n            token == address(Deployments.WETH)\n        );\n    }\n\n    /// @notice Called once on initialization to set token approvals\n    function _initialApproveTokens() internal override {\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        for (uint256 i; i < tokens.length; i++) {\n            tokens[i].checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        }\n\n        // Approve Aura to transfer pool tokens for staking\n        POOL_TOKEN().checkApprove(address(AURA_BOOSTER), type(uint256).max);\n    }\n\n    /// @notice Claim reward tokens\n    function _claimRewardTokens() internal override {\n        // Claim all reward tokens including extra tokens\n        bool success = AURA_REWARD_POOL.getReward(address(this), true); // claimExtraRewards = true\n        require(success);\n    }\n}"
    }
  ]
}