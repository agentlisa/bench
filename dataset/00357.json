{
  "Title": "[M-2] Failure in Maintaining Gauge Points",
  "Content": "# [M-2] Failure in Maintaining Gauge Points\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/beanstalk/sun/GaugePointFacet.sol#L36-L57\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/beanstalk/sun/GaugePointFacet.sol#L36-L57</a>\n\n\n## Summary\nThe defaultGaugePointFunction in the smart contract does not explicitly handle the scenario where the percentage of the Base Deposited Value (BDV) equals the optimal percentage (optimalPercentDepositedBdv), resulting in an unintended reduction of gauge points to 0 instead of maintaining their current value.\n\n## Impact\nThis behavior can lead to an undesired decrease in incentives for contract participants, potentially affecting participation and reward accumulation within the contract's ecosystem. Users may lose gauge points and, consequently, rewards due to a technical flaw rather than their actions.\n\n## Proof of Concept (PoC)\nThe testnew_GaugePointAdjustment() test demonstrated this flaw by providing inputs where currentGaugePoints = 1189, optimalPercentDepositedBdv = 64, and percentOfDepositedBdv = 64, expecting newGaugePoints to equal currentGaugePoints. However, the outcome was newGaugePoints = 0, indicating an unexpected reduction to zero.\n\n```solidity\nfunction testnew_GaugePointAdjustment() public {\n    uint256 currentGaugePoints = 1189; \n    uint256 optimalPercentDepositedBdv = 64; \n    uint256 percentOfDepositedBdv = 64; \n\n    uint256 newGaugePoints = gaugePointFacet.defaultGaugePointFunction(\n        currentGaugePoints,\n        optimalPercentDepositedBdv,\n        percentOfDepositedBdv\n    );\n\n    assertTrue(newGaugePoints <= MAX_GAUGE_POINTS, \"New gauge points exceed the maximum allowed\");\n    assertEq(newGaugePoints, currentGaugePoints, \"Gauge points adjustment does not match expected outcome\");\n}\n````\n\n## Recommendations\nImplement Explicit Returns: Ensure the defaultGaugePointFunction has an explicit return for the case where gauge points should not be adjusted. This can be achieved by adding a final return statement that simply returns currentGaugePoints if neither condition for incrementing nor decrementing is met, as shown below:\n\n```solidity\nelse {\n    return currentGaugePoints; \n}\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clsxlpte900074r5et7x6kh96",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/sun/GaugePointFacet.sol",
      "content": "/*\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibGauge} from \"contracts/libraries/LibGauge.sol\";\n\n/**\n * @title GaugePointFacet\n * @author Brean\n * @notice Calculates the gaugePoints for whitelisted Silo LP tokens.\n */\ncontract GaugePointFacet {\n    using SafeMath for uint256;\n\n    uint256 private constant ONE_POINT = 1e18;\n    uint256 private constant MAX_GAUGE_POINTS = 1000e18;\n\n    uint256 private constant UPPER_THRESHOLD = 10001;\n    uint256 private constant LOWER_THRESHOLD = 9999;\n    uint256 private constant THRESHOLD_PRECISION = 10000;\n\n    /**\n     * @notice DefaultGaugePointFunction\n     * is the default function to calculate the gauge points\n     * of an LP asset.\n     *\n     * @dev If % of deposited BDV is .01% within range of optimal,\n     * keep gauge points the same.\n     *\n     * Cap gaugePoints to MAX_GAUGE_POINTS to avoid runaway gaugePoints.\n     */\n    function defaultGaugePointFunction(\n        uint256 currentGaugePoints,\n        uint256 optimalPercentDepositedBdv,\n        uint256 percentOfDepositedBdv\n    ) external pure returns (uint256 newGaugePoints) {\n        if (\n            percentOfDepositedBdv >\n            optimalPercentDepositedBdv.mul(UPPER_THRESHOLD).div(THRESHOLD_PRECISION)\n        ) {\n            // gauge points cannot go below 0.\n            if (currentGaugePoints <= ONE_POINT) return 0;\n            newGaugePoints = currentGaugePoints.sub(ONE_POINT);\n        } else if (\n            percentOfDepositedBdv <\n            optimalPercentDepositedBdv.mul(LOWER_THRESHOLD).div(THRESHOLD_PRECISION)\n        ) {\n            newGaugePoints = currentGaugePoints.add(ONE_POINT);\n\n            // Cap gaugePoints to MAX_GAUGE_POINTS if it exceeds.\n            if (newGaugePoints > MAX_GAUGE_POINTS) return MAX_GAUGE_POINTS;\n        }\n    }\n}"
    }
  ]
}