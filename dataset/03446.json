{
  "Title": "[L02] Malicious parties could prevent the execution of permitable orders",
  "Content": "The [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract allows maker users to submit [permitable orders](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L207) so those can be executed in one transaction, rather than having to have a separate transaction for approvals. Also, order takers can [submit their own permit](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L176) during the filling of the order for the same purpose.\n\n\nHowever, because the maker’s permit is contained inside the [order](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L70), both the maker’s and the taker’s permits would be accessible while the order-fill transaction is in the mempool. This would make it possible for any malicious user to take those permits and execute them on the respective asset contracts while frontrunning the fill transaction. Because these permits have a `nonce` to prevent a double spending attack, the order’s fill transaction would fail as a result of trying to use the same permit that was just used during the frontrun.\n\n\nAlthough there is no security risk, and the maker could create a new order and pre-approve the transaction, this attack could certainly impact the usability of permitable orders. Indeed, a motivated attacker could block *all* permitable orders with this attack. Consider validating if the permit was already submitted, or if the allowance is enough, during the order fills. Also consider letting users know about this possible attack during order composition.\n\n\n***Update:** Not fixed. The 1inch team states:*\n\n\n\n> We had approval checks before but decided to simplify permit flow to just revert on unsuccessful approvals. We’ll think about the ways to notify makers about the issue.\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/OrderMixin.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./helpers/AmountCalculator.sol\";\nimport \"./helpers/ChainlinkCalculator.sol\";\nimport \"./helpers/NonceManager.sol\";\nimport \"./helpers/PredicateHelper.sol\";\nimport \"./interfaces/InteractiveNotificationReceiver.sol\";\nimport \"./libraries/ArgumentsDecoder.sol\";\nimport \"./libraries/Permitable.sol\";\n\n/// @title Order Limits v1 mixin\nabstract contract OrderMixin is\n    EIP712,\n    AmountCalculator,\n    ChainlinkCalculator,\n    NonceManager,\n    PredicateHelper,\n    Permitable\n{\n    using Address for address;\n    using ArgumentsDecoder for bytes;\n\n    /// @notice Emitted every time order gets filled, including partial fills\n    event OrderFilled(\n        address indexed maker,\n        bytes32 orderHash,\n        uint256 remaining\n    );\n\n    /// @notice Emitted when order gets cancelled\n    event OrderCanceled(\n        address indexed maker,\n        bytes32 orderHash\n    );\n\n    // Fixed-size order part with core information\n    struct StaticOrder {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    // `StaticOrder` extension including variable-sized additional order meta information\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n        bytes makerAssetData;\n        bytes takerAssetData;\n        bytes getMakerAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        bytes getTakerAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        bytes predicate;      // this.staticcall(bytes) => (bool)\n        bytes permit;         // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        bytes interaction;\n    }\n\n    bytes32 constant public LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(uint256 salt,address makerAsset,address takerAsset,address maker,address receiver,address allowedSender,uint256 makingAmount,uint256 takingAmount,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n    );\n\n    /// @notice Stores unfilled amounts for each order plus one.\n    /// Therefore 0 means order doesn't exist and 1 means order was filled\n    mapping(bytes32 => uint256) private _remaining;\n\n    /// @notice Returns unfilled amount for order. Throws if order does not exist\n    function remaining(bytes32 orderHash) external view returns(uint256 amount) {\n        amount = _remaining[orderHash];\n        require(amount > 0, \"LOP: Unknown order\");\n        unchecked { amount -= 1; }\n    }\n\n    /// @notice Returns unfilled amount for order\n    /// @return Result Unfilled amount of order plus one if order exists. Otherwise 0\n    function remainingRaw(bytes32 orderHash) external view returns(uint256) {\n        return _remaining[orderHash];\n    }\n\n    /// @notice Same as `remainingRaw` but for multiple orders\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory results) {\n        results = new uint256[](orderHashes.length);\n        for (uint i = 0; i < orderHashes.length; i++) {\n            results[i] = _remaining[orderHashes[i]];\n        }\n    }\n\n    /// @notice Checks order predicate\n    function checkPredicate(Order memory order) public view returns(bool) {\n        bytes memory result = address(this).functionStaticCall(order.predicate, \"LOP: predicate call failed\");\n        require(result.length == 32, \"LOP: invalid predicate return\");\n        return result.decodeBool();\n    }\n\n    /**\n     * @notice Calls every target with corresponding data. Then reverts with CALL_RESULTS_0101011 where zeroes and ones\n     * denote failure or success of the corresponding call\n     * @param targets Array of addresses that will be called\n     * @param data Array of data that will be passed to each call\n     */\n    function simulateCalls(address[] calldata targets, bytes[] calldata data) external {\n        require(targets.length == data.length, \"LOP: array size mismatch\");\n        bytes memory reason = new bytes(targets.length);\n        for (uint i = 0; i < targets.length; i++) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = targets[i].call(data[i]);\n            if (success && result.length > 0) {\n                success = result.decodeBool();\n            }\n            reason[i] = success ? bytes1(\"1\") : bytes1(\"0\");\n        }\n\n        // Always revert and provide per call results\n        revert(string(abi.encodePacked(\"CALL_RESULTS_\", reason)));\n    }\n\n    /// @notice Cancels order by setting remaining amount to zero\n    function cancelOrder(Order memory order) external {\n        require(order.maker == msg.sender, \"LOP: Access denied\");\n\n        bytes32 orderHash = _hash(order);\n        require(_remaining[orderHash] != 1, \"LOP: already filled\");\n        _remaining[orderHash] = 1;\n        emit OrderCanceled(msg.sender, orderHash);\n    }\n\n    /// @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount\n    ) external returns(uint256, uint256) {\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, msg.sender);\n    }\n\n    /// @notice Same as `fillOrder` but calls permit first,\n    /// allowing to approve token spending and make a swap in one transaction.\n    /// Also allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    /// @param target Address that will receive swap funds\n    /// @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.\n    /// See tests for examples\n    function fillOrderToWithPermit(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target,\n        bytes calldata permit\n    ) external returns(uint256, uint256) {\n        (address token, bytes calldata permitData) = permit.decodeTargetAndData();\n        _permit(token, permitData);\n        return fillOrderTo(order, signature, makingAmount, takingAmount, thresholdAmount, target);\n    }\n\n    /// @notice Same as `fillOrder` but allows to specify funds destination instead of `msg.sender`\n    /// @param order Order quote to fill\n    /// @param signature Signature to confirm quote ownership\n    /// @param makingAmount Making amount\n    /// @param takingAmount Taking amount\n    /// @param thresholdAmount Specifies maximum allowed takingAmount it's zero. Otherwise minimum allowed makingAmount\n    /// @param target Address that will receive swap funds\n    function fillOrderTo(\n        Order memory order,\n        bytes calldata signature,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 thresholdAmount,\n        address target\n    ) public returns(uint256, uint256) {\n        bytes32 orderHash = _hash(order);\n\n        {  // Stack too deep\n            uint256 remainingMakerAmount = _remaining[orderHash];\n            if (remainingMakerAmount == 0) {\n                // First fill: validate order and permit maker asset\n                require(order.allowedSender == address(0) || order.allowedSender == msg.sender, \"LOP: private order\");\n                require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"LOP: bad signature\");\n                remainingMakerAmount = order.makingAmount;\n                if (order.permit.length > 0) {\n                    (address token, bytes memory permit) = order.permit.decodeTargetAndCalldata();\n                    _permitMemory(token, permit);\n                    require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n                }\n            } else {\n                unchecked { remainingMakerAmount -= 1; }\n            }\n\n            // Check if order is valid\n            if (order.predicate.length > 0) {\n                require(checkPredicate(order), \"LOP: predicate returned false\");\n            }\n\n            // Compute maker and taker assets amount\n            if ((takingAmount == 0) == (makingAmount == 0)) {\n                revert(\"LOP: only one amount should be 0\");\n            }\n            else if (takingAmount == 0) {\n                if (makingAmount > remainingMakerAmount) {\n                    makingAmount = remainingMakerAmount;\n                }\n                takingAmount = _callGetTakerAmount(order, makingAmount);\n                require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n            }\n            else {\n                makingAmount = _callGetMakerAmount(order, takingAmount);\n                if (makingAmount > remainingMakerAmount) {\n                    makingAmount = remainingMakerAmount;\n                    takingAmount = _callGetTakerAmount(order, makingAmount);\n                }\n                require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n            }\n\n            require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n            // Update remaining amount in storage\n            unchecked {\n                remainingMakerAmount = remainingMakerAmount - makingAmount;\n                _remaining[orderHash] = remainingMakerAmount + 1;\n            }\n            emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n        }\n\n        // Taker => Maker\n        _makeCall(\n            order.takerAsset,\n            abi.encodePacked(\n                IERC20.transferFrom.selector,\n                uint256(uint160(msg.sender)),\n                uint256(uint160(order.receiver == address(0) ? order.maker : order.receiver)),\n                takingAmount,\n                order.takerAssetData\n            )\n        );\n\n        // Maker can handle funds interactively\n        if (order.interaction.length > 0) {\n            (address interactionTarget, bytes memory interactionData) = order.interaction.decodeTargetAndCalldata();\n            InteractiveNotificationReceiver(interactionTarget).notifyFillOrder(\n                msg.sender, order.makerAsset, order.takerAsset, makingAmount, takingAmount, interactionData\n            );\n        }\n\n        // Maker => Taker\n        _makeCall(\n            order.makerAsset,\n            abi.encodePacked(\n                IERC20.transferFrom.selector,\n                uint256(uint160(order.maker)),\n                uint256(uint160(target)),\n                makingAmount,\n                order.makerAsset\n            )\n        );\n\n        return (makingAmount, takingAmount);\n    }\n\n    function _hash(Order memory order) private view returns(bytes32) {\n        StaticOrder memory staticOrder;\n        assembly {  // solhint-disable-line no-inline-assembly\n            staticOrder := order\n        }\n        return _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    LIMIT_ORDER_TYPEHASH,\n                    staticOrder,\n                    keccak256(order.makerAssetData),\n                    keccak256(order.takerAssetData),\n                    keccak256(order.getMakerAmount),\n                    keccak256(order.getTakerAmount),\n                    keccak256(order.predicate),\n                    keccak256(order.permit),\n                    keccak256(order.interaction)\n                )\n            )\n        );\n    }\n\n    function _makeCall(address asset, bytes memory assetData) private {\n        bytes memory result = asset.functionCall(assetData, \"LOP: asset.call failed\");\n        if (result.length > 0) {\n            require(result.decodeBool(), \"LOP: asset.call bad result\");\n        }\n    }\n\n    function _callGetMakerAmount(Order memory order, uint256 takerAmount) private view returns(uint256 makerAmount) {\n        if (order.getMakerAmount.length == 0) {\n            // On empty order.getMakerAmount calldata only whole fills are allowed\n            require(takerAmount == order.takingAmount, \"LOP: wrong taker amount\");\n            return order.makingAmount;\n        }\n        bytes memory result = address(this).functionStaticCall(abi.encodePacked(order.getMakerAmount, takerAmount), \"LOP: getMakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getMakerAmount ret\");\n        return result.decodeUint256();\n    }\n\n    function _callGetTakerAmount(Order memory order, uint256 makerAmount) private view returns(uint256 takerAmount) {\n        if (order.getTakerAmount.length == 0) {\n            // On empty order.getTakerAmount calldata only whole fills are allowed\n            require(makerAmount == order.makingAmount, \"LOP: wrong maker amount\");\n            return order.takingAmount;\n        }\n        bytes memory result = address(this).functionStaticCall(abi.encodePacked(order.getTakerAmount, makerAmount), \"LOP: getTakerAmount call failed\");\n        require(result.length == 32, \"LOP: invalid getTakerAmount ret\");\n        return result.decodeUint256();\n    }\n}"
    }
  ]
}