{
  "Title": "[11] Hardcoded `Min_stake` of 1e18 doesn’t incentivize staking expensive tokens",
  "Content": "\n*Note: At the judge’s request [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1061#issuecomment-1919014163), this downgraded issue from the same warden has been included in this report for completeness.*\n\n### Lines of code\n\nhttps://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/loan/SurplusGuildMinter.sol#L26\n\n### Impact\n\nEach CREDIT Token holder (`gUSDC`, `gWETH`, `gWBTC`, etc.) can stake them and start voting in a gauge. However, there's a minimum staking amount (`MIN_STAKE`) of 1e18. This means that for certain markets, staking will be more expensive compared to others because of this fixed minimum stake requirement.\n\n### Proof of Concept\n\nFor instance, in the case of `gUSDC`, users looking to stake will need to provide approximately 1 USDC (based on `creditMultiplier`). On the other hand, for `gWBTC`, they would need to stake around 1 BTC (`$42,000` at the time of writing). This could discourage users from staking in such terms.\n\n```solidity\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n....\n```\n\n### Recommended Mitigation Steps\n\nInclude the `MIN_STAKE` value in the constructor, making it dependent on the Credit Token for that specific term.\n\n### Assessed type\n\nContext\n\n**[TrungOre (judge) decreased severity to Low](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1027#issuecomment-1910281000)**\n\n**[TrungOre (judge) commented via issue #1061](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1061#issuecomment-1918535428):**\n> [01] - Low<br>\n> [02] - Low<br>\n> [03] - Information<br>\n> [04] - Low<br>\n> [05] - Information<br>\n> [06] - Low<br>\n> [07] - Low<br>\n> [08] - Non-Critical<br>\n> [09] - Low<br>\n> [10] - Low<br>\n> [11] - Low\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/loan/SurplusGuildMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {SafeCastLib} from \"@src/external/solmate/SafeCastLib.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.\n/// In this contract, CREDIT tokens can be provided as first-loss capital to\n/// the surplus buffer of chosen terms, and in exchange, users can participate in the\n/// gauge voting system at a reduced capital cost & without exposure to GUILD\n/// token's price fluctuations. GUILD minted through this contract can only\n/// participate in the gauge system to increase debt ceiling and earn fees\n/// from selected lending terms.\n/// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will\n/// change the rewards of all pending unclaimed rewards. Before a proposal to update\n/// the reward ratio execute, this contract should be pinged with `getRewards` for\n/// all users that have pending rewards.\ncontract SurplusGuildMinter is CoreRef {\n    /// @notice minimum number of CREDIT to stake\n    uint256 public constant MIN_STAKE = 1e18;\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice emitted when a user stakes CREDIT on a target lending term\n    event Stake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user unstakes CREDIT on a target lending term\n    event Unstake(\n        uint256 indexed timestamp,\n        address indexed term,\n        uint256 amount\n    );\n    /// @notice emitted when a user is rewarded GUILD from non-zero interest\n    /// rate and closing their position without loss.\n    event GuildReward(\n        uint256 indexed timestamp,\n        address indexed user,\n        uint256 amount\n    );\n    /// @notice emitted when the mintRatio is updated\n    event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n    /// @notice emitted when the rewardRatio is updated\n    event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);\n\n    /// @notice reference to the ProfitManager\n    address public immutable profitManager;\n\n    /// @notice reference to the CREDIT token\n    address public immutable credit;\n\n    /// @notice reference to the GUILD token\n    address public immutable guild;\n\n    /// @notice reference to the RateLimitedGuildMinter\n    address public immutable rlgm;\n\n    /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.\n    uint256 public mintRatio;\n\n    /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.\n    /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18\n    /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.\n    uint256 public rewardRatio;\n\n    struct UserStake {\n        uint48 stakeTime;\n        uint48 lastGaugeLoss;\n        uint160 profitIndex;\n        uint128 credit;\n        uint128 guild;\n    }\n\n    /// @notice list of user stakes (stakes[user][term]=UserStake)\n    mapping(address => mapping(address => UserStake)) internal _stakes;\n\n    constructor(\n        address _core,\n        address _profitManager,\n        address _credit,\n        address _guild,\n        address _rlgm,\n        uint256 _mintRatio,\n        uint256 _rewardRatio\n    ) CoreRef(_core) {\n        profitManager = _profitManager;\n        credit = _credit;\n        guild = _guild;\n        rlgm = _rlgm;\n        mintRatio = _mintRatio;\n        rewardRatio = _rewardRatio;\n    }\n\n    /// @notice get a given user stake\n    function getUserStake(\n        address user,\n        address term\n    ) external view returns (UserStake memory) {\n        return _stakes[user][term];\n    }\n\n    /// @notice stake CREDIT tokens to start voting in a gauge.\n    function stake(address term, uint256 amount) external whenNotPaused {\n        // apply pending rewards\n        (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(\n            msg.sender,\n            term\n        );\n\n        require(\n            lastGaugeLoss != block.timestamp,\n            \"SurplusGuildMinter: loss in block\"\n        );\n        require(amount >= MIN_STAKE, \"SurplusGuildMinter: min stake\");\n\n        // pull CREDIT from user & transfer it to surplus buffer\n        CreditToken(credit).transferFrom(msg.sender, address(this), amount);\n        CreditToken(credit).approve(address(profitManager), amount);\n        ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);\n\n        // self-mint GUILD tokens\n        uint256 _mintRatio = mintRatio;\n        uint256 guildAmount = (_mintRatio * amount) / 1e18;\n        RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n        GuildToken(guild).incrementGauge(term, guildAmount);\n\n        // update state\n        userStake = UserStake({\n            stakeTime: SafeCastLib.safeCastTo48(block.timestamp),\n            lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),\n            profitIndex: SafeCastLib.safeCastTo160(\n                ProfitManager(profitManager).userGaugeProfitIndex(\n                    address(this),\n                    term\n                )\n            ),\n            credit: userStake.credit + SafeCastLib.safeCastTo128(amount),\n            guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)\n        });\n        _stakes[msg.sender][term] = userStake;\n\n        // emit event\n        emit Stake(block.timestamp, term, amount);\n    }\n\n    /// @notice unstake CREDIT tokens and stop voting in a gauge.\n    function unstake(address term, uint256 amount) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(\n            msg.sender,\n            term\n        );\n\n        // if the user has been slashed, there is nothing to do\n        if (slashed) return;\n\n        // check that the user is at least staking `amount` CREDIT\n        require(\n            amount != 0 && userStake.credit >= amount,\n            \"SurplusGuildMinter: invalid amount\"\n        );\n\n        // update stake\n        uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /\n            userStake.credit; /// upcast guild to prevent overflow\n        uint256 guildAmount = (userMintRatio * amount) / 1e18;\n\n        if (amount == userStake.credit) guildAmount = userStake.guild;\n\n        userStake.credit -= SafeCastLib.safeCastTo128(amount);\n        userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);\n\n        if (userStake.credit == 0) {\n            userStake.stakeTime = 0;\n            userStake.lastGaugeLoss = 0;\n            userStake.profitIndex = 0;\n        } else {\n            // if not unstaking all, make sure the stake remains\n            // greater than the minimum stake\n            require(\n                userStake.credit >= MIN_STAKE,\n                \"SurplusGuildMinter: remaining stake below min\"\n            );\n        }\n        _stakes[msg.sender][term] = userStake;\n\n        // withdraw & transfer CREDIT\n        ProfitManager(profitManager).withdrawFromTermSurplusBuffer(\n            term,\n            msg.sender,\n            amount\n        );\n\n        // burn GUILD\n        GuildToken(guild).decrementGauge(term, guildAmount);\n        RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n        GuildToken(guild).burn(guildAmount);\n\n        // emit event\n        emit Unstake(block.timestamp, term, amount);\n    }\n\n    /// @notice get rewards from a staking position without unstaking.\n    /// This can be used to slash users that have an outstanding unapplied loss.\n    function getRewards(\n        address user,\n        address term\n    )\n        public\n        returns (\n            uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)\n            UserStake memory userStake, // stake state after execution of getRewards()\n            bool slashed // true if the user has been slashed\n        )\n    {\n        bool updateState;\n        lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);\n        if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {\n            slashed = true;\n        }\n\n        // if the user is not staking, do nothing\n        userStake = _stakes[user][term];\n        if (userStake.stakeTime == 0)\n            return (lastGaugeLoss, userStake, slashed);\n\n        // compute CREDIT rewards\n        ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes\n        uint256 _profitIndex = ProfitManager(profitManager)\n            .userGaugeProfitIndex(address(this), term);\n        uint256 _userProfitIndex = uint256(userStake.profitIndex);\n\n        if (_profitIndex == 0) _profitIndex = 1e18;\n        if (_userProfitIndex == 0) _userProfitIndex = 1e18;\n\n        uint256 deltaIndex = _profitIndex - _userProfitIndex;\n\n        if (deltaIndex != 0) {\n            uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /\n                1e18;\n            uint256 guildReward = (creditReward * rewardRatio) / 1e18;\n            if (slashed) {\n                guildReward = 0;\n            }\n\n            // forward rewards to user\n            if (guildReward != 0) {\n                RateLimitedMinter(rlgm).mint(user, guildReward);\n                emit GuildReward(block.timestamp, user, guildReward);\n            }\n            if (creditReward != 0) {\n                CreditToken(credit).transfer(user, creditReward);\n            }\n\n            // save the updated profitIndex\n            userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);\n            updateState = true;\n        }\n\n        // if a loss occurred while the user was staking, the GuildToken.applyGaugeLoss(address(this))\n        // can be called by anyone to slash address(this) and decrement gauge weight etc.\n        // The contribution to the surplus buffer is also forfeited.\n        if (slashed) {\n            emit Unstake(block.timestamp, term, uint256(userStake.credit));\n            userStake = UserStake({\n                stakeTime: uint48(0),\n                lastGaugeLoss: uint48(0),\n                profitIndex: uint160(0),\n                credit: uint128(0),\n                guild: uint128(0)\n            });\n            updateState = true;\n        }\n\n        // store the updated stake, if needed\n        if (updateState) {\n            _stakes[user][term] = userStake;\n        }\n    }\n\n    /// @notice update the mint ratio for a given user.\n    function updateMintRatio(address user, address term) external {\n        // apply pending rewards\n        (, UserStake memory userStake, bool slashed) = getRewards(user, term);\n\n        // if the user has been slashed or isnt staking, there is nothing to do\n        if (userStake.stakeTime == 0 || slashed) return;\n\n        // update amount of GUILD tokens staked\n        uint256 guildBefore = uint256(userStake.guild);\n        uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;\n        if (guildAfter > guildBefore) {\n            uint256 guildAmount = guildAfter - guildBefore;\n            RateLimitedMinter(rlgm).mint(address(this), guildAmount);\n            GuildToken(guild).incrementGauge(term, guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        } else if (guildAfter < guildBefore) {\n            uint256 guildAmount = guildBefore - guildAfter;\n            GuildToken(guild).decrementGauge(term, guildAmount);\n            RateLimitedMinter(rlgm).replenishBuffer(guildAmount);\n            GuildToken(guild).burn(guildAmount);\n            _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);\n        }\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens minted\n    /// per CREDIT tokens contributed to the surplus buffer.\n    function setMintRatio(\n        uint256 _mintRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        mintRatio = _mintRatio;\n        emit MintRatioUpdate(block.timestamp, _mintRatio);\n    }\n\n    /// @notice governor-only function to set the ratio of GUILD tokens rewarded\n    /// per CREDIT tokens earned from GUILD staking.\n    function setRewardRatio(\n        uint256 _rewardRatio\n    ) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        rewardRatio = _rewardRatio;\n        emit RewardRatioUpdate(block.timestamp, _rewardRatio);\n    }\n}"
    }
  ]
}