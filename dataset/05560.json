{
  "Title": "[M-04] The way fees are accounted can break the sorted list order",
  "Content": "\neBTC borrows the corrected stake mechanism from Liquity for reward distributions. ([paper](https://github.com/liquity/dev/blob/main/papers/Efficient_Order-Preserving_Redistribution_of_Troves.pdf))\n\nDoing a pure collateral proportionnal redistribution will over-rewards fresh cdps, and under-rewards older troves. The redistribution must deal with the fact that some fraction of a cdp’s entire collateral is the accumulated reward from previous liquidations, and this fraction varies across cdps.\n\nThe corrected stake was introduced by Liquity to correct for this.\n\n> The intuition behind the choice of corrected stake is that the corrected stake effectively models the fresh trove’s collateral as a total collateral, which includes ‘virtual’ accumulated rewards. The corrected stake earns rewards for the trove as if the trove had been in the system from the beginning - thus maintaining proportional reward growth.\n\n*([Source](https://github.com/liquity/dev/blob/main/papers/Efficient_Order-Preserving_Redistribution_of_Troves.pdf>))*\n\neBTC makes some modifications to the original design that make the protocol vulnerable to an order break in the sorted list.\n\nLet’s explain why.\n\nInitially `totalStake == totalCollateral`, this is because no fees have been taken yet. Then, as the stETH value increases the protocol takes 50\\%. (if stETH apr is 5\\% then eBTC takes 2,5\\% as fees): [CdpManagerStorage.sol#L509-L521](https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/CdpManagerStorage.sol#L509-L521).\n\n```solidity\nfunction _calcSyncedGlobalAccounting(\n    uint256 _newIndex,\n    uint256 _oldIndex\n) internal view returns (uint256, uint256, uint256) {\n    if (_newIndex > _oldIndex && totalStakes > 0) {\n        /// @audit-ok We don't take the fee if we had a negative rebase\n        (\n            uint256 _feeTaken,\n            uint256 _deltaFeePerUnit,\n            uint256 _perUnitError\n        ) = calcFeeUponStakingReward(_newIndex, _oldIndex);\n\n        // calculate new split per stake unit\n        uint256 _newPerUnit = systemStEthFeePerUnitIndex + _deltaFeePerUnit;\n        return (_feeTaken, _newPerUnit, _perUnitError);\n    } else {\n        return (0, systemStEthFeePerUnitIndex, systemStEthFeePerUnitIndexError);\n    }\n}\n```\n\nThe `_feeTaken` goes directly to the protocol and reduces the `totalCollateral` value. (because internal accounting uses shares for internal accounting aka wstETH) [CdpManagerStorage.sol#L585](https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/CdpManagerStorage.sol#L585):\n\n```solidity\nactivePool.allocateSystemCollSharesToFeeRecipient(_feeTaken);\n```\n\nBecause the stake is calculated like this: [CdpManagerStorage.sol#L454](https://github.com/code-423n4/2023-10-badger/blob/f2f2e2cf9965a1020661d179af46cb49e993cb7e/packages/contracts/contracts/CdpManagerStorage.sol#L454)\n\n```solidity\nstake = (_coll * totalStakesSnapshot) / totalCollateralSnapshot;\n```\n\nNow the new CDP stake will be higher than old cdp stakes since `totalStakesSnapshot` has not moved but `totalCollateralSnapshot` has decreased.\n\n⇒ Since the debt redistributions and fee payments depend on the stake to distribute funds, we can intuitively understand that new CDPs will pay more fees than the old ones. Therefore, new cpds NICR (Nominal Individual Collateral Ratio = shares/debt) will decrease at a higher rate than old ones.\n\nThis can cause old CDPs to cross newer ones and break list order.\n\nThis list order break make the insertion position not unique anymore, this can lead to more and more disorder in the list that leads to unexpected behaviours such as DOS and bad redemption order.\n\n### Proof of Concept\n\nThis poc only takes advantage of splitting fees to break the list order, but note that debt redistribution events exacerbate this problem.\n\n<details>\n\n```solidity\nfunction test_H1() public {\n  vm.pauseGasMetering();\n\n  address firstUser;\n  address lastUser;\n  bytes32 firstCdpId;\n  bytes32 lastCdpId;       \n\n  uint loop = 100;\n\n  /// let's open 100 cdps and save the 1st and last index\n  for (uint256 i = 0; i < loop; i++) {\n      (uint256 oldIndex, uint256 newIndex) = _applyIndexChange(2000000000000000); // 0,2% stETH increase\n      // get a random user\n      address user = _utils.getNextUserAddress();\n      vm.startPrank(user);\n\n      // Randomize collateral amount used\n      vm.deal(user, 10 ether * 1000);\n      collateral.approve(address(borrowerOperations), 10 ether*1000);\n      collateral.deposit{value: 10 ether * 1000}();\n\n      uint shareAmount = 10 ether;\n      uint256 collAmount = collateral.getPooledEthByShares(shareAmount);\n\n      uint256 borrowedAmount;\n      if (i == loop - 1)\n          // here we compute borrowedAmount to make lastCdpId NCIR very close to firstCdpId NICR\n          borrowedAmount = (1e20 * (shareAmount - collateral.getSharesByPooledEth(2e17))) / cdpManager.getSyncedNominalICR(firstCdpId);   // borrowedAmount = 0.65764 ether;\n      else\n          borrowedAmount = 0.5 ether;\n\n      bytes32 id = borrowerOperations.openCdp(borrowedAmount, \"hint\", \"hint\", collAmount);\n\n      if (i == 0)        {firstUser = user; firstCdpId = id;}\n      if (i == loop - 1) {lastUser = user ; lastCdpId = id;}\n\n      vm.stopPrank();\n  }\n\n  logNICR(firstCdpId, lastCdpId);\n  // NICR 1st trove should be < NICR last trove \n  assertLe(cdpManager.getSyncedNominalICR(firstCdpId), cdpManager.getSyncedNominalICR(lastCdpId));\n\n  /// Let's increase the stETH by 40% and open a last cdp\n  (uint256 oldIndex, uint256 newIndex) = _applyIndexChange(400000000000000000); // 40% stETH increase\n  // get a random user\n  address user = _utils.getNextUserAddress();\n  vm.startPrank(user);\n\n  uint256 collAmount = 10 ether;\n  // deal ETH and deposit for collateral\n  vm.deal(user, collAmount * 1000);\n  collateral.approve(address(borrowerOperations), collAmount);\n  collateral.deposit{value: collAmount * 1000}();\n\n  uint borrowedAmount = 0.5 ether;\n  borrowerOperations.openCdp(borrowedAmount, \"hint\", \"hint\", collAmount);\n  vm.stopPrank();\n  \n  logNICR(firstCdpId, lastCdpId);\n  // NICR 1st trove should be < NICR last cdp but it's not the case \n  assertLe(cdpManager.getSyncedNominalICR(firstCdpId), cdpManager.getSyncedNominalICR(lastCdpId));\n}\n\nfunction logNICR(bytes32 firstCdpId, bytes32 lastCdpId) public {\n  console.log(\"---------------------------------- 1st cdp\");\n  console.log(\"getCdpStake         : \", cdpManager.getCdpStake(firstCdpId));\n  console.log(\"getCdpCollShares    : \", cdpManager.getCdpCollShares(firstCdpId));\n  console.log(\"getSyncedNominalICR : \", cdpManager.getSyncedNominalICR(firstCdpId));\n  console.log(\"---------------------------------- last cdp\");\n  console.log(\"getCdpStake         : \", cdpManager.getCdpStake(lastCdpId));  \n  console.log(\"getCdpCollShares    : \", cdpManager.getCdpCollShares(lastCdpId));\n  console.log(\"getSyncedNominalICR : \", cdpManager.getSyncedNominalICR(lastCdpId));\n  console.log(\"---\");\n  console.logInt(int(int(cdpManager.getSyncedNominalICR(firstCdpId))-int(cdpManager.getSyncedNominalICR(lastCdpId))));\n  console.log(\"----------------------------------\");\n}\n```\n\n</details>\n\nThis test fails on the last assertion, meaning that the list is no longer sorted.\n\n### Recommended Mitigation Steps\n\nThis is hard to fix because the sorted list was not designed to work this way.\n\nI haven't been able to find a quick fix that preserves the list order with a fair redistribution.\n\nEven if it is less fair for borrowers, a proportional distribution (without the corrected stake) can solve this problem but it will be an incomplete solution.\n\nThe eBTC team needs to rethink the fee/debt redistribution to maintain the list order.\n\n### Sources\n\n<https://github.com/liquity/dev/blob/main/papers/Efficient_Order-Preserving_Redistribution_of_Troves.pdf>\n\n**[Alex the Entreprenerd (Badger) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/155#issuecomment-1827750840):**\n > The conclusion is wrong.\n> \n> But the finding showed that the feeSplit math is incorrect, which is a severe finding.\n\n**[rayeaster (Badger) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/155#issuecomment-1831082736):**\n > It is more like a precision issue using Solidity (sth like $\\frac{(x -z) + (z - y)}{c} \\neq \\frac{x - z}{c} + \\frac{z - y}{c}$) instead of a fundamental design problem. \n> \n> The following statement is worth more thinking:\n> `we can intuitively understand that new CDPs will pay more fees than the old ones. Therefore, new cpds NICR (Nominal Individual Collateral Ratio = shares/debt) will decrease at a higher rate than old ones.`\n> \n> Yes, **higher stake** leads to **more fees**, but it is NOT equal to **\"decrease at a higher rate\"**, actually the **relative** ratio of NICR between two CDPs always keep the **same** \"theoretically\" by the stake mechanism:\n> \n> - Suppose `totalStakeSnapshot` is $S_{n}$ which is not changed by split fee claim\n> - At time `T0`, `totalCollateralSnapshot` is $C_{n0}$ \n> - At time `T1`, a $CDP_{1}$ is created with initial collateral share `c` and debt `d` thus its stake is $s_{1}=\\frac{c * S_{n}}{C_{n0}}$\n> - At time `T2`, a split fee claim happens and `totalCollateralSnapshot` is changed to $C_{n1}$, **note that** $C_{n1} < C_{n0}$ and $C_{n0} - C_{n1} = S_{n} * \\Delta{P_{1}}$ where $\\Delta{P_{1}}$ is the delta change of fee per stake unit\n> - At time `T3`, another $CDP_{2}$ is created with the same collateral share `c` and debt `d` but now its stake is $s_{2}=\\frac{C * S_n}{C_{n1}} > s_{1}$\n> - Now `NICR` of $CDP_{1}$ is $\\frac{c - s_{1} * \\Delta{P_{1}}}{d}$ and `NICR` of $CDP_{2}$ is $\\frac{c}{d} > NICR_{1}$, their `NICR` ratio $r_{1}$ is $\\frac{c - s_{1} * \\Delta{P_{1}}}{c}$\n> - At time `T4` (maybe after a long time), a split fee claim happens again and $\\Delta{P_{2}}$ is the delta change of fee per stake unit for this time\n> - Now `NICR` of $CDP_{1}$ is $\\frac{c - s_{1} * \\Delta{P_{1}} - s_{1} * \\Delta{P_{2}}}{d}$ and `NICR` of $CDP_{2}$ is $\\frac{c - s_{2} * \\Delta{P_{2}}}{d}$, so their `NICR` ratio $r_{2}$ is now $\\frac{c - s_{1} * \\Delta{P_{1}} - s_{1} * \\Delta{P_{2}}}{c - s_{2} * \\Delta{P_{2}}}$\n> - Let us prove that $r_{2}=r_{1}$ in theory\n> \n> If $\\frac{c - s_{1} * \\Delta{P_{1}} - s_{1} * \\Delta{P_{2}}}{c - s_{2} * \\Delta{P_{2}}} = \\frac{c - s_{1} * \\Delta{P_{1}}}{c} \\Rightarrow $ \n> \n> $(c - s_{1} * \\Delta{P_{1}}) * (c - s_{2} * \\Delta{P_{2}}) = c * (c - s_{1} * \\Delta{P_{1}} - s_{1} * \\Delta{P_{2}}) \\Rightarrow $\n> \n> $c^2 - c * s_{2} * \\Delta{P_{2}} - c * s_{1} * \\Delta{P_{1}} + s_{1} * s_{2} * \\Delta{P_{1}} * \\Delta{P_{2}} = c^2 - c * s_{1} * \\Delta{P_{1}} - c * s_{1} * \\Delta{P_{2}} \\Rightarrow $\n> \n> $s_{1} * s_{2} * \\Delta{P_{1}} = c * (s_{2} - s_{1}) \\Rightarrow \\frac{s_{1}}{c} * \\Delta{P_{1}} = 1 - \\frac{s_{1}}{s_{2}} \\Rightarrow$\n> \n> $\\frac{S_{n}}{C_{n0}} * \\Delta{P_{1}} = 1 - \\frac{C_{n1}}{C_{n0}} \\Rightarrow S_{n} * \\Delta{P_{1}} = C_{n0} - C_{n1} $ \n> \n> Proved\n> \n> If we could manually `syncAccounting` for the first CDP along the poc test path (i.e., always sync its collateral for every index increase in the loop) or **simply** set the loop number to 1000 instead of 100, the list order will not break at the end of the poc test. \n> \n> And the break require some delicate conditions like significant increase of the Lido stETH index, e.g., 40% increase means about 10 years at the current staking reward apr.\n> \n> I suggest to mark it as \"acknowledged\".\n\n**[ronnyx2017 (Judge) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/155#issuecomment-1833645852):**\n > Thanks for the careful and clear math prove from @rayeaster, it's very helpful to show the underlying mechanism of the issue based. It's amazing. And I want to add a comment for s2 in T3. There is no need to worry about the impact of c and s1 on Sn and Cn1 in T1, as they grow proportionally. The mathematical calculations in T3 are completely correct, and you can further prove this. I have actually done it myself, but I'm not very good at writing mathematical formulas using Markdown. So, I'm only providing this conclusion to prevent any doubts about this.\n> \n> And I add one line at the end of logNICR function in  the original poc:\n> ```solidity\n> console.log(cdpManager.getSyncedNominalICR(firstCdpId) * 1e18 / cdpManager.getSyncedNominalICR(lastCdpId));\n> ```\n> The console log can clearly show why the sponsor says it's a precision issue:\n> ```\n> Logs:\n> before\n>   ---------------------------------- 1st cdp\n>   getCdpStake         :  9800399201596806387\n>   getCdpCollShares    :  9800399201596806387\n>   getSyncedNominalICR :  1791162047648499053200\n>   ---------------------------------- last cdp\n>   getCdpStake         :  10760678217311938700\n>   getCdpCollShares    :  9833333333333333333\n>   getSyncedNominalICR :  1791162047648499053418\n>   ---\n>   -218\n>   999999999999999999\n>   ----------------------------------\n>  after\n>   ---------------------------------- current cdp\n>   getCdpStake         :  7660143815713583482\n>   getCdpCollShares    :  6125000000000000000\n>   getSyncedNominalICR :  1225000000000000000000\n>   ----------------------------------\n>   ---------------------------------- 1st cdp\n>   getCdpStake         :  9800399201596806387\n>   getCdpCollShares    :  9800399201596806387\n>   getSyncedNominalICR :  1567266791692436672600\n>   ---------------------------------- last cdp\n>   getCdpStake         :  10760678217311938700\n>   getCdpCollShares    :  9833333333333333333\n>   getSyncedNominalICR :  1567266791692436672219\n>   ---\n>   381\n>   1000000000000000000\n>   ----------------------------------\n> ```\n> In fact, this variation is not linear. It requires the growth of the index to occur at an extremely precise value in order to generate this error.\n> \n> And I also want to provide a poc test for the amazing math prove from @rayeaster, thanks again.\n> ```solidity\n>       function test_H2prove() public {\n>         vm.pauseGasMetering();\n>       \n>         address cdp1_user;\n>         address cdp2_user;\n>         bytes32 cdp1_id;\n>         bytes32 cdp2_id;       \n> \n>         // stake someting to init\n>         {\n>             address _nobody = prepareUser();\n>             vm.prank(_nobody);\n>             borrowerOperations.openCdp(1.337 ether, \"hint\", \"hint\", 31.415 ether);\n>             _applyIndexChange(1000000000000000); // +0.1% index\n>         }\n>         \n>         // T0\n>         {\n>             cdpManager.syncGlobalAccountingAndGracePeriod();\n>             uint Sn = cdpManager.totalStakesSnapshot();\n>             uint Cn0 = cdpManager.totalCollateralSnapshot();\n>             console.log(Sn, Cn0);    \n>         }\n>         \n>         // const\n>         uint c = 10 ether;\n>         uint d = 0.5 ether;\n> \n>         // T1\n>         cdp1_user = prepareUser();\n>         vm.prank(cdp1_user);\n>         cdp1_id = borrowerOperations.openCdp(d, \"hint\", \"hint\", c);\n>         // uint s1 = cdpManager.getCdpCollShares(cdp1_id);\n>         // console.log(s1);\n> \n>         // T2\n>         {\n>             int delta_p1 = 2000000000000000; // +0.2% index\n>             _applyIndexChange(delta_p1);\n>             cdpManager.syncGlobalAccountingAndGracePeriod();\n>             // vm.prank(cdp1_user);\n>             // cdpManager.syncAccounting(cdp1_id);\n>         }\n> \n>         // T3\n>         cdp2_user = prepareUser();\n>         vm.prank(cdp2_user);\n>         // c = 17 ether;\n>         // d = 1.1 ether;\n>         cdp2_id = borrowerOperations.openCdp(d, \"hint\", \"hint\", c);\n>         // uint s2 = cdpManager.getCdpCollShares(cdp2_id);\n>         // console.log(s2);\n> \n>         // after T3, we should calc NICR rate\n>         uint wad = 1e18;\n>         {\n>             uint cdp1_NICR_T3 = cdpManager.getSyncedNominalICR(cdp1_id);\n>             uint cdp2_NICR_T3 = cdpManager.getSyncedNominalICR(cdp2_id);\n>             uint rate_T3 = cdp1_NICR_T3 * wad / cdp2_NICR_T3;\n>             console.log(rate_T3);\n>         }\n> \n>         // T4\n>         {\n>             int delta_p2 = 400000000000000000; // +40% index\n>             _applyIndexChange(delta_p2);\n>             cdpManager.syncGlobalAccountingAndGracePeriod();\n>             // dump rate after T4\n>             uint cdp1_NICR_T4 = cdpManager.getSyncedNominalICR(cdp1_id);\n>             uint cdp2_NICR_T4 = cdpManager.getSyncedNominalICR(cdp2_id);\n>             uint rate_T4 = cdp1_NICR_T4 * wad / cdp2_NICR_T4;\n>             console.log(rate_T4);\n>             // console.log(cdpManager.getCdpCollShares(cdp1_id), cdpManager.getCdpCollShares(cdp2_id));\n>         }\n>       }\n> ```\n\n**[rayeaster (Badger) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/155#issuecomment-1833756837):**\n > @ronnyx2017 - Thanks for the great proof test!\n> \n> It helps to spark an interesting idea. Do you think it would help to use sth like `cdpManager.getSyncedNominalICR(firstCdpId) * 1e18 / cdpManager.getSyncedNominalICR(lastCdpId)` to compare the NICR as an additional check?\n> \n> I mean we could say $NICR_{1}$ is larger than $NICR_{2}$ **only if** the following two conditions are satisfied **at the same time**:\n> - $NICR_{1} > NICR_{2}$\n> - $\\frac{NICR_{1} * 1e18}{NICR_{2}} > 1e18$\n\n**[ronnyx2017 (Judge) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/155#issuecomment-1833965334):**\n > Aha, I think this check may be idealistic. The poc we are currently discussing only involves a single rounding situation, but the actual scenario may be much more complex. Each syncAccounting after a rebase introduces rounding, but I believe this will actually alleviate the impact of the issue.\n\n**[rayeaster (Badger) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/155#issuecomment-1835315439):**\n > If we add bad debt redistribution into the play, the ratio of NICR between CDPs would change but will **NOT** go to the extent that reverse the ordering, theoretically:\n> \n> - Following above [math derivation setup](https://github.com/code-423n4/2023-10-badger-findings/issues/155#issuecomment-1831082736), suppose right after $CDP_{2}$ is created at time T3, there is a liquidation with some bad debt to be redistributed and introduce a $\\Delta{d_{1}}$ increase for `systemDebtRedistributionIndex`\n> - Now the `NICR` of $CDP_{1}$ is $\\frac{c - s_{1} * \\Delta{P_{1}}}{d + s_{1} * \\Delta{d_{1}}}$, and `NICR` of $CDP_{2}$ is $\\frac{c}{d + s_{2} * \\Delta{d_{1}}}$, let us prove that their NICR ratio  still keep the ordering:\n> \n> $ratio_{NICR} = \\frac{c - s_{1} * \\Delta{P_{1}}}{c} * \\frac{d + s_{2} * \\Delta{d_{1}}}{d + s_{1} * \\Delta{d_{1}}} = \\frac{s_{1}}{s_{2}} * \\frac{d + s_{2} * \\Delta{d_{1}}}{d + s_{1} * \\Delta{d_{1}}} = \\frac{s_{1} * s_{2} * \\Delta{d_{1}} + s_{1} * d}{s_{1} * s_{2} * \\Delta{d_{1}} + s_{2} * d} \\lt 1$ \n> \n> Proved\n> \n> So the whole story would be: \n> - Split fee distribution would keep the NICR ratio the **same**\n> - Bad debt redistribution would change the NICR ratio a bit but still **remain the ordering**\n\n**[ronnyx2017 (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-badger-findings/issues/155#issuecomment-1839732287):**\n > The impact based on bad debt redistribution is valid, but it can't break the cdp order. Considering the fixes already introduced in Liquity, I suggest considering the impact of this issue in long-running systems. Therefore, I mark this issue as medium. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/CdpManagerStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Interfaces/ICdpManager.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IEBTCToken.sol\";\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Dependencies/EbtcBase.sol\";\nimport \"./Dependencies/ReentrancyGuard.sol\";\nimport \"./Dependencies/ICollateralTokenOracle.sol\";\nimport \"./Dependencies/AuthNoOwner.sol\";\n\n/// @title CDP Manager storage and shared functions with LiquidationLibrary\n/// @dev All features around Cdp management are split into separate parts to get around contract size limitations.\n/// @dev Liquidation related functions are delegated to LiquidationLibrary contract code.\n/// @dev Both CdpManager and LiquidationLibrary must maintain **the same storage layout**, so shared storage components\n/// @dev and shared functions are added here in CdpManagerStorage to de-dup code\ncontract CdpManagerStorage is EbtcBase, ReentrancyGuard, ICdpManagerData, AuthNoOwner {\n    // NOTE: No packing cause it's the last var, no need for u64\n    uint128 public constant UNSET_TIMESTAMP = type(uint128).max;\n    uint128 public constant MINIMUM_GRACE_PERIOD = 15 minutes;\n\n    uint128 public lastGracePeriodStartTimestamp = UNSET_TIMESTAMP; // use max to signify\n    uint128 public recoveryModeGracePeriodDuration = MINIMUM_GRACE_PERIOD;\n\n    /// @notice Start the recovery mode grace period, if the system is in RM and the grace period timestamp has not already been set\n    /// @dev Trusted function to allow BorrowerOperations actions to set RM Grace Period\n    /// @dev Assumes BorrowerOperations has correctly calculated and passed in the new system TCR\n    /// @dev To maintain CEI compliance we use this trusted function\n    /// @param tcr The TCR to be checked whether Grace Period should be started\n    function notifyStartGracePeriod(uint256 tcr) external {\n        _requireCallerIsBorrowerOperations();\n        _startGracePeriod(tcr);\n    }\n\n    /// @notice End the recovery mode grace period, if the system is no longer in RM\n    /// @dev Trusted function to allow BorrowerOperations actions to set RM Grace Period\n    /// @dev Assumes BorrowerOperations has correctly calculated and passed in the new system TCR\n    /// @dev To maintain CEI compliance we use this trusted function\n    /// @param tcr The TCR to be checked whether Grace Period should be ended\n    function notifyEndGracePeriod(uint256 tcr) external {\n        _requireCallerIsBorrowerOperations();\n        _endGracePeriod(tcr);\n    }\n\n    /// @dev Internal notify called by Redemptions and Liquidations\n    /// @dev Specified TCR is emitted for notification pruposes regardless of whether the Grace Period timestamp is set\n    function _startGracePeriod(uint256 _tcr) internal {\n        emit TCRNotified(_tcr);\n\n        if (lastGracePeriodStartTimestamp == UNSET_TIMESTAMP) {\n            lastGracePeriodStartTimestamp = uint128(block.timestamp);\n\n            emit GracePeriodStart();\n        }\n    }\n\n    /// @notice Clear RM Grace Period timestamp if it has been set\n    /// @notice No input validation, calling function must confirm that the system is not in recovery mode to be valid\n    /// @dev Specified TCR is emitted for notification pruposes regardless of whether the Grace Period timestamp is set\n    /// @dev Internal notify called by Redemptions and Liquidations\n    function _endGracePeriod(uint256 _tcr) internal {\n        emit TCRNotified(_tcr);\n\n        if (lastGracePeriodStartTimestamp != UNSET_TIMESTAMP) {\n            lastGracePeriodStartTimestamp = UNSET_TIMESTAMP;\n\n            emit GracePeriodEnd();\n        }\n    }\n\n    function _syncGracePeriod() internal {\n        uint256 price = priceFeed.fetchPrice();\n        uint256 tcr = _getCachedTCR(price);\n        bool isRecoveryMode = _checkRecoveryModeForTCR(tcr);\n\n        if (isRecoveryMode) {\n            _startGracePeriod(tcr);\n        } else {\n            _endGracePeriod(tcr);\n        }\n    }\n\n    /// @dev Set RM grace period based on specified system collShares, system debt, and price\n    /// @dev Variant for internal use in redemptions and liquidations\n    function _syncGracePeriodForGivenValues(\n        uint256 systemCollShares,\n        uint256 systemDebt,\n        uint256 price\n    ) internal {\n        // Compute TCR with specified values\n        uint256 newTCR = EbtcMath._computeCR(\n            collateral.getPooledEthByShares(systemCollShares),\n            systemDebt,\n            price\n        );\n\n        if (newTCR < CCR) {\n            // Notify system is in RM\n            _startGracePeriod(newTCR);\n        } else {\n            // Notify system is outside RM\n            _endGracePeriod(newTCR);\n        }\n    }\n\n    /// @notice Set grace period duratin\n    /// @notice Permissioned governance function, must set grace period duration above hardcoded minimum\n    /// @param _gracePeriod new grace period duration, in seconds\n    function setGracePeriod(uint128 _gracePeriod) external requiresAuth {\n        require(\n            _gracePeriod >= MINIMUM_GRACE_PERIOD,\n            \"CdpManager: Grace period below minimum duration\"\n        );\n\n        syncGlobalAccountingAndGracePeriod();\n        recoveryModeGracePeriodDuration = _gracePeriod;\n        emit GracePeriodDurationSet(_gracePeriod);\n    }\n\n    string public constant NAME = \"CdpManager\";\n\n    // --- Connected contract declarations ---\n\n    address public immutable borrowerOperationsAddress;\n\n    ICollSurplusPool immutable collSurplusPool;\n\n    IEBTCToken public immutable override ebtcToken;\n\n    address public immutable liquidationLibrary;\n\n    // A doubly linked list of Cdps, sorted by their sorted by their collateral ratios\n    ISortedCdps public immutable sortedCdps;\n\n    // --- Data structures ---\n\n    uint256 public constant SECONDS_IN_ONE_MINUTE = 60;\n\n    uint256 public constant MIN_REDEMPTION_FEE_FLOOR = (DECIMAL_PRECISION * 5) / 1000; // 0.5%\n    uint256 public redemptionFeeFloor = MIN_REDEMPTION_FEE_FLOOR;\n    bool public redemptionsPaused;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint256 public minuteDecayFactor = 999037758833783000;\n    uint256 public constant MIN_MINUTE_DECAY_FACTOR = 1; // Non-zero\n    uint256 public constant MAX_MINUTE_DECAY_FACTOR = 999999999999999999; // Corresponds to a very fast decay rate, but not too extreme\n\n    uint256 internal immutable deploymentStartTime;\n\n    /*\n     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction,\n     * in order to calc the new base rate from a redemption.\n     * Corresponds to (1 / ALPHA) in the Liquity white paper.\n     */\n    uint256 public beta = 2;\n\n    uint256 public baseRate;\n\n    uint256 public stakingRewardSplit;\n\n    // The timestamp of the latest fee operation (redemption or new EBTC issuance)\n    uint256 public lastRedemptionTimestamp;\n\n    mapping(bytes32 => Cdp) public Cdps;\n\n    uint256 public override totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation and split fee claim\n    uint256 public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool, immediately after the latest liquidation and split fee claim\n    uint256 public totalCollateralSnapshot;\n\n    /*\n     * systemDebtRedistributionIndex track the sums of accumulated socialized liquidations per unit staked.\n     * During its lifetime, each stake earns:\n     *\n     * A systemDebt increase  of ( stake * [systemDebtRedistributionIndex - systemDebtRedistributionIndex(0)] )\n     *\n     * Where systemDebtRedistributionIndex(0) are snapshots of systemDebtRedistributionIndex\n     * for the active Cdp taken at the instant the stake was made\n     */\n    uint256 public systemDebtRedistributionIndex;\n\n    // Map active cdps to their RewardSnapshot (eBTC debt redistributed)\n    mapping(bytes32 => uint256) public cdpDebtRedistributionIndex;\n\n    // Error trackers for the cdp redistribution calculation\n    uint256 public lastEBTCDebtErrorRedistribution;\n\n    /* Global Index for (Full Price Per Share) of underlying collateral token */\n    uint256 public override stEthIndex;\n    /* Global Fee accumulator (never decreasing) per stake unit in CDPManager, similar to systemDebtRedistributionIndex */\n    uint256 public override systemStEthFeePerUnitIndex;\n    /* Global Fee accumulator calculation error due to integer division, similar to redistribution calculation */\n    uint256 public override systemStEthFeePerUnitIndexError;\n    /* Individual CDP Fee accumulator tracker, used to calculate fee split distribution */\n    mapping(bytes32 => uint256) public cdpStEthFeePerUnitIndex;\n\n    // Array of all active cdp Ids - used to to compute an approximate hint off-chain, for the sorted list insertion\n    bytes32[] public CdpIds;\n\n    /// @notice Initializes the contract with the provided addresses and sets up the required initial state\n    /// @param _liquidationLibraryAddress The address of the Liquidation Library\n    /// @param _authorityAddress The address of the Authority\n    /// @param _borrowerOperationsAddress The address of Borrower Operations\n    /// @param _collSurplusPool The address of the Collateral Surplus Pool\n    /// @param _ebtcToken The address of the eBTC Token contract\n    /// @param _sortedCdps The address of the Sorted CDPs contract\n    /// @param _activePool The address of the Active Pool\n    /// @param _priceFeed The address of the Price Feed\n    /// @param _collateral The address of the Collateral token\n    constructor(\n        address _liquidationLibraryAddress,\n        address _authorityAddress,\n        address _borrowerOperationsAddress,\n        address _collSurplusPool,\n        address _ebtcToken,\n        address _sortedCdps,\n        address _activePool,\n        address _priceFeed,\n        address _collateral\n    ) EbtcBase(_activePool, _priceFeed, _collateral) {\n        deploymentStartTime = block.timestamp;\n        liquidationLibrary = _liquidationLibraryAddress;\n\n        _initializeAuthority(_authorityAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPool);\n        ebtcToken = IEBTCToken(_ebtcToken);\n        sortedCdps = ISortedCdps(_sortedCdps);\n    }\n\n    /// @notice BorrowerOperations and CdpManager share reentrancy status by confirming the other's locked flag before beginning operation\n    /// @dev This is an alternative to the more heavyweight solution of both being able to set the reentrancy flag on a 3rd contract.\n    modifier nonReentrantSelfAndBOps() {\n        require(locked == OPEN, \"CdpManager: Reentrancy in nonReentrant call\");\n        require(\n            ReentrancyGuard(borrowerOperationsAddress).locked() == OPEN,\n            \"BorrowerOperations: Reentrancy in nonReentrant call\"\n        );\n\n        locked = LOCKED;\n\n        _;\n\n        locked = OPEN;\n    }\n\n    function _closeCdp(bytes32 _cdpId, Status closedStatus) internal {\n        _closeCdpWithoutRemovingSortedCdps(_cdpId, closedStatus);\n        sortedCdps.remove(_cdpId);\n    }\n\n    function _closeCdpWithoutRemovingSortedCdps(bytes32 _cdpId, Status closedStatus) internal {\n        require(\n            closedStatus != Status.nonExistent && closedStatus != Status.active,\n            \"CdpManagerStorage: close non-exist or non-active CDP!\"\n        );\n\n        uint256 cdpIdsArrayLength = CdpIds.length;\n        _requireMoreThanOneCdpInSystem(cdpIdsArrayLength);\n\n        _removeStake(_cdpId);\n\n        Cdps[_cdpId].status = closedStatus;\n        Cdps[_cdpId].coll = 0;\n        Cdps[_cdpId].debt = 0;\n        Cdps[_cdpId].liquidatorRewardShares = 0;\n\n        cdpDebtRedistributionIndex[_cdpId] = 0;\n        cdpStEthFeePerUnitIndex[_cdpId] = 0;\n\n        _removeCdp(_cdpId, cdpIdsArrayLength);\n    }\n\n    /*\n     * Updates snapshots of system total stakes and total collateral,\n     * excluding a given collateral remainder from the calculation.\n     * Used in a liquidation sequence.\n     *\n     * The calculation excludes a portion of collateral that is in the ActivePool:\n     *\n     * the total stETH liquidator reward compensation from the liquidation sequence\n     *\n     * The stETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n     */\n    function _updateSystemSnapshotsExcludeCollRemainder(uint256 _collRemainder) internal {\n        uint256 _totalStakesSnapshot = totalStakes;\n        totalStakesSnapshot = _totalStakesSnapshot;\n\n        uint256 _totalCollateralSnapshot = activePool.getSystemCollShares() - _collRemainder;\n        totalCollateralSnapshot = _totalCollateralSnapshot;\n\n        emit SystemSnapshotsUpdated(_totalStakesSnapshot, _totalCollateralSnapshot);\n    }\n\n    /// @dev get the pending Cdp debt \"reward\" (i.e. the amount of extra debt assigned to the Cdp) from liquidation redistribution events, earned by their stake\n    function _getPendingRedistributedDebt(\n        bytes32 _cdpId\n    ) internal view returns (uint256 pendingEBTCDebtReward, uint256 _debtIndexDiff) {\n        Cdp storage cdp = Cdps[_cdpId];\n\n        if (cdp.status != Status.active) {\n            return (0, 0);\n        }\n\n        _debtIndexDiff = systemDebtRedistributionIndex - cdpDebtRedistributionIndex[_cdpId];\n\n        if (_debtIndexDiff > 0) {\n            pendingEBTCDebtReward = (cdp.stake * _debtIndexDiff) / DECIMAL_PRECISION;\n        } else {\n            return (0, 0);\n        }\n    }\n\n    /*\n     * A Cdp has pending redistributed debt if its snapshot is less than the current rewards per-unit-staked sum:\n     * this indicates that redistributions have occured since the snapshot was made, and the user therefore has\n     * pending debt\n     */\n    function _hasRedistributedDebt(bytes32 _cdpId) internal view returns (bool) {\n        if (Cdps[_cdpId].status != Status.active) {\n            return false;\n        }\n\n        return (cdpDebtRedistributionIndex[_cdpId] < systemDebtRedistributionIndex);\n    }\n\n    /// @dev Sync Cdp debt redistribution index to global value\n    function _updateRedistributedDebtIndex(bytes32 _cdpId) internal {\n        uint256 _systemDebtRedistributionIndex = systemDebtRedistributionIndex;\n\n        cdpDebtRedistributionIndex[_cdpId] = _systemDebtRedistributionIndex;\n        emit CdpDebtRedistributionIndexUpdated(_cdpId, _systemDebtRedistributionIndex);\n    }\n\n    /// @dev Calculate the new collateral and debt values for a given CDP, based on pending state changes\n    function _syncAccounting(bytes32 _cdpId) internal {\n        // Ensure global states like systemStEthFeePerUnitIndex get updated in a timely fashion\n        // whenever there is a CDP modification operation,\n        // such as opening, closing, adding collateral, repaying debt, or liquidating\n        _syncGlobalAccounting();\n\n        uint256 _oldPerUnitCdp = cdpStEthFeePerUnitIndex[_cdpId];\n        uint256 _systemStEthFeePerUnitIndex = systemStEthFeePerUnitIndex;\n\n        (\n            uint256 _newColl,\n            uint256 _newDebt,\n            uint256 _feeSplitDistributed,\n            uint _pendingDebt,\n            uint256 _debtIndexDelta\n        ) = _calcSyncedAccounting(_cdpId, _oldPerUnitCdp, _systemStEthFeePerUnitIndex);\n\n        // If any collShares or debt changes occured\n        if (_feeSplitDistributed > 0 || _debtIndexDelta > 0) {\n            Cdp storage _cdp = Cdps[_cdpId];\n\n            uint prevCollShares = _cdp.coll;\n            uint256 prevDebt = _cdp.debt;\n\n            // Apply Fee Split\n            if (_feeSplitDistributed > 0) {\n                _applyAccumulatedFeeSplit(\n                    _cdpId,\n                    _newColl,\n                    _feeSplitDistributed,\n                    _oldPerUnitCdp,\n                    _systemStEthFeePerUnitIndex\n                );\n            }\n\n            // Apply Debt Redistribution\n            if (_debtIndexDelta > 0) {\n                _updateRedistributedDebtIndex(_cdpId);\n\n                if (prevDebt != _newDebt) {\n                    {\n                        // Apply pending debt redistribution to this CDP\n                        _cdp.debt = _newDebt;\n                    }\n                }\n            }\n            emit CdpUpdated(\n                _cdpId,\n                ISortedCdps(sortedCdps).getOwnerAddress(_cdpId),\n                msg.sender,\n                prevDebt,\n                prevCollShares,\n                _newDebt,\n                _newColl,\n                _cdp.stake,\n                CdpOperation.syncAccounting\n            );\n        }\n\n        // sync per stake index for given CDP\n        if (_oldPerUnitCdp != _systemStEthFeePerUnitIndex) {\n            cdpStEthFeePerUnitIndex[_cdpId] = _systemStEthFeePerUnitIndex;\n        }\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(bytes32 _cdpId) internal {\n        uint256 _newTotalStakes = totalStakes - Cdps[_cdpId].stake;\n        totalStakes = _newTotalStakes;\n        Cdps[_cdpId].stake = 0;\n        emit TotalStakesUpdated(_newTotalStakes);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    // and update totalStakes accordingly as well\n    function _updateStakeAndTotalStakes(bytes32 _cdpId) internal returns (uint256) {\n        (uint256 newStake, uint256 oldStake) = _updateStakeForCdp(_cdpId);\n\n        uint256 _newTotalStakes = totalStakes + newStake - oldStake;\n        totalStakes = _newTotalStakes;\n\n        emit TotalStakesUpdated(_newTotalStakes);\n\n        return newStake;\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeForCdp(bytes32 _cdpId) internal returns (uint256, uint256) {\n        Cdp storage _cdp = Cdps[_cdpId];\n        uint256 newStake = _computeNewStake(_cdp.coll);\n        uint256 oldStake = _cdp.stake;\n        _cdp.stake = newStake;\n\n        return (newStake, oldStake);\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint256 _coll) internal view returns (uint256) {\n        uint256 stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n             * The following check holds true because:\n             * - The system always contains >= 1 cdp\n             * - When we close or liquidate a cdp, we redistribute the pending rewards,\n             * so if all cdps were closed/liquidated,\n             * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n             */\n            require(totalStakesSnapshot > 0, \"CdpManagerStorage: zero totalStakesSnapshot!\");\n            stake = (_coll * totalStakesSnapshot) / totalCollateralSnapshot;\n        }\n        return stake;\n    }\n\n    /*\n     * Remove a Cdp owner from the CdpOwners array, not preserving array order. Removing owner 'B' does the following:\n     * [A B C D E] => [A E C D], and updates E's Cdp struct to point to its new array index.\n     */\n    function _removeCdp(bytes32 _cdpId, uint256 cdpIdsArrayLength) internal {\n        Status cdpStatus = Cdps[_cdpId].status;\n        // It’s set in caller function `_closeCdp`\n        require(\n            cdpStatus != Status.nonExistent && cdpStatus != Status.active,\n            \"CdpManagerStorage: remove non-exist or non-active CDP!\"\n        );\n\n        uint128 index = Cdps[_cdpId].arrayIndex;\n        uint256 length = cdpIdsArrayLength;\n        uint256 idxLast = length - 1;\n\n        require(index <= idxLast, \"CdpManagerStorage: CDP indexing overflow!\");\n\n        bytes32 idToMove = CdpIds[idxLast];\n\n        CdpIds[index] = idToMove;\n        Cdps[idToMove].arrayIndex = index;\n        emit CdpArrayIndexUpdated(idToMove, index);\n\n        CdpIds.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    // Calculate TCR given an price, and the entire system coll and debt.\n    function _computeTCRWithGivenSystemValues(\n        uint256 _systemCollShares,\n        uint256 _systemDebt,\n        uint256 _price\n    ) internal view returns (uint256) {\n        uint256 _totalColl = collateral.getPooledEthByShares(_systemCollShares);\n        return EbtcMath._computeCR(_totalColl, _systemDebt, _price);\n    }\n\n    // --- Staking-Reward Fee split functions ---\n\n    /// @notice Claim split fee if there is staking-reward coming\n    /// @notice and update global index & fee-per-unit variables\n    /// @dev only BorrowerOperations is allowed to call this\n    /// @dev otherwise use syncGlobalAccountingAndGracePeriod()\n    function syncGlobalAccounting() external {\n        _requireCallerIsBorrowerOperations();\n        _syncGlobalAccounting();\n    }\n\n    function _syncGlobalAccounting() internal {\n        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();\n        _syncStEthIndex(_oldIndex, _newIndex);\n        if (_newIndex > _oldIndex && totalStakes > 0) {\n            (\n                uint256 _feeTaken,\n                uint256 _newFeePerUnit,\n                uint256 _perUnitError\n            ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);\n            _takeSplitAndUpdateFeePerUnit(_feeTaken, _newFeePerUnit, _perUnitError);\n            _updateSystemSnapshotsExcludeCollRemainder(0);\n        }\n    }\n\n    /// @notice Claim fee split, if there is staking-reward coming\n    /// @notice and update global index & fee-per-unit variables\n    /// @notice and toggles Grace Period accordingly.\n    /// @dev Call this if you want to help eBTC system to accrue split fee\n    function syncGlobalAccountingAndGracePeriod() public {\n        _syncGlobalAccounting(); // Apply // Could trigger RM\n        _syncGracePeriod(); // Synch Grace Period\n    }\n\n    /// @return existing(old) local stETH index AND\n    /// @return current(new) stETH index from collateral token\n    function _readStEthIndex() internal view returns (uint256, uint256) {\n        return (stEthIndex, collateral.getPooledEthByShares(DECIMAL_PRECISION));\n    }\n\n    // Update the global index via collateral token\n    function _syncStEthIndex(uint256 _oldIndex, uint256 _newIndex) internal {\n        if (_newIndex != _oldIndex) {\n            stEthIndex = _newIndex;\n            emit StEthIndexUpdated(_oldIndex, _newIndex, block.timestamp);\n        }\n    }\n\n    /// @notice Calculate fee for given pair of collateral indexes\n    /// @param _newIndex The value synced with stETH.getPooledEthByShares(1e18)\n    /// @param _prevIndex The cached global value of `stEthIndex`\n    /// @return _feeTaken The fee split in collateral token which will be deduced from current total system collateral\n    /// @return _deltaFeePerUnit The fee split increase per unit, used to added to `systemStEthFeePerUnitIndex`\n    /// @return _perUnitError The fee split calculation error, used to update `systemStEthFeePerUnitIndexError`\n    function calcFeeUponStakingReward(\n        uint256 _newIndex,\n        uint256 _prevIndex\n    ) public view returns (uint256, uint256, uint256) {\n        require(_newIndex > _prevIndex, \"CDPManager: only take fee with bigger new index\");\n        uint256 deltaIndex = _newIndex - _prevIndex;\n        uint256 deltaIndexFees = (deltaIndex * stakingRewardSplit) / MAX_REWARD_SPLIT;\n\n        // we take the fee for all CDPs immediately which is scaled by index precision\n        uint256 _deltaFeeSplit = deltaIndexFees * getSystemCollShares();\n        uint256 _cachedAllStakes = totalStakes;\n        // return the values to update the global fee accumulator\n        uint256 _feeTaken = collateral.getSharesByPooledEth(_deltaFeeSplit) / DECIMAL_PRECISION;\n        uint256 _deltaFeeSplitShare = (_feeTaken * DECIMAL_PRECISION) +\n            systemStEthFeePerUnitIndexError;\n        uint256 _deltaFeePerUnit = _deltaFeeSplitShare / _cachedAllStakes;\n        uint256 _perUnitError = _deltaFeeSplitShare - (_deltaFeePerUnit * _cachedAllStakes);\n        return (_feeTaken, _deltaFeePerUnit, _perUnitError);\n    }\n\n    // Take the cut from staking reward\n    // and update global fee-per-unit accumulator\n    function _takeSplitAndUpdateFeePerUnit(\n        uint256 _feeTaken,\n        uint256 _newPerUnit,\n        uint256 _newErrorPerUnit\n    ) internal {\n        uint256 _oldPerUnit = systemStEthFeePerUnitIndex;\n\n        systemStEthFeePerUnitIndex = _newPerUnit;\n        systemStEthFeePerUnitIndexError = _newErrorPerUnit;\n\n        require(activePool.getSystemCollShares() > _feeTaken, \"CDPManager: fee split is too big\");\n        activePool.allocateSystemCollSharesToFeeRecipient(_feeTaken);\n\n        emit CollateralFeePerUnitUpdated(_oldPerUnit, _newPerUnit, _feeTaken);\n    }\n\n    // Apply accumulated fee split distributed to the CDP\n    // and update its accumulator tracker accordingly\n    function _applyAccumulatedFeeSplit(\n        bytes32 _cdpId,\n        uint256 _newColl,\n        uint256 _feeSplitDistributed,\n        uint256 _oldPerUnitCdp,\n        uint256 _systemStEthFeePerUnitIndex\n    ) internal {\n        // apply split fee to given CDP\n        Cdps[_cdpId].coll = _newColl;\n\n        emit CdpFeeSplitApplied(\n            _cdpId,\n            _oldPerUnitCdp,\n            _systemStEthFeePerUnitIndex,\n            _feeSplitDistributed,\n            _newColl\n        );\n    }\n\n    /// @notice Calculate the applied split fee(scaled by 1e18) and the resulting CDP collateral share after applied\n    /// @param _cdpId The Cdp to which the calculated split fee is going to be applied\n    /// @param _systemStEthFeePerUnitIndex The fee-per-stake-unit value to be used in fee split calculation, could be result of calcFeeUponStakingReward()\n    /// @return _feeSplitDistributed The applied fee split to the specified Cdp (scaled up by 1e18)\n    /// @return _cdpCol The new collateral share of the specified Cdp after fe split applied\n    function getAccumulatedFeeSplitApplied(\n        bytes32 _cdpId,\n        uint256 _systemStEthFeePerUnitIndex\n    ) public view returns (uint256, uint256) {\n        uint256 _cdpStEthFeePerUnitIndex = cdpStEthFeePerUnitIndex[_cdpId];\n        uint256 _cdpCol = Cdps[_cdpId].coll;\n\n        if (\n            _cdpStEthFeePerUnitIndex == 0 ||\n            _cdpCol == 0 ||\n            _cdpStEthFeePerUnitIndex == _systemStEthFeePerUnitIndex\n        ) {\n            return (0, _cdpCol);\n        }\n\n        uint256 _feeSplitDistributed = Cdps[_cdpId].stake *\n            (_systemStEthFeePerUnitIndex - _cdpStEthFeePerUnitIndex);\n\n        uint256 _scaledCdpColl = _cdpCol * DECIMAL_PRECISION;\n\n        if (_scaledCdpColl > _feeSplitDistributed) {\n            return (\n                _feeSplitDistributed,\n                (_scaledCdpColl - _feeSplitDistributed) / DECIMAL_PRECISION\n            );\n        } else {\n            // extreme unlikely case to skip fee split on this CDP to avoid revert\n            return (0, _cdpCol);\n        }\n    }\n\n    // -- Modifier functions --\n    function _requireCdpIsActive(bytes32 _cdpId) internal view {\n        require(Cdps[_cdpId].status == Status.active, \"CdpManager: Cdp does not exist or is closed\");\n    }\n\n    function _requireMoreThanOneCdpInSystem(uint256 CdpOwnersArrayLength) internal view {\n        require(\n            CdpOwnersArrayLength > 1 && sortedCdps.getSize() > 1,\n            \"CdpManager: Only one cdp in the system\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"CdpManager: Caller is not the BorrowerOperations contract\"\n        );\n    }\n\n    // --- Helper functions ---\n\n    /// @notice Return the Nominal Collateral Ratio (NICR) of the specified Cdp as \"cached view\" (maybe outdated).\n    /// @dev Takes a cdp's pending coll and debt rewards from redistributions into account.\n    /// @param _cdpId The CdpId whose NICR to be queried\n    /// @return The Nominal Collateral Ratio (NICR) of the specified Cdp.\n    /// @dev Use getSyncedNominalICR() instead if pending fee split and debt redistribution should be considered\n    function getCachedNominalICR(bytes32 _cdpId) external view returns (uint256) {\n        (uint256 currentEBTCDebt, uint256 currentCollShares) = getSyncedDebtAndCollShares(_cdpId);\n\n        uint256 NICR = EbtcMath._computeNominalCR(currentCollShares, currentEBTCDebt);\n        return NICR;\n    }\n\n    /// @notice Return the Nominal Collateral Ratio (NICR) of the specified Cdp.\n    /// @dev Takes a cdp's pending coll and debt rewards as well as stETH Index into account.\n    /// @param _cdpId The CdpId whose NICR to be queried\n    /// @return The Nominal Collateral Ratio (NICR) of the specified Cdp with fee split and debt redistribution considered.\n    function getSyncedNominalICR(bytes32 _cdpId) external view returns (uint256) {\n        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();\n        (, uint256 _newGlobalSplitIdx, ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);\n        (uint256 _newColl, uint256 _newDebt, , uint256 _pendingDebt, ) = _calcSyncedAccounting(\n            _cdpId,\n            cdpStEthFeePerUnitIndex[_cdpId],\n            _newGlobalSplitIdx /// NOTE: This is latest index\n        );\n\n        uint256 NICR = EbtcMath._computeNominalCR(_newColl, _newDebt);\n        return NICR;\n    }\n\n    /// @notice Return the Individual Collateral Ratio (ICR) of the specified Cdp as \"cached view\" (maybe outdated).\n    /// @param _cdpId The CdpId whose ICR to be queried\n    /// @return The Individual Collateral Ratio (ICR) of the specified Cdp.\n    /// @dev Use getSyncedICR() instead if pending fee split and debt redistribution should be considered\n    function getCachedICR(bytes32 _cdpId, uint256 _price) public view returns (uint256) {\n        (uint256 currentEBTCDebt, uint256 currentCollShares) = getSyncedDebtAndCollShares(_cdpId);\n        uint256 ICR = _calculateCR(currentCollShares, currentEBTCDebt, _price);\n        return ICR;\n    }\n\n    function _calculateCR(\n        uint256 currentCollShare,\n        uint256 currentDebt,\n        uint256 _price\n    ) internal view returns (uint256) {\n        uint256 _underlyingCollateral = collateral.getPooledEthByShares(currentCollShare);\n        return EbtcMath._computeCR(_underlyingCollateral, currentDebt, _price);\n    }\n\n    /// @notice Return the pending extra debt assigned to the Cdp from liquidation redistribution, calcualted by Cdp's stake\n    /// @param _cdpId The CdpId whose pending debt redistribution to be queried\n    /// @return pendingEBTCDebtReward The pending debt redistribution of the specified Cdp.\n    function getPendingRedistributedDebt(\n        bytes32 _cdpId\n    ) public view returns (uint256 pendingEBTCDebtReward) {\n        (uint256 _pendingDebt, ) = _getPendingRedistributedDebt(_cdpId);\n        return _pendingDebt;\n    }\n\n    /// @return Whether the debt redistribution tracking index of the specified Cdp is less than the global tracking one (meaning it might get pending debt redistribution)\n    /// @param _cdpId The CdpId whose debt redistribution tracking index to be queried against the gloabl one\n    function hasPendingRedistributedDebt(bytes32 _cdpId) public view returns (bool) {\n        return _hasRedistributedDebt(_cdpId);\n    }\n\n    // Return the Cdps entire debt and coll struct\n    function _getSyncedDebtAndCollShares(\n        bytes32 _cdpId\n    ) internal view returns (CdpDebtAndCollShares memory) {\n        (uint256 entireDebt, uint256 entireColl) = getSyncedDebtAndCollShares(_cdpId);\n        return CdpDebtAndCollShares(entireDebt, entireColl);\n    }\n\n    /// @notice Calculate the Cdps entire debt and coll, including pending debt redistributions and collateral reduction from split fee.\n    /// @param _cdpId The CdpId to be queried\n    /// @return debt The total debt value of the Cdp including debt redistribution considered\n    /// @return coll The total collateral value of the Cdp including possible fee split considered\n    /// @dev Should always use this as the first(default) choice for Cdp position size query\n    function getSyncedDebtAndCollShares(\n        bytes32 _cdpId\n    ) public view returns (uint256 debt, uint256 coll) {\n        (uint256 _newColl, uint256 _newDebt, , , ) = _calcSyncedAccounting(\n            _cdpId,\n            cdpStEthFeePerUnitIndex[_cdpId],\n            systemStEthFeePerUnitIndex\n        );\n        coll = _newColl;\n        debt = _newDebt;\n    }\n\n    /// @dev calculate pending global state change to be applied:\n    /// @return split fee taken (if any) AND\n    /// @return new split index per stake unit AND\n    /// @return new split index error\n    function _calcSyncedGlobalAccounting(\n        uint256 _newIndex,\n        uint256 _oldIndex\n    ) internal view returns (uint256, uint256, uint256) {\n        if (_newIndex > _oldIndex && totalStakes > 0) {\n            /// @audit-ok We don't"
    }
  ]
}