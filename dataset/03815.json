{
  "Title": "[L07] Unneeded public visibility in some functions",
  "Content": "In [the Holdefi codebase](https://github.com/holdefi/Holdefi/tree/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts), there are situations in which functions have a public visibility although those are not called by any other function from the same contract. Some of them are:\n\n\n* In the `HoldefiPrices` contract, [the `addStableCoin` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPrices.sol#L47)\n* In the `HoldefiPauser` contract, [the `batchPause`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L65) and [the `batchUnpause`](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiPauser.sol#L74) functions\n* In the `HoldefiSettings` contract, [the `getMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L120). This function returns true if a certain market is whitelisted, but this information can be known by using [the `marketAssets` getter](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63)\n\n\nTo favor readability and to reduce the attack surface, consider reducing the visibility of these functions and any similar case to `external`, and consider reducing the visibility of [the `marketAssets` variable](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L63) if [the `getMarket` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L120) is not removed from the codebase.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/HoldefiPrices.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ninterface ETHMedianizerInterface {\r\n\r\n   function read() external view returns(uint price);\r\n}\r\n\r\n //This contract will be changed before adding ERC20 tokens that are not stable coin\r\ncontract HoldefiPrices is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint constant public priceDecimal = 10**18;\r\n   \r\n    mapping(address => uint) public assetPrices;\r\n\r\n    ETHMedianizerInterface public ethMedianizer;\r\n\r\n    event PriceChanged(address asset, uint newPrice);\r\n\r\n    constructor(address newOwnerChanger, ETHMedianizerInterface ethMedianizerContract) public Ownable(newOwnerChanger) {\r\n        ethMedianizer = ethMedianizerContract;\r\n    }\r\n\r\n    // Returns price of selected asset\r\n    function getPrice(address asset) external view returns(uint price) {\r\n    \tif (asset == address(0)){\r\n    \t\tprice = uint(ethMedianizer.read());\r\n    \t}\r\n        else {\r\n            price = assetPrices[asset];\r\n        }\r\n    }\r\n\r\n     // TODO: This function should be internal for the first version of priceFeed\r\n    function setPrice(address asset, uint newPrice) public onlyOwner {\r\n        require (asset != address(0),'Price of ETH can not be changed');\r\n\r\n        assetPrices[asset] = newPrice;\r\n        emit PriceChanged(asset, newPrice);\r\n    }\r\n\r\n    // Called by owner to add new stable token at 1$ price\r\n    function addStableCoin(address asset) public onlyOwner {\r\n        setPrice(asset, priceDecimal);\r\n    }\r\n    \r\n    function() payable external {\r\n        revert();\r\n    }\r\n}"
    },
    {
      "filename": "contracts/HoldefiPauser.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n// Taking ideas from Open Zeppelin's Pausable contract\r\ncontract HoldefiPauser is Ownable {    \r\n    address public pauser;\r\n\r\n     // '0' -> supply\r\n     // '1' -> withdrawSupply\r\n     // '2' -> collatralize\r\n     // '3' -> withdrawCollateral\r\n     // '4' -> borrow\r\n     // '5' -> repayBorrrow\r\n     // '6' -> liquidateBorrowerCollateral\r\n     // '7' -> buyLiquidatedCollateral\r\n    \r\n    uint constant functionsNum = 8;\r\n    uint[8] public paused;\r\n\r\n    uint public pauseDuration = 2592000;\r\n\r\n     \r\n    constructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n    }\r\n\r\n    // Modifier to make a function callable only by owner or pauser   \r\n    modifier onlyPausers() {\r\n        require(msg.sender == owner || msg.sender == pauser , 'Sender should be Owner or Pauser');\r\n        _;\r\n    }\r\n    \r\n    // Modifier to make a function callable only when a functions is not paused.\r\n    modifier whenNotPaused(uint index) {\r\n        require(!isPause(index), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to make a function callable only when a functions is paused.\r\n    modifier whenPaused(uint index) {\r\n        require(isPause(index), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function isPause(uint index) public view returns(bool res) {\r\n        if (block.timestamp - paused[index] >= pauseDuration) {\r\n            res = false;\r\n        }\r\n        else {\r\n            res = true;\r\n        }\r\n    }\r\n    \r\n    // Called by pausers to pause, triggers stopped state.\r\n    function pause(uint index) public onlyPausers {\r\n        paused[index] = block.timestamp;\r\n    }\r\n\r\n    // Called by owner to unpause, returns to normal state.\r\n    function unpause(uint index) public onlyOwner {\r\n        paused[index] = 0;\r\n    }\r\n\r\n    // Called by pausers to pause, triggers stopped state for selected functions\r\n    function batchPause(bool[8] memory newPaused) public onlyPausers {\r\n        for (uint i=0; i<functionsNum; i++) {\r\n            if (newPaused[i] == true){\r\n                pause(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Called by pausers to pause, returns to normal state for selected functions\r\n    function batchUnpause(bool[8] memory newUnpaused) public onlyOwner {\r\n        for (uint i=0; i<functionsNum; i++) {\r\n            if (newUnpaused[i] == true){\r\n                unpause(i);\r\n            }\r\n        }\r\n    }\r\n    // Called by owner to set a new pauser\r\n    function setPauser(address newPauser) external onlyOwner {\r\n        pauser = newPauser;\r\n    }\r\n\r\n    function setPauseDuration(uint newPauseDuration) external onlyOwner {\r\n        pauseDuration = newPauseDuration;\r\n    }\r\n}"
    },
    {
      "filename": "contracts/HoldefiSettings.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n\r\ninterface HoldefiInterface {\r\n\r\n\tfunction updateSupplyIndex(address market) external;\r\n\r\n\tfunction updateBorrowIndex(address market) external;\r\n\r\n\tfunction updatePromotionReserve(address market) external;\r\n}\r\n\r\n// All these settings is callable by only owner\r\ncontract HoldefiSettings is Ownable {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint constant public ratesDecimal = 10 ** 4;\r\n\r\n\tuint constant public secondsPerTenDays = 864000;\r\n\r\n\tuint constant public maxBorrowRate = 4000;\t\t\t\t  //40%\r\n\r\n\tuint constant public borrowRateMaxIncrease = 500;\t\t  //5%\r\n\r\n\tuint constant public minSuppliersShareRate = 5000;\t\t  //50%\r\n\r\n\tuint constant public suppliersShareRateMaxDecrease = 500; //5%\r\n\r\n\tuint constant public maxValueToLoanRate = 20000; \t\t  //200%\r\n\r\n\tuint constant public valueToLoanRateMaxIncrease = 500;\t  //5%\r\n\r\n\tuint constant public maxPenaltyRate = 13000; \t\t\t  //130%\r\n\r\n\tuint constant public penaltyRateMaxIncrease = 500; \t\t  //5%\r\n\r\n\t// Markets Features \r\n\tstruct Market {\r\n\t\tbool isActive;\r\n\r\n\t\tuint borrowRate;\r\n\t\tuint borrowRateUpdateTime;\r\n\r\n\t\tuint suppliersShareRate;\r\n\t\tuint suppliersShareRateUpdateTime;\t\r\n\t}\r\n\r\n\t// Collaterals Features\r\n\tstruct Collateral {\r\n\t\tbool isActive;\r\n\t\tuint valueToLoanRate;   // Collateral liquidation threshold\r\n\t\tuint VTLUpdateTime;\r\n\t\tuint penaltyRate; \t\t// Portion of collateral being liquidated during liquidation\r\n\t\tuint penaltyUpdateTime;\r\n\t\tuint bonusRate;\t\t    // Bonus for buyers who buy liquidated collaterals\r\n\t}\r\n\r\n\t// Asset address => Market features \r\n\tmapping (address => Market) public marketAssets;\r\n\taddress[] public marketsList;\r\n\r\n\t// Asset address => Collateral features\r\n\tmapping (address => Collateral) public collateralAssets;\r\n\r\n\tHoldefiInterface public holdefiContract;\r\n\r\n\tevent BorrowRateChanged(address market, uint newRate);\r\n\r\n\tevent SuppliersShareRateChanged(address market, uint newRate);\r\n\r\n\tevent MarketAdded(address market);\r\n\r\n\tevent MarketRemoved(address market);\r\n\r\n\tevent CollateralAdded(address collateral, uint valueToLoanRate, uint penaltyRate, uint bonusRate);\r\n\r\n\tevent CollateralRemoved(address collateral);\r\n\r\n\tevent ValueToLoanRateChanged(address collateral, uint newRate);\r\n\r\n\tevent PenaltyRateChanged(address collateral, uint newRate);\r\n\r\n\tevent BonusRateChanged(address collateral, uint newRate);\r\n\t\r\n\tconstructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n\t}\r\n\r\n\t// Disposable function to Get in touch with Holdefi contract\r\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\r\n\t\trequire (address(holdefiContract) == address(0),'Should be set once');\r\n\t\tholdefiContract = holdefiContractAddress;\r\n\t}\r\n\r\n\t// Returns supply rate and borrow rate \r\n\t// supply rate = ((total borrow * Borrow rate * suppliers share rate) / total supply\r\n\tfunction getInterests (address market, uint totalSupply, uint totalBorrow) external view returns(uint borrowRate, uint supplyRate) {\r\n\t\tborrowRate = marketAssets[market].borrowRate;\r\n\t\tuint suppliersShareRate = marketAssets[market].suppliersShareRate;\r\n\t\tif (totalSupply == 0){\r\n\t\t\tsupplyRate = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint totalInterestFromBorrow = totalBorrow.mul(borrowRate);\r\n\t\t\tuint suppliersShare = totalInterestFromBorrow.mul(suppliersShareRate);\r\n\t\t\tsuppliersShare = suppliersShare.div(ratesDecimal);\r\n\t\t\tsupplyRate = suppliersShare.div(totalSupply);\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns list of all markets\r\n\tfunction getMarketsList() external view returns (address[] memory res){\r\n\t\tres = marketsList;\r\n\t}\r\n\r\n\t// Returns true if an asset is in the market list\r\n\tfunction getMarket(address market) external view returns (bool active){\r\n\t\tactive = marketAssets[market].isActive;\r\n\t}\r\n\r\n\t// Returns the features of a collateral (Is active- VTL rate- Penalty rate- Bonus rate)\r\n\tfunction getCollateral(address collateral) external view returns (bool, uint, uint, uint){\r\n\t\treturn(\r\n\t\t\tcollateralAssets[collateral].isActive,\r\n\t\t\tcollateralAssets[collateral].valueToLoanRate,\r\n\t\t\tcollateralAssets[collateral].penaltyRate,\r\n\t\t\tcollateralAssets[collateral].bonusRate\t\t\r\n\t\t\t);\r\n\t}\r\n\t\r\n\t// Owner can set a new borrow rate\r\n\tfunction setBorrowRate (address market, uint newBorrowRate) external onlyOwner {\r\n\t\trequire (newBorrowRate <= maxBorrowRate,'Rate should be less than max');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newBorrowRate > marketAssets[market].borrowRate){\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\r\n\t\t\trequire (newBorrowRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateBorrowIndex(market);\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\r\n\r\n\t\temit BorrowRateChanged(market, newBorrowRate);\r\n\t}\r\n\r\n\t// Owner can set a new 'suppliers share rate' (Supplier's share of borrower's interest).\r\n\tfunction setSuppliersShareRate (address market, uint newSuppliersShareRate) external onlyOwner {\r\n\t\trequire (newSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= ratesDecimal,'Rate should be in allowed range');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Decreasing rate is not allowed at this time');\r\n\t\t\tuint maxDecrease = marketAssets[market].suppliersShareRate.sub(suppliersShareRateMaxDecrease);\r\n\t\t\trequire (newSuppliersShareRate >= maxDecrease,'Rate should be decreased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\r\n\r\n\t\temit SuppliersShareRateChanged(market, newSuppliersShareRate);\r\n\t}\r\n\r\n\t// Owner can add a new asset as a market.\r\n\tfunction addMarket (address market, uint borrowRate, uint suppliersShareRate) external onlyOwner {\r\n\t\trequire(!marketAssets[market].isActive, \"Market exists\");\r\n\t\trequire (borrowRate <= maxBorrowRate\r\n\t\t\t&& suppliersShareRate >= minSuppliersShareRate\r\n\t\t\t&& suppliersShareRate <= ratesDecimal\r\n\t\t\t, 'Rate should be in allowed range');\r\n\t\t\r\n\t\tmarketAssets[market].isActive = true;\r\n\t\tmarketAssets[market].borrowRate = borrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = block.timestamp;\r\n\t\tmarketAssets[market].suppliersShareRate = suppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = block.timestamp;\r\n\t\r\n\t\tbool exist = false;\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tif (marketsList[i] == market){\r\n\t\t\t\texist = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!exist) {\r\n\t\t\tmarketsList.push(market);\r\n\t\t}\r\n\r\n\t\temit MarketAdded(market);\r\n\t}\r\n\r\n\t// Owner can remove a market asset\r\n\tfunction removeMarket (address market) external onlyOwner {\t\t\r\n\t\tmarketAssets[market].isActive = false;\r\n\t\temit MarketRemoved(market);\r\n\t}\r\n\r\n\t// Owner can add a collateral asset with its VTL, penalty and bonus rate\r\n\tfunction addCollateral (address collateralAsset, uint valueToLoanRate, uint penaltyRate, uint bonusRate) external onlyOwner {\r\n\t\trequire(!collateralAssets[collateralAsset].isActive, \"Collateral exists\");\t\t\r\n\t\trequire (valueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& penaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& penaltyRate <= valueToLoanRate\r\n\t\t\t\t&& bonusRate <= penaltyRate\r\n\t\t\t\t&& bonusRate >= ratesDecimal\r\n\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tcollateralAssets[collateralAsset].isActive = true;\r\n\t\tcollateralAssets[collateralAsset].valueToLoanRate = valueToLoanRate;\r\n\t\tcollateralAssets[collateralAsset].penaltyRate  = penaltyRate;\r\n\t    collateralAssets[collateralAsset].bonusRate = bonusRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = block.timestamp;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = block.timestamp;\r\n\t    \t\r\n\t\temit CollateralAdded(collateralAsset, valueToLoanRate, penaltyRate, bonusRate);\r\n\t}\r\n\r\n\t// Owner can remove a collateral asset\r\n\tfunction removeCollateral (address collateralAsset) external onlyOwner {\r\n\t\tcollateralAssets[collateralAsset].isActive = false;\r\n\t\temit CollateralRemoved(collateralAsset);\r\n\t}\r\n\t\r\n\t// Owner can set a new VTL rate (Liquidation threshold) for each collateral asset\r\n\tfunction setValueToLoanRate (address collateralAsset, uint newValueToLoanRate) external onlyOwner {\r\n\t\trequire (newValueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].penaltyRate <= newValueToLoanRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newValueToLoanRate > collateralAssets[collateralAsset].valueToLoanRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].VTLUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].valueToLoanRate.add(valueToLoanRateMaxIncrease);\r\n\t\t\trequire (newValueToLoanRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].valueToLoanRate = newValueToLoanRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = currentTime;\r\n\r\n\t    emit ValueToLoanRateChanged(collateralAsset, newValueToLoanRate);\r\n\t}\r\n\r\n\t// Owner can set penalty rate for each collateral asset\r\n\tfunction setPenaltyRate (address collateralAsset ,uint newPenaltyRate) external onlyOwner {\r\n\t\trequire (newPenaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& newPenaltyRate <= collateralAssets[collateralAsset].valueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].bonusRate <= newPenaltyRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newPenaltyRate > collateralAssets[collateralAsset].penaltyRate){\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].penaltyUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].penaltyRate.add(penaltyRateMaxIncrease);\r\n\t\t\trequire (newPenaltyRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].penaltyRate  = newPenaltyRate;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = currentTime;\r\n\r\n\t    emit PenaltyRateChanged(collateralAsset, newPenaltyRate);\r\n\t}\r\n\r\n\t// Owner can set bonus rate for each collateral asset\r\n\tfunction setBonusRate (address collateralAsset, uint newBonusRate) external onlyOwner {\r\n\t\trequire (newBonusRate <= collateralAssets[collateralAsset].penaltyRate\r\n\t\t\t\t&& newBonusRate >= ratesDecimal\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t    collateralAssets[collateralAsset].bonusRate = newBonusRate;\r\n\r\n\t    emit BonusRateChanged(collateralAsset, newBonusRate);\r\n\t}\r\n\r\n\tfunction() payable external {\r\n        revert();\r\n    }\r\n}"
    },
    {
      "filename": "contracts/HoldefiSettings.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n\r\ninterface HoldefiInterface {\r\n\r\n\tfunction updateSupplyIndex(address market) external;\r\n\r\n\tfunction updateBorrowIndex(address market) external;\r\n\r\n\tfunction updatePromotionReserve(address market) external;\r\n}\r\n\r\n// All these settings is callable by only owner\r\ncontract HoldefiSettings is Ownable {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint constant public ratesDecimal = 10 ** 4;\r\n\r\n\tuint constant public secondsPerTenDays = 864000;\r\n\r\n\tuint constant public maxBorrowRate = 4000;\t\t\t\t  //40%\r\n\r\n\tuint constant public borrowRateMaxIncrease = 500;\t\t  //5%\r\n\r\n\tuint constant public minSuppliersShareRate = 5000;\t\t  //50%\r\n\r\n\tuint constant public suppliersShareRateMaxDecrease = 500; //5%\r\n\r\n\tuint constant public maxValueToLoanRate = 20000; \t\t  //200%\r\n\r\n\tuint constant public valueToLoanRateMaxIncrease = 500;\t  //5%\r\n\r\n\tuint constant public maxPenaltyRate = 13000; \t\t\t  //130%\r\n\r\n\tuint constant public penaltyRateMaxIncrease = 500; \t\t  //5%\r\n\r\n\t// Markets Features \r\n\tstruct Market {\r\n\t\tbool isActive;\r\n\r\n\t\tuint borrowRate;\r\n\t\tuint borrowRateUpdateTime;\r\n\r\n\t\tuint suppliersShareRate;\r\n\t\tuint suppliersShareRateUpdateTime;\t\r\n\t}\r\n\r\n\t// Collaterals Features\r\n\tstruct Collateral {\r\n\t\tbool isActive;\r\n\t\tuint valueToLoanRate;   // Collateral liquidation threshold\r\n\t\tuint VTLUpdateTime;\r\n\t\tuint penaltyRate; \t\t// Portion of collateral being liquidated during liquidation\r\n\t\tuint penaltyUpdateTime;\r\n\t\tuint bonusRate;\t\t    // Bonus for buyers who buy liquidated collaterals\r\n\t}\r\n\r\n\t// Asset address => Market features \r\n\tmapping (address => Market) public marketAssets;\r\n\taddress[] public marketsList;\r\n\r\n\t// Asset address => Collateral features\r\n\tmapping (address => Collateral) public collateralAssets;\r\n\r\n\tHoldefiInterface public holdefiContract;\r\n\r\n\tevent BorrowRateChanged(address market, uint newRate);\r\n\r\n\tevent SuppliersShareRateChanged(address market, uint newRate);\r\n\r\n\tevent MarketAdded(address market);\r\n\r\n\tevent MarketRemoved(address market);\r\n\r\n\tevent CollateralAdded(address collateral, uint valueToLoanRate, uint penaltyRate, uint bonusRate);\r\n\r\n\tevent CollateralRemoved(address collateral);\r\n\r\n\tevent ValueToLoanRateChanged(address collateral, uint newRate);\r\n\r\n\tevent PenaltyRateChanged(address collateral, uint newRate);\r\n\r\n\tevent BonusRateChanged(address collateral, uint newRate);\r\n\t\r\n\tconstructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\r\n\t}\r\n\r\n\t// Disposable function to Get in touch with Holdefi contract\r\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\r\n\t\trequire (address(holdefiContract) == address(0),'Should be set once');\r\n\t\tholdefiContract = holdefiContractAddress;\r\n\t}\r\n\r\n\t// Returns supply rate and borrow rate \r\n\t// supply rate = ((total borrow * Borrow rate * suppliers share rate) / total supply\r\n\tfunction getInterests (address market, uint totalSupply, uint totalBorrow) external view returns(uint borrowRate, uint supplyRate) {\r\n\t\tborrowRate = marketAssets[market].borrowRate;\r\n\t\tuint suppliersShareRate = marketAssets[market].suppliersShareRate;\r\n\t\tif (totalSupply == 0){\r\n\t\t\tsupplyRate = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint totalInterestFromBorrow = totalBorrow.mul(borrowRate);\r\n\t\t\tuint suppliersShare = totalInterestFromBorrow.mul(suppliersShareRate);\r\n\t\t\tsuppliersShare = suppliersShare.div(ratesDecimal);\r\n\t\t\tsupplyRate = suppliersShare.div(totalSupply);\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns list of all markets\r\n\tfunction getMarketsList() external view returns (address[] memory res){\r\n\t\tres = marketsList;\r\n\t}\r\n\r\n\t// Returns true if an asset is in the market list\r\n\tfunction getMarket(address market) external view returns (bool active){\r\n\t\tactive = marketAssets[market].isActive;\r\n\t}\r\n\r\n\t// Returns the features of a collateral (Is active- VTL rate- Penalty rate- Bonus rate)\r\n\tfunction getCollateral(address collateral) external view returns (bool, uint, uint, uint){\r\n\t\treturn(\r\n\t\t\tcollateralAssets[collateral].isActive,\r\n\t\t\tcollateralAssets[collateral].valueToLoanRate,\r\n\t\t\tcollateralAssets[collateral].penaltyRate,\r\n\t\t\tcollateralAssets[collateral].bonusRate\t\t\r\n\t\t\t);\r\n\t}\r\n\t\r\n\t// Owner can set a new borrow rate\r\n\tfunction setBorrowRate (address market, uint newBorrowRate) external onlyOwner {\r\n\t\trequire (newBorrowRate <= maxBorrowRate,'Rate should be less than max');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newBorrowRate > marketAssets[market].borrowRate){\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\r\n\t\t\trequire (newBorrowRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateBorrowIndex(market);\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\r\n\r\n\t\temit BorrowRateChanged(market, newBorrowRate);\r\n\t}\r\n\r\n\t// Owner can set a new 'suppliers share rate' (Supplier's share of borrower's interest).\r\n\tfunction setSuppliersShareRate (address market, uint newSuppliersShareRate) external onlyOwner {\r\n\t\trequire (newSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= ratesDecimal,'Rate should be in allowed range');\r\n\t\tuint currentTime = block.timestamp;\r\n\r\n\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Decreasing rate is not allowed at this time');\r\n\t\t\tuint maxDecrease = marketAssets[market].suppliersShareRate.sub(suppliersShareRateMaxDecrease);\r\n\t\t\trequire (newSuppliersShareRate >= maxDecrease,'Rate should be decreased less than max allowed');\r\n\t\t}\r\n\r\n\t\tholdefiContract.updateSupplyIndex(market);\r\n\t\tholdefiContract.updatePromotionReserve(market);\r\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\r\n\r\n\t\temit SuppliersShareRateChanged(market, newSuppliersShareRate);\r\n\t}\r\n\r\n\t// Owner can add a new asset as a market.\r\n\tfunction addMarket (address market, uint borrowRate, uint suppliersShareRate) external onlyOwner {\r\n\t\trequire(!marketAssets[market].isActive, \"Market exists\");\r\n\t\trequire (borrowRate <= maxBorrowRate\r\n\t\t\t&& suppliersShareRate >= minSuppliersShareRate\r\n\t\t\t&& suppliersShareRate <= ratesDecimal\r\n\t\t\t, 'Rate should be in allowed range');\r\n\t\t\r\n\t\tmarketAssets[market].isActive = true;\r\n\t\tmarketAssets[market].borrowRate = borrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = block.timestamp;\r\n\t\tmarketAssets[market].suppliersShareRate = suppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = block.timestamp;\r\n\t\r\n\t\tbool exist = false;\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tif (marketsList[i] == market){\r\n\t\t\t\texist = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!exist) {\r\n\t\t\tmarketsList.push(market);\r\n\t\t}\r\n\r\n\t\temit MarketAdded(market);\r\n\t}\r\n\r\n\t// Owner can remove a market asset\r\n\tfunction removeMarket (address market) external onlyOwner {\t\t\r\n\t\tmarketAssets[market].isActive = false;\r\n\t\temit MarketRemoved(market);\r\n\t}\r\n\r\n\t// Owner can add a collateral asset with its VTL, penalty and bonus rate\r\n\tfunction addCollateral (address collateralAsset, uint valueToLoanRate, uint penaltyRate, uint bonusRate) external onlyOwner {\r\n\t\trequire(!collateralAssets[collateralAsset].isActive, \"Collateral exists\");\t\t\r\n\t\trequire (valueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& penaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& penaltyRate <= valueToLoanRate\r\n\t\t\t\t&& bonusRate <= penaltyRate\r\n\t\t\t\t&& bonusRate >= ratesDecimal\r\n\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tcollateralAssets[collateralAsset].isActive = true;\r\n\t\tcollateralAssets[collateralAsset].valueToLoanRate = valueToLoanRate;\r\n\t\tcollateralAssets[collateralAsset].penaltyRate  = penaltyRate;\r\n\t    collateralAssets[collateralAsset].bonusRate = bonusRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = block.timestamp;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = block.timestamp;\r\n\t    \t\r\n\t\temit CollateralAdded(collateralAsset, valueToLoanRate, penaltyRate, bonusRate);\r\n\t}\r\n\r\n\t// Owner can remove a collateral asset\r\n\tfunction removeCollateral (address collateralAsset) external onlyOwner {\r\n\t\tcollateralAssets[collateralAsset].isActive = false;\r\n\t\temit CollateralRemoved(collateralAsset);\r\n\t}\r\n\t\r\n\t// Owner can set a new VTL rate (Liquidation threshold) for each collateral asset\r\n\tfunction setValueToLoanRate (address collateralAsset, uint newValueToLoanRate) external onlyOwner {\r\n\t\trequire (newValueToLoanRate <= maxValueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].penaltyRate <= newValueToLoanRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newValueToLoanRate > collateralAssets[collateralAsset].valueToLoanRate) {\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].VTLUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].valueToLoanRate.add(valueToLoanRateMaxIncrease);\r\n\t\t\trequire (newValueToLoanRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].valueToLoanRate = newValueToLoanRate;\r\n\t    collateralAssets[collateralAsset].VTLUpdateTime = currentTime;\r\n\r\n\t    emit ValueToLoanRateChanged(collateralAsset, newValueToLoanRate);\r\n\t}\r\n\r\n\t// Owner can set penalty rate for each collateral asset\r\n\tfunction setPenaltyRate (address collateralAsset ,uint newPenaltyRate) external onlyOwner {\r\n\t\trequire (newPenaltyRate <= maxPenaltyRate\r\n\t\t\t\t&& newPenaltyRate <= collateralAssets[collateralAsset].valueToLoanRate\r\n\t\t\t\t&& collateralAssets[collateralAsset].bonusRate <= newPenaltyRate\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\r\n\t\tuint currentTime = block.timestamp;\r\n\t\tif (newPenaltyRate > collateralAssets[collateralAsset].penaltyRate){\r\n\t\t\tuint deltaTime = currentTime.sub(collateralAssets[collateralAsset].penaltyUpdateTime);\r\n\t\t\trequire (deltaTime >= secondsPerTenDays,'Increasing rate is not allowed at this time');\r\n\t\t\tuint maxIncrease = collateralAssets[collateralAsset].penaltyRate.add(penaltyRateMaxIncrease);\r\n\t\t\trequire (newPenaltyRate <= maxIncrease,'Rate should be increased less than max allowed');\r\n\t\t}\r\n\t    collateralAssets[collateralAsset].penaltyRate  = newPenaltyRate;\r\n\t    collateralAssets[collateralAsset].penaltyUpdateTime = currentTime;\r\n\r\n\t    emit PenaltyRateChanged(collateralAsset, newPenaltyRate);\r\n\t}\r\n\r\n\t// Owner can set bonus rate for each collateral asset\r\n\tfunction setBonusRate (address collateralAsset, uint newBonusRate) external onlyOwner {\r\n\t\trequire (newBonusRate <= collateralAssets[collateralAsset].penaltyRate\r\n\t\t\t\t&& newBonusRate >= ratesDecimal\r\n\t\t\t\t,'Rate should be in allowed range');\r\n\t\t\r\n\t    collateralAssets[collateralAsset].bonusRate = newBonusRate;\r\n\r\n\t    emit BonusRateChanged(collateralAsset, newBonusRate);\r\n\t}\r\n\r\n\tfunction() payable external {\r\n        revert();\r\n    }\r\n}"
    }
  ]
}