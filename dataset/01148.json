{
  "Title": "Withdraw Root Can Be Set Up as a Rug Pull",
  "Content": "In the `ScrollChain` contract, the `importGenesisBatch` function allows anyone to set up the first finalized batch on L1. This includes the [`withdrawRoot` hash of the first batch](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/rollup/ScrollChain.sol#L146). For L2 to L1 communication, L2 transactions are relayed through the `L1ScrollMessenger` contract. To verify that a message was indeed initiated on L2, a provided Merkle proof needs to result in the `withdrawRoot` that was given in the genesis block or during the finalization of consecutive batches. Since the genesis block is finalized without any zk-proof, the `withdrawRoot` can be set up arbitrarily.\n\n\nThese circumstances can potentially be used to set up a rug pull. The [`_xDomainCalldataHash`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L134) which is based on the relayed message data can be precalculated to [send any amount of ETH to any address](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L155). By setting up that hash as the genesis block `withdrawRoot`, it would also be the [`_messageRoot`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L140) in the respective relay message call. Then, with a proof of length zero, the [hashes match](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/verifier/WithdrawTrieVerifier.sol#L27) and the [Merkle proof requirement](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L142) passes, thereby stealing the users' deposited funds.\n\n\nSince the `importGenesisBatch` function is unprotected this could be set up by anyone, although it is unlikely to be unnoticed that the genesis block was initialized by an outside actor. But this could also just lead to a malicious actor setting up the chain with erroneous parameters and the Scroll team having to redeploy the proxy contract that delegates into the `ScrollChain` contract implementation.\n\n\nConsider removing the `_withdrawRoot` parameter of the `importGenesisBatch` function and instead hardcoding its genesis block value to zero. Further, consider protecting the function to only be called by the owner.\n\n\n***Update:** Partially resolved in [pull request #558](https://github.com/scroll-tech/scroll/pull/558) at commit [b82dab5](https://github.com/scroll-tech/scroll/pull/558/commits/b82dab5da35b863c2c95f892d9b3dc05d7cfc147). The `_withdrawRoot` is removed as a parameter and unset, but the function is still callable by anyone. The Scroll team stated:*\n\n\n\n> *It is only called once during initialization, it should not be a problem to be callable by anyone.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {ChunkCodec} from \"../../libraries/codec/ChunkCodec.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when the address of rollup verifier is updated.\n    /// @param oldVerifier The address of old rollup verifier.\n    /// @param newVerifier The address of new rollup verifier.\n    event UpdateVerifier(address oldVerifier, address newVerifier);\n\n    /// @notice Emitted when the value of `maxNumL2TxInChunk` is updated.\n    /// @param oldMaxNumL2TxInChunk The old value of `maxNumL2TxInChunk`.\n    /// @param newMaxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    event UpdateMaxNumL2TxInChunk(uint256 oldMaxNumL2TxInChunk, uint256 newMaxNumL2TxInChunk);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint256 public immutable layer2ChainId;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumL2TxInChunk;\n\n    /// @notice The address of L1MessageQueue.\n    address public messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice The latest finalized batch index.\n    uint256 public lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isSequencer[msg.sender], \"caller not sequencer\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint256 _chainId) {\n        layer2ChainId = _chainId;\n    }\n\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumL2TxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateVerifier(address(0), _verifier);\n        emit UpdateMaxNumL2TxInChunk(0, _maxNumL2TxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    /// @dev Although `_withdrawRoot` is always zero, we add this parameter for the convenience of unit testing.\n    function importGenesisBatch(\n        bytes calldata _batchHeader,\n        bytes32 _stateRoot,\n        bytes32 _withdrawRoot\n    ) external {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"zero state root\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"Genesis batch imported\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.version(memPtr) +\n                BatchHeaderV0Codec.batchIndex(memPtr) +\n                BatchHeaderV0Codec.l1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.totalL1MessagePopped(memPtr);\n            require(sum == 0, \"not all fields are zero\");\n        }\n        require(BatchHeaderV0Codec.dataHash(memPtr) != bytes32(0), \"zero data hash\");\n        require(BatchHeaderV0Codec.parentBatchHash(memPtr) == bytes32(0), \"nonzero parent batch hash\");\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n        withdrawRoots[0] = _withdrawRoot;\n\n        emit CommitBatch(_batchHash);\n        emit FinalizeBatch(_batchHash, _stateRoot, _withdrawRoot);\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) external override OnlySequencer {\n        require(_version == 0, \"invalid version\");\n\n        // check whether the batch is empty\n        uint256 _chunksLength = _chunks.length;\n        require(_chunksLength > 0, \"batch is empty\");\n\n        // The overall memory layout in this function is organized as follows\n        // +---------------------+-------------------+------------------+\n        // | parent batch header | chunk data hashes | new batch header |\n        // +---------------------+-------------------+------------------+\n        // ^                     ^                   ^\n        // batchPtr              dataPtr             newBatchPtr (re-use var batchPtr)\n        //\n        // 1. We copy the parent batch header from calldata to memory starting at batchPtr\n        // 2. We store `_chunksLength` number of Keccak hashes starting at `dataPtr`. Each Keccak\n        //    hash corresponds to the data hash of a chunk. So we reserve the memory region from\n        //    `dataPtr` to `dataPtr + _chunkLength * 32` for the chunk data hashes.\n        // 3. The memory starting at `newBatchPtr` is used to store the new batch header and compute\n        //    the batch hash.\n\n        // the variable `batchPtr` will be reused later for the current batch\n        (uint256 batchPtr, bytes32 _parentBatchHash) = _loadBatchHeader(_parentBatchHeader);\n\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(batchPtr);\n        uint256 _totalL1MessagesPoppedOverall = BatchHeaderV0Codec.totalL1MessagePopped(batchPtr);\n        require(committedBatches[_batchIndex] == _parentBatchHash, \"incorrect parent batch hash\");\n        require(committedBatches[_batchIndex + 1] == 0, \"batch already committed\");\n\n        // load `dataPtr` and reserve the memory region for chunk data hashes\n        uint256 dataPtr;\n        assembly {\n            dataPtr := mload(0x40)\n            mstore(0x40, add(dataPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        uint256 _totalL1MessagesPoppedInBatch;\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk = _commitChunk(\n                dataPtr,\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n                dataPtr += 32;\n            }\n        }\n\n        // check the length of bitmap\n        unchecked {\n            require(\n                ((_totalL1MessagesPoppedInBatch + 255) / 256) * 32 == _skippedL1MessageBitmap.length,\n                \"wrong bitmap length\"\n            );\n        }\n\n        // compute the data hash for current batch\n        bytes32 _dataHash;\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _dataHash := keccak256(sub(dataPtr, dataLen), dataLen)\n\n            batchPtr := mload(0x40) // reset batchPtr\n            _batchIndex := add(_batchIndex, 1) // increase batch index\n        }\n\n        // store entries, the order matters\n        BatchHeaderV0Codec.storeVersion(batchPtr, _version);\n        BatchHeaderV0Codec.storeBatchIndex(batchPtr, _batchIndex);\n        BatchHeaderV0Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n        BatchHeaderV0Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n        BatchHeaderV0Codec.storeDataHash(batchPtr, _dataHash);\n        BatchHeaderV0Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n        BatchHeaderV0Codec.storeSkippedBitmap(batchPtr, _skippedL1MessageBitmap);\n\n        // compute batch hash\n        bytes32 _batchHash = BatchHeaderV0Codec.computeBatchHash(batchPtr, 89 + _skippedL1MessageBitmap.length);\n\n        committedBatches[_batchIndex] = _batchHash;\n        emit CommitBatch(_batchHash);\n    }\n\n    /// @inheritdoc IScrollChain\n    function revertBatch(bytes calldata _batchHeader, uint256 _count) external onlyOwner {\n        require(_count > 0, \"count must be nonzero\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check batch hash\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // check finalization\n        require(_batchIndex > lastFinalizedBatchIndex, \"can only revert unfinalized batch\");\n\n        while (_count > 0) {\n            committedBatches[_batchIndex] = bytes32(0);\n            unchecked {\n                _batchIndex += 1;\n                _count -= 1;\n            }\n\n            emit RevertBatch(_batchHash);\n\n            _batchHash = committedBatches[_batchIndex];\n            if (_batchHash == bytes32(0)) break;\n        }\n    }\n\n    /// @inheritdoc IScrollChain\n    function finalizeBatchWithProof(\n        bytes calldata _batchHeader,\n        bytes32 _prevStateRoot,\n        bytes32 _postStateRoot,\n        bytes32 _withdrawRoot,\n        bytes calldata _aggrProof\n    ) external override OnlySequencer {\n        require(_prevStateRoot != bytes32(0), \"previous state root is zero\");\n        require(_postStateRoot != bytes32(0), \"new state root is zero\");\n\n        // compute batch hash and verify\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        bytes32 _dataHash = BatchHeaderV0Codec.dataHash(memPtr);\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // verify previous state root.\n        require(finalizedStateRoots[_batchIndex - 1] == _prevStateRoot, \"incorrect previous state root\");\n\n        // avoid duplicated verification\n        require(finalizedStateRoots[_batchIndex] == bytes32(0), \"batch already verified\");\n\n        // compute public input hash\n        bytes32 _publicInputHash = keccak256(abi.encode(_prevStateRoot, _postStateRoot, _withdrawRoot, _dataHash));\n\n        // verify batch\n        IRollupVerifier(verifier).verifyAggregateProof(_aggrProof, _publicInputHash);\n\n        // check and update lastFinalizedBatchIndex\n        unchecked {\n            require(lastFinalizedBatchIndex + 1 == _batchIndex, \"incorrect batch index\");\n            lastFinalizedBatchIndex = _batchIndex;\n        }\n\n        // record state root and withdraw root\n        finalizedStateRoots[_batchIndex] = _postStateRoot;\n        withdrawRoots[_batchIndex] = _withdrawRoot;\n\n        // Pop finalized and non-skipped message from L1MessageQueue.\n        uint256 _l1MessagePopped = BatchHeaderV0Codec.l1MessagePopped(memPtr);\n        if (_l1MessagePopped > 0) {\n            IL1MessageQueue _queue = IL1MessageQueue(messageQueue);\n\n            unchecked {\n                uint256 _startIndex = BatchHeaderV0Codec.totalL1MessagePopped(memPtr) - _l1MessagePopped;\n\n                for (uint256 i = 0; i < _l1MessagePopped; i += 256) {\n                    uint256 _count = 256;\n                    if (_l1MessagePopped - i < _count) {\n                        _count = _l1MessagePopped - i;\n                    }\n                    uint256 _skippedBitmap = BatchHeaderV0Codec.skippedBitmap(memPtr, i / 256);\n\n                    _queue.popCrossDomainMessage(_startIndex, _count, _skippedBitmap);\n\n                    _startIndex += 256;\n                }\n            }\n        }\n\n        emit FinalizeBatch(_batchHash, _postStateRoot, _withdrawRoot);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the status of sequencer.\n    /// @dev This function can only called by contract owner.\n    /// @param _account The address of account to update.\n    /// @param _status The status of the account to update.\n    function updateSequencer(address _account, bool _status) external onlyOwner {\n        isSequencer[_account] = _status;\n\n        emit UpdateSequencer(_account, _status);\n    }\n\n    /// @notice Update the address verifier contract.\n    /// @param _newVerifier The address of new verifier contract.\n    function updateVerifier(address _newVerifier) external onlyOwner {\n        address _oldVerifier = verifier;\n        verifier = _newVerifier;\n\n        emit UpdateVerifier(_oldVerifier, _newVerifier);\n    }\n\n    /// @notice Update the value of `maxNumL2TxInChunk`.\n    /// @param _maxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    function updateMaxNumL2TxInChunk(uint256 _maxNumL2TxInChunk) external onlyOwner {\n        uint256 _oldMaxNumL2TxInChunk = maxNumL2TxInChunk;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateMaxNumL2TxInChunk(_oldMaxNumL2TxInChunk, _maxNumL2TxInChunk);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @return memPtr The start memory offset of loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    function _loadBatchHeader(bytes calldata _batchHeader) internal pure returns (uint256 memPtr, bytes32 _batchHash) {\n        // load to memory\n        uint256 _length;\n        (memPtr, _length) = BatchHeaderV0Codec.loadAndValidate(_batchHeader);\n\n        // compute batch hash\n        _batchHash = BatchHeaderV0Codec.computeBatchHash(memPtr, _length);\n    }\n\n    /// @dev Internal function to commit a chunk.\n    /// @param memPtr The start memory offset to store list of `dataHash`.\n    /// @param _chunk The encoded chunk to commit.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _totalNumL1MessagesInChunk The total number of L1 message popped in current chunk\n    function _commitChunk(\n        uint256 memPtr,\n        bytes memory _chunk,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256 _totalNumL1MessagesInChunk) {\n        uint256 chunkPtr;\n        uint256 dataPtr;\n        uint256 blockPtr;\n\n        assembly {\n            dataPtr := mload(0x40)\n            chunkPtr := add(_chunk, 0x20) // skip chunkLength\n            blockPtr := add(chunkPtr, 1) // skip numBlocks\n        }\n\n        uint256 _numBlocks = ChunkCodec.validateChunkLength(chunkPtr, _chunk.length);\n\n        // concatenate block contexts\n        for (uint256 i = 0; i < _numBlocks; i++) {\n            dataPtr = ChunkCodec.copyBlockContext(chunkPtr, dataPtr, i);\n        }\n\n        // concatenate tx hashes\n        uint256 l2TxPtr = ChunkCodec.l2TxPtr(chunkPtr, _numBlocks);\n\n        // avoid stack too deep on forge coverage\n        uint256 _totalTransactionsInChunk;\n        while (_numBlocks > 0) {\n            // concatenate l1 message hashes\n            uint256 _numL1MessagesInBlock = ChunkCodec.numL1Messages(blockPtr);\n            dataPtr = _loadL1MessageHashes(\n                dataPtr,\n                _numL1MessagesInBlock,\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            // concatenate l2 transaction hashes\n            uint256 _numTransactionsInBlock = ChunkCodec.numTransactions(blockPtr);\n            for (uint256 j = _numL1MessagesInBlock; j < _numTransactionsInBlock; j++) {\n                bytes32 txHash;\n                (txHash, l2TxPtr) = ChunkCodec.loadL2TxHash(l2TxPtr);\n                assembly {\n                    mstore(dataPtr, txHash)\n                    dataPtr := add(dataPtr, 0x20)\n                }\n            }\n\n            unchecked {\n                _totalTransactionsInChunk += _numTransactionsInBlock;\n                _totalNumL1MessagesInChunk += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedInBatch += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedOverall += _numL1MessagesInBlock;\n\n                _numBlocks -= 1;\n                blockPtr += ChunkCodec.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        // check the number of L2 transactions in the chunk\n        require(\n            _totalTransactionsInChunk - _totalNumL1MessagesInChunk <= maxNumL2TxInChunk,\n            \"too many L2 txs in one chunk\"\n        );\n\n        // check chunk has correct length\n        require(l2TxPtr - chunkPtr == _chunk.length, \"incomplete l2 transaction data\");\n\n        // compute data hash and store to memory\n        assembly {\n            let startPtr := mload(0x40)\n            let dataHash := keccak256(startPtr, sub(dataPtr, startPtr))\n\n            mstore(memPtr, dataHash)\n        }\n\n        return _totalNumL1MessagesInChunk;\n    }\n\n    /// @dev Internal function to load L1 message hashes from the message queue.\n    /// @param _ptr The memory offset to store the transaction hash.\n    /// @param _numL1Messages The number of L1 messages to load.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return uint256 The new memory offset after loading.\n    function _loadL1MessageHashes(\n        uint256 _ptr,\n        uint256 _numL1Messages,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256) {\n        if (_numL1Messages == 0) return _ptr;\n        IL1MessageQueue _messageQueue = IL1MessageQueue(messageQueue);\n\n        unchecked {\n            uint256 _bitmap;\n            for (uint256 i = 0; i < _numL1Messages; i++) {\n                uint256 quo = _totalL1MessagesPoppedInBatch >> 8;\n                uint256 rem = _totalL1MessagesPoppedInBatch & 0xff;\n\n                // load bitmap every 256 bits\n                if (i == 0 || rem == 0) {\n                    assembly {\n                        _bitmap := calldataload(add(_skippedL1MessageBitmap.offset, mul(0x20, quo)))\n                    }\n                }\n                if (((_bitmap >> rem) & 1) == 0) {\n                    // message not skipped\n                    bytes32 _hash = _messageQueue.getCrossDomainMessage(_totalL1MessagesPoppedOverall);\n                    assembly {\n                        mstore(_ptr, _hash)\n                        _ptr := add(_ptr, 0x20)\n                    }\n                }\n\n                _totalL1MessagesPoppedInBatch += 1;\n                _totalL1MessagesPoppedOverall += 1;\n            }\n        }\n\n        return _ptr;\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\n// solhint-disable avoid-low-level-calls\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is PausableUpgradeable, ScrollMessengerBase, IL1ScrollMessenger {\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from relay id to relay status.\n    mapping(bytes32 => bool) public isL1MessageRelayed;\n\n    /// @notice Mapping from L1 message hash to sent status.\n    mapping(bytes32 => bool) public isL1MessageSent;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, tx.origin);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            \"Message is already in execution\"\n        );\n\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            address _rollup = rollup;\n            require(IScrollChain(_rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(_rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n\n        bytes32 _relayId = keccak256(abi.encodePacked(_xDomainCalldataHash, msg.sender, block.number));\n        isL1MessageRelayed[_relayId] = true;\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _queueIndex,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` in layer 2 to avoid duplicated execution.\n        // So, only one message will succeed in layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        address _messageQueue = messageQueue;\n        address _counterpart = counterpart;\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _queueIndex, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _newGasLimit, _xDomainCalldata);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        address _messageQueue = messageQueue; // gas saving\n        address _counterpart = counterpart; // gas saving\n\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(msg.sender, _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL1MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL1MessageSent[_xDomainCalldataHash] = true;\n\n        emit SentMessage(msg.sender, _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    }
  ]
}