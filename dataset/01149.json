{
  "Title": "Users Can Lose Refund by Default",
  "Content": "In the `L1ScrollMessenger`, the `sendMessage` functions allow a user to initiate a transaction on L2 from L1. There are two `sendMessage` implementations, with and without a refund address parameter. For the function without the parameter, the refund address of the internal `_sendMessage` call is [defined as `tx.origin`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L1/L1ScrollMessenger.sol#L106).\n\n\nThis poses a risk of loss of funds for smart contract wallets. More concretely, with account abstraction gradually emerging, this default refund recipient would end up being the [`UserOperations` bundler](https://eips.ethereum.org/EIPS/eip-4337#definitions). Hence, while a user might think to receive the refund themselves, they end up losing their excessive funds.\n\n\nFurther, all of the gateways make use of this particular `sendMessage` function with the default `tx.origin` refund address. Hence, a high percentage of users with smart contract wallets may lose some ETH during bridging.\n\n\nConsider defaulting the refund address in the `L1ScrollMessenger` contract to `msg.sender`. In the gateway contracts, consider using the `sendMessage` function with the definable refund recipient that is then set to `msg.sender`.\n\n\n***Update:** Resolved in [pull request #605](https://github.com/scroll-tech/scroll/pull/605) at commit [76d4230](https://github.com/scroll-tech/scroll/pull/605/commits/76d4230571da5909499ace4c7bc90ad31a721325).*\n\n\n\nÂ \n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\n// solhint-disable avoid-low-level-calls\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is PausableUpgradeable, ScrollMessengerBase, IL1ScrollMessenger {\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from relay id to relay status.\n    mapping(bytes32 => bool) public isL1MessageRelayed;\n\n    /// @notice Mapping from L1 message hash to sent status.\n    mapping(bytes32 => bool) public isL1MessageSent;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    // @note move to ScrollMessengerBase in next big refactor\n    /// @dev The status of for non-reentrant check.\n    uint256 private _lock_status;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_lock_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _lock_status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _lock_status = _NOT_ENTERED;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n\n        // initialize to a nonzero value\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, tx.origin);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused {\n        require(\n            xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,\n            \"Message is already in execution\"\n        );\n\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            address _rollup = rollup;\n            require(IScrollChain(_rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(_rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n\n        bytes32 _relayId = keccak256(abi.encodePacked(_xDomainCalldataHash, msg.sender, block.number));\n        isL1MessageRelayed[_relayId] = true;\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _queueIndex,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` in layer 2 to avoid duplicated execution.\n        // So, only one message will succeed in layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        address _messageQueue = messageQueue;\n        address _counterpart = counterpart;\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _queueIndex, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _newGasLimit, _xDomainCalldata);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        address _messageQueue = messageQueue; // gas saving\n        address _counterpart = counterpart; // gas saving\n\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(msg.sender, _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL1MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL1MessageSent[_xDomainCalldataHash] = true;\n\n        emit SentMessage(msg.sender, _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    }
  ]
}