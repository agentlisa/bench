{
  "Title": "Sale can end while beingÂ paused",
  "Content": "The [`hasSaleEnded`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/TokenSale.sol#L215) function can change its return value from false to true during the pause period while there should be an extension of the duration of the token sale. The update of `endTime` is done only after calling the `unpause`function and the state during the pause period may be misreported.\n\n\nA consequence of this could be losing the ability to update whitelist in [`updateWhitelist`](https://github.com/OpenSTFoundation/SimpleTokenSale/blob/1a1e863441ba0149d7585203f5dbc6e800af00cf/contracts/TokenSale.sol#L234) function during the pause period.\n\n\nWe recommend updating `hasSaleEnded` function to consider the pause period.\n\n\n**Update**: *Fixed in [these two commits](https://github.com/OpenSTFoundation/SimpleTokenSale/pull/11/commits).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/TokenSale.sol",
      "content": "pragma solidity ^0.4.17;\n\n// ----------------------------------------------------------------------------\n// Simple Token - Token Sale Implementation\n//\n// Copyright (c) 2017 Simple Token and Enuma Technologies.\n// http://www.simpletoken.com/\n//\n// The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\nimport \"./SimpleToken.sol\";\nimport \"./Trustee.sol\";\nimport \"./TokenSaleConfig.sol\";\nimport \"./OpsManaged.sol\";\nimport \"./Pausable.sol\";\nimport \"./SafeMath.sol\";\n\n\n//\n// Implementation of the 1st token sale for Simple Token\n//\n// * Lifecycle *\n// Initialization sequence should be as follow:\n//    1. Deploy SimpleToken contract\n//    2. Deploy Trustee contract\n//    3. Deploy TokenSale contract\n//    4. Set operationsAddress of SimpleToken contract to TokenSale contract\n//    5. Set operationsAddress of Trustee contract to TokenSale contract\n//    6. Set operationsAddress of TokenSale contract to some address\n//    7. Transfer tokens from owner to TokenSale contract\n//    8. Transfer tokens from owner to Trustee contract\n//    9. Initialize TokenSale contract\n//\n// Pre-sale sequence:\n//    - Set tokensPerKEther\n//    - Set phase1AccountTokensMax\n//    - Add presales\n//    - Add allocations for founders, advisors, etc.\n//    - Update whitelist\n//\n// After-sale sequence:\n//    1. Finalize the TokenSale contract\n//    2. Finalize the SimpleToken contract\n//    3. Set operationsAddress of TokenSale contract to 0\n//    4. Set operationsAddress of SimpleToken contract to 0\n//    5. Set operationsAddress of Trustee contract to some address\n//\n// Anytime\n//    - Add/Remove allocations\n//\n\n//\n// Permissions, according to the ST key management specification.\n//\n//                                Owner    Admin   Ops\n// initialize                       x\n// changeWallet                              x\n// updateWhitelist                                  x\n// setTokensPerKEther                        x\n// setPhase1AccountTokensMax                 x\n// addPresale                                x\n// pause / unpause                           x\n// reclaimTokens                             x\n// finalize                                  x\n//\n\ncontract TokenSale is OpsManaged, Pausable, TokenSaleConfig { // Pausable is also Owned\n\n    using SafeMath for uint256;\n\n    // We keep track of whether the sale has been finalized, at which point\n    // no additional contributions will be permitted.\n    bool public finalized;\n\n    // The sale end time is initially defined by the END_TIME constant but it\n    // may get extended if the sale is paused.\n    uint256 public endTime;\n    uint256 public pausedTime;\n\n    // Number of tokens per 1000 ETH. See TokenSaleConfig for details.\n    uint256 public tokensPerKEther;\n\n    // Keeps track of the maximum amount of tokens that an account is allowed to purchase in phase 1.\n    uint256 public phase1AccountTokensMax;\n\n    // Address where the funds collected during the sale will be forwarded.\n    address public wallet;\n\n    // Token contract that the sale contract will interact with.\n    SimpleToken public tokenContract;\n\n    // Trustee contract to hold on token balances. The following token pools will be held by trustee:\n    //    - Founders\n    //    - Advisors\n    //    - Early investors\n    //    - Presales\n    Trustee public trusteeContract;\n\n    // Total amount of tokens sold during presale + public sale. Excludes pre-sale bonuses.\n    uint256 public totalTokensSold;\n\n    // Total amount of tokens given as bonus during presale. Will influence accelerator token balance.\n    uint256 public totalPresaleBase;\n    uint256 public totalPresaleBonus;\n\n    // Map of addresses that have been whitelisted in advance (and passed KYC).\n    // The whitelist value indicates what phase (1 or 2) the address has been whitelisted for.\n    // Addresses whitelisted for phase 1 can also contribute during phase 2.\n    mapping(address => uint8) public whitelist;\n\n\n    //\n    // EVENTS\n    //\n    event Initialized();\n    event PresaleAdded(address indexed _account, uint256 _baseTokens, uint256 _bonusTokens);\n    event WhitelistUpdated(address indexed _account, uint8 _phase);\n    event TokensPurchased(address indexed _beneficiary, uint256 _cost, uint256 _tokens);\n    event TokensPerKEtherUpdated(uint256 _amount);\n    event Phase1AccountTokensMaxUpdated(uint256 _tokens);\n    event WalletChanged(address _newWallet);\n    event TokensReclaimed(uint256 _amount);\n    event Finalized();\n\n\n    function TokenSale(SimpleToken _tokenContract, Trustee _trusteeContract, address _wallet) public\n        OpsManaged()\n    {\n        require(address(_tokenContract) != address(0));\n        require(address(_trusteeContract) != address(0));\n        require(_wallet != address(0));\n\n        require(PHASE1_START_TIME >= currentTime());\n        require(PHASE2_START_TIME > PHASE1_START_TIME);\n        require(END_TIME > PHASE2_START_TIME);\n        require(TOKENS_PER_KETHER > 0);\n        require(PHASE1_ACCOUNT_TOKENS_MAX > 0);\n\n        // Basic check that the constants add up to TOKENS_MAX\n        uint256 partialAllocations = TOKENS_FOUNDERS.add(TOKENS_ADVISORS).add(TOKENS_EARLY_INVESTORS);\n        require(partialAllocations.add(TOKENS_SALE).add(TOKENS_ACCELERATOR_MAX).add(TOKENS_FUTURE) == TOKENS_MAX);\n\n        wallet                 = _wallet;\n        pausedTime             = 0;\n        endTime                = END_TIME;\n        finalized              = false;\n        tokensPerKEther        = TOKENS_PER_KETHER;\n        phase1AccountTokensMax = PHASE1_ACCOUNT_TOKENS_MAX;\n\n        tokenContract   = _tokenContract;\n        trusteeContract = _trusteeContract;\n    }\n\n\n    // Initialize is called to link the sale token with the token contract.\n    // It expects that a certain amount of tokens have already been assigned to the sale contract address.\n    function initialize() external onlyOwner returns (bool) {\n        require(totalTokensSold == 0);\n        require(totalPresaleBase == 0);\n        require(totalPresaleBonus == 0);\n\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\n        require(ownBalance == TOKENS_SALE);\n\n        // Simple check to confirm that tokens are present\n        uint256 trusteeBalance = tokenContract.balanceOf(address(trusteeContract));\n        require(trusteeBalance >= TOKENS_FUTURE);\n\n        Initialized();\n\n        return true;\n    }\n\n\n    // Allows the admin to change the wallet where ETH contributions are sent.\n    function changeWallet(address _wallet) external onlyAdmin returns (bool) {\n        require(_wallet != address(0));\n        require(_wallet != address(this));\n        require(_wallet != address(trusteeContract));\n        require(_wallet != address(tokenContract));\n\n        wallet = _wallet;\n\n        WalletChanged(wallet);\n\n        return true;\n    }\n\n\n\n   //\n   // TIME\n   //\n\n    function currentTime() public view returns (uint256 _currentTime) {\n        return now;\n    }\n\n\n    modifier onlyBeforeSale() {\n        require(hasSaleEnded() == false);\n        require(currentTime() < PHASE1_START_TIME);\n       _;\n    }\n\n\n    modifier onlyDuringSale() {\n        require(hasSaleEnded() == false && currentTime() >= PHASE1_START_TIME);\n        _;\n    }\n\n\n    function hasSaleEnded() private view returns (bool) {\n        if (totalTokensSold >= TOKENS_SALE || currentTime() >= endTime || finalized) {\n            return true;\n        }\n\n        return false;\n    }\n\n\n\n    //\n    // WHITELIST\n    //\n\n    // Allows ops to add accounts to the whitelist.\n    // Only those accounts will be allowed to contribute during the sale.\n    // _phase = 1: Can contribute during phases 1 and 2 of the sale.\n    // _phase = 2: Can contribute during phase 2 of the sale only.\n    // _phase = 0: Cannot contribute at all (not whitelisted).\n    function updateWhitelist(address _account, uint8 _phase) external onlyOps returns (bool) {\n        require(_account != address(0));\n        require(_phase <= 2);\n        require(hasSaleEnded() == false);\n\n        whitelist[_account] = _phase;\n\n        WhitelistUpdated(_account, _phase);\n\n        return true;\n    }\n\n\n\n    //\n    // PURCHASES / CONTRIBUTIONS\n    //\n\n    // Allows the admin to set the price for tokens sold during phases 1 and 2 of the sale.\n    function setTokensPerKEther(uint256 _tokensPerKEther) external onlyAdmin onlyBeforeSale returns (bool) {\n        require(_tokensPerKEther > 0);\n\n        tokensPerKEther = _tokensPerKEther;\n\n        TokensPerKEtherUpdated(_tokensPerKEther);\n\n        return true;\n    }\n\n\n    // Allows the admin to set the maximum amount of tokens that an account can buy during phase 1 of the sale.\n    function setPhase1AccountTokensMax(uint256 _tokens) external onlyAdmin onlyBeforeSale returns (bool) {\n        require(_tokens > 0);\n\n        phase1AccountTokensMax = _tokens;\n\n        Phase1AccountTokensMaxUpdated(_tokens);\n\n        return true;\n    }\n\n\n    function () external payable whenNotPaused onlyDuringSale {\n        buyTokens();\n    }\n\n\n    // This is the main function to process incoming ETH contributions.\n    function buyTokens() public payable whenNotPaused onlyDuringSale returns (bool) {\n        require(msg.value >= CONTRIBUTION_MIN);\n        require(msg.value <= CONTRIBUTION_MAX);\n        require(totalTokensSold < TOKENS_SALE);\n\n        // All accounts need to be whitelisted to purchase.\n        uint8 whitelistedPhase = whitelist[msg.sender];\n        require(whitelistedPhase > 0);\n\n        uint256 tokensMax = TOKENS_SALE.sub(totalTokensSold);\n\n        if (currentTime() < PHASE2_START_TIME) {\n            // We are in phase 1 of the sale\n            require(whitelistedPhase == 1);\n\n            uint256 accountBalance = tokenContract.balanceOf(msg.sender);\n\n            // Can only purchase up to a maximum per account.\n            tokensMax = phase1AccountTokensMax.sub(accountBalance);\n        }\n\n        require(tokensMax > 0);\n\n        uint256 tokensBought = msg.value.mul(tokensPerKEther).div(10**(18 - uint256(TOKEN_DECIMALS) + 3));\n        require(tokensBought > 0);\n\n        uint256 cost = msg.value;\n        uint256 refund = 0;\n\n        if (tokensBought > tokensMax) {\n            // Not enough tokens available for full contribution, we will do partial.\n            tokensBought = tokensMax;\n\n            // Calculate actual cost for partial amount of tokens.\n            cost = tokensBought.mul(10**(18 - uint256(TOKEN_DECIMALS) + 3)).div(tokensPerKEther);\n\n            // Calculate refund for contributor.\n            refund = msg.value.sub(cost);\n        }\n\n        totalTokensSold = totalTokensSold.add(tokensBought);\n\n        // Transfer tokens to the account\n        require(tokenContract.transfer(msg.sender, tokensBought));\n\n        // Issue a ETH refund for any unused portion of the funds.\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n\n        // Transfer the contribution to the wallet\n        wallet.transfer(msg.value.sub(refund));\n\n        TokensPurchased(msg.sender, cost, tokensBought);\n\n        // If all tokens available for sale have been sold out, finalize the sale automatically.\n        if (totalTokensSold == TOKENS_SALE) {\n            finalizeInternal();\n        }\n\n        return true;\n    }\n\n\n    //\n    // PRESALES\n    //\n\n    // Allows the admin to record pre-sales, before the public sale starts. Presale base tokens come out of the\n    // main sale pool (the 30% allocation) while bonus tokens come from the remaining token pool.\n    function addPresale(address _account, uint256 _baseTokens, uint256 _bonusTokens) external onlyAdmin onlyBeforeSale returns (bool) {\n        require(_account != address(0));\n\n        // Presales may have 0 bonus tokens but need to have a base amount of tokens sold.\n        require(_baseTokens > 0);\n        require(_bonusTokens < _baseTokens);\n\n        // We do not count bonus tokens as part of the sale cap.\n        totalTokensSold = totalTokensSold.add(_baseTokens);\n        require(totalTokensSold <= TOKENS_SALE);\n\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\n        require(_baseTokens <= ownBalance);\n\n        totalPresaleBase  = totalPresaleBase.add(_baseTokens);\n        totalPresaleBonus = totalPresaleBonus.add(_bonusTokens);\n\n        // Move base tokens to the trustee\n        require(tokenContract.transfer(address(trusteeContract), _baseTokens));\n\n        // Presale allocations are marked as locked, they cannot be removed by the owner.\n        uint256 tokens = _baseTokens.add(_bonusTokens);\n        require(trusteeContract.grantAllocation(_account, tokens, false /* revokable */));\n\n        PresaleAdded(_account, _baseTokens, _bonusTokens);\n\n        return true;\n    }\n\n\n    //\n    // PAUSE / UNPAUSE\n    //\n\n    // Allows the owner or admin to pause the sale for any reason.\n    function pause() public onlyAdmin whenNotPaused {\n        require(hasSaleEnded() == false);\n\n        pausedTime = currentTime();\n\n        return super.pause();\n    }\n\n\n    // Unpause may extend the end time of the public sale.\n    // Note that we do not extend the start time of each phase.\n    // Currently does not extend phase 1 end time, only final end time.\n    function unpause() public onlyAdmin whenPaused {\n\n        // If owner unpauses before sale starts, no impact on end time.\n        uint256 current = currentTime();\n\n        // If owner unpauses after sale starts, calculate how to extend end.\n        if (current > PHASE1_START_TIME) {\n            uint256 timeDelta;\n\n            if (pausedTime < PHASE1_START_TIME) {\n                // Pause was triggered before the start time, extend by time that\n                // passed from proposed start time until now.\n                timeDelta = current.sub(PHASE1_START_TIME);\n            } else {\n                // Pause was triggered while the sale was already started.\n                // Extend end time by amount of time since pause.\n                timeDelta = current.sub(pausedTime);\n            }\n\n            endTime = endTime.add(timeDelta);\n        }\n\n        pausedTime = 0;\n\n        return super.unpause();\n    }\n\n\n    // Allows the admin to reclaim all tokens assigned to the sale contract.\n    // This should only be used in case of emergency.\n    function reclaimTokens() external onlyAdmin returns (bool) {\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\n\n        require(tokenContract.transfer(owner, ownBalance));\n\n        TokensReclaimed(ownBalance);\n\n        return true;\n    }\n\n\n    // Allows the admin to finalize the sale and complete allocations.\n    // The owner will also need to finalize the token contract so that\n    // token transfers are enabled.\n    function finalize() external onlyAdmin returns (bool) {\n        return finalizeInternal();\n    }\n\n\n    // The internal one will be called if tokens are sold out or\n    // the end time for the sale is reached, in addition to being called\n    // from the public version of finalize().\n    function finalizeInternal() private returns (bool) {\n        require(!finalized);\n\n        finalized = true;\n\n        Finalized();\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/TokenSale.sol",
      "content": "pragma solidity ^0.4.17;\n\n// ----------------------------------------------------------------------------\n// Simple Token - Token Sale Implementation\n//\n// Copyright (c) 2017 Simple Token and Enuma Technologies.\n// http://www.simpletoken.com/\n//\n// The MIT Licence.\n// ----------------------------------------------------------------------------\n\n\nimport \"./SimpleToken.sol\";\nimport \"./Trustee.sol\";\nimport \"./TokenSaleConfig.sol\";\nimport \"./OpsManaged.sol\";\nimport \"./Pausable.sol\";\nimport \"./SafeMath.sol\";\n\n\n//\n// Implementation of the 1st token sale for Simple Token\n//\n// * Lifecycle *\n// Initialization sequence should be as follow:\n//    1. Deploy SimpleToken contract\n//    2. Deploy Trustee contract\n//    3. Deploy TokenSale contract\n//    4. Set operationsAddress of SimpleToken contract to TokenSale contract\n//    5. Set operationsAddress of Trustee contract to TokenSale contract\n//    6. Set operationsAddress of TokenSale contract to some address\n//    7. Transfer tokens from owner to TokenSale contract\n//    8. Transfer tokens from owner to Trustee contract\n//    9. Initialize TokenSale contract\n//\n// Pre-sale sequence:\n//    - Set tokensPerKEther\n//    - Set phase1AccountTokensMax\n//    - Add presales\n//    - Add allocations for founders, advisors, etc.\n//    - Update whitelist\n//\n// After-sale sequence:\n//    1. Finalize the TokenSale contract\n//    2. Finalize the SimpleToken contract\n//    3. Set operationsAddress of TokenSale contract to 0\n//    4. Set operationsAddress of SimpleToken contract to 0\n//    5. Set operationsAddress of Trustee contract to some address\n//\n// Anytime\n//    - Add/Remove allocations\n//\n\n//\n// Permissions, according to the ST key management specification.\n//\n//                                Owner    Admin   Ops\n// initialize                       x\n// changeWallet                              x\n// updateWhitelist                                  x\n// setTokensPerKEther                        x\n// setPhase1AccountTokensMax                 x\n// addPresale                                x\n// pause / unpause                           x\n// reclaimTokens                             x\n// finalize                                  x\n//\n\ncontract TokenSale is OpsManaged, Pausable, TokenSaleConfig { // Pausable is also Owned\n\n    using SafeMath for uint256;\n\n    // We keep track of whether the sale has been finalized, at which point\n    // no additional contributions will be permitted.\n    bool public finalized;\n\n    // The sale end time is initially defined by the END_TIME constant but it\n    // may get extended if the sale is paused.\n    uint256 public endTime;\n    uint256 public pausedTime;\n\n    // Number of tokens per 1000 ETH. See TokenSaleConfig for details.\n    uint256 public tokensPerKEther;\n\n    // Keeps track of the maximum amount of tokens that an account is allowed to purchase in phase 1.\n    uint256 public phase1AccountTokensMax;\n\n    // Address where the funds collected during the sale will be forwarded.\n    address public wallet;\n\n    // Token contract that the sale contract will interact with.\n    SimpleToken public tokenContract;\n\n    // Trustee contract to hold on token balances. The following token pools will be held by trustee:\n    //    - Founders\n    //    - Advisors\n    //    - Early investors\n    //    - Presales\n    Trustee public trusteeContract;\n\n    // Total amount of tokens sold during presale + public sale. Excludes pre-sale bonuses.\n    uint256 public totalTokensSold;\n\n    // Total amount of tokens given as bonus during presale. Will influence accelerator token balance.\n    uint256 public totalPresaleBase;\n    uint256 public totalPresaleBonus;\n\n    // Map of addresses that have been whitelisted in advance (and passed KYC).\n    // The whitelist value indicates what phase (1 or 2) the address has been whitelisted for.\n    // Addresses whitelisted for phase 1 can also contribute during phase 2.\n    mapping(address => uint8) public whitelist;\n\n\n    //\n    // EVENTS\n    //\n    event Initialized();\n    event PresaleAdded(address indexed _account, uint256 _baseTokens, uint256 _bonusTokens);\n    event WhitelistUpdated(address indexed _account, uint8 _phase);\n    event TokensPurchased(address indexed _beneficiary, uint256 _cost, uint256 _tokens);\n    event TokensPerKEtherUpdated(uint256 _amount);\n    event Phase1AccountTokensMaxUpdated(uint256 _tokens);\n    event WalletChanged(address _newWallet);\n    event TokensReclaimed(uint256 _amount);\n    event Finalized();\n\n\n    function TokenSale(SimpleToken _tokenContract, Trustee _trusteeContract, address _wallet) public\n        OpsManaged()\n    {\n        require(address(_tokenContract) != address(0));\n        require(address(_trusteeContract) != address(0));\n        require(_wallet != address(0));\n\n        require(PHASE1_START_TIME >= currentTime());\n        require(PHASE2_START_TIME > PHASE1_START_TIME);\n        require(END_TIME > PHASE2_START_TIME);\n        require(TOKENS_PER_KETHER > 0);\n        require(PHASE1_ACCOUNT_TOKENS_MAX > 0);\n\n        // Basic check that the constants add up to TOKENS_MAX\n        uint256 partialAllocations = TOKENS_FOUNDERS.add(TOKENS_ADVISORS).add(TOKENS_EARLY_INVESTORS);\n        require(partialAllocations.add(TOKENS_SALE).add(TOKENS_ACCELERATOR_MAX).add(TOKENS_FUTURE) == TOKENS_MAX);\n\n        wallet                 = _wallet;\n        pausedTime             = 0;\n        endTime                = END_TIME;\n        finalized              = false;\n        tokensPerKEther        = TOKENS_PER_KETHER;\n        phase1AccountTokensMax = PHASE1_ACCOUNT_TOKENS_MAX;\n\n        tokenContract   = _tokenContract;\n        trusteeContract = _trusteeContract;\n    }\n\n\n    // Initialize is called to link the sale token with the token contract.\n    // It expects that a certain amount of tokens have already been assigned to the sale contract address.\n    function initialize() external onlyOwner returns (bool) {\n        require(totalTokensSold == 0);\n        require(totalPresaleBase == 0);\n        require(totalPresaleBonus == 0);\n\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\n        require(ownBalance == TOKENS_SALE);\n\n        // Simple check to confirm that tokens are present\n        uint256 trusteeBalance = tokenContract.balanceOf(address(trusteeContract));\n        require(trusteeBalance >= TOKENS_FUTURE);\n\n        Initialized();\n\n        return true;\n    }\n\n\n    // Allows the admin to change the wallet where ETH contributions are sent.\n    function changeWallet(address _wallet) external onlyAdmin returns (bool) {\n        require(_wallet != address(0));\n        require(_wallet != address(this));\n        require(_wallet != address(trusteeContract));\n        require(_wallet != address(tokenContract));\n\n        wallet = _wallet;\n\n        WalletChanged(wallet);\n\n        return true;\n    }\n\n\n\n   //\n   // TIME\n   //\n\n    function currentTime() public view returns (uint256 _currentTime) {\n        return now;\n    }\n\n\n    modifier onlyBeforeSale() {\n        require(hasSaleEnded() == false);\n        require(currentTime() < PHASE1_START_TIME);\n       _;\n    }\n\n\n    modifier onlyDuringSale() {\n        require(hasSaleEnded() == false && currentTime() >= PHASE1_START_TIME);\n        _;\n    }\n\n\n    function hasSaleEnded() private view returns (bool) {\n        if (totalTokensSold >= TOKENS_SALE || currentTime() >= endTime || finalized) {\n            return true;\n        }\n\n        return false;\n    }\n\n\n\n    //\n    // WHITELIST\n    //\n\n    // Allows ops to add accounts to the whitelist.\n    // Only those accounts will be allowed to contribute during the sale.\n    // _phase = 1: Can contribute during phases 1 and 2 of the sale.\n    // _phase = 2: Can contribute during phase 2 of the sale only.\n    // _phase = 0: Cannot contribute at all (not whitelisted).\n    function updateWhitelist(address _account, uint8 _phase) external onlyOps returns (bool) {\n        require(_account != address(0));\n        require(_phase <= 2);\n        require(hasSaleEnded() == false);\n\n        whitelist[_account] = _phase;\n\n        WhitelistUpdated(_account, _phase);\n\n        return true;\n    }\n\n\n\n    //\n    // PURCHASES / CONTRIBUTIONS\n    //\n\n    // Allows the admin to set the price for tokens sold during phases 1 and 2 of the sale.\n    function setTokensPerKEther(uint256 _tokensPerKEther) external onlyAdmin onlyBeforeSale returns (bool) {\n        require(_tokensPerKEther > 0);\n\n        tokensPerKEther = _tokensPerKEther;\n\n        TokensPerKEtherUpdated(_tokensPerKEther);\n\n        return true;\n    }\n\n\n    // Allows the admin to set the maximum amount of tokens that an account can buy during phase 1 of the sale.\n    function setPhase1AccountTokensMax(uint256 _tokens) external onlyAdmin onlyBeforeSale returns (bool) {\n        require(_tokens > 0);\n\n        phase1AccountTokensMax = _tokens;\n\n        Phase1AccountTokensMaxUpdated(_tokens);\n\n        return true;\n    }\n\n\n    function () external payable whenNotPaused onlyDuringSale {\n        buyTokens();\n    }\n\n\n    // This is the main function to process incoming ETH contributions.\n    function buyTokens() public payable whenNotPaused onlyDuringSale returns (bool) {\n        require(msg.value >= CONTRIBUTION_MIN);\n        require(msg.value <= CONTRIBUTION_MAX);\n        require(totalTokensSold < TOKENS_SALE);\n\n        // All accounts need to be whitelisted to purchase.\n        uint8 whitelistedPhase = whitelist[msg.sender];\n        require(whitelistedPhase > 0);\n\n        uint256 tokensMax = TOKENS_SALE.sub(totalTokensSold);\n\n        if (currentTime() < PHASE2_START_TIME) {\n            // We are in phase 1 of the sale\n            require(whitelistedPhase == 1);\n\n            uint256 accountBalance = tokenContract.balanceOf(msg.sender);\n\n            // Can only purchase up to a maximum per account.\n            tokensMax = phase1AccountTokensMax.sub(accountBalance);\n        }\n\n        require(tokensMax > 0);\n\n        uint256 tokensBought = msg.value.mul(tokensPerKEther).div(10**(18 - uint256(TOKEN_DECIMALS) + 3));\n        require(tokensBought > 0);\n\n        uint256 cost = msg.value;\n        uint256 refund = 0;\n\n        if (tokensBought > tokensMax) {\n            // Not enough tokens available for full contribution, we will do partial.\n            tokensBought = tokensMax;\n\n            // Calculate actual cost for partial amount of tokens.\n            cost = tokensBought.mul(10**(18 - uint256(TOKEN_DECIMALS) + 3)).div(tokensPerKEther);\n\n            // Calculate refund for contributor.\n            refund = msg.value.sub(cost);\n        }\n\n        totalTokensSold = totalTokensSold.add(tokensBought);\n\n        // Transfer tokens to the account\n        require(tokenContract.transfer(msg.sender, tokensBought));\n\n        // Issue a ETH refund for any unused portion of the funds.\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n\n        // Transfer the contribution to the wallet\n        wallet.transfer(msg.value.sub(refund));\n\n        TokensPurchased(msg.sender, cost, tokensBought);\n\n        // If all tokens available for sale have been sold out, finalize the sale automatically.\n        if (totalTokensSold == TOKENS_SALE) {\n            finalizeInternal();\n        }\n\n        return true;\n    }\n\n\n    //\n    // PRESALES\n    //\n\n    // Allows the admin to record pre-sales, before the public sale starts. Presale base tokens come out of the\n    // main sale pool (the 30% allocation) while bonus tokens come from the remaining token pool.\n    function addPresale(address _account, uint256 _baseTokens, uint256 _bonusTokens) external onlyAdmin onlyBeforeSale returns (bool) {\n        require(_account != address(0));\n\n        // Presales may have 0 bonus tokens but need to have a base amount of tokens sold.\n        require(_baseTokens > 0);\n        require(_bonusTokens < _baseTokens);\n\n        // We do not count bonus tokens as part of the sale cap.\n        totalTokensSold = totalTokensSold.add(_baseTokens);\n        require(totalTokensSold <= TOKENS_SALE);\n\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\n        require(_baseTokens <= ownBalance);\n\n        totalPresaleBase  = totalPresaleBase.add(_baseTokens);\n        totalPresaleBonus = totalPresaleBonus.add(_bonusTokens);\n\n        // Move base tokens to the trustee\n        require(tokenContract.transfer(address(trusteeContract), _baseTokens));\n\n        // Presale allocations are marked as locked, they cannot be removed by the owner.\n        uint256 tokens = _baseTokens.add(_bonusTokens);\n        require(trusteeContract.grantAllocation(_account, tokens, false /* revokable */));\n\n        PresaleAdded(_account, _baseTokens, _bonusTokens);\n\n        return true;\n    }\n\n\n    //\n    // PAUSE / UNPAUSE\n    //\n\n    // Allows the owner or admin to pause the sale for any reason.\n    function pause() public onlyAdmin whenNotPaused {\n        require(hasSaleEnded() == false);\n\n        pausedTime = currentTime();\n\n        return super.pause();\n    }\n\n\n    // Unpause may extend the end time of the public sale.\n    // Note that we do not extend the start time of each phase.\n    // Currently does not extend phase 1 end time, only final end time.\n    function unpause() public onlyAdmin whenPaused {\n\n        // If owner unpauses before sale starts, no impact on end time.\n        uint256 current = currentTime();\n\n        // If owner unpauses after sale starts, calculate how to extend end.\n        if (current > PHASE1_START_TIME) {\n            uint256 timeDelta;\n\n            if (pausedTime < PHASE1_START_TIME) {\n                // Pause was triggered before the start time, extend by time that\n                // passed from proposed start time until now.\n                timeDelta = current.sub(PHASE1_START_TIME);\n            } else {\n                // Pause was triggered while the sale was already started.\n                // Extend end time by amount of time since pause.\n                timeDelta = current.sub(pausedTime);\n            }\n\n            endTime = endTime.add(timeDelta);\n        }\n\n        pausedTime = 0;\n\n        return super.unpause();\n    }\n\n\n    // Allows the admin to reclaim all tokens assigned to the sale contract.\n    // This should only be used in case of emergency.\n    function reclaimTokens() external onlyAdmin returns (bool) {\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\n\n        require(tokenContract.transfer(owner, ownBalance));\n\n        TokensReclaimed(ownBalance);\n\n        return true;\n    }\n\n\n    // Allows the admin to finalize the sale and complete allocations.\n    // The owner will also need to finalize the token contract so that\n    // token transfers are enabled.\n    function finalize() external onlyAdmin returns (bool) {\n        return finalizeInternal();\n    }\n\n\n    // The internal one will be called if tokens are sold out or\n    // the end time for the sale is reached, in addition to being called\n    // from the public version of finalize().\n    function finalizeInternal() private returns (bool) {\n        require(!finalized);\n\n        finalized = true;\n\n        Finalized();\n\n        return true;\n    }\n}"
    }
  ]
}