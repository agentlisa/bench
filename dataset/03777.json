{
  "Title": "[M10] Updating storage variables could soft-brick the protocol",
  "Content": "The `Implementation` contract has the [`setRegistry`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/common/Implementation.sol#L73) function which is used to update the address of the `Registry` contract in all contracts that inherit from the `Implementation` contract, such as the [`ReserveAccessors` contract](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveState.sol#L264) contract or the [`StabilizerAccessors` contract](hhttps://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/stabilizer/StabilizerState.sol#L334).\n\n\nIn [Line 78](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/common/Implementation.sol#L78) of the same function, the require statements force either:\n\n\n* To have not set the `registry` address yet.\n* That the new `Registry` which is going to be set, has the same `timelock` address of the old `Registry` contract.\n\n\nThe `Registry` contract is owned by the `Timelock` contract, that executes transaction to set addresses on the `Registry` contract on behalf of the governance.\n\n\nAll the setter functions from the `Registry` contract are lacking from input validation, so it is possible, by mistakenly executing a bad proposal, to set the `Timelock` contract’s address in the `Registry` contract to an erroneous address (either an EOA or another contract).\n\n\nIf this happens, the `setRegistry` function of the `Implementation` contract will revert at any call trying to update the `Registry` contract’s address, freezing entirely the functionality.\n\n\nConsider validating that the `timelock` address is a valid contract address whenever it is set in the `Registry` contract. This can be done using the [OpenZeppelin `Address.isContract` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L26) or eventually, consider also implementing the [`EIP1820`](https://eips.ethereum.org/EIPS/eip-1820) for this use case.\n\n\n***Update**: Fixed on [pull request 12](https://github.com/emptysetsquad/emptyset/pull/12/commits/ea224acc113732075610c382d2dec6c738f8aac2).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/common/Implementation.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces.sol\";\nimport \"./IImplementation.sol\";\n\n/**\n * @title Implementation\n * @notice Common functions and accessors across upgradeable, ownable contracts\n */\ncontract Implementation is IImplementation {\n\n    /**\n     * @dev Storage slot with the address of the current implementation\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n     */\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Storage slot with the admin of the contract\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n     */\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    // UPGRADEABILITY\n\n    /**\n     * @notice Returns the current implementation\n     * @return Address of the current implementation\n     */\n    function implementation() external view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @notice Returns the current proxy admin contract\n     * @return Address of the current proxy admin contract\n     */\n    function admin() external view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    // REGISTRY\n\n    /**\n     * @notice Updates the registry contract\n     * @dev Owner only - governance hook\n     *      If registry is already set, the new registry's timelock must match the current's\n     * @param newRegistry New registry contract\n     */\n    function setRegistry(address newRegistry) external onlyOwner {\n        IRegistry registry = registry();\n\n        require(newRegistry != address(0), \"Implementation: zero address\");\n        require(\n            address(registry) == address(0) || IRegistry(newRegistry).timelock() == registry.timelock(),\n            \"Implementation: timelocks must match\"\n        );\n\n        _setRegistry(newRegistry);\n\n        emit RegistryUpdate(newRegistry);\n    }\n\n    // OWNER\n\n    /**\n     * @notice Takes ownership over a contract if none has been set yet\n     * @dev Needs to be called initialize ownership after deployment\n     *      Ensure that this has been properly set before using the protocol\n     */\n    function takeOwnership() external {\n        require(owner() == address(0), \"Implementation: already initialized\");\n\n        _setOwner(msg.sender);\n\n        emit OwnerUpdate(msg.sender);\n    }\n\n    /**\n     * @notice Updates the owner contract\n     * @dev Owner only - governance hook\n     * @param newOwner New owner contract\n     */\n    function setOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Implementation: zero address\");\n\n        _setOwner(newOwner);\n\n        emit OwnerUpdate(newOwner);\n    }\n\n    /**\n     * @dev Only allow when the caller is the owner address\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner(), \"Implementation: not owner\");\n\n        _;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/common/Implementation.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../Interfaces.sol\";\nimport \"./IImplementation.sol\";\n\n/**\n * @title Implementation\n * @notice Common functions and accessors across upgradeable, ownable contracts\n */\ncontract Implementation is IImplementation {\n\n    /**\n     * @dev Storage slot with the address of the current implementation\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n     */\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Storage slot with the admin of the contract\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1\n     */\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    // UPGRADEABILITY\n\n    /**\n     * @notice Returns the current implementation\n     * @return Address of the current implementation\n     */\n    function implementation() external view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @notice Returns the current proxy admin contract\n     * @return Address of the current proxy admin contract\n     */\n    function admin() external view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    // REGISTRY\n\n    /**\n     * @notice Updates the registry contract\n     * @dev Owner only - governance hook\n     *      If registry is already set, the new registry's timelock must match the current's\n     * @param newRegistry New registry contract\n     */\n    function setRegistry(address newRegistry) external onlyOwner {\n        IRegistry registry = registry();\n\n        require(newRegistry != address(0), \"Implementation: zero address\");\n        require(\n            address(registry) == address(0) || IRegistry(newRegistry).timelock() == registry.timelock(),\n            \"Implementation: timelocks must match\"\n        );\n\n        _setRegistry(newRegistry);\n\n        emit RegistryUpdate(newRegistry);\n    }\n\n    // OWNER\n\n    /**\n     * @notice Takes ownership over a contract if none has been set yet\n     * @dev Needs to be called initialize ownership after deployment\n     *      Ensure that this has been properly set before using the protocol\n     */\n    function takeOwnership() external {\n        require(owner() == address(0), \"Implementation: already initialized\");\n\n        _setOwner(msg.sender);\n\n        emit OwnerUpdate(msg.sender);\n    }\n\n    /**\n     * @notice Updates the owner contract\n     * @dev Owner only - governance hook\n     * @param newOwner New owner contract\n     */\n    function setOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Implementation: zero address\");\n\n        _setOwner(newOwner);\n\n        emit OwnerUpdate(newOwner);\n    }\n\n    /**\n     * @dev Only allow when the caller is the owner address\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner(), \"Implementation: not owner\");\n\n        _;\n    }\n}"
    },
    {
      "filename": "contracts/utils/Address.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}"
    }
  ]
}