{
  "Title": "Unused `PausableUpgradeable::CannotRenounceWhilePaused` error should be removed",
  "Content": "[`PausableUpgradeable::CannotRenounceWhilePaused`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/PausableUpgradeable.sol#L50-L53) is a custom error defined as follows:\n```solidity\n/**\n * @dev Cannot renounce the pauser capability when the contract is in the `PAUSED` state\n */\nerror CannotRenounceWhilePaused(address account);\n```\nThe above error and inline comments imply that the pauser capability cannot be transferred when a contract is in a `PAUSED` state. However, no such check is performed in `PausableOwnable::transferPauserCapability`:\n\n```solidity\n/**\n * @dev Transfers the ability to pause to a new account (`newPauser`).\n */\nfunction transferPauserCapability(address newPauser) public virtual onlyOwnerOrPauser {\n    PauserStorage storage $ = _getPauserStorage();\n    address oldPauser = $._pauser;\n    $._pauser = newPauser;\n    emit PauserTransferred(oldPauser, newPauser);\n}\n```\n\nGiven that it is understood this is not an error of omission, where stated functionality is not implemented in the function, but rather an unused custom error that is not intended to be used, it is recommended that the definition be removed.\n\n**Wormhole Foundation:** Fixed in [PR \\#244](https://github.com/wormhole-foundation/example-native-token-transfers/pull/244).\n\n**Cyfrin:** Verified. The unused error has been removed.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/libraries/PausableUpgradeable.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\n/**\n * @dev Contact Module that allows children to implement logic to pause and unpause the contract.\n * This is based on the OpenZeppelin Pausable contract but makes use of deterministic storage slots\n * and the EVM native word size to optimize gas costs.\n *\n * The `whenPaused` and `whenNotPaused` modifiers are used to\n * execute code based on the current state of the contract.\n *\n */\nimport {Initializable} from \"./external/Initializable.sol\";\n\nabstract contract PausableUpgradeable is Initializable {\n    /*\n     * @custom:storage-location erc7201:openzeppelin.storage.Pausable.\n     * @dev Storage slot with the pauser account, this is managed by the `PauserStorage` struct\n    */\n    struct PauserStorage {\n        address _pauser;\n    }\n\n    // @dev Storage slot with the pause flag, this is managed by the `PauseStorage` struct\n    struct PauseStorage {\n        uint256 _pauseFlag;\n    }\n\n    /// NOTE: use uint256 to save on gas because it is the native word size of the EVM\n    /// it is cheaper than using a bool because modifying a boolean value requires an extra SLOAD\n    uint256 private constant NOT_PAUSED = 1;\n    uint256 private constant PAUSED = 2;\n\n    event PauserTransferred(address indexed oldPauser, address indexed newPauser);\n\n    /**\n     * @dev Contract is not paused, functionality is unblocked\n     */\n    error RequireContractIsNotPaused();\n    /**\n     * @dev Contract state is paused, blocking\n     */\n    error RequireContractIsPaused();\n\n    /**\n     * @dev the pauser is not a valid pauser account (e.g. `address(0)`)\n     */\n    error InvalidPauser(address account);\n\n    /**\n     * @dev Cannot renounce the pauser capability when the contract is in the `PAUSED` state\n     */\n    error CannotRenounceWhilePaused(address account);\n\n    // @dev Emitted when the contract is paused\n    event Paused(bool paused);\n    event NotPaused(bool notPaused);\n\n    bytes32 private constant PAUSE_SLOT = bytes32(uint256(keccak256(\"Pause.pauseFlag\")) - 1);\n    bytes32 private constant PAUSER_ROLE_SLOT = bytes32(uint256(keccak256(\"Pause.pauseRole\")) - 1);\n\n    function _getPauserStorage() internal pure returns (PauserStorage storage $) {\n        uint256 slot = uint256(PAUSER_ROLE_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns the current pauser account address.\n     */\n    function pauser() public view returns (address) {\n        return _getPauserStorage()._pauser;\n    }\n\n    function _getPauseStorage() private pure returns (PauseStorage storage $) {\n        uint256 slot = uint256(PAUSE_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    function _setPauseStorage(uint256 pauseFlag) internal {\n        _getPauseStorage()._pauseFlag = pauseFlag;\n    }\n\n    function __Paused_init(address initialPauser) internal onlyInitializing {\n        __Paused_init_unchained(initialPauser);\n    }\n\n    function __Paused_init_unchained(address initialPauser) internal onlyInitializing {\n        // set pause flag to false initially\n        PauseStorage storage $ = _getPauseStorage();\n        $._pauseFlag = NOT_PAUSED;\n\n        // set the initial pauser\n        PauserStorage storage $_role = _getPauserStorage();\n        $_role._pauser = initialPauser;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     * Calling a function when this flag is set to `PAUSED` will cause the transaction to revert.\n     */\n    modifier whenNotPaused() {\n        if (isPaused()) {\n            revert RequireContractIsNotPaused();\n        }\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     * Calling a function when this flag is set to `PAUSED` will cause the transaction to revert.\n     */\n    modifier whenPaused() {\n        if (!isPaused()) {\n            revert RequireContractIsPaused();\n        }\n        _;\n    }\n\n    /*\n     * @dev Modifier to allow only the Pauser to access pausing functionality\n     */\n    modifier onlyPauser() {\n        _checkPauser();\n        _;\n    }\n\n    /*\n     * @dev Modifier to allow only the Pauser to access some functionality\n     */\n    function _checkPauser() internal view {\n        if (pauser() != msg.sender) {\n            revert InvalidPauser(msg.sender);\n        }\n    }\n\n    /**\n     * @dev pauses the function and emits the `Paused` event\n     */\n    function _pause() internal virtual whenNotPaused {\n        // this can only be set to PAUSED when the state is NOTPAUSED\n        _setPauseStorage(PAUSED);\n        emit Paused(true);\n    }\n\n    /**\n     * @dev unpauses the function\n     */\n    function _unpause() internal virtual whenPaused {\n        // this can only be set to NOTPAUSED when the state is PAUSED\n        _setPauseStorage(NOT_PAUSED);\n        emit NotPaused(false);\n    }\n\n    /**\n     * @dev Returns true if the method is paused, and false otherwise.\n     */\n    function isPaused() public view returns (bool) {\n        PauseStorage storage $ = _getPauseStorage();\n        return $._pauseFlag == PAUSED;\n    }\n}"
    }
  ]
}