{
  "Title": "M-3: There may be excess funds in the PnL pool or bad debt due to the funding fee.",
  "Content": "# Issue M-3: There may be excess funds in the PnL pool or bad debt due to the funding fee. \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/102 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nether\\_sky\n## Summary\nThere are two types of `makers`: `OracleMaker` and `SpotHedgeBaseMaker`, where `LPs` can deposit funds.\n`Traders` can then execute their `orders` against these `makers`.\nTo incentivize `LPs`, several mechanisms exist for these `makers` to profit.\nOne is the `borrowing fee`, which both `makers` can benefit from.\nAnother is the `funding fee`, which specifically benefits `OracleMaker`.\nThe `funding fee` incentivizes users to maintain `positions` with the same direction of `OracleMaker`.\nHowever, due to the `funding fee`, there may be excess funds in the `PnL pool` or occurrences of `bad debt`.\n## Vulnerability Detail\nTypically, in most `protocols`, the generated `yields` are totally distributed to users and the `protocol` itself.\nIn the `Perpetual` protocol, all `borrowing fees` from `payers` are solely distributed to `receivers`, which are whitelisted by the `protocol`.\nHowever, not all `funding fees` are distributed, or there may be a lack of `funding fees` available for distribution.\nThe current `funding rate` is determined based on the current `position` of the `base pool`(`OracleMaker`).\n```solidity\nfunction getCurrentFundingRate(uint256 marketId) public view returns (int256) {\n    uint256 fundingRateAbs = FixedPointMathLib.fullMulDiv(\n        fundingConfig.fundingFactor,\n        FixedPointMathLib\n            .powWad(openNotionalAbs.toInt256(), fundingConfig.fundingExponentFactor.toInt256())\n            .toUint256(),\n        maxCapacity\n    );\n}\n```\nHolders of `positions` with the same direction of the `position` of the `OracleMaker` receive `funding fees`, while those with `positions` in the opposite direction are required to pay `funding fees`.\nThe amount of `funding fees` generated per second is calculated as the product of the `funding rate` and the sum of `openNotionals` of `positions` with the opposite direction.\nConversely, the amount of `funding fees` distributed per second is calculated as the product of the `funding rate` and the sum of `openNotionls` of `positions` with the same direction of the `position` of the `OracleMaker`.\n```solidity\nfunction getPendingFee(uint256 marketId, address trader) public view returns (int256) {\n    int256 fundingRate = getCurrentFundingRate(marketId);\n    int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +\n        (fundingRate * int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]));\n    int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n    int256 fundingFee = 0;\n    if (openNotional != 0) {\n        fundingFee = _calcFundingFee(\n            openNotional,\n            fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n        );   // @audit, here\n    }\n    return fundingFee;\n}\n```\nAll `orders` are settled against `makers`, meaning for every `long position`, there should be an equivalent `short position`.\nWhile we might expect the sum of `openNotionals` of `long positions` to be equal to the `openNotionals` of `short positions`, in reality, they may differ.\n\nSuppose there are two `long positions` with `openNotional` values of `S` and `S/2`.\nThen there should be two `short positions` with `openNotianal` values of `-S` and `-S/2`.\nIf the holder of the first `long position` cancels his `order` against the second `short position` with `-S/2`, the `openNotional` of the `long position` becomes `0`, and the second `short position` becomes a `long position`.\nHowever, we can not be certain that the `openNotional` of the new `long position` is exactly `S/2`.\n```solidity\nfunction add(Position storage self, int256 positionSizeDelta, int256 openNotionalDelta) internal returns (int256) {\n    int256 openNotional = self.openNotional;\n    int256 positionSize = self.positionSize;\n\n    bool isLong = positionSizeDelta > 0;\n    int256 realizedPnl = 0;\n\n    // new or increase position\n    if (positionSize == 0 || (positionSize > 0 && isLong) || (positionSize < 0 && !isLong)) {\n        // no old pos size = new position\n        // direction is same as old pos = increase position\n    } else {\n        // openNotionalDelta and oldOpenNotional have different signs = reduce, close or reverse position\n        // check if it's reduce or close by comparing absolute position size\n        // if reduce\n        // realizedPnl = oldOpenNotional * closedRatio + openNotionalDelta\n        // closedRatio = positionSizeDeltaAbs / positionSizeAbs\n        // if close and increase reverse position\n        // realizedPnl = oldOpenNotional + openNotionalDelta * closedPositionSize / positionSizeDelta\n        uint256 positionSizeDeltaAbs = positionSizeDelta.abs();\n        uint256 positionSizeAbs = positionSize.abs();\n\n        if (positionSizeAbs >= positionSizeDeltaAbs) {\n            // reduce or close position\n            int256 reducedOpenNotional = (openNotional * positionSizeDeltaAbs.toInt256()) /\n                positionSizeAbs.toInt256();\n            realizedPnl = reducedOpenNotional + openNotionalDelta;\n        } else {\n            // open reverse position\n            realizedPnl =\n                openNotional +\n                (openNotionalDelta * positionSizeAbs.toInt256()) /\n                positionSizeDeltaAbs.toInt256();\n        }\n    }\n\n    self.positionSize += positionSizeDelta;\n    self.openNotional += openNotionalDelta - realizedPnl;\n\n    return realizedPnl;\n}\n```\nIndeed, the `openNotional` of the new `long position` is determined by the current `price`.\nConsequently, while the `position size` of this new `long position` will be the same with the old second `long position` with an `openNotional` value of `S/2`, the `openNotional` of the new `long position` can indeed vary from `S/2`.\nAs a result, the sum of `openNotionals` of `short positions` can differ from the sum of `long positions`.\nThere are numerous other scenarios where the sums of `openNotionals` may vary.\n\nI believe that the developers also thought that the `funding fees` are totally used between it's `payers` and `receivers` from the below code.\n```solidity\n/// @notice positive -> pay funding fee -> fundingFee should round up\n/// negative -> receive funding fee -> -fundingFee should round down\nfunction _calcFundingFee(int256 openNotional, int256 deltaGrowthIndex) internal pure returns (int256) {\n    if (openNotional * deltaGrowthIndex > 0) {\n        return int256(FixedPointMathLib.fullMulDivUp(openNotional.abs(), deltaGrowthIndex.abs(), WAD));\n    } else {\n        return (openNotional * deltaGrowthIndex) / WAD.toInt256();\n    }\n}\n```\nThey even took `rounding` into serious consideration to prevent any shortfall of `funding fees` for distribution.\n## Impact\nExcess `funding fees` in the `PnL pool` can arise when the sum of `openNotionals` of the `payers` exceeds that of the `receivers`.\nConversely, `bad debt` may occur in other cases, leading to a situation where users are unable to receive their `funding fees` due to an insufficient `PnL pool`.\nIt is worth to note that other `yields`, such as the `borrowing fee`, are entirely utilized between it's `payers` and `receivers`.\nTherefore, there are no additional `funding sources` available to address any shortages of `funding fees`.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/fundingFee/FundingFee.sol#L133-L139\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/fundingFee/FundingFee.sol#L89-L102\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/vault/LibPosition.sol#L45-L48\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/fundingFee/FundingFee.sol#L183-L191\n## Tool used\n\nManual Review\n\n## Recommendation\nWe can calculate `funding fees` based on the `position size` because the sum of the `position sizes` of `long positions` will always be equal to the sum of `short positions` in all cases.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n**takarez** commented:\n>  valid; medium(8)\n\n\n\n**vinta**\n\nConfirmed, this is valid. Thanks for finding this bug!\n\nWe're still figuring out a fix, or we might probably just disable fundingFee entirely if we cannot solve it before launch.\n\n**etherSky111**\n\nEscalate\n\nI think this is a `high` risk issue.\nThis has a `high likelihood` of occurrence, as it can happen easily.\nThe impact is also `high` due to the absence of `available funding sources` in case of `bad debt`. \nConsequently, users' `margins` and `borrowing fees` will be reduced.\n\nAnd the sponsor has confirmed their intention to disable this feature if a suitable solution is not found.\nThis shows the severity of the impact.\n\nAnyway, this is my first contest in Sherlock and am not familiar with the rules.\nI hope for a kind review.\nThanks in advance.\n\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I think this is a `high` risk issue.\n> This has a `high likelihood` of occurrence, as it can happen easily.\n> The impact is also `high` due to the absence of `available funding sources` in case of `bad debt`. \n> Consequently, users' `margins` and `borrowing fees` will be reduced.\n> \n> And the sponsor has confirmed their intention to disable this feature if a suitable solution is not found.\n> This shows the severity of the impact.\n> \n> Anyway, this is my first contest in Sherlock and am not familiar with the rules.\n> I hope for a kind review.\n> Thanks in advance.\n> \n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**etherSky111**\n\nHi @nevillehuang , thanks for your judging.\n\nI need assistance with escalation, as I couldn't create it.\nWhat do I need to do for this?\n\nThanks.\n\n**GTH1235**\n\nEscalate\n\nI think this is a high risk issue.\nThis has a high likelihood of occurrence, as it can happen easily.\nThe impact is also high due to the absence of available funding sources in case of bad debt.\nConsequently, users' margins and borrowing fees will be reduced.\n\nAnd the sponsor has confirmed their intention to disable this feature if a suitable solution is not found.\nThis shows the severity of the impact.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I think this is a high risk issue.\n> This has a high likelihood of occurrence, as it can happen easily.\n> The impact is also high due to the absence of available funding sources in case of bad debt.\n> Consequently, users' margins and borrowing fees will be reduced.\n> \n> And the sponsor has confirmed their intention to disable this feature if a suitable solution is not found.\n> This shows the severity of the impact.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\n`There may be` meaning it won't necessarily happen (i.e. Medium). The funding fee does not cause bad debt, it just temporarily causes there to be fewer funds in the pool than expected. As soon as the funding flips to the other side, it's likely to be remedied without any intervention at all (as is indicated by the fact that the title begins with `There may be excess funds`). The readme says `PnL Pool currently starts empty, so a trader with realized gains may experience temporary illiquidity when he tries to withdraw those gains. This inconvenience will be mitigated in the future with a buffer balance` so the pool is expected to have temporary liquidity problems for traders, which are expected to be mitigated. There is no bad debt being created here.\n\n**etherSky111**\n\nLet's change `There may be` to `There should be`.\nIn cases where the opposite open notional is larger, there should be `bad debt`. \nThe `PnL pool` involves the user's `margin` and `borrowing fees`. \nWhen users withdraw their `funding fees`, it is deducted from the `PnL pool`, which involves the user's `margin` and `borrowing fees`.\nAnd `As soon as the funding flips to the other side,`: this is just assumption.\nIf we evaluate things in this manner, the likelihood of most issues will be very low.\n\n**nevillehuang**\n\n@etherSky111 @IllIllI000 How often can this situation of excess funds occur?\n\n**etherSky111**\n\nThis situation can easily happen (The `likelihood` is really high).\n\nThere are `2` possible states.\n`1`. The opposite `open notional` is larger.\n`2`. vice versa\n\nIn case 1, there will be `bad debts` due to there are more `receivers` than `payers`.\nUsers' `PnL`, `borrowing fees` and `funding fees` are settled through `PnL pool`.\nIf there are `X bad debts` in `funding fees`, these will be deducted from `PnL pool` which includes users' `PnL` and `borrowing fees`.\n\nIt's important to note that there's no guarantee that the market will swiftly transition from the first case to the second.\nIt will disrupt the equilibrium of the `market`.\n\nThanks. \n\n**IllIllI000**\n\nThere is no bad debt created. Bad debt is when a specific user has losses that are greater than the margin collateral backing the position, which means it will _never_ be paid back and the system as a whole will have a loss forever. In this case, it's a temporary liquidity deficit that will be resolved when the opposite side becomes the larger open notional. As I've pointed out [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/102#issuecomment-2041451118), according to the readme, it's _expected_ that there are temporary liquidity deficits, so _that is not a security risk_. The only thing broken here is that the sponsor though that only trader PnL could cause the temporary deficit, but with this issue, the funding fee can cause it too.\n\n**etherSky111**\n\nAre you sure 100%?\n```\nwhen the opposite side becomes the larger open notional.\n```\nAs I said earlier, this is just an assumption.\n\n**IllIllI000**\n\nThere has never been a perpetuals market, where the funding fee stayed only on one side. The whole point of the fee is to incentivize people to open positions on the other side of the market in order to make the futures price equal the spot price, at which point the fee rate will become zero again, and then there will be a random walk of orders coming in, which will randomly choose the next side with the larger open notional.\n\n**etherSky111**\n\nEnsuring that the sum of `funding fees` aligns with `0` is not guaranteed.\nAnd this is not a `temporary liquidity deficits`.\nThis deficit is based on the fact that the sum of `borrowing fees` and users' `PnL` equal `0`.\n\nAs a newcomer to `Sherlock`, I'm unfamiliar with the rules, so I'll leave it to the judge to decide, and I'll respect his decision.\n\nThank you.\n\n**nevillehuang**\n\nBased on discussions, I believe medium severity is appropriate for this issue.\n\n**WangSecurity**\n\nAgree with the Lead Judge, Medium is indeed appropriate here due to requirement of specific state. Hence, planning to reject the escalation and leave the issue as it is.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [GTH1235](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/102/#issuecomment-2039586410): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/fundingFee/FundingFee.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { WAD } from \"../common/LibConstant.sol\";\nimport { FundingConfig } from \"../config/FundingConfig.sol\";\nimport { OracleMaker } from \"../maker/OracleMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IFundingFee } from \"./IFundingFee.sol\";\n\ncontract FundingFee is AddressResolverUpgradeable, IFundingFee {\n    using SafeCast for *;\n    using FixedPointMathLib for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.fundingFee\n    struct FundingFeeStorage {\n        // key: marketId, value: fundingGrowthLongIndex\n        mapping(uint256 => int256) fundingGrowthLongIndexMap;\n        // key: marketId, value: lastUpdatedTimestamp\n        mapping(uint256 => uint256) lastUpdatedTimestampMap;\n        mapping(uint256 => mapping(address => int256)) lastFundingGrowthLongIndexMap;\n    }\n\n    event FundingFeeSettled(uint256 marketId, address trader, int256 fundingFee);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.fundingFee\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _FUNDING_FEE_STORAGE_LOCATION = 0x67af2bbd5c68531270a033011670248db9cc70016659ba644098886bbb018000;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyVault() {\n        if (msg.sender != address(_getVault())) revert LibError.Unauthorized();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n    }\n\n    //\n    // EXTERNAL\n    //\n\n    /// @inheritdoc IFundingFee\n    function beforeUpdateMargin(uint256 marketId, address trader) external onlyVault returns (int256) {\n        _updateFundingGrowthIndex(marketId);\n        int256 fundingFee = _settleFundingFee(marketId, trader);\n        return fundingFee;\n    }\n\n    /// @inheritdoc IFundingFee\n    function beforeSettlePosition(\n        uint256 marketId,\n        address taker,\n        address maker\n    ) external onlyVault returns (int256, int256) {\n        _updateFundingGrowthIndex(marketId);\n        int256 takerFundingFee = _settleFundingFee(marketId, taker);\n        int256 makerFundingFee = _settleFundingFee(marketId, maker);\n        return (takerFundingFee, makerFundingFee);\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    /// @inheritdoc IFundingFee\n    function getPendingFee(uint256 marketId, address trader) public view returns (int256) {\n        int256 fundingRate = getCurrentFundingRate(marketId);\n        int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +\n            (fundingRate * int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]));\n        int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n        int256 fundingFee = 0;\n        if (openNotional != 0) {\n            fundingFee = _calcFundingFee(\n                openNotional,\n                fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n            );\n        }\n        return fundingFee;\n    }\n\n    function getCurrentFundingRate(uint256 marketId) public view returns (int256) {\n        Config config = getAddressManager().getConfig();\n        FundingConfig memory fundingConfig = config.getFundingConfig(marketId);\n\n        if (fundingConfig.basePool == address(0)) {\n            return 0;\n        }\n\n        int256 openNotional = _getVault().getOpenNotional(marketId, fundingConfig.basePool);\n        if (openNotional == 0) {\n            return 0;\n        }\n\n        uint256 openNotionalAbs = openNotional.abs();\n        bool isBasePoolLong = openNotional < 0;\n\n        // we can only use margin without pendingMargin as totalDepositedAmount\n        // since pendingMargin includes pending borrowingFee and fundingFee,\n        // it will be infinite loop dependency\n        uint256 totalDepositedAmount = uint256(_getVault().getSettledMargin(marketId, fundingConfig.basePool));\n        uint256 maxCapacity = FixedPointMathLib.divWad(\n            totalDepositedAmount,\n            uint256(OracleMaker(fundingConfig.basePool).minMarginRatio())\n        );\n\n        // maxCapacity = basePool.totalDepositedAmount / basePool.minMarginRatio\n        // imbalanceRatio = basePool.openNotional^fundingExponentFactor / maxCapacity\n        // fundingRate = fundingFactor * imbalanceRatio\n        // funding = trader.openNotional * fundingRate * deltaTimeInSeconds\n        uint256 fundingRateAbs = FixedPointMathLib.fullMulDiv(\n            fundingConfig.fundingFactor,\n            FixedPointMathLib\n                .powWad(openNotionalAbs.toInt256(), fundingConfig.fundingExponentFactor.toInt256())\n                .toUint256(),\n            maxCapacity\n        );\n\n        // positive -> basePool is long -> receive funding for long position, pay funding for short position\n        // negative -> basePool is short -> receive funding for short position, pay funding for long position,\n        int256 fundingRate = isBasePoolLong ? int256(fundingRateAbs) : -int256(fundingRateAbs);\n        return fundingRate;\n    }\n\n    //\n    // INTERNAL\n    //\n\n    function _updateFundingGrowthIndex(uint256 marketId) internal {\n        int256 fundingRate = getCurrentFundingRate(marketId);\n        // index increase -> receive funding\n        // index reduce   -> pay funding\n        _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +=\n            fundingRate *\n            int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]);\n        _getFundingFeeStorage().lastUpdatedTimestampMap[marketId] = block.timestamp;\n    }\n\n    /// @dev caller must ensure _updateFundingGrowthIndex() is called before calling this function\n    function _settleFundingFee(uint256 marketId, address trader) internal returns (int256) {\n        int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId];\n        int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n        int256 fundingFee = 0;\n        if (openNotional != 0) {\n            fundingFee = _calcFundingFee(\n                openNotional,\n                fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n            );\n        }\n        _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader] = _getFundingFeeStorage()\n            .fundingGrowthLongIndexMap[marketId];\n\n        emit FundingFeeSettled(marketId, trader, fundingFee);\n        return fundingFee;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    /// @notice positive -> pay funding fee -> fundingFee should round up\n    /// negative -> receive funding fee -> -fundingFee should round down\n    function _calcFundingFee(int256 openNotional, int256 deltaGrowthIndex) internal pure returns (int256) {\n        if (openNotional * deltaGrowthIndex > 0) {\n            return int256(FixedPointMathLib.fullMulDivUp(openNotional.abs(), deltaGrowthIndex.abs(), WAD));\n        } else {\n            return (openNotional * deltaGrowthIndex) / WAD.toInt256();\n        }\n    }\n\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    function _getFundingFeeStorage() private pure returns (FundingFeeStorage storage $) {\n        assembly {\n            $.slot := _FUNDING_FEE_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/fundingFee/FundingFee.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { WAD } from \"../common/LibConstant.sol\";\nimport { FundingConfig } from \"../config/FundingConfig.sol\";\nimport { OracleMaker } from \"../maker/OracleMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IFundingFee } from \"./IFundingFee.sol\";\n\ncontract FundingFee is AddressResolverUpgradeable, IFundingFee {\n    using SafeCast for *;\n    using FixedPointMathLib for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.fundingFee\n    struct FundingFeeStorage {\n        // key: marketId, value: fundingGrowthLongIndex\n        mapping(uint256 => int256) fundingGrowthLongIndexMap;\n        // key: marketId, value: lastUpdatedTimestamp\n        mapping(uint256 => uint256) lastUpdatedTimestampMap;\n        mapping(uint256 => mapping(address => int256)) lastFundingGrowthLongIndexMap;\n    }\n\n    event FundingFeeSettled(uint256 marketId, address trader, int256 fundingFee);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.fundingFee\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _FUNDING_FEE_STORAGE_LOCATION = 0x67af2bbd5c68531270a033011670248db9cc70016659ba644098886bbb018000;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyVault() {\n        if (msg.sender != address(_getVault())) revert LibError.Unauthorized();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n    }\n\n    //\n    // EXTERNAL\n    //\n\n    /// @inheritdoc IFundingFee\n    function beforeUpdateMargin(uint256 marketId, address trader) external onlyVault returns (int256) {\n        _updateFundingGrowthIndex(marketId);\n        int256 fundingFee = _settleFundingFee(marketId, trader);\n        return fundingFee;\n    }\n\n    /// @inheritdoc IFundingFee\n    function beforeSettlePosition(\n        uint256 marketId,\n        address taker,\n        address maker\n    ) external onlyVault returns (int256, int256) {\n        _updateFundingGrowthIndex(marketId);\n        int256 takerFundingFee = _settleFundingFee(marketId, taker);\n        int256 makerFundingFee = _settleFundingFee(marketId, maker);\n        return (takerFundingFee, makerFundingFee);\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    /// @inheritdoc IFundingFee\n    function getPendingFee(uint256 marketId, address trader) public view returns (int256) {\n        int256 fundingRate = getCurrentFundingRate(marketId);\n        int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +\n            (fundingRate * int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]));\n        int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n        int256 fundingFee = 0;\n        if (openNotional != 0) {\n            fundingFee = _calcFundingFee(\n                openNotional,\n                fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n            );\n        }\n        return fundingFee;\n    }\n\n    function getCurrentFundingRate(uint256 marketId) public view returns (int256) {\n        Config config = getAddressManager().getConfig();\n        FundingConfig memory fundingConfig = config.getFundingConfig(marketId);\n\n        if (fundingConfig.basePool == address(0)) {\n            return 0;\n        }\n\n        int256 openNotional = _getVault().getOpenNotional(marketId, fundingConfig.basePool);\n        if (openNotional == 0) {\n            return 0;\n        }\n\n        uint256 openNotionalAbs = openNotional.abs();\n        bool isBasePoolLong = openNotional < 0;\n\n        // we can only use margin without pendingMargin as totalDepositedAmount\n        // since pendingMargin includes pending borrowingFee and fundingFee,\n        // it will be infinite loop dependency\n        uint256 totalDepositedAmount = uint256(_getVault().getSettledMargin(marketId, fundingConfig.basePool));\n        uint256 maxCapacity = FixedPointMathLib.divWad(\n            totalDepositedAmount,\n            uint256(OracleMaker(fundingConfig.basePool).minMarginRatio())\n        );\n\n        // maxCapacity = basePool.totalDepositedAmount / basePool.minMarginRatio\n        // imbalanceRatio = basePool.openNotional^fundingExponentFactor / maxCapacity\n        // fundingRate = fundingFactor * imbalanceRatio\n        // funding = trader.openNotional * fundingRate * deltaTimeInSeconds\n        uint256 fundingRateAbs = FixedPointMathLib.fullMulDiv(\n            fundingConfig.fundingFactor,\n            FixedPointMathLib\n                .powWad(openNotionalAbs.toInt256(), fundingConfig.fundingExponentFactor.toInt256())\n                .toUint256(),\n            maxCapacity\n        );\n\n        // positive -> basePool is long -> receive funding for long position, pay funding for short position\n        // negative -> basePool is short -> receive funding for short position, pay funding for long position,\n        int256 fundingRate = isBasePoolLong ? int256(fundingRateAbs) : -int256(fundingRateAbs);\n        return fundingRate;\n    }\n\n    //\n    // INTERNAL\n    //\n\n    function _updateFundingGrowthIndex(uint256 marketId) internal {\n        int256 fundingRate = getCurrentFundingRate(marketId);\n        // index increase -> receive funding\n        // index reduce   -> pay funding\n        _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +=\n            fundingRate *\n            int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]);\n        _getFundingFeeStorage().lastUpdatedTimestampMap[marketId] = block.timestamp;\n    }\n\n    /// @dev caller must ensure _updateFundingGrowthIndex() is called before calling this function\n    function _settleFundingFee(uint256 marketId, address trader) internal returns (int256) {\n        int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId];\n        int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n        int256 fundingFee = 0;\n        if (openNotional != 0) {\n            fundingFee = _calcFundingFee(\n                openNotional,\n                fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n            );\n        }\n        _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader] = _getFundingFeeStorage()\n            .fundingGrowthLongIndexMap[marketId];\n\n        emit FundingFeeSettled(marketId, trader, fundingFee);\n        return fundingFee;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    /// @notice positive -> pay funding fee -> fundingFee should round up\n    /// negative -> receive funding fee -> -fundingFee should round down\n    function _calcFundingFee(int256 openNotional, int256 deltaGrowthIndex) internal pure returns (int256) {\n        if (openNotional * deltaGrowthIndex > 0) {\n            return int256(FixedPointMathLib.fullMulDivUp(openNotional.abs(), deltaGrowthIndex.abs(), WAD));\n        } else {\n            return (openNotional * deltaGrowthIndex) / WAD.toInt256();\n        }\n    }\n\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    function _getFundingFeeStorage() private pure returns (FundingFeeStorage storage $) {\n        assembly {\n            $.slot := _FUNDING_FEE_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/vault/LibPosition.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { LibLugiaMath } from \"../common/LugiaMath.sol\";\nimport { Position } from \"./PositionModelStruct.sol\";\n\nlibrary LibPosition {\n    using SafeCast for uint256;\n    using FixedPointMathLib for int256;\n    using LibPosition for Position;\n\n    /// @notice update both positionSize and openNotional\n    /// @return realizedPnl\n    function add(Position storage self, int256 positionSizeDelta, int256 openNotionalDelta) internal returns (int256) {\n        int256 openNotional = self.openNotional;\n        int256 positionSize = self.positionSize;\n\n        bool isLong = positionSizeDelta > 0;\n        int256 realizedPnl = 0;\n\n        // new or increase position\n        if (positionSize == 0 || (positionSize > 0 && isLong) || (positionSize < 0 && !isLong)) {\n            // no old pos size = new position\n            // direction is same as old pos = increase position\n        } else {\n            // openNotionalDelta and oldOpenNotional have different signs = reduce, close or reverse position\n            // check if it's reduce or close by comparing absolute position size\n            // if reduce\n            // realizedPnl = oldOpenNotional * closedRatio + openNotionalDelta\n            // closedRatio = positionSizeDeltaAbs / positionSizeAbs\n            // if close and increase reverse position\n            // realizedPnl = oldOpenNotional + openNotionalDelta * closedPositionSize / positionSizeDelta\n            uint256 positionSizeDeltaAbs = positionSizeDelta.abs();\n            uint256 positionSizeAbs = positionSize.abs();\n\n            if (positionSizeAbs >= positionSizeDeltaAbs) {\n                // reduce or close position\n                int256 reducedOpenNotional = (openNotional * positionSizeDeltaAbs.toInt256()) /\n                    positionSizeAbs.toInt256();\n                realizedPnl = reducedOpenNotional + openNotionalDelta;\n            } else {\n                // open reverse position\n                realizedPnl =\n                    openNotional +\n                    (openNotionalDelta * positionSizeAbs.toInt256()) /\n                    positionSizeDeltaAbs.toInt256();\n            }\n        }\n\n        self.positionSize += positionSizeDelta;\n        self.openNotional += openNotionalDelta - realizedPnl;\n\n        return realizedPnl;\n    }\n\n    function updateMargin(Position storage self, int256 delta) internal {\n        self.margin = LibLugiaMath.applyDelta(self.margin, delta);\n    }\n\n    //\n    // PURE\n    //\n\n    /// @notice Reverse position (eg. long 1 -> short 1) is not reduce only\n    function isReduceOnly(int256 positionSizeBefore, int256 positionSizeAfter) internal pure returns (bool) {\n        if (positionSizeAfter != 0 && positionSizeBefore ^ positionSizeAfter < 0) {\n            return false;\n        }\n        return positionSizeBefore.abs() > positionSizeAfter.abs();\n    }\n\n    function isIncreasing(int256 positionSizeBefore, int256 positionSizeDelta) internal pure returns (bool) {\n        bool isOldPositionLong = positionSizeBefore > 0;\n        bool isLong = positionSizeDelta > 0;\n        return positionSizeBefore == 0 || (isOldPositionLong && isLong) || (!isOldPositionLong && !isLong);\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/fundingFee/FundingFee.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { WAD } from \"../common/LibConstant.sol\";\nimport { FundingConfig } from \"../config/FundingConfig.sol\";\nimport { OracleMaker } from \"../maker/OracleMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IFundingFee } from \"./IFundingFee.sol\";\n\ncontract FundingFee is AddressResolverUpgradeable, IFundingFee {\n    using SafeCast for *;\n    using FixedPointMathLib for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.fundingFee\n    struct FundingFeeStorage {\n        // key: marketId, value: fundingGrowthLongIndex\n        mapping(uint256 => int256) fundingGrowthLongIndexMap;\n        // key: marketId, value: lastUpdatedTimestamp\n        mapping(uint256 => uint256) lastUpdatedTimestampMap;\n        mapping(uint256 => mapping(address => int256)) lastFundingGrowthLongIndexMap;\n    }\n\n    event FundingFeeSettled(uint256 marketId, address trader, int256 fundingFee);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.fundingFee\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _FUNDING_FEE_STORAGE_LOCATION = 0x67af2bbd5c68531270a033011670248db9cc70016659ba644098886bbb018000;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyVault() {\n        if (msg.sender != address(_getVault())) revert LibError.Unauthorized();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n    }\n\n    //\n    // EXTERNAL\n    //\n\n    /// @inheritdoc IFundingFee\n    function beforeUpdateMargin(uint256 marketId, address trader) external onlyVault returns (int256) {\n        _updateFundingGrowthIndex(marketId);\n        int256 fundingFee = _settleFundingFee(marketId, trader);\n        return fundingFee;\n    }\n\n    /// @inheritdoc IFundingFee\n    function beforeSettlePosition(\n        uint256 marketId,\n        address taker,\n        address maker\n    ) external onlyVault returns (int256, int256) {\n        _updateFundingGrowthIndex(marketId);\n        int256 takerFundingFee = _settleFundingFee(marketId, taker);\n        int256 makerFundingFee = _settleFundingFee(marketId, maker);\n        return (takerFundingFee, makerFundingFee);\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    /// @inheritdoc IFundingFee\n    function getPendingFee(uint256 marketId, address trader) public view returns (int256) {\n        int256 fundingRate = getCurrentFundingRate(marketId);\n        int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +\n            (fundingRate * int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]));\n        int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n        int256 fundingFee = 0;\n        if (openNotional != 0) {\n            fundingFee = _calcFundingFee(\n                openNotional,\n                fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n            );\n        }\n        return fundingFee;\n    }\n\n    function getCurrentFundingRate(uint256 marketId) public view returns (int256) {\n        Config config = getAddressManager().getConfig();\n        FundingConfig memory fundingConfig = config.getFundingConfig(marketId);\n\n        if (fundingConfig.basePool == address(0)) {\n            return 0;\n        }\n\n        int256 openNotional = _getVault().getOpenNotional(marketId, fundingConfig.basePool);\n        if (openNotional == 0) {\n            return 0;\n        }\n\n        uint256 openNotionalAbs = openNotional.abs();\n        bool isBasePoolLong = openNotional < 0;\n\n        // we can only use margin without pendingMargin as totalDepositedAmount\n        // since pendingMargin includes pending borrowingFee and fundingFee,\n        // it will be infinite loop dependency\n        uint256 totalDepositedAmount = uint256(_getVault().getSettledMargin(marketId, fundingConfig.basePool));\n        uint256 maxCapacity = FixedPointMathLib.divWad(\n            totalDepositedAmount,\n            uint256(OracleMaker(fundingConfig.basePool).minMarginRatio())\n        );\n\n        // maxCapacity = basePool.totalDepositedAmount / basePool.minMarginRatio\n        // imbalanceRatio = basePool.openNotional^fundingExponentFactor / maxCapacity\n        // fundingRate = fundingFactor * imbalanceRatio\n        // funding = trader.openNotional * fundingRate * deltaTimeInSeconds\n        uint256 fundingRateAbs = FixedPointMathLib.fullMulDiv(\n            fundingConfig.fundingFactor,\n            FixedPointMathLib\n                .powWad(openNotionalAbs.toInt256(), fundingConfig.fundingExponentFactor.toInt256())\n                .toUint256(),\n            maxCapacity\n        );\n\n        // positive -> basePool is long -> receive funding for long position, pay funding for short position\n        // negative -> basePool is short -> receive funding for short position, pay funding for long position,\n        int256 fundingRate = isBasePoolLong ? int256(fundingRateAbs) : -int256(fundingRateAbs);\n        return fundingRate;\n    }\n\n    //\n    // INTERNAL\n    //\n\n    function _updateFundingGrowthIndex(uint256 marketId) internal {\n        int256 fundingRate = getCurrentFundingRate(marketId);\n        // index increase -> receive funding\n        // index reduce   -> pay funding\n        _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +=\n            fundingRate *\n            int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]);\n        _getFundingFeeStorage().lastUpdatedTimestampMap[marketId] = block.timestamp;\n    }\n\n    /// @dev caller must ensure _updateFundingGrowthIndex() is called before calling this function\n    function _settleFundingFee(uint256 marketId, address trader) internal returns (int256) {\n        int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId];\n        int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n        int256 fundingFee = 0;\n        if (openNotional != 0) {\n            fundingFee = _calcFundingFee(\n                openNotional,\n                fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n            );\n        }\n        _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader] = _getFundingFeeStorage()\n            .fundingGrowthLongIndexMap[marketId];\n\n        emit FundingFeeSettled(marketId, trader, fundingFee);\n        return fundingFee;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    /// @notice positive -> pay funding fee -> fundingFee should round up\n    /// negative -> receive funding fee -> -fundingFee should round down\n    function _calcFundingFee(int256 openNotional, int256 deltaGrowthIndex) internal pure returns (int256) {\n        if (openNotional * deltaGrowthIndex > 0) {\n            return int256(FixedPointMathLib.fullMulDivUp(openNotional.abs(), deltaGrowthIndex.abs(), WAD));\n        } else {\n            return (openNotional * deltaGrowthIndex) / WAD.toInt256();\n        }\n    }\n\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    function _getFundingFeeStorage() private pure returns (FundingFeeStorage storage $) {\n        assembly {\n            $.slot := _FUNDING_FEE_STORAGE_LOCATION\n        }\n    }\n}"
    }
  ]
}