{
  "Title": "[L02] Constants not explicitly declared",
  "Content": "Throughout the codebase there are many occurrences of literal values being used with unexplained meaning. This makes areas of the code more difficult to understand. Some examples include:\n\n\n* The ‘maximum integer’ `uint(-1)` used throughout the codebase.\n* The acceptable range of [`1e18` to `1.5e18`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/oracle/AggregatorOracle.sol#L60) used in `AggregatorOracle`.\n* Many literal values used [throughout `_optimalDepositA`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/spell/UniswapV2SpellV1.sol#L82-L89) to calculate optimal uniswap values.\n* The literal `2**112` used throughout the contracts.\n* The literal `10000` used throughout `ProxyOracle`.\n\n\nLiteral values in the codebase without an explanation as to their meaning make the code harder to read, understand, and maintain for developers, auditors and external contributors alike. Consider defining a `constant` variable for every literal value used and giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended.\n\n\n***Update:** Partially fixed in [PR#98](https://github.com/AlphaFinanceLab/homora-v2/pull/98). Alpha added constant variables to address the second point above, but have decided to leave the others as they are.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracle/AggregatorOracle.sol",
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\n\nimport '../Governable.sol';\nimport '../../interfaces/IBaseOracle.sol';\n\ncontract AggregatorOracle is IBaseOracle, Governable {\n  using SafeMath for uint;\n\n  event SetPrimarySource(address indexed token, uint maxPriceDeviation, IBaseOracle[] oracles);\n\n  mapping(address => uint) public primarySourceCount; // Mapping from token to number of sources\n  mapping(address => mapping(uint => IBaseOracle)) public primarySources; // Mapping from token to (mapping from index to oracle source)\n  mapping(address => uint) public maxPriceDeviations; // Mapping from token to max price deviation (in bps)\n\n  constructor() public {\n    __Governable__init();\n  }\n\n  /// @dev Set oracle primary sources for the token\n  /// @param token Token address to set oracle sources\n  /// @param maxPriceDeviation Max price deviation (in bps) for token\n  /// @param sources Oracle sources for the token\n  function setPrimarySources(\n    address token,\n    uint maxPriceDeviation,\n    IBaseOracle[] memory sources\n  ) external onlyGov {\n    _setPrimarySources(token, maxPriceDeviation, sources);\n  }\n\n  /// @dev Set oracle primary sources for multiple tokens\n  /// @param tokens List of token addresses to set oracle sources\n  /// @param maxPriceDeviationList List of max price deviations (in bps) for tokens\n  /// @param allSources List of oracle sources for tokens\n  function setMultiPrimarySources(\n    address[] memory tokens,\n    uint[] memory maxPriceDeviationList,\n    IBaseOracle[][] memory allSources\n  ) external onlyGov {\n    require(tokens.length == allSources.length, 'inconsistent length');\n    require(tokens.length == maxPriceDeviationList.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      _setPrimarySources(tokens[idx], maxPriceDeviationList[idx], allSources[idx]);\n    }\n  }\n\n  /// @dev Set oracle primary sources for tokens\n  /// @param token Token to set oracle sources\n  /// @param maxPriceDeviation Max price deviation (in bps) for token\n  /// @param sources Oracle sources for the token\n  function _setPrimarySources(\n    address token,\n    uint maxPriceDeviation,\n    IBaseOracle[] memory sources\n  ) internal {\n    primarySourceCount[token] = sources.length;\n    require(maxPriceDeviation >= 1e18 && maxPriceDeviation <= 1.5e18, 'bad max deviation value');\n    maxPriceDeviations[token] = maxPriceDeviation;\n    for (uint idx = 0; idx < sources.length; idx++) {\n      primarySources[token][idx] = sources[idx];\n    }\n    emit SetPrimarySource(token, maxPriceDeviation, sources);\n  }\n\n  /// @dev Return token price relative to ETH, multiplied by 2**112\n  /// @param token Token to get price of\n  /// NOTE: Support at most 3 oracle sources per token\n  function getETHPx(address token) external view override returns (uint) {\n    uint candidateSourceCount = primarySourceCount[token];\n    require(candidateSourceCount > 0, 'no primary source');\n    uint[] memory prices = new uint[](candidateSourceCount);\n\n    // Get valid oracle sources\n    uint validSourceCount = 0;\n    for (uint idx = 0; idx < candidateSourceCount; idx++) {\n      try primarySources[token][idx].getETHPx(token) returns (uint px) {\n        prices[validSourceCount++] = px;\n      } catch {}\n    }\n    require(validSourceCount > 0, 'no valid source');\n    for (uint i = 0; i < validSourceCount - 1; i++) {\n      for (uint j = 0; j < validSourceCount - i - 1; j++) {\n        if (prices[j] > prices[j + 1]) {\n          (prices[j], prices[j + 1]) = (prices[j + 1], prices[j]);\n        }\n      }\n    }\n    uint maxPriceDeviation = maxPriceDeviations[token];\n    require(maxPriceDeviation >= 1e18 && maxPriceDeviation <= 1.5e18, 'bad max deviation value');\n\n    // Algo:\n    // - 1 valid source --> return price\n    // - 2 valid sources\n    //     --> if the prices within deviation threshold, return average\n    //     --> else revert\n    // - 3 valid sources --> check deviation threshold of each pair\n    //     --> if all within threshold, return median\n    //     --> if one pair within threshold, return average of the pair\n    //     --> if none, revert\n    // - revert otherwise\n    if (validSourceCount == 1) {\n      return prices[0]; // if 1 valid source, return\n    } else if (validSourceCount == 2) {\n      require(\n        prices[1].mul(1e18) / prices[0] <= maxPriceDeviation,\n        'too much deviation (2 valid sources)'\n      );\n      return prices[0].add(prices[1]) / 2; // if 2 valid sources, return average\n    } else if (validSourceCount == 3) {\n      bool midMinOk = prices[1].mul(1e18) / prices[0] <= maxPriceDeviation;\n      bool maxMidOk = prices[2].mul(1e18) / prices[1] <= maxPriceDeviation;\n      if (midMinOk && maxMidOk) {\n        return prices[1]; // if 3 valid sources, and each pair is within thresh, return median\n      } else if (midMinOk) {\n        return prices[0].add(prices[1]) / 2; // return average of pair within thresh\n      } else if (maxMidOk) {\n        return prices[1].add(prices[2]) / 2; // return average of pair within thresh\n      } else {\n        revert('too much deviation (3 valid sources)');\n      }\n    } else {\n      revert('more than 3 valid sources not supported');\n    }\n  }\n}"
    },
    {
      "filename": "contracts/spell/UniswapV2SpellV1.sol",
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\n\nimport './WhitelistSpell.sol';\nimport '../utils/HomoraMath.sol';\nimport '../../interfaces/IUniswapV2Factory.sol';\nimport '../../interfaces/IUniswapV2Router02.sol';\nimport '../../interfaces/IUniswapV2Pair.sol';\nimport '../../interfaces/IWStakingRewards.sol';\n\ncontract UniswapV2SpellV1 is WhitelistSpell {\n  using SafeMath for uint;\n  using HomoraMath for uint;\n\n  IUniswapV2Factory public immutable factory; // Uniswap factory\n  IUniswapV2Router02 public immutable router; // Uniswap router\n\n  mapping(address => mapping(address => address)) public pairs; // Mapping from tokenA to (mapping from tokenB to LP token)\n\n  constructor(\n    IBank _bank,\n    address _werc20,\n    IUniswapV2Router02 _router\n  ) public WhitelistSpell(_bank, _werc20, _router.WETH()) {\n    router = _router;\n    factory = IUniswapV2Factory(_router.factory());\n  }\n\n  /// @dev Return the LP token for the token pairs (can be in any order)\n  /// @param tokenA Token A to get LP token\n  /// @param tokenB Token B to get LP token\n  function getPair(address tokenA, address tokenB) public returns (address) {\n    address lp = pairs[tokenA][tokenB];\n    if (lp == address(0)) {\n      lp = factory.getPair(tokenA, tokenB);\n      require(lp != address(0), 'no lp token');\n      ensureApprove(tokenA, address(router));\n      ensureApprove(tokenB, address(router));\n      ensureApprove(lp, address(router));\n      pairs[tokenA][tokenB] = lp;\n      pairs[tokenB][tokenA] = lp;\n    }\n    return lp;\n  }\n\n  /// @dev Compute optimal deposit amount\n  /// @param amtA amount of token A desired to deposit\n  /// @param amtB amount of token B desired to deposit\n  /// @param resA amount of token A in reserve\n  /// @param resB amount of token B in reserve\n  function optimalDeposit(\n    uint amtA,\n    uint amtB,\n    uint resA,\n    uint resB\n  ) internal pure returns (uint swapAmt, bool isReversed) {\n    if (amtA.mul(resB) >= amtB.mul(resA)) {\n      swapAmt = _optimalDepositA(amtA, amtB, resA, resB);\n      isReversed = false;\n    } else {\n      swapAmt = _optimalDepositA(amtB, amtA, resB, resA);\n      isReversed = true;\n    }\n  }\n\n  /// @dev Compute optimal deposit amount helper.\n  /// @param amtA amount of token A desired to deposit\n  /// @param amtB amount of token B desired to deposit\n  /// @param resA amount of token A in reserve\n  /// @param resB amount of token B in reserve\n  /// Formula: https://blog.alphafinance.io/byot/\n  function _optimalDepositA(\n    uint amtA,\n    uint amtB,\n    uint resA,\n    uint resB\n  ) internal pure returns (uint) {\n    require(amtA.mul(resB) >= amtB.mul(resA), 'Reversed');\n    uint a = 997;\n    uint b = uint(1997).mul(resA);\n    uint _c = (amtA.mul(resB)).sub(amtB.mul(resA));\n    uint c = _c.mul(1000).div(amtB.add(resB)).mul(resA);\n    uint d = a.mul(c).mul(4);\n    uint e = HomoraMath.sqrt(b.mul(b).add(d));\n    uint numerator = e.sub(b);\n    uint denominator = a.mul(2);\n    return numerator.div(denominator);\n  }\n\n  struct Amounts {\n    uint amtAUser; // Supplied tokenA amount\n    uint amtBUser; // Supplied tokenB amount\n    uint amtLPUser; // Supplied LP token amount\n    uint amtABorrow; // Borrow tokenA amount\n    uint amtBBorrow; // Borrow tokenB amount\n    uint amtLPBorrow; // Borrow LP token amount\n    uint amtAMin; // Desired tokenA amount (slippage control)\n    uint amtBMin; // Desired tokenB amount (slippage control)\n  }\n\n  /// @dev Add liquidity to Uniswap pool\n  /// @param tokenA Token A for the pair\n  /// @param tokenB Token B for the pair\n  /// @param amt Amounts of tokens to supply, borrow, and get.\n  function addLiquidityInternal(\n    address tokenA,\n    address tokenB,\n    Amounts calldata amt\n  ) internal {\n    address lp = getPair(tokenA, tokenB);\n    require(whitelistedLpTokens[lp], 'lp token not whitelisted');\n\n    // 1. Get user input amounts\n    doTransmitETH();\n    doTransmit(tokenA, amt.amtAUser);\n    doTransmit(tokenB, amt.amtBUser);\n    doTransmit(lp, amt.amtLPUser);\n\n    // 2. Borrow specified amounts\n    doBorrow(tokenA, amt.amtABorrow);\n    doBorrow(tokenB, amt.amtBBorrow);\n    doBorrow(lp, amt.amtLPBorrow);\n\n    // 3. Calculate optimal swap amount\n    uint swapAmt;\n    bool isReversed;\n    {\n      uint amtA = IERC20(tokenA).balanceOf(address(this));\n      uint amtB = IERC20(tokenB).balanceOf(address(this));\n      uint resA;\n      uint resB;\n      if (IUniswapV2Pair(lp).token0() == tokenA) {\n        (resA, resB, ) = IUniswapV2Pair(lp).getReserves();\n      } else {\n        (resB, resA, ) = IUniswapV2Pair(lp).getReserves();\n      }\n      (swapAmt, isReversed) = optimalDeposit(amtA, amtB, resA, resB);\n    }\n\n    // 4. Swap optimal amount\n    if (swapAmt > 0) {\n      address[] memory path = new address[](2);\n      (path[0], path[1]) = isReversed ? (tokenB, tokenA) : (tokenA, tokenB);\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), now);\n    }\n\n    // 5. Add liquidity\n    uint balA = IERC20(tokenA).balanceOf(address(this));\n    uint balB = IERC20(tokenB).balanceOf(address(this));\n    if (balA > 0 || balB > 0) {\n      router.addLiquidity(tokenA, tokenB, balA, balB, amt.amtAMin, amt.amtBMin, address(this), now);\n    }\n  }\n\n  /// @dev Add liquidity to Uniswap pool, with no staking rewards (use WERC20 wrapper)\n  /// @param tokenA Token A for the pair\n  /// @param tokenB Token B for the pair\n  /// @param amt Amounts of tokens to supply, borrow, and get.\n  function addLiquidityWERC20(\n    address tokenA,\n    address tokenB,\n    Amounts calldata amt\n  ) external payable {\n    address lp = getPair(tokenA, tokenB);\n    // 1-5. add liquidity\n    addLiquidityInternal(tokenA, tokenB, amt);\n\n    // 6. Put collateral\n    doPutCollateral(lp, IERC20(lp).balanceOf(address(this)));\n\n    // 7. Refund leftovers to users\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n  }\n\n  /// @dev Add liquidity to Uniswap pool, with staking rewards\n  /// @param tokenA Token A for the pair\n  /// @param tokenB Token B for the pair\n  /// @param amt Amounts of tokens to supply, borrow, and get.\n  /// @param wstaking Wrapped staking rewards address\n  function addLiquidityWStakingRewards(\n    address tokenA,\n    address tokenB,\n    Amounts calldata amt,\n    address wstaking\n  ) external payable {\n    address lp = getPair(tokenA, tokenB);\n    address reward = IWStakingRewards(wstaking).reward();\n\n    // 1-5. add liquidity\n    addLiquidityInternal(tokenA, tokenB, amt);\n\n    // 6. Take out collateral\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, uint collSize) = bank.getPositionInfo(positionId);\n    if (collSize > 0) {\n      require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n      bank.takeCollateral(wstaking, collId, collSize);\n      IWStakingRewards(wstaking).burn(collId, collSize);\n    }\n\n    // 7. Put collateral\n    ensureApprove(lp, wstaking);\n    uint amount = IERC20(lp).balanceOf(address(this));\n    uint id = IWStakingRewards(wstaking).mint(amount);\n    if (!IWStakingRewards(wstaking).isApprovedForAll(address(this), address(bank))) {\n      IWStakingRewards(wstaking).setApprovalForAll(address(bank), true);\n    }\n    bank.putCollateral(address(wstaking), id, amount);\n\n    // 8. Refund leftovers to users\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n\n    // 9. Refund reward\n    doRefund(reward);\n  }\n\n  struct RepayAmounts {\n    uint amtLPTake; // Take out LP token amount (from Homora)\n    uint amtLPWithdraw; // Withdraw LP token amount (back to caller)\n    uint amtARepay; // Repay tokenA amount\n    uint amtBRepay; // Repay tokenB amount\n    uint amtLPRepay; // Repay LP token amount\n    uint amtAMin; // Desired tokenA amount\n    uint amtBMin; // Desired tokenB amount\n  }\n\n  /// @dev Remove liqudity from Uniswap pool\n  /// @param tokenA Token A for the pair\n  /// @param tokenB Token B for the pair\n  /// @param amt Amounts of tokens to take out, withdraw, repay, and get.\n  function removeLiquidityInternal(\n    address tokenA,\n    address tokenB,\n    RepayAmounts calldata amt\n  ) internal {\n    address lp = getPair(tokenA, tokenB);\n    require(whitelistedLpTokens[lp], 'lp token not whitelisted');\n    uint positionId = bank.POSITION_ID();\n\n    uint amtARepay = amt.amtARepay;\n    uint amtBRepay = amt.amtBRepay;\n    uint amtLPRepay = amt.amtLPRepay;\n\n    // 2. Compute repay amount if MAX_INT is supplied (max debt)\n    if (amtARepay == uint(-1)) {\n      amtARepay = bank.borrowBalanceCurrent(positionId, tokenA);\n    }\n    if (amtBRepay == uint(-1)) {\n      amtBRepay = bank.borrowBalanceCurrent(positionId, tokenB);\n    }\n    if (amtLPRepay == uint(-1)) {\n      amtLPRepay = bank.borrowBalanceCurrent(positionId, lp);\n    }\n\n    // 3. Compute amount to actually remove\n    uint amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amt.amtLPWithdraw);\n\n    // 4. Remove liquidity\n    uint amtA;\n    uint amtB;\n    if (amtLPToRemove > 0) {\n      (amtA, amtB) = router.removeLiquidity(\n        tokenA,\n        tokenB,\n        amtLPToRemove,\n        0,\n        0,\n        address(this),\n        now\n      );\n    }\n\n    // 5. MinimizeTrading\n    uint amtADesired = amtARepay.add(amt.amtAMin);\n    uint amtBDesired = amtBRepay.add(amt.amtBMin);\n\n    if (amtA < amtADesired && amtB >= amtBDesired) {\n      address[] memory path = new address[](2);\n      (path[0], path[1]) = (tokenB, tokenA);\n      router.swapTokensForExactTokens(\n        amtADesired.sub(amtA),\n        amtB.sub(amtBDesired),\n        path,\n        address(this),\n        now\n      );\n    } else if (amtA >= amtADesired && amtB < amtBDesired) {\n      address[] memory path = new address[](2);\n      (path[0], path[1]) = (tokenA, tokenB);\n      router.swapTokensForExactTokens(\n        amtBDesired.sub(amtB),\n        amtA.sub(amtADesired),\n        path,\n        address(this),\n        now\n      );\n    }\n\n    // 6. Repay\n    doRepay(tokenA, amtARepay);\n    doRepay(tokenB, amtBRepay);\n    doRepay(lp, amtLPRepay);\n\n    // 7. Slippage control\n    require(IERC20(tokenA).balanceOf(address(this)) >= amt.amtAMin);\n    require(IERC20(tokenB).balanceOf(address(this)) >= amt.amtBMin);\n    require(IERC20(lp).balanceOf(address(this)) >= amt.amtLPWithdraw);\n\n    // 8. Refund leftover\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n    doRefund(lp);\n  }\n\n  /// @dev Remove liqudity from Uniswap pool, with no staking rewards (use WERC20 wrapper)\n  /// @param tokenA Token A for the pair\n  /// @param tokenB Token B for the pair\n  /// @param amt Amounts of tokens to take out, withdraw, repay, and get.\n  function removeLiquidityWERC20(\n    address tokenA,\n    address tokenB,\n    RepayAmounts calldata amt\n  ) external {\n    address lp = getPair(tokenA, tokenB);\n\n    // 1. Take out collateral\n    doTakeCollateral(lp, amt.amtLPTake);\n\n    // 2-8. remove liquidity\n    removeLiquidityInternal(tokenA, tokenB, amt);\n  }\n\n  /// @dev Remove liqudity from Uniswap pool, from staking rewards\n  /// @param tokenA Token A for the pair\n  /// @param tokenB Token B for the pair\n  /// @param amt Amounts of tokens to take out, withdraw, repay, and get.\n  function removeLiquidityWStakingRewards(\n    address tokenA,\n    address tokenB,\n    RepayAmounts calldata amt,\n    address wstaking\n  ) external {\n    address lp = getPair(tokenA, tokenB);\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\n    address reward = IWStakingRewards(wstaking).reward();\n\n    // 1. Take out collateral\n    require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n    bank.takeCollateral(wstaking, collId, amt.amtLPTake);\n    IWStakingRewards(wstaking).burn(collId, amt.amtLPTake);\n\n    // 2-8. remove liquidity\n    removeLiquidityInternal(tokenA, tokenB, amt);\n\n    // 9. Refund reward\n    doRefund(reward);\n  }\n\n  /// @dev Harvest staking reward tokens to in-exec position's owner\n  /// @param wstaking Wrapped staking rewards address\n  function harvestWStakingRewards(address wstaking) external {\n    address reward = IWStakingRewards(wstaking).reward();\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, ) = bank.getPositionInfo(positionId);\n    address lp = IWStakingRewards(wstaking).getUnderlyingToken(collId);\n    require(whitelistedLpTokens[lp], 'lp token not whitelisted');\n\n    // 1. Take out collateral\n    bank.takeCollateral(wstaking, collId, uint(-1));\n    IWStakingRewards(wstaking).burn(collId, uint(-1));\n\n    // 2. put collateral\n    uint amount = IERC20(lp).balanceOf(address(this));\n    ensureApprove(lp, wstaking);\n    uint id = IWStakingRewards(wstaking).mint(amount);\n    bank.putCollateral(wstaking, id, amount);\n\n    // 3. Refund reward\n    doRefund(reward);\n  }\n}"
    }
  ]
}