{
  "Title": "[G-08] Use assembly for loops",
  "Content": "In the following instances, assembly is used for more gas efficient loops. The only memory slots that are manually used in the loops are `scratch space (0x00-0x20)`, the `free memory pointer (0x40)`, and the `zero slot (0x60)`. This allows us to avoid using the free memory pointer to allocate new memory, which may result in memory expansion costs.\n\n**Note that in order to do this optimization safely we will need to cache and restore the `free memory pointer` after the loop. We will also set the `zero slot (0x60)` back to 0.**\n\n*The [final diffs](https://gist.github.com/0xJCN/b03b5f1f8cabc937c8bbe4d4a46b8d47) have comments explaining the assembly code*.\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/Factory.sol#L119-L121\n\n*Gas Savings for `Factory.create`, obtained via protocol's tests: Avg 129 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  161124  |  245619  |  148801 |    35    |\n| After  |  161112  |  243941  |  148672 |    35    |\n\n```solidity\nFile: src/Factory.sol\n119:        for (uint256 i = 0; i < tokenIds.length; i++) {\n120:            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n121:        }\n```\n```diff\ndiff --git a/src/Factory.sol b/src/Factory.sol\nindex 09cbb4e..c2e06f6 100644\n--- a/src/Factory.sol\n+++ b/src/Factory.sol\n@@ -116,8 +116,26 @@ contract Factory is ERC721, Owned {\n         }\n\n         // deposit the nfts from the caller into the pool\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n+        assembly {\n+            if mload(tokenIds) {\n+                let memptr := mload(0x40)\n+                let end := add(add(tokenIds, 0x20), mul(0x20, mload(tokenIds)))\n+                let i := add(tokenIds, 0x20)\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, caller())\n+                mstore(0x40, privatePool)\n+                for {} 1 {} {\n+                    mstore(0x60, mload(i))\n+                    let success := call(gas(), calldataload(0x24), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L134-L137\n\n*Gas Savings for `EthRouter.buy`, obtained via protocol's tests: Avg 5728 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  187054  |  397581  |  199750 |    7     |\n| After  |  182465  |  384540  |  194022 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n134:            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n135:                // transfer the NFT to the caller\n136:                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n137:            }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..4ea89f5 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -131,9 +131,28 @@ contract EthRouter is ERC721TokenReceiver {\n                 );\n             }\n\n-            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n-                // transfer the NFT to the caller\n-                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n+            Buy calldata _buy = buys[i];\n+            uint256[] calldata _tokenIds = _buy.tokenIds;\n+            assembly {\n+                if _tokenIds.length {\n+                    let memptr := mload(0x40)\n+                    let end := add(_tokenIds.offset, mul(0x20, _tokenIds.length))\n+                    let j := _tokenIds.offset\n+                    mstore(0x00, 0x42842e0e)\n+                    mstore(0x20, address())\n+                    mstore(0x40, caller())\n+                    for {} 1 {} {\n+                        mstore(0x60, calldataload(j))\n+                        let success := call(gas(), calldataload(add(_buy, 0x20)), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                        if iszero(success) {\n+                            revert(0, 0)\n+                        }\n+                        j := add(j, 0x20)\n+                        if iszero(lt(j, end)) { break }\n+                    }\n+                    mstore(0x40, memptr)\n+                    mstore(0x60, 0x00)\n+                }\n             }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L161-L163\n\n*Gas Savings for `EthRouter.sell`, obtained via protocol's tests: Avg 4735 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  217300  |  402940  |  232102 |    7     |\n| After  |  212706  |  395062  |  227367 |    7     |\n\n```solidity\nFile: src/EthRouter.sol\n161:            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n162:                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n163:            }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..c1a07ab 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -158,8 +158,30 @@ contract EthRouter is ERC721TokenReceiver {\n         // loop through and execute the sells\n         for (uint256 i = 0; i < sells.length; i++) {\n             // transfer the NFTs into the router from the caller\n-            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n-                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n+            {\n+                Sell calldata _sell = sells[i];\n+                uint256[] calldata _tokenIds = _sell.tokenIds;\n+                assembly {\n+                    if _tokenIds.length {\n+                        let memptr := mload(0x40)\n+                        let end := add(_tokenIds.offset, mul(0x20, _tokenIds.length))\n+                        let j := _tokenIds.offset\n+                        mstore(0x00, 0x42842e0e)\n+                        mstore(0x20, caller())\n+                        mstore(0x40, address())\n+                        for {} 1 {} {\n+                            mstore(0x60, calldataload(j))\n+                            let success := call(gas(), calldataload(add(_sell, 0x20)), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                            if iszero(success) {\n+                                revert(0, 0)\n+                            }\n+                            j := add(j, 0x20)\n+                            if iszero(lt(j, end)) { break }\n+                        }\n+                        mstore(0x40, memptr)\n+                        mstore(0x60, 0x00)\n+                    }\n+                }\n             }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L239-L241\n\n*Gas Savings for `EthRouter.deposit`, obtained via protocol's tests: Avg 211 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  2371    |  114072  |  29900  |    4     |\n| After  |  2371    |  113228  |  29689  |    4     |\n\n```solidity\nFile: src/EthRouter.sol\n239:        for (uint256 i = 0; i < tokenIds.length; i++) {\n240:            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n241:        }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..3006dcb 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -236,8 +236,26 @@ contract EthRouter is ERC721TokenReceiver {\n         }\n\n         // transfer NFTs from caller\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n+        assembly {\n+            if tokenIds.length {\n+                let memptr := mload(0x40)\n+                let end := add(tokenIds.offset, mul(0x20, tokenIds.length))\n+                let i := tokenIds.offset\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, caller())\n+                mstore(0x40, address())\n+                for {} 1 {} {\n+                    mstore(0x60, calldataload(i))\n+                    let success := call(gas(), calldataload(0x24), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/EthRouter.sol#L265-L286\n\n*Gas Savings for `EthRouter.change`, obtained via protocol's tests: Avg 6587 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  284857  |  298879  |  217295 |    4     |\n| After  |  276074  |  290096  |  210708 |    4     |\n\n```solidity\nFile: src/EthRouter.sol\n265:            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n266:                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n267:            }\n...            \n284:            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n285:                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n286:            }\n```\n```diff\ndiff --git a/src/EthRouter.sol b/src/EthRouter.sol\nindex 125001d..250b83b 100644\n--- a/src/EthRouter.sol\n+++ b/src/EthRouter.sol\n@@ -260,10 +260,30 @@ contract EthRouter is ERC721TokenReceiver {\n         // loop through and execute the changes\n         for (uint256 i = 0; i < changes.length; i++) {\n             Change memory _change = changes[i];\n+            uint256[] memory _inputTokenIds = _change.inputTokenIds;\n+            uint256[] memory _outputTokenIds = _change.outputTokenIds;\n\n             // transfer NFTs from caller\n-            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n-                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n+            assembly {\n+                if mload(_inputTokenIds) {\n+                    let memptr := mload(0x40)\n+                    let end := add(add(_inputTokenIds, 0x20), mul(0x20, mload(_inputTokenIds)))\n+                    let j := add(_inputTokenIds, 0x20)\n+                    mstore(0x00, 0x42842e0e)\n+                    mstore(0x20, caller())\n+                    mstore(0x40, address())\n+                    for {} 1 {} {\n+                        mstore(0x60, mload(j))\n+                        let success := call(gas(), mload(add(_change, 0x20)), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                        if iszero(success) {\n+                            revert(0, 0)\n+                        }\n+                        j := add(j, 0x20)\n+                        if iszero(lt(j, end)) { break }\n+                    }\n+                    mstore(0x40, memptr)\n+                    mstore(0x60, 0x00)\n+                }\n             }\n\n             // approve pair to transfer NFTs from router\n@@ -281,8 +301,26 @@ contract EthRouter is ERC721TokenReceiver {\n             );\n\n             // transfer NFTs to caller\n-            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n-                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n+            assembly {\n+                if mload(_outputTokenIds) {\n+                    let memptr := mload(0x40)\n+                    let end := add(add(_outputTokenIds, 0x20), mul(0x20, mload(_outputTokenIds)))\n+                    let j := add(_outputTokenIds, 0x20)\n+                    mstore(0x00, 0x42842e0e)\n+                    mstore(0x20, address())\n+                    mstore(0x40, caller())\n+                    for {} 1 {} {\n+                        mstore(0x60, mload(j))\n+                        let success := call(gas(), mload(add(_change, 0x20)), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                        if iszero(success) {\n+                            revert(0, 0)\n+                        }\n+                        j := add(j, 0x20)\n+                        if iszero(lt(j, end)) { break }\n+                    }\n+                    mstore(0x40, memptr)\n+                    mstore(0x60, 0x00)\n+                }\n             }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L441-L448\n\n*Gas Savings for `PrivatePool.change`, obtained via protocol's tests: Avg 2388 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  116432  |  142008  |  82138  |    17    |\n| After  |  113218  |  136466  |  79750  |    17    |\n\n```solidity\nFile: src/PrivatePool.sol\n441:        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n442:            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n443:        }\n444:\n445:        // transfer the output nfts to the caller\n446:        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n447:            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n448:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..859111e 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -438,13 +438,51 @@ contract PrivatePool is ERC721TokenReceiver {\n         }\n\n         // transfer the input nfts from the caller\n-        for (uint256 i = 0; i < inputTokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\n+        address _nft = nft;\n+        assembly {\n+            if mload(inputTokenIds) {\n+                let memptr := mload(0x40)\n+                let end := add(add(inputTokenIds, 0x20), mul(0x20, mload(inputTokenIds)))\n+                let i := add(inputTokenIds, 0x20)\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, caller())\n+                mstore(0x40, address())\n+                for {} 1 {} {\n+                    mstore(0x60, mload(i))\n+                    let success := call(gas(), _nft, 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n+\n         }\n\n         // transfer the output nfts to the caller\n-        for (uint256 i = 0; i < outputTokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\n+        assembly {\n+            if mload(outputTokenIds) {\n+                let memptr := mload(0x40)\n+                let end := add(add(outputTokenIds, 0x20), mul(0x20, mload(outputTokenIds)))\n+                let i := add(outputTokenIds, 0x20)\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, address())\n+                mstore(0x40, caller())\n+                for {} 1 {} {\n+                    mstore(0x60, mload(i))\n+                    let success := call(gas(), _nft, 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L496-L498\n\n**Note: `PrivatePool.deposit` is fuzzed, which results in inconsistent gas usage during tests. This is why `EthRouter.deposit` is benchmarked instead**.\n\n*Gas Savings for `EthRouter.deposit`, obtained via protocol's tests: Avg 232 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  2371    |  114072  |  29900  |    4     |\n| After  |  2371    |  113145  |  29668  |    4     |\n\n```solidity\nFile: src/PrivatePool.sol\n496:        for (uint256 i = 0; i < tokenIds.length; i++) {\n497:            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n498:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..b22c813 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -493,8 +493,27 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Interactions ~~~ //\n\n         // transfer the nfts from the caller\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n+        address _nft = nft;\n+        assembly {\n+            if tokenIds.length {\n+                let memptr := mload(0x40)\n+                let end := add(tokenIds.offset, mul(0x20, tokenIds.length))\n+                let i := tokenIds.offset\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, caller())\n+                mstore(0x40, address())\n+                for {} 1 {} {\n+                    mstore(0x60, calldataload(i))\n+                    let success := call(gas(), _nft, 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L518-L520\n\n*Gas Savings for `PrivatePool.withdraw`, obtained via protocol's tests: Avg 985 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  81842   |  81842   |  62023  |    5     |\n| After  |  80547   |  80547   |  61038  |    5     |\n\n```solidity\nFile: src/PrivatePool.sol\n518:        for (uint256 i = 0; i < tokenIds.length; i++) {\n519:            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n520:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..4211c9e 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -515,8 +515,26 @@ contract PrivatePool is ERC721TokenReceiver {\n         // ~~~ Interactions ~~~ //\n\n         // transfer the nfts to the caller\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n+        assembly {\n+            if tokenIds.length {\n+                let memptr := mload(0x40)\n+                let end := add(tokenIds.offset, mul(0x20, tokenIds.length))\n+                let i := tokenIds.offset\n+                mstore(0x00, 0x42842e0e)\n+                mstore(0x20, address())\n+                mstore(0x40, caller())\n+                for {} 1 {} {\n+                    mstore(0x60, calldataload(i))\n+                    let success := call(gas(), calldataload(0x04), 0x00, 0x1c, 0x64, 0x00, 0x00)\n+                    if iszero(success) {\n+                        revert(0, 0)\n+                    }\n+                    i := add(i, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+                mstore(0x40, memptr)\n+                mstore(0x60, 0x00)\n+            }\n         }\n```\n\nhttps://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L673-L679\n\n**Note: `PrivatePool.sumWeightsAndValidateProof` is called by all the functions below**.\n\n*Gas Savings for `PrivatePool.buy`, obtained via protocol's tests: Avg 33 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  74037   |  158864  |  70884  |    24    |\n| After  |  74037   |  158864  |  70851  |    24    |\n\n*Gas Savings for `PrivatePool.sell`, obtained via protocol's tests: Avg 74 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  50139   |  170448  |  81969  |    25    |\n| After  |  50139   |  170448  |  81895  |    25    |\n\n*Gas Savings for `PrivatePool.change`, obtained via protocol's tests: Avg 157 gas*\n\n|        |    Med   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  116432  |  142008  |  82138  |    17    |\n| After  |  116432  |  142008  |  81981  |    17    |\n\n```solidity\nFile: src/PrivatePool.sol\n673:        for (uint256 i = 0; i < tokenIds.length; i++) {\n674:            // create the leaf for the merkle proof\n675:            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n676:\n677:            // sum each token weight\n678:            sum += tokenWeights[i];\n679:        }\n```\n```diff\ndiff --git a/src/PrivatePool.sol b/src/PrivatePool.sol\nindex 75991e1..7d63e8e 100644\n--- a/src/PrivatePool.sol\n+++ b/src/PrivatePool.sol\n@@ -670,12 +670,25 @@ contract PrivatePool is ERC721TokenReceiver {\n\n         uint256 sum;\n         bytes32[] memory leafs = new bytes32[](tokenIds.length);\n-        for (uint256 i = 0; i < tokenIds.length; i++) {\n-            // create the leaf for the merkle proof\n-            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\n-\n-            // sum each token weight\n-            sum += tokenWeights[i];\n+        assembly {\n+            if mload(tokenIds) {\n+                let end := add(add(tokenIds, 0x20), mul(0x20, mload(tokenIds)))\n+                let i := add(tokenIds, 0x20)\n+                let j := add(tokenWeights, 0x20)\n+                let k := add(leafs, 0x20)\n+                for {} 1 {} {\n+                    mstore(0x00, mload(i))\n+                    mstore(0x20, mload(j))\n+                    mstore(0x00, keccak256(0x00, 0x40))\n+                    let hash := keccak256(0x00, 0x20)\n+                    mstore(k, hash)\n+                    sum := add(sum, mload(j))\n+                    i := add(i, 0x20)\n+                    j := add(j, 0x20)\n+                    k := add(k, 0x20)\n+                    if iszero(lt(i, end)) { break }\n+                }\n+            }\n         }\n```\n## `GasReport` output, with all optimizations applied\n```js\n| src/EthRouter.sol:EthRouter contract |                 |        |        |        |         |\n|--------------------------------------|-----------------|--------|--------|--------|---------|\n| Deployment Cost                      | Deployment Size |        |        |        |         |\n| 1415709                              | 7247            |        |        |        |         |\n| Function Name                        | min             | avg    | median | max    | # calls |\n| buy                                  | 658             | 190464 | 179510 | 374824 | 7       |\n| change                               | 576             | 202568 | 265225 | 279247 | 4       |\n| deposit                              | 773             | 29393  | 2361   | 112078 | 4       |\n| onERC721Received                     | 698             | 698    | 698    | 698    | 92      |\n| receive                              | 55              | 55     | 55     | 55     | 16      |\n| sell                                 | 732             | 223981 | 209434 | 388776 | 7       |\n\n\n| src/Factory.sol:Factory contract |                 |        |        |        |         |\n|----------------------------------|-----------------|--------|--------|--------|---------|\n| Deployment Cost                  | Deployment Size |        |        |        |         |\n| 1403424                          | 7270            |        |        |        |         |\n| Function Name                    | min             | avg    | median | max    | # calls |\n| create                           | 1641            | 148672 | 161112 | 243941 | 35      |\n| ownerOf                          | 0               | 20     | 0      | 622    | 30      |\n| predictPoolDeploymentAddress     | 2868            | 2868   | 2868   | 2868   | 1       |\n| privatePoolImplementation        | 403             | 403    | 403    | 403    | 1       |\n| privatePoolMetadata              | 426             | 426    | 426    | 426    | 1       |\n| protocolFeeRate                  | 419             | 1332   | 419    | 2419   | 127     |\n| receive                          | 55              | 55     | 55     | 55     | 3       |\n| setPrivatePoolImplementation     | 22744           | 22744  | 22744  | 22744  | 133     |\n| setPrivatePoolMetadata           | 2599            | 22357  | 22634  | 22634  | 127     |\n| setProtocolFeeRate               | 7521            | 9678   | 7521   | 22621  | 7       |\n| tokenURI                         | 367468          | 367468 | 367468 | 367468 | 1       |\n| withdraw                         | 2729            | 12149  | 11128  | 23611  | 4       |\n\n\n| src/PrivatePool.sol:PrivatePool contract |                 |       |        |        |         |\n|------------------------------------------|-----------------|-------|--------|--------|---------|\n| Deployment Cost                          | Deployment Size |       |        |        |         |\n| 3097024                                  | 15926           |       |        |        |         |\n| Function Name                            | min             | avg   | median | max    | # calls |\n| baseToken                                | 404             | 904   | 404    | 2404   | 12      |\n| buy                                      | 1123            | 69821 | 73315  | 157662 | 24      |\n| buyQuote                                 | 2282            | 5817  | 4282   | 10782  | 28      |\n| change                                   | 4723            | 78083 | 111589 | 134100 | 17      |\n| changeFee                                | 366             | 366   | 366    | 366    | 2       |\n| changeFeeQuote                           | 3070            | 9202  | 10796  | 10796  | 18      |\n| deposit                                  | 793             | 62671 | 13721  | 357344 | 8       |\n| execute                                  | 3615            | 18550 | 17976  | 35939  | 6       |\n| factory                                  | 261             | 261   | 261    | 261    | 2       |\n| feeRate                                  | 375             | 375   | 375    | 375    | 5       |\n| flashFee                                 | 539             | 1872  | 2539   | 2539   | 3       |\n| flashFeeToken                            | 419             | 819   | 419    | 2419   | 5       |\n| flashLoan                                | 62820           | 82915 | 82915  | 103011 | 2       |\n| initialize                               | 1205            | 62085 | 55637  | 95437  | 147     |\n| initialized                              | 418             | 418   | 418    | 418    | 1       |\n| merkleRoot                               | 385             | 385   | 385    | 385    | 3       |\n| nft                                      | 383             | 383   | 383    | 383    | 6       |\n| onERC721Received                         | 840             | 840   | 840    | 840    | 151     |\n| payRoyalties                             | 393             | 393   | 393    | 393    | 3       |\n| price                                    | 1185            | 3866  | 5185   | 5185   | 7       |\n| receive                                  | 55              | 55    | 55     | 55     | 33      |\n| sell                                     | 6077            | 81284 | 49660  | 169661 | 25      |\n| sellQuote                                | 2407            | 5657  | 4407   | 10907  | 22      |\n| setFeeRate                               | 3384            | 6451  | 6459   | 9503   | 4       |\n| setMerkleRoot                            | 9425            | 9425  | 9425   | 9425   | 2       |\n| setPayRoyalties                          | 3406            | 6164  | 6704   | 9504   | 5       |\n| setUseStolenNftOracle                    | 3428            | 5628  | 6729   | 6729   | 3       |\n| setVirtualReserves                       | 3568            | 7639  | 8530   | 9930   | 4       |\n| useStolenNftOracle                       | 417             | 417   | 417    | 417    | 3       |\n| virtualBaseTokenReserves                 | 470             | 470   | 470    | 470    | 8       |\n| virtualNftReserves                       | 465             | 465   | 465    | 465    | 8       |\n| withdraw                                 | 3774            | 61038 | 80547  | 80547  | 5       |\n```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/372#issuecomment-1523266431):**\n > At least 2k gas from SLOADs and the Calldata.\n> \n> Will check the rest.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-04-caviar-findings/issues/372#issuecomment-1527531813):**\n > **[G-01] Cache calldata/memory pointers for complex types to avoid offset calculations**   52<br>\n> Refactor\n> \n> **[G-02] Use calldata instead of memory for function arguments that do not get mutated**   4<br>\n> Low\n> \n> **[G-03] State variables can be cached instead of re-reading them from storage**   16<br>\n> Low\n> \n> **[G-04] Cache state variables outside of loop to avoid reading storage on every iteration**   6<br>\n> Non-Critical\n> \n> **[G-05] Rearrange code to fail early**   1<br>\n> Ignoring\n> \n> **[G-06] x += y/x -= y costs more gas than x = x + y/x = x - y for state variables**   2<br>\n> Non-Critical\n> \n> **[G-07] If statements that use && can be refactored into nested if statements**   9<br>\n> Ignoring\n> \n> **[G-08] Use assembly for loops**<br>\n> Refactor\n> \n> Bonus of 5 points because fully benchmarked.\n\n\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-04-caviar-private-pools",
  "Code": [
    {
      "filename": "src/Factory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *\n *       __________...----..____..-'``-..___\n *     ,'.                                  ```--.._\n *    :                                             ``._\n *    |                           --                    ``.\n *    |                 -0-           -.     -   -.        `.\n *    :                     __           --            .     \\\n *     `._____________     (  `.   -.-      --  -   .   `     \\\n *        `-----------------\\   \\_.--------..__..--.._ `. `.   :\n *                           `--'                     `-._ .   |\n *                                                        `.`  |\n *                                                          \\` |\n *                                                           \\ |\n *                                                           / \\`.\n *                                                          /  _\\-'\n *                                                         /_,'\n */\n\nimport {LibClone} from \"solady/utils/LibClone.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {PrivatePoolMetadata} from \"./PrivatePoolMetadata.sol\";\n\n/// @title Caviar Private Pool Factory\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to create and initialize new private pools. Each time a private pool is created, a new\n/// NFT representing that private pool is minted to the creator. All protocol fees also accrue to this contract and can\n/// be withdrawn by the admin.\ncontract Factory is ERC721, Owned {\n    using LibClone for address;\n    using SafeTransferLib for address;\n\n    event Create(address indexed privatePool, uint256[] tokenIds, uint256 baseTokenAmount);\n    event Withdraw(address indexed token, uint256 indexed amount);\n\n    /// @notice The address of the private pool implementation that proxies point to.\n    address public privatePoolImplementation;\n\n    /// @notice Helper contract that constructs the private pool metadata svg and json for each pool NFT.\n    address public privatePoolMetadata;\n\n    /// @notice The protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    uint16 public protocolFeeRate;\n\n    constructor() ERC721(\"Caviar Private Pools\", \"POOL\") Owned(msg.sender) {}\n\n    receive() external payable {}\n\n    /// @notice Creates a new private pool using the minimal proxy pattern that points to the private pool\n    /// implementation. The caller must approve the factory to transfer the NFTs that will be deposited to the pool.\n    /// @param _baseToken The address of the base token.\n    /// @param _nft The address of the NFT.\n    /// @param _virtualBaseTokenReserves The virtual base token reserves.\n    /// @param _virtualNftReserves The virtual NFT reserves.\n    /// @param _changeFee The change fee.\n    /// @param _feeRate The fee rate.\n    /// @param _merkleRoot The merkle root.\n    /// @param _useStolenNftOracle Whether to use the stolen NFT oracle.\n    /// @param _salt The salt that will used on deployment.\n    /// @param tokenIds The token ids to deposit to the pool.\n    /// @param baseTokenAmount The amount of base tokens to deposit to the pool.\n    /// @return privatePool The address of the private pool.\n    function create(\n        address _baseToken,\n        address _nft,\n        uint128 _virtualBaseTokenReserves,\n        uint128 _virtualNftReserves,\n        uint56 _changeFee,\n        uint16 _feeRate,\n        bytes32 _merkleRoot,\n        bool _useStolenNftOracle,\n        bool _payRoyalties,\n        bytes32 _salt,\n        uint256[] memory tokenIds, // put in memory to avoid stack too deep error\n        uint256 baseTokenAmount\n    ) public payable returns (PrivatePool privatePool) {\n        // check that the msg.value is equal to the base token amount if the base token is ETH or the msg.value is equal\n        // to zero if the base token is not ETH\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\n            revert PrivatePool.InvalidEthAmount();\n        }\n\n        // deploy a minimal proxy clone of the private pool implementation\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(_salt)));\n\n        // mint the nft to the caller\n        _safeMint(msg.sender, uint256(uint160(address(privatePool))));\n\n        // initialize the pool\n        privatePool.initialize(\n            _baseToken,\n            _nft,\n            _virtualBaseTokenReserves,\n            _virtualNftReserves,\n            _changeFee,\n            _feeRate,\n            _merkleRoot,\n            _useStolenNftOracle,\n            _payRoyalties\n        );\n\n        if (_baseToken == address(0)) {\n            // transfer eth into the pool if base token is ETH\n            address(privatePool).safeTransferETH(baseTokenAmount);\n        } else {\n            // deposit the base tokens from the caller into the pool\n            ERC20(_baseToken).transferFrom(msg.sender, address(privatePool), baseTokenAmount);\n        }\n\n        // deposit the nfts from the caller into the pool\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\n        }\n\n        // emit create event\n        emit Create(address(privatePool), tokenIds, baseTokenAmount);\n    }\n\n    /// @notice Sets private pool metadata contract.\n    /// @param _privatePoolMetadata The private pool metadata contract.\n    function setPrivatePoolMetadata(address _privatePoolMetadata) public onlyOwner {\n        privatePoolMetadata = _privatePoolMetadata;\n    }\n\n    /// @notice Sets the private pool implementation contract that newly deployed proxies point to.\n    /// @param _privatePoolImplementation The private pool implementation contract.\n    function setPrivatePoolImplementation(address _privatePoolImplementation) public onlyOwner {\n        privatePoolImplementation = _privatePoolImplementation;\n    }\n\n    /// @notice Sets the protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\n    /// @param _protocolFeeRate The protocol fee.\n    function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {\n        protocolFeeRate = _protocolFeeRate;\n    }\n\n    /// @notice Withdraws the earned protocol fees.\n    /// @param token The token to withdraw.\n    /// @param amount The amount to withdraw.\n    function withdraw(address token, uint256 amount) public onlyOwner {\n        if (token == address(0)) {\n            msg.sender.safeTransferETH(amount);\n        } else {\n            ERC20(token).transfer(msg.sender, amount);\n        }\n\n        emit Withdraw(token, amount);\n    }\n\n    /// @notice Returns the token URI for a given token id.\n    /// @param id The token id.\n    /// @return uri The token URI.\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);\n    }\n\n    /// @notice Predicts the deployment address of a new private pool.\n    /// @param salt The salt that will used on deployment.\n    /// @return predictedAddress The predicted deployment address of the private pool.\n    function predictPoolDeploymentAddress(bytes32 salt) public view returns (address predictedAddress) {\n        predictedAddress = privatePoolImplementation.predictDeterministicAddress(salt, address(this));\n    }\n}"
    },
    {
      "filename": "src/EthRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";\n\n/// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}\n\n    constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }\n\n    /// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            // transfer the NFTs into the router from the caller\n            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n            }\n\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n\n            if (sells[i].isPublicPool) {\n                // exceute the sell against a public pool\n                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n                    sells[i].tokenIds,\n                    0,\n                    0,\n                    sells[i].publicPoolProofs,\n                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                    // decoded/encoded 1-to-1.\n                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n                );\n\n                // pay the royalties if seller has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the sell against a private pool\n                PrivatePool(sells[i].pool).sell(\n                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n                );\n            }\n        }\n\n        // check that the output amount is greater than the minimum\n        if (address(this).balance < minOutputAmount) {\n            revert OutputAmountTooSmall();\n        }\n\n        // transfer the output amount to the caller\n        msg.sender.safeTransferETH(address(this).balance);\n    }\n\n    /// @notice Executes a deposit to a private pool (transfers NFTs and ETH to the pool).\n    /// @param privatePool The private pool to deposit to.\n    /// @param nft The NFT contract address.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param minPrice The minimum price of the pool. Will revert if price is smaller than this.\n    /// @param maxPrice The maximum price of the pool. Will revert if price is greater than this.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // check pool price is in between min and max\n        uint256 price = PrivatePool(privatePool).price();\n        if (price > maxPrice || price < minPrice) {\n            revert PriceOutOfRange();\n        }\n\n        // transfer NFTs from caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n\n        // execute deposit\n        PrivatePool(privatePool).deposit{value: msg.value}(tokenIds, msg.value);\n    }\n\n    /// @notice Executes a series of change operations against a private pool.\n    /// @param changes The change operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n\n            // transfer NFTs from caller\n            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n            }\n\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n\n            // execute change\n            PrivatePool(_change.pool).change{value: msg.value}(\n                _change.inputTokenIds,\n                _change.inputTokenWeights,\n                _change.inputProof,\n                _change.stolenNftProofs,\n                _change.outputTokenIds,\n                _change.outputTokenWeights,\n                _change.outputProof\n            );\n\n            // transfer NFTs to caller\n            for (uint256 j = 0; j < changes[i].outputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(address(this), msg.sender, _change.outputTokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\n    /// manifold registry.\n    /// @param tokenId The token ID of the NFT.\n    /// @param salePrice The sale price of the NFT.\n    /// @return royaltyFee The royalty fee to pay.\n    /// @return recipient The address to pay the royalty fee to.\n    function getRoyalty(address nft, uint256 tokenId, uint256 salePrice)\n        public\n        view\n        returns (uint256 royaltyFee, address recipient)\n    {\n        // get the royalty lookup address\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);\n\n        if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\n            // get the royalty fee from the registry\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\n\n            // revert if the royalty fee is greater than the sale price\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\n        }\n    }\n}"
    },
    {
      "filename": "src/EthRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/*\n *                                     _H_\n *                                    /___\\\n *                                    \\888/\n * ~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~^~U~^~^~^~^~^~^~^\n *                       ~              |\n *       ~                        o     |        ~\n *                 ___        o         |\n *        _,.--,.'`   `~'-.._    O      |\n *       /_  .-\"      _   /_\\'.         |   ~\n *      .-';'       (( `  \\0/  `\\       #\n *     /__;          ((_  ,_     |  ,   #\n *     .-;                  \\_   /  #  _#,\n *    /  ;    .-' /  _.--\"\"-.\\`~`   `#(('\\\\        ~\n *    ;-';   /   / .'                  )) \\\\\n *        ; /.--'.'                   ((   ))\n *         \\     |        ~            \\\\ ((\n *          \\    |                      )) `\n *    ~      \\   |                      `\n *            \\  |\n *            .` `\"\"-.\n *          .'        \\         ~               ~\n *          |    |\\    |\n *          \\   /  '-._|\n *           \\.'\n */\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IERC2981} from \"openzeppelin/interfaces/IERC2981.sol\";\nimport {Pair, ReservoirOracle} from \"caviar/Pair.sol\";\nimport {IRoyaltyRegistry} from \"royalty-registry-solidity/IRoyaltyRegistry.sol\";\n\nimport {PrivatePool} from \"./PrivatePool.sol\";\nimport {IStolenNftOracle} from \"./interfaces/IStolenNftOracle.sol\";\n\n/// @title Eth Router\n/// @author out.eth (@outdoteth)\n/// @notice This contract is used to route buy, sell, and change orders to multiple pools in one transaction. It\n/// will route the orders to either a private pool or a public pool. If the order goes to a public pool, then users\n/// can choose whether or not they would like to pay royalties. The only base token which is supported is native ETH.\ncontract EthRouter is ERC721TokenReceiver {\n    using SafeTransferLib for address;\n\n    struct Buy {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        uint256 baseTokenAmount;\n        bool isPublicPool;\n    }\n\n    struct Sell {\n        address payable pool;\n        address nft;\n        uint256[] tokenIds;\n        uint256[] tokenWeights;\n        PrivatePool.MerkleMultiProof proof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        bool isPublicPool;\n        bytes32[][] publicPoolProofs;\n    }\n\n    struct Change {\n        address payable pool;\n        address nft;\n        uint256[] inputTokenIds;\n        uint256[] inputTokenWeights;\n        PrivatePool.MerkleMultiProof inputProof;\n        IStolenNftOracle.Message[] stolenNftProofs;\n        uint256[] outputTokenIds;\n        uint256[] outputTokenWeights;\n        PrivatePool.MerkleMultiProof outputProof;\n    }\n\n    error DeadlinePassed();\n    error OutputAmountTooSmall();\n    error PriceOutOfRange();\n    error InvalidRoyaltyFee();\n\n    address public immutable royaltyRegistry;\n\n    receive() external payable {}\n\n    constructor(address _royaltyRegistry) {\n        royaltyRegistry = _royaltyRegistry;\n    }\n\n    /// @notice Executes a series of buy operations against public or private pools.\n    /// @param buys The buy operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// If it's set to 0 then there is no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function buy(Buy[] calldata buys, uint256 deadline, bool payRoyalties) public payable {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the the buys\n        for (uint256 i = 0; i < buys.length; i++) {\n            if (buys[i].isPublicPool) {\n                // execute the buy against a public pool\n                uint256 inputAmount = Pair(buys[i].pool).nftBuy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].baseTokenAmount, 0\n                );\n\n                // pay the royalties if buyer has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = inputAmount / buys[i].tokenIds.length;\n                    for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(buys[i].nft, buys[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the buy against a private pool\n                PrivatePool(buys[i].pool).buy{value: buys[i].baseTokenAmount}(\n                    buys[i].tokenIds, buys[i].tokenWeights, buys[i].proof\n                );\n            }\n\n            for (uint256 j = 0; j < buys[i].tokenIds.length; j++) {\n                // transfer the NFT to the caller\n                ERC721(buys[i].nft).safeTransferFrom(address(this), msg.sender, buys[i].tokenIds[j]);\n            }\n        }\n\n        // refund any surplus ETH to the caller\n        if (address(this).balance > 0) {\n            msg.sender.safeTransferETH(address(this).balance);\n        }\n    }\n\n    /// @notice Executes a series of sell operations against public or private pools.\n    /// @param sells The sell operations to execute.\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction to succeed.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for there to be no deadline.\n    /// @param payRoyalties Whether to pay royalties or not.\n    function sell(Sell[] calldata sells, uint256 minOutputAmount, uint256 deadline, bool payRoyalties) public {\n        // check that the deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the sells\n        for (uint256 i = 0; i < sells.length; i++) {\n            // transfer the NFTs into the router from the caller\n            for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                ERC721(sells[i].nft).safeTransferFrom(msg.sender, address(this), sells[i].tokenIds[j]);\n            }\n\n            // approve the pair to transfer NFTs from the router\n            ERC721(sells[i].nft).setApprovalForAll(sells[i].pool, true);\n\n            if (sells[i].isPublicPool) {\n                // exceute the sell against a public pool\n                uint256 outputAmount = Pair(sells[i].pool).nftSell(\n                    sells[i].tokenIds,\n                    0,\n                    0,\n                    sells[i].publicPoolProofs,\n                    // ReservoirOracle.Message[] is the exact same as IStolenNftOracle.Message[] and can be\n                    // decoded/encoded 1-to-1.\n                    abi.decode(abi.encode(sells[i].stolenNftProofs), (ReservoirOracle.Message[]))\n                );\n\n                // pay the royalties if seller has opted-in\n                if (payRoyalties) {\n                    uint256 salePrice = outputAmount / sells[i].tokenIds.length;\n                    for (uint256 j = 0; j < sells[i].tokenIds.length; j++) {\n                        // get the royalty fee and recipient\n                        (uint256 royaltyFee, address royaltyRecipient) =\n                            getRoyalty(sells[i].nft, sells[i].tokenIds[j], salePrice);\n\n                        if (royaltyFee > 0) {\n                            // transfer the royalty fee to the royalty recipient\n                            royaltyRecipient.safeTransferETH(royaltyFee);\n                        }\n                    }\n                }\n            } else {\n                // execute the sell against a private pool\n                PrivatePool(sells[i].pool).sell(\n                    sells[i].tokenIds, sells[i].tokenWeights, sells[i].proof, sells[i].stolenNftProofs\n                );\n            }\n        }\n\n        // check that the output amount is greater than the minimum\n        if (address(this).balance < minOutputAmount) {\n            revert OutputAmountTooSmall();\n        }\n\n        // transfer the output amount to the caller\n        msg.sender.safeTransferETH(address(this).balance);\n    }\n\n    /// @notice Executes a deposit to a private pool (transfers NFTs and ETH to the pool).\n    /// @param privatePool The private pool to deposit to.\n    /// @param nft The NFT contract address.\n    /// @param tokenIds The token IDs of the NFTs to deposit.\n    /// @param minPrice The minimum price of the pool. Will revert if price is smaller than this.\n    /// @param maxPrice The maximum price of the pool. Will revert if price is greater than this.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function deposit(\n        address payable privatePool,\n        address nft,\n        uint256[] calldata tokenIds,\n        uint256 minPrice,\n        uint256 maxPrice,\n        uint256 deadline\n    ) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // check pool price is in between min and max\n        uint256 price = PrivatePool(privatePool).price();\n        if (price > maxPrice || price < minPrice) {\n            revert PriceOutOfRange();\n        }\n\n        // transfer NFTs from caller\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        // approve pair to transfer NFTs from router\n        ERC721(nft).setApprovalForAll(privatePool, true);\n\n        // execute deposit\n        PrivatePool(privatePool).deposit{value: msg.value}(tokenIds, msg.value);\n    }\n\n    /// @notice Executes a series of change operations against a private pool.\n    /// @param changes The change operations to execute.\n    /// @param deadline The deadline for the transaction to be mined. Will revert if timestamp is greater than deadline.\n    /// Set to 0 for deadline to be ignored.\n    function change(Change[] calldata changes, uint256 deadline) public payable {\n        // check deadline has not passed (if any)\n        if (block.timestamp > deadline && deadline != 0) {\n            revert DeadlinePassed();\n        }\n\n        // loop through and execute the changes\n        for (uint256 i = 0; i < changes.length; i++) {\n            Change memory _change = changes[i];\n\n            // transfer NFTs from caller\n            for (uint256 j = 0; j < changes[i].inputTokenIds.length; j++) {\n                ERC721(_change.nft).safeTransferFrom(msg.sender, address(this), _change.inputTokenIds[j]);\n            }\n\n            // approve pair to transfer NFTs from router\n            ERC721(_change.nft).setApprovalForAll(_change.pool, true);\n\n            // execute change\n            PrivatePool(_change.pool).change{value: msg.value}(\n                _change.inputTokenIds,\n                _change.inputTokenWeights,\n                _change.inputProof,\n                _change.stolenNftProofs,\n                _change.outputTokenIds,\n                _change.outputTokenWeights,"
    }
  ]
}