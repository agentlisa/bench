{
  "Title": "[H-03] Malicious Users Can Drain The Assets Of Auto Compound Vault",
  "Content": "\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315>\n\n### Proof of Concept\n\n> Note: This issue affects both the AutoPxGmx and AutoPxGlp vaults. Since the root cause is the same, the PoC of AutoPxGlp vault is omitted for brevity.\n\nThe `PirexERC4626.convertToShares` function relies on the `mulDivDown` function in Line 164 when calculating the number of shares needed in exchange for a certain number of assets. Note that the computation is rounded down, therefore, if the result is less than 1 (e.g. 0.9), Solidity will round them down to zero. Thus, it is possible that this function will return zero.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156>\n\n```solidity\nFile: PirexERC4626.sol\n156:     function convertToShares(uint256 assets)\n157:         public\n158:         view\n159:         virtual\n160:         returns (uint256)\n161:     {\n162:         uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n163: \n164:         return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n165:     }\n```\n\nThe `AutoPxGmx.previewWithdraw` function relies on the `PirexERC4626.convertToShares` function in Line 206. Thus, this function will also \"round down\".\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199>\n\n```solidity\nFile: AutoPxGmx.sol\n199:     function previewWithdraw(uint256 assets)\n200:         public\n201:         view\n202:         override\n203:         returns (uint256)\n204:     {\n205:         // Calculate shares based on the specified assets' proportion of the pool\n206:         uint256 shares = convertToShares(assets);\n207: \n208:         // Save 1 SLOAD\n209:         uint256 _totalSupply = totalSupply;\n210: \n211:         // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n212:         return\n213:             (_totalSupply == 0 || _totalSupply - shares == 0)\n214:                 ? shares\n215:                 : (shares * FEE_DENOMINATOR) /\n216:                     (FEE_DENOMINATOR - withdrawalPenalty);\n217:     }\n```\n\nThe `AutoPxGmx.withdraw` function relies on the `AutoPxGmx.previewWithdraw` function. In certain conditions, the `AutoPxGmx.previewWithdraw` function in Line 323 will return zero if the withdrawal amount causes the division within the `PirexERC4626.convertToShares` function to round down to zero (usually due to a small amount of withdrawal amount).\n\nIf the `AutoPxGmx.previewWithdraw` function in Line 323 returns zero, no shares will be burned at Line 332. Subsequently, in Line 336, the contract will transfer the assets to the users. As a result, the users receive the assets without burning any of their shares, effectively allowing them to receive assets for free.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315>\n\n```solidity\nFile: AutoPxGmx.sol\n315:     function withdraw(\n316:         uint256 assets,\n317:         address receiver,\n318:         address owner\n319:     ) public override returns (uint256 shares) {\n320:         // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n321:         compound(poolFee, 1, 0, true);\n322:         \n323:         shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n324: \n325:         if (msg.sender != owner) {\n326:             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n327: \n328:             if (allowed != type(uint256).max)\n329:                 allowance[owner][msg.sender] = allowed - shares;\n330:         }\n331: \n332:         _burn(owner, shares);\n333: \n334:         emit Withdraw(msg.sender, receiver, owner, assets, shares);\n335: \n336:         asset.safeTransfer(receiver, assets);\n337:     }\n```\n\nAssume that the vault with the following state:\n\n*   Total Asset = 1000 WETH\n*   Total Supply = 10 shares\n\nAssume that Alice wants to withdraw 99 WETH from the vault. Thus, she calls the `AutoPxGmx.withdraw(99 WETH)` function.\n\nThe `PirexERC4626.convertToShares` function will compute the number of shares that Alice needs to burn in exchange for 99 WETH.\n\n```solidity\nassets.mulDivDown(supply, totalAssets())\n99WETH.mulDivDown(10 shares, 1000WETH)\n(99 * 10) / 1000\n990 / 1000 = 0.99 = 0\n```\n\nHowever, since Solidity rounds `0.99` down to `0`, Alice does not need to burn a single share. She will receive 99 WETH for free.\n\n### Impact\n\nMalicious users can withdraw the assets from the vault for free, effectively allowing them to drain the assets of the vault.\n\n### Recommended Mitigation Steps\n\nEnsure that at least 1 share is burned when the users withdraw their assets.\n\nThis can be mitigated by updating the `previewWithdraw` function to round up instead of round down when computing the number of shares to be burned.\n\n```diff\nfunction previewWithdraw(uint256 assets)\n\tpublic\n\tview\n\toverride\n\treturns (uint256)\n{\n\t// Calculate shares based on the specified assets' proportion of the pool\n-\tuint256 shares = convertToShares(assets);\n+\tuint256 shares = supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n\t\n\t// Save 1 SLOAD\n\tuint256 _totalSupply = totalSupply;\n\n\t// Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n\treturn\n\t\t(_totalSupply == 0 || _totalSupply - shares == 0)\n\t\t\t? shares\n\t\t\t: (shares * FEE_DENOMINATOR) /\n\t\t\t\t(FEE_DENOMINATOR - withdrawalPenalty);\n}\n```\n\n**[kphed (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/264)** \n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/vaults/PirexERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/**\n    @notice Pirex modifications\n            - Add beforeDeposit method\n            - Call beforeDeposit in deposit and mint methods\n            - Add afterWithdraw method\n            - Call afterWithdraw in redeem and withdraw methods\n            - Add afterTransfer method\n            - Call afterTransfer in transfer and transferFrom methods\n */\nabstract contract PirexERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /**\n        @notice Override transfer method to allow for pre-transfer internal hook\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        bool status = ERC20.transfer(to, amount);\n\n        afterTransfer(msg.sender, to, amount);\n\n        return status;\n    }\n\n    /**\n        @notice Override transferFrom method to allow for pre-transfer internal hook\n        @param  from    address  Account sending apxGLP\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        bool status = ERC20.transferFrom(from, to, amount);\n\n        afterTransfer(from, to, amount);\n\n        return status;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function beforeDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256 amount\n    ) internal virtual {}\n}"
    },
    {
      "filename": "src/vaults/AutoPxGmx.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {IV3SwapRouter} from \"src/interfaces/IV3SwapRouter.sol\";\n\ncontract AutoPxGmx is ReentrancyGuard, Owned, PirexERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    IV3SwapRouter public constant SWAP_ROUTER =\n        IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n\n    // Uniswap pool fee\n    uint24 public poolFee = 3000;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    ERC20 public immutable gmxBaseReward;\n    ERC20 public immutable gmx;\n\n    event PoolFeeUpdated(uint24 _poolFee);\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 gmxBaseRewardAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error AlreadySet();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _gmx            address  GMX token contract address\n        @param  _asset          address  Asset address (e.g. pxGMX)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGMX)\n        @param  _symbol         string   Asset symbol (e.g. apxGMX)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _gmx,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);\n        gmx.safeApprove(_platform, type(uint256).max);\n    }\n\n    /**\n        @notice Set the Uniswap pool fee\n        @param  _poolFee  uint24  Uniswap pool fee\n     */\n    function setPoolFee(uint24 _poolFee) external onlyOwner {\n        if (_poolFee == 0) revert ZeroAmount();\n\n        poolFee = _poolFee;\n\n        emit PoolFeeUpdated(_poolFee);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGMX custodied by the AutoPxGmx contract\n        @return uint256  Amount of pxGMX custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares  uint256  Shares\n        @return uint256  Assets\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets  uint256  Assets\n        @return uint256  Shares\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGMX rewards before depositing\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(poolFee, 1, 0, true);\n    }\n\n    /**\n        @notice Compound pxGMX rewards\n        @param  fee                    uint24   Uniswap pool tier fee\n        @param  amountOutMinimum       uint256  Outbound token swap amount\n        @param  sqrtPriceLimitX96      uint160  Swap price impact limit (optional)\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  GMX base reward inbound swap amount\n        @return gmxAmountOut           uint256  GMX outbound swap amount\n        @return pxGmxMintAmount        uint256  pxGMX minted when depositing GMX\n        @return totalFee               uint256  Total platform fee\n        @return incentive              uint256  Compound incentive\n     */\n    function compound(\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        )\n    {\n        if (fee == 0) revert InvalidParam();\n        if (amountOutMinimum == 0) revert InvalidParam();\n\n        uint256 assetsBeforeClaim = asset.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n\n        // Swap entire reward balance for GMX\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            gmxAmountOut = SWAP_ROUTER.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: address(gmxBaseReward),\n                    tokenOut: address(gmx),\n                    fee: fee,\n                    recipient: address(this),\n                    amountIn: gmxBaseRewardAmountIn,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\n                })\n            );\n\n            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount\n            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(\n                gmx.balanceOf(address(this)),\n                address(this)\n            );\n        }\n\n        // Only distribute fees if the amount of vault assets increased\n        if ((totalAssets() - assetsBeforeClaim) != 0) {\n            totalFee =\n                ((asset.balanceOf(address(this)) - assetsBeforeClaim) *\n                    platformFee) /\n                FEE_DENOMINATOR;\n            incentive = optOutIncentive\n                ? 0\n                : (totalFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (incentive != 0) asset.safeTransfer(msg.sender, incentive);\n\n            asset.safeTransfer(owner, totalFee - incentive);\n        }\n\n        emit Compounded(\n            msg.sender,\n            fee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            gmxBaseRewardAmountIn,\n            gmxAmountOut,\n            pxGmxMintAmount,\n            totalFee,\n            incentive\n        );\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n        compound(poolFee, 1, 0, true);\n\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        // Compound rewards and ensure they are properly accounted for prior to redemption calculation\n        compound(poolFee, 1, 0, true);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n        @notice Deposit GMX for apxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  apxGMX receiver\n        @return shares    uint256  Vault shares (i.e. apxGMX)\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Handle compounding of rewards before deposit (arguments are not used by `beforeDeposit` hook)\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // Intake sender GMX\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Convert sender GMX into pxGMX and get the post-fee amount (i.e. assets)\n        (, uint256 assets, ) = PirexGmx(platform).depositGmx(\n            amount,\n            address(this)\n        );\n\n        // NOTE: Modified `convertToShares` logic to consider assets already being in the vault\n        // and handle it by deducting the recently-deposited assets from the total\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n}"
    },
    {
      "filename": "src/vaults/AutoPxGmx.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {IV3SwapRouter} from \"src/interfaces/IV3SwapRouter.sol\";\n\ncontract AutoPxGmx is ReentrancyGuard, Owned, PirexERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    IV3SwapRouter public constant SWAP_ROUTER =\n        IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n\n    // Uniswap pool fee\n    uint24 public poolFee = 3000;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    ERC20 public immutable gmxBaseReward;\n    ERC20 public immutable gmx;\n\n    event PoolFeeUpdated(uint24 _poolFee);\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 gmxBaseRewardAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error AlreadySet();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _gmx            address  GMX token contract address\n        @param  _asset          address  Asset address (e.g. pxGMX)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGMX)\n        @param  _symbol         string   Asset symbol (e.g. apxGMX)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _gmx,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);\n        gmx.safeApprove(_platform, type(uint256).max);\n    }\n\n    /**\n        @notice Set the Uniswap pool fee\n        @param  _poolFee  uint24  Uniswap pool fee\n     */\n    function setPoolFee(uint24 _poolFee) external onlyOwner {\n        if (_poolFee == 0) revert ZeroAmount();\n\n        poolFee = _poolFee;\n\n        emit PoolFeeUpdated(_poolFee);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGMX custodied by the AutoPxGmx contract\n        @return uint256  Amount of pxGMX custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares  uint256  Shares\n        @return uint256  Assets\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets  uint256  Assets\n        @return uint256  Shares\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGMX rewards before depositing\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(poolFee, 1, 0, true);\n    }\n\n    /**\n        @notice Compound pxGMX rewards\n        @param  fee                    uint24   Uniswap pool tier fee\n        @param  amountOutMinimum       uint256  Outbound token swap amount\n        @param  sqrtPriceLimitX96      uint160  Swap price impact limit (optional)\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  GMX base reward inbound swap amount\n        @return gmxAmountOut           uint256  GMX outbound swap amount\n        @return pxGmxMintAmount        uint256  pxGMX minted when depositing GMX\n        @return totalFee               uint256  Total platform fee\n        @return incentive              uint256  Compound incentive\n     */\n    function compound(\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        )\n    {\n        if (fee == 0) revert InvalidParam();\n        if (amountOutMinimum == 0) revert InvalidParam();\n\n        uint256 assetsBeforeClaim = asset.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n\n        // Swap entire reward balance for GMX\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            gmxAmountOut = SWAP_ROUTER.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: address(gmxBaseReward),\n                    tokenOut: address(gmx),\n                    fee: fee,\n                    recipient: address(this),\n                    amountIn: gmxBaseRewardAmountIn,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\n                })\n            );\n\n            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount\n            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(\n                gmx.balanceOf(address(this)),\n                address(this)\n            );\n        }\n\n        // Only distribute fees if the amount of vault assets increased\n        if ((totalAssets() - assetsBeforeClaim) != 0) {\n            totalFee =\n                ((asset.balanceOf(address(this)) - assetsBeforeCl"
    }
  ]
}