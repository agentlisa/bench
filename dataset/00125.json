{
  "Title": "Time-weighted average reserves should be read from the Beanstalk Pump in `LibWell` using a `try/catch` block",
  "Content": "There are instances in [`LibWell::getTwaReservesFromBeanstalkPump`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Well/LibWell.sol#L242) and [`LibWell::getTwaLiquidityFromBeanstalkPump`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Well/LibWell.sol#L262) where the time-weighted average reserves are read directly from the Beanstalk Pump. Unlike the implementation in [`LibWellMinting::twaDeltaB`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Minting/LibWellMinting.sol#L160), these functions do not wrap the call in a `try/catch` block. This should not affect the Beanstalk Sunrise mechanism as the execution of `LibWell::getTwaReservesFromStorageOrBeanstalkPump` will not reach the [invocation](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Well/LibWell.sol#L228) of `LibWell::getTwaReservesFromBeanstalkPump`, since here the reserves are already set in storage, but consider handling Pump failure gracefully so that [`LibEvaluate::calcLPToSupplyRatio`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/LibEvaluate.sol#L222) and [`SeasonGettersFacet::getBeanEthTwaUsdLiquidity`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonGettersFacet.sol#L227-L232) (which is also used in [`SeasonGettersFacet::getTotalUsdLiquidity`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/sun/SeasonFacet/SeasonGettersFacet.sol#L238-L240)) do not revert if there is an issue.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Well/LibWell.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {ICumulativePump} from \"contracts/interfaces/basin/pumps/ICumulativePump.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {AppStorage, LibAppStorage, Storage} from \"../LibAppStorage.sol\";\nimport {LibUsdOracle} from \"contracts/libraries/Oracle/LibUsdOracle.sol\";\nimport {LibSafeMath128} from \"contracts/libraries/LibSafeMath128.sol\";\n\n/**\n * @title Well Library\n * Contains helper functions for common Well related functionality.\n **/\nlibrary LibWell {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n\n    // The BDV Selector that all Wells should be whitelisted with.\n    bytes4 internal constant WELL_BDV_SELECTOR = 0xc84c7727;\n\n    /**\n     * @dev Returns the price ratios between `tokens` and the index of Bean in `tokens`.\n     * These actions are combined into a single function for gas efficiency.\n     */\n    function getRatiosAndBeanIndex(\n        IERC20[] memory tokens\n    ) internal view returns (uint[] memory ratios, uint beanIndex, bool success) {\n        success = true;\n        ratios = new uint[](tokens.length);\n        beanIndex = type(uint256).max;\n        for (uint i; i < tokens.length; ++i) {\n            if (C.BEAN == address(tokens[i])) {\n                beanIndex = i;\n                ratios[i] = 1e6;\n            } else {\n                ratios[i] = LibUsdOracle.getUsdPrice(address(tokens[i]));\n                if (ratios[i] == 0) {\n                    success = false;\n                }\n            }\n        }\n        require(beanIndex != type(uint256).max, \"Bean not in Well.\");\n    }\n\n    /**\n     * @dev Returns the index of Bean in a list of tokens.\n     */\n    function getBeanIndex(IERC20[] memory tokens) internal pure returns (uint beanIndex) {\n        for (beanIndex; beanIndex < tokens.length; ++beanIndex) {\n            if (C.BEAN == address(tokens[beanIndex])) {\n                return beanIndex;\n            }\n        }\n        revert(\"Bean not in Well.\");\n    }\n\n    /**\n     * @dev Returns the index of Bean given a Well.\n     */\n    function getBeanIndexFromWell(address well) internal view returns (uint beanIndex) {\n        IERC20[] memory tokens = IWell(well).tokens();\n        beanIndex = getBeanIndex(tokens);\n    }\n\n    /**\n     * @dev Returns the non-Bean token within a Well.\n     * Assumes a well with 2 tokens only.\n     * Cannot fail (and thus revert), as wells cannot have 2 of the same tokens as the pairing.\n     */\n    function getNonBeanTokenAndIndexFromWell(\n        address well\n    ) internal view returns (address, uint256) {\n        IERC20[] memory tokens = IWell(well).tokens();\n        for (uint256 i; i < tokens.length; i++) {\n            if (address(tokens[i]) != C.BEAN) {\n                return (address(tokens[i]), i);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns whether an address is a whitelisted Well by checking\n     * if the BDV function selector is the `wellBdv` function.\n     */\n    function isWell(address well) internal view returns (bool _isWell) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.ss[well].selector == WELL_BDV_SELECTOR;\n    }\n\n    /**\n     * @notice gets the non-bean usd liquidity of a well,\n     * using the twa reserves and price in storage.\n     *\n     * @dev this is done for gas efficency purposes, rather than calling the pump multiple times.\n     * This function should be called after the reserves for the well have been set.\n     * Currently this is only done in {seasonFacet.sunrise}.\n     *\n     * if LibWell.getUsdTokenPriceForWell() returns 1, then this function is called without the reserves being set.\n     * if s.usdTokenPrice[well] or s.twaReserves[well] returns 0, then the oracle failed to compute\n     * a valid price this Season, and thus beanstalk cannot calculate the usd liquidity.\n     */\n    function getWellTwaUsdLiquidityFromReserves(\n        address well,\n        uint256[] memory twaReserves\n    ) internal view returns (uint256 usdLiquidity) {\n        uint256 tokenUsd = getUsdTokenPriceForWell(well);\n        (address token, uint256 j) = getNonBeanTokenAndIndexFromWell(well);\n        if (tokenUsd > 1) {\n            return twaReserves[j].mul(1e18).div(tokenUsd);\n        }\n\n        // if tokenUsd == 0, then the beanstalk could not compute a valid eth price,\n        // and should return 0. if s.twaReserves[C.BEAN_ETH_WELL].reserve1 is 0, the previous if block will return 0.\n        if (tokenUsd == 0) {\n            return 0;\n        }\n\n        // if the function reaches here, then this is called outside the sunrise function\n        // (i.e, seasonGetterFacet.getLiquidityToSupplyRatio()).We use LibUsdOracle\n        // to get the price. This should never be reached during sunrise and thus\n        // should not impact gas.\n        return LibUsdOracle.getTokenPrice(token).mul(twaReserves[j]).div(1e6);\n    }\n\n    /**\n     * @dev Sets the price in {AppStorage.usdTokenPrice} given a set of ratios.\n     * It assumes that the ratios correspond to the Constant Product Well indexes.\n     */\n    function setUsdTokenPriceForWell(address well, uint256[] memory ratios) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        // If the reserves length is 0, then {LibWellMinting} failed to compute\n        // valid manipulation resistant reserves and thus the price is set to 0\n        // indicating that the oracle failed to compute a valid price this Season.\n        if (ratios.length == 0) {\n            s.usdTokenPrice[well] = 0;\n        } else {\n            (, uint256 j) = getNonBeanTokenAndIndexFromWell(well);\n            s.usdTokenPrice[well] = ratios[j];\n        }\n    }\n\n    /**\n     * @notice Returns the USD / TKN price stored in {AppStorage.usdTokenPrice}.\n     * @dev assumes TKN has 18 decimals.\n     */\n    function getUsdTokenPriceForWell(address well) internal view returns (uint tokenUsd) {\n        tokenUsd = LibAppStorage.diamondStorage().usdTokenPrice[well];\n    }\n\n    /**\n     * @notice resets token price for a well to 1.\n     * @dev must be called at the end of sunrise() once the\n     * price is not needed anymore to save gas.\n     */\n    function resetUsdTokenPriceForWell(address well) internal {\n        LibAppStorage.diamondStorage().usdTokenPrice[well] = 1;\n    }\n\n    /**\n     * @dev Sets the twaReserves in {AppStorage.usdTokenPrice}.\n     * assumes the twaReserve indexes correspond to the Constant Product Well indexes.\n     * if the length of the twaReserves is 0, then the minting oracle is off.\n     *\n     */\n    function setTwaReservesForWell(address well, uint256[] memory twaReserves) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // if the length of twaReserves is 0, then return 0.\n        // the length of twaReserves should never be 1, but\n        // is added for safety.\n        if (twaReserves.length < 1) {\n            delete s.twaReserves[well].reserve0;\n            delete s.twaReserves[well].reserve1;\n        } else {\n            // safeCast not needed as the reserves are uint128 in the wells.\n            s.twaReserves[well].reserve0 = uint128(twaReserves[0]);\n            s.twaReserves[well].reserve1 = uint128(twaReserves[1]);\n        }\n    }\n\n    /**\n     * @notice Returns the USD / TKN price stored in {AppStorage.usdTokenPrice}.\n     * @dev assumes TKN has 18 decimals.\n     */\n    function getTwaReservesForWell(\n        address well\n    ) internal view returns (uint256[] memory twaReserves) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        twaReserves = new uint256[](2);\n        twaReserves[0] = s.twaReserves[well].reserve0;\n        twaReserves[1] = s.twaReserves[well].reserve1;\n    }\n\n    /**\n     * @notice resets token price for a well to 1.\n     * @dev must be called at the end of sunrise() once the\n     * price is not needed anymore to save gas.\n     */\n    function resetTwaReservesForWell(address well) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.twaReserves[well].reserve0 = 1;\n        s.twaReserves[well].reserve1 = 1;\n    }\n\n    function getWellPriceFromTwaReserves(address well) internal view returns (uint256 price) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // s.twaReserve[well] should be set prior to this function being called.\n        // 'price' is in terms of reserve0:reserve1.\n        if (s.twaReserves[well].reserve0 == 0) {\n            price = 0;\n        } else {\n            price = s.twaReserves[well].reserve0.mul(1e18).div(s.twaReserves[well].reserve1);\n        }\n    }\n\n    function getTwaReservesFromStorageOrBeanstalkPump(\n        address well\n    ) internal view returns (uint256[] memory twaReserves) {\n        twaReserves = getTwaReservesForWell(well);\n        if (twaReserves[0] == 1) {\n            twaReserves = getTwaReservesFromBeanstalkPump(well);\n        }\n    }\n\n    /**\n     * @notice gets the TwaReserves of a given well.\n     * @dev only supports wells that are whitelisted in beanstalk.\n     * the inital timestamp and reserves is the timestamp of the start\n     * of the last season.\n     */\n    function getTwaReservesFromBeanstalkPump(\n        address well\n    ) internal view returns (uint256[] memory twaReserves) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        (twaReserves, ) = ICumulativePump(C.BEANSTALK_PUMP).readTwaReserves(\n            well,\n            s.wellOracleSnapshots[well],\n            s.season.timestamp,\n            C.BYTES_ZERO\n        );\n    }\n\n    /**\n     * @notice gets the TwaLiquidity of a given well.\n     * @dev only supports wells that are whitelisted in beanstalk.\n     * the inital timestamp and reserves is the timestamp of the start\n     * of the last season.\n     */\n    function getTwaLiquidityFromBeanstalkPump(\n        address well,\n        uint256 tokenUsdPrice\n    ) internal view returns (uint256 usdLiquidity) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        (, uint256 j) = getNonBeanTokenAndIndexFromWell(well);\n        (uint256[] memory twaReserves, ) = ICumulativePump(C.BEANSTALK_PUMP).readTwaReserves(\n            well,\n            s.wellOracleSnapshots[well],\n            s.season.timestamp,\n            C.BYTES_ZERO\n        );\n        usdLiquidity = tokenUsdPrice.mul(twaReserves[j]).div(1e6);\n    }\n}"
    }
  ]
}