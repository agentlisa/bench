{
  "Title": "Timestamp Discrepancy in Spot Oracle Price Feeds May Cause Inaccurate Price",
  "Content": "The [`getPrice` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/oracles/spot/EthXSpotOracle.sol#L38) of the `EthXSpotOracle` contract computes the price of ETHx in ETH. Two oracles are used to determine the price: a Redstone oracle returns the price of ETHx in USD, and a Chainlink oracle returns the price of ETH in USD. These prices are combined to return the price of ETHx in ETH.\n\n\nThe corresponding timestamps for the prices for the oracles are never validated to ensure they are from similar times. If there is a significant discrepancy between the timestamps for the price feeds, this could result in an inaccurate ETHx in ETH price. Specifically, the two prices might have significant misalignment during volatile periods and may be large enough to cause a significant impact on the health of users' vaults. This situation could lead to the following:\n\n\n* A user could take on less additional debt if the oracle underprices their collateral.\n* A user could take on more debt than intended when collateral is over-priced, although this overpricing will never exceed the reserve exchange rate.\n\n\nConsider validating that the two price feeds are returning prices from similar timestamps.\n\n\n***Update:** Acknowledged, not resolved. Ion Protocol team stated:*\n\n\n\n> *The concern around the delayed oracle misrepresenting user health vaults is not an issue that will lead to a loss of user-locked funds as no liquidation can be triggered by the spot oracle price. The spot oracle can malfunction by either 'under' valuing or 'over' valuing the market price. This misrepresented spot oracle in the core protocol is used to value the collateral when issuing debt, such that the user debt-to-collateral ratio will adhere to the LTV. It is important to note that the value reported by the spot oracle is not used for liquidations.*\n> \n> \n> *If the spot oracle ‘under’ reports a value, this will temporarily reduce the amount of debt that the borrowers can take out from the Ion Pool. However, it will neither lead to a liquidation nor an increase in borrow rate payments and therefore will not result in a loss for the borrower. It will only restrict the amount of debt possible to be issued. There is also no loss for the lenders aside from the borrowers creating fewer loans than what would theoretically have been possible.*\n> \n> \n> *If the spot oracle ‘over’ represents the value, this will allow the user to borrow more funds compared to using the ‘fair’ value. However, the maximum this value will reach is the exchange rate reported by the reserve oracle as the spot oracle is maximum-bounded by the exchange rate. This means that even in times of overvalued spot prices, the maximum divergence it can have is capped by the exchange rate. This means that the lenders will never be issuing loans at a valuation any higher than the native redemption value of the staked collateral which is the exchange rate.*\n> \n> \n> *The spot oracle is upper-bounded by the exchange rate value reported by the reserve oracle. Thus, the maximum price a spot oracle can report is the exchange rate. If the 'true' value of the market price of the asset falls in a drastic de-peg event, and the spot oracle is manipulated to report a value much larger than this 'true' value, then the risk exists that the attacker can borrow more than they theoretically should have at the true value. In the case of this oracle manipulation, the protocol would redeem the collateral into the beacon chain instead of selling it to make lenders whole. This is possible since the manipulated spot price will again be capped by the exchange rate.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/oracles/spot/EthXSpotOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.21;\n\nimport { SpotOracle } from \"src/oracles/spot/SpotOracle.sol\";\nimport { IChainlink } from \"src/interfaces/IChainlink.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\n\ninterface IRedstonePriceFeed {\n    function latestAnswer() external view returns (int256 answer);\n}\n\nuint8 constant REDSTONE_DECIMALS = 8;\nuint8 constant CHAINLINK_DECIMALS = 8;\n\ncontract EthXSpotOracle is SpotOracle {\n    using WadRayMath for uint256;\n\n    IRedstonePriceFeed immutable REDSTONE_ETHX_PRICE_FEED;\n    IChainlink immutable USD_PER_ETH_CHAINLINK;\n\n    constructor(\n        uint256 _ltv,\n        address _reserveOracle,\n        address _redstoneEthXPriceFeed,\n        address _usdPerEthChainlink\n    )\n        SpotOracle(_ltv, _reserveOracle)\n    {\n        REDSTONE_ETHX_PRICE_FEED = IRedstonePriceFeed(_redstoneEthXPriceFeed);\n        USD_PER_ETH_CHAINLINK = IChainlink(_usdPerEthChainlink);\n    }\n\n    // @notice Gets the price of ETHx in ETH. \n    // @dev redstone oracle returns dollar value per ETHx with 6 decimals.\n    // This needs to be converted to [wad] and to ETH denomination.\n    // @return ethPerEthX price of ETHx in ETH [wad] \n    function getPrice() public view override returns (uint256 ethPerEthX) {\n        // get price from the protocol feed\n        // usd per ETHx\n\n        uint256 usdPerEthX = uint256(REDSTONE_ETHX_PRICE_FEED.latestAnswer()).scaleUpToWad(REDSTONE_DECIMALS); //\n\n        // usd per ETH\n        (, int256 _usdPerEth,,,) = USD_PER_ETH_CHAINLINK.latestRoundData(); // price of stETH denominated in ETH\n        uint256 usdPerEth = uint256(_usdPerEth).scaleUpToWad(CHAINLINK_DECIMALS); // price of stETH denominated in ETH\n\n        // (USD per ETHx) / (USD per ETH) = (USD per ETHx) * (ETH per USD) = ETH per ETHx\n        ethPerEthX = usdPerEthX.wadDivDown(usdPerEth);\n    }\n}"
    }
  ]
}