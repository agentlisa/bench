{
  "Title": "[N-02] `_sendToRecipient(...)` is unnecessary if the `receiver` is passed as the `receipient` of the swap parameter.",
  "Content": "\nThere are 2 instances of this\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/swappers/UniSwapper.sol#L130C13-L140C68\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/swappers/UniSwapper.sol#L150C13-L168C79\n\nThe `swapExactIn(...)` and the `swapExactOut(...)` did a two way movement of output asset by first sending the output asset of the swap to `address(this)` before sending it to the receiver.\n\nIt is much more efficient to pass the `receiver` parameter as the `recipient` address in the swap param in order to directly send asset to the `receiver`.\n\nWith this there will be no need for the `_sendToRecipient(...)` function since swap output will be sent directly.\n\n```\nfunction swapExactIn(\n        SwapParams memory swapParams, // SwapParams is a struct\n        address receiver\n    ) public payable routerIsSet returns (uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: swapParams.path,\n@>                recipient: address(this),//@audit pass receiver here\n                amountIn: swapParams.amountIn,\n                amountOutMinimum: swapParams.amountOut\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountOut = IV3SwapRouter(uniswap_router).exactInput(params);\n\n@>        _sendToRecipient(receiver, swapParams.tokenOut, amountOut);\n    }\n\n```\n\n### Impact:\n\nWaste of gas and adds more unnecessary codes to the codebase which could open more attack surface for vulnerabilities.\n\n### Recommendation:\n\nConsider passing the `receiver` parameter to the ExactInputParams' `receipient` like in this diff below\n```diff\nfunction swapExactIn(...) {\n...\n  IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: swapParams.path,\n--              recipient: address(this),\n++              recipient: receiver,\n                amountIn: swapParams.amountIn,\n                amountOutMinimum: swapParams.amountOut\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountOut = IV3SwapRouter(uniswap_router).exactInput(params);\n\n--      _sendToRecipient(receiver, swapParams.tokenOut, amountOut);\n}\n```\n\n**[0xsomeone (Judge) commented](https://github.com/code-423n4/2024-01-decent-findings/issues/83#issuecomment-1925955233):**\n > This report is tied with #276 and was selected as the best due to its more curated look, highlighting instances per finding instead of containing only code. \n\n**[wkantaros (Decent) confirmed](https://github.com/code-423n4/2024-01-decent-findings/issues/83#issuecomment-1942661707)**\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/swappers/UniSwapper.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {UTBOwned} from \"../UTBOwned.sol\";\nimport {SwapParams} from \"./SwapParams.sol\";\nimport {SwapDirection} from \"./SwapParams.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ISwapper} from \"../UTB.sol\";\nimport {IV3SwapRouter} from \"@uniswap/swap-contracts/interfaces/IV3SwapRouter.sol\";\n\ncontract UniSwapper is UTBOwned, ISwapper {\n    constructor() UTBOwned() {}\n\n    uint8 public constant SWAPPER_ID = 0;\n    address public uniswap_router;\n    address payable public wrapped;\n\n    function setRouter(address _router) public onlyOwner {\n        uniswap_router = _router;\n    }\n\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = _wrapped;\n    }\n\n    function getId() public pure returns (uint8) {\n        return SWAPPER_ID;\n    }\n\n    function updateSwapParams(\n        SwapParams memory newSwapParams,\n        bytes memory payload\n    ) external pure returns (bytes memory) {\n        (, address receiver, address refund) = abi.decode(\n            payload,\n            (SwapParams, address, address)\n        );\n        return abi.encode(newSwapParams, receiver, refund);\n    }\n\n    function _refundUser(address user, address token, uint amount) private {\n        IERC20(token).transfer(user, amount);\n    }\n\n    function _sendToRecipient(\n        address recipient,\n        address token,\n        uint amount\n    ) private {\n        if (token == address(0)) {\n            token = wrapped;\n        }\n        IERC20(token).transfer(recipient, amount);\n    }\n\n    function swap(\n        bytes memory swapPayload\n    )\n        external\n        onlyUtb\n        returns (address tokenOut, uint256 amountOut)\n    {\n        (SwapParams memory swapParams, address receiver, address refund) = abi\n            .decode(swapPayload, (SwapParams, address, address));\n        tokenOut = swapParams.tokenOut;\n        if (swapParams.path.length == 0) {\n            return swapNoPath(swapParams, receiver, refund);\n        }\n        if (swapParams.direction == SwapDirection.EXACT_IN) {\n            amountOut = swapExactIn(swapParams, receiver);\n        } else {\n            swapExactOut(swapParams, receiver, refund);\n            amountOut = swapParams.amountOut;\n        }\n    }\n\n    function _receiveAndWrapIfNeeded(\n        SwapParams memory swapParams\n    ) private returns (SwapParams memory _swapParams) {\n        if (swapParams.tokenIn != address(0)) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n            return swapParams;\n        }\n        swapParams.tokenIn = wrapped;\n        IWETH(wrapped).deposit{value: swapParams.amountIn}();\n        return swapParams;\n    }\n\n    modifier routerIsSet() {\n        require(uniswap_router != address(0), \"router not set\");\n        _;\n    }\n\n    function swapNoPath(\n        SwapParams memory swapParams,\n        address receiver,\n        address refund\n    ) public payable returns (address tokenOut, uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        if (swapParams.direction == SwapDirection.EXACT_OUT) {\n            _refundUser(\n                refund,\n                swapParams.tokenIn,\n                swapParams.amountIn - swapParams.amountOut\n            );\n        }\n\n        uint amt2Recipient = swapParams.direction == SwapDirection.EXACT_OUT\n            ? swapParams.amountOut\n            : swapParams.amountIn;\n\n        _sendToRecipient(receiver, swapParams.tokenOut, amt2Recipient);\n        return (swapParams.tokenOut, amt2Recipient);\n    }\n\n    function swapExactIn(\n        SwapParams memory swapParams, // SwapParams is a struct\n        address receiver\n    ) public payable routerIsSet returns (uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                amountIn: swapParams.amountIn,\n                amountOutMinimum: swapParams.amountOut\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountOut = IV3SwapRouter(uniswap_router).exactInput(params);\n\n        _sendToRecipient(receiver, swapParams.tokenOut, amountOut);\n    }\n\n    function swapExactOut(\n        SwapParams memory swapParams,\n        address receiver,\n        address refundAddress\n    ) public payable routerIsSet returns (uint256 amountIn) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n        IV3SwapRouter.ExactOutputParams memory params = IV3SwapRouter\n            .ExactOutputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountOut: swapParams.amountOut,\n                amountInMaximum: swapParams.amountIn\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountIn = IV3SwapRouter(uniswap_router).exactOutput(params);\n\n        // refund sender\n        _refundUser(\n            refundAddress,\n            swapParams.tokenIn,\n            params.amountInMaximum - amountIn\n        );\n\n        _sendToRecipient(receiver, swapParams.tokenOut, swapParams.amountOut);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    {
      "filename": "src/swappers/UniSwapper.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {UTBOwned} from \"../UTBOwned.sol\";\nimport {SwapParams} from \"./SwapParams.sol\";\nimport {SwapDirection} from \"./SwapParams.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {IWETH} from \"decent-bridge/src/interfaces/IWETH.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ISwapper} from \"../UTB.sol\";\nimport {IV3SwapRouter} from \"@uniswap/swap-contracts/interfaces/IV3SwapRouter.sol\";\n\ncontract UniSwapper is UTBOwned, ISwapper {\n    constructor() UTBOwned() {}\n\n    uint8 public constant SWAPPER_ID = 0;\n    address public uniswap_router;\n    address payable public wrapped;\n\n    function setRouter(address _router) public onlyOwner {\n        uniswap_router = _router;\n    }\n\n    function setWrapped(address payable _wrapped) public onlyOwner {\n        wrapped = _wrapped;\n    }\n\n    function getId() public pure returns (uint8) {\n        return SWAPPER_ID;\n    }\n\n    function updateSwapParams(\n        SwapParams memory newSwapParams,\n        bytes memory payload\n    ) external pure returns (bytes memory) {\n        (, address receiver, address refund) = abi.decode(\n            payload,\n            (SwapParams, address, address)\n        );\n        return abi.encode(newSwapParams, receiver, refund);\n    }\n\n    function _refundUser(address user, address token, uint amount) private {\n        IERC20(token).transfer(user, amount);\n    }\n\n    function _sendToRecipient(\n        address recipient,\n        address token,\n        uint amount\n    ) private {\n        if (token == address(0)) {\n            token = wrapped;\n        }\n        IERC20(token).transfer(recipient, amount);\n    }\n\n    function swap(\n        bytes memory swapPayload\n    )\n        external\n        onlyUtb\n        returns (address tokenOut, uint256 amountOut)\n    {\n        (SwapParams memory swapParams, address receiver, address refund) = abi\n            .decode(swapPayload, (SwapParams, address, address));\n        tokenOut = swapParams.tokenOut;\n        if (swapParams.path.length == 0) {\n            return swapNoPath(swapParams, receiver, refund);\n        }\n        if (swapParams.direction == SwapDirection.EXACT_IN) {\n            amountOut = swapExactIn(swapParams, receiver);\n        } else {\n            swapExactOut(swapParams, receiver, refund);\n            amountOut = swapParams.amountOut;\n        }\n    }\n\n    function _receiveAndWrapIfNeeded(\n        SwapParams memory swapParams\n    ) private returns (SwapParams memory _swapParams) {\n        if (swapParams.tokenIn != address(0)) {\n            IERC20(swapParams.tokenIn).transferFrom(\n                msg.sender,\n                address(this),\n                swapParams.amountIn\n            );\n            return swapParams;\n        }\n        swapParams.tokenIn = wrapped;\n        IWETH(wrapped).deposit{value: swapParams.amountIn}();\n        return swapParams;\n    }\n\n    modifier routerIsSet() {\n        require(uniswap_router != address(0), \"router not set\");\n        _;\n    }\n\n    function swapNoPath(\n        SwapParams memory swapParams,\n        address receiver,\n        address refund\n    ) public payable returns (address tokenOut, uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        if (swapParams.direction == SwapDirection.EXACT_OUT) {\n            _refundUser(\n                refund,\n                swapParams.tokenIn,\n                swapParams.amountIn - swapParams.amountOut\n            );\n        }\n\n        uint amt2Recipient = swapParams.direction == SwapDirection.EXACT_OUT\n            ? swapParams.amountOut\n            : swapParams.amountIn;\n\n        _sendToRecipient(receiver, swapParams.tokenOut, amt2Recipient);\n        return (swapParams.tokenOut, amt2Recipient);\n    }\n\n    function swapExactIn(\n        SwapParams memory swapParams, // SwapParams is a struct\n        address receiver\n    ) public payable routerIsSet returns (uint256 amountOut) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                amountIn: swapParams.amountIn,\n                amountOutMinimum: swapParams.amountOut\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountOut = IV3SwapRouter(uniswap_router).exactInput(params);\n\n        _sendToRecipient(receiver, swapParams.tokenOut, amountOut);\n    }\n\n    function swapExactOut(\n        SwapParams memory swapParams,\n        address receiver,\n        address refundAddress\n    ) public payable routerIsSet returns (uint256 amountIn) {\n        swapParams = _receiveAndWrapIfNeeded(swapParams);\n        IV3SwapRouter.ExactOutputParams memory params = IV3SwapRouter\n            .ExactOutputParams({\n                path: swapParams.path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountOut: swapParams.amountOut,\n                amountInMaximum: swapParams.amountIn\n            });\n\n        IERC20(swapParams.tokenIn).approve(uniswap_router, swapParams.amountIn);\n        amountIn = IV3SwapRouter(uniswap_router).exactOutput(params);\n\n        // refund sender\n        _refundUser(\n            refundAddress,\n            swapParams.tokenIn,\n            params.amountInMaximum - amountIn\n        );\n\n        _sendToRecipient(receiver, swapParams.tokenOut, swapParams.amountOut);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    }
  ]
}