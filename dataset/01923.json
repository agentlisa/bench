{
  "Title": "M-1: MarginTrading.sol: The whole balance and not just the traded funds are deposited into Aave when a trade is opened",
  "Content": "# Issue M-1: MarginTrading.sol: The whole balance and not just the traded funds are deposited into Aave when a trade is opened \n\nSource: https://github.com/sherlock-audit/2023-05-dodo-judging/issues/72 \n\n## Found by \nroguereddwarf\n## Summary\nIt's expected by the protocol that funds can be in the `MarginTrading` contract without being deposited into Aave as margin.\n\nWe can see this by looking at the `MarginTradingFactory.depositMarginTradingETH` and `MarginTradingFactory.depositMarginTradingERC20` functions.\n\nIf the user sets `margin=false` as the parameter, the funds are only sent to the `MarginTrading` contract but NOT deposited into Aave.\n\nhttps://github.com/sherlock-audit/2023-05-dodo/blob/main/dodo-margin-trading-contracts/contracts/marginTrading/MarginTradingFactory.sol#L203-L211\n\nhttps://github.com/sherlock-audit/2023-05-dodo/blob/main/dodo-margin-trading-contracts/contracts/marginTrading/MarginTradingFactory.sol#L259-L272\n\nSo clearly there is the expectation for funds to be in the `MarginTrading` contract that should not be deposited into Aave.\n\nThis becomes an issue when a trade is opened.\n\n## Vulnerability Detail\nLet's look at the `MarginTrading._openTrade` function that is called when a trade is opened:\n\nhttps://github.com/sherlock-audit/2023-05-dodo/blob/main/dodo-margin-trading-contracts/contracts/marginTrading/MarginTrading.sol#L257-L279\n\nThe whole balance of the token will be deposited into Aave:\n\n```solidity\n_tradeAmounts[i] = IERC20(_tradeAssets[i]).balanceOf(address(this)); \n_lendingPoolDeposit(_tradeAssets[i], _tradeAmounts[i], 1); \n```\n\nNot just those funds that have been acquired by the swap. This means that funds that should stay in the `MarginTrading` contract might also be deposited as margin.\n\n## Impact\nWhen opening a trade funds can be deposited into Aave unintentionally. Thereby the funds act as margin and the trade can incur a larger loss than expected.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-dodo/blob/main/dodo-margin-trading-contracts/contracts/marginTrading/MarginTradingFactory.sol#L203-L211\n\nhttps://github.com/sherlock-audit/2023-05-dodo/blob/main/dodo-margin-trading-contracts/contracts/marginTrading/MarginTradingFactory.sol#L259-L272\n\nhttps://github.com/sherlock-audit/2023-05-dodo/blob/main/dodo-margin-trading-contracts/contracts/marginTrading/MarginTrading.sol#L257-L279\n\n## Tool used\nManual Review\n\n## Recommendation\nIt is necessary to differentiate the funds that are acquired by the swap and those funds that were there before and should stay in the contract:\n\n```diff\ndiff --git a/dodo-margin-trading-contracts/contracts/marginTrading/MarginTrading.sol b/dodo-margin-trading-contracts/contracts/marginTrading/MarginTrading.sol\nindex f68c1f3..42f96cf 100644\n--- a/dodo-margin-trading-contracts/contracts/marginTrading/MarginTrading.sol\n+++ b/dodo-margin-trading-contracts/contracts/marginTrading/MarginTrading.sol\n@@ -261,6 +261,10 @@ contract MarginTrading is OwnableUpgradeable, IMarginTrading, IFlashLoanReceiver\n         bytes memory _swapParams,\n         address[] memory _tradeAssets\n     ) internal {\n+        int256[] memory _amountsBefore = new uint256[](_tradeAssets.length);\n+        for (uint256 i = 0; i < _tradeAssets.length; i++) {\n+            _amountsBefore[i] = IERC20(_tradeAssets[i]).balanceOf(address(this));\n+        }\n         if (_swapParams.length > 0) {\n             // approve to swap route\n             for (uint256 i = 0; i < _swapApproveToken.length; i++) {\n@@ -272,8 +276,10 @@ contract MarginTrading is OwnableUpgradeable, IMarginTrading, IFlashLoanReceiver\n         }\n         uint256[] memory _tradeAmounts = new uint256[](_tradeAssets.length);\n         for (uint256 i = 0; i < _tradeAssets.length; i++) {\n-            _tradeAmounts[i] = IERC20(_tradeAssets[i]).balanceOf(address(this));\n-            _lendingPoolDeposit(_tradeAssets[i], _tradeAmounts[i], 1);\n+            if (_amountsBefore[i] < IERC20(_tradeAssets[i]).balanceOf(address(this))) {\n+                _tradeAmounts[i] = IERC20(_tradeAssets[i]).balanceOf(address(this)) - _amountsBefore[i];\n+                _lendingPoolDeposit(_tradeAssets[i], _tradeAmounts[i], 1);\n+            }\n         }\n         emit OpenPosition(_swapAddress, _swapApproveToken, _tradeAssets, _tradeAmounts);\n     }\n```\n\nIf funds that were in the contract prior to the swap should be deposited there is the separate `MarginTrading.lendingPoolDeposit` function to achieve this.\n\n\n\n## Discussion\n\n**Zack995**\n\nIn terms of product design, users do not have a separate concept of balance. However, the contract is designed to be more flexible and allows for balances to be maintained. Users will not perceive or interact with balances in terms of user experience or operations.\n\n**roguereddwarf**\n\nBased on the smart contract logic there is clearly the notion of balance that is not intended to be used as collateral (but e.g. used to repay a loan).\nIf this notion of a separate balance is not exposed on the front-end this is not a sufficient mitigation of the issue since the issue is clearly present in the smart contract.\n\n**securitygrid**\n\nEscalate for 10 USDC\nThis is valid low/info as stated by the sponsor. No bad impact.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> This is valid low/info as stated by the sponsor. No bad impact.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\ncan consider #80 duplicate of this one\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this issue as valid medium based on the above comments from smart contract perspective and enforcing in the front end is not a mitigation as mentioned above. \n\n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [securitygrid](https://github.com/sherlock-audit/2023-05-dodo-judging/issues/72/#issuecomment-1565183119): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/78",
  "Code": [
    {
      "filename": "dodo-margin-trading-contracts/contracts/marginTrading/MarginTradingFactory.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.15;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {IMarginTrading} from \"./interfaces/IMarginTrading.sol\";\nimport {IMarginTradingFactory} from \"./interfaces/IMarginTradingFactory.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDODOApprove} from \"./interfaces/IDODOApprove.sol\";\nimport {MarginTrading} from \"./MarginTrading.sol\";\n\ncontract MarginTradingFactory is Ownable, IMarginTradingFactory {\n    event CleanToken(address _tokenAddress, address _to, uint256 _amount);\n\n    event CleanETH(address _to, uint256 _amount);\n\n    address public immutable MARGIN_TRADING_TEMPLATE;\n    address internal LendingPool;\n    IWETH internal WETH;\n    IDODOApprove internal DODOApprove;\n    // user => approveAddress = > bool\n    mapping(address => mapping(address => bool)) public ALLOWED_FLASH_LOAN;\n\n    mapping(address => address[]) public crossMarginTrading;\n\n    mapping(address => address[]) public isolatedMarginTrading;\n\n    //user approve close address\n    constructor(address _lendingPool, address _weth, address _DODOApprove, address _template) {\n        LendingPool = _lendingPool;\n        WETH = IWETH(_weth);\n        MARGIN_TRADING_TEMPLATE = _template;\n        DODOApprove = IDODOApprove(_DODOApprove);\n    }\n\n    receive() external payable {}\n\n    /// @notice Get the marginTrading contract address created by the user.\n    /// @param _num MarginTrading contract Num\n    /// @param _flag 1 -cross , 2 - isolated\n    /// @param _user User address\n    /// @return _ad User marginTrading contract\n    function getCreateMarginTradingAddress(\n        uint256 _num,\n        uint8 _flag,\n        address _user\n    ) external view returns (address _ad) {\n        _ad =\n            Clones.predictDeterministicAddress(MARGIN_TRADING_TEMPLATE, keccak256(abi.encodePacked(_user, _num, _flag)));\n    }\n\n    /// @notice To get the number of marginTrading contracts created by a user.\n    /// @param _user User address\n    /// @return _crossNum User cross marginTrading contract num\n    /// @return _isolateNum User isolate marginTrading contract num\n    function getUserMarginTradingNum(address _user) external view returns (uint256 _crossNum, uint256 _isolateNum) {\n        _crossNum = crossMarginTrading[_user].length;\n        _isolateNum = isolatedMarginTrading[_user].length;\n    }\n\n    /// @notice Get whether the proxyAddress is allowed to call the marginTrading contract.\n    /// @param _marginTradingAddress Margin trading address\n    /// @param _proxy Proxy user address\n    /// @return True is Allowed\n    function isAllowedProxy(address _marginTradingAddress, address _proxy) external view returns (bool) {\n        return ALLOWED_FLASH_LOAN[_marginTradingAddress][_proxy];\n    }\n\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            results[i] = result;\n        }\n    }\n\n    // ============ Functions ============\n\n    /// @notice Add the proxy address that is allowed to execute flashloan operations.\n    /// @param _marginTradingAddress Margin trading address\n    /// @param _proxy Proxy address\n    function addFlashLoanProxy(address _marginTradingAddress, address _proxy) external {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"caller is not the user\");\n        ALLOWED_FLASH_LOAN[_marginTradingAddress][_proxy] = true;\n    }\n\n    /// @notice Delete the proxy address that is allowed to execute flash loan operation.\n    /// @param _marginTradingAddress Margin trading address\n    /// @param _proxy Proxy address\n    function removeFlashLoanProxy(address _marginTradingAddress, address _proxy) external {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"caller is not the user\");\n        ALLOWED_FLASH_LOAN[_marginTradingAddress][_proxy] = false;\n    }\n\n    /// @notice Create a marginTrading contract for the user, deposit funds, and open a position.\n    /// @dev 1.Create a marginTrading contract for the user.\n    /// @dev 2.Make a deposit.\n    /// @dev 3.Execute the executeFlashLoans method of the marginTrading contract to open a position.\n    /// @param _flag 1 -cross , 2 - isolated\n    /// @param depositParams Deposit execution parameters.\n    /// @param executeParams The parameters for executing the executeFlashLoans function in the marginTrading contract.\n    /// @return marginTrading Create marginTrading address\n    function createMarginTrading(\n        uint8 _flag,\n        bytes calldata depositParams,\n        bytes calldata executeParams\n    ) external payable returns (address marginTrading) {\n        if (_flag == 1) {\n            marginTrading = Clones.cloneDeterministic(\n                MARGIN_TRADING_TEMPLATE,\n                keccak256(abi.encodePacked(msg.sender, crossMarginTrading[msg.sender].length, _flag))\n            );\n            crossMarginTrading[msg.sender].push(marginTrading);\n            emit MarginTradingCreated(msg.sender, marginTrading, crossMarginTrading[msg.sender].length, _flag);\n        }\n        if (_flag == 2) {\n            marginTrading = Clones.cloneDeterministic(\n                MARGIN_TRADING_TEMPLATE,\n                keccak256(abi.encodePacked(msg.sender, isolatedMarginTrading[msg.sender].length, _flag))\n            );\n            isolatedMarginTrading[msg.sender].push(marginTrading);\n            emit MarginTradingCreated(msg.sender, marginTrading, isolatedMarginTrading[msg.sender].length, _flag);\n        }\n        //调用marginTrading地址的合约中的\"initialize\"方法,LendingPool,WETH,user\n        IMarginTrading(marginTrading).initialize(LendingPool, address(WETH), msg.sender);\n        if (depositParams.length > 0) {\n            (\n                uint8 _depositFlag, //1- erc20 2-eth\n                address _tokenAddres,\n                uint256 _depositAmount\n            ) = abi.decode(depositParams, (uint8, address, uint256));\n            if (_depositFlag == 1) {\n                _depositMarginTradingERC20(marginTrading, _tokenAddres, _depositAmount, false, uint8(1));\n            }\n            if (_depositFlag == 2) {\n                depositMarginTradingETH(marginTrading, false, uint8(1));\n            }\n        }\n        if (executeParams.length > 0) {\n            (\n                address[] memory _assets,\n                uint256[] memory _amounts,\n                uint256[] memory _modes,\n                address _mainToken,\n                bytes memory _params\n            ) = abi.decode(executeParams, (address[], uint256[], uint256[], address, bytes));\n            _executeMarginTradingFlashLoans(marginTrading, _assets, _amounts, _modes, _mainToken, _params);\n        }\n    }\n\n    /// @notice Execution marginTrading executeFlashLoans methods for opening and closing.\n    /// @dev Execute a flash loan and pass the parameters to the executeOperation method.\n    /// @param assets Borrowing assets\n    /// @param amounts Borrowing assets amounts\n    /// @param modes Borrowing assets premiums\n    /// @param mainToken initiator address\n    /// @param params The parameters for the execution logic.\n    function executeMarginTradingFlashLoans(\n        address _marginTradingAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address mainToken,\n        bytes calldata params\n    ) external {\n        _executeMarginTradingFlashLoans(_marginTradingAddress, assets, amounts, modes, mainToken, params);\n    }\n\n    /// @notice User deposits ERC20 token into marginTrading contract.\n    /// @dev Use DODOApprove to allow users to deposit ERC20 tokens into the marginTrading contract.\n    /// @param _marginTradingAddress User marginTrading contract address\n    /// @param _marginAddress Margin token address\n    /// @param _marginAmount Margin token amount\n    /// @param _margin Whether to be used as collateral\n    /// @param _flag Operation flag\n    function depositMarginTradingERC20(\n        address _marginTradingAddress,\n        address _marginAddress,\n        uint256 _marginAmount,\n        bool _margin,\n        uint8 _flag\n    ) external {\n        _depositMarginTradingERC20(_marginTradingAddress, _marginAddress, _marginAmount, _margin, _flag);\n    }\n\n    /// @notice User deposits ETH into marginTrading contract.\n    /// @dev Convert ETH to ERC20 token using the WETH contract, and then deposit it into the marginTrading contract.\n    /// @param _marginTradingAddress User marginTrading contract address\n    /// @param _margin Whether to be used as collateral\n    /// @param _flag Operation flag\n    function depositMarginTradingETH(address _marginTradingAddress, bool _margin, uint8 _flag) public payable {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"factory:caller is not the user\");\n        WETH.deposit{value: msg.value}();\n        WETH.transfer(_marginTradingAddress, msg.value);\n        if (_margin) {\n            IMarginTrading(_marginTradingAddress).lendingPoolDeposit(address(WETH), msg.value, _flag);\n        }\n        emit DepositMarginTradingETH(_marginTradingAddress, msg.value, _margin, _flag);\n    }\n\n    /// @notice Owner clean contract ERC20 token\n    /// @param _tokenAddress send ERC20 token address\n    /// @param _to To address\n    /// @param _amt send ERC20 token amount\n    function cleanToken(address _tokenAddress, address _to, uint256 _amt) external onlyOwner {\n        IERC20(_tokenAddress).transfer(_to, _amt);\n        emit CleanToken(_tokenAddress, _to, _amt);\n    }\n\n    /// @notice Owner clean contract ETH.\n    /// @param _to To address\n    /// @param _amt send ETH amount\n    function cleanETH(address _to, uint256 _amt) external onlyOwner {\n        (bool success,) = _to.call{value: _amt}(new bytes(0));\n        require(success, \"ETH_TRANSFER_FAILED\");\n        emit CleanETH(_to, _amt);\n    }\n\n    // =========== internal ==========\n\n    /// @notice Execution marginTrading contract methods for opening and closing.\n    /// @dev Execute a flash loan and pass the parameters to the executeOperation method.\n    /// @param _marginTradingAddress MarginTrading contract address\n    /// @param assets Borrowing assets\n    /// @param amounts Borrowing assets amounts\n    /// @param modes Borrowing assets premiums\n    /// @param mainToken initiator address\n    /// @param params The parameters for the execution logic.\n    function _executeMarginTradingFlashLoans(\n        address _marginTradingAddress,\n        address[] memory assets,\n        uint256[] memory amounts,\n        uint256[] memory modes,\n        address mainToken,\n        bytes memory params\n    ) internal {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"factory: caller is not the user\");\n        IMarginTrading(_marginTradingAddress).executeFlashLoans(assets, amounts, modes, mainToken, params);\n    }\n\n    /// @notice Deposits ERC20 token into marginTrading contract.\n    /// @param _marginTradingAddress MarginTrading contract address\n    /// @param _marginAddress margin token address\n    /// @param _marginAmount margin token Amount\n    /// @param _margin Whether to be used as collateral\n    /// @param _flag Operation flag\n    function _depositMarginTradingERC20(\n        address _marginTradingAddress,\n        address _marginAddress,\n        uint256 _marginAmount,\n        bool _margin,\n        uint8 _flag\n    ) internal {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"factory:caller is not the user\");\n        DODOApprove.claimTokens(_marginAddress, msg.sender, _marginTradingAddress, _marginAmount);\n        if (_margin) {\n            IMarginTrading(_marginTradingAddress).lendingPoolDeposit(_marginAddress, _marginAmount, _flag);\n        }\n        emit DepositMarginTradingERC20(_marginTradingAddress, _marginAddress, _marginAmount, _margin, _flag);\n    }\n}"
    },
    {
      "filename": "dodo-margin-trading-contracts/contracts/marginTrading/MarginTradingFactory.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.15;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {IMarginTrading} from \"./interfaces/IMarginTrading.sol\";\nimport {IMarginTradingFactory} from \"./interfaces/IMarginTradingFactory.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IDODOApprove} from \"./interfaces/IDODOApprove.sol\";\nimport {MarginTrading} from \"./MarginTrading.sol\";\n\ncontract MarginTradingFactory is Ownable, IMarginTradingFactory {\n    event CleanToken(address _tokenAddress, address _to, uint256 _amount);\n\n    event CleanETH(address _to, uint256 _amount);\n\n    address public immutable MARGIN_TRADING_TEMPLATE;\n    address internal LendingPool;\n    IWETH internal WETH;\n    IDODOApprove internal DODOApprove;\n    // user => approveAddress = > bool\n    mapping(address => mapping(address => bool)) public ALLOWED_FLASH_LOAN;\n\n    mapping(address => address[]) public crossMarginTrading;\n\n    mapping(address => address[]) public isolatedMarginTrading;\n\n    //user approve close address\n    constructor(address _lendingPool, address _weth, address _DODOApprove, address _template) {\n        LendingPool = _lendingPool;\n        WETH = IWETH(_weth);\n        MARGIN_TRADING_TEMPLATE = _template;\n        DODOApprove = IDODOApprove(_DODOApprove);\n    }\n\n    receive() external payable {}\n\n    /// @notice Get the marginTrading contract address created by the user.\n    /// @param _num MarginTrading contract Num\n    /// @param _flag 1 -cross , 2 - isolated\n    /// @param _user User address\n    /// @return _ad User marginTrading contract\n    function getCreateMarginTradingAddress(\n        uint256 _num,\n        uint8 _flag,\n        address _user\n    ) external view returns (address _ad) {\n        _ad =\n            Clones.predictDeterministicAddress(MARGIN_TRADING_TEMPLATE, keccak256(abi.encodePacked(_user, _num, _flag)));\n    }\n\n    /// @notice To get the number of marginTrading contracts created by a user.\n    /// @param _user User address\n    /// @return _crossNum User cross marginTrading contract num\n    /// @return _isolateNum User isolate marginTrading contract num\n    function getUserMarginTradingNum(address _user) external view returns (uint256 _crossNum, uint256 _isolateNum) {\n        _crossNum = crossMarginTrading[_user].length;\n        _isolateNum = isolatedMarginTrading[_user].length;\n    }\n\n    /// @notice Get whether the proxyAddress is allowed to call the marginTrading contract.\n    /// @param _marginTradingAddress Margin trading address\n    /// @param _proxy Proxy user address\n    /// @return True is Allowed\n    function isAllowedProxy(address _marginTradingAddress, address _proxy) external view returns (bool) {\n        return ALLOWED_FLASH_LOAN[_marginTradingAddress][_proxy];\n    }\n\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            results[i] = result;\n        }\n    }\n\n    // ============ Functions ============\n\n    /// @notice Add the proxy address that is allowed to execute flashloan operations.\n    /// @param _marginTradingAddress Margin trading address\n    /// @param _proxy Proxy address\n    function addFlashLoanProxy(address _marginTradingAddress, address _proxy) external {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"caller is not the user\");\n        ALLOWED_FLASH_LOAN[_marginTradingAddress][_proxy] = true;\n    }\n\n    /// @notice Delete the proxy address that is allowed to execute flash loan operation.\n    /// @param _marginTradingAddress Margin trading address\n    /// @param _proxy Proxy address\n    function removeFlashLoanProxy(address _marginTradingAddress, address _proxy) external {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"caller is not the user\");\n        ALLOWED_FLASH_LOAN[_marginTradingAddress][_proxy] = false;\n    }\n\n    /// @notice Create a marginTrading contract for the user, deposit funds, and open a position.\n    /// @dev 1.Create a marginTrading contract for the user.\n    /// @dev 2.Make a deposit.\n    /// @dev 3.Execute the executeFlashLoans method of the marginTrading contract to open a position.\n    /// @param _flag 1 -cross , 2 - isolated\n    /// @param depositParams Deposit execution parameters.\n    /// @param executeParams The parameters for executing the executeFlashLoans function in the marginTrading contract.\n    /// @return marginTrading Create marginTrading address\n    function createMarginTrading(\n        uint8 _flag,\n        bytes calldata depositParams,\n        bytes calldata executeParams\n    ) external payable returns (address marginTrading) {\n        if (_flag == 1) {\n            marginTrading = Clones.cloneDeterministic(\n                MARGIN_TRADING_TEMPLATE,\n                keccak256(abi.encodePacked(msg.sender, crossMarginTrading[msg.sender].length, _flag))\n            );\n            crossMarginTrading[msg.sender].push(marginTrading);\n            emit MarginTradingCreated(msg.sender, marginTrading, crossMarginTrading[msg.sender].length, _flag);\n        }\n        if (_flag == 2) {\n            marginTrading = Clones.cloneDeterministic(\n                MARGIN_TRADING_TEMPLATE,\n                keccak256(abi.encodePacked(msg.sender, isolatedMarginTrading[msg.sender].length, _flag))\n            );\n            isolatedMarginTrading[msg.sender].push(marginTrading);\n            emit MarginTradingCreated(msg.sender, marginTrading, isolatedMarginTrading[msg.sender].length, _flag);\n        }\n        //调用marginTrading地址的合约中的\"initialize\"方法,LendingPool,WETH,user\n        IMarginTrading(marginTrading).initialize(LendingPool, address(WETH), msg.sender);\n        if (depositParams.length > 0) {\n            (\n                uint8 _depositFlag, //1- erc20 2-eth\n                address _tokenAddres,\n                uint256 _depositAmount\n            ) = abi.decode(depositParams, (uint8, address, uint256));\n            if (_depositFlag == 1) {\n                _depositMarginTradingERC20(marginTrading, _tokenAddres, _depositAmount, false, uint8(1));\n            }\n            if (_depositFlag == 2) {\n                depositMarginTradingETH(marginTrading, false, uint8(1));\n            }\n        }\n        if (executeParams.length > 0) {\n            (\n                address[] memory _assets,\n                uint256[] memory _amounts,\n                uint256[] memory _modes,\n                address _mainToken,\n                bytes memory _params\n            ) = abi.decode(executeParams, (address[], uint256[], uint256[], address, bytes));\n            _executeMarginTradingFlashLoans(marginTrading, _assets, _amounts, _modes, _mainToken, _params);\n        }\n    }\n\n    /// @notice Execution marginTrading executeFlashLoans methods for opening and closing.\n    /// @dev Execute a flash loan and pass the parameters to the executeOperation method.\n    /// @param assets Borrowing assets\n    /// @param amounts Borrowing assets amounts\n    /// @param modes Borrowing assets premiums\n    /// @param mainToken initiator address\n    /// @param params The parameters for the execution logic.\n    function executeMarginTradingFlashLoans(\n        address _marginTradingAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address mainToken,\n        bytes calldata params\n    ) external {\n        _executeMarginTradingFlashLoans(_marginTradingAddress, assets, amounts, modes, mainToken, params);\n    }\n\n    /// @notice User deposits ERC20 token into marginTrading contract.\n    /// @dev Use DODOApprove to allow users to deposit ERC20 tokens into the marginTrading contract.\n    /// @param _marginTradingAddress User marginTrading contract address\n    /// @param _marginAddress Margin token address\n    /// @param _marginAmount Margin token amount\n    /// @param _margin Whether to be used as collateral\n    /// @param _flag Operation flag\n    function depositMarginTradingERC20(\n        address _marginTradingAddress,\n        address _marginAddress,\n        uint256 _marginAmount,\n        bool _margin,\n        uint8 _flag\n    ) external {\n        _depositMarginTradingERC20(_marginTradingAddress, _marginAddress, _marginAmount, _margin, _flag);\n    }\n\n    /// @notice User deposits ETH into marginTrading contract.\n    /// @dev Convert ETH to ERC20 token using the WETH contract, and then deposit it into the marginTrading contract.\n    /// @param _marginTradingAddress User marginTrading contract address\n    /// @param _margin Whether to be used as collateral\n    /// @param _flag Operation flag\n    function depositMarginTradingETH(address _marginTradingAddress, bool _margin, uint8 _flag) public payable {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"factory:caller is not the user\");\n        WETH.deposit{value: msg.value}();\n        WETH.transfer(_marginTradingAddress, msg.value);\n        if (_margin) {\n            IMarginTrading(_marginTradingAddress).lendingPoolDeposit(address(WETH), msg.value, _flag);\n        }\n        emit DepositMarginTradingETH(_marginTradingAddress, msg.value, _margin, _flag);\n    }\n\n    /// @notice Owner clean contract ERC20 token\n    /// @param _tokenAddress send ERC20 token address\n    /// @param _to To address\n    /// @param _amt send ERC20 token amount\n    function cleanToken(address _tokenAddress, address _to, uint256 _amt) external onlyOwner {\n        IERC20(_tokenAddress).transfer(_to, _amt);\n        emit CleanToken(_tokenAddress, _to, _amt);\n    }\n\n    /// @notice Owner clean contract ETH.\n    /// @param _to To address\n    /// @param _amt send ETH amount\n    function cleanETH(address _to, uint256 _amt) external onlyOwner {\n        (bool success,) = _to.call{value: _amt}(new bytes(0));\n        require(success, \"ETH_TRANSFER_FAILED\");\n        emit CleanETH(_to, _amt);\n    }\n\n    // =========== internal ==========\n\n    /// @notice Execution marginTrading contract methods for opening and closing.\n    /// @dev Execute a flash loan and pass the parameters to the executeOperation method.\n    /// @param _marginTradingAddress MarginTrading contract address\n    /// @param assets Borrowing assets\n    /// @param amounts Borrowing assets amounts\n    /// @param modes Borrowing assets premiums\n    /// @param mainToken initiator address\n    /// @param params The parameters for the execution logic.\n    function _executeMarginTradingFlashLoans(\n        address _marginTradingAddress,\n        address[] memory assets,\n        uint256[] memory amounts,\n        uint256[] memory modes,\n        address mainToken,\n        bytes memory params\n    ) internal {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"factory: caller is not the user\");\n        IMarginTrading(_marginTradingAddress).executeFlashLoans(assets, amounts, modes, mainToken, params);\n    }\n\n    /// @notice Deposits ERC20 token into marginTrading contract.\n    /// @param _marginTradingAddress MarginTrading contract address\n    /// @param _marginAddress margin token address\n    /// @param _marginAmount margin token Amount\n    /// @param _margin Whether to be used as collateral\n    /// @param _flag Operation flag\n    function _depositMarginTradingERC20(\n        address _marginTradingAddress,\n        address _marginAddress,\n        uint256 _marginAmount,\n        bool _margin,\n        uint8 _flag\n    ) internal {\n        require(IMarginTrading(_marginTradingAddress).user() == msg.sender, \"factory:caller is not the user\");\n        DODOApprove.claimTokens(_marginAddress, msg.sender, _marginTradingAddress, _marginAmount);\n        if (_margin) {\n            IMarginTrading(_marginTradingAddress).lendingPoolDeposit(_marginAddress, _marginAmount, _flag);\n        }\n        emit DepositMarginTradingERC20(_marginTradingAddress, _marginAddress, _marginAmount, _margin, _flag);\n    }\n}"
    },
    {
      "filename": "dodo-margin-trading-contracts/contracts/marginTrading/MarginTrading.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.15;\n\nimport {ILendingPool, IFlashLoanReceiver} from \"../aaveLib/Interfaces.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IMarginTrading} from \"./interfaces/IMarginTrading.sol\";\nimport {IMarginTradingFactory} from \"./interfaces/IMarginTradingFactory.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {Types} from \"./Types.sol\";\n/**\n * @author  DODO\n * @title   MarginTrading\n * @dev     To save contract size, most of the function implements are moved to LiquidationLibrary.\n * @notice  This contract serves as a user-managed asset contract, responsible for interacting with Aave, including functions such as opening, closing, repaying, and withdrawing.\n */\n\ncontract MarginTrading is OwnableUpgradeable, IMarginTrading, IFlashLoanReceiver {\n    using SafeERC20 for IERC20;\n\n    ILendingPool internal lendingPool;\n\n    IWETH internal WETH;\n\n    address private _USER;\n\n    modifier onlyUser() {\n        require(_USER == msg.sender, \"caller is not the user\");\n        _;\n    }\n\n    modifier onlyLendingPool() {\n        require(address(lendingPool) == msg.sender, \"caller is not the lendingPool\");\n        _;\n    }\n\n    modifier onlyDeposit() {\n        require(_USER == msg.sender || owner() == msg.sender, \"caller is unauthorized\");\n        _;\n    }\n\n    modifier onlyFlashLoan() {\n        require(\n            _USER == msg.sender || owner() == msg.sender\n                || IMarginTradingFactory(owner()).isAllowedProxy(address(this), msg.sender),\n            \"caller is unauthorized\"\n        );\n        _;\n    }\n\n    /// @notice Obtaining the address of the user who owns this contract.\n    /// @return _userAddress User address\n    function user() external view returns (address _userAddress) {\n        return _USER;\n    }\n\n    /// @notice Get owner address\n    /// @return _ad Owner address\n    function getOwner() external view returns (address _ad) {\n        _ad = owner();\n    }\n\n    /// @notice Query the addresses of relevant external contracts.\n    /// @return _lendingPoolAddress lendingPool address\n    /// @return _WETHAddress weth address\n    function getContractAddress() external view returns (address _lendingPoolAddress, address _WETHAddress) {\n        return (address(lendingPool), address(WETH));\n    }\n\n    function initialize(address _lendingPool, address _weth, address _user) external initializer {\n        __Ownable_init();\n        lendingPool = ILendingPool(_lendingPool);\n        WETH = IWETH(_weth);\n        _USER = _user;\n    }\n\n    receive() external payable {}\n\n    // ============ Functions ============\n\n    /// @notice Execution methods for opening and closing.\n    /// @dev Execute a flash loan and pass the parameters to the executeOperation method.\n    /// @param assets Borrowing assets\n    /// @param amounts Borrowing assets amounts\n    /// @param modes Borrowing assets premiums\n    /// @param mainToken initiator address\n    /// @param params The parameters for the execution logic.\n    function executeFlashLoans(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address mainToken,\n        bytes calldata params\n    ) external onlyFlashLoan {\n        address receiverAddress = address(this);\n\n        // the various assets to be flashed\n\n        // the amount to be flashed for each asset\n\n        // 0 = no debt, 1 = stable, 2 = variable\n\n        address onBehalfOf = address(this);\n        // bytes memory params = \"\";\n        lendingPool.flashLoan(receiverAddress, assets, amounts, modes, onBehalfOf, params, Types.REFERRAL_CODE);\n        emit FlashLoans(assets, amounts, modes, mainToken);\n    }\n\n    /// @notice LendingPool flashloan callback function, returns true upon successful execution.\n    /// @dev It internally implements three operations: partial closure, full closure, and opening.\n    /// @dev Opening: Borrowing token through flash loan, swapping it into deposit token, and depositing it into Aave to complete the opening process.\n    /// @dev Partial closure: Borrowing Aave deposit token through flash loan, swapping it into borrowed token, repaying according to the balance, then extracting token from Aave deposit to repay the flash loan.\n    /// @dev Full closure: Borrowing Aave deposit token through flash loan, swapping it into borrowed token, repaying all debts, returning the remaining debt tokens to the user, then extracting token from Aave deposit to repay the flash loan.\n    /// @param _assets Borrowing assets\n    /// @param _amounts Borrowing assets amounts\n    /// @param _premiums Borrowing assets premiums\n    /// @param _initiator initiator address\n    /// @param _params The parameters for the execution logic.\n    /// @return Returns true upon successful execution.\n    function executeOperation(\n        address[] calldata _assets,\n        uint256[] calldata _amounts,\n        uint256[] calldata _premiums,\n        address _initiator,\n        bytes calldata _params\n    ) external override onlyLendingPool returns (bool) {\n        //decode params exe swap and deposit\n        {\n            (\n                uint8 _flag,\n                address _swapAddress,\n                address _swapApproveTarget,\n                address[] memory _swapApproveToken,\n                bytes memory _swapParams,\n                address[] memory _tradeAssets,\n                address[] memory _withdrawAssets,\n                uint256[] memory _withdrawAmounts,\n                uint256[] memory _rateMode,\n                address[] memory _debtTokens\n            ) = abi.decode(\n                _params,\n                (uint8, address, address, address[], bytes, address[], address[], uint256[], uint256[], address[])\n            );\n            if (_flag == 0 || _flag == 2) {\n                //close\n                _closetrade(\n                    _flag,\n                    _swapAddress,\n                    _swapApproveTarget,\n                    _swapApproveToken,\n                    _swapParams,\n                    _tradeAssets,\n                    _withdrawAssets,\n                    _withdrawAmounts,\n                    _rateMode,\n                    _debtTokens\n                );\n            }\n            if (_flag == 1) {\n                //open\n                _opentrade(_swapAddress, _swapApproveTarget, _swapApproveToken, _swapParams, _tradeAssets);\n            }\n        }\n        return true;\n    }\n\n    /// @notice Withdraws the token collateral from the lending pool\n    /// @param _asset Asset token address\n    /// @param _amount Asset token Amount\n    /// @param _flag Operation flag\n    function lendingPoolWithdraw(address _asset, uint256 _amount, uint8 _flag) external onlyUser {\n        _lendingPoolWithdraw(_asset, _amount, _flag);\n    }\n\n    /// @notice Deposits the token liquidity onto the lending pool as collateral\n    /// @param _asset Asset token address\n    /// @param _amount Asset token Amount\n    /// @param _flag Operation flag\n    function lendingPoolDeposi"
    }
  ]
}