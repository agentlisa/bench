{
  "Title": "Wrong and Incomplete Docstrings",
  "Content": "Throughout the [codebase](https://github.com/NethermindEth/forta-staking-vault/tree/ce87cffbf813e27cc83157933760b51fa44a1885/), there are several parts that have wrong or incomplete docstrings:\n\n\n* The documentation for the [`undelegate`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/InactiveSharesDistributor.sol#L73) method within the `InactiveSharesDistributor` contract inaccurately states that vault shares are transferred to the vault. In reality, these shares are burned and it is the `FORT` tokens that are sent to the vault instead. In addition, the documentation for the [`claim`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/InactiveSharesDistributor.sol#L94) function misleadingly indicates its use for claiming a portion of the inactive shares owned by individuals, whereas it actually facilitates the claiming of `FORT` tokens.\n* The [`initiateUndelegate`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L201-L225), [`getRedemptionReceiver`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L400-L402), and [`claimRedeem`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L383-L386) functions in [`FortaStakingVault.sol`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol) do not have their return values documented.\n* The [`initiateUndelegate`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/InactiveSharesDistributor.sol#L64-L67) and [`claim`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/InactiveSharesDistributor.sol#L94-L103) functions in [`InactiveSharesDistributor.sol`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/InactiveSharesDistributor.sol) do not have their return values documented.\n* The [`claim`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/RedemptionReceiver.sol#L76-L117) function in [`RedemptionReceiver.sol`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/RedemptionReceiver.sol) does not have its parameters nor return values documented.\n* The [`redeem`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L294) and [`deposit`](https://github.com/NethermindEth/forta-staking-vault/blob/ce87cffbf813e27cc83157933760b51fa44a1885/src/FortaStakingVault.sol#L276) functions use `inheritdoc` tags to reference `ERC4626Upgradeable` docstrings but fail to delineate the modifications from the original implementation.\n\n\nConsider thoroughly documenting all functions/events (and their parameters or return values) that are part of any contract's public API. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #26](https://github.com/NethermindEth/forta-staking-vault/pull/26).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/InactiveSharesDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport { ERC20Upgradeable, IERC20 } from \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\n\n/**\n * @title Inactives shares distributor\n * @author Nethermind\n * @notice Simulates the behavior of a vault so the invalidShares in each of the pools can be distributed given that\n * they are not transferrable\n */\ncontract InactiveSharesDistributor is OwnableUpgradeable, ERC20Upgradeable, ERC1155HolderUpgradeable {\n    using SafeERC20 for IERC20;\n\n    IFortaStaking private _staking;\n    bool private _claimable;\n    uint64 private _deadline;\n    IERC20 private _token;\n    uint256 private _subject;\n    uint256 private _shares;\n    uint256 private _assetsReceived;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Initializes the contract\n     * @param stakingContract FortaStaking contract address\n     * @param token Forta token address\n     * @param subject Subject from where inactive shares are going to be distributed\n     * @param shares Shares to distribute\n     */\n    function initialize(\n        IFortaStaking stakingContract,\n        IERC20 token,\n        uint256 subject,\n        uint256 shares\n    )\n        public\n        initializer\n    {\n        __Ownable_init(msg.sender);\n        __ERC20_init(\"Inactive Shares\", \"IS\");\n\n        _staking = stakingContract;\n        _shares = shares;\n        _subject = subject;\n        _token = token;\n\n        _mint(msg.sender, shares);\n    }\n\n    /**\n     * @notice Initiates the undelegation process\n     * @dev Shares become inactive at this point\n     */\n    function initiateUndelegate() public onlyOwner returns (uint64) {\n        _deadline = _staking.initiateWithdrawal(DELEGATOR_SCANNER_POOL_SUBJECT, _subject, _shares);\n        return _deadline;\n    }\n\n    /**\n     * @notice Finish the undelegation process\n     * @dev Shares are redeemed and Vault shares are sent to the vault\n     */\n    function undelegate() public onlyOwner {\n        _staking.withdraw(DELEGATOR_SCANNER_POOL_SUBJECT, _subject);\n        uint256 assetsReceived = _token.balanceOf(address(this));\n        _assetsReceived = assetsReceived;\n        _claimable = true;\n\n        uint256 vaultShares = balanceOf(owner());\n        uint256 nonVaultShares = _shares - vaultShares;\n        uint256 vaultAssets = assetsReceived - Math.mulDiv(nonVaultShares, _assetsReceived, _shares);\n        if (vaultAssets > 0) {\n            _token.safeTransfer(owner(), vaultAssets);\n        }\n        if (vaultShares > 0) {\n            _burn(owner(), vaultShares);\n        }\n    }\n\n    /**\n     * @notice Claim the portion of the inactive shares owned by the caller\n     * @dev Shares are burned in the process\n     */\n    function claim() public returns (bool) {\n        if (!_claimable) return false;\n\n        uint256 assetsToDeliver = Math.mulDiv(balanceOf(msg.sender), _assetsReceived, _shares);\n        if (assetsToDeliver > 0) {\n            _token.safeTransfer(msg.sender, assetsToDeliver);\n        }\n        _burn(msg.sender, balanceOf(msg.sender));\n        return true;\n    }\n}"
    },
    {
      "filename": "src/FortaStakingVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ERC4626Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\nimport { IRewardsDistributor } from \"./interfaces/IRewardsDistributor.sol\";\nimport { FortaStakingUtils } from \"./utils/FortaStakingUtils.sol\";\nimport { OperatorFeeUtils, FEE_BASIS_POINTS_DENOMINATOR } from \"./utils/OperatorFeeUtils.sol\";\nimport { RedemptionReceiver } from \"./RedemptionReceiver.sol\";\nimport { InactiveSharesDistributor } from \"./InactiveSharesDistributor.sol\";\n\n/**\n * @title FORT Vault with a stategy to generate rewards by staking in the forta network\n * @author Nethermind\n * @notice Strategy is manually operated by the OPERATOR_ROLE\n */\ncontract FortaStakingVault is AccessControlUpgradeable, ERC4626Upgradeable, ERC1155HolderUpgradeable {\n    using Clones for address;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    mapping(uint256 => uint256) private _assetsPerSubject;\n\n    mapping(uint256 => uint256) private _subjectIndex;\n    uint256[] public subjects;\n\n    mapping(uint256 => uint256) private _subjectInactiveSharesDistributorIndex;\n    mapping(uint256 => uint256) private _subjectDeadline;\n    mapping(address => uint256) private _distributorSubject;\n    address[] private _inactiveSharesDistributors;\n\n    uint256 public feeInBasisPoints; // e.g. 300 = 3%\n    address public feeTreasury;\n\n    IERC20 private _token;\n    IFortaStaking private _staking;\n    IRewardsDistributor private _rewardsDistributor;\n    address private _receiverImplementation;\n    address private _distributorImplementation;\n    uint256 private _totalAssets;\n\n    error NotOperator();\n    error InvalidTreasury();\n    error InvalidFee();\n    error PendingUndelegation();\n    error InvalidUndelegation();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the Vault\n     * @param asset_ Asset to stake (FORT Token address)\n     * @param fortaStaking FortaStaking contract address\n     * @param redemptionReceiverImplementation RedemptionReceiver implementation contract\n     * @param inactiveSharesDistributorImplementation InactiveSharesDistributor implementation contract\n     * @param operatorFeeInBasisPoints Fee applied on redemptions\n     * @param operatorFeeTreasury Treasury address to receive the fees\n     * @param rewardsDistributor RewardsDistributor contract address\n     */\n    function initialize(\n        address asset_,\n        address fortaStaking,\n        address redemptionReceiverImplementation,\n        address inactiveSharesDistributorImplementation,\n        uint256 operatorFeeInBasisPoints,\n        address operatorFeeTreasury,\n        address rewardsDistributor\n    )\n        public\n        initializer\n    {\n        __ERC20_init_unchained(\"FORT Staking Vault\", \"vFORT\");\n        __ERC4626_init_unchained(IERC20(asset_));\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(OPERATOR_ROLE, msg.sender);\n        _staking = IFortaStaking(fortaStaking);\n        _token = IERC20(asset_);\n        _receiverImplementation = redemptionReceiverImplementation;\n        _distributorImplementation = inactiveSharesDistributorImplementation;\n        _rewardsDistributor = IRewardsDistributor(rewardsDistributor);\n        feeInBasisPoints = operatorFeeInBasisPoints;\n        feeTreasury = operatorFeeTreasury;\n    }\n\n    /**\n     * @inheritdoc ERC1155HolderUpgradeable\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155HolderUpgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @notice Updates the known assets in the different subjects\n     * @dev Needed to ensure the _totalAssets are correct and shares\n     * distributed correctly\n     */\n    function _updatePoolsAssets() private {\n        for (uint256 i = 0; i < subjects.length; ++i) {\n            _updatePoolAssets(subjects[i]);\n        }\n    }\n\n    /**\n     * @notice Updates the amount of assets delegated to a subject\n     * @param subject Subject to update the amount of assets\n     */\n    function _updatePoolAssets(uint256 subject) private {\n        uint256 activeId = FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject);\n        uint256 inactiveId = FortaStakingUtils.activeToInactive(activeId);\n\n        uint256 assets = _staking.activeSharesToStake(activeId, _staking.balanceOf(address(this), activeId));\n\n        if (_subjectDeadline[subject] != 0) {\n            assets += _staking.inactiveSharesToStake(\n                inactiveId,\n                IERC20(_inactiveSharesDistributors[_subjectInactiveSharesDistributorIndex[subject]]).balanceOf(\n                    address(this)\n                )\n            );\n        }\n\n        if (_assetsPerSubject[subject] != assets) {\n            _totalAssets = _totalAssets - _assetsPerSubject[subject] + assets;\n            _assetsPerSubject[subject] = assets;\n        }\n    }\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     * @dev Overrided because assets are moved out of the vault\n     */\n    function totalAssets() public view override returns (uint256) {\n        return _totalAssets;\n    }\n\n    /**\n     * @notice Claim rewards associated to a subject\n     * @param subjectId Subject to claim rewards from\n     * @param epochNumber Epoch where the rewards were generated\n     * @dev meant to be called by a relayer (i.e OZ Defender)\n     */\n    function claimRewards(uint256 subjectId, uint256 epochNumber) public {\n        uint256[] memory epochs = new uint256[](1);\n        epochs[0] = epochNumber;\n        _rewardsDistributor.claimRewards(DELEGATOR_SCANNER_POOL_SUBJECT, subjectId, epochs);\n    }\n\n    //// Operator functions ////\n\n    /**\n     * @notice Checks that the caller is the OPERATOR_ROLE\n     */\n    function _validateIsOperator() private view {\n        if (!hasRole(OPERATOR_ROLE, msg.sender)) {\n            revert NotOperator();\n        }\n    }\n\n    /**\n     * @notice Delegate FORT in the vault to a subject\n     * @param subject Subject to delegate assets to\n     * @param assets Amount of assets to delegate\n     */\n    function delegate(uint256 subject, uint256 assets) public {\n        _validateIsOperator();\n\n        if (_assetsPerSubject[subject] == 0) {\n            _subjectIndex[subject] = subjects.length;\n            subjects.push(subject);\n        }\n        _token.approve(address(_staking), assets);\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _staking.deposit(DELEGATOR_SCANNER_POOL_SUBJECT, subject, assets);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n        // get the exact amount delivered to the pool\n        _assetsPerSubject[subject] += (balanceBefore - balanceAfter);\n    }\n\n    /**\n     * @notice Initiate an undelegation from a subject\n     * @param subject Subject to undelegate assets from\n     * @param shares Amount of shares to undelegate\n     * @dev generated a new contract to simulate a pool given\n     * that inactiveShares are not transferrable\n     */\n    function initiateUndelegate(uint256 subject, uint256 shares) public returns (uint256, address) {\n        _validateIsOperator();\n\n        if (_subjectDeadline[subject] != 0) {\n            // can generate extra delays for users\n            revert PendingUndelegation();\n        }\n\n        InactiveSharesDistributor distributor = InactiveSharesDistributor(_distributorImplementation.clone());\n        _staking.safeTransferFrom(\n            address(this),\n            address(distributor),\n            FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject),\n            shares,\n            \"\"\n        );\n        distributor.initialize(_staking, _token, subject, shares);\n\n        _subjectInactiveSharesDistributorIndex[subject] = _inactiveSharesDistributors.length;\n        _inactiveSharesDistributors.push(address(distributor));\n        _distributorSubject[address(distributor)] = subject;\n        uint256 deadline = distributor.initiateUndelegate();\n        _subjectDeadline[subject] = deadline;\n        return (deadline, address(distributor));\n    }\n\n    /**\n     * @notice Finish an undelegation from a subject\n     * @param subject Subject being undelegate\n     * @dev vault receives the portion of undelegated assets\n     * not redeemed by users\n     */\n    function undelegate(uint256 subject) public {\n        _updatePoolAssets(subject);\n\n        if (\n            (_subjectDeadline[subject] == 0) || (_subjectDeadline[subject] > block.timestamp)\n                || _staking.isFrozen(DELEGATOR_SCANNER_POOL_SUBJECT, subject)\n        ) {\n            revert InvalidUndelegation();\n        }\n\n        uint256 distributorIndex = _subjectInactiveSharesDistributorIndex[subject];\n        InactiveSharesDistributor distributor = InactiveSharesDistributor(_inactiveSharesDistributors[distributorIndex]);\n\n        uint256 beforeWithdrawBalance = _token.balanceOf(address(this));\n        distributor.undelegate();\n        uint256 afterWithdrawBalance = _token.balanceOf(address(this));\n\n        // remove _inactiveSharesDistributors\n        address lastDistributor = _inactiveSharesDistributors[_inactiveSharesDistributors.length - 1];\n        _inactiveSharesDistributors[distributorIndex] = lastDistributor;\n        _subjectInactiveSharesDistributorIndex[_distributorSubject[lastDistributor]] = distributorIndex;\n        _inactiveSharesDistributors.pop();\n        delete _subjectDeadline[subject];\n        delete _distributorSubject[address(distributor)];\n        delete _subjectInactiveSharesDistributorIndex[subject];\n\n        _assetsPerSubject[subject] -= (afterWithdrawBalance - beforeWithdrawBalance);\n\n        //slither-disable-next-line incorrect-equality\n        if (_assetsPerSubject[subject] == 0) {\n            uint256 index = _subjectIndex[subject];\n            subjects[index] = subjects[subjects.length - 1];\n            _subjectIndex[subjects[index]] = index;\n            subjects.pop();\n            delete _subjectIndex[subject];\n        }\n    }\n\n    //// User operations ////\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        _updatePoolsAssets();\n\n        uint256 beforeDepositBalance = _token.balanceOf(address(this));\n        uint256 shares = super.deposit(assets, receiver);\n        uint256 afterDepositBalance = _token.balanceOf(address(this));\n\n        _totalAssets += afterDepositBalance - beforeDepositBalance;\n\n        return shares;\n    }\n\n    /**\n     * @inheritdoc ERC4626Upgradeable\n     * @dev Assets in the pool are redeemed inmediatly\n     * @dev New contract is crated per user so the redemptions\n     * don't share the same delay in the FortaStaking contract\n     */\n    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256) {\n        _updatePoolsAssets();\n\n        if (msg.sender != owner) {\n            // caller needs to be allowed\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        // user redemption contract\n        RedemptionReceiver redemptionReceiver = RedemptionReceiver(createAndGetRedemptionReceiver(owner));\n\n        {\n            // Active shares redemption\n            uint256 newUndelegations;\n            uint256[] memory tempSharesToUndelegate = new uint256[](subjects.length);\n            uint256[] memory tempSubjectsToUndelegateFrom = new uint256[](subjects.length);\n\n            for (uint256 i = 0; i < subjects.length; ++i) {\n                uint256 subject = subjects[i];\n                uint256 subjectShares = _staking.sharesOf(DELEGATOR_SCANNER_POOL_SUBJECT, subject, address(this));\n                uint256 sharesToUndelegateInSubject = Math.mulDiv(shares, subjectShares, totalSupply());\n                if (sharesToUndelegateInSubject != 0) {\n                    _staking.safeTransferFrom(\n                        address(this),\n                        address(redemptionReceiver),\n                        FortaStakingUtils.subjectToActive(DELEGATOR_SCANNER_POOL_SUBJECT, subject),\n                        sharesToUndelegateInSubject,\n                        \"\"\n                    );\n                    _updatePoolAssets(subject);\n                    tempSharesToUndelegate[newUndelegations] = sharesToUndelegateInSubject;\n                    tempSubjectsToUndelegateFrom[newUndelegations] = subject;\n                    ++newUndelegations;\n                }\n            }\n            uint256[] memory sharesToUndelegate = new uint256[](newUndelegations);\n            uint256[] memory subjectsToUndelegateFrom = new uint256[](newUndelegations);\n            for (uint256 i = 0; i < newUndelegations; ++i) {\n                sharesToUndelegate[i] = tempSharesToUndelegate[i];\n                subjectsToUndelegateFrom[i] = tempSubjectsToUndelegateFrom[i];\n            }\n            redemptionReceiver.addUndelegations(subjectsToUndelegateFrom, sharesToUndelegate);\n        }\n\n        {\n            // Inactive shares redemption\n            uint256 newUndelegations;\n            address[] memory tempDistributors = new address[](_inactiveSharesDistributors.length);\n\n            for (uint256 i = 0; i < _inactiveSharesDistributors.length; ++i) {\n                InactiveSharesDistributor distributor = InactiveSharesDistributor(_inactiveSharesDistributors[i]);\n                uint256 vaultShares = distributor.balanceOf(address(this));\n                uint256 sharesToUndelegateInDistributor = Math.mulDiv(shares, vaultShares, totalSupply());\n                if (sharesToUndelegateInDistributor != 0) {\n                    IERC20(distributor).safeTransfer(address(redemptionReceiver), sharesToUndelegateInDistributor);\n                    _updatePoolAssets(_distributorSubject[address(distributor)]);\n                    tempDistributors[newUndelegations] = address(distributor);\n                    ++newUndelegations;\n                }\n            }\n            address[] memory distributorsToUndelegateFrom = new address[](newUndelegations);\n            for (uint256 i = 0; i < newUndelegations; ++i) {\n                distributorsToUndelegateFrom[i] = tempDistributors[i];\n            }\n            redemptionReceiver.addDistributors(distributorsToUndelegateFrom);\n        }\n\n        // send portion of assets in the pool\n        uint256 vaultBalance = _token.balanceOf(address(this));\n        uint256 vaultBalanceToRedeem = Math.mulDiv(shares, vaultBalance, totalSupply());\n\n        uint256 userAmountToRedeem =\n            OperatorFeeUtils.deductAndTransferFee(vaultBalanceToRedeem, feeInBasisPoints, feeTreasury, _token);\n\n        _token.safeTransfer(receiver, userAmountToRedeem);\n        _totalAssets -= vaultBalanceToRedeem;\n        _burn(owner, shares);\n\n        return vaultBalanceToRedeem;\n    }\n\n    /**\n     * @notice Claim user redeemed assets\n     * @param receiver Address to receive the redeemed assets\n     */\n    function claimRedeem(address receiver) public returns (uint256) {\n        RedemptionReceiver redemptionReceiver = RedemptionReceiver(getRedemptionReceiver(msg.sender));\n        return redemptionReceiver.claim(receiver, feeInBasisPoints, feeTreasury);\n    }\n\n    /**\n     * @notice Generates the salt to be used by create2 given an user\n     * @param user Address of the user the salt is associated to\n     */\n    function getSalt(address user) private pure returns (bytes32) {\n        return keccak256(abi.encode(user));\n    }\n\n    /**\n     * @notice Return the redemption receiver contract of a user\n     * @param user Address of the user the receiver is associated to\n     */\n    function getRedemptionReceiver(address user) public view returns (address) {\n        return _receiverImplementation.predictDeterministicAddress(getSalt(user), address(this));\n    }\n\n    /**\n     * @notice Deploys a new Redemption Receiver for a user\n     * @param user Address of the user the receiver is associated to\n     * @dev If the address if already deployed it is simply returned\n     */\n    function createAndGetRedemptionReceiver(address user) private returns (address) {\n        address receiver = getRedemptionReceiver(user);\n        if (receiver.code.length == 0) {\n            // create and initialize a new contract\n            _receiverImplementation.cloneDeterministic(getSalt(user));\n            RedemptionReceiver(receiver).initialize(_staking, _token);\n        }\n        return receiver;\n    }\n\n    /**\n     * @notice Updates the treasury address\n     * @param treasury New treasury address\n     */\n    function updateFeeTreasury(address treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (treasury == address(0)) {\n            revert InvalidTreasury();\n        }\n        feeTreasury = treasury;\n    }\n\n    /**\n     * @notice Updates the redemption fee\n     * @param feeBasisPoints New fee\n     */\n    function updateFeeBasisPoints(uint256 feeBasisPoints) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (feeBasisPoints >= FEE_BASIS_POINTS_DENOMINATOR) {\n            revert InvalidFee();\n        }\n        feeInBasisPoints = feeBasisPoints;\n    }\n}"
    },
    {
      "filename": "src/InactiveSharesDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport { ERC20Upgradeable, IERC20 } from \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\n\n/**\n * @title Inactives shares distributor\n * @author Nethermind\n * @notice Simulates the behavior of a vault so the invalidShares in each of the pools can be distributed given that\n * they are not transferrable\n */\ncontract InactiveSharesDistributor is OwnableUpgradeable, ERC20Upgradeable, ERC1155HolderUpgradeable {\n    using SafeERC20 for IERC20;\n\n    IFortaStaking private _staking;\n    bool private _claimable;\n    uint64 private _deadline;\n    IERC20 private _token;\n    uint256 private _subject;\n    uint256 private _shares;\n    uint256 private _assetsReceived;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Initializes the contract\n     * @param stakingContract FortaStaking contract address\n     * @param token Forta token address\n     * @param subject Subject from where inactive shares are going to be distributed\n     * @param shares Shares to distribute\n     */\n    function initialize(\n        IFortaStaking stakingContract,\n        IERC20 token,\n        uint256 subject,\n        uint256 shares\n    )\n        public\n        initializer\n    {\n        __Ownable_init(msg.sender);\n        __ERC20_init(\"Inactive Shares\", \"IS\");\n\n        _staking = stakingContract;\n        _shares = shares;\n        _subject = subject;\n        _token = token;\n\n        _mint(msg.sender, shares);\n    }\n\n    /**\n     * @notice Initiates the undelegation process\n     * @dev Shares become inactive at this point\n     */\n    function initiateUndelegate() public onlyOwner returns (uint64) {\n        _deadline = _staking.initiateWithdrawal(DELEGATOR_SCANNER_POOL_SUBJECT, _subject, _shares);\n        return _deadline;\n    }\n\n    /**\n     * @notice Finish the undelegation process\n     * @dev Shares are redeemed and Vault shares are sent to the vault\n     */\n    function undelegate() public onlyOwner {\n        _staking.withdraw(DELEGATOR_SCANNER_POOL_SUBJECT, _subject);\n        uint256 assetsReceived = _token.balanceOf(address(this));\n        _assetsReceived = assetsReceived;\n        _claimable = true;\n\n        uint256 vaultShares = balanceOf(owner());\n        uint256 nonVaultShares = _shares - vaultShares;\n        uint256 vaultAssets = assetsReceived - Math.mulDiv(nonVaultShares, _assetsReceived, _shares);\n        if (vaultAssets > 0) {\n            _token.safeTransfer(owner(), vaultAssets);\n        }\n        if (vaultShares > 0) {\n            _burn(owner(), vaultShares);\n        }\n    }\n\n    /**\n     * @notice Claim the portion of the inactive shares owned by the caller\n     * @dev Shares are burned in the process\n     */\n    function claim() public returns (bool) {\n        if (!_claimable) return false;\n\n        uint256 assetsToDeliver = Math.mulDiv(balanceOf(msg.sender), _assetsReceived, _shares);\n        if (assetsToDeliver > 0) {\n            _token.safeTransfer(msg.sender, assetsToDeliver);\n        }\n        _burn(msg.sender, balanceOf(msg.sender));\n        return true;\n    }\n}"
    },
    {
      "filename": "src/RedemptionReceiver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OperatorFeeUtils } from \"./utils/OperatorFeeUtils.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\nimport { InactiveSharesDistributor } from \"./InactiveSharesDistributor.sol\";\n\n/**\n * @title Redemption Receiver\n * @author Nethermind\n * @notice Personal contract for each Vault participant to receive redeemed assets\n * @dev Needed to separate delays associated to redemptions of different users\n */\ncontract RedemptionReceiver is OwnableUpgradeable, ERC1155HolderUpgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256[] private _subjects;\n    address[] private _distributors;\n    mapping(uint256 => uint256) private _subjectsPending;\n    mapping(address => bool) private _distributorsPending;\n    IFortaStaking private _staking;\n    IERC20 private _token;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Initialiazes the contract\n     * @param staking FortaStaking contract address\n     * @param token FORT contract address\n     */\n    function initialize(IFortaStaking staking, IERC20 token) public initializer {\n        __Ownable_init(msg.sender);\n        _staking = staking;\n        _token = token;\n    }\n\n    /**\n     * @notice Register undelegations to initiate\n     * @param newUndelegations List of subjects to undelegate from\n     * @param shares list of shares to undelegate from each subject\n     */\n    function addUndelegations(uint256[] memory newUndelegations, uint256[] memory shares) public onlyOwner {\n        for (uint256 i = 0; i < newUndelegations.length; ++i) {\n            uint256 subject = newUndelegations[i];\n            if (_subjectsPending[subject] == 0) {\n                _subjects.push(subject);\n            }\n            _subjectsPending[subject] = _staking.initiateWithdrawal(DELEGATOR_SCANNER_POOL_SUBJECT, subject, shares[i]);\n        }\n    }\n\n    /**\n     * @notice Register inactive shares to claim\n     * @param newDistributors List of inactive shares distributors contracts to claim from\n     */\n    function addDistributors(address[] memory newDistributors) public onlyOwner {\n        for (uint256 i = 0; i < newDistributors.length; ++i) {\n            address distributor = newDistributors[i];\n            if (!_distributorsPending[distributor]) {\n                _distributors.push(distributor);\n                _distributorsPending[distributor] = true;\n            }\n        }\n    }\n\n    /**\n     * @notice Claim user redemptions\n     */\n    function claim(\n        address receiver,\n        uint256 feeInBasisPoints,\n        address feeTreasury\n    )\n        public\n        onlyOwner\n        returns (uint256)\n    {\n        uint256 stake;\n        for (uint256 i = 0; i < _subjects.length;) {\n            uint256 subject = _subjects[i];\n            if (\n                (_subjectsPending[subject] < block.timestamp)\n                    && !_staking.isFrozen(DELEGATOR_SCANNER_POOL_SUBJECT, subject)\n            ) {\n                stake += _staking.withdraw(DELEGATOR_SCANNER_POOL_SUBJECT, subject);\n                _subjects[i] = _subjects[_subjects.length - 1];\n                delete _subjectsPending[subject];\n                _subjects.pop();\n            } else {\n                ++i;\n            }\n        }\n        for (uint256 i = 0; i < _distributors.length;) {\n            InactiveSharesDistributor distributor = InactiveSharesDistributor(_distributors[i]);\n            uint256 balanceBefore = _token.balanceOf(address(this));\n            bool validClaim = distributor.claim();\n            if (validClaim) {\n                uint256 balanceAfter = _token.balanceOf(address(this));\n                stake += (balanceAfter - balanceBefore);\n                _distributorsPending[address(distributor)] = false;\n                _distributors[i] = _distributors[_distributors.length - 1];\n                _distributors.pop();\n            } else {\n                ++i;\n            }\n        }\n        uint256 userStake = OperatorFeeUtils.deductAndTransferFee(stake, feeInBasisPoints, feeTreasury, _token);\n        _token.safeTransfer(receiver, userStake);\n        return stake;\n    }\n}"
    },
    {
      "filename": "src/FortaStakingVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ERC4626Upgradeable } from \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin-upgradeable/contracts/access/AccessControlUpgradeable.sol\";\nimport { ERC1155HolderUpgradeable } from\n    \"@openzeppelin-upgradeable/contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport { IFortaStaking, DELEGATOR_SCANNER_POOL_SUBJECT } from \"./interfaces/IFortaStaking.sol\";\nimport { IRewardsDistributor } from \"./interfaces/IRewardsDistributor.sol\";\nimport { FortaStakingUtils } from \"./utils/FortaStakingUtils.sol\";\nimport { OperatorFeeUtils, FEE_BASIS_POINTS_DENOMINATOR } from \"./utils/OperatorFeeUtils.sol\";\nimport { RedemptionReceiver } from \"./RedemptionReceiver.sol\";\nimport { InactiveSharesDistributor } from \"./InactiveSharesDistributor.sol\";\n\n/**\n * @title FORT Vault with a stategy to generate rewards by staking in the forta network\n * @author Nethermind\n * @notice Strategy is manually operated by the OPERATOR_ROLE\n */\ncontract FortaStakingVault is AccessControlUpgradeable, ERC4626Upgradeable, ERC1155HolderUpgradeable {\n    using Clones for address;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    mapping(uint256 => uint256) private _assetsPerSubject;\n\n    mapping(uint256 => uint256) private _subjectIndex;\n    uint256[] public subjects;\n\n    mapping(uint256 => uint256) private _subjectInactiveSharesDistributorIndex;\n    mapping(uint256 => uint256) private _subjectDeadline;\n    mapping(address => uint256) private _distributorSubject;\n    address[] private _inactiveSharesDistributors;\n\n    uint256 public feeInBasisPoints; // e.g. 300 = 3%\n    address public feeTreasury;\n\n    IERC20 private _token;\n    IFortaStaking private _staking;\n    IRewardsDistributor private _rewardsDistributor;\n    address private _receiverImplementation;\n    address private _distributorImplementation;\n    uint256 private _totalAssets;\n\n    error NotOperator();\n    error InvalidTreasury();\n    error InvalidFee();\n    error PendingUndelegation();\n    error InvalidUndelegation();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initializes the Vault\n     * @param asset_ Asset to stake (FORT Token address)\n     * @param fortaStaking FortaStaking contract address\n     * @param redemptionReceiverImplementation RedemptionReceiver implementation contract\n     * @param inactiveSharesDistributorImplementation InactiveSharesDistributor implementation contract\n     * @param operatorFeeInBasisPoints F"
    }
  ]
}