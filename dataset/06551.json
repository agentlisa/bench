{
  "Title": "[M-01] Delegate architecture forces users to set zero slippage",
  "Content": "\nThe design of the delegate forces users to set a zero value for the `_minReturnedTokens` parameter when calling `pay()` in the terminal.\n\n#### Technical details\n\nIn order to implement the swap functionality, the JBXBuybackDelegate needs to signal the terminal to not mint any tokens when the swap path is token. This is done by setting the `weight` variable to zero:\n\n<https://github.com/code-423n4/2023-05-juicebox/blob/main/juice-buyback/contracts/JBXBuybackDelegate.sol#L144-L171>\n\n```solidity\n144:     function payParams(JBPayParamsData calldata _data)\n145:         external\n146:         override\n147:         returns (uint256 weight, string memory memo, JBPayDelegateAllocation[] memory delegateAllocations)\n148:     {\n149:         // Find the total number of tokens to mint, as a fixed point number with 18 decimals\n150:         uint256 _tokenCount = PRBMath.mulDiv(_data.amount.value, _data.weight, 10 ** 18);\n151: \n152:         // Unpack the quote from the pool, given by the frontend\n153:         (,, uint256 _quote, uint256 _slippage) = abi.decode(_data.metadata, (bytes32, bytes32, uint256, uint256));\n154: \n155:         // If the amount swapped is bigger than the lowest received when minting, use the swap pathway\n156:         if (_tokenCount < _quote - (_quote * _slippage / SLIPPAGE_DENOMINATOR)) {\n157:             // Pass the quote and reserve rate via a mutex\n158:             mintedAmount = _tokenCount;\n159:             reservedRate = _data.reservedRate;\n160: \n161:             // Return this delegate as the one to use, and do not mint from the terminal\n162:             delegateAllocations = new JBPayDelegateAllocation[](1);\n163:             delegateAllocations[0] =\n164:                 JBPayDelegateAllocation({delegate: IJBPayDelegate(this), amount: _data.amount.value});\n165: \n166:             return (0, _data.memo, delegateAllocations);\n167:         }\n168: \n169:         // If minting, do not use this as delegate\n170:         return (_data.weight, _data.memo, new JBPayDelegateAllocation[](0));\n171:     }\n```\n\nThis can be seen in line 166 in the previous snippet of code, where the function returns zero as the `weight` return value when going the swap path. This `weight` is then used to calculate the `tokenCount` in the JBSingleTokenPaymentTerminalStore3\\_1 contract:\n\n<https://github.com/jbx-protocol/juice-contracts-v3/blob/main/contracts/JBSingleTokenPaymentTerminalStore3_1.sol#L427>\n\n```solidity\n...\ntokenCount = PRBMath.mulDiv(_amount.value, _weight, _weightRatio);\n...\n```\n\nThis `tokenCount` variable is finally returned to the JBPayoutRedemptionPaymentTerminal3\\_1 contract, which uses it to calculate the amount of tokens to mint and validate the tokens assigned to the beneficiary are above the minimum:\n\n<https://github.com/jbx-protocol/juice-contracts-v3/blob/main/contracts/abstract/JBPayoutRedemptionPaymentTerminal3_1.sol#L1470-L1493>\n\n```solidity\n...\n\n(_fundingCycle, _tokenCount, _delegateAllocations, _memo) = store.recordPaymentFrom(\n  _payer,\n  _bundledAmount,\n  _projectId,\n  baseWeightCurrency,\n  _beneficiary,\n  _memo,\n  _metadata\n);\n\n// Mint the tokens if needed.\nif (_tokenCount > 0)\n  // Set token count to be the number of tokens minted for the beneficiary instead of the total amount.\n  beneficiaryTokenCount = IJBController(directory.controllerOf(_projectId)).mintTokensOf(\n    _projectId,\n    _tokenCount,\n    _beneficiary,\n    '',\n    _preferClaimedTokens,\n    true\n  );\n\n// The token count for the beneficiary must be greater than or equal to the minimum expected.\nif (beneficiaryTokenCount < _minReturnedTokens) revert INADEQUATE_TOKEN_COUNT();\n\n...\n```\n\nThis means that if the swap path is chosen, `weight` is going to be zero, which sets `_tokenCount` to zero, and implies that `beneficiaryTokenCount` is going to be zero as well. Setting `_minReturnedTokens` to any value different than zero will make the transaction revert.\n\nHowever, the \"buyback\" path is not the only alternative. The delegate could also take the \"vanilla\" path in which it simply bypasses the delegate and tokens are minted in the terminal (line 170 in `payParams()`). This creates a conflict between both paths that forces the user to set `_minReturnedTokens` to zero, because the taken path is resolved at transaction time. Setting `_minReturnedTokens` to any value different than zero will make the \"buyback\" path revert, while setting `_minReturnedTokens` to zero nullifies the slippage check when the \"vanilla\" path is taken.\n\n### Impact\n\nMedium. The current design forces the user to set `_minReturnedTokens` to zero and disables any type of check over the amount of minted tokens.\n\n### Recommendation\n\nIt is difficult to give a recommendation that doesn't involve significant changes to the code, as the current design relies on returning a zero weight when choosing the \"buyback\" path, which forces the condition in `_minReturnedTokens` in order to prevent the transaction revert. Nevertheless, the situation should be revised, as setting a zero value for `_minReturnedTokens` can have a significant impact on users engaging with the protocol.\n\n**[drgorillamd (Juicebox) disagreed with severity via duplicate issue #36 and commented:](https://github.com/code-423n4/2023-05-juicebox-findings/issues/36#issuecomment-1565636239)**\n>2 things: \n> - `_minReturnedToken` is not really used currently in the protocol, as it's rather for future-proof (for the day where we have terminals with various currencies, where a slippage might appear) - screenshot of the latest pay(..) for instance:\n> ![image](https://github.com/code-423n4/2023-05-juicebox-findings/assets/83670532/04d43353-a09f-4f90-a730-d41f62f1e7d6)\n>\n>- In this setting, the delegate doesn't receive this arg (hence the use of the \"free\" metadata arg, to pass the quote/min received)\n>\n>The scenario of \"the transaction is pending then current fc rolls over and the beneficiary receive less token\" looks a bit super edge case (especially for a Medium risk)...\n>\n>Agreed it should be more documented though, as it might be confusing right now.\n\n**[LSDan (judge) commented via issue #36:](https://github.com/code-423n4/2023-05-juicebox-findings/issues/36#issuecomment-1573819837)**\n> I'm going to leave this in place as a Medium. The code functions in unexpected ways based on external factors and it's actual function is very different than a user could reasonably expect. If the variable should always be zero, consider removing it. I don't agree with the assertion that including dead arguments which may be used in the future is future-proof.\n>\n> Also, see [here](https://github.com/code-423n4/org/issues/53#issuecomment-1340685618) with regard to protecting users from themselves.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-juicebox",
  "Code": [
    {
      "filename": "juice-buyback/contracts/JBXBuybackDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBController3_1.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBFundingCycleDataSource.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBPayDelegate.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBPayoutRedemptionPaymentTerminal3_1.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBFundingCycleBallot.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/libraries/JBConstants.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/libraries/JBFundingCycleMetadataResolver.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/libraries/JBTokens.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/structs/JBDidPayData.sol\";\nimport \"@jbx-protocol/juice-contracts-v3/contracts/structs/JBPayParamsData.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nimport \"@paulrberg/contracts/math/PRBMath.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\n\nimport \"./interfaces/external/IWETH9.sol\";\n\n/**\n * @custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n *\n * @title  Buyback Delegate\n *\n * @notice Datasource and delegate allowing pay beneficiary to get the highest amount\n *         of project tokens between minting using the project weigh and swapping in a\n *         given Uniswap V3 pool\n *\n * @dev    This only supports ETH terminal. The pool is fixed, if a new pool offers deeper\n *         liquidity, this delegate needs to be redeployed.\n */\n\ncontract JBXBuybackDelegate is IJBFundingCycleDataSource, IJBPayDelegate, IUniswapV3SwapCallback, Ownable {\n    using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JuiceBuyback_Unauthorized();\n    error JuiceBuyback_MaximumSlippage();\n\n    //*********************************************************************//\n    // -----------------------------  events ----------------------------- //\n    //*********************************************************************//\n\n    event JBXBuybackDelegate_Swap(uint256 projectId, uint256 amountEth, uint256 amountOut);\n    event JBXBuybackDelegate_Mint(uint256 projectId);\n\n    //*********************************************************************//\n    // --------------------- private constant properties ----------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice Address project token < address terminal token ?\n     */\n    bool private immutable _projectTokenIsZero;\n\n    /**\n     * @notice The unit of the max slippage (expressed in 1/10000th)\n     */\n    uint256 private constant SLIPPAGE_DENOMINATOR = 10000;\n\n    //*********************************************************************//\n    // --------------------- public constant properties ------------------ //\n    //*********************************************************************//\n\n    /**\n     * @notice The project token address\n     * \n     * @dev In this context, this is the tokenOut\n     */\n    IERC20 public immutable projectToken;\n\n    /**\n     * @notice The uniswap pool corresponding to the project token-other token market\n     *         (this should be carefully chosen liquidity wise)\n     */\n    IUniswapV3Pool public immutable pool;\n\n    /**\n     * @notice The project terminal using this extension\n     */\n    IJBPayoutRedemptionPaymentTerminal3_1 public immutable jbxTerminal;\n\n    /**\n     * @notice The WETH contract\n     */\n    IWETH9 public immutable weth;\n\n    //*********************************************************************//\n    // --------------------- private stored properties ------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice The amount of token created if minted is prefered\n     * \n     * @dev    This is a mutex 1-x-1\n     */\n    uint256 private mintedAmount = 1;\n\n    /**\n     * @notice The current reserved rate\n     * \n     * @dev    This is a mutex 1-x-1\n     */\n    uint256 private reservedRate = 1;\n\n    /**\n     * @dev No other logic besides initializing the immutables\n     */\n    constructor(\n        IERC20 _projectToken,\n        IWETH9 _weth,\n        IUniswapV3Pool _pool,\n        IJBPayoutRedemptionPaymentTerminal3_1 _jbxTerminal\n    ) {\n        projectToken = _projectToken;\n        pool = _pool;\n        jbxTerminal = _jbxTerminal;\n        _projectTokenIsZero = address(_projectToken) < address(_weth);\n        weth = _weth;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external functions ------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice The datasource implementation\n     *\n     * @param  _data the data passed to the data source in terminal.pay(..). _data.metadata need to have the Uniswap quote\n     * @return weight the weight to use (the one passed if not max reserved rate, 0 if swapping or the one corresponding\n     *         to the reserved token to mint if minting)\n     * @return memo the original memo passed\n     * @return delegateAllocations The amount to send to delegates instead of adding to the local balance.\n     */\n    function payParams(JBPayParamsData calldata _data)\n        external\n        override\n        returns (uint256 weight, string memory memo, JBPayDelegateAllocation[] memory delegateAllocations)\n    {\n        // Find the total number of tokens to mint, as a fixed point number with 18 decimals\n        uint256 _tokenCount = PRBMath.mulDiv(_data.amount.value, _data.weight, 10 ** 18);\n\n        // Unpack the quote from the pool, given by the frontend\n        (,, uint256 _quote, uint256 _slippage) = abi.decode(_data.metadata, (bytes32, bytes32, uint256, uint256));\n\n        // If the amount swapped is bigger than the lowest received when minting, use the swap pathway\n        if (_tokenCount < _quote - (_quote * _slippage / SLIPPAGE_DENOMINATOR)) {\n            // Pass the quote and reserve rate via a mutex\n            mintedAmount = _tokenCount;\n            reservedRate = _data.reservedRate;\n\n            // Return this delegate as the one to use, and do not mint from the terminal\n            delegateAllocations = new JBPayDelegateAllocation[](1);\n            delegateAllocations[0] =\n                JBPayDelegateAllocation({delegate: IJBPayDelegate(this), amount: _data.amount.value});\n\n            return (0, _data.memo, delegateAllocations);\n        }\n\n        // If minting, do not use this as delegate\n        return (_data.weight, _data.memo, new JBPayDelegateAllocation[](0));\n    }\n\n    /**\n     * @notice Delegate to either swap to the beneficiary or mint to the beneficiary\n     *\n     * @dev    This delegate is called only if the quote for the swap is bigger than the lowest received when minting.\n     *         If the swap reverts (slippage, liquidity, etc), the delegate will then mint the same amount of token as\n     *         if the delegate was not used.\n     *         If the beneficiary requests non claimed token, the swap is not used (as it is, per definition, claimed token)\n     *\n     * @param _data the delegate data passed by the terminal\n     */\n    function didPay(JBDidPayData calldata _data) external payable override {\n        // Access control as minting is authorized to this delegate\n        if (msg.sender != address(jbxTerminal)) revert JuiceBuyback_Unauthorized();\n\n        // Retrieve the number of token created if minting and reset the mutex (not exposed in JBDidPayData)\n        uint256 _tokenCount = mintedAmount;\n        mintedAmount = 1;\n\n        // Retrieve the fc reserved rate and reset the mutex\n        uint256 _reservedRate = reservedRate;\n        reservedRate = 1;\n\n        // The minimum amount of token received if swapping\n        (,, uint256 _quote, uint256 _slippage) = abi.decode(_data.metadata, (bytes32, bytes32, uint256, uint256));\n        uint256 _minimumReceivedFromSwap = _quote - (_quote * _slippage / SLIPPAGE_DENOMINATOR);\n\n        // Pick the appropriate pathway (swap vs mint), use mint if non-claimed prefered\n        if (_data.preferClaimedTokens) {\n            // Try swapping\n            uint256 _amountReceived = _swap(_data, _minimumReceivedFromSwap, _reservedRate);\n\n            // If swap failed, mint instead, with the original weight + add to balance the token in\n            if (_amountReceived == 0) _mint(_data, _tokenCount);\n        } else {\n            _mint(_data, _tokenCount);\n        }\n    }\n\n    /**\n     * @notice The Uniswap V3 pool callback (where token transfer should happens)\n     *\n     * @dev    Slippage controle is achieved here\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {\n        // Check if this is really a callback\n        if (msg.sender != address(pool)) revert JuiceBuyback_Unauthorized();\n\n        // Unpack the data\n        (uint256 _minimumAmountReceived) = abi.decode(data, (uint256));\n\n        // Assign 0 and 1 accordingly\n        uint256 _amountReceived = uint256(-(_projectTokenIsZero ? amount0Delta : amount1Delta));\n        uint256 _amountToSend = uint256(_projectTokenIsZero ? amount1Delta : amount0Delta);\n\n        // Revert if slippage is too high\n        if (_amountReceived < _minimumAmountReceived) revert JuiceBuyback_MaximumSlippage();\n\n        // Wrap and transfer the weth to the pool\n        weth.deposit{value: _amountToSend}();\n        weth.transfer(address(pool), _amountToSend);\n    }\n\n    function redeemParams(JBRedeemParamsData calldata _data)\n        external\n        override\n        returns (uint256 reclaimAmount, string memory memo, JBRedemptionDelegateAllocation[] memory delegateAllocations)\n    {}\n\n    //*********************************************************************//\n    // ---------------------- internal functions ------------------------- //\n    //*********************************************************************//\n\n    /**\n     * @notice Swap the terminal token to receive the project toke_beforeTransferTon\n     *\n     * @dev    This delegate first receive the whole amount of project token,\n     *         then send the non-reserved token to the beneficiary,\n     *         then burn the rest of this delegate balance (ie the amount of reserved token),\n     *         then mint the same amount as received (this will add the reserved token, following the fc rate)\n     *         then burn the difference (ie this delegate balance)\n     *         -> End result is having the correct balances (beneficiary and reserve), according to the reserve rate\n     *\n     * @param  _data the didPayData passed by the terminal\n     * @param  _minimumReceivedFromSwap the minimum amount received, to prevent slippage\n     */\n    function _swap(JBDidPayData calldata _data, uint256 _minimumReceivedFromSwap, uint256 _reservedRate)\n        internal\n        returns (uint256 _amountReceived)\n    {\n        // Pass the token and min amount to receive as extra data\n        try pool.swap({\n            recipient: address(this),\n            zeroForOne: !_projectTokenIsZero,\n            amountSpecified: int256(_data.amount.value),\n            sqrtPriceLimitX96: _projectTokenIsZero ? TickMath.MAX_SQRT_RATIO - 1 : TickMath.MIN_SQRT_RATIO + 1,\n            data: abi.encode(_minimumReceivedFromSwap)\n        }) returns (int256 amount0, int256 amount1) {\n            // Swap succeded, take note of the amount of projectToken received (negative as it is an exact input)\n            _amountReceived = uint256(-(_projectTokenIsZero ? amount0 : amount1));\n        } catch {\n            // implies _amountReceived = 0 -> will later mint when back in didPay\n            return _amountReceived;\n        }\n\n        // The amount to send to the beneficiary\n        uint256 _nonReservedToken = PRBMath.mulDiv(\n            _amountReceived, JBConstants.MAX_RESERVED_RATE - _reservedRate, JBConstants.MAX_RESERVED_RATE\n        );\n\n        // The amount to add to the reserved token\n        uint256 _reservedToken = _amountReceived - _nonReservedToken;\n\n        // Send the non-reserved token to the beneficiary (if any / reserved rate is not max)\n        if (_nonReservedToken != 0) projectToken.transfer(_data.beneficiary, _nonReservedToken);\n\n        // If there are reserved token, add them to the reserve\n        if (_reservedToken != 0) {\n            IJBController controller = IJBController(jbxTerminal.directory().controllerOf(_data.projectId));\n\n            // 1) Burn all the reserved token, which are in this address -> result: 0 here, 0 in reserve\n            controller.burnTokensOf({\n                _holder: address(this),\n                _projectId: _data.projectId,\n                _tokenCount: _reservedToken,\n                _memo: \"\",\n                _preferClaimedTokens: true\n            });\n\n            // 2) Mint the reserved token with this address as beneficiary -> result: _amountReceived-reserved here, reservedToken in reserve\n            controller.mintTokensOf({\n                _projectId: _data.projectId,\n                _tokenCount: _amountReceived,\n                _beneficiary: address(this),\n                _memo: _data.memo,\n                _preferClaimedTokens: false,\n                _useReservedRate: true\n            });\n\n            // 3) Burn the non-reserve token which are now left in this address (can be 0) -> result: 0 here, reservedToken in reserve\n            uint256 _nonReservedTokenInContract = _amountReceived - _reservedToken;\n\n            if (_nonReservedTokenInContract != 0) {\n                controller.burnTokensOf({\n                    _holder: address(this),\n                    _projectId: _data.projectId,\n                    _tokenCount: _nonReservedTokenInContract,\n                    _memo: \"\",\n                    _preferClaimedTokens: false\n                });\n            }\n        }\n\n        emit JBXBuybackDelegate_Swap(_data.projectId, _data.amount.value, _amountReceived);\n    }\n\n    /**\n     * @notice Mint the token out, sending back the token in in the terminal\n     *\n     * @param  _data the didPayData passed by the terminal\n     * @param  _amount the amount of token out to mint\n     */\n    function _mint(JBDidPayData calldata _data, uint256 _amount) internal {\n        IJBController controller = IJBController(jbxTerminal.directory().controllerOf(_data.projectId));\n\n        // Mint to the beneficiary with the fc reserve rate\n        controller.mintTokensOf({\n            _projectId: _data.projectId,\n            _tokenCount: _amount,\n            _beneficiary: _data.beneficiary,\n            _memo: _data.memo,\n            _preferClaimedTokens: _data.preferClaimedTokens,\n            _useReservedRate: true\n        });\n\n        // Send the eth back to the terminal balance\n        jbxTerminal.addToBalanceOf{value: _data.amount.value}(\n            _data.projectId, _data.amount.value, JBTokens.ETH, \"\", new bytes(0)\n        );\n\n        emit JBXBuybackDelegate_Mint(_data.projectId);\n    }\n\n    //*********************************************************************//\n    // ---------------------- peripheral functions ----------------------- //\n    //*********************************************************************//\n\n    function supportsInterface(bytes4 _interfaceId) external pure override returns (bool) {\n        return _interfaceId == type(IJBFundingCycleDataSource).interfaceId\n            || _interfaceId == type(IJBPayDelegate).interfaceId;\n    }\n}"
    },
    {
      "filename": "contracts/JBSingleTokenPaymentTerminalStore3_1.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {PRBMath} from '@paulrberg/contracts/math/PRBMath.sol';\nimport {JBBallotState} from './enums/JBBallotState.sol';\nimport {IJBDirectory} from './interfaces/IJBDirectory.sol';\nimport {IJBController3_1} from './interfaces/IJBController3_1.sol';\nimport {IJBFundingCycleDataSource} from './interfaces/IJBFundingCycleDataSource.sol';\nimport {IJBFundingCycleStore} from './interfaces/IJBFundingCycleStore.sol';\nimport {IJBPaymentTerminal} from './interfaces/IJBPaymentTerminal.sol';\nimport {IJBSingleTokenPaymentTerminal} from './interfaces/IJBSingleTokenPaymentTerminal.sol';\nimport {IJBSingleTokenPaymentTerminalStore} from './interfaces/IJBSingleTokenPaymentTerminalStore.sol';\nimport {IJBPrices} from './interfaces/IJBPrices.sol';\nimport {JBConstants} from './libraries/JBConstants.sol';\nimport {JBCurrencies} from './libraries/JBCurrencies.sol';\nimport {JBFixedPointNumber} from './libraries/JBFixedPointNumber.sol';\nimport {JBFundingCycle} from './structs/JBFundingCycle.sol';\nimport {JBFundingCycleMetadataResolver} from './libraries/JBFundingCycleMetadataResolver.sol';\nimport {JBPayDelegateAllocation} from './structs/JBPayDelegateAllocation.sol';\nimport {JBPayParamsData} from './structs/JBPayParamsData.sol';\nimport {JBRedeemParamsData} from './structs/JBRedeemParamsData.sol';\nimport {JBRedemptionDelegateAllocation} from './structs/JBRedemptionDelegateAllocation.sol';\nimport {JBTokenAmount} from './structs/JBTokenAmount.sol';\n\n/// @notice Manages all bookkeeping for inflows and outflows of funds from any ISingleTokenPaymentTerminal.\n/// @dev This Store expects a project's controller to be an IJBController3_1. This is the only difference between this version and the original.\ncontract JBSingleTokenPaymentTerminalStore3_1 is\n  ReentrancyGuard,\n  IJBSingleTokenPaymentTerminalStore\n{\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error INVALID_AMOUNT_TO_SEND_DELEGATE();\n  error CURRENCY_MISMATCH();\n  error DISTRIBUTION_AMOUNT_LIMIT_REACHED();\n  error FUNDING_CYCLE_PAYMENT_PAUSED();\n  error FUNDING_CYCLE_DISTRIBUTION_PAUSED();\n  error FUNDING_CYCLE_REDEEM_PAUSED();\n  error INADEQUATE_CONTROLLER_ALLOWANCE();\n  error INADEQUATE_PAYMENT_TERMINAL_STORE_BALANCE();\n  error INSUFFICIENT_TOKENS();\n  error INVALID_FUNDING_CYCLE();\n  error PAYMENT_TERMINAL_MIGRATION_NOT_ALLOWED();\n\n  //*********************************************************************//\n  // -------------------------- private constants ---------------------- //\n  //*********************************************************************//\n\n  /// @notice Ensures a maximum number of decimal points of persisted fidelity on mulDiv operations of fixed point numbers.\n  uint256 private constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n  //*********************************************************************//\n  // ---------------- public immutable stored properties --------------- //\n  //*********************************************************************//\n\n  /// @notice The directory of terminals and controllers for projects.\n  IJBDirectory public immutable override directory;\n\n  /// @notice The contract storing all funding cycle configurations.\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /// @notice The contract that exposes price feeds.\n  IJBPrices public immutable override prices;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /// @notice The amount of tokens that each project has for each terminal, in terms of the terminal's token.\n  /// @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n  /// @custom:param _terminal The terminal to which the balance applies.\n  /// @custom:param _projectId The ID of the project to get the balance of.\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => uint256)) public override balanceOf;\n\n  /// @notice The amount of funds that a project has distributed from its limit during the current funding cycle for each terminal, in terms of the distribution limit's currency.\n  /// @dev Increases as projects use their preconfigured distribution limits.\n  /// @dev The used distribution limit is represented as a fixed point number with the same amount of decimals as its relative terminal.\n  /// @custom:param _terminal The terminal to which the used distribution limit applies.\n  /// @custom:param _projectId The ID of the project to get the used distribution limit of.\n  /// @custom:param _fundingCycleNumber The number of the funding cycle during which the distribution limit was used.\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))\n    public\n    override usedDistributionLimitOf;\n\n  /// @notice The amount of funds that a project has used from its allowance during the current funding cycle configuration for each terminal, in terms of the overflow allowance's currency.\n  /// @dev Increases as projects use their allowance.\n  /// @dev The used allowance is represented as a fixed point number with the same amount of decimals as its relative terminal.\n  /// @custom:param _terminal The terminal to which the overflow allowance applies.\n  /// @custom:param _projectId The ID of the project to get the used overflow allowance of.\n  /// @custom:param _configuration The configuration of the during which the allowance was used.\n  mapping(IJBSingleTokenPaymentTerminal => mapping(uint256 => mapping(uint256 => uint256)))\n    public\n    override usedOverflowAllowanceOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /// @notice Gets the current overflowed amount in a terminal for a specified project.\n  /// @dev The current overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n  /// @param _terminal The terminal for which the overflow is being calculated.\n  /// @param _projectId The ID of the project to get overflow for.\n  /// @return The current amount of overflow that project has in the specified terminal.\n  function currentOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId\n  ) external view override returns (uint256) {\n    // Return the overflow during the project's current funding cycle.\n    return\n      _overflowDuring(\n        _terminal,\n        _projectId,\n        fundingCycleStore.currentOf(_projectId),\n        _terminal.currency()\n      );\n  }\n\n  /// @notice Gets the current overflowed amount for a specified project across all terminals.\n  /// @param _projectId The ID of the project to get total overflow for.\n  /// @param _decimals The number of decimals that the fixed point overflow should include.\n  /// @param _currency The currency that the total overflow should be in terms of.\n  /// @return The current total amount of overflow that project has across all terminals.\n  function currentTotalOverflowOf(\n    uint256 _projectId,\n    uint256 _decimals,\n    uint256 _currency\n  ) external view override returns (uint256) {\n    return _currentTotalOverflowOf(_projectId, _decimals, _currency);\n  }\n\n  /// @notice The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the total token supply and overflow in the ecosystem.\n  /// @dev If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n  /// @dev The current reclaimable overflow is returned in terms of the specified terminal's currency.\n  /// @dev The reclaimable overflow is represented as a fixed point number with the same amount of decimals as the specified terminal.\n  /// @param _terminal The terminal from which the reclaimable amount would come.\n  /// @param _projectId The ID of the project to get the reclaimable overflow amount for.\n  /// @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n  /// @param _useTotalOverflow A flag indicating whether the overflow used in the calculation should be summed from all of the project's terminals. If false, overflow should be limited to the amount in the specified `_terminal`.\n  /// @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_terminal`.\n  function currentReclaimableOverflowOf(\n    IJBSingleTokenPaymentTerminal _terminal,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    bool _useTotalOverflow\n  ) external view override returns (uint256) {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get the amount of current overflow.\n    // Use the project's total overflow across all of its terminals if the flag species specifies so. Otherwise, use the overflow local to the specified terminal.\n    uint256 _currentOverflow = _useTotalOverflow\n      ? _currentTotalOverflowOf(_projectId, _terminal.decimals(), _terminal.currency())\n      : _overflowDuring(_terminal, _projectId, _fundingCycle, _terminal.currency());\n\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_currentOverflow == 0) return 0;\n\n    // Get the number of outstanding tokens the project has.\n    uint256 _totalSupply = IJBController3_1(directory.controllerOf(_projectId))\n      .totalOutstandingTokensOf(_projectId);\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount > _totalSupply) return 0;\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(\n        _projectId,\n        _fundingCycle,\n        _tokenCount,\n        _totalSupply,\n        _currentOverflow\n      );\n  }\n\n  /// @notice The current amount of overflowed tokens from a terminal that can be reclaimed by the specified number of tokens, using the specified total token supply and overflow amounts.\n  /// @dev If the project has an active funding cycle reconfiguration ballot, the project's ballot redemption rate is used.\n  /// @param _projectId The ID of the project to get the reclaimable overflow amount for.\n  /// @param _tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n  /// @param _totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n  /// @param _overflow The amount of overflow to make the calculation with, as a fixed point number.\n  /// @return The amount of overflowed tokens that can be reclaimed, as a fixed point number with the same number of decimals as the provided `_overflow`.\n  function currentReclaimableOverflowOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    uint256 _totalSupply,\n    uint256 _overflow\n  ) external view override returns (uint256) {\n    // If there's no overflow, there's no reclaimable overflow.\n    if (_overflow == 0) return 0;\n\n    // Can't redeem more tokens that is in the supply.\n    if (_tokenCount > _totalSupply) return 0;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Return the reclaimable overflow amount.\n    return\n      _reclaimableOverflowDuring(_projectId, _fundingCycle, _tokenCount, _totalSupply, _overflow);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /// @param _directory A contract storing directories of terminals and controllers for each project.\n  /// @param _fundingCycleStore A contract storing all funding cycle configurations.\n  /// @param _prices A contract that exposes price feeds.\n  constructor(IJBDirectory _directory, IJBFundingCycleStore _fundingCycleStore, IJBPrices _prices) {\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    prices = _prices;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /// @notice Records newly contributed tokens to a project.\n  /// @dev Mints the project's tokens according to values provided by a configured data source. If no data source is configured, mints tokens proportional to the amount of the contribution.\n  /// @dev The msg.sender must be an IJBSingleTokenPaymentTerminal. The amount specified in the params is in terms of the msg.sender's tokens.\n  /// @param _payer The original address that sent the payment to the terminal.\n  /// @param _amount The amount of tokens being paid. Includes the token being paid, the value, the number of decimals included, and the currency of the amount.\n  /// @param _projectId The ID of the project being paid.\n  /// @param _baseWeightCurrency The currency to base token issuance on.\n  /// @param _beneficiary The specified address that should be the beneficiary of anything that results from the payment.\n  /// @param _memo A memo to pass along to the emitted event, and passed along to the funding cycle's data source.\n  /// @param _metadata Bytes to send along to the data source, if one is provided.\n  /// @return fundingCycle The project's funding cycle during which payment was made.\n  /// @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n  /// @return delegateAllocations The amount to send to delegates instead of adding to the local balance.\n  /// @return memo A memo that should be passed along to the emitted event.\n  function recordPaymentFrom(\n    address _payer,\n    JBTokenAmount calldata _amount,\n    uint256 _projectId,\n    uint256 _baseWeightCurrency,\n    address _beneficiary,\n    string calldata _memo,\n    bytes memory _metadata\n  )\n    external\n    override\n    nonReentrant\n    returns (\n      JBFundingCycle memory fundingCycle,\n      uint256 tokenCount,\n      JBPayDelegateAllocation[] memory delegateAllocations,\n      string memory memo\n    )\n  {\n    // Get a reference to the current funding cycle for the project.\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The project must have a funding cycle configured.\n    if (fundingCycle.number == 0) revert INVALID_FUNDING_CYCLE();\n\n    // Must not be paused.\n    if (fundingCycle.payPaused()) revert FUNDING_CYCLE_PAYMENT_PAUSED();\n\n    // The weight according to which new token supply is to be minted, as a fixed point number with 18 decimals.\n    uint256 _weight;\n\n    // If the funding cycle has configured a data source, use it to derive a weight and memo.\n    if (fundingCycle.useDataSourceForPay() && fundingCycle.dataSource() != address(0)) {\n      // Create the params that'll be sent to the data source.\n      JBPayParamsData memory _data = JBPayParamsData(\n        IJBSingleTokenPaymentTerminal(msg.sender),\n        _payer,\n        _amount,\n        _projectId,\n        fundingCycle.configuration,\n        _beneficiary,\n        fundingCycle.weight,\n        fundingCycle.reservedRate(),\n        _memo,\n        _metadata\n      );\n      (_weight, memo, delegateAllocations) = IJBFundingCycleDataSource(fundingCycle.dataSource())\n        .payParams(_data);\n    }\n    // Otherwise use the funding cycle's weight\n    else {\n      _weight = fundingCycle.weight;\n      memo = _memo;\n    }\n\n    // Scoped section prevents stack too deep. `_balanceDiff` only used within scope.\n    {\n      // Keep a reference to the amount that should be added to the project's balance.\n      uint256 _balanceDiff = _amount.value;\n\n      // Validate all delegated amounts. This needs to be done before returning the delegate allocations to ensure valid delegated amounts.\n      if (delegateAllocations.length != 0) {\n        for (uin"
    }
  ]
}