{
  "Title": "M-7: Unsafe casting within _purchase function can result in overflow",
  "Content": "# Issue M-7: Unsafe casting within _purchase function can result in overflow \n\nSource: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/204 \n\n## Found by \nFindEverythingX\n## Summary\nUnsafe casting within _purchase function can result in overflow\n\n## Vulnerability Detail\nContract: FPAM.sol\n\nThe _purchase function is invoked whenever a user wants to buy some tokens from an FPAM auction. \n\nNote how the amount_ parameter is from type uint96:\n\n[https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/FPAM.sol#L128](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/FPAM.sol#L128)\n\nThe payout is then calculated as follows:\n\namount * 10^baseTokenDecimals / price\n\n[https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/FPAM.sol#L135](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/FPAM.sol#L135)\n\nThe crux: The quote token can be with 6 decimals and the base token with 18 decimals.\n\nThis would then potentially result in an overflow and the payout is falsified. \n\nConsider the following PoC:\n\namount = 1_000_000_000e6 (fees can be deducted or not, this does not matter for this PoC)\n\nbaseTokenDecimals = 18\n\nprice = 1e4\n\nThis price basically means, a user will receive 1e18 BASE tokens for 1e4 (0.01) QUOTE tokens, respectively a user must provide 1e4 (0.01) QUOTE tokens to receive 1e18 BASE tokens\n\nThe calculation would be as follows:\n\n1_000_000_000e6 * 1e18 / 1e4 = 1e29\n\nwhile uint96.max = 7.922â€¦.e28\n\nTherefore, the result will be casted to uint96 and overflow, it would effectively manipulate the auction outcome, which can result in a loss of funds for the buyer, because he will receive less BASE tokens than expected (due to the overflow).\n\nIt is clear that this calculation example can work on multiple different scenarios (even though only very limited because of the high bidding [amount] size) . However, using BASE token with 18 decimals and QUOTE token with 6 decimals will more often result in such an issue.\n\nThis issue is only rated as medium severity because the buyer can determine a minAmountOut parameter. The problem is however the auction is a fixed price auction and the buyer already knows the price and the amount he provides, which gives him exactly the fixed output amount. Therefore, there is usually absolutely no slippage necessity to be set by the buyer and lazy buyers might just set this to zero.\n\n## Impact\nIMPACT:\n\na) Loss of funds for buyer\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/FPAM.sol#L128\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/FPAM.sol#L135\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider simply switching to a uint256 approach, this should be adapted in the overall architecture. The only important thing (as far as I have observed) is to make sure the heap mechanism does not overflow when calculating the relative values:\n\n[https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/lib/MaxPriorityQueue.sol#L114](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/lib/MaxPriorityQueue.sol#L114)\n\n\n\n## Discussion\n\n**0xJem**\n\nI would rate this low priority.\n\nIt is possible, but highly unlikely as it requires all of these conditions to be met:\n- The lot capacity would need to be close to the maximum (uint96 max)\n- The max payout needs to be 100%\n- The quote token decimals need to be low\n- The price needs to be low\n\n**Oighty**\n\nI do think this is valid. I'll leave it up to the judge to determine severity. The fact that the buyer can receive much fewer tokens than expected, even in an outlandish scenario, shouldn't be possible.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Axis-Fi/moonraker/pull/130\n\n\n**10xhash**\n\n> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#130](https://github.com/Axis-Fi/moonraker/pull/130)\n\nFixed\nuint256 is now used, avoiding the unsafe casting\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/206",
  "Code": [
    {
      "filename": "moonraker/src/modules/auctions/FPAM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n// Protocol dependencies\nimport {Module} from \"src/modules/Modules.sol\";\nimport {AuctionModule, Auction} from \"src/modules/Auction.sol\";\nimport {Veecode, toVeecode} from \"src/modules/Modules.sol\";\n\n// Libraries\nimport {FixedPointMathLib as Math} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\n\ncontract FixedPriceAuctionModule is AuctionModule {\n    // ========== ERRORS ========== //\n\n    error Auction_InsufficientPayout();\n    error Auction_PayoutGreaterThanMax();\n\n    // ========== EVENTS ========== //\n\n    // ========== DATA STRUCTURES ========== //\n\n    /// @notice             Auction-specific data for a lot\n    ///\n    /// @param price        The fixed price of the lot\n    /// @param maxPayout    The maximum payout per purchase, in terms of the base token\n    struct AuctionData {\n        uint96 price;\n        uint96 maxPayout;\n    }\n\n    /// @notice                     Parameters for a fixed price auction\n    ///\n    /// @param price                The fixed price of the lot\n    /// @param maxPayoutPercent     The maximum payout per purchase, as a percentage of the capacity\n    struct FixedPriceParams {\n        uint96 price;\n        uint24 maxPayoutPercent;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     Auction-specific data for a lot\n    mapping(uint96 lotId => AuctionData) public auctionData;\n\n    // ========== SETUP ========== //\n\n    constructor(address auctionHouse_) AuctionModule(auctionHouse_) {\n        // Set the minimum auction duration to 1 day initially\n        minAuctionDuration = 1 days;\n    }\n\n    /// @inheritdoc Module\n    function VEECODE() public pure override returns (Veecode) {\n        return toVeecode(\"01FPAM\");\n    }\n\n    /// @inheritdoc Module\n    function TYPE() public pure override returns (Type) {\n        return Type.Auction;\n    }\n\n    /// @inheritdoc Auction\n    function auctionType() external pure override returns (AuctionType) {\n        return AuctionType.Atomic;\n    }\n\n    // ========== AUCTION ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The start and duration of the lot have been validated\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The price is zero\n    ///             - The max payout percent is greater than 100% or less than 1%\n    function _auction(uint96 lotId_, Lot memory lot_, bytes memory params_) internal override {\n        // Decode the auction params\n        FixedPriceParams memory auctionParams = abi.decode(params_, (FixedPriceParams));\n\n        // Validate the price is not zero\n        if (auctionParams.price == 0) revert Auction_InvalidParams();\n\n        // Validate the max payout percent is between 1% and 100%\n        if (\n            auctionParams.maxPayoutPercent < 1e3\n                || auctionParams.maxPayoutPercent > _ONE_HUNDRED_PERCENT\n        ) revert Auction_InvalidParams();\n\n        // Calculate the max payout\n        uint96 maxPayout = uint96(\n            Math.mulDivDown(lot_.capacity, auctionParams.maxPayoutPercent, _ONE_HUNDRED_PERCENT)\n        );\n        // If capacity in quote, convert max payout to base token using the provided price\n        if (lot_.capacityInQuote) {\n            maxPayout = uint96(\n                Math.mulDivDown(maxPayout, 10 ** lot_.baseTokenDecimals, auctionParams.price)\n            );\n        }\n\n        // Store the auction data\n        AuctionData storage data = auctionData[lotId_];\n        data.price = auctionParams.price;\n        data.maxPayout = maxPayout;\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction has not concluded\n    function _cancelAuction(uint96 lotId_) internal pure override {}\n\n    // ========== PURCHASE ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///\n    ///             This function reverts if:\n    ///             - The payout is less than the minAmountOut specified by the purchaser\n    ///             - The payout is greater than the max payout\n    function _purchase(\n        uint96 lotId_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal view override returns (uint96 payout, bytes memory) {\n        // Decode the auction data into the min amount out\n        uint96 minAmountOut = abi.decode(auctionData_, (uint96));\n\n        // Calculate the amount of the base token to purchase\n        payout = uint96(\n            Math.mulDivDown(\n                amount_, 10 ** lotData[lotId_].baseTokenDecimals, auctionData[lotId_].price\n            )\n        );\n\n        // Validate the payout is greater than or equal to the minimum amount out\n        if (payout < minAmountOut) revert Auction_InsufficientPayout();\n\n        // Validate the payout is less than the max payout\n        if (payout > auctionData[lotId_].maxPayout) revert Auction_PayoutGreaterThanMax();\n\n        return (payout, bytes(\"\"));\n    }\n\n    // ========== NOT IMPLEMENTED ========== //\n\n    function _bid(\n        uint96,\n        address,\n        address,\n        uint96,\n        bytes calldata\n    ) internal pure override returns (uint64) {\n        revert Auction_NotImplemented();\n    }\n\n    function _refundBid(uint96, uint64, address) internal pure override returns (uint96) {\n        revert Auction_NotImplemented();\n    }\n\n    function _claimBids(\n        uint96,\n        uint64[] calldata\n    ) internal pure override returns (BidClaim[] memory, bytes memory) {\n        revert Auction_NotImplemented();\n    }\n\n    function _settle(uint96) internal pure override returns (Settlement memory, bytes memory) {\n        revert Auction_NotImplemented();\n    }\n\n    function _claimProceeds(uint96) internal pure override returns (uint96, uint96, uint96) {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotSettled(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotNotSettled(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotProceedsClaimed(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfBidInvalid(uint96, uint64) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfNotBidOwner(uint96, uint64, address) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfBidClaimed(uint96, uint64) internal pure override {\n        revert Auction_NotImplemented();\n    }\n}"
    },
    {
      "filename": "moonraker/src/modules/auctions/FPAM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n// Protocol dependencies\nimport {Module} from \"src/modules/Modules.sol\";\nimport {AuctionModule, Auction} from \"src/modules/Auction.sol\";\nimport {Veecode, toVeecode} from \"src/modules/Modules.sol\";\n\n// Libraries\nimport {FixedPointMathLib as Math} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\n\ncontract FixedPriceAuctionModule is AuctionModule {\n    // ========== ERRORS ========== //\n\n    error Auction_InsufficientPayout();\n    error Auction_PayoutGreaterThanMax();\n\n    // ========== EVENTS ========== //\n\n    // ========== DATA STRUCTURES ========== //\n\n    /// @notice             Auction-specific data for a lot\n    ///\n    /// @param price        The fixed price of the lot\n    /// @param maxPayout    The maximum payout per purchase, in terms of the base token\n    struct AuctionData {\n        uint96 price;\n        uint96 maxPayout;\n    }\n\n    /// @notice                     Parameters for a fixed price auction\n    ///\n    /// @param price                The fixed price of the lot\n    /// @param maxPayoutPercent     The maximum payout per purchase, as a percentage of the capacity\n    struct FixedPriceParams {\n        uint96 price;\n        uint24 maxPayoutPercent;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     Auction-specific data for a lot\n    mapping(uint96 lotId => AuctionData) public auctionData;\n\n    // ========== SETUP ========== //\n\n    constructor(address auctionHouse_) AuctionModule(auctionHouse_) {\n        // Set the minimum auction duration to 1 day initially\n        minAuctionDuration = 1 days;\n    }\n\n    /// @inheritdoc Module\n    function VEECODE() public pure override returns (Veecode) {\n        return toVeecode(\"01FPAM\");\n    }\n\n    /// @inheritdoc Module\n    function TYPE() public pure override returns (Type) {\n        return Type.Auction;\n    }\n\n    /// @inheritdoc Auction\n    function auctionType() external pure override returns (AuctionType) {\n        return AuctionType.Atomic;\n    }\n\n    // ========== AUCTION ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The start and duration of the lot have been validated\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The price is zero\n    ///             - The max payout percent is greater than 100% or less than 1%\n    function _auction(uint96 lotId_, Lot memory lot_, bytes memory params_) internal override {\n        // Decode the auction params\n        FixedPriceParams memory auctionParams = abi.decode(params_, (FixedPriceParams));\n\n        // Validate the price is not zero\n        if (auctionParams.price == 0) revert Auction_InvalidParams();\n\n        // Validate the max payout percent is between 1% and 100%\n        if (\n            auctionParams.maxPayoutPercent < 1e3\n                || auctionParams.maxPayoutPercent > _ONE_HUNDRED_PERCENT\n        ) revert Auction_InvalidParams();\n\n        // Calculate the max payout\n        uint96 maxPayout = uint96(\n            Math.mulDivDown(lot_.capacity, auctionParams.maxPayoutPercent, _ONE_HUNDRED_PERCENT)\n        );\n        // If capacity in quote, convert max payout to base token using the provided price\n        if (lot_.capacityInQuote) {\n            maxPayout = uint96(\n                Math.mulDivDown(maxPayout, 10 ** lot_.baseTokenDecimals, auctionParams.price)\n            );\n        }\n\n        // Store the auction data\n        AuctionData storage data = auctionData[lotId_];\n        data.price = auctionParams.price;\n        data.maxPayout = maxPayout;\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction has not concluded\n    function _cancelAuction(uint96 lotId_) internal pure override {}\n\n    // ========== PURCHASE ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///\n    ///             This function reverts if:\n    ///             - The payout is less than the minAmountOut specified by the purchaser\n    ///             - The payout is greater than the max payout\n    function _purchase(\n        uint96 lotId_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal view override returns (uint96 payout, bytes memory) {\n        // Decode the auction data into the min amount out\n        uint96 minAmountOut = abi.decode(auctionData_, (uint96));\n\n        // Calculate the amount of the base token to purchase\n        payout = uint96(\n            Math.mulDivDown(\n                amount_, 10 ** lotData[lotId_].baseTokenDecimals, auctionData[lotId_].price\n            )\n        );\n\n        // Validate the payout is greater than or equal to the minimum amount out\n        if (payout < minAmountOut) revert Auction_InsufficientPayout();\n\n        // Validate the payout is less than the max payout\n        if (payout > auctionData[lotId_].maxPayout) revert Auction_PayoutGreaterThanMax();\n\n        return (payout, bytes(\"\"));\n    }\n\n    // ========== NOT IMPLEMENTED ========== //\n\n    function _bid(\n        uint96,\n        address,\n        address,\n        uint96,\n        bytes calldata\n    ) internal pure override returns (uint64) {\n        revert Auction_NotImplemented();\n    }\n\n    function _refundBid(uint96, uint64, address) internal pure override returns (uint96) {\n        revert Auction_NotImplemented();\n    }\n\n    function _claimBids(\n        uint96,\n        uint64[] calldata\n    ) internal pure override returns (BidClaim[] memory, bytes memory) {\n        revert Auction_NotImplemented();\n    }\n\n    function _settle(uint96) internal pure override returns (Settlement memory, bytes memory) {\n        revert Auction_NotImplemented();\n    }\n\n    function _claimProceeds(uint96) internal pure override returns (uint96, uint96, uint96) {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotSettled(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotNotSettled(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotProceedsClaimed(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfBidInvalid(uint96, uint64) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfNotBidOwner(uint96, uint64, address) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfBidClaimed(uint96, uint64) internal pure override {\n        revert Auction_NotImplemented();\n    }\n}"
    },
    {
      "filename": "moonraker/src/modules/auctions/FPAM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n// Protocol dependencies\nimport {Module} from \"src/modules/Modules.sol\";\nimport {AuctionModule, Auction} from \"src/modules/Auction.sol\";\nimport {Veecode, toVeecode} from \"src/modules/Modules.sol\";\n\n// Libraries\nimport {FixedPointMathLib as Math} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\n\ncontract FixedPriceAuctionModule is AuctionModule {\n    // ========== ERRORS ========== //\n\n    error Auction_InsufficientPayout();\n    error Auction_PayoutGreaterThanMax();\n\n    // ========== EVENTS ========== //\n\n    // ========== DATA STRUCTURES ========== //\n\n    /// @notice             Auction-specific data for a lot\n    ///\n    /// @param price        The fixed price of the lot\n    /// @param maxPayout    The maximum payout per purchase, in terms of the base token\n    struct AuctionData {\n        uint96 price;\n        uint96 maxPayout;\n    }\n\n    /// @notice                     Parameters for a fixed price auction\n    ///\n    /// @param price                The fixed price of the lot\n    /// @param maxPayoutPercent     The maximum payout per purchase, as a percentage of the capacity\n    struct FixedPriceParams {\n        uint96 price;\n        uint24 maxPayoutPercent;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     Auction-specific data for a lot\n    mapping(uint96 lotId => AuctionData) public auctionData;\n\n    // ========== SETUP ========== //\n\n    constructor(address auctionHouse_) AuctionModule(auctionHouse_) {\n        // Set the minimum auction duration to 1 day initially\n        minAuctionDuration = 1 days;\n    }\n\n    /// @inheritdoc Module\n    function VEECODE() public pure override returns (Veecode) {\n        return toVeecode(\"01FPAM\");\n    }\n\n    /// @inheritdoc Module\n    function TYPE() public pure override returns (Type) {\n        return Type.Auction;\n    }\n\n    /// @inheritdoc Auction\n    function auctionType() external pure override returns (AuctionType) {\n        return AuctionType.Atomic;\n    }\n\n    // ========== AUCTION ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The start and duration of the lot have been validated\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The price is zero\n    ///             - The max payout percent is greater than 100% or less than 1%\n    function _auction(uint96 lotId_, Lot memory lot_, bytes memory params_) internal override {\n        // Decode the auction params\n        FixedPriceParams memory auctionParams = abi.decode(params_, (FixedPriceParams));\n\n        // Validate the price is not zero\n        if (auctionParams.price == 0) revert Auction_InvalidParams();\n\n        // Validate the max payout percent is between 1% and 100%\n        if (\n            auctionParams.maxPayoutPercent < 1e3\n                || auctionParams.maxPayoutPercent > _ONE_HUNDRED_PERCENT\n        ) revert Auction_InvalidParams();\n\n        // Calculate the max payout\n        uint96 maxPayout = uint96(\n            Math.mulDivDown(lot_.capacity, auctionParams.maxPayoutPercent, _ONE_HUNDRED_PERCENT)\n        );\n        // If capacity in quote, convert max payout to base token using the provided price\n        if (lot_.capacityInQuote) {\n            maxPayout = uint96(\n                Math.mulDivDown(maxPayout, 10 ** lot_.baseTokenDecimals, auctionParams.price)\n            );\n        }\n\n        // Store the auction data\n        AuctionData storage data = auctionData[lotId_];\n        data.price = auctionParams.price;\n        data.maxPayout = maxPayout;\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction has not concluded\n    function _cancelAuction(uint96 lotId_) internal pure override {}\n\n    // ========== PURCHASE ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///\n    ///             This function reverts if:\n    ///             - The payout is less than the minAmountOut specified by the purchaser\n    ///             - The payout is greater than the max payout\n    function _purchase(\n        uint96 lotId_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal view override returns (uint96 payout, bytes memory) {\n        // Decode the auction data into the min amount out\n        uint96 minAmountOut = abi.decode(auctionData_, (uint96));\n\n        // Calculate the amount of the base token to purchase\n        payout = uint96(\n            Math.mulDivDown(\n                amount_, 10 ** lotData[lotId_].baseTokenDecimals, auctionData[lotId_].price\n            )\n        );\n\n        // Validate the payout is greater than or equal to the minimum amount out\n        if (payout < minAmountOut) revert Auction_InsufficientPayout();\n\n        // Validate the payout is less than the max payout\n        if (payout > auctionData[lotId_].maxPayout) revert Auction_PayoutGreaterThanMax();\n\n        return (payout, bytes(\"\"));\n    }\n\n    // ========== NOT IMPLEMENTED ========== //\n\n    function _bid(\n        uint96,\n        address,\n        address,\n        uint96,\n        bytes calldata\n    ) internal pure override returns (uint64) {\n        revert Auction_NotImplemented();\n    }\n\n    function _refundBid(uint96, uint64, address) internal pure override returns (uint96) {\n        revert Auction_NotImplemented();\n    }\n\n    function _claimBids(\n        uint96,\n        uint64[] calldata\n    ) internal pure override returns (BidClaim[] memory, bytes memory) {\n        revert Auction_NotImplemented();\n    }\n\n    function _settle(uint96) internal pure override returns (Settlement memory, bytes memory) {\n        revert Auction_NotImplemented();\n    }\n\n    function _claimProceeds(uint96) internal pure override returns (uint96, uint96, uint96) {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotSettled(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotNotSettled(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotProceedsClaimed(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfBidInvalid(uint96, uint64) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfNotBidOwner(uint96, uint64, address) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfBidClaimed(uint96, uint64) internal pure override {\n        revert Auction_NotImplemented();\n    }\n}"
    },
    {
      "filename": "moonraker/src/modules/auctions/FPAM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n// Protocol dependencies\nimport {Module} from \"src/modules/Modules.sol\";\nimport {AuctionModule, Auction} from \"src/modules/Auction.sol\";\nimport {Veecode, toVeecode} from \"src/modules/Modules.sol\";\n\n// Libraries\nimport {FixedPointMathLib as Math} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\n\ncontract FixedPriceAuctionModule is AuctionModule {\n    // ========== ERRORS ========== //\n\n    error Auction_InsufficientPayout();\n    error Auction_PayoutGreaterThanMax();\n\n    // ========== EVENTS ========== //\n\n    // ========== DATA STRUCTURES ========== //\n\n    /// @notice             Auction-specific data for a lot\n    ///\n    /// @param price        The fixed price of the lot\n    /// @param maxPayout    The maximum payout per purchase, in terms of the base token\n    struct AuctionData {\n        uint96 price;\n        uint96 maxPayout;\n    }\n\n    /// @notice                     Parameters for a fixed price auction\n    ///\n    /// @param price                The fixed price of the lot\n    /// @param maxPayoutPercent     The maximum payout per purchase, as a percentage of the capacity\n    struct FixedPriceParams {\n        uint96 price;\n        uint24 maxPayoutPercent;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     Auction-specific data for a lot\n    mapping(uint96 lotId => AuctionData) public auctionData;\n\n    // ========== SETUP ========== //\n\n    constructor(address auctionHouse_) AuctionModule(auctionHouse_) {\n        // Set the minimum auction duration to 1 day initially\n        minAuctionDuration = 1 days;\n    }\n\n    /// @inheritdoc Module\n    function VEECODE() public pure override returns (Veecode) {\n        return toVeecode(\"01FPAM\");\n    }\n\n    /// @inheritdoc Module\n    function TYPE() public pure override returns (Type) {\n        return Type.Auction;\n    }\n\n    /// @inheritdoc Auction\n    function auctionType() external pure override returns (AuctionType) {\n        return AuctionType.Atomic;\n    }\n\n    // ========== AUCTION ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The start and duration of the lot have been validated\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The price is zero\n    ///             - The max payout percent is greater than 100% or less than 1%\n    function _auction(uint96 lotId_, Lot memory lot_, bytes memory params_) internal override {\n        // Decode the auction params\n        FixedPriceParams memory auctionParams = abi.decode(params_, (FixedPriceParams));\n\n        // Validate the price is not zero\n        if (auctionParams.price == 0) revert Auction_InvalidParams();\n\n        // Validate the max payout percent is between 1% and 100%\n        if (\n            auctionParams.maxPayoutPercent < 1e3\n                || auctionParams.maxPayoutPercent > _ONE_HUNDRED_PERCENT\n        ) revert Auction_InvalidParams();\n\n        // Calculate the max payout\n        uint96 maxPayout = uint96(\n            Math.mulDivDown(lot_.capacity, auctionParams.maxPayoutPercent, _ONE_HUNDRED_PERCENT)\n        );\n        // If capacity in quote, convert max payout to base token using the provided price\n        if (lot_.capacityInQuote) {\n            maxPayout = uint96(\n                Math.mulDivDown(maxPayout, 10 ** lot_.baseTokenDecimals, auctionParams.price)\n            );\n        }\n\n        // Store the auction data\n        AuctionData storage data = auctionData[lotId_];\n        data.price = auctionParams.price;\n        data.maxPayout = maxPayout;\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction has not concluded\n    function _cancelAuction(uint96 lotId_) internal pure override {}\n\n    // ========== PURCHASE ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///\n    ///             This function reverts if:\n    ///             - The payout is less than the minAmountOut specified by the purchaser\n    ///             - The payout is greater than the max payout\n    function _purchase(\n        uint96 lotId_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal view override returns (uint96 payout, bytes memory) {\n        // Decode the auction data into the min amount out\n        uint96 minAmountOut = abi.decode(auctionData_, (uint96));\n\n        // Calculate the amount of the base token to purchase\n        payout = uint96(\n            Math.mulDivDown(\n                amount_, 10 ** lotData[lotId_].baseTokenDecimals, auctionData[lotId_].price\n            )\n        );\n\n        // Validate the payout is greater than or equal to the minimum amount out\n        if (payout < minAmountOut) revert Auction_InsufficientPayout();\n\n        // Validate the payout is less than the max payout\n        if (payout > auctionData[lotId_].maxPayout) revert Auction_PayoutGreaterThanMax();\n\n        return (payout, bytes(\"\"));\n    }\n\n    // ========== NOT IMPLEMENTED ========== //\n\n    function _bid(\n        uint96,\n        address,\n        address,\n        uint96,\n        bytes calldata\n    ) internal pure override returns (uint64) {\n        revert Auction_NotImplemented();\n    }\n\n    function _refundBid(uint96, uint64, address) internal pure override returns (uint96) {\n        revert Auction_NotImplemented();\n    }\n\n    function _claimBids(\n        uint96,\n        uint64[] calldata\n    ) internal pure override returns (BidClaim[] memory, bytes memory) {\n        revert Auction_NotImplemented();\n    }\n\n    function _settle(uint96) internal pure override returns (Settlement memory, bytes memory) {\n        revert Auction_NotImplemented();\n    }\n\n    function _claimProceeds(uint96) internal pure override returns (uint96, uint96, uint96) {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotSettled(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotNotSettled(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfLotProceedsClaimed(uint96) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfBidInvalid(uint96, uint64) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfNotBidOwner(uint96, uint64, address) internal pure override {\n        revert Auction_NotImplemented();\n    }\n\n    function _revertIfBidClaimed(uint96, uint64) internal pure override {\n        revert Auction_NotImplemented();\n    }\n}"
    },
    {
      "filename": "moonraker/src/lib/MaxPriorityQueue.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nstruct Bid {\n    uint96 amountIn;\n    uint96 minAmountOut;\n}\n\nstruct Queue {\n    ///@notice array backing priority queue\n    uint64[] bidIdList;\n    ///@notice total number of bids in queue\n    uint64 numBids;\n    //@notice map bid ids to bids\n    mapping(uint64 => Bid) idToBidMap;\n}\n\n/// @notice a max priority queue implementation on a binary heap, based off https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n/// @notice adapted from FrankieIsLost's min priority queue implementation at https://github.com/FrankieIsLost/smart-batched-auction/blob/master/contracts/libraries/MinPriorityQueue.sol\n/// @author FrankieIsLost\n/// @author Oighty (edits)\n/// Bids in descending order\n/// @dev    Important assumptions:\n///         - The queue assumes that the bid ids are unique. Behaviour will be unexpected if this is not the case.\nlibrary MaxPriorityQueue {\n    ///@notice initialize must be called before using queue.\n    function initialize(Queue storage self) public {\n        self.bidIdList.push(0);\n    }\n\n    function isEmpty(Queue storage self) public view returns (bool) {\n        return self.numBids == 0;\n    }\n\n    function getNumBids(Queue storage self) public view returns (uint256) {\n        return self.numBids;\n    }\n\n    ///@notice view max bid\n    function getMax(Queue storage self) public view returns (Bid storage) {\n        require(!isEmpty(self), \"nothing to return\");\n        uint64 maxId = self.bidIdList[1];\n        return self.idToBidMap[maxId];\n    }\n\n    function getMaxId(Queue storage self) public view returns (uint64) {\n        require(!isEmpty(self), \"nothing to return\");\n        return self.bidIdList[1];\n    }\n\n    ///@notice move bid up heap\n    function _swim(Queue storage self, uint64 k) private {\n        while (k > 1 && _isLess(self, k / 2, k)) {\n            _exchange(self, k, k / 2);\n            k = k / 2;\n        }\n    }\n\n    ///@notice move bid down heap\n    function _sink(Queue storage self, uint64 k) private {\n        while (2 * k <= self.numBids) {\n            uint64 j = 2 * k;\n            if (j < self.numBids && _isLess(self, j, j + 1)) {\n                j++;\n            }\n            if (!_isLess(self, k, j)) {\n                break;\n            }\n            _exchange(self, k, j);\n            k = j;\n        }\n    }\n\n    ///@notice insert bid in heap\n    function insert(\n        Queue storage self,\n        uint64 bidId,\n        uint96 amountIn,\n        uint96 minAmountOut\n    ) public {\n        // Prevents infinite price\n        if (minAmountOut == 0) revert(\"minAmountOut cannot be 0\");\n\n        _insert(self, bidId, Bid(amountIn, minAmountOut));\n    }\n\n    ///@notice insert bid in heap\n    function _insert(Queue storage self, uint64 bidId, Bid memory bid) private {\n        self.bidIdList.push(bidId);\n        self.idToBidMap[bidId] = bid;\n        self.numBids += 1;\n        _swim(self, self.numBids);\n    }\n\n    ///@notice delete max bid from heap and return\n    function delMax(Queue storage self) public returns (Bid memory) {\n        require(!isEmpty(self), \"nothing to delete\");\n        uint64 bidId = self.bidIdList[1];\n        Bid memory max = self.idToBidMap[bidId];\n        _exchange(self, 1, self.numBids--);\n        self.bidIdList.pop();\n        delete self.idToBidMap[bidId];\n        _sink(self, 1);\n        return max;\n    }\n\n    ///@notice helper function to determine ordering. When two bids have the same price, give priority\n    ///to the lower bid ID (inserted earlier)\n    function _isLess(Queue storage self, uint256 i, uint256 j) private view returns (bool) {\n        uint64 iId = self.bidIdList[i];\n        uint64 jId = self.bidIdList[j];\n        Bid memory bidI = self.idToBidMap[iId];\n        Bid memory bidJ = self.idToBidMap[jId];\n        uint256 relI = uint256(bidI.amountIn) * uint256(bidJ.minAmountOut);\n        uint256 relJ = uint256(bidJ.amountIn) * uint256(bidI.minAmountOut);\n        if (relI == relJ) {\n            return iId > jId;\n        }\n        return relI < relJ;\n    }\n\n    ///@notice helper function to exchange to bids in the heap\n    function _exchange(Queue storage self, uint256 i, uint256 j) private {\n        uint64 tempId = self.bidIdList[i];\n        self.bidIdList[i] = self.bidIdList[j];\n        self.bidIdList[j] = tempId;\n    }\n}"
    }
  ]
}