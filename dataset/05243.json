{
  "Title": "[M-10] Unwhitelisting does not clear _arbitrageProfits, so re-whitelisting may result in an unfair distribution of liquidity rewards",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/aab6bbc6fe49d4dd37becc7bbd0c847ec4a7c1e6/src/dao/DAO.sol#L157-L164> \n\n<https://github.com/code-423n4/2024-01-salty/blob/aab6bbc6fe49d4dd37becc7bbd0c847ec4a7c1e6/src/pools/PoolStats.sol#L51-L55>\n\nWhen a pool that has been excluded from the whitelist is added again, it can receive liquidity rewards based on the previous `_arbitrageProfits`.\n\n### Proof of Concept\n\nWhen unwhitelisting, `_arbitrageProfits` is not cleared. When added to the whitelist again, rewards can be distributed unfairly due to the remaining `_arbitrageProfits`.\n\nLet's assume there are A/WETH, A/WBTC, B/WETH, B/WBTC, WETH/WBTC pools. A swap occurred in each of the A/WETH, B/WETH pools, generating 1 ether of arbitrage profit. If the liquidity rewards are settled at this time, each pool can receive liquidity rewards at a ratio of A/WETH: A/WBTC: B/WETH: B/WBTC: WETH/WBTC = 1: 1: 1: 1: 2. This is because they can take as much as the proportion of profits generated in each pool.\n\n```solidity\nfunction _calculateArbitrageProfits( bytes32[] memory poolIDs, uint256[] memory _calculatedProfits ) internal view\n{\n    for( uint256 i = 0; i < poolIDs.length; i++ )\n    {\n        // references poolID(arbToken2, arbToken3) which defines the arbitage path of WETH->arbToken2->arbToken3->WETH\n        bytes32 poolID = poolIDs[i];\n\n        // Split the arbitrage profit between all the pools that contributed to generating the arbitrage for the referenced pool.\n@>      uint256 arbitrageProfit = _arbitrageProfits[poolID] / 3;\n        if ( arbitrageProfit > 0 )\n        {\n            ArbitrageIndicies memory indicies = _arbitrageIndicies[poolID];\n\n            if ( indicies.index1 != INVALID_POOL_ID )\n                _calculatedProfits[indicies.index1] += arbitrageProfit;\n\n            if ( indicies.index2 != INVALID_POOL_ID )\n                _calculatedProfits[indicies.index2] += arbitrageProfit;\n\n            if ( indicies.index3 != INVALID_POOL_ID )\n                _calculatedProfits[indicies.index3] += arbitrageProfit;\n        }\n    }\n}\n\nfunction profitsForWhitelistedPools() external view returns (uint256[] memory _calculatedProfits)\n{\n@>  bytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n    _calculatedProfits = new uint256[](poolIDs.length);\n@>  _calculateArbitrageProfits( poolIDs, _calculatedProfits );\n}\n```\n\nSuppose you unwhitelist B tokens without settling rewards. The B/WETH and B/WBTC pools will be unwhitelisted. Since they are not included in the whitelist, they cannot be involved in reward settlements, so even if the someone calls `performUpkeep` , their `_arbitrageProfits` remain the same.\n\n```solidity\nfunction clearProfitsForPools() external\n{\n    require(msg.sender == address(exchangeConfig.upkeep()), \"PoolStats.clearProfitsForPools is only callable from the Upkeep contract\" );\n\n@>  bytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n    for( uint256 i = 0; i < poolIDs.length; i++ )\n        _arbitrageProfits[ poolIDs[i] ] = 0;\n}\n```\n\nTime has passed and B token is added to the whitelist again, so that the B/WETH, B/WBTC pools are registered on the whitelist. Since the past `_arbitrageProfits` were not cleared, 1 ether remains in B/WETH pool's `_arbitrageProfits`. The rewards for the other pools have already been settled and `_arbitrageProfits` has been reset.\n\nAfter that, the A/WBTC pool makes new arbitrage profit of 0.1 ether. If the reward is settled in this state, they will receive rewards at a ratio of A/WETH: A/WBTC: B/WETH: B/WBTC: WETH/WBTC = 1: 1: 10: 10: 11.\n\nThis is the PoC. You can add it to the DAO.t.sol file and test it.\n\n<details>\n\n```solidity\nfunction testPoCArbitrageProfitsNotCleared() public\n{\n\tvm.prank(DEPLOYER);\n\tsalt.approve(address(liquidityRewardsEmitter), type(uint256).max);\n\t\n\tIERC20 token1 = new TestERC20(\"TEST\", 18);\n\tIERC20 token2 = new TestERC20(\"TEST\", 18);\n\t\n\ttoken1.transfer(DEPLOYER, 1000000 ether);\n\ttoken2.transfer(DEPLOYER, 1000000 ether);\n\ttoken1.transfer(alice, 1000000 ether);\n\ttoken2.transfer(alice, 1000000 ether);\n\ttoken1.transfer(bob, 1000000 ether);\n\ttoken2.transfer(bob, 1000000 ether);\n\t\n\t// --- add whitelist ---\n\t\n\tvm.startPrank(alice);\n\tstaking.stakeSALT( 1000000 ether );\n\t\n\tsalt.transfer( address(dao), 2000000 ether );\n\t\n\tuint256 ballotId = proposals.proposeTokenWhitelisting( token1, \"\", \"\" );\n\t_voteForAndFinalizeBallot(ballotId, Vote.YES);\n\t\n\tballotId = proposals.proposeTokenWhitelisting( token2, \"\", \"\" );\n\t_voteForAndFinalizeBallot(ballotId, Vote.YES);\n\tvm.stopPrank();\n\t\n\t// --- Add liquidity ---\n\tvm.startPrank(DEPLOYER);\n\ttoken1.approve(address(collateralAndLiquidity), type(uint256).max);\n\ttoken2.approve(address(collateralAndLiquidity), type(uint256).max);\n\tweth.approve(address(collateralAndLiquidity), type(uint256).max);\n\twbtc.approve(address(collateralAndLiquidity), type(uint256).max);\n\t// Adds token1/WETH, token1/WBTC liquidity\n\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare(token1, weth, 1000 ether, 10 ether, 0, block.timestamp, false);\n\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare(token1, wbtc, 1000 ether, 10 * 10**8, 0, block.timestamp, false);\n\t// Adds token2/WETH, token2/WBTC liquidity\n\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare(token2, weth, 1000 ether, 10 ether, 0, block.timestamp, false);\n\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare(token2, wbtc, 1000 ether, 10 * 10**8, 0, block.timestamp, false);\n\t// Adds WETH/WBTC liquidity\n\tcollateralAndLiquidity.depositCollateralAndIncreaseShare(1000 * 10**8, 1000 ether, 0, block.timestamp, false);\n\t\n\tvm.stopPrank();\n\t\n\t\n\t\t// --- arbitrage profit ---\n\tvm.startPrank(bob);\n\ttoken1.approve(address(pools), type(uint256).max);\n\ttoken2.approve(address(pools), type(uint256).max);\n\tpools.depositSwapWithdraw(token1, wbtc, 1 ether, 0, block.timestamp);\n\tpools.depositSwapWithdraw(token2, wbtc, 1 ether, 0, block.timestamp);\n\tvm.stopPrank();\n\t\n\tuint256 token2_wbtc_index;\n\tuint256 token2_weth_index;\n\t\n\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\t\n\tfor(uint256 i = 0; i < poolIDs.length; i ++){\n\t\tif(poolIDs[i] == PoolUtils._poolID(token2, wbtc)){\n\t\t\ttoken2_wbtc_index = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif(poolIDs[i] == PoolUtils._poolID(token2, weth)){\n\t\t\ttoken2_weth_index = i;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tassertTrue(token2_wbtc_index != 0 && token2_weth_index != 0, \"wrong index\");\n\t\n\tuint256[] memory old_profits = pools.profitsForWhitelistedPools();\n\t\n\t// --- unwhitelist pool ---\n\t\n\tvm.startPrank(alice);\n\tballotId = proposals.proposeTokenUnwhitelisting( token2, \"\", \"\" );\n\t_voteForAndFinalizeBallot(ballotId, Vote.YES);\n\tvm.stopPrank();\n\t\n\t// Check for the effects of the vote\n\tassertFalse( poolsConfig.tokenHasBeenWhitelisted(token2, wbtc, weth), \"Token should not be whitelisted\" );\n\t\n\t// user calls upkeep, the old reward cleared (but token2's reward is not cleared)\n\tvm.prank(address(upkeep));\n\tpools.clearProfitsForPools();\n\t\n\t\n\t// --- re-whitelist ---\n\t\n\tvm.startPrank(alice);\n\tballotId = proposals.proposeTokenWhitelisting( token2, \"\", \"\" );\n\t_voteForAndFinalizeBallot(ballotId, Vote.YES);\n\tvm.stopPrank();\n\t\n\tpoolIDs = poolsConfig.whitelistedPools();\n\t\n\tuint256 new_token2_wbtc_index;\n\tuint256 new_token2_weth_index;\n\t\n\tfor(uint256 i = 0; i < poolIDs.length; i ++){\n\t\tif(poolIDs[i] == PoolUtils._poolID(token2, wbtc)){\n\t\t\tnew_token2_wbtc_index = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif(poolIDs[i] == PoolUtils._poolID(token2, weth)){\n\t\t\tnew_token2_weth_index = i;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tassertTrue(new_token2_wbtc_index != 0 && new_token2_weth_index != 0, \"wrong index\");\n\t\n\t// --- old and new reward for token2 pool are same ---\n\tuint256[] memory new_profits = pools.profitsForWhitelistedPools();\n\t\n\tassertEq(old_profits[token2_wbtc_index], new_profits[new_token2_wbtc_index], \"old _arbitrageProfits remain\");\n\tassertEq(old_profits[token2_weth_index], new_profits[new_token2_weth_index], \"old _arbitrageProfits remain\");\n\n}\n```\n</details>\n\n### Recommended Mitigation Steps\n\nBefore finalizing the unwhitelist ballot, user should call `performUpkeep` first to force the rewards to be settled. Check if `_arbitrageProfits` is cleared.\n\n```diff\nfunction _executeApproval( Ballot memory ballot ) internal\n{\n    if ( ballot.ballotType == BallotType.UNWHITELIST_TOKEN )\n    {\n+       require(pools._arbitrageProfits(poolId_wbtc) == 0, \"not cleared yet\");\n+       require(pools._arbitrageProfits(poolId_weth) == 0, \"not cleared yet\");\n        // All tokens are paired with both WBTC and WETH so unwhitelist those pools\n        poolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.wbtc() );\n        poolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.weth() );\n\n        emit UnwhitelistToken(IERC20(ballot.address1));\n    }\n    ...\n}\n\n```\n\n**[othernet-global (Salty.IO) disputed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/752#issuecomment-1937955176):**\n > It is acceptable that an unwhitelisted pool will retain some rewards after being whitelisted again - as the period in which they were unwhitelisted they did not receive rewards that were owed to them.  As the frequency of performUpkeep is sufficiently high, this behavior is acceptable.\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IAccessManager.sol\";\nimport \"./interfaces/ICalledContract.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\nimport \"./Parameters.sol\";\nimport \"../Upkeep.sol\";\n\n\n// Allows users to propose and vote on various governance actions such as changing parameters, whitelisting/unwhitelisting tokens, sending tokens, calling other contracts, and updating the website.\n// It handles proposing ballots, tracking votes, enforcing voting requirements, and executing approved proposals.\ncontract DAO is IDAO, Parameters, ReentrancyGuard\n    {\n\tevent BallotFinalized(uint256 indexed ballotID, Vote winningVote);\n    event SetContract(string indexed ballotName, address indexed contractAddress);\n    event SetWebsiteURL(string newURL);\n    event WhitelistToken(IERC20 indexed token);\n    event UnwhitelistToken(IERC20 indexed token);\n    event GeoExclusionUpdated(string country, bool excluded, uint256 geoVersion);\n    event ArbitrageProfitsWithdrawn(address indexed upkeepContract, IERC20 indexed weth, uint256 withdrawnAmount);\n    event SaltSent(address indexed to, uint256 amount);\n    event ContractCalled(address indexed contractAddress, uint256 indexed intArg);\n    event TeamRewardsTransferred(uint256 teamAmount);\n\n    event POLFormed(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event POLProcessed(uint256 claimedSALT);\n    event POLWithdrawn(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 withdrawnA, uint256 withdrawnB);\n\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n\n\tIPools immutable public pools;\n\tIProposals immutable public proposals;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIStakingConfig immutable public stakingConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tIStableConfig immutable public stableConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tIRewardsEmitter immutable public liquidityRewardsEmitter;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tILiquidizer immutable public liquidizer;\n\n\tISalt immutable public salt;\n    IUSDS immutable public usds;\n\tIERC20 immutable public dai;\n\n\n\t// The default IPFS URL for the website content (can be changed with a setWebsiteURL proposal)\n\tstring public websiteURL;\n\n\t// Countries that have been excluded from access to the DEX (used by AccessManager.sol)\n\t// Keys as ISO 3166 Alpha-2 Codes\n\tmapping(string=>bool) public excludedCountries;\n\n\n    constructor( IPools _pools, IProposals _proposals, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IRewardsConfig _rewardsConfig, IStableConfig _stableConfig, IDAOConfig _daoConfig, IPriceAggregator _priceAggregator, IRewardsEmitter _liquidityRewardsEmitter, ICollateralAndLiquidity _collateralAndLiquidity )\n\t\t{\n\t\tpools = _pools;\n\t\tproposals = _proposals;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tstableConfig = _stableConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tpriceAggregator = _priceAggregator;\n        liquidityRewardsEmitter = _liquidityRewardsEmitter;\n        collateralAndLiquidity = _collateralAndLiquidity;\n \t\tliquidizer = collateralAndLiquidity.liquidizer();\n\n        usds = exchangeConfig.usds();\n        salt = exchangeConfig.salt();\n        dai = exchangeConfig.dai();\n\n\t\t// Gas saving approves for eventually forming Protocol Owned Liquidity\n\t\tsalt.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tusds.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tdai.approve(address(collateralAndLiquidity), type(uint256).max);\n\n\t\t// Excluded by default: United States, Canada, United Kingdom, China, India, Pakistan, Russia, Afghanistan, Cuba, Iran, North Korea, Syria, Venezuela\n\t\t// Note that the DAO can remove any of these exclusions - or open up access completely to the exchange as it sees fit.\n\t\texcludedCountries[\"US\"] = true;\n\t\texcludedCountries[\"CA\"] = true;\n\t\texcludedCountries[\"GB\"] = true;\n\t\texcludedCountries[\"CN\"] = true;\n\t\texcludedCountries[\"IN\"] = true;\n\t\texcludedCountries[\"PK\"] = true;\n\t\texcludedCountries[\"RU\"] = true;\n\t\texcludedCountries[\"AF\"] = true;\n\t\texcludedCountries[\"CU\"] = true;\n\t\texcludedCountries[\"IR\"] = true;\n\t\texcludedCountries[\"KP\"] = true;\n\t\texcludedCountries[\"SY\"] = true;\n\t\texcludedCountries[\"VE\"] = true;\n        }\n\n\n\t// Finalize the vote for a parameter ballot (increase, decrease or no_change) for a given parameter\n\tfunction _finalizeParameterBallot( uint256 ballotID ) internal\n\t\t{\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tVote winningVote = proposals.winningParameterVote(ballotID);\n\n\t\tif ( winningVote == Vote.INCREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), true, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\t\telse if ( winningVote == Vote.DECREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), false, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\n\t\t// Finalize the ballot even if NO_CHANGE won\n\t\tproposals.markBallotAsFinalized(ballotID);\n\n\t\temit BallotFinalized(ballotID, winningVote);\n\t\t}\n\n\n\tfunction _executeSetContract( Ballot memory ballot ) internal\n\t\t{\n\t\tbytes32 nameHash = keccak256(bytes( ballot.ballotName ) );\n\n\t\tif ( nameHash == keccak256(bytes( \"setContract:priceFeed1_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 1, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed2_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 2, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed3_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 3, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:accessManager_confirm\" )) )\n\t\t\texchangeConfig.setAccessManager( IAccessManager(ballot.address1) );\n\n\t\temit SetContract(ballot.ballotName, ballot.address1);\n\t\t}\n\n\n\tfunction _executeSetWebsiteURL( Ballot memory ballot ) internal\n\t\t{\n\t\twebsiteURL = ballot.string1;\n\t\temit SetWebsiteURL(ballot.string1);\n\t\t}\n\n\n\tfunction _executeApproval( Ballot memory ballot ) internal\n\t\t{\n\t\tif ( ballot.ballotType == BallotType.UNWHITELIST_TOKEN )\n\t\t\t{\n\t\t\t// All tokens are paired with both WBTC and WETH so unwhitelist those pools\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\temit UnwhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.SEND_SALT )\n\t\t\t{\n\t\t\t// Make sure the contract has the SALT balance before trying to send it.\n\t\t\t// This should not happen but is here just in case - to prevent approved proposals from reverting on finalization.\n\t\t\tif ( exchangeConfig.salt().balanceOf(address(this)) >= ballot.number1 )\n\t\t\t\t{\n\t\t\t\tIERC20(exchangeConfig.salt()).safeTransfer( ballot.address1, ballot.number1 );\n\n\t\t\t\temit SaltSent(ballot.address1, ballot.number1);\n\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.CALL_CONTRACT )\n\t\t\t{\n\t\t\tICalledContract(ballot.address1).callFromDAO( ballot.number1 );\n\n\t\t\temit ContractCalled(ballot.address1, ballot.number1);\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.INCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = false;\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, false, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.EXCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = true;\n\n\t\t\t// If the AccessManager doesn't implement excludedCountriesUpdated, this will revert and countries will not be able to be excluded until the AccessManager is working properly.\n\t\t\texchangeConfig.accessManager().excludedCountriesUpdated();\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, true, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\t// Once an initial setContract proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_CONTRACT )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_CONTRACT, ballot.address1, \"\", ballot.description );\n\n\t\t// Once an initial setWebsiteURL proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_WEBSITE_URL )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_WEBSITE_URL, address(0), ballot.string1, ballot.description );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_CONTRACT )\n\t\t\t_executeSetContract( ballot );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_WEBSITE_URL )\n\t\t\t_executeSetWebsiteURL( ballot );\n\t\t}\n\n\n\t// Finalize the vote for an approval ballot (yes or no) for a given proposal\n\tfunction _finalizeApprovalBallot( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\t\t\t_executeApproval( ballot );\n\t\t\t}\n\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize and execute a token whitelisting ballot.\n\t// If the proposal is currently the whitelisting proposal with the most yes votes then the token can be whitelisted.\n\t// Only the top voted whitelisting proposal can be finalized - as whitelisting requires bootstrapping rewards to be sent from the DAO.\n\t// If NO > YES than the proposal is removed immediately (quorum would already have been determined - in canFinalizeBallot as called from finalizeBallot).\n\tfunction _finalizeTokenWhitelisting( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\t// The ballot is approved. Any reversions below will allow the ballot to be attemped to be finalized later - as the ballot won't be finalized on reversion.\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\t\tuint256 bootstrappingRewards = daoConfig.bootstrappingRewards();\n\n\t\t\t// Make sure that the DAO contract holds the required amount of SALT for bootstrappingRewards.\n\t\t\t// Twice the bootstrapping rewards are needed (for both the token/WBTC and token/WETH pools)\n\t\t\tuint256 saltBalance = exchangeConfig.salt().balanceOf( address(this) );\n\t\t\trequire( saltBalance >= bootstrappingRewards * 2, \"Whitelisting is not currently possible due to insufficient bootstrapping rewards\" );\n\n\t\t\t// Fail to whitelist for now if this isn't the whitelisting proposal with the most votes - can try again later.\n\t\t\tuint256 bestWhitelistingBallotID = proposals.tokenWhitelistingBallotWithTheMostVotes();\n\t\t\trequire( bestWhitelistingBallotID == ballotID, \"Only the token whitelisting ballot with the most votes can be finalized\" );\n\n\t\t\t// All tokens are paired with both WBTC and WETH, so whitelist both pairings\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\tbytes32 pool1 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tbytes32 pool2 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\t// Send the initial bootstrappingRewards to promote initial liquidity on these two newly whitelisted pools\n\t\t\tAddedReward[] memory addedRewards = new AddedReward[](2);\n\t\t\taddedRewards[0] = AddedReward( pool1, bootstrappingRewards );\n\t\t\taddedRewards[1] = AddedReward( pool2, bootstrappingRewards );\n\n\t\t\texchangeConfig.salt().approve( address(liquidityRewardsEmitter), bootstrappingRewards * 2 );\n\t\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\n\t\t\temit WhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\t// Mark the ballot as finalized (which will also remove it from the list of open token whitelisting proposals)\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize the vote on a specific ballot.\n\t// Can be called by anyone, but only actually finalizes the ballot if it can be finalized.\n\tfunction finalizeBallot( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\t// Checks that ballot is live, and minimumEndTime and quorum have both been reached\n\t\trequire( proposals.canFinalizeBallot(ballotID), \"The ballot is not yet able to be finalized\" );\n\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\t_finalizeParameterBallot(ballotID);\n\t\telse if ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_finalizeTokenWhitelisting(ballotID);\n\t\telse\n\t\t\t_finalizeApprovalBallot(ballotID);\n\t\t}\n\n\n\t// Withdraw the WETH arbitrage profits deposited in the Pools contract and send them to the caller (the Upkeep contract).\n\tfunction withdrawArbitrageProfits( IERC20 weth ) external returns (uint256 withdrawnAmount)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.withdrawArbitrageProfits is only callable from the Upkeep contract\" );\n\n\t\t// The arbitrage profits are deposited in the Pools contract as WETH and owned by the DAO.\n\t\tuint256 depositedWETH = pools.depositedUserBalance(address(this), weth );\n\t\tif ( depositedWETH == 0 )\n\t\t\treturn 0;\n\n\t\tpools.withdraw( weth, depositedWETH );\n\n\t\t// Check the WETH balance - in case any WETH was accidentally sent here previously\n\t\twithdrawnAmount = weth.balanceOf( address(this) );\n\t\tweth.safeTransfer( msg.sender, withdrawnAmount );\n\n\t\temit ArbitrageProfitsWithdrawn(msg.sender, weth, withdrawnAmount);\n\t\t}\n\n\n\t// Form SALT/USDS or USDS/DAI Protocol Owned Liquidity using the given amount of specified tokens.\n\t// Assumes that the tokens have already been transferred to this contract.\n\tfunction formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountA, uint256 amountB ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.formPOL is only callable from the Upkeep contract\" );\n\n\t\t// Use zapping to form the liquidity so that all the specified tokens are used\n\t\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare( tokenA, tokenB, amountA, amountB, 0, block.timestamp, true );\n\n\t\temit POLFormed(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\tfunction processRewardsFromPOL() external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.processRewardsFromPOL is only callable from the Upkeep contract\" );\n\n\t\t// The DAO owns SALT/USDS and USDS/DAI liquidity.\n\t\tbytes32[] memory poolIDs = new bytes32[](2);\n\t\tpoolIDs[0] = PoolUtils._poolID(salt, usds);\n\t\tpoolIDs[1] = PoolUtils._poolID(usds, dai);\n\n\t\tuint256 claimedSALT = collateralAndLiquidity.claimAllRewards(poolIDs);\n\t\tif ( claimedSALT == 0 )\n\t\t\treturn;\n\n\t\t// Send 10% of the rewards to the initial team\n\t\tuint256 amountToSendToTeam = claimedSALT / 10;\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), amountToSendToTeam );\n\t\temit TeamRewardsTransferred(amountToSendToTeam);\n\n\t\tuint256 remainingSALT = claimedSALT - amountToSendToTeam;\n\n\t\t// Burn a default 50% of the remaining SALT that was just claimed - the rest of the SALT stays in the DAO contract.\n\t\tuint256 saltToBurn = ( remainingSALT * daoConfig.percentPolRewardsBurned() ) / 100;\n\n\t\tsalt.safeTransfer( address(salt), saltToBurn );\n\t\tsalt.burnTokensInContract();\n\n\t\temit POLProcessed(claimedSALT);\n\t\t}\n\n\n\t// Withdraws the specified amount of the Protocol Owned Liquidity from the DAO and sends the underlying tokens to the Liquidizer to be burned as USDS as needed.\n\t// Called when the amount of recovered USDS from liquidating a user's WBTC/WETH collateral is insufficient to cover burning the USDS that they had borrowed.\n\t// Only callable from the Liquidizer contract.\n\tfunction withdrawPOL( IERC20 tokenA, IERC20 tokenB, uint256 percentToLiquidate ) external\n\t\t{\n\t\trequire(msg.sender == address(liquidizer), \"DAO.withdrawProtocolOwnedLiquidity is only callable from the Liquidizer contract\" );\n\n\t\tbytes32 poolID = PoolUtils._poolID(tokenA, tokenB);\n\t\tuint256 liquidityHeld = collateralAndLiquidity.userShareForPool( address(this), poolID );\n\t\tif ( liquidityHeld == 0 )\n\t\t\treturn;\n\n\t\tuint256 liquidityToWithdraw = (liquidityHeld * percentToLiquidate) / 100;\n\n\t\t// Withdraw the specified Protocol Owned Liquidity\n\t\t(uint256 reclaimedA, uint256 reclaimedB) = collateralAndLiquidity.withdrawLiquidityAndClaim(tokenA, tokenB, liquidityToWithdraw, 0, 0, block.timestamp );\n\n\t\t// Send the withdrawn tokens to the Liquidizer so that the tokens can be swapped to USDS and burned as needed.\n\t\ttokenA.safeTransfer( address(liquidizer), reclaimedA );\n\t\ttokenB.safeTransfer( address(liquidizer), reclaimedB );\n\n\t\temit POLWithdrawn(tokenA, tokenB, reclaimedA, reclaimedB);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction countryIsExcluded( string calldata country ) external view returns (bool)\n\t\t{\n\t\treturn excludedCountries[country];\n\t\t}\n\t}"
    },
    {
      "filename": "src/pools/PoolStats.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IPoolsConfig.sol\";\nimport \"./interfaces/IPoolStats.sol\";\nimport \"./PoolUtils.sol\";\n\n\n// Keeps track of the arbitrage profits generated by pools (for rewards distribution proportional to the profits generated per pool).\nabstract contract PoolStats is IPoolStats\n\t{\n\tuint64 constant INVALID_POOL_ID = type(uint64).max;\n\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIERC20 immutable public _weth;\n\n\t// poolID(arbToken2, arbToken3) => arbitrage profits contributed since the last performUpkeep\n\tmapping(bytes32=>uint256) public _arbitrageProfits;\n\n\t// Maps poolID(arbToken2, arbToken3) => the indicies (within the whitelistedPools array) of the pools involved in WETH->arbToken2->arbToken3->WETH\n\tmapping(bytes32=>ArbitrageIndicies) public _arbitrageIndicies;\n\n\n    constructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig )\n    \t{\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\n\t\t_weth = exchangeConfig.weth();\n    \t}\n\n\n\t// Record that arbitrageProfit was generated and the a specific arbitrage path generated it (which is defined by the middle two tokens in WETH->arbToken2->arbToken3->WETH)\n\tfunction _updateProfitsFromArbitrage( IERC20 arbToken2, IERC20 arbToken3, uint256 arbitrageProfit ) internal\n\t\t{\n\t\t// Though three pools contributed to the arbitrage we can record just the middle one as we know the input and output token will be WETH\n\t\tbytes32 poolID = PoolUtils._poolID( arbToken2, arbToken3 );\n\n\t\t_arbitrageProfits[poolID] += arbitrageProfit;\n\t\t}\n\n\n\t// Called at the end of Upkeep.performUpkeep to reset the arbitrage stats for the pools\n\tfunction clearProfitsForPools() external\n\t\t{\n\t\trequire(msg.sender == address(exchangeConfig.upkeep()), \"PoolStats.clearProfitsForPools is only callable from the Upkeep contract\" );\n\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t_arbitrageProfits[ poolIDs[i] ] = 0;\n\t\t}\n\n\n\t// The index of pool tokenA/tokenB within the whitelistedPools array.\n\t// Should always find a value as only whitelisted pools are used in the arbitrage path.\n\t// Returns uint64.max in the event of failed lookup\n\tfunction _poolIndex( IERC20 tokenA, IERC20 tokenB, bytes32[] memory poolIDs ) internal pure returns (uint64 index)\n\t\t{\n\t\tbytes32 poolID = PoolUtils._poolID( tokenA, tokenB );\n\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tif (poolID == poolIDs[i])\n\t\t\t\treturn uint64(i);\n\t\t\t}\n\n\t\treturn INVALID_POOL_ID;\n\t\t}\n\n\n\t// Traverse the current whitelisted poolIDs and update the indicies of each pool that would contribute to arbitrage for it.\n\t// Maps poolID(arbToken2, arbToken3) => the indicies (within the whitelistedPools array) of the pools involved in WETH->arbToken2->arbToken3->WETH arbitrage.\n\tfunction updateArbitrageIndicies() public\n\t\t{\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\t\t\t(IERC20 arbToken2, IERC20 arbToken3) = poolsConfig.underlyingTokenPair(poolID);\n\n\t\t\t// The middle two tokens can never be WETH in a valid arbitrage path as the path is WETH->arbToken2->arbToken3->WETH.\n\t\t\tif ( (arbToken2 != _weth) && (arbToken3 != _weth) )\n\t\t\t\t{\n\t\t\t\tuint64 poolIndex1 = _poolIndex( _weth, arbToken2, poolIDs );\n\t\t\t\tuint64 poolIndex2 = _poolIndex( arbToken2, arbToken3, poolIDs );\n\t\t\t\tuint64 poolIndex3 = _poolIndex( arbToken3, _weth, poolIDs );\n\n\t\t\t\t// Check if the indicies in storage have the correct values - and if not then update them\n\t\t\t\tArbitrageIndicies memory indicies = _arbitrageIndicies[poolID];\n\t\t\t\tif ( ( poolIndex1 != indicies.index1 ) || ( poolIndex2 != indicies.index2 ) || ( poolIndex3 != indicies.index3 ) )\n\t\t\t\t\t_arbitrageIndicies[poolID] = ArbitrageIndicies(poolIndex1, poolIndex2, poolIndex3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t// Examine the arbitrage that has been generated since the last Upkeep.performUpkeep call and credit the pools that have contributed towards it.\n\t// The calculated sums for each pool will then be used to proportionally distribute SALT rewards to each of the contributing pools.\n\tfunction _calculateArbitrageProfits( bytes32[] memory poolIDs, uint256[] memory _calculatedProfits ) internal view\n\t\t{\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\t// references poolID(arbToken2, arbToken3) which defines the arbitage path of WETH->arbToken2->arbToken3->WETH\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\t// Split the arbitrage profit between all the pools that contributed to generating the arbitrage for the referenced pool.\n\t\t\tuint256 arbitrageProfit = _arbitrageProfits[poolID] / 3;\n\t\t\tif ( arbitrageProfit > 0 )\n\t\t\t\t{\n\t\t\t\tArbitrageIndicies memory indicies = _arbitrageIndicies[poolID];\n\n\t\t\t\tif ( indicies.index1 != INVALID_POOL_ID )\n\t\t\t\t\t_calculatedProfits[indicies.index1] += arbitrageProfit;\n\n\t\t\t\tif ( indicies.index2 != INVALID_POOL_ID )\n\t\t\t\t\t_calculatedProfits[indicies.index2] += arbitrageProfit;\n\n\t\t\t\tif ( indicies.index3 != INVALID_POOL_ID )\n\t\t\t\t\t_calculatedProfits[indicies.index3] += arbitrageProfit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Look at the arbitrage that has been generated since the last performUpkeep and determine how much each of the pools contributed to those generated profits.\n\t// Returns the profits for all of the current whitelisted pools\n\tfunction profitsForWhitelistedPools() external view returns (uint256[] memory _calculatedProfits)\n\t\t{\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n\t\t_calculatedProfits = new uint256[](poolIDs.length);\n\t\t_calculateArbitrageProfits( poolIDs, _calculatedProfits );\n\t\t}\n\n\n\tfunction arbitrageIndicies(bytes32 poolID) external view returns (ArbitrageIndicies memory)\n\t\t{\n\t\treturn _arbitrageIndicies[poolID];\n\t\t}\n\t}"
    }
  ]
}