{
  "Title": " Transfer Limit of UNI Tokens May Lead to a DoS and Token Loss Risk",
  "Content": "#  Transfer Limit of UNI Tokens May Lead to a DoS and Token Loss Risk\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L193-L194\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L193-L194</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L47-L52\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L47-L52</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L191-L192\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L191-L192</a>\n\n\n## Summary\nUsers who accumulate more than 2^96 UNI tokens may lose their tokens because transfers above that will always revert.\n\n## Vulnerability Details\nThe UNI token contract imposes a transfer limit, restricting the maximum amount of tokens that can be transferred in a single transaction to 2^96 UNI tokens. Any transfer exceeding this threshold will trigger a transaction revert. The contract relies on the `balanceOf` function to verify the sender's token balance before proceeding with a transfer.\n\n```\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n```\nsuch a transfer will always revert for balances above 2^96 UNI tokens\n\nhttps://github.com/d-xo/weird-erc20#revert-on-large-approvals--transfers\n\n\n## Impact\nUsers who accumulate more than 2^96 UNI tokens may lose their tokens due to a DOS revert when attempting to withdraw their token balance. \n\n\n## Tools Used\nhttps://github.com/d-xo/weird-erc20#revert-on-large-approvals--transfers\n## Recommendations\nContracts should always check the amount of UNI being  transferred before processing the transaction. \n\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessWithdraw } from \"./GMXProcessWithdraw.sol\";\n\n/**\n  * @title GMXWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXWithdraw {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event WithdrawCreated(address indexed user, uint256 shareAmt);\n  event WithdrawCompleted(\n    address indexed user,\n    address token,\n    uint256 tokenAmt\n  );\n  event WithdrawCancelled(address indexed user);\n  event WithdrawFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function withdraw(\n    GMXTypes.Store storage self,\n    GMXTypes.WithdrawParams memory wp\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of withdrawers assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    GMXTypes.WithdrawCache memory _wc;\n\n    _wc.user = payable(msg.sender);\n\n    _wc.shareRatio = wp.shareAmt\n      * SAFE_MULTIPLIER\n      / IERC20(address(self.vault)).totalSupply();\n    _wc.lpAmt = _wc.shareRatio\n      * GMXReader.lpAmt(self)\n      / SAFE_MULTIPLIER;\n    _wc.withdrawValue = _wc.lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    _wc.withdrawParams = wp;\n    _wc.healthParams = _hp;\n\n    (\n      uint256 _repayTokenAAmt,\n      uint256 _repayTokenBAmt\n    ) = GMXManager.calcRepay(self, _wc.shareRatio);\n\n    _wc.repayParams.repayTokenAAmt = _repayTokenAAmt;\n    _wc.repayParams.repayTokenBAmt = _repayTokenBAmt;\n\n    self.withdrawCache = _wc;\n\n    GMXChecks.beforeWithdrawChecks(self);\n\n    self.status = GMXTypes.Status.Withdraw;\n\n    self.vault.mintFee();\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If user wants to withdraw LP tokens, only remove liquidity of\n    // LP tokens that are proportionately borrowed to repay debt\n    // If not, we just remove all LP tokens computed in _wc.lpAmt\n    if (wp.token == address(self.lpToken)) {\n      // LP amount to be removed for leverage debt repayment\n      // Multiply LP amt to remove by 2% to account for price differential,\n      // fees on LP removal, slippages to ensure payment of debt is covered\n      // Excess tokenA/B will be returned to the user regardless\n      uint256 _lpAmtToRemove = _wc.lpAmt\n        * (self.leverage - SAFE_MULTIPLIER)\n        / self.leverage\n        * 10200 / 10000;\n\n      _wc.tokensToUser = _wc.lpAmt - _lpAmtToRemove;\n      _wc.lpAmt = _lpAmtToRemove;\n    }\n\n\n    // If delta strategy is Long, remove all in tokenB to make it more\n    // efficent to repay tokenB debt as Long strategy only borrows tokenB\n    if (self.delta == GMXTypes.Delta.Long) {\n      address[] memory _tokenASwapPath = new address[](1);\n      _tokenASwapPath[0] = address(self.lpToken);\n      _rlp.tokenASwapPath = _tokenASwapPath;\n\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenB),\n        address(self.tokenB),\n        wp.slippage\n      );\n    } else {\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenA),\n        address(self.tokenB),\n        wp.slippage\n      );\n    }\n\n    _rlp.lpAmt = _wc.lpAmt;\n    _rlp.executionFee = wp.executionFee;\n\n    _wc.withdrawKey = GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    // Add withdrawKey to store\n    self.withdrawCache = _wc;\n\n    emit WithdrawCreated(\n      _wc.user,\n      _wc.withdrawParams.shareAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessWithdraw.processWithdraw()\n    // to allow try/catch here to catch for any issues such as any token swaps failing or\n    // debt repayment failing, or any checks in afterWithdrawChecks() failing.\n    // If there are any issues, a WithdrawFailed event will be emitted and processWithdrawFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessWithdraw.processWithdraw(self) {\n      // If native token is being withdrawn, we convert wrapped to native\n      if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n        self.WNT.withdraw(self.withdrawCache.tokensToUser);\n        (bool success, ) = self.withdrawCache.user.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n      } else {\n        // Transfer requested withdraw asset to user\n        IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n          self.withdrawCache.user,\n          self.withdrawCache.tokensToUser\n        );\n      }\n\n      // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n      self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n      // Burn user shares\n      self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit WithdrawCompleted(\n        self.withdrawCache.user,\n        self.withdrawCache.withdrawParams.token,\n        self.withdrawCache.tokensToUser\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Withdraw_Failed;\n\n      emit WithdrawFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit WithdrawCancelled(self.withdrawCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n    // Re-borrow assets based on the repaid amount\n    GMXManager.borrow(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // Re-add liquidity using all available tokenA/B in vault\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    // Calculate slippage\n    uint256 _depositValue = GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenA),\n      self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenB),\n      self.tokenB.balanceOf(address(this))\n    );\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _depositValue,\n      slippage\n    );\n    _alp.executionFee = executionFee;\n\n    // Re-add liquidity with all tokenA/tokenB in vault\n    self.withdrawCache.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureLiquidityAdded(self);\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessWithdraw } from \"./GMXProcessWithdraw.sol\";\n\n/**\n  * @title GMXWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXWithdraw {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event WithdrawCreated(address indexed user, uint256 shareAmt);\n  event WithdrawCompleted(\n    address indexed user,\n    address token,\n    uint256 tokenAmt\n  );\n  event WithdrawCancelled(address indexed user);\n  event WithdrawFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function withdraw(\n    GMXTypes.Store storage self,\n    GMXTypes.WithdrawParams memory wp\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of withdrawers assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    GMXTypes.WithdrawCache memory _wc;\n\n    _wc.user = payable(msg.sender);\n\n    _wc.shareRatio = wp.shareAmt\n      * SAFE_MULTIPLIER\n      / IERC20(address(self.vault)).totalSupply();\n    _wc.lpAmt = _wc.shareRatio\n      * GMXReader.lpAmt(self)\n      / SAFE_MULTIPLIER;\n    _wc.withdrawValue = _wc.lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    _wc.withdrawParams = wp;\n    _wc.healthParams = _hp;\n\n    (\n      uint256 _repayTokenAAmt,\n      uint256 _repayTokenBAmt\n    ) = GMXManager.calcRepay(self, _wc.shareRatio);\n\n    _wc.repayParams.repayTokenAAmt = _repayTokenAAmt;\n    _wc.repayParams.repayTokenBAmt = _repayTokenBAmt;\n\n    self.withdrawCache = _wc;\n\n    GMXChecks.beforeWithdrawChecks(self);\n\n    self.status = GMXTypes.Status.Withdraw;\n\n    self.vault.mintFee();\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If user wants to withdraw LP tokens, only remove liquidity of\n    // LP tokens that are proportionately borrowed to repay debt\n    // If not, we just remove all LP tokens computed in _wc.lpAmt\n    if (wp.token == address(self.lpToken)) {\n      // LP amount to be removed for leverage debt repayment\n      // Multiply LP amt to remove by 2% to account for price differential,\n      // fees on LP removal, slippages to ensure payment of debt is covered\n      // Excess tokenA/B will be returned to the user regardless\n      uint256 _lpAmtToRemove = _wc.lpAmt\n        * (self.leverage - SAFE_MULTIPLIER)\n        / self.leverage\n        * 10200 / 10000;\n\n      _wc.tokensToUser = _wc.lpAmt - _lpAmtToRemove;\n      _wc.lpAmt = _lpAmtToRemove;\n    }\n\n\n    // If delta strategy is Long, remove all in tokenB to make it more\n    // efficent to repay tokenB debt as Long strategy only borrows tokenB\n    if (self.delta == GMXTypes.Delta.Long) {\n      address[] memory _tokenASwapPath = new address[](1);\n      _tokenASwapPath[0] = address(self.lpToken);\n      _rlp.tokenASwapPath = _tokenASwapPath;\n\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenB),\n        address(self.tokenB),\n        wp.slippage\n      );\n    } else {\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenA),\n        address(self.tokenB),\n        wp.slippage\n      );\n    }\n\n    _rlp.lpAmt = _wc.lpAmt;\n    _rlp.executionFee = wp.executionFee;\n\n    _wc.withdrawKey = GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    // Add withdrawKey to store\n    self.withdrawCache = _wc;\n\n    emit WithdrawCreated(\n      _wc.user,\n      _wc.withdrawParams.shareAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessWithdraw.processWithdraw()\n    // to allow try/catch here to catch for any issues such as any token swaps failing or\n    // debt repayment failing, or any checks in afterWithdrawChecks() failing.\n    // If there are any issues, a WithdrawFailed event will be emitted and processWithdrawFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessWithdraw.processWithdraw(self) {\n      // If native token is being withdrawn, we convert wrapped to native\n      if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n        self.WNT.withdraw(self.withdrawCache.tokensToUser);\n        (bool success, ) = self.withdrawCache.user.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n      } else {\n        // Transfer requested withdraw asset to user\n        IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n          self.withdrawCache.user,\n          self.withdrawCache.tokensToUser\n        );\n      }\n\n      // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n      self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n      // Burn user shares\n      self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit WithdrawCompleted(\n        self.withdrawCache.user,\n        self.withdrawCache.withdrawParams.token,\n        self.withdrawCache.tokensToUser\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Withdraw_Failed;\n\n      emit WithdrawFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit WithdrawCancelled(self.withdrawCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n    // Re-borrow assets based on the repaid amount\n    GMXManager.borrow(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // Re-add liquidity using all available tokenA/B in vault\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    // Calculate slippage\n    uint256 _depositValue = GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenA),\n      self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenB),\n      self.tokenB.balanceOf(address(this))\n    );\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _depositValue,\n      slippage\n    );\n    _alp.executionFee = executionFee;\n\n    // Re-add liquidity with all tokenA/tokenB in vault\n    self.withdrawCache.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureLiquidityAdded(self);\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    }
  ]
}