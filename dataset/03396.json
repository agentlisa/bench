{
  "Title": "Possible reentrancy",
  "Content": "##### Description\nIn the following function reentrancy can occur:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/CurveV1.sol#L56\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/UniswapV2.sol#L55\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/UniswapV2.sol#L112\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/UniswapV3.sol#L49\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/UniswapV3.sol#L102\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/UniswapV3.sol#L152\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/UniswapV3.sol#L196\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/YearnV2.sol#L75\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/adapters/YearnV2.sol#L126\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/core/WETHGateway.sol#L107\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/core/WETHGateway.sol#L128\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/core/WETHGateway.sol#L159\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/core/WETHGateway.sol#L181\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/pool/PoolService.sol#L242\n##### Recommendation\nWe recommend to add a `nonReentrant` modificator.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/adapters/CurveV1.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {ICurvePool} from \"../integrations/curve/ICurvePool.sol\";\n\nimport {CreditAccount} from \"../credit/CreditAccount.sol\";\nimport {CreditManager} from \"../credit/CreditManager.sol\";\n\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title CurveV1 adapter\ncontract CurveV1Adapter is ICurvePool {\n    using SafeMath for uint256;\n\n    // Default swap contracts - uses for automatic close / liquidation process\n    ICurvePool public curvePool; //\n    ICreditManager public creditManager;\n    ICreditFilter public creditFilter;\n\n    /// @dev Constructor\n    /// @param _creditManager Address Credit manager\n    /// @param _curvePool Address of curve-compatible pool\n    constructor(address _creditManager, address _curvePool) {\n        creditManager = ICreditManager(_creditManager);\n        creditFilter = ICreditFilter(creditManager.creditFilter());\n\n        curvePool = ICurvePool(_curvePool);\n    }\n\n    function coins(uint256 i) external view override returns (address) {\n        return ICurvePool(curvePool).coins(i);\n    }\n\n    /// @dev Exchanges two assets on Curve-compatible pools. Restricted for pool calls only\n    /// @param i Index value for the coin to send\n    /// @param j Index value of the coin to receive\n    /// @param dx Amount of i being exchanged\n    /// @param min_dy Minimum amount of j to receive\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external override {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        address tokenIn = curvePool.coins(uint256(i));\n        address tokenOut = curvePool.coins(uint256(j));\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            address(curvePool),\n            tokenIn\n        ); // T:[CVA-3]\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x3df02124), // \"exchange(int128,int128,uint256,uint256)\",\n            i,\n            j,\n            dx,\n            min_dy\n        ); // T:[CVA-3]\n\n        creditManager.executeOrder(msg.sender, address(curvePool), data); // T:[CVA-3]\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            tokenIn,\n            tokenOut,\n            dx,\n            min_dy\n        ); // T:[CVA-2]\n    }\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function get_dx_underlying(\n        int128 i,\n        int128 j,\n        uint256 dy\n    ) external view override returns (uint256) {\n        return curvePool.get_dx_underlying(i, j, dy);\n    }\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view override returns (uint256) {\n        return curvePool.get_dy_underlying(i, j, dx);\n    }\n\n    function get_dx(\n        int128 i,\n        int128 j,\n        uint256 dy\n    ) external view override returns (uint256) {\n        return curvePool.get_dx(i, j, dy);\n    }\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view override returns (uint256) {\n        return curvePool.get_dy(i, j, dx);\n    }\n\n    function get_virtual_price() external view override returns (uint256) {\n        return curvePool.get_virtual_price();\n    }\n}"
    },
    {
      "filename": "contracts/adapters/UniswapV2.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\n\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {CreditManager} from \"../credit/CreditManager.sol\";\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"hardhat/console.sol\";\nimport \"../integrations/uniswap/IUniswapV2Router02.sol\";\n\n/// @title UniswapV2 Router adapter\ncontract UniswapV2Adapter is IUniswapV2Router02 {\n    ICreditManager public creditManager;\n    ICreditFilter public creditFilter;\n    using SafeMath for uint256;\n    address public swapContract;\n\n    /// @dev Constructor\n    /// @param _creditManager Address Credit manager\n    /// @param _swapContract Address of swap contract\n    constructor(address _creditManager, address _swapContract) {\n        creditManager = ICreditManager(_creditManager);\n        creditFilter = ICreditFilter(creditManager.creditFilter());\n        swapContract = _swapContract;\n    }\n\n    /**\n     * @dev Swap tokens to exact tokens using Uniswap-compatible protocol\n     * - checks that swap contract is allowed\n     * - checks that in/out tokens are in allowed list\n     * - checks that required allowance is enough, if not - set it to MAX_INT\n     * - call swap function on credit account contracts\n     * @param amountOut The amount of output tokens to receive.\n     * @param amountInMax The maximum amount of input tokens that can be required before the transaction reverts.\n     * @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of\n     *        addresses must exist and have liquidity.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * for more information check uniswap documentation: https://uniswap.org/docs/v2/smart-contracts/router02/\n     */\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            path[0]\n        );\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x8803dbee), // \"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)\",\n            amountOut,\n            amountInMax,\n            path,\n            creditAccount,\n            deadline\n        );\n\n        amounts = abi.decode(\n            creditManager.executeOrder(msg.sender, swapContract, data),\n            (uint256[])\n        );\n\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            path[0],\n            path[path.length - 1],\n            amounts[0],\n            amounts[amounts.length - 1]\n        );\n    }\n\n    /**\n     * Swaps exact tokens to tokens on Uniswap compatible protocols\n     * - checks that swap contract is allowed\n     * - checks that in/out tokens are in allowed list\n     * - checks that required allowance is enough, if not - set it to MAX_INT\n     * - call swap function on credit account contracts\n     * @param amountIn The amount of input tokens to send.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of\n     *        addresses must exist and have liquidity.\n     * deadline Unix timestamp after which the transaction will revert.\n     * for more information check uniswap documentation: https://uniswap.org/docs/v2/smart-contracts/router02/\n     */\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            path[0]\n        );\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x38ed1739), // \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",\n            amountIn,\n            amountOutMin,\n            path,\n            creditAccount,\n            deadline\n        );\n\n        amounts = abi.decode(\n            creditManager.executeOrder(msg.sender, swapContract, data),\n            (uint256[])\n        );\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            path[0],\n            path[path.length - 1],\n            amounts[0],\n            amounts[amounts.length - 1]\n        ); // ToDo: CHECK(!)\n    }\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function factory() external view override returns (address) {\n        return IUniswapV2Router02(swapContract).factory();\n    }\n\n    function WETH() external view override returns (address) {\n        return IUniswapV2Router02(swapContract).WETH();\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountA, uint256 amountB) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountToken, uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountA, uint256 amountB) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountToken, uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external view override returns (uint256 amountB) {\n        return\n            IUniswapV2Router02(swapContract).quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external view override returns (uint256 amountOut) {\n        return\n            IUniswapV2Router02(swapContract).getAmountOut(\n                amountIn,\n                reserveIn,\n                reserveOut\n            );\n    }\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external view override returns (uint256 amountIn) {\n        return\n            IUniswapV2Router02(swapContract).getAmountIn(\n                amountOut,\n                reserveIn,\n                reserveOut\n            );\n    }\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        override\n        returns (uint256[] memory amounts)\n    {\n        return IUniswapV2Router02(swapContract).getAmountsOut(amountIn, path);\n    }\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        override\n        returns (uint256[] memory amounts)\n    {\n        return IUniswapV2Router02(swapContract).getAmountsOut(amountOut, path);\n    }\n}"
    },
    {
      "filename": "contracts/adapters/UniswapV2.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\n\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {CreditManager} from \"../credit/CreditManager.sol\";\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"hardhat/console.sol\";\nimport \"../integrations/uniswap/IUniswapV2Router02.sol\";\n\n/// @title UniswapV2 Router adapter\ncontract UniswapV2Adapter is IUniswapV2Router02 {\n    ICreditManager public creditManager;\n    ICreditFilter public creditFilter;\n    using SafeMath for uint256;\n    address public swapContract;\n\n    /// @dev Constructor\n    /// @param _creditManager Address Credit manager\n    /// @param _swapContract Address of swap contract\n    constructor(address _creditManager, address _swapContract) {\n        creditManager = ICreditManager(_creditManager);\n        creditFilter = ICreditFilter(creditManager.creditFilter());\n        swapContract = _swapContract;\n    }\n\n    /**\n     * @dev Swap tokens to exact tokens using Uniswap-compatible protocol\n     * - checks that swap contract is allowed\n     * - checks that in/out tokens are in allowed list\n     * - checks that required allowance is enough, if not - set it to MAX_INT\n     * - call swap function on credit account contracts\n     * @param amountOut The amount of output tokens to receive.\n     * @param amountInMax The maximum amount of input tokens that can be required before the transaction reverts.\n     * @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of\n     *        addresses must exist and have liquidity.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * for more information check uniswap documentation: https://uniswap.org/docs/v2/smart-contracts/router02/\n     */\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            path[0]\n        );\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x8803dbee), // \"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)\",\n            amountOut,\n            amountInMax,\n            path,\n            creditAccount,\n            deadline\n        );\n\n        amounts = abi.decode(\n            creditManager.executeOrder(msg.sender, swapContract, data),\n            (uint256[])\n        );\n\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            path[0],\n            path[path.length - 1],\n            amounts[0],\n            amounts[amounts.length - 1]\n        );\n    }\n\n    /**\n     * Swaps exact tokens to tokens on Uniswap compatible protocols\n     * - checks that swap contract is allowed\n     * - checks that in/out tokens are in allowed list\n     * - checks that required allowance is enough, if not - set it to MAX_INT\n     * - call swap function on credit account contracts\n     * @param amountIn The amount of input tokens to send.\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\n     * @param path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of\n     *        addresses must exist and have liquidity.\n     * deadline Unix timestamp after which the transaction will revert.\n     * for more information check uniswap documentation: https://uniswap.org/docs/v2/smart-contracts/router02/\n     */\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            path[0]\n        );\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x38ed1739), // \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",\n            amountIn,\n            amountOutMin,\n            path,\n            creditAccount,\n            deadline\n        );\n\n        amounts = abi.decode(\n            creditManager.executeOrder(msg.sender, swapContract, data),\n            (uint256[])\n        );\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            path[0],\n            path[path.length - 1],\n            amounts[0],\n            amounts[amounts.length - 1]\n        ); // ToDo: CHECK(!)\n    }\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function factory() external view override returns (address) {\n        return IUniswapV2Router02(swapContract).factory();\n    }\n\n    function WETH() external view override returns (address) {\n        return IUniswapV2Router02(swapContract).WETH();\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountA, uint256 amountB) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 amountToken, uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountA, uint256 amountB) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override returns (uint256 amountToken, uint256 amountETH) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable override returns (uint256[] memory amounts) {\n        revert(Errors.NOT_IMPLEMENTED);\n    }\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external view override returns (uint256 amountB) {\n        return\n            IUniswapV2Router02(swapContract).quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external view override returns (uint256 amountOut) {\n        return\n            IUniswapV2Router02(swapContract).getAmountOut(\n                amountIn,\n                reserveIn,\n                reserveOut\n            );\n    }\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external view override returns (uint256 amountIn) {\n        return\n            IUniswapV2Router02(swapContract).getAmountIn(\n                amountOut,\n                reserveIn,\n                reserveOut\n            );\n    }\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        override\n        returns (uint256[] memory amounts)\n    {\n        return IUniswapV2Router02(swapContract).getAmountsOut(amountIn, path);\n    }\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        override\n        returns (uint256[] memory amounts)\n    {\n        return IUniswapV2Router02(swapContract).getAmountsOut(amountOut, path);\n    }\n}"
    },
    {
      "filename": "contracts/adapters/UniswapV3.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {ISwapRouter} from \"../integrations/uniswap/IUniswapV3.sol\";\nimport {BytesLib} from \"../integrations/uniswap/BytesLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {CreditManager} from \"../credit/CreditManager.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title UniswapV3 Router adapter\ncontract UniswapV3Adapter is ISwapRouter {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    ICreditManager public creditManager;\n    ICreditFilter public creditFilter;\n    address public swapContract;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n\n    /// @dev Constructor\n    /// @param _creditManager Address Credit manager\n    /// @param _swapContract Address of swap contract\n    constructor(address _creditManager, address _swapContract) {\n        creditManager = ICreditManager(_creditManager);\n        creditFilter = ICreditFilter(creditManager.creditFilter());\n        swapContract = _swapContract;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        override\n        returns (uint256 amountOut)\n    {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            params.tokenIn\n        );\n\n        ExactInputSingleParams memory paramsUpdate = params;\n        paramsUpdate.recipient = creditAccount;\n\n        // 0x414bf389 = exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x414bf389), // +\n            paramsUpdate\n        );\n\n        uint256 balanceBefore = IERC20(paramsUpdate.tokenIn).balanceOf(\n            creditAccount\n        );\n\n        // ToDo: Check for partial execution\n        bytes memory result = creditManager.executeOrder(\n            msg.sender,\n            swapContract,\n            data\n        );\n        (amountOut) = abi.decode(result, (uint256));\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            params.tokenIn,\n            params.tokenOut,\n            balanceBefore.sub(\n                IERC20(paramsUpdate.tokenIn).balanceOf(creditAccount)\n            ),\n            amountOut\n        );\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        override\n        returns (uint256 amountOut)\n    {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        (address tokenIn, address tokenOut) = _extractTokens(params.path);\n\n        creditManager.provideCreditAccountAllowance(\n            creditAccount,\n            swapContract,\n            tokenIn\n        );\n\n        ExactInputParams memory paramsUpdate = params;\n        paramsUpdate.recipient = creditAccount;\n\n        // 0xc04b8d59 = exactInput((bytes,address,uint256,uint256,uint256))\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0xc04b8d59), // +\n            paramsUpdate\n        );\n\n        uint256 balanceBefore = IERC20(tokenIn).balanceOf(creditAccount);\n\n        bytes memory result = creditManager.executeOrder(\n            msg.sender,\n            swapContract,\n            data\n        );\n        (amountOut) = abi.decode(result, (uint256));\n\n        creditFilter.checkCollateralChange(\n            creditAccount,\n            tokenIn,\n            tokenOut,\n            balanceBefore.sub(IERC20(tokenIn).balanceOf(creditAccount)),\n            amountOut\n        );\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in"
    }
  ]
}