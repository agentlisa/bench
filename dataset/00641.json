{
  "Title": "M-4: Large amounts of points can be minted virtually without any cost",
  "Content": "# Issue M-4: Large amounts of points can be minted virtually without any cost \n\nSource: https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/187 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nBauer, Dliteofficial, GoSlang, evmboi32, jennifer37, joicygiore, nobody2018, novaman33, vesla0xfa, xiaoming90\n## Summary\n\nLarge amounts of points can be minted virtually without any cost. The points are intended to be used to exchange something of value. A malicious user could abuse this to obtain a large number of points, which could obtain excessive value and create unfairness among other protocol users.\n\n## Vulnerability Detail\n\nWhen depositing stable collateral, the LPs only need to pay for the keeper fee. The keeper fee will be sent to the caller who executed the deposit order.\n\nWhen withdrawing stable collateral, the LPs need to pay for the keeper fee and withdraw fee. However, there is an instance where one does not need to pay for the withdrawal fee. Per the condition at Line 120 below, if the `totalSupply` is zero, this means that it is the final/last withdrawal. In this case, the withdraw fee will not be applicable and remain at zero.\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/StableModule.sol#L96\n\n```solidity\nFile: StableModule.sol\n096:     function executeWithdraw(\n097:         address _account,\n098:         uint64 _executableAtTime,\n099:         FlatcoinStructs.AnnouncedStableWithdraw calldata _announcedWithdraw\n100:     ) external whenNotPaused onlyAuthorizedModule returns (uint256 _amountOut, uint256 _withdrawFee) {\n101:         uint256 withdrawAmount = _announcedWithdraw.withdrawAmount;\n..SNIP..\n112:         _burn(_account, withdrawAmount);\n..SNIP..\n118:         // Check that there is no significant impact on stable token price.\n119:         // This should never happen and means that too much value or not enough value was withdrawn.\n120:         if (totalSupply() > 0) {\n121:             if (\n122:                 stableCollateralPerShareAfter < stableCollateralPerShareBefore - 1e6 ||\n123:                 stableCollateralPerShareAfter > stableCollateralPerShareBefore + 1e6\n124:             ) revert FlatcoinErrors.PriceImpactDuringWithdraw();\n125: \n126:             // Apply the withdraw fee if it's not the final withdrawal.\n127:             _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n128: \n129:             // additionalSkew = 0 because withdrawal was already processed above.\n130:             vault.checkSkewMax({additionalSkew: 0});\n131:         } else {\n132:             // Need to check there are no longs open before allowing full system withdrawal.\n133:             uint256 sizeOpenedTotal = vault.getVaultSummary().globalPositions.sizeOpenedTotal;\n134: \n135:             if (sizeOpenedTotal != 0) revert FlatcoinErrors.MaxSkewReached(sizeOpenedTotal);\n136:             if (stableCollateralPerShareAfter != 1e18) revert FlatcoinErrors.PriceImpactDuringFullWithdraw();\n137:         }\n```\n\nWhen LPs deposit rETH and mint UNIT, the protocol will mint points to the depositor's account as per Line 84 below.\n\nAssume that the vault has been newly deployed on-chain. Bob is the first LP to deposit rETH into the vault. Assume for a period of time (e.g., around 30 minutes), there are no other users depositing into the vault except for Bob.\n\nBob could perform the following actions to mint points for free:\n\n- Bob announces a deposit order to deposit 100e18 rETH. Paid for the keeper fee. (Acting as a LP).\n- Wait 10 seconds for the `minExecutabilityAge` to pass\n- Bob executes the deposit order and mints 100e18 UNIT (Exchange rate 1:1). Protocol also mints 100e18 points to Bob's account. Bob gets back the keeper fee. (Acting as Keeper)\n- Immediately after his `executeDeposit` TX, Bob inserts an \"announce withdraw order\" TX to withdraw all his 100e18 UNIT and pay for the keeper fee.\n- Wait 10 seconds for the `minExecutabilityAge` to pass\n- Bob executes the withdraw order and receives back his initial investment of 100e18 rETH. Since he is the only LP in the protocol, it is considered the final/last withdrawal, and he does not need to pay any withdraw fee. He also got back his keeper fee. (Acting as Keeper)\n\nEach attack requires 20 seconds (10 + 10) to be executed. Bob could rinse and repeat the attack until he was no longer the only LP in the system, where he had to pay for the withdraw fee, which might make this attack unprofitable.\n\nIf Bob is the only LP in the system for 30 minutes, he could gain 9000e18 points (`(30 minutes / 20 seconds) * 100e18` ) for free as Bob could get back his keeper fee and does not incur any withdraw fee. The only thing that Bob needs to pay for is the gas fee, which is extremely cheap on L2 like Base.\n\n```solidity\nFile: StableModule.sol\n61:     function executeDeposit(\n62:         address _account,\n63:         uint64 _executableAtTime,\n64:         FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n65:     ) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n66:         uint256 depositAmount = _announcedDeposit.depositAmount;\n..SNIP..\n70:         _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n..SNIP..\n75:         _mint(_account, _liquidityMinted);\n76: \n77:         vault.updateStableCollateralTotal(int256(depositAmount));\n..SNIP..\n82:         // Mint points\n83:         IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n84:         pointsModule.mintDeposit(_account, _announcedDeposit.depositAmount);\n```\n\n## Impact\n\nLarge amounts of points can be minted virtually without any cost. The points are intended to be used to exchange something of value. A malicious user could abuse this to obtain a large number of points, which could obtain excessive value from the protocol and create unfairness among other protocol users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/StableModule.sol#L96\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOne approach that could mitigate this risk is also to impose withdraw fee for the final/last withdrawal so that no one could abuse this exception to perform any attack that was once not profitable due to the need to pay withdraw fee.\n\nIn addition, consider deducting the points once a position is closed or reduced in size so that no one can attempt to open and adjust/close a position repeatedly to obtain more points.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xLogos** commented:\n> low/info, points != funds\n\n**takarez** commented:\n>  invalid\n\n\n\n**nevillehuang**\n\n@rashtrakoff Any reason why this issue was disputed? What are the points FMP for?\n\nI believe large amount of points shouldn't be freely minted.\n\n**rashtrakoff**\n\n@nevillehuang , this is a good find imo but since we are going to be the first depositors as well as creators of leverage positions as part of protocol initialisation I wouldn't believe this is something we  are concerned about. Furthermore, the points have no monetary value (at least not something we are going to assign) and there are costs associated with doing looping (keeper fees, possible losses due to price volatility etc.). Cc @itsermin @D-Ig .\n\n**nevillehuang**\n\n@rashtrakoff I will be maintaining as medium severity, even though points currently do not hold value, I believe it is not intended to allow free minting of points freely given it will hold some form of incentives in the future, so I believe it breaks core contract functionality. From my understanding, being the first depositor is only given as an example and is not required as shown in other issues such as #44 and #141.\n\n**0xLogos**\n\nEscalate \n\nShould be info\n\n> the points have no monetary value\n> there are costs associated with doing looping\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Should be info\n> \n> > the points have no monetary value\n> > there are costs associated with doing looping\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**santipu03**\n\nAgree with @0xLogos. \n\nMoreover, the withdrawal fee will make the attacker lose value with each withdrawal, making the attack unfeasable. \n\nEven in the improbable case that the attacker is a sophisticated bot that can act as a keeper and the withdrawal fee is not activated, the probability would be low with the impact being low/medium. Therefore, the overall severity should be low. \n\n**securitygrid**\n\nThis issue is valid. According to rules:\n\n> Loss of airdrops or liquidity fees or any other rewards that are not part of the original protocol design is not considered a valid high/medium\n\nFMP is part of the original protocol design. It's an incentive for users.\n\n**0xcrunch**\n\nSponsor is OK with issues related to FMP if they are not relevant to the overall functioning of the protocol.\n\nhttps://discord.com/channels/812037309376495636/1199005620536356874/1200372130253115413\n\n**xiaoming9090**\n\nIf points are not an incentive or something of value to the user, then there is no purpose for having a points system in the first place. The obvious answer is that the points will not be worthless because it makes no sense for users to hold something that is worthless. With that, points should be considered something of value, and any bugs, such as infinity minting of points/values, should not be QA/Low.\n\n**0xcrunch**\n\nThis kind of issue has no impact to the overall functioning of the protocol, so it is acceptable as stated by sponsor in the public channel.\n\n**nevillehuang**\n\nAgree with @xiaoming9090, I believe there is no logical reason why this should be allowed in the first place. \n\n@rashtrakoff What is the intended use case of points? It must have some incentive attached to it (even if its in the future), so users should never be getting points arbitrarily.\n\n**itsermin**\n\nThanks for your inputs here @xiaoming9090 @nevillehuang \n\nI discussed this with @rashtrakoff today. Even though there's a cost associated with looped mints (trading fees). Being able to mint a large number of FMP is not ideal. The user could alao potentially LP on the UNIT side to minimise their downside.\n\nWe're looking at a couple of options:\na) put a daily cap on the number of available FMP\nb) remove the trade volume minting altogether\n\n**0xcrunch**\n\nRewarding an issue publicly known as acceptable is unfair to watsons who didn't submit the issue out of respecting of Sherlock rules.\n\n**Czar102**\n\nI'd normally consider this a valid issue given that the points may have some value, but given the sponsor's message referenced in https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/187#issuecomment-1956258407, I think this should be considered informational.\n\nPlanning to accept the escalation and invalidate the issue.\n\n**nevillehuang**\n\n@Czar102 Fair enough, given the new hierachy of truth in place, I believe this can be low severity, unless watsons have any contest details and/or protocol documentation indicating a incentivized use case of points. @xiaoming9090 @securitygrid \n\n> Hierarchy of truth: Contest README > Sherlock rules for valid issues > protocol documentation (including code comments) > protocol answers on the contest public Discord channel.\n\n\n\n**novaman33**\n\n@Czar102 , I believe there are several code comments that suggest that points are incentive:\nIn `PointsModule.sol` \n```\n/// @title PointsModule\n/// @author dHEDGE\n/// @notice Module for awarding points as an incentive.\n```\n\nAnd before owner mintTo function:\n```\n/// @notice Owner can mint points to any account. \nThis can be used to distribute points to competition winners and other reward incentives.\n    ///         The points start a 12 month unlock tax (update unlockTime).\n ```\nThese state that points will be used as an encouragement, meaning they will either be something of value or be used to obtain something of value. I cannot agree that being able to obtain large amounts of points is a low severity case, given the comments in the code, which in the sherlock's Hierarchy of truth have more weight than protocol answers on the contest public Discord channel.\n\n**nevillehuang**\n\n> @Czar102 , I believe there are several code comments that suggest that points are incentive: In `PointsModule.sol`\n> \n> ```\n> /// @title PointsModule\n> /// @author dHEDGE\n> /// @notice Module for awarding points as an incentive.\n> ```\n> \n> And before owner mintTo function:\n> \n> ```\n> /// @notice Owner can mint points to any account. \n> This can be used to distribute points to competition winners and other reward incentives.\n>     ///         The points start a 12 month unlock tax (update unlockTime).\n> ```\n> \n> These state that points will be used as an encouragement, meaning they will either be something of value or be used to obtain something of value. I cannot agree that being able to obtain large amounts of points is a low severity case, given the comments in the code, which in the sherlock's Hierarchy of truth have more weight than protocol answers on the contest public Discord channel.\n\nGood point, in that case, I believe this issue should remain medium severity, given code comments (as seen [here](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/PointsModule.sol#L14) and [here](https://github.com/sherlock-audit/2023-12-flatmoney/blob/main/flatcoin-v1/src/PointsModule.sol#L89) has a greater significance than discord messages as shown in the hierarchy of truth [above](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/187#issuecomment-1970591636)\n\n**Czar102**\n\nI believe considering something an incentive doesn't imply this functionality being important enough for issues regarding it to be considered valid, while the sponsor's comment directly specified whether the issues of the type are valid. Also, these comments don't contradict the sponsor's comment at all.\n\nI stand by the previous proposition to invalidate the issue.\n\n**novaman33**\n\n@Czar102 the contracts in scope are stated in the readMe. The sponsor said \" we can be ok with issues with the same.\",  by which they state issues related to the points module are out of scope. I cannot understand why the points module is in scope in the first place. Given the Hierarchy of truth I believe points module are still in scope.\n\n\n**nevillehuang**\n\n@Czar102 I don't quite get your statement, it was already stated explicitly in code comments of the contract that points are meant to have an incentivized use case. So by hierarchy of truth, this is clearly a medium severity issue (and maybe can even be argued as high severity). Whatever it is, I will respect your decision, but hoping for a better clarification.\n\n**Czar102**\n\nGiven the hierarchy of truth, I think this issue is indeed a valid Medium.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2023-12-flatmoney-judging/issues/187/#issuecomment-1956094137): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/132",
  "Code": [
    {
      "filename": "flatcoin-v1/src/StableModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {ERC20LockableUpgradeable} from \"./misc/ERC20LockableUpgradeable.sol\";\n\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\n\n/// @title StableModule\n/// @author dHEDGE\n/// @notice Contains functions to handle stable LP deposits and withdrawals.\ncontract StableModule is IStableModule, ModuleUpgradeable, ERC20LockableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using PerpMath for int256;\n    using PerpMath for uint256;\n\n    uint256 public constant MIN_LIQUIDITY = 10_000; // minimum totalSupply that is allowable\n\n    /// @notice Fee for stable LP redemptions.\n    /// @dev 1e18 = 100%\n    uint256 public stableWithdrawFee;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault, uint256 _stableWithdrawFee) external initializer {\n        __Module_init(FlatcoinModuleKeys._STABLE_MODULE_KEY, _vault);\n        __ERC20_init(\"Flatmoney\", \"UNIT\");\n\n        setStableWithdrawFee(_stableWithdrawFee);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions        //\n    /////////////////////////////////////////////\n\n    /// @notice User delayed deposit into the stable LP. Mints ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending deposit.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedDeposit The pending order.\n    /// @return _liquidityMinted The amount of LP tokens minted.\n    function executeDeposit(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n        uint256 depositAmount = _announcedDeposit.depositAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n\n        if (_liquidityMinted < _announcedDeposit.minAmountOut)\n            revert FlatcoinErrors.HighSlippage(_liquidityMinted, _announcedDeposit.minAmountOut);\n\n        _mint(_account, _liquidityMinted);\n\n        vault.updateStableCollateralTotal(int256(depositAmount));\n\n        if (totalSupply() < MIN_LIQUIDITY)\n            revert FlatcoinErrors.AmountTooSmall({amount: totalSupply(), minAmount: MIN_LIQUIDITY});\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintDeposit(_account, _announcedDeposit.depositAmount);\n\n        emit FlatcoinEvents.Deposit(_account, depositAmount, _liquidityMinted);\n    }\n\n    /// @notice User delayed withdrawal from the stable LP. Burns ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending withdrawal.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedWithdraw The pending order.\n    /// @return _amountOut The amount of collateral withdrawn.\n    /// @return _withdrawFee The fee paid to the remaining LPs.\n    function executeWithdraw(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableWithdraw calldata _announcedWithdraw\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _amountOut, uint256 _withdrawFee) {\n        uint256 withdrawAmount = _announcedWithdraw.withdrawAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        uint256 stableCollateralPerShareBefore = stableCollateralPerShare(maxAge);\n        _amountOut = (withdrawAmount * stableCollateralPerShareBefore) / (10 ** decimals());\n\n        // Unlock the locked LP tokens before burning.\n        // This is because if the amount to be burned is locked, the burn will fail due to `_beforeTokenTransfer`.\n        _unlock(_account, withdrawAmount);\n\n        _burn(_account, withdrawAmount);\n\n        vault.updateStableCollateralTotal(-int256(_amountOut));\n\n        uint256 stableCollateralPerShareAfter = stableCollateralPerShare(maxAge);\n\n        // Check that there is no significant impact on stable token price.\n        // This should never happen and means that too much value or not enough value was withdrawn.\n        if (totalSupply() > 0) {\n            if (\n                stableCollateralPerShareAfter < stableCollateralPerShareBefore - 1e6 ||\n                stableCollateralPerShareAfter > stableCollateralPerShareBefore + 1e6\n            ) revert FlatcoinErrors.PriceImpactDuringWithdraw();\n\n            // Apply the withdraw fee if it's not the final withdrawal.\n            _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n\n            // additionalSkew = 0 because withdrawal was already processed above.\n            vault.checkSkewMax({additionalSkew: 0});\n        } else {\n            // Need to check there are no longs open before allowing full system withdrawal.\n            uint256 sizeOpenedTotal = vault.getVaultSummary().globalPositions.sizeOpenedTotal;\n\n            if (sizeOpenedTotal != 0) revert FlatcoinErrors.MaxSkewReached(sizeOpenedTotal);\n            if (stableCollateralPerShareAfter != 1e18) revert FlatcoinErrors.PriceImpactDuringFullWithdraw();\n        }\n\n        emit FlatcoinEvents.Withdraw(_account, _amountOut, withdrawAmount);\n    }\n\n    /// @notice Function to lock a certain amount of an account's LP tokens.\n    /// @dev This function is used to lock LP tokens when an account announces a delayed order.\n    /// @param _account The account to lock the LP tokens from.\n    /// @param _amount The amount of LP tokens to lock.\n    function lock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _lock(_account, _amount);\n    }\n\n    /// @notice Function to unlock a certain amount of an account's LP tokens.\n    /// @dev This function is used to unlock LP tokens when an account cancels a delayed order\n    ///      or when an order is executed.\n    /// @param _account The account to unlock the LP tokens from.\n    /// @param _amount The amount of LP tokens to unlock.\n    function unlock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _unlock(_account, _amount);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Total collateral available for withdrawal.\n    /// @dev Balance takes into account trader profit and loss and funding rate.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement() public view returns (uint256 _stableCollateralBalance) {\n        return stableCollateralTotalAfterSettlement({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate total stable side collateral after accounting for trader profit and loss and funding fees.\n    /// @param _maxAge The oldest price oracle timestamp that can be used. Set to 0 to ignore.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement(\n        uint32 _maxAge\n    ) public view returns (uint256 _stableCollateralBalance) {\n        // Assumption => pnlTotal = pnlLong + fundingAccruedLong\n        // The assumption is based on the fact that stable LPs are the counterparty to leverage traders.\n        // If the `pnlLong` is +ve that means the traders won and the LPs lost between the last funding rate update and now.\n        // Similary if the `fundingAccruedLong` is +ve that means the market was skewed short-side.\n        // When we combine these two terms, we get the total profit/loss of the leverage traders.\n        // NOTE: This function if called after settlement returns only the PnL as funding has already been adjusted\n        //      due to calling `_settleFundingFees()`. Although this still means `netTotal` includes the funding\n        //      adjusted long PnL, it might not be clear to the reader of the code.\n        int256 netTotal = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY))\n            .fundingAdjustedLongPnLTotal({maxAge: _maxAge});\n\n        // The flatcoin LPs are the counterparty to the leverage traders.\n        // So when the traders win, the flatcoin LPs lose and vice versa.\n        // Therefore we subtract the leverage trader profits and add the losses\n        int256 totalAfterSettlement = int256(vault.stableCollateralTotal()) - netTotal;\n\n        if (totalAfterSettlement < 0) {\n            _stableCollateralBalance = 0;\n        } else {\n            _stableCollateralBalance = uint256(totalAfterSettlement);\n        }\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare() public view returns (uint256 _collateralPerShare) {\n        return stableCollateralPerShare({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @param _maxAge The oldest price oracle timestamp that can be used.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare(uint32 _maxAge) public view returns (uint256 _collateralPerShare) {\n        uint256 totalSupply = totalSupply();\n\n        if (totalSupply > 0) {\n            uint256 stableBalance = stableCollateralTotalAfterSettlement(_maxAge);\n\n            _collateralPerShare = (stableBalance * (10 ** decimals())) / totalSupply;\n        } else {\n            // no shares have been minted yet\n            _collateralPerShare = 1e18;\n        }\n    }\n\n    /// @notice Quoter function for getting the stable deposit amount out.\n    /// @param _depositAmount The amount of collateral to deposit.\n    /// @return _amountOut The amount of LP tokens minted.\n    function stableDepositQuote(uint256 _depositAmount) public view returns (uint256 _amountOut) {\n        return (_depositAmount * (10 ** decimals())) / stableCollateralPerShare();\n    }\n\n    /// @notice Quoter function for getting the stable withdraw amount out.\n    /// @param _withdrawAmount The amount of LP tokens to withdraw.\n    /// @return _amountOut The amount of collateral withdrawn.\n    function stableWithdrawQuote(uint256 _withdrawAmount) public view returns (uint256 _amountOut) {\n        _amountOut = (_withdrawAmount * stableCollateralPerShare()) / (10 ** decimals());\n\n        // Take out the withdrawal fee\n        _amountOut -= (_amountOut * stableWithdrawFee) / 1e18;\n    }\n\n    /// @notice Function to get the locked amount of an account.\n    /// @param _account The account to get the locked amount for.\n    /// @return _amountLocked The amount of LP tokens locked.\n    function getLockedAmount(address _account) public view returns (uint256 _amountLocked) {\n        return _lockedAmount[_account];\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the maximum age of the oracle price to be used.\n    /// @param _executableAtTime The time at which the order is executable.\n    /// @return _maxAge The maximum age of the oracle price to be used.\n    function _getMaxAge(uint64 _executableAtTime) internal view returns (uint32 _maxAge) {\n        return (block.timestamp - _executableAtTime).toUint32();\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the stable withdraw fee.\n    /// @dev Fees can be set to 0 if needed.\n    /// @param _stableWithdrawFee The new stable withdraw fee.\n    function setStableWithdrawFee(uint256 _stableWithdrawFee) public onlyOwner {\n        // Set fee cap to max 1%.\n        // This is to avoid fat fingering but if any change is needed, the owner needs to\n        // upgrade this module.\n        if (_stableWithdrawFee > 0.01e18) revert FlatcoinErrors.InvalidFee(_stableWithdrawFee);\n\n        stableWithdrawFee = _stableWithdrawFee;\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/StableModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/utils/math/SafeCastUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC20Upgradeable.sol\";\nimport {ERC20LockableUpgradeable} from \"./misc/ERC20LockableUpgradeable.sol\";\n\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {FlatcoinEvents} from \"./libraries/FlatcoinEvents.sol\";\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\nimport {ILeverageModule} from \"./interfaces/ILeverageModule.sol\";\nimport {IStableModule} from \"./interfaces/IStableModule.sol\";\nimport {IPointsModule} from \"./interfaces/IPointsModule.sol\";\n\n/// @title StableModule\n/// @author dHEDGE\n/// @notice Contains functions to handle stable LP deposits and withdrawals.\ncontract StableModule is IStableModule, ModuleUpgradeable, ERC20LockableUpgradeable {\n    using SafeCastUpgradeable for *;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using PerpMath for int256;\n    using PerpMath for uint256;\n\n    uint256 public constant MIN_LIQUIDITY = 10_000; // minimum totalSupply that is allowable\n\n    /// @notice Fee for stable LP redemptions.\n    /// @dev 1e18 = 100%\n    uint256 public stableWithdrawFee;\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(IFlatcoinVault _vault, uint256 _stableWithdrawFee) external initializer {\n        __Module_init(FlatcoinModuleKeys._STABLE_MODULE_KEY, _vault);\n        __ERC20_init(\"Flatmoney\", \"UNIT\");\n\n        setStableWithdrawFee(_stableWithdrawFee);\n    }\n\n    /////////////////////////////////////////////\n    //         External Write Functions        //\n    /////////////////////////////////////////////\n\n    /// @notice User delayed deposit into the stable LP. Mints ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending deposit.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedDeposit The pending order.\n    /// @return _liquidityMinted The amount of LP tokens minted.\n    function executeDeposit(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableDeposit calldata _announcedDeposit\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _liquidityMinted) {\n        uint256 depositAmount = _announcedDeposit.depositAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        _liquidityMinted = (depositAmount * (10 ** decimals())) / stableCollateralPerShare(maxAge);\n\n        if (_liquidityMinted < _announcedDeposit.minAmountOut)\n            revert FlatcoinErrors.HighSlippage(_liquidityMinted, _announcedDeposit.minAmountOut);\n\n        _mint(_account, _liquidityMinted);\n\n        vault.updateStableCollateralTotal(int256(depositAmount));\n\n        if (totalSupply() < MIN_LIQUIDITY)\n            revert FlatcoinErrors.AmountTooSmall({amount: totalSupply(), minAmount: MIN_LIQUIDITY});\n\n        // Mint points\n        IPointsModule pointsModule = IPointsModule(vault.moduleAddress(FlatcoinModuleKeys._POINTS_MODULE_KEY));\n        pointsModule.mintDeposit(_account, _announcedDeposit.depositAmount);\n\n        emit FlatcoinEvents.Deposit(_account, depositAmount, _liquidityMinted);\n    }\n\n    /// @notice User delayed withdrawal from the stable LP. Burns ERC20 token receipt.\n    /// @dev Needs to be used in conjunction with DelayedOrder module.\n    /// @param _account The usser account which has a pending withdrawal.\n    /// @param _executableAtTime The time at which the order can be executed.\n    /// @param _announcedWithdraw The pending order.\n    /// @return _amountOut The amount of collateral withdrawn.\n    /// @return _withdrawFee The fee paid to the remaining LPs.\n    function executeWithdraw(\n        address _account,\n        uint64 _executableAtTime,\n        FlatcoinStructs.AnnouncedStableWithdraw calldata _announcedWithdraw\n    ) external whenNotPaused onlyAuthorizedModule returns (uint256 _amountOut, uint256 _withdrawFee) {\n        uint256 withdrawAmount = _announcedWithdraw.withdrawAmount;\n\n        uint32 maxAge = _getMaxAge(_executableAtTime);\n\n        uint256 stableCollateralPerShareBefore = stableCollateralPerShare(maxAge);\n        _amountOut = (withdrawAmount * stableCollateralPerShareBefore) / (10 ** decimals());\n\n        // Unlock the locked LP tokens before burning.\n        // This is because if the amount to be burned is locked, the burn will fail due to `_beforeTokenTransfer`.\n        _unlock(_account, withdrawAmount);\n\n        _burn(_account, withdrawAmount);\n\n        vault.updateStableCollateralTotal(-int256(_amountOut));\n\n        uint256 stableCollateralPerShareAfter = stableCollateralPerShare(maxAge);\n\n        // Check that there is no significant impact on stable token price.\n        // This should never happen and means that too much value or not enough value was withdrawn.\n        if (totalSupply() > 0) {\n            if (\n                stableCollateralPerShareAfter < stableCollateralPerShareBefore - 1e6 ||\n                stableCollateralPerShareAfter > stableCollateralPerShareBefore + 1e6\n            ) revert FlatcoinErrors.PriceImpactDuringWithdraw();\n\n            // Apply the withdraw fee if it's not the final withdrawal.\n            _withdrawFee = (stableWithdrawFee * _amountOut) / 1e18;\n\n            // additionalSkew = 0 because withdrawal was already processed above.\n            vault.checkSkewMax({additionalSkew: 0});\n        } else {\n            // Need to check there are no longs open before allowing full system withdrawal.\n            uint256 sizeOpenedTotal = vault.getVaultSummary().globalPositions.sizeOpenedTotal;\n\n            if (sizeOpenedTotal != 0) revert FlatcoinErrors.MaxSkewReached(sizeOpenedTotal);\n            if (stableCollateralPerShareAfter != 1e18) revert FlatcoinErrors.PriceImpactDuringFullWithdraw();\n        }\n\n        emit FlatcoinEvents.Withdraw(_account, _amountOut, withdrawAmount);\n    }\n\n    /// @notice Function to lock a certain amount of an account's LP tokens.\n    /// @dev This function is used to lock LP tokens when an account announces a delayed order.\n    /// @param _account The account to lock the LP tokens from.\n    /// @param _amount The amount of LP tokens to lock.\n    function lock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _lock(_account, _amount);\n    }\n\n    /// @notice Function to unlock a certain amount of an account's LP tokens.\n    /// @dev This function is used to unlock LP tokens when an account cancels a delayed order\n    ///      or when an order is executed.\n    /// @param _account The account to unlock the LP tokens from.\n    /// @param _amount The amount of LP tokens to unlock.\n    function unlock(address _account, uint256 _amount) public onlyAuthorizedModule {\n        _unlock(_account, _amount);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Total collateral available for withdrawal.\n    /// @dev Balance takes into account trader profit and loss and funding rate.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement() public view returns (uint256 _stableCollateralBalance) {\n        return stableCollateralTotalAfterSettlement({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate total stable side collateral after accounting for trader profit and loss and funding fees.\n    /// @param _maxAge The oldest price oracle timestamp that can be used. Set to 0 to ignore.\n    /// @return _stableCollateralBalance The total collateral available for withdrawal.\n    function stableCollateralTotalAfterSettlement(\n        uint32 _maxAge\n    ) public view returns (uint256 _stableCollateralBalance) {\n        // Assumption => pnlTotal = pnlLong + fundingAccruedLong\n        // The assumption is based on the fact that stable LPs are the counterparty to leverage traders.\n        // If the `pnlLong` is +ve that means the traders won and the LPs lost between the last funding rate update and now.\n        // Similary if the `fundingAccruedLong` is +ve that means the market was skewed short-side.\n        // When we combine these two terms, we get the total profit/loss of the leverage traders.\n        // NOTE: This function if called after settlement returns only the PnL as funding has already been adjusted\n        //      due to calling `_settleFundingFees()`. Although this still means `netTotal` includes the funding\n        //      adjusted long PnL, it might not be clear to the reader of the code.\n        int256 netTotal = ILeverageModule(vault.moduleAddress(FlatcoinModuleKeys._LEVERAGE_MODULE_KEY))\n            .fundingAdjustedLongPnLTotal({maxAge: _maxAge});\n\n        // The flatcoin LPs are the counterparty to the leverage traders.\n        // So when the traders win, the flatcoin LPs lose and vice versa.\n        // Therefore we subtract the leverage trader profits and add the losses\n        int256 totalAfterSettlement = int256(vault.stableCollateralTotal()) - netTotal;\n\n        if (totalAfterSettlement < 0) {\n            _stableCollateralBalance = 0;\n        } else {\n            _stableCollateralBalance = uint256(totalAfterSettlement);\n        }\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare() public view returns (uint256 _collateralPerShare) {\n        return stableCollateralPerShare({_maxAge: type(uint32).max});\n    }\n\n    /// @notice Function to calculate the collateral per share.\n    /// @param _maxAge The oldest price oracle timestamp that can be used.\n    /// @return _collateralPerShare The collateral per share.\n    function stableCollateralPerShare(uint32 _maxAge) public view returns (uint256 _collateralPerShare) {\n        uint256 totalSupply = totalSupply();\n\n        if (totalSupply > 0) {\n            uint256 stableBalance = stableCollateralTotalAfterSettlement(_maxAge);\n\n            _collateralPerShare = (stableBalance * (10 ** decimals())) / totalSupply;\n        } else {\n            // no shares have been minted yet\n            _collateralPerShare = 1e18;\n        }\n    }\n\n    /// @notice Quoter function for getting the stable deposit amount out.\n    /// @param _depositAmount The amount of collateral to deposit.\n    /// @return _amountOut The amount of LP tokens minted.\n    function stableDepositQuote(uint256 _depositAmount) public view returns (uint256 _amountOut) {\n        return (_depositAmount * (10 ** decimals())) / stableCollateralPerShare();\n    }\n\n    /// @notice Quoter function for getting the stable withdraw amount out.\n    /// @param _withdrawAmount The amount of LP tokens to withdraw.\n    /// @return _amountOut The amount of collateral withdrawn.\n    function stableWithdrawQuote(uint256 _withdrawAmount) public view returns (uint256 _amountOut) {\n        _amountOut = (_withdrawAmount * stableCollateralPerShare()) / (10 ** decimals());\n\n        // Take out the withdrawal fee\n        _amountOut -= (_amountOut * stableWithdrawFee) / 1e18;\n    }\n\n    /// @notice Function to get the locked amount of an account.\n    /// @param _account The account to get the locked amount for.\n    /// @return _amountLocked The amount of LP tokens locked.\n    function getLockedAmount(address _account) public view returns (uint256 _amountLocked) {\n        return _lockedAmount[_account];\n    }\n\n    /////////////////////////////////////////////\n    //            Internal Functions           //\n    /////////////////////////////////////////////\n\n    /// @notice Returns the maximum age of the oracle price to be used.\n    /// @param _executableAtTime The time at which the order is executable.\n    /// @return _maxAge The maximum age of the oracle price to be used.\n    function _getMaxAge(uint64 _executableAtTime) internal view returns (uint32 _maxAge) {\n        return (block.timestamp - _executableAtTime).toUint32();\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the stable withdraw fee.\n    /// @dev Fees can be set to 0 if needed.\n    /// @param _stableWithdrawFee The new stable withdraw fee.\n    function setStableWithdrawFee(uint256 _stableWithdrawFee) public onlyOwner {\n        // Set fee cap to max 1%.\n        // This is to avoid fat fingering but if any change is needed, the owner needs to\n        // upgrade this module.\n        if (_stableWithdrawFee > 0.01e18) revert FlatcoinErrors.InvalidFee(_stableWithdrawFee);\n\n        stableWithdrawFee = _stableWithdrawFee;\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/PointsModule.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.18;\n\nimport {ModuleUpgradeable} from \"./abstracts/ModuleUpgradeable.sol\";\nimport {DecimalMath} from \"./libraries/DecimalMath.sol\";\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinModuleKeys} from \"./libraries/FlatcoinModuleKeys.sol\";\nimport {ERC20LockableUpgradeable} from \"./misc/ERC20LockableUpgradeable.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\n\n/// @title PointsModule\n/// @author dHEDGE\n/// @notice Module for awarding points as an incentive.\ncontract PointsModule is ModuleUpgradeable, ERC20LockableUpgradeable {\n    using DecimalMath for uint256;\n\n    address public treasury;\n\n    /// @notice The duration of the unlock tax vesting period\n    uint256 public unlockTaxVest;\n\n    /// @notice Used to calculate points to mint when a user opens a leveraged position\n    uint256 public pointsPerSize;\n\n    /// @notice Used to calculate points to mint when a user deposits an amount of collateral to the flatcoin\n    uint256 public pointsPerDeposit;\n\n    /// @notice Time when user’s points will have 0% unlock tax\n    mapping(address account => uint256 unlockTime) public unlockTime;\n\n    struct MintPoints {\n        address to;\n        uint256 amount;\n    }\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    /// function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    function initialize(\n        IFlatcoinVault _flatcoinVault,\n        address _treasury,\n        uint256 _unlockTaxVest,\n        uint256 _pointsPerSize,\n        uint256 _pointsPerDeposit\n    ) external initializer {\n        if (address(_flatcoinVault) == address(0)) revert FlatcoinErrors.ZeroAddress(\"flatcoinVault\");\n\n        __Module_init(FlatcoinModuleKeys._POINTS_MODULE_KEY, _flatcoinVault);\n        __ERC20_init(\"Flat.money Points\", \"FMP\");\n\n        setTreasury(_treasury);\n        setPointsVest(_unlockTaxVest, _pointsPerSize, _pointsPerDeposit);\n    }\n\n    /////////////////////////////////////////////\n    //         Public Write Functions          //\n    /////////////////////////////////////////////\n\n    /// @notice Mints locked points to the user account when a user opens a leveraged position (uses pointsPerSize).\n    ///         The points start a 12 month unlock tax (update unlockTime).\n    /// @dev The function will not revert if no points are minted because it's called by the flatcoin contracts.\n    function mintLeverageOpen(address to, uint256 size) external onlyAuthorizedModule {\n        if (pointsPerSize == 0) return; // no incentives set on leverage open\n\n        uint256 amount = size._multiplyDecimal(pointsPerSize);\n        if (amount < 1e6) return; // ignore dust amounts (could happen on adjustment)\n\n        _mintTo(to, amount);\n    }\n\n    /// @notice Mints locked points to the user account when a user deposits to the flatcoin (uses pointsPerDeposit).\n    ///         The points start a 12 month unlock tax (update unlockTime).\n    /// @dev The function will not revert if no points are minted because it's called by the flatcoin contracts.\n    function mintDeposit(address to, uint256 depositAmount) external onlyAuthorizedModule {\n        if (pointsPerDeposit == 0) return; // no incentives set on flatcoin LP deposit\n\n        uint256 amount = depositAmount._multiplyDecimal(pointsPerDeposit);\n        if (amount < 1e6) return; // ignore dust amounts\n\n        _mintTo(to, amount);\n    }\n\n    /// @notice Owner can mint points to any account. This can be used to distribute points to competition winners and other reward incentives.\n    ///         The points start a 12 month unlock tax (update unlockTime).\n    function mintTo(MintPoints calldata _mintPoints) external onlyOwner {\n        _mintTo(_mintPoints.to, _mintPoints.amount);\n    }\n\n    /// @notice Owner can mint points to multiple accounts\n    function mintToMultiple(MintPoints[] calldata _mintPoints) external onlyOwner {\n        for (uint256 i = 0; i < _mintPoints.length; i++) {\n            _mintTo(_mintPoints[i].to, _mintPoints[i].amount);\n        }\n    }\n\n    /// @notice Unlocks all of sender’s locked tokens. Sends any taxed points to the treasury.\n    function unlockAll() public {\n        _unlock(type(uint256).max);\n    }\n\n    /// @notice Unlocks a specified amount of the sender’s locked tokens. Sends any taxed points to the treasury.\n    function unlock(uint256 amount) public {\n        _unlock(amount);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Calculates the unlock tax for a specific account.\n    ///         If a user has 100 points that have vested for 6 months (50% tax), then it returns 0.5e18.\n    ///         If this user earns another 100 points, then the new unlock tax should be 75% or 0.75e18.\n    ///         This tax can be calculated by using and modifying the unlockTime when the points are minted to an account.\n    function getUnlockTax(address account) public view returns (uint256 unlockTax) {\n        if (unlockTime[account] <= block.timestamp) return 0;"
    }
  ]
}