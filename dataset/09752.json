{
  "Title": "[L-02] Inconsistent `approve()` behavior between `ERC20` and `RevenueDistributionToken`",
  "Content": "\n`RevenueDistributionToken` considers an approval value of `type(uint256).max` as 'allow all amounts':\n\n```solidity\nif (callerAllowance == type(uint256).max) return;\n```\n\n[RevenueDistributionToken.sol#L279](https://github.com/maple-labs/revenue-distribution-token/blob/41a3e40bf8c109ff19b38b80fde300c44fd42a3d/contracts/RevenueDistributionToken.sol#L279)<br>\n\nwhereas `ERC20` considers it as a numerical amount:\n\n```solidity\n_approve(owner_, msg.sender, allowance[owner_][msg.sender] - amount_);\n```\n\n[ERC20.sol#L110](https://github.com/maple-labs/erc20/blob/10ccf4aa0b2d6914e3c2d32e454e4d106a99a4fd/contracts/ERC20.sol#L110)<br>\n\nThese inconsistences will likely lead to confusion at some point in the future.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-maple",
  "Code": [
    {
      "filename": "contracts/RevenueDistributionToken.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.7;\n\nimport { ERC20 }       from \"../modules/erc20/contracts/ERC20.sol\";\nimport { ERC20Helper } from \"../modules/erc20-helper/src/ERC20Helper.sol\";\n\nimport { IRevenueDistributionToken } from \"./interfaces/IRevenueDistributionToken.sol\";\n\n/*\n    ██████╗ ██████╗ ████████╗\n    ██╔══██╗██╔══██╗╚══██╔══╝\n    ██████╔╝██║  ██║   ██║\n    ██╔══██╗██║  ██║   ██║\n    ██║  ██║██████╔╝   ██║\n    ╚═╝  ╚═╝╚═════╝    ╚═╝\n*/\n\ncontract RevenueDistributionToken is IRevenueDistributionToken, ERC20 {\n\n    uint256 public immutable override precision;  // Precision of rates, equals max deposit amounts before rounding errors occur\n\n    address public override asset;  // Underlying ERC-20 asset used by ERC-4626 functionality.\n\n    address public override owner;         // Current owner of the contract, able to update the vesting schedule.\n    address public override pendingOwner;  // Pending owner of the contract, able to accept ownership.\n\n    uint256 public override freeAssets;           // Amount of assets unlocked regardless of time passed.\n    uint256 public override issuanceRate;         // asset/second rate dependent on aggregate vesting schedule (needs increased precision).\n    uint256 public override lastUpdated;          // Timestamp of when issuance equation was last updated.\n    uint256 public override vestingPeriodFinish;  // Timestamp when current vesting schedule ends.\n\n    uint256 private locked = 1;  // Used in reentrancy check.\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    modifier nonReentrant() {\n        require(locked == 1, \"RDT:LOCKED\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n\n    constructor(string memory name_, string memory symbol_, address owner_, address asset_, uint256 precision_)\n        ERC20(name_, symbol_, ERC20(asset_).decimals())\n    {\n        require((owner = owner_) != address(0), \"RDT:C:OWNER_ZERO_ADDRESS\");\n\n        asset     = asset_;  // Don't need to check zero address as ERC20(asset_).decimals() will fail in ERC20 constructor.\n        precision = precision_;\n    }\n\n    /********************************/\n    /*** Administrative Functions ***/\n    /********************************/\n\n    function acceptOwnership() external override {\n        require(msg.sender == pendingOwner, \"RDT:AO:NOT_PO\");\n\n        emit OwnershipAccepted(owner, msg.sender);\n\n        owner        = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    function setPendingOwner(address pendingOwner_) external override {\n        require(msg.sender == owner, \"RDT:SPO:NOT_OWNER\");\n\n        pendingOwner = pendingOwner_;\n\n        emit PendingOwnerSet(msg.sender, pendingOwner_);\n    }\n\n    // TODO: Revisit returns\n    function updateVestingSchedule(uint256 vestingPeriod_) external override returns (uint256 issuanceRate_, uint256 freeAssets_) {\n        require(msg.sender == owner, \"RDT:UVS:NOT_OWNER\");\n        require(totalSupply != 0,    \"RDT:UVS:ZERO_SUPPLY\");\n\n        // Update \"y-intercept\" to reflect current available asset.\n        freeAssets_ = freeAssets = totalAssets();\n\n        // Calculate slope.\n        issuanceRate_ = issuanceRate = ((ERC20(asset).balanceOf(address(this)) - freeAssets_) * precision) / vestingPeriod_;\n\n        // Update timestamp and period finish.\n        vestingPeriodFinish = (lastUpdated = block.timestamp) + vestingPeriod_;\n\n        emit VestingScheduleUpdated(msg.sender, vestingPeriodFinish, issuanceRate);\n    }\n\n    /************************/\n    /*** Staker Functions ***/\n    /************************/\n\n    function deposit(uint256 assets_, address receiver_) external virtual override nonReentrant returns (uint256 shares_) {\n        _mint(shares_ = previewDeposit(assets_), assets_, receiver_, msg.sender);\n    }\n\n    function depositWithPermit(\n        uint256 assets_,\n        address receiver_,\n        uint256 deadline_,\n        uint8   v_,\n        bytes32 r_,\n        bytes32 s_\n    )\n        external virtual override nonReentrant returns (uint256 shares_)\n    {\n        ERC20(asset).permit(msg.sender, address(this), assets_, deadline_, v_, r_, s_);\n        _mint(shares_ = previewDeposit(assets_), assets_, receiver_, msg.sender);\n    }\n\n    function mint(uint256 shares_, address receiver_) external virtual override nonReentrant returns (uint256 assets_) {\n        _mint(shares_, assets_ = previewMint(shares_), receiver_, msg.sender);\n    }\n\n    function mintWithPermit(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_,\n        uint256 deadline_,\n        uint8   v_,\n        bytes32 r_,\n        bytes32 s_\n    )\n        external virtual override nonReentrant returns (uint256 assets_)\n    {\n        require((assets_ = previewMint(shares_)) <= maxAssets_, \"RDT:MWP:INSUFFICIENT_PERMIT\");\n\n        ERC20(asset).permit(msg.sender, address(this), maxAssets_, deadline_, v_, r_, s_);\n        _mint(shares_, assets_, receiver_, msg.sender);\n    }\n\n    function redeem(uint256 shares_, address receiver_, address owner_) external virtual override nonReentrant returns (uint256 assets_) {\n        _burn(shares_, assets_ = previewRedeem(shares_), receiver_, owner_, msg.sender);\n    }\n\n    function withdraw(uint256 assets_, address receiver_, address owner_) external virtual override nonReentrant returns (uint256 shares_) {\n        _burn(shares_ = previewWithdraw(assets_), assets_, receiver_, owner_, msg.sender);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function _mint(uint256 shares_, uint256 assets_, address receiver_, address caller_) internal {\n        require(shares_ != 0, \"RDT:M:ZERO_SHARES\");\n        require(assets_ != 0, \"RDT:M:ZERO_ASSETS\");\n\n        _mint(receiver_, shares_);\n\n        freeAssets = totalAssets() + assets_;\n\n        _updateIssuanceParams();\n\n        emit Deposit(caller_, receiver_, assets_, shares_);\n\n        require(ERC20Helper.transferFrom(address(asset), caller_, address(this), assets_), \"RDT:M:TRANSFER_FROM\");\n    }\n\n    function _burn(uint256 shares_, uint256 assets_, address receiver_, address owner_, address caller_) internal {\n        require(shares_ != 0, \"RDT:B:ZERO_SHARES\");\n        require(assets_ != 0, \"RDT:B:ZERO_ASSETS\");\n\n        if (caller_ != owner_) {\n            _reduceCallerAllowance(caller_, owner_, shares_);\n        }\n\n        _burn(owner_, shares_);\n\n        freeAssets = totalAssets() - assets_;\n\n        _updateIssuanceParams();\n\n        emit Withdraw(caller_, receiver_, owner_, assets_, shares_);\n\n        require(ERC20Helper.transfer(address(asset), receiver_, assets_), \"RDT:B:TRANSFER\");\n    }\n\n    function _updateIssuanceParams() internal {\n        issuanceRate = (lastUpdated = block.timestamp) > vestingPeriodFinish ? 0 : issuanceRate;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    function APR() external view override returns (uint256 apr_) {\n        return (issuanceRate * 365 days * 1e6) / (totalSupply * precision);\n    }\n\n    function balanceOfAssets(address account_) public view override returns (uint256 balanceOfAssets_) {\n        return convertToAssets(balanceOf[account_]);\n    }\n\n    function convertToAssets(uint256 shares_) public view override returns (uint256 assets_) {\n        uint256 supply = totalSupply;  // Cache to stack.\n\n        assets_ = supply == 0 ? shares_ : (shares_ * totalAssets()) / supply;\n    }\n\n    function convertToShares(uint256 assets_) public view override returns (uint256 shares_) {\n        uint256 supply = totalSupply;  // Cache to stack.\n\n        shares_ = supply == 0 ? assets_ : (assets_ * supply) / totalAssets();\n    }\n\n    function maxDeposit(address receiver_) external pure virtual override returns (uint256 maxAssets_) {\n        receiver_;  // Silence warning\n        maxAssets_ = type(uint256).max;\n    }\n\n    function maxMint(address receiver_) external pure virtual override returns (uint256 maxShares_) {\n        receiver_;  // Silence warning\n        maxShares_ = type(uint256).max;\n    }\n\n    function maxRedeem(address owner_) external view virtual override returns (uint256 maxShares_) {\n        maxShares_ = balanceOf[owner_];\n    }\n\n    function maxWithdraw(address owner_) external view virtual override returns (uint256 maxAssets_) {\n        maxAssets_ = balanceOfAssets(owner_);\n    }\n\n    function previewDeposit(uint256 assets_) public view virtual override returns (uint256 shares_) {\n        // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\n        // it should round DOWN if it’s calculating the amount of shares to issue to a user, given an amount of assets provided.\n        shares_ = convertToShares(assets_);\n    }\n\n    function previewMint(uint256 shares_) public view virtual override returns (uint256 assets_) {\n        uint256 supply = totalSupply;  // Cache to stack.\n\n        // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\n        // it should round UP if it’s calculating the amount of assets a user must provide, to be issued a given amount of shares.\n        assets_ = supply == 0 ? shares_ : _divRoundUp(shares_ * totalAssets(), supply);\n    }\n\n    function previewRedeem(uint256 shares_) public view virtual override returns (uint256 assets_) {\n        // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\n        // it should round DOWN if it’s calculating the amount of assets to send to a user, given amount of shares returned.\n        assets_ = convertToAssets(shares_);\n    }\n\n    function previewWithdraw(uint256 assets_) public view virtual override returns (uint256 shares_) {\n        uint256 supply = totalSupply;  // Cache to stack.\n\n        // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\n        // it should round UP if it’s calculating the amount of shares a user must return, to be sent a given amount of assets.\n        shares_ = supply == 0 ? assets_ : _divRoundUp(assets_ * supply, totalAssets());\n    }\n\n    function totalAssets() public view override returns (uint256 totalManagedAssets_) {\n        if (issuanceRate == 0) return freeAssets;\n\n        uint256 vestingTimePassed =\n            block.timestamp > vestingPeriodFinish ?\n                vestingPeriodFinish - lastUpdated :\n                block.timestamp - lastUpdated;\n\n        return ((issuanceRate * vestingTimePassed) / precision) + freeAssets;\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function _reduceCallerAllowance(address caller_, address owner_, uint256 shares_) internal {\n        uint256 callerAllowance = allowance[owner_][caller_];  // Cache to stack.\n\n        // TODO: investigate whether leave this `require()` in for clarity from error message, or let the safe math check in `callerAllowance - shares_` handle the underflow.\n        require(callerAllowance >= shares_, \"RDT:CALLER_ALLOWANCE\");\n\n        if (callerAllowance == type(uint256).max) return;\n\n        allowance[owner_][caller_] = callerAllowance - shares_;\n    }\n\n    function _divRoundUp(uint256 numerator_, uint256 divisor_) internal pure returns (uint256 result_) {\n       return (numerator_ / divisor_) + (numerator_ % divisor_ > 0 ? 1 : 0);\n    }\n\n}"
    },
    {
      "filename": "contracts/ERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.7;\n\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\n\n/*\n    ███████╗██████╗  ██████╗    ██████╗  ██████╗\n    ██╔════╝██╔══██╗██╔════╝    ╚════██╗██╔═████╗\n    █████╗  ██████╔╝██║          █████╔╝██║██╔██║\n    ██╔══╝  ██╔══██╗██║         ██╔═══╝ ████╔╝██║\n    ███████╗██║  ██║╚██████╗    ███████╗╚██████╔╝\n    ╚══════╝╚═╝  ╚═╝ ╚═════╝    ╚══════╝ ╚═════╝\n*/\n\n/**\n *  @title Modern ERC-20 implementation.\n *  @dev   Acknowledgements to Solmate, OpenZeppelin, and DSS for inspiring this code.\n */\ncontract ERC20 is IERC20 {\n\n    /**************/\n    /*** ERC-20 ***/\n    /**************/\n\n    string public override name;\n    string public override symbol;\n\n    uint8 public immutable override decimals;\n\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    /****************/\n    /*** ERC-2612 ***/\n    /****************/\n\n    // PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH = bytes32(0xfc77c2b9d30fe91687fd39abb7d16fcdfe1472d065740051ab8b13e4bf4a617f);\n\n    mapping(address => uint256) public override nonces;\n\n    /**\n     *  @param name_     The name of the token.\n     *  @param symbol_   The symbol of the token.\n     *  @param decimals_ The decimal precision used by the token.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        name     = name_;\n        symbol   = symbol_;\n        decimals = decimals_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    function approve(address spender_, uint256 amount_) external override returns (bool success_) {\n        _approve(msg.sender, spender_, amount_);\n        return true;\n    }\n\n    function decreaseAllowance(address spender_, uint256 subtractedAmount_) external override returns (bool success_) {\n        _approve(msg.sender, spender_, allowance[msg.sender][spender_] - subtractedAmount_);\n        return true;\n    }\n\n    function increaseAllowance(address spender_, uint256 addedAmount_) external override returns (bool success_) {\n        _approve(msg.sender, spender_, allowance[msg.sender][spender_] + addedAmount_);\n        return true;\n    }\n\n    function permit(address owner_, address spender_, uint256 amount_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external override {\n        require(deadline_ >= block.timestamp, \"ERC20:P:EXPIRED\");\n\n        // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}.\n        require(\n            uint256(s_) <= uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) &&\n            (v_ == 27 || v_ == 28),\n            \"ERC20:P:MALLEABLE\"\n        );\n\n        // Nonce realistically cannot overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v_, r_, s_);\n\n            require(recoveredAddress == owner_ && owner_ != address(0), \"ERC20:P:INVALID_SIGNATURE\");\n        }\n\n        _approve(owner_, spender_, amount_);\n    }\n\n    function transfer(address recipient_, uint256 amount_) external override returns (bool success_) {\n        _transfer(msg.sender, recipient_, amount_);\n        return true;\n    }\n\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external override returns (bool success_) {\n        _approve(owner_, msg.sender, allowance[owner_][msg.sender] - amount_);\n        _transfer(owner_, recipient_, amount_);\n        return true;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32 domainSeparator_) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function _approve(address owner_, address spender_, uint256 amount_) internal {\n        emit Approval(owner_, spender_, allowance[owner_][spender_] = amount_);\n    }\n\n    function _burn(address owner_, uint256 amount_) internal {\n        balanceOf[owner_] -= amount_;\n\n        // Cannot underflow because a user's balance will never be larger than the total supply.\n        unchecked { totalSupply -= amount_; }\n\n        emit Transfer(owner_, address(0), amount_);\n    }\n\n    function _mint(address recipient_, uint256 amount_) internal {\n        totalSupply += amount_;\n\n        // Cannot overflow because totalSupply would first overflow in the statement above.\n        unchecked { balanceOf[recipient_] += amount_; }\n\n        emit Transfer(address(0), recipient_, amount_);\n    }\n\n    function _transfer(address owner_, address recipient_, uint256 amount_) internal {\n        balanceOf[owner_] -= amount_;\n\n        // Cannot overflow because minting prevents overflow of totalSupply, and sum of user balances == totalSupply.\n        unchecked { balanceOf[recipient_] += amount_; }\n\n        emit Transfer(owner_, recipient_, amount_);\n    }\n\n}"
    }
  ]
}