{
  "Title": "[G-03] Add unchecked blocks for subtractions where the operands cannot underflow",
  "Content": "There are some checks to avoid an underflow, but in some scenarios where it is impossible for underflow to occur we can use unchecked blocks to have some gas savings.\n\n### Please note this instance was not included in the bot reports.\n\n### 1 Instance\n1. ### The calculation `uint256 numYears = (block.timestamp - timeLaunch) / oneYear` can be unchecked\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L101\n\nIn the `inflationRemainder()` function it is not possible that the computation `block.timestamp - timeLaunch` statement would underflow as the value of `block.timestamp` would always be greater than that of `timeLaunch` so we can perform the ` uint256 numYears = (block.timestamp - timeLaunch) / oneYear` statement in an `unchecked {}` block as this would save some gas from the unnecessary internal underflow checks. The code could be recfatored as shown in the diff below.\n\n<details>\n\n```solidity\nfile: governance/contracts/OLAS.sol\n\n98:     function inflationRemainder() public view returns (uint256 remainder) {\n99:         uint256 _totalSupply = totalSupply;\n100:        // Current year\n101:        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;   //@audit can be unchecked\n102:        // Calculate maximum mint amount to date\n103:        uint256 supplyCap = tenYearSupplyCap;\n104:        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n105:        if (numYears > 9) {\n106:            // Number of years after ten years have passed (including ongoing ones)\n107:            numYears -= 9;\n108:            for (uint256 i = 0; i < numYears; ++i) {\n109:                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n110:            }\n111:        }\n112:        // Check for the requested mint overflow\n113:        remainder = supplyCap - _totalSupply;\n114:    }\n```\n\n```diff\ndiff --git a/governance/contracts/OLAS.sol b/governance/contracts/OLAS.sol\nindex a1700ed..33fc569 100644\n--- a/governance/contracts/OLAS.sol\n+++ b/governance/contracts/OLAS.sol\n@@ -98,7 +98,10 @@ contract OLAS is ERC20 {\n     function inflationRemainder() public view returns (uint256 remainder) {\n         uint256 _totalSupply = totalSupply;\n         // Current year\n-        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n+        uint256 numYears;\n+        unchecked {\n+            numYears = (block.timestamp - timeLaunch) / oneYear;\n+        }\n         // Calculate maximum mint amount to date\n         uint256 supplyCap = tenYearSupplyCap;\n         // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n```\n</details>\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    }
  ]
}