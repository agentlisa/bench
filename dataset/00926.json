{
  "Title": "Error-Prone and Unnecessary Push-Payment Mechanism in PaymentSplitter Contract",
  "Content": "The `PaymentSplitter` contract implements a push-payment mechanism through the internal [`_release_all` function](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/finance/payment_splitter/mod.rs#L144). This function iterates through all the payees added to the contract and transfers the corresponding amount to each of them.\n\n\nHowever, this function presents the following problems:\n\n\n* If one of the beneficiaries has already claimed their part and their releasable amount is 0, then even if other beneficiaries have yet to receive their part, [the whole transaction will revert](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/finance/payment_splitter/mod.rs#L169).\n* If the number of beneficiaries is too big, the function call might revert due to the defined [block limit size in Polkadot](https://wiki.polkadot.network/docs/learn-transaction-fees#block-limits-and-transaction-priority).\n\n\nEven though this function is not public and therefore not accessible by default, library users might want to call this function from custom public functions, potentially triggering the aforementioned errors.\n\n\nConsider removing the `_release_all` function, documenting why there is no push-payment implementation provided by the library, and encouraging the use of the [`release` function](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/finance/payment_splitter/mod.rs#L75)'s pull-payment mechanism instead.\n\n\n***Update:** Resolved in [pull request #145](https://github.com/Brushfam/openbrush-contracts/pull/145) at commit [e5de183](https://github.com/Brushfam/openbrush-contracts/pull/145/commits/e5de183399289e7d5a9e3a0c1d8ebae61b86770b).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/finance/payment_splitter/mod.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    payment_splitter,\n    traits::payment_splitter::*,\n};\nuse ink::prelude::vec::Vec;\nuse openbrush::{\n    storage::Mapping,\n    traits::{\n        AccountId,\n        Balance,\n        Storage,\n    },\n};\npub use payment_splitter::Internal as _;\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub total_shares: Balance,\n    #[lazy]\n    pub total_released: Balance,\n    pub shares: Mapping<AccountId, Balance>,\n    pub released: Mapping<AccountId, Balance>,\n    #[lazy]\n    pub payees: Vec<AccountId>,\n}\n\npub trait PaymentSplitterImpl: Storage<Data> + Internal {\n    fn total_shares(&self) -> Balance {\n        self.data().total_shares.get_or_default()\n    }\n\n    fn total_released(&self) -> Balance {\n        self.data().total_released.get_or_default()\n    }\n\n    fn shares(&self, account: AccountId) -> Balance {\n        self.data().shares.get(&account).unwrap_or(0)\n    }\n\n    fn released(&self, account: AccountId) -> Balance {\n        self.data().released.get(&account).unwrap_or(0)\n    }\n\n    fn payee(&self, index: u32) -> Option<AccountId> {\n        self.data().payees.get_or_default().get(index as usize).cloned()\n    }\n\n    fn receive(&mut self) {\n        self._emit_payee_added_event(Self::env().caller(), Self::env().transferred_value())\n    }\n\n    fn release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        self._release(account)\n    }\n}\n\npub trait Internal {\n    /// User must override those methods in their contract.\n    fn _emit_payee_added_event(&self, account: AccountId, shares: Balance);\n\n    fn _emit_payment_received_event(&self, from: AccountId, amount: Balance);\n\n    fn _emit_payment_released_event(&self, to: AccountId, amount: Balance);\n\n    /// Inits an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n    /// the matching position in the `shares` array.\n    ///\n    /// All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n    /// duplicates in `payees`.\n    ///\n    /// Emits `PayeeAdded` on each account.\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError>;\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError>;\n\n    /// Calls the `release` method for each `AccountId` in the `payees` vec.\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError>;\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal {\n    fn _emit_payee_added_event(&self, _account: AccountId, _shares: Balance) {}\n\n    fn _emit_payment_received_event(&self, _from: AccountId, _amount: Balance) {}\n\n    fn _emit_payment_released_event(&self, _to: AccountId, _amount: Balance) {}\n\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError> {\n        if payees_and_shares.is_empty() {\n            return Err(PaymentSplitterError::NoPayees)\n        }\n\n        for (payee, share) in payees_and_shares.into_iter() {\n            Internal::_add_payee(self, payee, share)?;\n        }\n        Ok(())\n    }\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError> {\n        if share == 0 {\n            return Err(PaymentSplitterError::SharesAreZero)\n        }\n        if self.data().shares.get(&payee).is_some() {\n            return Err(PaymentSplitterError::AlreadyHasShares)\n        }\n\n        let mut payees = self.data().payees.get_or_default();\n        payees.push(payee);\n        self.data().payees.set(&payees);\n\n        self.data().shares.insert(&payee, &share);\n\n        let new_shares = self.data().total_shares.get_or_default() + share;\n        self.data().total_shares.set(&new_shares);\n\n        Internal::_emit_payee_added_event(self, payee, share);\n        Ok(())\n    }\n\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError> {\n        let payees = self.data().payees.get_or_default();\n        let len = payees.len();\n\n        for account in payees.iter().take(len) {\n            Internal::_release(self, *account)?;\n        }\n\n        Ok(())\n    }\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        if self.data().shares.get(&account).is_none() {\n            return Err(PaymentSplitterError::AccountHasNoShares)\n        }\n\n        let balance = Self::env().balance();\n        let current_balance = balance.checked_sub(Self::env().minimum_balance()).unwrap_or_default();\n        let total_released = self.data().total_released.get_or_default();\n        let total_received = current_balance + total_released;\n        let shares = self.data().shares.get(&account).unwrap();\n        let total_shares = self.data().total_shares.get_or_default();\n        let released = self.data().released.get(&account).unwrap_or_default();\n        let payment = total_received * shares / total_shares - released;\n\n        if payment == 0 {\n            return Err(PaymentSplitterError::AccountIsNotDuePayment)\n        }\n\n        self.data().released.insert(&account, &(released + payment));\n        self.data().total_released.set(&(total_released + payment));\n\n        let transfer_result = Self::env().transfer(account, payment);\n        if transfer_result.is_err() {\n            return Err(PaymentSplitterError::TransferFailed)\n        }\n        Internal::_emit_payment_released_event(self, account, payment);\n        Ok(())\n    }\n}"
    },
    {
      "filename": "contracts/src/finance/payment_splitter/mod.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    payment_splitter,\n    traits::payment_splitter::*,\n};\nuse ink::prelude::vec::Vec;\nuse openbrush::{\n    storage::Mapping,\n    traits::{\n        AccountId,\n        Balance,\n        Storage,\n    },\n};\npub use payment_splitter::Internal as _;\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub total_shares: Balance,\n    #[lazy]\n    pub total_released: Balance,\n    pub shares: Mapping<AccountId, Balance>,\n    pub released: Mapping<AccountId, Balance>,\n    #[lazy]\n    pub payees: Vec<AccountId>,\n}\n\npub trait PaymentSplitterImpl: Storage<Data> + Internal {\n    fn total_shares(&self) -> Balance {\n        self.data().total_shares.get_or_default()\n    }\n\n    fn total_released(&self) -> Balance {\n        self.data().total_released.get_or_default()\n    }\n\n    fn shares(&self, account: AccountId) -> Balance {\n        self.data().shares.get(&account).unwrap_or(0)\n    }\n\n    fn released(&self, account: AccountId) -> Balance {\n        self.data().released.get(&account).unwrap_or(0)\n    }\n\n    fn payee(&self, index: u32) -> Option<AccountId> {\n        self.data().payees.get_or_default().get(index as usize).cloned()\n    }\n\n    fn receive(&mut self) {\n        self._emit_payee_added_event(Self::env().caller(), Self::env().transferred_value())\n    }\n\n    fn release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        self._release(account)\n    }\n}\n\npub trait Internal {\n    /// User must override those methods in their contract.\n    fn _emit_payee_added_event(&self, account: AccountId, shares: Balance);\n\n    fn _emit_payment_received_event(&self, from: AccountId, amount: Balance);\n\n    fn _emit_payment_released_event(&self, to: AccountId, amount: Balance);\n\n    /// Inits an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n    /// the matching position in the `shares` array.\n    ///\n    /// All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n    /// duplicates in `payees`.\n    ///\n    /// Emits `PayeeAdded` on each account.\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError>;\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError>;\n\n    /// Calls the `release` method for each `AccountId` in the `payees` vec.\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError>;\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal {\n    fn _emit_payee_added_event(&self, _account: AccountId, _shares: Balance) {}\n\n    fn _emit_payment_received_event(&self, _from: AccountId, _amount: Balance) {}\n\n    fn _emit_payment_released_event(&self, _to: AccountId, _amount: Balance) {}\n\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError> {\n        if payees_and_shares.is_empty() {\n            return Err(PaymentSplitterError::NoPayees)\n        }\n\n        for (payee, share) in payees_and_shares.into_iter() {\n            Internal::_add_payee(self, payee, share)?;\n        }\n        Ok(())\n    }\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError> {\n        if share == 0 {\n            return Err(PaymentSplitterError::SharesAreZero)\n        }\n        if self.data().shares.get(&payee).is_some() {\n            return Err(PaymentSplitterError::AlreadyHasShares)\n        }\n\n        let mut payees = self.data().payees.get_or_default();\n        payees.push(payee);\n        self.data().payees.set(&payees);\n\n        self.data().shares.insert(&payee, &share);\n\n        let new_shares = self.data().total_shares.get_or_default() + share;\n        self.data().total_shares.set(&new_shares);\n\n        Internal::_emit_payee_added_event(self, payee, share);\n        Ok(())\n    }\n\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError> {\n        let payees = self.data().payees.get_or_default();\n        let len = payees.len();\n\n        for account in payees.iter().take(len) {\n            Internal::_release(self, *account)?;\n        }\n\n        Ok(())\n    }\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        if self.data().shares.get(&account).is_none() {\n            return Err(PaymentSplitterError::AccountHasNoShares)\n        }\n\n        let balance = Self::env().balance();\n        let current_balance = balance.checked_sub(Self::env().minimum_balance()).unwrap_or_default();\n        let total_released = self.data().total_released.get_or_default();\n        let total_received = current_balance + total_released;\n        let shares = self.data().shares.get(&account).unwrap();\n        let total_shares = self.data().total_shares.get_or_default();\n        let released = self.data().released.get(&account).unwrap_or_default();\n        let payment = total_received * shares / total_shares - released;\n\n        if payment == 0 {\n            return Err(PaymentSplitterError::AccountIsNotDuePayment)\n        }\n\n        self.data().released.insert(&account, &(released + payment));\n        self.data().total_released.set(&(total_released + payment));\n\n        let transfer_result = Self::env().transfer(account, payment);\n        if transfer_result.is_err() {\n            return Err(PaymentSplitterError::TransferFailed)\n        }\n        Internal::_emit_payment_released_event(self, account, payment);\n        Ok(())\n    }\n}"
    },
    {
      "filename": "contracts/src/finance/payment_splitter/mod.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    payment_splitter,\n    traits::payment_splitter::*,\n};\nuse ink::prelude::vec::Vec;\nuse openbrush::{\n    storage::Mapping,\n    traits::{\n        AccountId,\n        Balance,\n        Storage,\n    },\n};\npub use payment_splitter::Internal as _;\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub total_shares: Balance,\n    #[lazy]\n    pub total_released: Balance,\n    pub shares: Mapping<AccountId, Balance>,\n    pub released: Mapping<AccountId, Balance>,\n    #[lazy]\n    pub payees: Vec<AccountId>,\n}\n\npub trait PaymentSplitterImpl: Storage<Data> + Internal {\n    fn total_shares(&self) -> Balance {\n        self.data().total_shares.get_or_default()\n    }\n\n    fn total_released(&self) -> Balance {\n        self.data().total_released.get_or_default()\n    }\n\n    fn shares(&self, account: AccountId) -> Balance {\n        self.data().shares.get(&account).unwrap_or(0)\n    }\n\n    fn released(&self, account: AccountId) -> Balance {\n        self.data().released.get(&account).unwrap_or(0)\n    }\n\n    fn payee(&self, index: u32) -> Option<AccountId> {\n        self.data().payees.get_or_default().get(index as usize).cloned()\n    }\n\n    fn receive(&mut self) {\n        self._emit_payee_added_event(Self::env().caller(), Self::env().transferred_value())\n    }\n\n    fn release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        self._release(account)\n    }\n}\n\npub trait Internal {\n    /// User must override those methods in their contract.\n    fn _emit_payee_added_event(&self, account: AccountId, shares: Balance);\n\n    fn _emit_payment_received_event(&self, from: AccountId, amount: Balance);\n\n    fn _emit_payment_released_event(&self, to: AccountId, amount: Balance);\n\n    /// Inits an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n    /// the matching position in the `shares` array.\n    ///\n    /// All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n    /// duplicates in `payees`.\n    ///\n    /// Emits `PayeeAdded` on each account.\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError>;\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError>;\n\n    /// Calls the `release` method for each `AccountId` in the `payees` vec.\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError>;\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal {\n    fn _emit_payee_added_event(&self, _account: AccountId, _shares: Balance) {}\n\n    fn _emit_payment_received_event(&self, _from: AccountId, _amount: Balance) {}\n\n    fn _emit_payment_released_event(&self, _to: AccountId, _amount: Balance) {}\n\n    fn _init(&mut self, payees_and_shares: Vec<(AccountId, Balance)>) -> Result<(), PaymentSplitterError> {\n        if payees_and_shares.is_empty() {\n            return Err(PaymentSplitterError::NoPayees)\n        }\n\n        for (payee, share) in payees_and_shares.into_iter() {\n            Internal::_add_payee(self, payee, share)?;\n        }\n        Ok(())\n    }\n\n    fn _add_payee(&mut self, payee: AccountId, share: Balance) -> Result<(), PaymentSplitterError> {\n        if share == 0 {\n            return Err(PaymentSplitterError::SharesAreZero)\n        }\n        if self.data().shares.get(&payee).is_some() {\n            return Err(PaymentSplitterError::AlreadyHasShares)\n        }\n\n        let mut payees = self.data().payees.get_or_default();\n        payees.push(payee);\n        self.data().payees.set(&payees);\n\n        self.data().shares.insert(&payee, &share);\n\n        let new_shares = self.data().total_shares.get_or_default() + share;\n        self.data().total_shares.set(&new_shares);\n\n        Internal::_emit_payee_added_event(self, payee, share);\n        Ok(())\n    }\n\n    fn _release_all(&mut self) -> Result<(), PaymentSplitterError> {\n        let payees = self.data().payees.get_or_default();\n        let len = payees.len();\n\n        for account in payees.iter().take(len) {\n            Internal::_release(self, *account)?;\n        }\n\n        Ok(())\n    }\n\n    fn _release(&mut self, account: AccountId) -> Result<(), PaymentSplitterError> {\n        if self.data().shares.get(&account).is_none() {\n            return Err(PaymentSplitterError::AccountHasNoShares)\n        }\n\n        let balance = Self::env().balance();\n        let current_balance = balance.checked_sub(Self::env().minimum_balance()).unwrap_or_default();\n        let total_released = self.data().total_released.get_or_default();\n        let total_received = current_balance + total_released;\n        let shares = self.data().shares.get(&account).unwrap();\n        let total_shares = self.data().total_shares.get_or_default();\n        let released = self.data().released.get(&account).unwrap_or_default();\n        let payment = total_received * shares / total_shares - released;\n\n        if payment == 0 {\n            return Err(PaymentSplitterError::AccountIsNotDuePayment)\n        }\n\n        self.data().released.insert(&account, &(released + payment));\n        self.data().total_released.set(&(total_released + payment));\n\n        let transfer_result = Self::env().transfer(account, payment);\n        if transfer_result.is_err() {\n            return Err(PaymentSplitterError::TransferFailed)\n        }\n        Internal::_emit_payment_released_event(self, account, payment);\n        Ok(())\n    }\n}"
    }
  ]
}