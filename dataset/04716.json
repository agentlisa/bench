{
  "Title": "[M-02] Inadequate handling of `BUIDL` redemption limit in `OUSG` instant manager",
  "Content": "\n<https://github.com/code-423n4/2024-03-ondo-finance/blob/78779c30bebfd46e6f416b03066c55d587e8b30b/contracts/ousg/ousgInstantManager.sol#L426-L429> \n\n<https://github.com/code-423n4/2024-03-ondo-finance/blob/78779c30bebfd46e6f416b03066c55d587e8b30b/contracts/ousg/ousgInstantManager.sol#L460>\n\n### Impact\n\nThe `OUSG` Instant Redemption Manager contract contains an oversight in its `redeem` function, specifically in the handling of `BUIDL` redemption limits. This oversight can potentially lead to failed redemption attempts when the redemption balance exceeds the `BUIDL` balance held by the manager contract while it has a right amount if its concatenated with USDC amount left by another redemption process. The impact of this issue is significant as it affects the usability of the redemption feature and can result in user frustration and loss of trust in the system.\n\n### Proof of Concept\n\nThe following POC demonstrates the issue. Use it as part of `forge-tests/ousg/OUSGInstantManager/redeem.t.sol` file.\n\nRun using this command:\n\n```\nnpm run test-forge -- --match-test test_POC_redeem_fail_when_alice_redeemtion_balance_is_over_manager_BUIDL_balance\n```\n\n```solidity\n  function test_POC_redeem_fail_when_alice_redeemtion_balance_is_over_manager_BUIDL_balance()\n    public\n    setupSecuritize(500_000e6, 500_000e6)\n  {    \n    uint256 aliceOUSGRedeemAmount = 1667e18; \n    uint256 aliceUSDCAmount = 250_100e6;\n\n    uint256 bobOUSGRedeemAmount = 1666e18;\n    uint256 bobUSDCAmount = 249_900e6;\n\n\n    // Mint OUSG tokens for Alice and Bob\n    vm.prank(address(ousgInstantManager));\n    ousg.mint(alice, aliceOUSGRedeemAmount);\n\n    vm.prank(address(ousgInstantManager));\n    ousg.mint(bob, bobOUSGRedeemAmount);\n\n    // Bob redeems OUSG tokens successfully\n    vm.startPrank(bob);\n    ousg.approve(address(ousgInstantManager), (bobOUSGRedeemAmount));\n    ousgInstantManager.redeem(bobOUSGRedeemAmount);\n    vm.stopPrank();\n\n    // Alice attempts to redeem OUSG tokens, but the redemption fails due to insufficient BUIDL balance\n    vm.startPrank(alice);\n    ousg.approve(address(ousgInstantManager), (aliceOUSGRedeemAmount));\n    vm.expectRevert('Not enough tokens');\n    ousgInstantManager.redeem(aliceOUSGRedeemAmount);\n    vm.stopPrank();\n\n    assertEq(USDC.balanceOf(bob), bobUSDCAmount);\n\n    assertEq(\n      BUIDL.balanceOf(address(ousgInstantManager)) + USDC.balanceOf(address(ousgInstantManager)),\n      aliceUSDCAmount\n    );\n\n    // However if Alice try to reddem an amount that will be in usdc amount <= minBUIDLRedeemAmount in ousgInstantManager it will success\n    vm.startPrank(alice);\n    ousgInstantManager.redeem(aliceOUSGRedeemAmount - 10e18);\n    vm.stopPrank();\n\n    // Tokens remaining in Alice's balance after successful redemption\n    assertEq(ousg.balanceOf(alice), 10e18);\n\n  }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nTo address this issue, the `OUSG` Instant Redemption Manager contract should implement a mechanism to ensure that redemption requests do not exceed the available `BUIDL` balance held by the manager contract. This can be achieved by incorporating proper checks and balances in the redemption process, such as verifying the `BUIDL` balance before processing redemption requests and adjusting the redemption amount accordingly. Additionally, consider an redeem implementation that concatenate the balance of remaining USDC amount with the `BUIDL` redeemed balance if the corresponding `USDC` amount or redeem amount of `OUSG` is more than `minBUIDLRedeemAmount`.\n\n### Assessed type\n\nError\n\n**[cameronclifton (Ondo) confirmed and commented](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/306#issuecomment-2071074179):**\n> Due to changing requirements, the contract will now concatenate the USDC amount with `BUIDL` when performing redemptions. (This should mitigate this already known issue). \n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/306).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-ondo-finance",
  "Code": [
    {
      "filename": "contracts/ousg/ousgInstantManager.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/ousg/rOUSG.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/interfaces/IBUIDLRedeemer.sol\";\nimport \"contracts/InstantMintTimeBasedRateLimiter.sol\";\nimport \"contracts/interfaces/IOUSGInstantManager.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\nimport \"contracts/interfaces/IInvestorBasedRateLimiter.sol\";\n\n/**\n * @title OUSGInstantManager\n * @author Ondo Finance\n * @notice This contract is responsible for minting\n *         and redeeming OUSG and rOUSG against USDC. Addresses\n *         with the DEFAULT_ADMIN_ROLE able to set optional mint and\n *         redeem fees. It is implemented in terms of a\n *         InstantMintTimeBasedRateLimiter, which imposes mint and redeem limits within\n *         specified intervals. Additionally, addresses with the PAUSER role in\n *         the registry can pause mints and redemptions, while addresses with\n *         the DEFAULT_ADMIN role can unpause mints or redemptions.\n *\n * @dev Please be aware of the differences of decimals representations between\n *      OUSG, rOUSG, USDC, and BUIDL. This contract multiplies\n *      or divides quantities by a scaling factor (see `decimalsMultiplier`) to\n *      account for this. Due to the way the difference in decimals is\n *      calculated, the decimals value of the usdc token MUST be less\n *      than or equal to OUSG's decimals value or else contract deployment\n *      will fail.\n */\ncontract OUSGInstantManager is\n  ReentrancyGuard,\n  InstantMintTimeBasedRateLimiter,\n  AccessControlEnumerable,\n  IOUSGInstantManager,\n  IMulticall\n{\n  // Role to configure the contract\n  bytes32 public constant CONFIGURER_ROLE = keccak256(\"CONFIGURER_ROLE\");\n\n  // Role to pause minting and redemptions\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // Safety circuit breaker in case of Oracle malfunction\n  uint256 public constant MINIMUM_OUSG_PRICE = 105e18;\n\n  // Helper constant that allows us to precisely specify fees in basis points\n  uint256 public constant FEE_GRANULARITY = 10_000;\n\n  // Helper constant that allows us to convert between OUSG and rOUSG shares\n  uint256 public constant OUSG_TO_ROUSG_SHARES_MULTIPLIER = 10_000;\n\n  // USDC contract\n  IERC20 public immutable usdc; // 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n  // OUSG contract\n  IRWALike public immutable ousg;\n\n  // Rebasing OUSG Contract\n  ROUSG public immutable rousg;\n\n  // BUIDL token contract\n  IERC20 public immutable buidl;\n\n  // Redeemer contract used for instant redemptions of BUIDL\n  IBUIDLRedeemer public immutable buidlRedeemer;\n\n  // Scaling factor to account for differences in decimals between OUSG/rOUSG and BUIDL/USDC\n  uint256 public immutable decimalsMultiplier;\n\n  // The address that receives USDC for subscriptions\n  address public immutable usdcReceiver;\n\n  // Address of the oracle that provides the `ousgPrice`\n  IRWAOracle public oracle;\n\n  // The address in which USDC should be sent to as a fee for minting and redeeming\n  address public feeReceiver;\n\n  // Fee collected when minting OUSG (in basis points)\n  uint256 public mintFee = 0;\n\n  // Fee collected when redeeming OUSG (in basis points)\n  uint256 public redeemFee = 0;\n\n  // Minimum amount of USDC that must be deposited to mint OUSG or rOUSG\n  // Denoted in 6 decimals for USDC\n  uint256 public minimumDepositAmount = 100_000e6;\n\n  // Minimum amount of USDC that must be redeemed for to redeem OUSG or rOUSG\n  // Denoted in 6 decimals for USDC\n  uint256 public minimumRedemptionAmount = 50_000e6;\n\n  // Whether minting is paused for this contract\n  bool public mintPaused;\n\n  // Whether redemptions are paused for this contract\n  bool public redeemPaused;\n\n  // The minimum amount of BUIDL that must be redeemed in a single redemption\n  // with the BUIDLRedeemer contract\n  uint256 public minBUIDLRedeemAmount = 250_000e6;\n\n  // Optional investor-based rate limiting contract reference\n  IInvestorBasedRateLimiter public investorBasedRateLimiter;\n\n  /**\n   * @notice Constructor.\n   *\n   * @param defaultAdmin        Address that receives all roles during init DEFAULT_ADMIN_ROLE\n   * @param _usdc               USDC's token contract address\n   * @param _usdcReciever       Address that receives USDC during minting\n   * @param _feeReceiver        Address that receives mint and redemption fees\n   * @param _ousgOracle         OUSG's oracle contract address\n   * @param _ousg               OUSG's token contract address\n   * @param _rousg              rOUSG's token contract address\n   * @param _buidl              BUIDL token contract address\n   * @param _buidlRedeemer      Contract address used for instant redemptions of BUIDL\n   * @param rateLimiterConfig   See IOUSGInstantManager.sol & InstantMintTimeBasedRateLimiter.sol\n   *\n   * @dev We calculate `decimalsMultiplier` by subtracting OUSG's decimals by\n   *      the `usdc` contract's decimals and performing 10 ^ difference.\n   *      Deployment will fail if the difference is a negative number via\n   *      runtime underflow protections provided by our solidity version.\n   */\n  constructor(\n    address defaultAdmin,\n    address _usdc,\n    address _usdcReciever,\n    address _feeReceiver,\n    address _ousgOracle,\n    address _ousg,\n    address _rousg,\n    address _buidl,\n    address _buidlRedeemer,\n    RateLimiterConfig memory rateLimiterConfig\n  )\n    InstantMintTimeBasedRateLimiter(\n      rateLimiterConfig.mintLimitDuration,\n      rateLimiterConfig.redeemLimitDuration,\n      rateLimiterConfig.mintLimit,\n      rateLimiterConfig.redeemLimit\n    )\n  {\n    require(\n      address(_usdc) != address(0),\n      \"OUSGInstantManager: USDC cannot be 0x0\"\n    );\n    require(\n      address(_usdcReciever) != address(0),\n      \"OUSGInstantManager: USDC Receiver cannot be 0x0\"\n    );\n    require(\n      address(_feeReceiver) != address(0),\n      \"OUSGInstantManager: feeReceiver cannot be 0x0\"\n    );\n    require(\n      address(_ousgOracle) != address(0),\n      \"OUSGInstantManager: OUSG Oracle cannot be 0x0\"\n    );\n    require(_ousg != address(0), \"OUSGInstantManager: OUSG cannot be 0x0\");\n    require(_rousg != address(0), \"OUSGInstantManager: rOUSG cannot be 0x0\");\n    require(_buidl != address(0), \"OUSGInstantManager: BUIDL cannot be 0x0\");\n    require(\n      address(_buidlRedeemer) != address(0),\n      \"OUSGInstantManager: BUIDL Redeemer cannot be 0x0\"\n    );\n    require(\n      IERC20Metadata(_ousg).decimals() == IERC20Metadata(_rousg).decimals(),\n      \"OUSGInstantManager: OUSG decimals must be equal to USDC decimals\"\n    );\n    require(\n      IERC20Metadata(_usdc).decimals() == IERC20Metadata(_buidl).decimals(),\n      \"OUSGInstantManager: USDC decimals must be equal to BUIDL decimals\"\n    );\n    usdc = IERC20(_usdc);\n    usdcReceiver = _usdcReciever;\n    feeReceiver = _feeReceiver;\n    oracle = IRWAOracle(_ousgOracle);\n    ousg = IRWALike(_ousg);\n    rousg = ROUSG(_rousg);\n    buidl = IERC20(_buidl);\n    buidlRedeemer = IBUIDLRedeemer(_buidlRedeemer);\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_ousg).decimals() - IERC20Metadata(_usdc).decimals());\n    require(\n      OUSG_TO_ROUSG_SHARES_MULTIPLIER ==\n        rousg.OUSG_TO_ROUSG_SHARES_MULTIPLIER(),\n      \"OUSGInstantManager: OUSG to rOUSG shares multiplier must be equal to rOUSG's\"\n    );\n\n    _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n    _grantRole(CONFIGURER_ROLE, defaultAdmin);\n    _grantRole(PAUSER_ROLE, defaultAdmin);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Mint/Redeem\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Calculates fees and triggers minting OUSG for a given amount of USDC\n   *\n   * @dev Please note that the fees are accumulated in `feeReceiver`\n   *\n   * @param usdcAmountIn amount of USDC exchanged for OUSG (in whatever decimals\n   *                     specifed by usdc token contract)\n   *\n   * @return ousgAmountOut The quantity of OUSG minted for the user\n   *                       (18 decimals per OUSG contract)\n   */\n  function mint(\n    uint256 usdcAmountIn\n  )\n    external\n    override\n    nonReentrant\n    whenMintNotPaused\n    returns (uint256 ousgAmountOut)\n  {\n    ousgAmountOut = _mint(usdcAmountIn, msg.sender);\n    emit InstantMintOUSG(msg.sender, usdcAmountIn, ousgAmountOut);\n  }\n\n  /**\n   * @notice Calculates fees and triggers minting rOUSG for a given amount of USDC\n   *\n   * @dev Please note that the fees are accumulated in `feeReceiver`\n   *\n   * @param usdcAmountIn amount of USDC exchanged for rOUSG (in whatever decimals\n   *                     specifed by usdc token contract)\n   *\n   * @return rousgAmountOut The quantity of rOUSG minted for the user\n   *                        (18 decimals per rOUSG contract)\n   */\n  function mintRebasingOUSG(\n    uint256 usdcAmountIn\n  )\n    external\n    override\n    nonReentrant\n    whenMintNotPaused\n    returns (uint256 rousgAmountOut)\n  {\n    uint256 ousgAmountOut = _mint(usdcAmountIn, address(this));\n    ousg.approve(address(rousg), ousgAmountOut);\n    rousg.wrap(ousgAmountOut);\n    rousgAmountOut = rousg.getROUSGByShares(\n      ousgAmountOut * OUSG_TO_ROUSG_SHARES_MULTIPLIER\n    );\n    rousg.transfer(msg.sender, rousgAmountOut);\n    emit InstantMintRebasingOUSG(\n      msg.sender,\n      usdcAmountIn,\n      ousgAmountOut,\n      rousgAmountOut\n    );\n  }\n\n  function _mint(\n    uint256 usdcAmountIn,\n    address to\n  ) internal returns (uint256 ousgAmountOut) {\n    require(\n      IERC20Metadata(address(usdc)).decimals() == 6,\n      \"OUSGInstantManager::_mint: USDC decimals must be 6\"\n    );\n    require(\n      usdcAmountIn >= minimumDepositAmount,\n      \"OUSGInstantManager::_mint: Deposit amount too small\"\n    );\n    _checkAndUpdateInstantMintLimit(usdcAmountIn);\n    if (address(investorBasedRateLimiter) != address(0)) {\n      investorBasedRateLimiter.checkAndUpdateMintLimit(\n        msg.sender,\n        usdcAmountIn\n      );\n    }\n\n    require(\n      usdc.allowance(msg.sender, address(this)) >= usdcAmountIn,\n      \"OUSGInstantManager::_mint: Allowance must be given to OUSGInstantManager\"\n    );\n\n    uint256 usdcfees = _getInstantMintFees(usdcAmountIn);\n    uint256 usdcAmountAfterFee = usdcAmountIn - usdcfees;\n\n    // Calculate the mint amount based on mint fees and usdc quantity\n    uint256 ousgPrice = getOUSGPrice();\n    ousgAmountOut = _getMintAmount(usdcAmountAfterFee, ousgPrice);\n\n    require(\n      ousgAmountOut > 0,\n      \"OUSGInstantManager::_mint: net mint amount can't be zero\"\n    );\n\n    // Transfer USDC\n    if (usdcfees > 0) {\n      usdc.transferFrom(msg.sender, feeReceiver, usdcfees);\n    }\n    usdc.transferFrom(msg.sender, usdcReceiver, usdcAmountAfterFee);\n\n    emit MintFeesDeducted(msg.sender, feeReceiver, usdcfees, usdcAmountIn);\n\n    ousg.mint(to, ousgAmountOut);\n  }\n\n  /**\n   * @notice Calculates fees and triggers a redemption of OUSG for a given amount of USDC\n   *\n   * @dev Please note that the fees are accumulated in `feeReceiver`\n   *\n   * @param ousgAmountIn Amount of OUSG to redeem\n   *\n   * @return usdcAmountOut The amount of USDC returned to the user\n   */\n  function redeem(\n    uint256 ousgAmountIn\n  )\n    external\n    override\n    nonReentrant\n    whenRedeemNotPaused\n    returns (uint256 usdcAmountOut)\n  {\n    require(\n      ousg.allowance(msg.sender, address(this)) >= ousgAmountIn,\n      \"OUSGInstantManager::redeem: Insufficient allowance\"\n    );\n    ousg.transferFrom(msg.sender, address(this), ousgAmountIn);\n    usdcAmountOut = _redeem(ousgAmountIn);\n    emit InstantRedemptionOUSG(msg.sender, ousgAmountIn, usdcAmountOut);\n  }\n\n  /**\n   * @notice Calculates fees and triggers minting rOUSG for a given amount of USDC\n   *\n   * @dev Please note that the fees are actually accumulated in `feeReceiver`\n   *\n   * @param rousgAmountIn Amount of rOUSG to redeem\n   *\n   * @return usdcAmountOut The amount of USDC returned to the user\n   */\n  function redeemRebasingOUSG(\n    uint256 rousgAmountIn\n  )\n    external\n    override\n    nonReentrant\n    whenRedeemNotPaused\n    returns (uint256 usdcAmountOut)\n  {\n    require(\n      rousg.allowance(msg.sender, address(this)) >= rousgAmountIn,\n      \"OUSGInstantManager::redeemRebasingOUSG: Insufficient allowance\"\n    );\n    rousg.transferFrom(msg.sender, address(this), rousgAmountIn);\n    rousg.unwrap(rousgAmountIn);\n    uint256 ousgAmountIn = rousg.getSharesByROUSG(rousgAmountIn) /\n      OUSG_TO_ROUSG_SHARES_MULTIPLIER;\n    usdcAmountOut = _redeem(ousgAmountIn);\n    emit InstantRedemptionRebasingOUSG(\n      msg.sender,\n      rousgAmountIn,\n      ousgAmountIn,\n      usdcAmountOut\n    );\n  }\n\n  function _redeem(\n    uint256 ousgAmountIn\n  ) internal returns (uint256 usdcAmountOut) {\n    require(\n      IERC20Metadata(address(usdc)).decimals() == 6,\n      \"OUSGInstantManager::_redeem: USDC decimals must be 6\"\n    );\n    require(\n      IERC20Metadata(address(buidl)).decimals() == 6,\n      \"OUSGInstantManager::_redeem: BUIDL decimals must be 6\"\n    );\n    uint256 ousgPrice = getOUSGPrice();\n    uint256 usdcAmountToRedeem = _getRedemptionAmount(ousgAmountIn, ousgPrice);\n\n    require(\n      usdcAmountToRedeem >= minimumRedemptionAmount,\n      \"OUSGInstantManager::_redeem: Redemption amount too small\"\n    );\n    _checkAndUpdateInstantRedemptionLimit(usdcAmountToRedeem);\n\n    if (address(investorBasedRateLimiter) != address(0)) {\n      investorBasedRateLimiter.checkAndUpdateRedeemLimit(\n        msg.sender,\n        usdcAmountToRedeem\n      );\n    }\n\n    uint256 usdcFees = _getInstantRedemptionFees(usdcAmountToRedeem);\n    usdcAmountOut = usdcAmountToRedeem - usdcFees;\n    require(\n      usdcAmountOut > 0,\n      \"OUSGInstantManager::_redeem: redeem amount can't be zero\"\n    );\n\n    ousg.burn(ousgAmountIn);\n\n    uint256 usdcBalance = usdc.balanceOf(address(this));\n\n    if (usdcAmountToRedeem >= minBUIDLRedeemAmount) {\n      // amount of USDC needed is over minBUIDLRedeemAmount, do a BUIDL redemption\n      // to cover the full amount\n      _redeemBUIDL(usdcAmountToRedeem);\n    } else if (usdcAmountToRedeem > usdcBalance) {\n      // There isn't enough USDC held by this contract to cover the redemption,\n      // so we perform a BUIDL redemption of BUIDL's minimum required amount.\n      // The remaining amount of USDC will be held in the contract for future redemptions.\n      _redeemBUIDL(minBUIDLRedeemAmount);\n      emit MinimumBUIDLRedemption(\n        msg.sender,\n        minBUIDLRedeemAmount,\n        usdcBalance + minBUIDLRedeemAmount - usdcAmountToRedeem\n      );\n    } else {\n      // We have enough USDC sitting in this contract already, so use it\n      // to cover the redemption and fees without redeeming more BUIDL.\n      emit BUIDLRedemptionSkipped(\n        msg.sender,\n        usdcAmountToRedeem,\n        usdcBalance - usdcAmountToRedeem\n      );\n    }\n\n    if (usdcFees > 0) {\n      usdc.transfer(feeReceiver, usdcFees);\n    }\n    emit RedeemFeesDeducted(msg.sender, feeReceiver, usdcFees, usdcAmountOut);\n\n    usdc.transfer(msg.sender, usdcAmountOut);\n  }\n\n  function _redeemBUIDL(uint256 buidlAmountToRedeem) internal {\n    require(\n      buidl.balanceOf(address(this)) >= minBUIDLRedeemAmount,\n      \"OUSGInstantManager::_redeemBUIDL: Insufficient BUIDL balance\"\n    );\n    uint256 usdcBalanceBefore = usdc.balanceOf(address(this));\n    buidl.approve(address(buidlRedeemer), buidlAmountToRedeem);\n    buidlRedeemer.redeem(buidlAmountToRedeem);\n    require(\n      usdc.balanceOf(address(this)) == usdcBalanceBefore + buidlAmountToRedeem,\n      \"OUSGInstantManager::_redeemBUIDL: BUIDL:USDC not 1:1\"\n    );\n  }\n\n  /**\n   * @notice Returns the current price of OUSG in USDC\n   *\n   * @dev Sanity check: this function will revert if the price is unexpectedly low\n   *\n   * @return price The current price of OUSG in USDC\n   */\n  function getOUSGPrice() public view returns (uint256 price) {\n    (price, ) = oracle.getPriceData();\n    require(\n      price > MINIMUM_OUSG_PRICE,\n      \"OUSGInstantManager::getOUSGPrice: Price unexpectedly low\"\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Rate Limiter Configuration\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Set the mintLimit constraint inside the InstantMintTimeBasedRateLimiter\n   *         base contract\n   *\n   * @param _instantMintLimit New limit that dicates how much USDC can be transfered\n   *                     for minting in a specified duration\n   *                     (in 6 decimals per the USDC contract)\n   */\n  function setInstantMintLimit(\n    uint256 _instantMintLimit\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    _setInstantMintLimit(_instantMintLimit);\n  }\n\n  /**\n   * @notice Set the redeemLimit constraint inside the InstantMintTimeBasedRateLimiter\n   *         base contract\n   *\n   * @param _instantRedemptionLimit New limit that dicates how much USDC\n   *                       can be redeemed in a specified duration\n   *                       (in 6 decimals per the USDC contract)\n   */\n  function setInstantRedemptionLimit(\n    uint256 _instantRedemptionLimit\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    _setInstantRedemptionLimit(_instantRedemptionLimit);\n  }\n\n  /**\n   * @notice Sets mintLimitDuration constraint inside the InstantMintTimeBasedRateLimiter\n   *         base contract\n   *\n   * @param _instantMintLimitDuration New limit that specifies the interval\n   *                             (in seconds) in which only `mintLimit` USDC\n   *                             can be used for minting within\n   */\n  function setInstantMintLimitDuration(\n    uint256 _instantMintLimitDuration\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    _setInstantMintLimitDuration(_instantMintLimitDuration);\n  }\n\n  /**\n   * @notice Sets redeemLimitDuration inside the InstantMintTimeBasedRateLimiter\n   *         base contract\n   *\n   * @param _instantRedemptionLimitDuratioin New limit that specifies the interval\n   *                               (in seconds) in which only `redeemLimit` USDC\n   *                               can be redeemed within\n   */\n  function setInstantRedemptionLimitDuration(\n    uint256 _instantRedemptionLimitDuratioin\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    _setInstantRedemptionLimitDuration(_instantRedemptionLimitDuratioin);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Mint/Redeem Configuration\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Sets the mint fee\n   *\n   * @param _mintFee new mint fee specified in basis points\n   */\n  function setMintFee(\n    uint256 _mintFee\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    require(mintFee < 200, \"OUSGInstantManager::setMintFee: Fee too high\");\n    emit MintFeeSet(mintFee, _mintFee);\n    mintFee = _mintFee;\n  }\n\n  /**\n   * @notice Sets the redeem fee.\n   *\n   * @param _redeemFee new redeem fee specified in basis points\n   */\n  function setRedeemFee(\n    uint256 _redeemFee\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    require(redeemFee < 200, \"OUSGInstantManager::setRedeemFee: Fee too high\");\n    emit RedeemFeeSet(redeemFee, _redeemFee);\n    redeemFee = _redeemFee;\n  }\n\n  /**\n   * @notice Admin function to set the minimum amount required for a deposit\n   *\n   * @param _minimumDepositAmount The minimum amount required to submit a deposit\n   *                          request\n   */\n  function setMinimumDepositAmount(\n    uint256 _minimumDepositAmount\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    require(\n      _minimumDepositAmount >= FEE_GRANULARITY,\n      \"setMinimumDepositAmount: Amount too small\"\n    );\n\n    emit MinimumDepositAmountSet(minimumDepositAmount, _minimumDepositAmount);\n    minimumDepositAmount = _minimumDepositAmount;\n  }\n\n  /**\n   * @notice Admin function to set the minimum amount to redeem\n   *\n   * @param _minimumRedemptionAmount The minimum amount required to submit a\n   *                                 redemption request\n   */\n  function setMinimumRedemptionAmount(\n    uint256 _minimumRedemptionAmount\n  ) external override onlyRole(CONFIGURER_ROLE) {\n    require(\n      _minimumRedemptionAmount >= FEE_GRANULARITY,\n      \"setMinimumRedemptionAmount: Amount too small\"\n    );\n    emit MinimumRedemptionAmountSet(\n      minimumRedemptionAmount,\n      _minimumRedemptionAmount\n    );\n    minimumRedemptionAmount = _minimumRedemptionAmount;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    General Configuration\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to set the minimum amount required to redeem BUIDL\n   *\n   * @param _minimumBUIDLRedemptionAmount The minimum amount required to redeem BUIDL\n   */\n  function setMinimumBUIDLRedemptionAmount(\n    uint256 _minimumBUIDLRedemptionAmount\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    emit MinimumBUIDLRedemptionAmountSet(\n      minBUIDLRedeemAmount,\n      _minimumBUIDLRedemptionAmount\n    );\n    minBUIDLRedeemAmount = _minimumBUIDLRedemptionAmount;\n  }\n\n  /**\n   * @notice Admin function to set the oracle address\n   *\n   * @param _oracle The address of the oracle that provides the OUSG price\n   *                in USDC\n   */\n  function setOracle(\n    address _oracle\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    emit OracleSet(address(oracle), _oracle);\n    oracle = IRWAOracle(_oracle);\n  }\n\n  /**\n   * @notice Admin function to set the fee receiver address\n\n   * @param _feeReceiver The address to receive the mint and redemption fees\n   */\n  function setFeeReceiver(\n    address _feeReceiver\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_feeReceiver != address(0), \"FeeReceiver cannot be 0x0\");\n    emit FeeReceiverSet(feeReceiver, _feeReceiver);\n    feeReceiver = _feeReceiver;\n  }\n\n  /**\n   * @notice Admin function to set the optional investor-based rate limiter\n   *\n   * @param _investorBasedRateLimiter The address of the investor-based rate limiter contract\n   */\n  function setInvestorBasedRateLimiter(\n    address _investorBasedRateLimiter\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n    emit InvestorBasedRateLimiterSet(\n      address(investorBasedRateLimiter),\n      _investorBasedRateLimiter\n    );\n    investorBasedRateLimiter = IInvestorBasedRateLimiter(\n      _investorBasedRateLimiter\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                  Helper fee conversion functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Given a deposit amount and a price, returns the OUSG amount due\n   *\n   * @param usdcAmountIn The amount deposited in units of USDC\n   * @param price        The price at which to mint\n   */\n  function _getMintAmount(\n    uint256 usdcAmountIn,\n    uint256 price\n  ) internal view returns (uint256 ousgAmountOut) {\n    uint256 amountE36 = _scaleUp(usdcAmountIn) * 1e18;\n    ousgAmountOut = amountE36 / price;\n  }\n\n  /**\n   * @notice Given a redemption amount and a price, returns the USDC amount due\n   *\n   * @param ousgAmountBurned The amount of OUSG burned for a redemption\n   * @param price            The price at which to redeem\n   */\n  function _getRedemptionAmount(\n    uint256 ousgAmountBurned,\n    uint256 price\n  ) internal view returns (uint256 usdcOwed) {\n    uint256 amountE36 = ousgAmountBurned * price;\n    usdcOwed = _scaleDown(amountE36 / 1e18);\n  }\n\n  /**\n   * @notice Given amount of USDC, returns how much in fees are owed\n   *\n   * @param usdcAmount Amount of USDC to calculate fees\n   *                   (in 6 decimals)\n   */\n  function _getInstantMintFees(\n    uint256 usdcAmount\n  ) internal view returns (uint256) {\n    return (usdcAmount * mintFee) / FEE_GRANULARITY;\n  }\n\n  /**\n   * @notice Given amount of USDC, returns how much in fees are owed\n   *\n   * @param usdcAmount Amount USDC to calculate fees\n   *                   (in decimals of USDC)\n   */\n  function _getInstantRedemptionFees(\n    uint256 usdcAmount\n  ) internal view returns (uint256) {\n    return (usdcAmount * redeemFee) / FEE_GRANULARITY;\n  }\n\n  /**\n   * @notice Scale provided amount up by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting a USDC amount's decimals\n   *      representation to the rOUSG/OUSG decimals representation.\n   */\n  function _scaleUp(uint256 amount) internal view returns (uint256) {\n    return amount * decimalsMultiplier;\n  }\n\n  /**\n   * @notice Scale provided amount down by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting an rOUSG/OUSG amount's decimals\n   *      representation to the USDC decimals representation.\n   */\n  function _scaleDown(uint256 amount) internal view returns (uint256) {\n    return amount / decimalsMultiplier;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Pause/Unpause\n  //////////////////////////////////////////////////////////////*/\n\n  /// @notice Ensure that the mint functionality is not paused\n  modifier whenMintNotPaused() {\n    require(!mintPaused, \"OUSGInstantManager: Mint paused\");\n    _;\n  }\n\n  /// @notice Ensure that the redeem functionality is not paused\n  modifier whenRedeemNotPaused() {\n    require(!redeemPaused, \"OUSGInstantManager: Redeem paused\");\n    _;\n  }\n\n  /// @notice Pause the mint functionality\n  function pauseMint() external onlyRole(PAUSER_ROLE) {\n    mintPaused = true;\n    emit MintPaused();\n  }\n\n  /// @notice Unpause the mint functionality\n  function unpauseMint() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    mintPaused = false;\n    emit MintUnpaused();\n  }\n\n  /// @notice Pause the redeem functionality\n  function pauseRedeem() external onlyRole(PAUSER_ROLE) {\n    redeemPaused = true;\n    emit RedeemPaused();\n  }\n\n  /// @notice Unpause the redeem functionality\n  function unpauseRedeem() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    redeemPaused = false;\n    emit RedeemUnpaused();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Miscellaneous\n  //////////////////////////////////////////////////////////////*/\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  )\n    external\n    payable\n    override\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (bytes[] memory results)\n  {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function retrieveTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    IERC20(token).transfer(to, amount);\n  }\n}"
    },
    {
      "filename": "contracts/ousg/ousgInstantManager.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/ousg/rOUSG.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/interfaces/IBUIDLRedeemer.sol\";\nimport \"contracts/InstantMintTimeBasedRateLimiter.sol\";\nimport \"contracts/interfaces/IOUSGInstantManager.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\nimport \"contracts/interfaces/IInvestorBasedRateLimiter.sol\";\n\n/**\n * @title OUSGInstantManager\n * @author Ondo Finance\n * @notice This contract is responsible for minting\n *         and redeeming OUSG and rOUSG against USDC. Addresses\n *         with the DEFAULT_ADMIN_ROLE able to set optional mint and\n *         redeem fees. It is implemented in terms of a\n *         InstantMintTimeBasedRateLimiter, which imposes mint and redeem limits within\n *         specified intervals. Additionally, addresses with the PAUSER role in\n *         the registry can pause mints and redemptions, while addresses with\n *         the DEFAULT_ADMIN role can unpause mints or redemptions.\n *\n * @dev Please be aware of the differences of decimals representations between\n *      OUSG, rOUSG, USDC, and BUIDL. This contract multiplies\n *      or divides quantities by a scaling factor (see `decimalsMultiplier`) to\n *      account for this. Due to the way the difference in decimals is\n *      calculated, the decimals value of the usdc token MUST be less\n *      than or equal to OUSG's decimals value or else contract deployment\n *      will fail.\n */\ncontract OUSGInstantManager is\n  ReentrancyGuard,\n  InstantMintTimeBasedRateLimiter,\n  AccessControlEnumerable,\n  IOUSGInstantManager,\n  IMulticall\n{\n  // Role to configure the contract\n  bytes32 public constant CONFIGURER_ROLE = keccak256(\"CONFIGURER_ROLE\");\n\n  // Role to pause minting and redemptions\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // Safety circuit breaker in case of Oracle malfunction\n  uint256 public constant MINIMUM_OUSG_PRICE = 105e18;\n\n  // Helper constant that allows us to precisely specify fees in basis points\n  uint256 public constant FEE_GRANULARITY = 10_000;\n\n  // Helper constant that allows us to convert between OUSG and rOUSG shares\n  uint256 public constant OUSG_TO_ROUSG_SHARES_MULTIPLIER = 10_000;\n\n  // USDC contract\n  IERC20 public immutable usdc; // 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n  // OUSG contract\n  IRWALike public immutable ousg;\n\n  // Rebasing OUSG Contract\n  ROUSG public immutable rousg;\n\n  // BUIDL token contract\n  IERC20 public immutable buidl;\n\n  // Redeemer contract used for instant redemptions of BUIDL\n  IBUIDLRedeemer public immutable buidlRedeemer;\n\n  // Scaling factor to account for differences in decimals between OUSG/rOUSG and BUIDL/USDC\n  uint256 public immutable decimalsMultiplier;\n\n  // The address that receives USDC for subscriptions\n  address public immutable usdcReceiver;\n\n  // Address of the oracle that provides the `ousgPrice`\n  IRWAOracle public oracle;\n\n  // The address in which USDC should be sent to as a fee for minting and redeeming\n  address public feeReceiver;\n\n  // Fee collected when minting OUSG (in basis points)\n  uint256 public mintFee = 0;\n\n  // Fee collected when redeeming OUSG (in basis points)\n  uint256 public redeemFee = 0;\n\n  // Minimum amount of USDC that must be deposited to mint OUSG or rOUSG\n  // Denoted in 6 decimals for USDC\n  uint256 public minimumDepositAmount = 100_000e6;\n\n  // Minimum amount of USDC that must be redeemed for to redeem OUSG or rOUSG\n  // Denoted in 6 decimals for USDC\n  uint256 public minimumRedemptionAmount = 50_000e6;\n\n  // Whether minting is paused for this contract\n  bool public mintPaused;\n\n  // Whether redemptions are paused for this contract\n  bool public redeemPaused;\n\n  // The minimum amount of BUIDL that must be redeemed in a single rede"
    }
  ]
}