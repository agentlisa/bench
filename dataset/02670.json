{
  "Title": "Missing documentation",
  "Content": "Many of the functions, events, and variables within the codebase lack documentation.\n\n\nContracts that do not have a docstring:\n\n\n* [`SlashingLibrary`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/SlashingLibrary.sol)\n* [`SpamGuardIdentifierLib`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/SpamGuardIdentifierLib.sol)\n\n\nFunctions that do not have a docstring:\n\n\n* [`_getVotingContract`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol#L116) in [`DesignatedVotingV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol)\n* [`_executeCall`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/GovernorV2.sol#L185), [`_getOracle`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/GovernorV2.sol#L204), [`getIdentifierWhitelist`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/GovernorV2.sol#L208) in [`GovernorV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/GovernorV2.sol)\n* [`updateTrackers`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol#L248), [`getStartingIndexForStaker`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol#L314) in [`Staker.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol)\n* [`computeRoundToVoteOnPriceRequest`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VoteTimingV2.sol#L72) in [`VoteTimingV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VoteTimingV2.sol)\n* [`getNumberOfPriceRequests`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L724), [`_getPriceRequest`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1089), [`_encodePriceRequest`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1097), [`_freezeRoundVariables`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1105), [`_priceRequestResolved`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1116), [`_computeGat`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1153), [`_getRequestStatus`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1158), [`unsafe_inc`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1175), [`unsafe_inc_64`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1179), [`_getIdentifierWhitelist`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1183), [`_requireNotMigrated`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1187), [`_requireRegisteredContract`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1191) in [`VotingV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol)\n\n\nDocstrings that are incomplete:\n\n\n* [`commitVote`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol#L58) in [`DesignatedVotingV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol) is missing the @param for [`ancillaryData`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol#L61)\n* [`_constructIdentifier`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/SpamGuardIdentifierLib.sol#L6) in [`SpamGuardIdentifierLib.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/SpamGuardIdentifierLib.sol) is missing the @param for [`id`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/SpamGuardIdentifierLib.sol#L6)\n* [`init`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VoteTimingV2.sol#L18) in [`VoteTimingV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VoteTimingV2.sol) is missing the @param documentation for all input parameters\n* [`getVoterFromDelegate`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L646) in [`VotingV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol) is missing the @param for [`caller`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L646)\n* [`constructor`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L246) in [`VotingV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol) is missing the @param for [`_spamDeletionProposalBond`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L248) and [`_startingRequestIndex`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L253)\n\n\nMany events and storage variables throughout the codebase also lack explanatory comments.\n\n\nFinally, some useful documentation was recently removed:\n\n\n* Documentation for the [`NewProposal`](https://github.com/UMAprotocol/protocol/pull/4053/files#diff-7115f901768a60762580ebd95f1a17a7148600d6834b48dd1fe206ec1cfbba4fL50) and [`ProposalExexcuted`](https://github.com/UMAprotocol/protocol/pull/4053/files#diff-7115f901768a60762580ebd95f1a17a7148600d6834b48dd1fe206ec1cfbba4fL53) events in `GovernorV2.sol`\n* Documentation explaining the [`propose`](https://github.com/UMAprotocol/protocol/pull/4053/files#diff-7115f901768a60762580ebd95f1a17a7148600d6834b48dd1fe206ec1cfbba4fL96-L97) function’s public visibility in `GovernorV2.sol`\n\n\nMissing documentation hinder reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions that implement sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec). Also consider providing explanatory comments for all events, structs, and storage variables that indicate their intended purpose.\n\n\n**Update:** *Partially fixed as of commit [`3d68ad7fa471d4d763ab3ae9e6e5052bad1dce8e`](https://github.com/UMAprotocol/protocol/pull/4077/commits/3d68ad7fa471d4d763ab3ae9e6e5052bad1dce8e) in [pull request #4077](https://github.com/UMAprotocol/protocol/pull/4077). The following functions still lack docstrings:*\n\n\n* *[`getIdentifierWhitelist`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/GovernorV2.sol#L208) in [`GovernorV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/GovernorV2.sol)*\n* *[`updateTrackers`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol#L248), [`getStartingIndexForStaker`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol#L314) in [`Staker.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/Staker.sol)*\n* *[`_requireRegisteredContract`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol#L1191) in [`VotingV2.sol`](https://github.com/UMAprotocol/protocol/blob/7938617bf79854811959eb605237edf6bdccbc90/packages/core/contracts/oracle/implementation/VotingV2.sol)*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/DesignatedVotingV2.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/MultiCaller.sol\";\nimport \"../../common/implementation/Stakeable.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/VotingV2Interface.sol\";\nimport \"./Constants.sol\";\n\n/**\n * @title Proxy to allow voting from another address.\n * @dev Allows a UMA token holder to designate another address to vote on their behalf.\n * Each voter must deploy their own instance of this contract.\n */\ncontract DesignatedVotingV2 is Stakeable, MultiCaller {\n    /****************************************\n     *    INTERNAL VARIABLES AND STORAGE    *\n     ****************************************/\n\n    enum Roles {\n        Owner, // Can set the Voter role. Is also permanently permissioned as the minter role.\n        Voter // Can vote through this contract.\n    }\n\n    // Reference to the UMA Finder contract, allowing Voting upgrades to be performed\n    // without requiring any calls to this contract.\n    FinderInterface private finder;\n\n    /**\n     * @notice Construct the DesignatedVoting contract.\n     * @param finderAddress keeps track of all contracts within the system based on their interfaceName.\n     * @param ownerAddress address of the owner of the DesignatedVoting contract.\n     * @param voterAddress address to which the owner has delegated their voting power.\n     */\n    constructor(\n        address finderAddress,\n        address ownerAddress,\n        address voterAddress\n    ) {\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), ownerAddress);\n        _createExclusiveRole(uint256(Roles.Voter), uint256(Roles.Owner), voterAddress);\n        _setWithdrawRole(uint256(Roles.Owner));\n        _setStakeRole(uint256(Roles.Owner));\n\n        finder = FinderInterface(finderAddress);\n    }\n\n    /****************************************\n     *   VOTING AND REWARD FUNCTIONALITY    *\n     ****************************************/\n\n    /**\n     * @notice Forwards a commit to Voting.\n     * @param identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param hash the keccak256 hash of the price you want to vote for and a random integer salt value.\n     */\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingContract().commitVote(identifier, time, ancillaryData, hash);\n    }\n\n    /**\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingContract().commitAndEmitEncryptedVote(identifier, time, ancillaryData, hash, encryptedVote);\n    }\n\n    /**\n     * @notice Forwards a reveal to Voting.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price used along with the `salt` to produce the `hash` during the commit phase.\n     * @param salt used along with the `price` to produce the `hash` during the commit phase.\n     */\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingContract().revealVote(identifier, time, price, ancillaryData, salt);\n    }\n\n    /**\n     * @notice Forwards a reward retrieval to Voting.\n     * @dev Rewards are added to the tokens already held by this contract.\n     * @return amount of rewards that the user should receive.\n     */\n    function retrieveRewards() public onlyRoleHolder(uint256(Roles.Voter)) returns (uint256) {\n        StakerInterface voting = StakerInterface(address(_getVotingContract()));\n        uint256 rewardsMinted = voting.withdrawRewards();\n        IERC20(address(voting.votingToken())).approve(address(voting), rewardsMinted);\n        voting.stake(rewardsMinted);\n    }\n\n    function _getVotingContract() private view returns (VotingV2Interface) {\n        return VotingV2Interface(finder.getImplementationAddress(OracleInterfaces.Oracle));\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/GovernorV2.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/MultiRole.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleGovernanceInterface.sol\";\nimport \"./Constants.sol\";\nimport \"./AdminIdentifierLib.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Takes proposals for certain governance actions and allows UMA token holders to vote on them.\n */\ncontract GovernorV2 is MultiRole, Testable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    /****************************************\n     *     INTERNAL VARIABLES AND STORAGE   *\n     ****************************************/\n\n    enum Roles {\n        Owner, // Can set the proposer.\n        Proposer // Address that can make proposals.\n    }\n\n    struct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    struct Proposal {\n        Transaction[] transactions;\n        uint256 requestTime;\n        bytes ancillaryData;\n    }\n\n    FinderInterface private finder;\n    Proposal[] public proposals;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event NewProposal(uint256 indexed id, Transaction[] transactions);\n\n    event ProposalExecuted(uint256 indexed id, uint256 transactionIndex);\n\n    /**\n     * @notice Construct the Governor contract.\n     * @param _finderAddress keeps track of all contracts within the system based on their interfaceName.\n     * @param _startingId the initial proposal id that the contract will begin incrementing from.\n     * @param _timerAddress Contract that stores the current time in a testing environment.\n     * Must be set to 0x0 for production environments that use live time.\n     */\n    constructor(\n        address _finderAddress,\n        uint256 _startingId,\n        address _timerAddress\n    ) Testable(_timerAddress) {\n        finder = FinderInterface(_finderAddress);\n        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n        _createExclusiveRole(uint256(Roles.Proposer), uint256(Roles.Owner), msg.sender);\n\n        // Ensure the startingId is not set unreasonably high to avoid it being set such that new proposals overwrite\n        // other storage slots in the contract.\n        uint256 maxStartingId = 10**18;\n        require(_startingId <= maxStartingId, \"Cannot set startingId larger than 10^18\");\n\n        // Sets the initial length of the array to the startingId. Modifying length directly has been disallowed in solidity 0.6.\n        assembly {\n            sstore(proposals.slot, _startingId)\n        }\n    }\n\n    /****************************************\n     *          PROPOSAL ACTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\n     * @param transactions list of transactions that are being proposed.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function propose(Transaction[] memory transactions, bytes memory ancillaryData)\n        public\n        onlyRoleHolder(uint256(Roles.Proposer))\n    {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n        proposal.ancillaryData = ancillaryData;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = AdminIdentifierLib._constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        _getOracle().requestGovernanceAction(identifier, time, ancillaryData);\n\n        emit NewProposal(id, transactions);\n    }\n\n    /**\n     * @notice Executes a proposed governance action that has been approved by voters.\n     * @dev This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.\n     * @param id unique id for the executed proposal.\n     * @param transactionIndex unique transaction index for the executed proposal.\n     */\n    function executeProposal(uint256 id, uint256 transactionIndex) external payable {\n        Proposal storage proposal = proposals[id];\n        int256 price =\n            _getOracle().getPrice(\n                AdminIdentifierLib._constructIdentifier(id),\n                proposal.requestTime,\n                proposal.ancillaryData\n            );\n\n        Transaction memory transaction = proposal.transactions[transactionIndex];\n\n        require(\n            transactionIndex == 0 || proposal.transactions[transactionIndex.sub(1)].to == address(0),\n            \"Previous tx not yet executed\"\n        );\n        require(transaction.to != address(0), \"Tx already executed\");\n        require(price != 0, \"Proposal was rejected\");\n        require(msg.value == transaction.value, \"Must send exact amount of ETH\");\n\n        // Delete the transaction before execution to avoid any potential re-entrancy issues.\n        delete proposal.transactions[transactionIndex];\n\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Tx execution failed\");\n\n        emit ProposalExecuted(id, transactionIndex);\n    }\n\n    /****************************************\n     *       GOVERNOR STATE GETTERS         *\n     ****************************************/\n\n    /**\n     * @notice Gets the total number of proposals (includes executed and non-executed).\n     * @return uint256 representing the current number of proposals.\n     */\n    function numProposals() external view returns (uint256) {\n        return proposals.length;\n    }\n\n    /**\n     * @notice Gets the proposal data for a particular id.\n     * @dev after a proposal is executed, its data will be zeroed out, except for the request time.\n     * @param id uniquely identify the identity of the proposal.\n     * @return proposal struct containing transactions[] and requestTime.\n     */\n    function getProposal(uint256 id) external view returns (Proposal memory) {\n        return proposals[id];\n    }\n\n    /****************************************\n     *      PRIVATE GETTERS AND FUNCTIONS   *\n     ****************************************/\n\n    function _executeCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) private returns (bool) {\n        // Mostly copied from:\n        // solhint-disable-next-line max-line-length\n        // https://github.com/gnosis/safe-contracts/blob/59cfdaebcd8b87a0a32f87b50fead092c10d3a05/contracts/base/Executor.sol#L23-L31\n        // solhint-disable-next-line no-inline-assembly\n\n        bool success;\n        assembly {\n            let inputData := add(data, 0x20)\n            let inputDataSize := mload(data)\n            success := call(gas(), to, value, inputData, inputDataSize, 0, 0)\n        }\n        return success;\n    }\n\n    function _getOracle() private view returns (OracleGovernanceInterface) {\n        return OracleGovernanceInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\n    }\n\n    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/Staker.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/Testable.sol\";\n\nimport \"./VotingToken.sol\";\nimport \"../interfaces/StakerInterface.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Staking contract enabling UMA to be locked up by stakers to earn a prorate share of a fixed emission rate.\n * @dev Handles the staking, unstaking and reward retrieval logic.\n */\ncontract Staker is StakerInterface, Ownable {\n    /****************************************\n     *           STAKING TRACKERS           *\n     ****************************************/\n\n    uint256 public emissionRate;\n    uint256 public cumulativeActiveStake;\n    uint256 public cumulativePendingStake;\n    uint256 public rewardPerTokenStored;\n\n    VotingToken public override votingToken;\n    uint64 public lastUpdateTime;\n    uint64 public unstakeCoolDown;\n\n    struct VoterStake {\n        uint256 activeStake;\n        uint256 pendingUnstake;\n        uint256 pendingStake;\n        uint256 rewardsPaidPerToken;\n        uint256 outstandingRewards;\n        uint64 lastRequestIndexConsidered;\n        uint64 unstakeRequestTime;\n        address delegate;\n    }\n\n    mapping(address => VoterStake) public voterStakes;\n    mapping(address => address) public delegateToStaker;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event Staked(\n        address indexed voter,\n        uint256 amount,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 voterPendingUnStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event RequestedUnstake(\n        address indexed voter,\n        uint256 amount,\n        uint256 unstakeTime,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event ExecutedUnstake(\n        address indexed voter,\n        uint256 tokensSent,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake\n    );\n\n    event WithdrawnRewards(address indexed voter, uint256 tokensWithdrawn);\n\n    event UpdatedReward(address indexed voter, uint256 newReward, uint256 lastUpdateTime);\n\n    event UpdatedActiveStake(\n        address indexed voter,\n        uint256 voterActiveStake,\n        uint256 voterPendingStake,\n        uint256 cumulativeActiveStake,\n        uint256 cumulativePendingStake\n    );\n\n    event SetNewEmissionRate(uint256 newEmissionRate);\n\n    event SetNewUnstakeCooldown(uint256 newUnstakeCooldown);\n\n    /**\n     * @notice Construct the Staker contract\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate to stakers.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     *  to be voted on in the next round. If after this, the request is rolled to a round after the next round.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     */\n    constructor(\n        uint256 _emissionRate,\n        uint64 _unstakeCoolDown,\n        address _votingToken\n    ) {\n        emissionRate = _emissionRate;\n        unstakeCoolDown = _unstakeCoolDown;\n        votingToken = VotingToken(_votingToken);\n    }\n\n    /****************************************\n     *           STAKER FUNCTIONS           *\n     ****************************************/\n\n    /**\n     * @notice Pulls tokens from users wallet and stakes them. If we are in a active reveal phase the stake amount will\n     * be added to the pending stake. If not, the stake amount will be added to the active stake.\n     * @param amount the amount of tokens to stake.\n     */\n    function stake(uint256 amount) public override {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        // If the staker has a cumulative staked balance of 0 then we can shortcut their lastRequestIndexConsidered to\n        // the most recent index. This means we don't need to traverse requests where the staker was not staked.\n        // getStartingIndexForStaker returns the appropriate index to start at.\n        if (getVoterStake(msg.sender) + voterStake.pendingUnstake == 0)\n            voterStake.lastRequestIndexConsidered = getStartingIndexForStaker();\n        _updateTrackers(msg.sender);\n\n        if (inActiveReveal()) {\n            voterStake.pendingStake += amount;\n            cumulativePendingStake += amount;\n        } else {\n            voterStake.activeStake += amount;\n            cumulativeActiveStake += amount;\n        }\n\n        votingToken.transferFrom(msg.sender, address(this), amount);\n        emit Staked(\n            msg.sender,\n            amount,\n            voterStake.activeStake,\n            voterStake.pendingStake,\n            voterStake.pendingUnstake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n\n    /**\n     * @notice Request a certain number of tokens to be unstaked. After the unstake time expires, the user may execute\n     * the unstake. Tokens requested to unstake are not slashable nor subject to earning rewards.\n     * This function cannot be called during an active reveal phase.\n     * Note that there is no way to cancel an unstake request, you must wait until after unstakeRequestTime and re-stake.\n     * @param amount the amount of tokens to request to be unstaked.\n     */\n    function requestUnstake(uint256 amount) public override {\n        require(!inActiveReveal(), \"In an active reveal phase\");\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];\n\n        require(voterStake.activeStake >= amount, \"Bad request amount\");\n        require(voterStake.pendingUnstake == 0, \"Have previous request unstake\");\n\n        cumulativeActiveStake -= amount;\n        voterStake.pendingUnstake = amount;\n        voterStake.activeStake -= amount;\n        voterStake.unstakeRequestTime = SafeCast.toUint64(getCurrentTime());\n\n        emit RequestedUnstake(\n            msg.sender,\n            amount,\n            voterStake.unstakeRequestTime,\n            voterStake.activeStake,\n            voterStake.pendingStake\n        );\n    }\n\n    /**\n     * @notice  Execute a previously requested unstake. Requires the unstake time to have passed.\n     * @dev If a staker requested an unstake and time > unstakeRequestTime then send funds to staker. Note that this\n     * method assumes that the `updateTrackers().\n     */\n    function executeUnstake() public override {\n        VoterStake storage voterStake = voterStakes[msg.sender];\n        require(\n            voterStake.unstakeRequestTime != 0 && getCurrentTime() >= voterStake.unstakeRequestTime + unstakeCoolDown,\n            \"Unstake time not passed\"\n        );\n        uint256 tokensToSend = voterStake.pendingUnstake;\n\n        if (tokensToSend > 0) {\n            voterStake.pendingUnstake = 0;\n            voterStake.unstakeRequestTime = 0;\n            votingToken.transfer(msg.sender, tokensToSend);\n        }\n\n        emit ExecutedUnstake(msg.sender, tokensToSend, voterStake.activeStake, voterStake.pendingStake);\n    }\n\n    /**\n     * @notice Send accumulated rewards to the voter. Note that these rewards do not include slashing balance changes.\n     * @return uint256 the amount of tokens sent to the voter.\n     */\n    function withdrawRewards() public override returns (uint256) {\n        _updateTrackers(msg.sender);\n        VoterStake storage voterStake = voterStakes[msg.sender];\n\n        uint256 tokensToMint = voterStake.outstandingRewards;\n        if (tokensToMint > 0) {\n            voterStake.outstandingRewards = 0;\n            require(votingToken.mint(msg.sender, tokensToMint), \"Voting token issuance failed\");\n        }\n        emit WithdrawnRewards(msg.sender, tokensToMint);\n        return (tokensToMint);\n    }\n\n    /**\n     * @notice Stake accumulated rewards. This is just a convenience method that combines withdraw with stake in the\n     * same transaction.\n     * @dev this method requires that the user has approved this contract.\n     * @return uint256 the amount of tokens that the user is staking.\n     */\n    function withdrawAndRestake() public returns (uint256) {\n        uint256 rewards = withdrawRewards();\n        stake(rewards);\n        return rewards;\n    }\n\n    /****************************************\n     *        OWNER ADMIN FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice  Set the token's emission rate, the number of voting tokens that are emitted per second per staked token,\n     * split prorate to stakers.\n     * @param _emissionRate the new amount of voting tokens that are emitted per second, split prorate to stakers.\n     */\n    function setEmissionRate(uint256 _emissionRate) public onlyOwner {\n        _updateReward(address(0));\n        emissionRate = _emissionRate;\n        emit SetNewEmissionRate(emissionRate);\n    }\n\n    /**\n     * @notice  Set the amount of time a voter must wait to unstake after submitting a request to do so.\n     * @param _unstakeCoolDown the new duration of the cool down period in seconds.\n     */\n    function setUnstakeCoolDown(uint64 _unstakeCoolDown) public onlyOwner {\n        unstakeCoolDown = _unstakeCoolDown;\n        emit SetNewUnstakeCooldown(unstakeCoolDown);\n    }\n\n    function _updateTrackers(address voterAddress) internal virtual {\n        _updateReward(voterAddress);\n        _updateActiveStake(voterAddress);\n    }\n\n    /****************************************\n     *            VIEW FUNCTIONS            *\n     ****************************************/\n\n    /**\n     * @notice  Determine the number of outstanding token rewards that can be withdrawn by a voter.\n     * @param voterAddress the address of the voter.\n     * @return uint256 the outstanding rewards.\n     */\n    function outstandingRewards(address voterAddress) public view returns (uint256) {\n        VoterStake storage voterStake = voterStakes[voterAddress];\n\n        return\n            ((getVoterStake(voterAddress) * (rewardPerToken() - voterStake.rewardsPaidPerToken)) / 1e18) +\n            voterStake.outstandingRewards;\n    }\n\n    /**\n     * @notice  Calculate the reward per token based on the last time the reward was updated.\n     * @return uint256 the reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (getCumulativeStake() == 0) return rewardPerTokenStored;\n        return\n            rewardPerTokenStored + ((getCurrentTime() - lastUpdateTime) * emissionRate * 1e18) / getCumulativeStake();\n    }\n\n    /**\n     * @notice  Returns the total amount of tokens staked. This is the sum of the active stake and the pending stake.\n     * @return uint256 the cumulative stake.\n     */\n    function getCumulativeStake() public view returns (uint256) {\n        return cumulativeActiveStake + cumulativePendingStake;\n    }\n\n    /**\n     * @notice  Returns the total amount of tokens staked by the voter.\n     * @param voterAddress the address of the voter.\n     * @return uint256 the total stake.\n     */\n    function getVoterStake(address voterAddress) public view returns (uint256) {\n        return voterStakes[voterAddress].activeStake + voterStakes[voterAddress].pendingStake;\n    }\n\n    /**\n     * @notice Returns the current block timestamp.\n     * @dev Can be overridden to control contract time.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS          *\n     ****************************************/\n\n    // Determine if we are in an active reveal phase. This function should be overridden by the child contract.\n    function inActiveReveal() internal virtual returns (bool) {\n        return false;\n    }\n\n    function getStartingIndexForStaker() internal virtual returns (uint64) {\n        return 0;\n    }\n\n    // Calculate the reward per token based on last time the reward was updated.\n    function _updateReward(address voterAddress) internal {\n        uint256 newRewardPerToken = rewardPerToken();\n        rewardPerTokenStored = newRewardPerToken;\n        lastUpdateTime = SafeCast.toUint64(getCurrentTime());\n        if (voterAddress != address(0)) {\n            VoterStake storage voterStake = voterStakes[voterAddress];\n            voterStake.outstandingRewards = outstandingRewards(voterAddress);\n            voterStake.rewardsPaidPerToken = newRewardPerToken;\n        }\n        emit UpdatedReward(voterAddress, newRewardPerToken, lastUpdateTime);\n    }\n\n    // Updates the active stake of the voter if not in an active reveal phase.\n    function _updateActiveStake(address voterAddress) internal {\n        if (voterStakes[voterAddress].pendingStake == 0 || inActiveReveal()) return;\n        cumulativeActiveStake += voterStakes[voterAddress].pendingStake;\n        cumulativePendingStake -= voterStakes[voterAddress].pendingStake;\n        voterStakes[voterAddress].activeStake += voterStakes[voterAddress].pendingStake;\n        voterStakes[voterAddress].pendingStake = 0;\n\n        emit UpdatedActiveStake(\n            voterAddress,\n            voterStakes[voterAddress].activeStake,\n            voterStakes[voterAddress].pendingStake,\n            cumulativeActiveStake,\n            cumulativePendingStake\n        );\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/VoteTimingV2.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../interfaces/VotingV2Interface.sol\";\n\n/**\n * @title Library to compute rounds and phases for an equal length commit-reveal voting cycle.\n */\nlibrary VoteTimingV2 {\n    struct Data {\n        uint256 phaseLength;\n        uint256 minRollToNextRoundLength;\n    }\n\n    /**\n     * @notice Initializes the data object. Sets the phase length based on the input.\n     */\n    function init(\n        Data storage data,\n        uint256 phaseLength,\n        uint256 minRollToNextRoundLength\n    ) internal {\n        // This should have a require message but this results in an internal Solidity error.\n        require(phaseLength > 0);\n        require(minRollToNextRoundLength <= phaseLength);\n        data.phaseLength = phaseLength;\n        data.minRollToNextRoundLength = minRollToNextRoundLength;\n    }\n\n    /**\n     * @notice Computes the roundID based off the current time as floor(timestamp/roundLength).\n     * @dev The round ID depends on the global timestamp but not on the lifetime of the system.\n     * The consequence is that the initial round ID starts at an arbitrary number (that increments, as expected, for subsequent rounds) instead of zero or one.\n     * @param data input data object.\n     * @param currentTime input unix timestamp used to compute the current roundId.\n     * @return roundId defined as a function of the currentTime and `phaseLength` from `data`.\n     */\n    function computeCurrentRoundId(Data storage data, uint256 currentTime) internal view returns (uint256) {\n        uint256 roundLength = data.phaseLength * uint256(VotingV2Interface.Phase.NUM_PHASES_PLACEHOLDER);\n        return currentTime / roundLength;\n    }\n\n    /**\n     * @notice compute the round end time as a function of the round Id.\n     * @param data input data object.\n     * @param roundId uniquely identifies the current round.\n     * @return timestamp unix time of when the current round will end.\n     */\n    function computeRoundEndTime(Data storage data, uint256 roundId) internal view returns (uint256) {\n        uint256 roundLength = data.phaseLength * uint256(VotingV2Interface.Phase.NUM_PHASES_PLACEHOLDER);\n        return roundLength * (roundId + 1);\n    }\n\n    /**\n     * @notice Computes the current phase based only on the current time.\n     * @param data input data object.\n     * @param currentTime input unix timestamp used to compute the current roundId.\n     * @return current voting phase based on current time and vote phases configuration.\n     */\n    function computeCurrentPhase(Data storage data, uint256 currentTime)\n        internal\n        view\n        returns (VotingV2Interface.Phase)\n    {\n        // This employs some hacky casting. We could make this an if-statement if we're worried about type safety.\n        return\n            VotingV2Interface.Phase(\n                (currentTime / data.phaseLength) % uint256(VotingV2Interface.Phase.NUM_PHASES_PLACEHOLDER)\n            );\n    }\n\n    function computeRoundToVoteOnPriceRequest(Data storage data, uint256 currentTime) internal view returns (uint256) {\n        uint256 currentRoundId = computeCurrentRoundId(data, currentTime);\n        uint256 roundEndTime = computeRoundEndTime(data, currentRoundId);\n        if (currentTime >= roundEndTime - data.minRollToNextRoundLength) return currentRoundId + 2;\n        else return currentRoundId + 1;\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/oracle/implementation/VotingV2.sol",
      "content": "// TODO: this whole /oracle/implementation directory should be restructured to separate the DVM and the OO.\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/implementation/MultiCaller.sol\";\n\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"../interfaces/OracleGovernanceInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"../interfaces/VotingV2Interface.sol\";\nimport \"./Constants.sol\";\nimport \"./Registry.sol\";\nimport \"./ResultComputationV2.sol\";\nimport \"./SlashingLibrary.sol\";\nimport \"./SpamGuardIdentifierLib.sol\";\nimport \"./Staker.sol\";\nimport \"./VoteTimingV2.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title VotingV2 contract for UMA's DVM mechanism.\n * @dev Handles receiving and resolving price requests via a commit-reveal voting schelling scheme.\n */\n\ncontract VotingV2 is\n    Staker,\n    OracleInterface,\n    OracleAncillaryInterface,\n    OracleGovernanceInterface,\n    VotingV2Interface,\n    MultiCaller\n{\n    using VoteTimingV2 for VoteTimingV2.Data;\n    using ResultComputationV2 for ResultComputationV2.Data;\n\n    /****************************************\n     *        VOTING DATA STRUCTURES        *\n     ****************************************/\n\n    // Identifies a unique price request. Tracks ongoing votes as well as the result of the vote.\n    struct PriceRequest {\n        // If in the past, this was the voting round where this price was resolved. If current or the upcoming round,\n        // this is the voting round where this price will be voted on, but not necessarily resolved.\n        uint32 lastVotingRound;\n        // Denotes whether this is a governance request or not.\n        bool isGovernance;\n        // The pendingRequestIndex in the `pendingPriceRequests` that references this PriceRequest. A value of UINT_MAX\n        //"
    }
  ]
}