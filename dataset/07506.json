{
  "Title": "[M-01] Escher721 contract does not have setTokenRoyalty function",
  "Content": "\nOn the Code4rena page of this contest there is a \"SALES PATTERNS\" section that describes the flow of how to use Sales:\n\n<https://code4rena.com/contests/2022-12-escher-contest>\n\nIt contains this statement:\n\n> If the artist would like sales and royalties to go somewhere other than the default royalty receiver, they\\\n> must call setTokenRoyalty with the following variables\n\nSo an artist should be able to call the `setTokenRoyalty` function on the `Escher721` contract.\n\nHowever this function cannot be called. It does not exist. There exists a `_setTokenRoyalty` in `ERC2981.sol` from OpenZeppelin. This function however is `internal` (<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3d7a93876a2e5e1d7fe29b5a0e96e222afdc4cfa/contracts/token/common/ERC2981.sol#L94>).\n\nSo there is no `setTokenRoyalty` function that can be called by the artist. So an artist cannot set a royalty individually for a token as is stated in the documentation.\n\n### Proof of Concept\n\nI tried calling `setTokenRoyalty` from inside `Escher721.t.sol` with the following test:\n\n```solidity\nfunction test_setDefaultRoyalty() public {\n    edition.setTokenRoyalty(1,address(this), 5);\n}\n```\n\nThis won't even compile because the `setTokenRoyalty` function does not exist.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nIn order to expose the internal `_setTokenRoyalty` function to the artist, add the following function to the `Escher721` contract:\n\n```solidity\nfunction setTokenRoyalty(\n    uint256 tokenId,\n    address receiver,\n    uint96 feeNumerato r\n) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setTokenRoyalty(tokenId,receiver,feeNumerator);\n}\n```\n\n**[mehtaculous (Escher) disputed](https://github.com/code-423n4/2022-12-escher-findings/issues/181)** \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-escher-contest",
  "Code": [
    {
      "filename": "contracts/token/common/ERC2981.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IERC2981.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n *\n * _Available since v4.5._\n */\nabstract contract ERC2981 is IERC2981, ERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC2981\n     */\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\n\n        if (royalty.receiver == address(0)) {\n            royalty = _defaultRoyaltyInfo;\n        }\n\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: invalid receiver\");\n\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(\n        uint256 tokenId,\n        address receiver,\n        uint96 feeNumerator\n    ) internal virtual {\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: Invalid parameters\");\n\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        delete _tokenRoyaltyInfo[tokenId];\n    }\n}"
    }
  ]
}