{
  "Title": "[G-09] Short-circuit rules can be used to optimize some gas usage",
  "Content": "- Severity: Gas Optimization\n- Confidence: Medium\n- Total Gas Saved: 2100\n\n### Note \nI reported issue that was overlooked by the winning bot.\n\n### Description\nSome conditions may be reordered to save an SLOAD (2100 gas), as we avoid reading state variables when the first part of the condition fails (with &&), or succeeds (with ||). For instance, consider a scenario where you have a `stateVariable` (a variable stored in contract storage) and a `localVariable` (a variable in memory). \n\nIf you have a condition like `stateVariable > 0 && localVariable > 0`, if `localVariable > 0` is false, the Solidity runtime will still execute `stateVariable > 0`, which costs an SLOAD operation (2100 gas). However, if you reorder the condition to `localVariable > 0 && stateVariable > 0`, the `stateVariable > 0` check won't happen if `localVariable > 0` is false, saving you the SLOAD gas cost.\n\nSimilarly, for the `||` operator, if you have a condition like `stateVariable > 0 || localVariable > 0`, and `stateVariable > 0` is true, the Solidity runtime will still execute `localVariable > 0`. But if you reorder the condition to `localVariable > 0 || stateVariable > 0`, and `localVariable > 0` is true, the `stateVariable > 0` check won't happen, again saving you the SLOAD gas cost.\n\nThis detector checks for such conditions in the contract and reports if any condition could be optimized by taking advantage of the short-circuiting behavior of `&&` and `||`.\n\n<details>\n\n<summary>\nThere are 1 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 158          _poolId != 0 && balances[_token] != 0 && !isTokenStaked[_token]\n```\n\n```\n // @audit: Switch ! isTokenStaked[_token] && _poolId != 0 && balances[_token] != 0 \n```\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L158](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L158)\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\nimport {IVirtualBalanceRewardPool} from '@interfaces/utils/IVirtualBalanceRewardPool.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {SafeERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {ICVX} from '@interfaces/utils/ICVX.sol';\n\n/// @notice Vault contract, our implementation of maker-vault like vault\n/// @dev Major differences:\n/// 1. multi-collateral\n/// 2. generate interest in USDA\ncontract Vault is IVault, Context {\n  using SafeERC20Upgradeable for IERC20;\n\n  /// @dev The CVX token\n  ICVX public immutable CVX;\n\n  /// @dev The CRV token\n  IERC20 public immutable CRV;\n\n  /// @dev The vault controller\n  IVaultController public immutable CONTROLLER;\n\n  /// @dev Metadata of vault, aka the id & the minter's address\n  VaultInfo public vaultInfo;\n\n  /// @dev This is the unscaled liability of the vault.\n  /// The number is meaningless on its own, and must be combined with the factor taken from\n  /// the vaultController in order to find the true liabilitiy\n  uint256 public baseLiability;\n\n  /// @dev Keeps track of the accounting of the collateral deposited\n  mapping(address => uint256) public balances;\n\n  /// @dev Keeps track of the tokens that are staked on convex\n  mapping(address => bool) public isTokenStaked;\n\n  /// @notice Checks if _msgSender is the controller of the vault\n  modifier onlyVaultController() {\n    if (_msgSender() != address(CONTROLLER)) revert Vault_NotVaultController();\n    _;\n  }\n\n  /// @notice Checks if _msgSender is the minter of the vault\n  modifier onlyMinter() {\n    if (_msgSender() != vaultInfo.minter) revert Vault_NotMinter();\n    _;\n  }\n\n  /// @dev Must be called by VaultController, else it will not be registered as a vault in system\n  /// @param _id Unique id of the vault, ever increasing and tracked by VaultController\n  /// @param _minter Address of the person who created this vault\n  /// @param _controllerAddress Address of the VaultController\n  /// @param _cvx Address of CVX token\n  /// @param _crv Address of CRV token\n  constructor(uint96 _id, address _minter, address _controllerAddress, IERC20 _cvx, IERC20 _crv) {\n    vaultInfo = VaultInfo(_id, _minter);\n    CONTROLLER = IVaultController(_controllerAddress);\n    CVX = ICVX(address(_cvx));\n    CRV = _crv;\n  }\n\n  /// @notice Returns the minter of the vault\n  /// @return _minter The address of minter\n  function minter() external view override returns (address _minter) {\n    _minter = vaultInfo.minter;\n  }\n\n  /// @notice Returns the id of the vault\n  /// @return _id The id of the vault\n  function id() external view override returns (uint96 _id) {\n    _id = vaultInfo.id;\n  }\n\n  /// @notice Used to deposit a token to the vault\n  /// @dev    Deposits and stakes on convex if token is of type CurveLPStakedOnConvex\n  /// @param _token The address of the token to deposit\n  /// @param _amount The amount of the token to deposit\n  function depositERC20(address _token, uint256 _amount) external override onlyMinter {\n    if (CONTROLLER.tokenId(_token) == 0) revert Vault_TokenNotRegistered();\n    if (_amount == 0) revert Vault_AmountZero();\n    SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(this), _amount);\n    if (CONTROLLER.tokenCollateralType(_token) == IVaultController.CollateralType.CurveLPStakedOnConvex) {\n      uint256 _poolId = CONTROLLER.tokenPoolId(_token);\n      /// If it's type CurveLPStakedOnConvex then pool id can't be 0\n      IBooster _booster = CONTROLLER.BOOSTER();\n      if (isTokenStaked[_token]) {\n        /// In this case the user's balance is already staked so we only stake the newly deposited amount\n        _depositAndStakeOnConvex(_token, _booster, _amount, _poolId);\n      } else {\n        /// In this case the user's balance isn't staked so we stake the amount + his balance for the specific tokenv\n        isTokenStaked[_token] = true;\n        _depositAndStakeOnConvex(_token, _booster, balances[_token] + _amount, _poolId);\n      }\n    }\n    balances[_token] += _amount;\n    CONTROLLER.modifyTotalDeposited(vaultInfo.id, _amount, _token, true);\n    emit Deposit(_token, _amount);\n  }\n\n  /// @notice Withdraws an erc20 token from the vault\n  /// @dev    This can only be called by the minter\n  ///         The withdraw will be denied if ones vault would become insolvent\n  ///         If the withdraw token is of CurveLPStakedOnConvex then unstake and withdraw directly to user\n  /// @param _tokenAddress The address of erc20 token\n  /// @param _amount The amount of erc20 token to withdraw\n  function withdrawERC20(address _tokenAddress, uint256 _amount) external override onlyMinter {\n    if (CONTROLLER.tokenId(_tokenAddress) == 0) revert Vault_TokenNotRegistered();\n    if (isTokenStaked[_tokenAddress]) {\n      if (!CONTROLLER.tokenCrvRewardsContract(_tokenAddress).withdrawAndUnwrap(_amount, false)) {\n        revert Vault_WithdrawAndUnstakeOnConvexFailed();\n      }\n    }\n    // reduce balance\n    balances[_tokenAddress] -= _amount;\n    // check if the account is solvent\n    if (!CONTROLLER.checkVault(vaultInfo.id)) revert Vault_OverWithdrawal();\n    // transfer the token to the owner\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_tokenAddress), _msgSender(), _amount);\n    // modify total deposited\n    CONTROLLER.modifyTotalDeposited(vaultInfo.id, _amount, _tokenAddress, false);\n    emit Withdraw(_tokenAddress, _amount);\n  }\n\n  /// @notice Let's the user manually stake their crvLP\n  /// @dev    This can be called if the convex pool didn't exist when the token was registered\n  ///         and was later updated\n  /// @param _tokenAddress The address of erc20 crvLP token\n  function stakeCrvLPCollateral(address _tokenAddress) external override onlyMinter {\n    uint256 _poolId = CONTROLLER.tokenPoolId(_tokenAddress);\n    if (_poolId == 0) revert Vault_TokenCanNotBeStaked();\n    if (balances[_tokenAddress] == 0) revert Vault_TokenZeroBalance();\n    if (isTokenStaked[_tokenAddress]) revert Vault_TokenAlreadyStaked();\n\n    isTokenStaked[_tokenAddress] = true;\n\n    IBooster _booster = CONTROLLER.BOOSTER();\n    _depositAndStakeOnConvex(_tokenAddress, _booster, balances[_tokenAddress], _poolId);\n\n    emit Staked(_tokenAddress, balances[_tokenAddress]);\n  }\n\n  /// @notice Returns true when user can manually stake their token balance\n  /// @param _token The address of the token to check\n  /// @return _canStake Returns true if the token can be staked manually\n  function canStake(address _token) external view override returns (bool _canStake) {\n    uint256 _poolId = CONTROLLER.tokenPoolId(_token);\n    if (_poolId != 0 && balances[_token] != 0 && !isTokenStaked[_token]) _canStake = true;\n  }\n\n  /// @notice Claims available rewards from multiple tokens\n  /// @dev    Transfers a percentage of the crv and cvx rewards to claim AMPH tokens\n  /// @param _tokenAddresses The addresses of the erc20 tokens\n  function claimRewards(address[] memory _tokenAddresses) external override onlyMinter {\n    uint256 _totalCrvReward;\n    uint256 _totalCvxReward;\n\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n    for (uint256 _i; _i < _tokenAddresses.length;) {\n      IVaultController.CollateralInfo memory _collateralInfo = CONTROLLER.tokenCollateralInfo(_tokenAddresses[_i]);\n      if (_collateralInfo.tokenId == 0) revert Vault_TokenNotRegistered();\n      if (_collateralInfo.collateralType != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n        revert Vault_TokenNotCurveLP();\n      }\n\n      IBaseRewardPool _rewardsContract = _collateralInfo.crvRewardsContract;\n      uint256 _crvReward = _rewardsContract.earned(address(this));\n\n      if (_crvReward != 0) {\n        // Claim the CRV reward\n        _totalCrvReward += _crvReward;\n        _rewardsContract.getReward(address(this), false);\n        _totalCvxReward += _calculateCVXReward(_crvReward);\n      }\n\n      // Loop and claim all virtual rewards\n      uint256 _extraRewards = _rewardsContract.extraRewardsLength();\n      for (uint256 _j; _j < _extraRewards;) {\n        IVirtualBalanceRewardPool _virtualReward = _rewardsContract.extraRewards(_j);\n        IERC20 _rewardToken = _virtualReward.rewardToken();\n        uint256 _earnedReward = _virtualReward.earned(address(this));\n        if (_earnedReward != 0) {\n          _virtualReward.getReward();\n          _rewardToken.transfer(_msgSender(), _earnedReward);\n          emit ClaimedReward(address(_rewardToken), _earnedReward);\n        }\n        unchecked {\n          ++_j;\n        }\n      }\n      unchecked {\n        ++_i;\n      }\n    }\n\n    if (_totalCrvReward > 0 || _totalCvxReward > 0) {\n      if (address(_amphClaimer) != address(0)) {\n        // Approve amounts for it to be taken\n        (uint256 _takenCVX, uint256 _takenCRV, uint256 _claimableAmph) =\n          _amphClaimer.claimable(address(this), this.id(), _totalCvxReward, _totalCrvReward);\n        if (_claimableAmph != 0) {\n          CRV.approve(address(_amphClaimer), _takenCRV);\n          CVX.approve(address(_amphClaimer), _takenCVX);\n\n          // Claim AMPH tokens depending on how much CRV and CVX was claimed\n          _amphClaimer.claimAmph(this.id(), _totalCvxReward, _totalCrvReward, _msgSender());\n\n          _totalCvxReward -= _takenCVX;\n          _totalCrvReward -= _takenCRV;\n        }\n      }\n\n      if (_totalCvxReward > 0) CVX.transfer(_msgSender(), _totalCvxReward);\n      if (_totalCrvReward > 0) CRV.transfer(_msgSender(), _totalCrvReward);\n\n      emit ClaimedReward(address(CRV), _totalCrvReward);\n      emit ClaimedReward(address(CVX), _totalCvxReward);\n    }\n  }\n\n  /// @notice Returns an array of all the available rewards the user can claim\n  /// @param _tokenAddress The address of the token collateral to check rewards for\n  /// @return _rewards The array of all the available rewards\n  function claimableRewards(address _tokenAddress) external view override returns (Reward[] memory _rewards) {\n    if (CONTROLLER.tokenId(_tokenAddress) == 0) revert Vault_TokenNotRegistered();\n    if (CONTROLLER.tokenCollateralType(_tokenAddress) != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n      revert Vault_TokenNotCurveLP();\n    }\n\n    IBaseRewardPool _rewardsContract = CONTROLLER.tokenCrvRewardsContract(_tokenAddress);\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n\n    uint256 _rewardsAmount = _rewardsContract.extraRewardsLength();\n\n    uint256 _crvReward = _rewardsContract.earned(address(this));\n    uint256 _cvxReward = _calculateCVXReward(_crvReward);\n\n    // +3 for CRV, CVX and AMPH\n    _rewards = new Reward[](_rewardsAmount+3);\n    _rewards[0] = Reward(CRV, _crvReward);\n    _rewards[1] = Reward(CVX, _cvxReward);\n\n    uint256 _i;\n    for (_i; _i < _rewardsAmount;) {\n      IVirtualBalanceRewardPool _virtualReward = _rewardsContract.extraRewards(_i);\n      IERC20 _rewardToken = _virtualReward.rewardToken();\n      uint256 _earnedReward = _virtualReward.earned(address(this));\n      _rewards[_i + 2] = Reward(_rewardToken, _earnedReward);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    uint256 _takenCVX;\n    uint256 _takenCRV;\n    uint256 _claimableAmph;\n    // if claimer is not set, nothing will happen (and variables are already in zero)\n    if (address(_amphClaimer) != address(0)) {\n      // claimer is set, proceed\n      (_takenCVX, _takenCRV, _claimableAmph) = _amphClaimer.claimable(address(this), this.id(), _cvxReward, _crvReward);\n      _rewards[_i + 2] = Reward(_amphClaimer.AMPH(), _claimableAmph);\n    }\n\n    _rewards[0].amount = _crvReward - _takenCRV;\n    if (_cvxReward > 0) _rewards[1].amount = _cvxReward - _takenCVX;\n  }\n\n  /// @notice Function used by the VaultController to transfer tokens\n  /// @dev Callable by the VaultController only\n  /// @param _token The token to transfer\n  /// @param _to The address to send the tokens to\n  /// @param _amount The amount of tokens to move\n  function controllerTransfer(address _token, address _to, uint256 _amount) external override onlyVaultController {\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_token), _to, _amount);\n    balances[_token] -= _amount;\n  }\n\n  /// @notice Function used by the VaultController to withdraw from convex\n  /// @dev Callable by the VaultController only\n  /// @param _rewardPool The pool to withdraw\n  /// @param _amount The amount of tokens to withdraw\n  function controllerWithdrawAndUnwrap(\n    IBaseRewardPool _rewardPool,\n    uint256 _amount\n  ) external override onlyVaultController {\n    if (!_rewardPool.withdrawAndUnwrap(_amount, false)) revert Vault_WithdrawAndUnstakeOnConvexFailed();\n  }\n\n  /// @notice Function used by the VaultController to reduce a vault's liability\n  /// @dev Callable by the VaultController only\n  /// @param _increase True to increase, false to decrease\n  /// @param _baseAmount The change in base liability\n  /// @return _newLiability The new liability\n  function modifyLiability(\n    bool _increase,\n    uint256 _baseAmount\n  ) external override onlyVaultController returns (uint256 _newLiability) {\n    if (_increase) {\n      baseLiability += _baseAmount;\n    } else {\n      // require statement only valid for repayment\n      if (baseLiability < _baseAmount) revert Vault_RepayTooMuch();\n      baseLiability -= _baseAmount;\n    }\n    _newLiability = baseLiability;\n  }\n\n  /// @dev Internal function for depositing and staking on convex\n  function _depositAndStakeOnConvex(address _token, IBooster _booster, uint256 _amount, uint256 _poolId) internal {\n    IERC20(_token).approve(address(_booster), _amount);\n    if (!_booster.deposit(_poolId, _amount, true)) revert Vault_DepositAndStakeOnConvexFailed();\n  }\n\n  /// @notice Used to calculate the CVX reward for a given CRV amount\n  /// @dev This is copied from the CVX mint function\n  /// @param _crv The amount of CRV to calculate the CVX reward for\n  /// @return _cvxAmount The amount of CVX to get\n  function _calculateCVXReward(uint256 _crv) internal view returns (uint256 _cvxAmount) {\n    uint256 _supply = CVX.totalSupply();\n    uint256 _totalCliffs = CVX.totalCliffs();\n\n    //use current supply to gauge cliff\n    //this will cause a bit of overflow into the next cliff range\n    //but should be within reasonable levels.\n    //requires a max supply check though\n    uint256 _cliff = _supply / CVX.reductionPerCliff();\n    //mint if below total cliffs\n    if (_cliff < _totalCliffs) {\n      //for reduction% take inverse of current cliff\n      uint256 _reduction = _totalCliffs - _cliff;\n      //reduce\n      _cvxAmount = (_crv * _reduction) / _totalCliffs;\n\n      //supply cap check\n      uint256 _amtTillMax = CVX.maxSupply() - _supply;\n      if (_cvxAmount > _amtTillMax) _cvxAmount = _amtTillMax;\n    }\n  }\n}"
    }
  ]
}