{
  "Title": "[G-09]  Avoid reading state variable twice",
  "Content": "\n**Files:** `SystemContext.sol`, `L2StandardERC20.sol`\n\nReading state variables costs a lot of gas. It's better to always cache the state variable into local variable and read the local variable instead.\n\n[File: code/contracts/zksync/contracts/bridge/L2StandardERC20.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2StandardERC20.sol#L093)\n```solidity\n093:         try this.decodeUint8(decimalsBytes) returns (uint8 decimalsUint8) {\n094:             // Set decoded value for decimals.\n095:             decimals_ = decimalsUint8;\n096:         } catch {\n097:             getters.ignoreDecimals = true;\n098:         }\n099: \n100:         availableGetters = getters;\n101:         emit BridgeInitialize(_l1Address, decodedName, decodedSymbol, decimals_);\n```\nVariable `decimals_` is a state variable, thus reading it costs more gas than local variable.\nPlease notice, that we're reading this variable twice - firstly, at line 95, then at line 101.\n\nReading state variables multiple of times costs a lot of gas. Much more effective solution would be to just read it once and cache the result into local variable.\n\n[File: code/system-contracts/contracts/SystemContext.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L117)\n```solidity\n117:     function getCurrentPubdataSpent() public view returns (uint256) {\n118:         uint256 pubdataPublished = SystemContractHelper.getZkSyncMeta().pubdataPublished;\n119:         return pubdataPublished > basePubdataSpent ? pubdataPublished - basePubdataSpent : 0;\n120:     }\n```\n\nTo avoid reading `basePubdataSpent` twice, above code can be rewritten to:\n\n```\n    function getCurrentPubdataSpent() public view returns (uint256) {\n        uint256 cachedBasePubdataSpent = basePubdataSpent;\n        uint256 pubdataPublished = SystemContractHelper.getZkSyncMeta().pubdataPublished;\n        return pubdataPublished > cachedBasePubdataSpent ? pubdataPublished - cachedBasePubdataSpent : 0;\n    }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/zksync/contracts/bridge/L2StandardERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport {ERC1967Upgrade} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\n\nimport {IL2StandardToken} from \"./interfaces/IL2StandardToken.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The ERC20 token implementation, that is used in the \"default\" ERC20 bridge. Note, that it does not\n/// support any custom token logic, i.e. rebase tokens' functionality is not supported.\ncontract L2StandardERC20 is ERC20PermitUpgradeable, IL2StandardToken, ERC1967Upgrade {\n    /// @dev Describes whether there is a specific getter in the token.\n    /// @notice Used to explicitly separate which getters the token has and which it does not.\n    /// @notice Different tokens in L1 can implement or not implement getter function as `name`/`symbol`/`decimals`,\n    /// @notice Our goal is to store all the getters that L1 token implements, and for others, we keep it as an unimplemented method.\n    struct ERC20Getters {\n        bool ignoreName;\n        bool ignoreSymbol;\n        bool ignoreDecimals;\n    }\n\n    ERC20Getters private availableGetters;\n\n    /// @dev The decimals of the token, that are used as a value for `decimals` getter function.\n    /// @notice A private variable is used only for decimals, but not for `name` and `symbol`, because standard\n    /// @notice OpenZeppelin token represents `name` and `symbol` as storage variables and `decimals` as constant.\n    uint8 private decimals_;\n\n    /// @dev Address of the L2 bridge that is used as trustee who can mint/burn tokens\n    address public override l2Bridge;\n\n    /// @dev Address of the L1 token that can be deposited to mint this L2 token\n    address public override l1Address;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    constructor() {\n        // Disable initialization to prevent Parity hack.\n        _disableInitializers();\n    }\n\n    /// @notice Initializes a contract token for later use. Expected to be used in the proxy.\n    /// @dev Stores the L1 address of the bridge and set `name`/`symbol`/`decimals` getters that L1 token has.\n    /// @param _l1Address Address of the L1 token that can be deposited to mint this L2 token\n    /// @param _data The additional data that the L1 bridge provide for initialization.\n    /// In this case, it is packed `name`/`symbol`/`decimals` of the L1 token.\n    function bridgeInitialize(address _l1Address, bytes memory _data) external initializer {\n        require(_l1Address != address(0), \"in6\"); // Should be non-zero address\n        l1Address = _l1Address;\n\n        l2Bridge = msg.sender;\n\n        // We parse the data exactly as they were created on the L1 bridge\n        (bytes memory nameBytes, bytes memory symbolBytes, bytes memory decimalsBytes) = abi.decode(\n            _data,\n            (bytes, bytes, bytes)\n        );\n\n        ERC20Getters memory getters;\n        string memory decodedName;\n        string memory decodedSymbol;\n\n        // L1 bridge didn't check if the L1 token return values with proper types for `name`/`symbol`/`decimals`\n        // That's why we need to try to decode them, and if it works out, set the values as getters.\n\n        // NOTE: Solidity doesn't have a convenient way to try to decode a value:\n        // - Decode them manually, i.e. write a function that will validate that data in the correct format\n        // and return decoded value and a boolean value - whether it was possible to decode.\n        // - Use the standard abi.decode method, but wrap it into an external call in which error can be handled.\n        // We use the second option here.\n\n        try this.decodeString(nameBytes) returns (string memory nameString) {\n            decodedName = nameString;\n        } catch {\n            getters.ignoreName = true;\n        }\n\n        try this.decodeString(symbolBytes) returns (string memory symbolString) {\n            decodedSymbol = symbolString;\n        } catch {\n            getters.ignoreSymbol = true;\n        }\n\n        // Set decoded values for name and symbol.\n        __ERC20_init_unchained(decodedName, decodedSymbol);\n\n        // Set the name for EIP-712 signature.\n        __ERC20Permit_init(decodedName);\n\n        try this.decodeUint8(decimalsBytes) returns (uint8 decimalsUint8) {\n            // Set decoded value for decimals.\n            decimals_ = decimalsUint8;\n        } catch {\n            getters.ignoreDecimals = true;\n        }\n\n        availableGetters = getters;\n        emit BridgeInitialize(_l1Address, decodedName, decodedSymbol, decimals_);\n    }\n\n    /// @notice A method to be called by the governor to update the token's metadata.\n    /// @param _availableGetters The getters that the token has.\n    /// @param _newName The new name of the token.\n    /// @param _newSymbol The new symbol of the token.\n    /// @param _version The version of the token that will be initialized.\n    /// @dev The _version must be exactly the version higher by 1 than the current version. This is needed\n    /// to ensure that the governor can not accidentally disable future reinitialization of the token.\n    function reinitializeToken(\n        ERC20Getters calldata _availableGetters,\n        string memory _newName,\n        string memory _newSymbol,\n        uint8 _version\n    ) external onlyNextVersion(_version) reinitializer(_version) {\n        // It is expected that this token is deployed as a beacon proxy, so we'll\n        // allow the governor of the beacon to reinitialize the token.\n        address beaconAddress = _getBeacon();\n        require(msg.sender == UpgradeableBeacon(beaconAddress).owner(), \"tt\");\n\n        __ERC20_init_unchained(_newName, _newSymbol);\n        __ERC20Permit_init(_newName);\n        availableGetters = _availableGetters;\n\n        emit BridgeInitialize(l1Address, _newName, _newSymbol, decimals_);\n    }\n\n    modifier onlyBridge() {\n        require(msg.sender == l2Bridge, \"xnt\"); // Only L2 bridge can call this method\n        _;\n    }\n\n    modifier onlyNextVersion(uint8 _version) {\n        // The version should be incremented by 1. Otherwise, the governor risks disabling\n        // future reinitialization of the token by providing too large a version.\n        require(_version == _getInitializedVersion() + 1, \"v\");\n        _;\n    }\n\n    /// @dev Mint tokens to a given account.\n    /// @param _to The account that will receive the created tokens.\n    /// @param _amount The amount that will be created.\n    /// @notice Should be called by bridge after depositing tokens from L1.\n    function bridgeMint(address _to, uint256 _amount) external override onlyBridge {\n        _mint(_to, _amount);\n        emit BridgeMint(_to, _amount);\n    }\n\n    /// @dev Burn tokens from a given account.\n    /// @param _from The account from which tokens will be burned.\n    /// @param _amount The amount that will be burned.\n    /// @notice Should be called by bridge before withdrawing tokens to L1.\n    function bridgeBurn(address _from, uint256 _amount) external override onlyBridge {\n        _burn(_from, _amount);\n        emit BridgeBurn(_from, _amount);\n    }\n\n    function name() public view override returns (string memory) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreName) revert();\n        return super.name();\n    }\n\n    function symbol() public view override returns (string memory) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreSymbol) revert();\n        return super.symbol();\n    }\n\n    function decimals() public view override returns (uint8) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreDecimals) revert();\n        return decimals_;\n    }\n\n    /// @dev External function to decode a string from bytes.\n    function decodeString(bytes memory _input) external pure returns (string memory result) {\n        (result) = abi.decode(_input, (string));\n    }\n\n    /// @dev External function to decode a uint8 from bytes.\n    function decodeUint8(bytes memory _input) external pure returns (uint8 result) {\n        (result) = abi.decode(_input, (uint8));\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/SystemContext.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {ISystemContextDeprecated} from \"./interfaces/ISystemContextDeprecated.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, SystemLogKey} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Contract that stores some of the context variables, that may be either\n * block-scoped, tx-scoped or system-wide.\n */\ncontract SystemContext is ISystemContext, ISystemContextDeprecated, ISystemContract {\n    /// @notice The number of latest L2 blocks to store.\n    /// @dev EVM requires us to be able to query the hashes of previous 256 blocks.\n    /// We could either:\n    /// - Store the latest 256 hashes (and strictly rely that we do not accidentally override the hash of the block 256 blocks ago)\n    /// - Store the latest 257 blocks' hashes.\n    uint256 internal constant MINIBLOCK_HASHES_TO_STORE = 257;\n\n    /// @notice The chainId of the network. It is set at the genesis.\n    uint256 public chainId;\n\n    /// @notice The `tx.origin` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    address public origin;\n\n    /// @notice The `tx.gasPrice` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    uint256 public gasPrice;\n\n    /// @notice The current block's gasLimit.\n    uint256 public blockGasLimit = type(uint32).max;\n\n    /// @notice The `block.coinbase` in the current transaction.\n    /// @dev For the support of coinbase, we will use the bootloader formal address for now\n    address public coinbase = BOOTLOADER_FORMAL_ADDRESS;\n\n    /// @notice Formal `block.difficulty` parameter.\n    uint256 public difficulty = 2.5e15;\n\n    /// @notice The `block.basefee`.\n    /// @dev It is currently a constant.\n    uint256 public baseFee;\n\n    /// @notice The number and the timestamp of the current L1 batch stored packed.\n    BlockInfo internal currentBatchInfo;\n\n    /// @notice The hashes of batches.\n    /// @dev It stores batch hashes for all previous batches.\n    mapping(uint256 batchNumber => bytes32 batchHash) internal batchHashes;\n\n    /// @notice The number and the timestamp of the current L2 block.\n    BlockInfo internal currentL2BlockInfo;\n\n    /// @notice The rolling hash of the transactions in the current L2 block.\n    bytes32 internal currentL2BlockTxsRollingHash;\n\n    /// @notice The hashes of L2 blocks.\n    /// @dev It stores block hashes for previous L2 blocks. Note, in order to make publishing the hashes\n    /// of the miniblocks cheaper, we only store the previous MINIBLOCK_HASHES_TO_STORE ones. Since whenever we need to publish a state\n    /// diff, a pair of <key, value> is published and for cached keys only 8-byte id is used instead of 32 bytes.\n    /// By having this data in a cyclic array of MINIBLOCK_HASHES_TO_STORE blocks, we bring the costs down by 40% (i.e. 40 bytes per miniblock instead of 64 bytes).\n    /// @dev The hash of a miniblock with number N would be stored under slot N%MINIBLOCK_HASHES_TO_STORE.\n    /// @dev Hashes of the blocks older than the ones which are stored here can be calculated as _calculateLegacyL2BlockHash(blockNumber).\n    bytes32[MINIBLOCK_HASHES_TO_STORE] internal l2BlockHash;\n\n    /// @notice To make migration to L2 blocks smoother, we introduce a temporary concept of virtual L2 blocks, the data\n    /// about which will be returned by the EVM-like methods: block.number/block.timestamp/blockhash.\n    /// - Their number will start from being equal to the number of the batch and it will increase until it reaches the L2 block number.\n    /// - Their timestamp is updated each time a new virtual block is created.\n    /// - Their hash is calculated as `keccak256(uint256(number))`\n    BlockInfo internal currentVirtualL2BlockInfo;\n\n    /// @notice The information about the virtual blocks upgrade, which tracks when the migration to the L2 blocks has started and finished.\n    VirtualBlockUpgradeInfo internal virtualBlockUpgradeInfo;\n\n    /// @notice Set the chainId origin.\n    /// @param _newChainId The chainId\n    function setChainId(uint256 _newChainId) external onlyCallFromForceDeployer {\n        chainId = _newChainId;\n    }\n\n    /// @notice Number of current transaction in block.\n    uint16 public txNumberInBlock;\n\n    /// @notice The current gas per pubdata byte\n    uint256 public gasPerPubdataByte;\n\n    /// @notice The number of pubdata spent as of the start of the transaction\n    uint256 internal basePubdataSpent;\n\n    /// @notice Set the current tx origin.\n    /// @param _newOrigin The new tx origin.\n    function setTxOrigin(address _newOrigin) external onlyCallFromBootloader {\n        origin = _newOrigin;\n    }\n\n    /// @notice Set the the current gas price.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyCallFromBootloader {\n        gasPrice = _gasPrice;\n    }\n\n    /// @notice Sets the number of L2 gas that is needed to pay a single byte of pubdata.\n    /// @dev This value does not have any impact on the execution and purely serves as a way for users\n    /// to access the current gas price for the pubdata.\n    function setPubdataInfo(uint256 _gasPerPubdataByte, uint256 _basePubdataSpent) external onlyCallFromBootloader {\n        basePubdataSpent = _basePubdataSpent;\n        gasPerPubdataByte = _gasPerPubdataByte;\n    }\n\n    function getCurrentPubdataSpent() public view returns (uint256) {\n        uint256 pubdataPublished = SystemContractHelper.getZkSyncMeta().pubdataPublished;\n        return pubdataPublished > basePubdataSpent ? pubdataPublished - basePubdataSpent : 0;\n    }\n\n    function getCurrentPubdataCost() external view returns (uint256) {\n        return gasPerPubdataByte * getCurrentPubdataSpent();\n    }\n\n    /// @notice The method that emulates `blockhash` opcode in EVM.\n    /// @dev Just like the blockhash in the EVM, it returns bytes32(0),\n    /// when queried about hashes that are older than 256 blocks ago.\n    /// @dev Since zksolc compiler calls this method to emulate `blockhash`,\n    /// its signature can not be changed to `getL2BlockHashEVM`.\n    /// @return hash The blockhash of the block with the given number.\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32 hash) {\n        uint128 blockNumber = currentVirtualL2BlockInfo.number;\n\n        VirtualBlockUpgradeInfo memory currentVirtualBlockUpgradeInfo = virtualBlockUpgradeInfo;\n\n        // Due to virtual blocks upgrade, we'll have to use the following logic for retreiving the blockhash:\n        // 1. If the block number is out of the 256-block supported range, return 0.\n        // 2. If the block was created before the upgrade for the virtual blocks (i.e. there we used to use hashes of the batches),\n        // we return the hash of the batch.\n        // 3. If the block was created after the day when the virtual blocks have caught up with the L2 blocks, i.e.\n        // all the information which is returned for users should be for L2 blocks, we return the hash of the corresponding L2 block.\n        // 4. If the block queried is a virtual blocks, calculate it on the fly.\n        if (blockNumber <= _block || blockNumber - _block > 256) {\n            hash = bytes32(0);\n        } else if (_block < currentVirtualBlockUpgradeInfo.virtualBlockStartBatch) {\n            // Note, that we will get into this branch only for a brief moment of time, right after the upgrade\n            // for virtual blocks before 256 virtual blocks are produced.\n            hash = batchHashes[_block];\n        } else if (\n            _block >= currentVirtualBlockUpgradeInfo.virtualBlockFinishL2Block &&\n            currentVirtualBlockUpgradeInfo.virtualBlockFinishL2Block > 0\n        ) {\n            hash = _getLatest257L2blockHash(_block);\n        } else {\n            // Important: we do not want this number to ever collide with the L2 block hash (either new or old one) and so\n            // that's why the legacy L2 blocks' hashes are keccak256(abi.encodePacked(uint32(_block))), while these are equivalent to\n            // keccak256(abi.encodePacked(_block))\n            hash = keccak256(abi.encode(_block));\n        }\n    }\n\n    /// @notice Returns the hash of the given batch.\n    /// @param _batchNumber The number of the batch.\n    /// @return hash The hash of the batch.\n    function getBatchHash(uint256 _batchNumber) external view returns (bytes32 hash) {\n        hash = batchHashes[_batchNumber];\n    }\n\n    /// @notice Returns the current batch's number and timestamp.\n    /// @return batchNumber and batchTimestamp tuple of the current batch's number and the current batch's timestamp\n    function getBatchNumberAndTimestamp() public view returns (uint128 batchNumber, uint128 batchTimestamp) {\n        BlockInfo memory batchInfo = currentBatchInfo;\n        batchNumber = batchInfo.number;\n        batchTimestamp = batchInfo.timestamp;\n    }\n\n    /// @notice Returns the current block's number and timestamp.\n    /// @return blockNumber and blockTimestamp tuple of the current L2 block's number and the current block's timestamp\n    function getL2BlockNumberAndTimestamp() public view returns (uint128 blockNumber, uint128 blockTimestamp) {\n        BlockInfo memory blockInfo = currentL2BlockInfo;\n        blockNumber = blockInfo.number;\n        blockTimestamp = blockInfo.timestamp;\n    }\n\n    /// @notice Returns the current L2 block's number.\n    /// @dev Since zksolc compiler calls this method to emulate `block.number`,\n    /// its signature can not be changed to `getL2BlockNumber`.\n    /// @return blockNumber The current L2 block's number.\n    function getBlockNumber() public view returns (uint128) {\n        return currentVirtualL2BlockInfo.number;\n    }\n\n    /// @notice Returns the current L2 block's timestamp.\n    /// @dev Since zksolc compiler calls this method to emulate `block.timestamp`,\n    /// its signature can not be changed to `getL2BlockTimestamp`.\n    /// @return timestamp The current L2 block's timestamp.\n    function getBlockTimestamp() public view returns (uint128) {\n        return currentVirtualL2BlockInfo.timestamp;\n    }\n\n    /// @notice Assuming that block is one of the last MINIBLOCK_HASHES_TO_STORE ones, returns its hash.\n    /// @param _block The number of the block.\n    /// @return hash The hash of the block.\n    function _getLatest257L2blockHash(uint256 _block) internal view returns (bytes32) {\n        return l2BlockHash[_block % MINIBLOCK_HASHES_TO_STORE];\n    }\n\n    /// @notice Assuming that the block is one of the last MINIBLOCK_HASHES_TO_STORE ones, sets its hash.\n    /// @param _block The number of the block.\n    /// @param _hash The hash of the block.\n    function _setL2BlockHash(uint256 _block, bytes32 _hash) internal {\n        l2BlockHash[_block % MINIBLOCK_HASHES_TO_STORE] = _hash;\n    }\n\n    /// @notice Calculates the hash of an L2 block.\n    /// @param _blockNumber The number of the L2 block.\n    /// @param _blockTimestamp The timestamp of the L2 block.\n    /// @param _prevL2BlockHash The hash of the previous L2 block.\n    /// @param _blockTxsRollingHash The rolling hash of the transactions in the L2 block.\n    function _calculateL2BlockHash(\n        uint128 _blockNumber,\n        uint128 _blockTimestamp,\n        bytes32 _prevL2BlockHash,\n        bytes32 _blockTxsRollingHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_blockNumber, _blockTimestamp, _prevL2BlockHash, _blockTxsRollingHash));\n    }\n\n    /// @notice Calculates the legacy block hash of L2 block, which were used before the upgrade where\n    /// the advanced block hashes were introduced.\n    /// @param _blockNumber The number of the L2 block.\n    function _calculateLegacyL2BlockHash(uint128 _blockNumber) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(uint32(_blockNumber)));\n    }\n\n    /// @notice Performs the upgrade where we transition to the L2 blocks.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _expectedPrevL2BlockHash The expected hash of the previous L2 block.\n    /// @param _isFirstInBatch Whether this method is called for the first time in the batch.\n    function _upgradeL2Blocks(uint128 _l2BlockNumber, bytes32 _expectedPrevL2BlockHash, bool _isFirstInBatch) internal {\n        require(_isFirstInBatch, \"Upgrade transaction must be first\");\n\n        // This is how it will be commonly done in practice, but it will simplify some logic later\n        require(_l2BlockNumber > 0, \"L2 block number is never expected to be zero\");\n\n        unchecked {\n            bytes32 correctPrevBlockHash = _calculateLegacyL2BlockHash(_l2BlockNumber - 1);\n            require(correctPrevBlockHash == _expectedPrevL2BlockHash, \"The previous L2 block hash is incorrect\");\n\n            // Whenever we'll be queried about the hashes of the blocks before the upgrade,\n            // we'll use batches' hashes, so we don't need to store 256 previous hashes.\n            // However, we do need to store the last previous hash in order to be able to correctly calculate the\n            // hash of the new L2 block.\n            _setL2BlockHash(_l2BlockNumber - 1, correctPrevBlockHash);\n        }\n    }\n\n    /// @notice Creates new virtual blocks, while ensuring they don't exceed the L2 block number.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _maxVirtualBlocksToCreate The maximum number of virtual blocks to create with this L2 block.\n    /// @param _newTimestamp The timestamp of the new L2 block, which is also the timestamp of the new virtual block.\n    function _setVirtualBlock(\n        uint128 _l2BlockNumber,\n        uint128 _maxVirtualBlocksToCreate,\n        uint128 _newTimestamp\n    ) internal {\n        if (virtualBlockUpgradeInfo.virtualBlockFinishL2Block != 0) {\n            // No need to to do anything about virtual blocks anymore\n            // All the info is the same as for L2 blocks.\n            currentVirtualL2BlockInfo = currentL2BlockInfo;\n            return;\n        }\n\n        BlockInfo memory virtualBlockInfo = currentVirtualL2BlockInfo;\n\n        if (currentVirtualL2BlockInfo.number == 0 && virtualBlockInfo.timestamp == 0) {\n            uint128 currentBatchNumber = currentBatchInfo.number;\n\n            // The virtual block is set for the first time. We can count it as 1 creation of a virtual block.\n            // Note, that when setting the virtual block number we use the batch number to make a smoother upgrade from batch number to\n            // the L2 block number.\n            virtualBlockInfo.number = currentBatchNumber;\n            // Remembering the batch number on which the upgrade to the virtual blocks has been done.\n            virtualBlockUpgradeInfo.virtualBlockStartBatch = currentBatchNumber;\n\n            require(_maxVirtualBlocksToCreate > 0, \"Can't initialize the first virtual block\");\n            _maxVirtualBlocksToCreate -= 1;\n        } else if (_maxVirtualBlocksToCreate == 0) {\n            // The virtual blocks have been already initialized, but the operator didn't ask to create\n            // any new virtual blocks. So we can just return.\n            return;\n        }\n\n        virtualBlockInfo.number += _maxVirtualBlocksToCreate;\n        virtualBlockInfo.timestamp = _newTimestamp;\n\n        // The virtual block number must never exceed the L2 block number.\n        // We do not use a `require` here, since the virtual blocks are a temporary solution to let the Solidity's `block.number`\n        // catch up with the L2 block number and so the situation where virtualBlockInfo.number starts getting larger\n        // than _l2BlockNumber is expected once virtual blocks have caught up the L2 blocks.\n        if (virtualBlockInfo.number >= _l2BlockNumber) {\n            virtualBlockUpgradeInfo.virtualBlockFinishL2Block = _l2BlockNumber;\n            virtualBlockInfo.number = _l2BlockNumber;\n        }\n\n        currentVirtualL2BlockInfo = virtualBlockInfo;\n    }\n\n    /// @notice Sets the current block number and timestamp of the L2 block.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _l2BlockTimestamp The timestamp of the new L2 block.\n    /// @param _prevL2BlockHash The hash of the previous L2 block.\n    function _setNewL2BlockData(uint128 _l2BlockNumber, uint128 _l2BlockTimestamp, bytes32 _prevL2BlockHash) internal {\n        // In the unsafe version we do not check that the block data is correct\n        currentL2BlockInfo = BlockInfo({number: _l2BlockNumber, timestamp: _l2BlockTimestamp});\n\n        // It is always assumed in production that _l2BlockNumber > 0\n        _setL2BlockHash(_l2BlockNumber - 1, _prevL2BlockHash);\n\n        // Reseting the rolling hash\n        currentL2BlockTxsRollingHash = bytes32(0);\n    }\n\n    /// @notice Sets the current block number and timestamp of the L2 block.\n    /// @dev Called by the bootloader before each transaction. This is needed to ensure\n    /// that the data about the block is consistent with the sequencer.\n    /// @dev If the new block number is the same as the current one, we ensure that the block's data is\n    /// consistent with the one in the current block.\n    /// @dev If the new block number is greater than the current one by 1,\n    /// then we ensure that timestamp has increased.\n    /// @dev If the currently stored number is 0, we assume that it is the first upgrade transaction\n    /// and so we will fill up the old data.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _l2BlockTimestamp The timestamp of the new L2 block.\n    /// @param _expectedPrevL2BlockHash The expected hash of the previous L2 block.\n    /// @param _isFirstInBatch Whether this method is called for the first time in the batch.\n    /// @param _maxVirtualBlocksToCreate The maximum number of virtual block to create with this L2 block.\n    /// @dev It is a strict requirement that a new virtual block is created at the start of the batch.\n    /// @dev It is also enforced that the number of the current virtual L2 block can not exceed the number of the L2 block.\n    function setL2Block(\n        uint128 _l2BlockNumber,\n        uint128 _l2BlockTimestamp,\n        bytes32 _expectedPrevL2BlockHash,\n        bool _isFirstInBatch,\n        uint128 _maxVirtualBlocksToCreate\n    ) external onlyCallFromBootloader {\n        // We check that the timestamp of the L2 block is consistent with the timestamp of the batch.\n        if (_isFirstInBatch) {\n            uint128 currentBatchTimestamp = currentBatchInfo.timestamp;\n            require(\n                _l2BlockTimestamp >= currentBatchTimestamp,\n                \"The timestamp of the L2 block must be greater than or equal to the timestamp of the current batch\"\n            );\n            require(_maxVirtualBlocksToCreate > 0, \"There must be a virtual block created at the start of the batch\");\n        }\n\n        (uint128 currentL2BlockNumber, uint128 currentL2BlockTimestamp) = getL2BlockNumberAndTimestamp();\n\n        if (currentL2BlockNumber == 0 && currentL2BlockTimestamp == 0) {\n            // Since currentL2BlockNumber and currentL2BlockTimestamp are zero it means that it is\n            // the first ever batch with L2 blocks, so we need to initialize those.\n            _upgradeL2Blocks(_l2BlockNumber, _expectedPrevL2BlockHash, _isFirstInBatch);\n\n            _setNewL2BlockData(_l2BlockNumber, _l2BlockTimestamp, _expectedPrevL2BlockHash);\n        } else if (currentL2BlockNumber == _l2BlockNumber) {\n            require(!_isFirstInBatch, \"Can not reuse L2 block number from the previous batch\");\n            require(currentL2BlockTimestamp == _l2BlockTimestamp, \"The timestamp of the same L2 block must be same\");\n            require(\n                _expectedPrevL2BlockHash == _getLatest257L2blockHash(_l2BlockNumber - 1),\n                \"The previous hash of the same L2 block must be same\"\n            );\n            require(_maxVirtualBlocksToCreate == 0, \"Can not create virtual blocks in the middle of the miniblock\");\n        } else if (currentL2BlockNumber + 1 == _l2BlockNumber) {\n            // From the checks in _upgradeL2Blocks it is known that currentL2BlockNumber can not be 0\n            bytes32 prevL2BlockHash = _getLatest257L2blockHash(currentL2BlockNumber - 1);\n\n            bytes32 pendingL2BlockHash = _calculateL2BlockHash(\n                currentL2BlockNumber,\n                currentL2BlockTimestamp,\n                prevL2BlockHash,\n                currentL2BlockTxsRollingHash\n            );\n\n            require(_expectedPrevL2BlockHash == pendingL2BlockHash, \"The current L2 block hash is incorrect\");\n            require(\n                _l2BlockTimestamp > currentL2BlockTimestamp,\n                \"The timestamp of the new L2 block must be greater than the timestamp of the previous L2 block\"\n            );\n\n            // Since the new block is created, we'll clear out the rolling hash\n            _setNewL2BlockData(_l2BlockNumber, _l2BlockTimestamp, _expectedPrevL2BlockHash);\n        } else {\n            revert(\"Invalid new L2 block number\");\n        }\n\n        _setVirtualBlock(_l2BlockNumber, _maxVirtualBlocksToCreate, _l2BlockTimestamp);\n    }\n\n    /// @notice Appends the transaction hash to the rolling hash of the current L2 block.\n    /// @param _txHash The hash of the transaction.\n    function appendTransactionToCurrentL2Block(bytes32 _txHash) external onlyCallFromBootloader {\n        currentL2BlockTxsRollingHash = keccak256(abi.encode(currentL2BlockTxsRollingHash, _txHash));\n    }\n\n    /// @notice Publishes L2->L1 logs needed to verify the validity of this batch on L1.\n    /// @dev Should be called at the end of the current batch.\n    function publishTimestampDataToL1() external onlyCallFromBootloader {\n        (uint128 currentBatchNumber, uint128 currentBatchTimestamp) = getBatchNumberAndTimestamp();\n        (, uint128 currentL2BlockTimestamp) = getL2BlockNumberAndTimestamp();\n\n        // The structure of the \"setNewBatch\" implies that currentBatchNumber > 0, but we still double check it\n        require(currentBatchNumber > 0, \"The current batch number must be greater than 0\");\n\n        // In order to spend less pubdata, the packed version is published\n        uint256 packedTimestamps = (uint256(currentBatchTimestamp) << 128) | currentL2BlockTimestamp;\n\n        SystemContractHelper.toL1(\n            false,\n            bytes32(uint256(SystemLogKey.PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY)),\n            bytes32(packedTimestamps)\n        );\n    }\n\n    /// @notice Ensures that the timestamp of the batch is greater than the timestamp of the last L2 block.\n    /// @param _newTimestamp The timestamp of the new batch.\n    function _ensureBatchConsistentWithL2Block(uint128 _newTimestamp) internal view {\n        uint128 currentBlockTimestamp = currentL2BlockInfo.timestamp;\n        require(\n            _newTimestamp > currentBlockTimestamp,\n            \"The timestamp of the batch must be greater than the timestamp of the previous block\"\n        );\n    }\n\n    /// @notice Increments the current batch number and sets the new timestamp\n    /// @dev Called by the bootloader at the start of the batch.\n    /// @param _prevBatchHash The hash of the previous batch.\n    /// @param _newTimestamp The timestamp of the new batch.\n    /// @param _expectedNewNumber The new batch's number.\n    /// @param _baseFee The new batch's base fee\n    /// @dev While _expectedNewNumber can be derived as prevBatchNumber + 1, we still\n    /// manually supply it here for consistency checks.\n    /// @dev The correctness of the _prevBatchHash and _newTimestamp should be enforced on L1.\n    function setNewBatch(\n        bytes32 _prevBatchHash,\n        uint128 _newTimestamp,\n        uint128 _expectedNewNumber,\n        uint256 _baseFee\n    ) external onlyCallFromBootloader {\n        (uint128 previousBatchN"
    }
  ]
}