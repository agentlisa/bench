{
  "Title": "Wrong Accounting of Extra Rewards Upon Depositing to a Gauge",
  "Content": "Liquidity providers that deposit their tokens to a gauge are entitled to a portion of the extra rewards, if there are any. The extra reward amount is handled by the [GaugeExtraRewarder](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol) contract and is distributed to the users in proportion to their share of the total staked LP tokens. Thus, each time the total staked amount in the gauge changes (i.e. upon deposit or withdrawal) the extra-reward-per-share value needs to be updated appropriately.\n\n\nUpon depositing to a gauge, [the user's funds are first transferred to the contract](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol#L222) and the [`onReward`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L71) function of the `GaugeExtraRewarder` contract [is only called thereafter](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol#L225). The sequence of these two operations is wrong, leading to a miscalculation of `accRewardPerShare` [when updating the pool](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L138), because the gauge's balance has already been increased by the freshly deposited amount. As a consequence, the users might lose part of their reward.\n\n\nConsider transferring the user's deposited funds only after calling the `onReward` function.\n\n\n***Update:** Resolved in [pull request #4](https://github.com/ThenafiBNB/THENA-Contracts/pull/4) at commit [da9df65](https://github.com/ThenafiBNB/THENA-Contracts/pull/4/commits/da9df654b21eb140e4465270c6d1b0e5fd9a7cc2).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GaugeV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\n\ninterface IRewarder {\n    function onReward(\n        uint256 pid,\n        address user,\n        address recipient,\n        uint256 amount,\n        uint256 newLpAmount\n    ) external;\n}\n\n\ncontract GaugeV2 is ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    bool public isForPair;\n    bool public emergency;\n\n\n    IERC20 public rewardToken;\n    IERC20 public _VE;\n    IERC20 public TOKEN;\n\n    address public DISTRIBUTION;\n    address public gaugeRewarder;\n    address public internal_bribe;\n    address public external_bribe;\n\n    uint256 public rewarderPid;\n    uint256 public DURATION;\n    uint256 public periodFinish;\n    uint256 public rewardRate;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    uint public fees0;\n    uint public fees1;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 public _totalSupply;\n    mapping(address => uint256) public _balances;\n\n    event RewardAdded(uint256 reward);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Harvest(address indexed user, uint256 reward);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    modifier onlyDistribution() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier isNotEmergency() {\n        require(emergency == false);\n        _;\n    }\n\n    constructor(address _rewardToken,address _ve,address _token,address _distribution, address _internal_bribe, address _external_bribe, bool _isForPair) {\n        rewardToken = IERC20(_rewardToken);     // main reward\n        _VE = IERC20(_ve);                      // vested\n        TOKEN = IERC20(_token);                 // underlying (LP)\n        DISTRIBUTION = _distribution;           // distro address (voter)\n        DURATION = 7 * 86400;                    // distro time\n\n        internal_bribe = _internal_bribe;       // lp fees goes here\n        external_bribe = _external_bribe;       // bribe fees goes here\n\n        isForPair = _isForPair;                 // pair boolean, if false no claim_fees\n\n        emergency = false;                      // emergency flag\n\n    }\n\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ONLY OWNER\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice set distribution address (should be GaugeProxyL2)\n    function setDistribution(address _distribution) external onlyOwner {\n        require(_distribution != address(0), \"zero addr\");\n        require(_distribution != DISTRIBUTION, \"same addr\");\n        DISTRIBUTION = _distribution;\n    }\n\n    ///@notice set gauge rewarder address\n    function setGaugeRewarder(address _gaugeRewarder) external onlyOwner {\n        require(_gaugeRewarder != address(0), \"zero addr\");\n        require(_gaugeRewarder != gaugeRewarder, \"same addr\");\n        gaugeRewarder = _gaugeRewarder;\n    }\n\n    ///@notice set extra rewarder pid\n    function setRewarderPid(uint256 _pid) external onlyOwner {\n        require(_pid >= 0, \"zero\");\n        require(_pid != rewarderPid, \"same pid\");\n        rewarderPid = _pid;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function setInternalBribe(address _int) external onlyOwner {\n        require(_int >= address(0), \"zero\");\n        internal_bribe = _int;\n    }\n\n    function activateEmergencyMode() external onlyOwner {\n        require(emergency == false);\n        emergency = true;\n    }\n\n    function stopEmergencyMode() external onlyOwner {\n        require(emergency == false);\n        emergency = false;\n    }\n\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice total supply held\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    ///@notice balance of a user\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    ///@notice last time reward\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    ///@notice  reward for a sinle token\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        } else {\n            return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply));\n        }\n    }\n\n    ///@notice see earned rewards for user\n    function earned(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    ///@notice get total reward for the duration\n    function rewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(DURATION);\n    }\n\n    function _periodFinish() external view returns (uint256) {\n        return periodFinish;\n    }\n\n\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n\n    ///@notice deposit all TOKEN of msg.sender\n    function depositAll() external {\n        _deposit(TOKEN.balanceOf(msg.sender), msg.sender);\n    }\n\n    ///@notice deposit amount TOKEN\n    function deposit(uint256 amount) external {\n        _deposit(amount, msg.sender);\n    }\n\n    ///@notice deposit internal\n    function _deposit(uint256 amount, address account) internal nonReentrant isNotEmergency updateReward(account) {\n        require(amount > 0, \"deposit(Gauge): cannot stake 0\");\n\n        _balances[account] = _balances[account].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n\n        TOKEN.safeTransferFrom(account, address(this), amount);\n\n        if (address(gaugeRewarder) != address(0)) {\n            IRewarder(gaugeRewarder).onReward(rewarderPid, account, account, 0, _balances[account]);\n        }\n\n        emit Deposit(account, amount);\n    }\n\n    ///@notice withdraw all token\n    function withdrawAll() external {\n        _withdraw(_balances[msg.sender]);\n    }\n\n    ///@notice withdraw a certain amount of TOKEN\n    function withdraw(uint256 amount) external {\n        _withdraw(amount);\n    }\n\n    ///@notice withdraw internal\n    function _withdraw(uint256 amount) internal nonReentrant isNotEmergency updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        require(_totalSupply.sub(amount) >= 0, \"supply < 0\");\n        require(_balances[msg.sender] > 0, \"no balances\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        if (address(gaugeRewarder) != address(0)) {\n            IRewarder(gaugeRewarder).onReward(rewarderPid, msg.sender, msg.sender, 0, _balances[msg.sender]);\n        }\n\n        TOKEN.safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function emergencyWithdraw() external nonReentrant {\n        require(emergency);\n        require(_balances[msg.sender] > 0, \"no balances\");\n        uint256 _amount = _balances[msg.sender];\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = 0;\n        TOKEN.safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n    function emergencyWithdrawAmount(uint256 _amount) external nonReentrant {\n        require(emergency);\n        _totalSupply = _totalSupply.sub(_amount);\n        _balances[msg.sender] = _balances[msg.sender] - _amount;\n        TOKEN.safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    ///@notice withdraw all TOKEN and harvest rewardToken\n    function withdrawAllAndHarvest() external {\n        _withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n \n    ///@notice User harvest function called from distribution (voter allows harvest on multiple gauges)\n    function getReward(address _user) public nonReentrant onlyDistribution updateReward(_user) {\n        uint256 reward = rewards[_user];\n        if (reward > 0) {\n            rewards[_user] = 0;\n            rewardToken.safeTransfer(_user, reward);\n            emit Harvest(_user, reward);\n        }\n\n        if (gaugeRewarder != address(0)) {\n            IRewarder(gaugeRewarder).onReward(rewarderPid, _user, _user, reward, _balances[_user]);\n        }\n    }\n\n     ///@notice User harvest function\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit Harvest(msg.sender, reward);\n        }\n\n        if (gaugeRewarder != address(0)) {\n            IRewarder(gaugeRewarder).onReward(rewarderPid, msg.sender, msg.sender, reward, _balances[msg.sender]);\n        }\n    }\n\n\n\n\n\n\n\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    DISTRIBUTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n\n    /// @dev Receive rewards from distribution\n    function notifyRewardAmount(address token, uint reward) external nonReentrant isNotEmergency onlyDistribution updateReward(address(0)) {\n        require(token == address(rewardToken));\n        rewardToken.safeTransferFrom(DISTRIBUTION, address(this), reward);\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(DURATION);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardToken.balanceOf(address(this));\n        require(rewardRate <= balance.div(DURATION), \"Provided reward too high\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n        emit RewardAdded(reward);\n    }\n\n\n    function claimFees() external nonReentrant returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n     function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        address _token = address(TOKEN);\n        (claimed0, claimed1) = IPair(_token).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(_token).tokens();\n\n            if (_fees0  > 0) {\n                fees0 = 0;\n                IERC20(_token0).approve(internal_bribe, 0);\n                IERC20(_token0).approve(internal_bribe, _fees0);\n                IBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1  > 0) {\n                fees1 = 0;\n                IERC20(_token1).approve(internal_bribe, 0);\n                IERC20(_token1).approve(internal_bribe, _fees1);\n                IBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n\n\n}"
    }
  ]
}