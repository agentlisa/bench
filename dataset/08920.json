{
  "Title": "[M-10] Unable To Get Rewards If Admin Withdraws \\$VE3D tokens From `VeTokenMinter` Contract",
  "Content": "_Submitted by xiaoming90, also found by 0x1f8b, and VAD37_\n\nIt was observed that users will not be able to get their rewards from the reward contract at certain point of time if admin withdraws \\$VE3D token from the `VeTokenMinter` contract.\n\n### Proof of Concept\n\nBased on the deployment script, it was understood that at the start of the project deployment, 30 million \\$VE3D tokens will be pre-minted for the `VeTokenMinter` contract. Thus, the `veToken.balanceOf(VeTokenMinter.address)` will be 30 million \\$VE3D tokens after the deployment.\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18>\n\n```javascript\n// vetoken minter\nawait deployer.deploy(VeTokenMinter, veTokenAddress);\nlet vetokenMinter = await VeTokenMinter.deployed();\naddContract(\"system\", \"vetokenMinter\", vetokenMinter.address);\nglobal.created = true;\n//mint vetoke to minter contract\nconst vetoken = await VeToken.at(veTokenAddress);\nawait vetoken.mint(vetokenMinter.address, web3.utils.toWei(\"30000000\"), { from: vetokenOperator });\naddContract(\"system\", \"vetoken\", veTokenAddress);\n```\n\nIn the ` VeTokenMinter  ` contract, there is a function called `VeTokenMinter.withdraw` that allows the admin to withdraw \\$VE3D tokens from the contract. Noted that this withdraw function only perform the transfer, but did not update any of the state variables (e.g. totalSupply, maxSupply) in the contract.\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77>\n\n```\nfunction withdraw(address _destination, uint256 _amount) external onlyOwner {\n    veToken.safeTransfer(_destination, _amount);\n\n    emit Withdraw(_destination, _amount);\n}\n```\n\nAssuming that an admin withdrawed 29 million \\$VE3D tokens from the `VoteProxy` with the appropriate approval from the DAO or community for some valid purposes. The `veToken.balanceOf(VeTokenMinter.address)` will be 1 million \\$VE3D tokens after the withdrawal.\n\nAt this point, notice that `veToken.balanceOf(VeTokenMinter.address)` is 1 million, while the `VeTokenMinter.maxSupply` constant is 30 million. Therefore, there exists a discrepency between the actual amount of \\$VE3D tokens (1 million) stored in the contact versus the max supply (30 million).\n\nThis discrepency will cause an issue in the `VeTokenMinter.mint` function because the calculation of the amount of \\$VE3D tokens to be transferred is based on the fact that 30 million \\$VE3D tokens is always sitting in the `VeTokenMinter` contract, and thus there is always sufficient \\$VE3D tokens available in the `VeTokenMinter` contract to send to its users.\n\nThe `uint256 amtTillMax = maxSupply.sub(supply);` code shows that the calculation is based on `maxSupply` constant, which is 30 million.\n\nAssume that `mint(0x001, 10 million)` is called, and the value of the state variables when stepping through this function are as follows:\n\n*   `maxSupply` constant = 30 million\n*   `veToken.balanceOf(VeTokenMinter.address)` = 1 million\n*   `supply` & `totalSupply` = 20 million\n*   `totalCliffs` = 1000\n*   ` reductionPerCliff  ` = 30,000 (maxSupply / totalCliffs)\n*   `cliff` = 666 (supply/reductionPerCliff)\n*   `reduction` = 1000 - 666 = 334\n*   `_amount` = 10 million &ast; (334/1000) = 3.340 million\n*   `amtTillMax` = 10 million (maxSupply - supply) (Over here the contract assume that it still has 10 million VE3D tokens more to reach the max supply)\n*   `(_amount > amtTillMax)` = `False` (since \"3.340 million > 10 million\" = false )\n*   `veToken.safeTransfer(0x001, 3.340 million)` (This will revert. Insufficent balance)\n\nThe `veToken.safeTransfer(0x001, 3.340 million` will fail and revert because `VeTokenMinter` contract does not hold sufficent amount of \\$VE3D tokens to transfer out.`veToken.balanceOf(VeTokenMinter.address)` = 1 million, while the contract was attempting to send out 3.340 million.\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48>\n\n```\nfunction mint(address _to, uint256 _amount) external {\n    require(operators.contains(_msgSender()), \"not an operator\");\n\n    uint256 supply = totalSupply;\n\n    //use current supply to gauge cliff\n    //this will cause a bit of overflow into the next cliff range\n    //but should be within reasonable levels.\n    //requires a max supply check though\n    uint256 cliff = supply.div(reductionPerCliff);\n    //mint if below total cliffs\n    if (cliff < totalCliffs) {\n        //for reduction% take inverse of current cliff\n        uint256 reduction = totalCliffs.sub(cliff);\n        //reduce\n        _amount = _amount.mul(reduction).div(totalCliffs);\n\n        //supply cap check\n        uint256 amtTillMax = maxSupply.sub(supply);\n        if (_amount > amtTillMax) {\n            _amount = amtTillMax;\n        }\n\n        //mint\n        veToken.safeTransfer(_to, _amount);\n        totalSupply += _amount;\n    }\n}\n```\n\nThe failure/revert of `VeTokenMinter.mint` function will cascade up to `Booster.rewardClaimed`, and futher cascade up to `BaseRewardPool.getReward`. Thus, `BaseRewardPool.getReward` will stop working. As a result, the users will not be able to get any rewards from the reward contracts.\n\nThis issue will affect all projects (Curve, Pickle, Ribbon, Idle, Angle, Balancer) because ` VeTokenMinter  ` contract is deployed once, and referenced by all the projects. Thus, the impact could be quite widespread if this occurs, and many users would be affected.\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598>\n\n```\nfunction rewardClaimed(\n    uint256 _pid,\n    address _address,\n    uint256 _amount\n) external returns (bool) {\n    address rewardContract = poolInfo[_pid].veAssetRewards;\n    require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");\n    ITokenMinter veTokenMinter = ITokenMinter(minter);\n    //calc the amount of veAssetEarned\n    uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(\n        veTokenMinter.totalWeight()\n    );\n    //mint reward tokens\n    ITokenMinter(minter).mint(_address, _veAssetEarned);\n\n    return true;\n}\n```\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267>\n\n```\nfunction getReward(address _account, bool _claimExtras)\n    public\n    updateReward(_account)\n    returns (bool)\n{\n    uint256 reward = earned(_account);\n    if (reward > 0) {\n        rewards[_account] = 0;\n        rewardToken.safeTransfer(_account, reward);\n        IDeposit(operator).rewardClaimed(pid, _account, reward);\n        emit RewardPaid(_account, reward);\n    }\n\n    //also get rewards from linked rewards\n    if (_claimExtras) {\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).getReward(_account);\n        }\n    }\n    return true;\n}\n```\n\n### Recommended Mitigation Steps\n\nRemove the `VeTokenMinter.withdraw` function if possible. Otherwise, update the internal accounting of `VeTokenMinter` contract during withdrawal so that the actual balance of the \\$VE3D tokens is taken into consideration within the `VeTokenMinter.mint`, and the contract will not attempt to transfer more tokens than what it has.\n\nOn a side note, [Convex's Minter contract](https://github.com/convex-eth/platform/blob/main/contracts/contracts/Cvx.sol), will mint the `CRX` gov tokens to the users on the fly. See <https://github.com/convex-eth/platform/blob/1f11027d429e454dacc4c959502687eaeffdb74a/contracts/contracts/Cvx.sol#L76>. Thus, there will not be a case where there is not sufficient `CRV` tokens in the contract to send to it users.\n\nHowever, in VeToken Protocol, it attempts to transfer the portion of pre-minted \\$VE3D tokens (30 millions) to the users. See <https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L72>. Thus, it is possible that there is not enough \\$VE3D tokens to send to its users if the admin withdraw the pre-minted \\$VE3D tokens.\n\n**[solvetony (veToken Finance) confirmed and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/202#issuecomment-1156661445):**\n > We might need to withdraw, so we need to fix it.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/202#issuecomment-1193401315):**\n > I have to acknowledge that `mint` can fail if not enough token is present, however I must disagree with the finding.\n> \n> The warden is saying that [`totalSupply`](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L73) is going to be a big number, while the number is updated exclusively after minting happens.\n> \n> For this reason I think the report is mostly invalid. No math issues will happen due to minting to the contract and then withdrawing as the variables will not be set in unrealistic values.\n> \n> However, it is true that `mint`ing an amount greater than what the contract hold will brick the system.\n> For that reason I'll consider the report as valid and Medium, however I believe the POC for the high severity finding to be incorrect.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-vetoken-finance-contest",
  "Code": [
    {
      "filename": "migrations/2_deploy_basic_contracts.js",
      "content": "const { ether, balance, constants, time } = require(\"@openzeppelin/test-helpers\");\nconst RewardFactory = artifacts.require(\"RewardFactory\");\nconst TokenFactory = artifacts.require(\"TokenFactory\");\nconst StashFactory = artifacts.require(\"StashFactory\");\nconst VeTokenMinter = artifacts.require(\"VeTokenMinter\");\nconst PoolManager = artifacts.require(\"PoolManager\");\nconst VeToken = artifacts.require(\"VeToken\");\nconst VE3DRewardPool = artifacts.require(\"VE3DRewardPool\");\nconst { addContract } = require(\"./helper/addContracts\");\nconst VE3DLocker = artifacts.require(\"VE3DLocker\");\n\nmodule.exports = async function (deployer, network, accounts) {\n  global.created = false;\n  const veTokenAddress = \"0x1F209ed40DD77183e9B69c72106F043e0B51bf24\";\n  const vetokenOperator = \"0xa2a379a34cc30c69ab5597bb1c4b6c5c8b23d87e\";\n  const admin = accounts[0];\n  web3.eth.sendTransaction({ from: admin, to: vetokenOperator, value: web3.utils.toWei(\"10\") });\n  // vetoken minter\n  await deployer.deploy(VeTokenMinter, veTokenAddress);\n  let vetokenMinter = await VeTokenMinter.deployed();\n  addContract(\"system\", \"vetokenMinter\", vetokenMinter.address);\n  global.created = true;\n  //mint vetoke to minter contract\n  const vetoken = await VeToken.at(veTokenAddress);\n  await vetoken.mint(vetokenMinter.address, web3.utils.toWei(\"30000000\"), { from: vetokenOperator });\n  addContract(\"system\", \"vetoken\", veTokenAddress);\n\n  // reward factory\n  await deployer.deploy(RewardFactory);\n  const rFactory = await RewardFactory.deployed();\n  addContract(\"system\", \"rFactory\", rFactory.address);\n\n  // token factory\n  await deployer.deploy(TokenFactory);\n  const tFactory = await TokenFactory.deployed();\n  addContract(\"system\", \"tFactory\", tFactory.address);\n\n  //stash factory\n  await deployer.deploy(StashFactory, rFactory.address);\n  const sFactory = await StashFactory.deployed();\n  addContract(\"system\", \"sFactory\", sFactory.address);\n\n  // pool manager\n  await deployer.deploy(PoolManager);\n  const poolManager = await PoolManager.deployed();\n  addContract(\"system\", \"poolManager\", poolManager.address);\n\n  // VE3DRewardPool\n  await deployer.deploy(VE3DRewardPool, veTokenAddress, rFactory.address);\n  const ve3dRewardPool = await VE3DRewardPool.deployed();\n  addContract(\"system\", \"vetokenRewards\", ve3dRewardPool.address);\n\n  // xVE3D Reward Pool\n  await deployer.deploy(VE3DLocker, veTokenAddress);\n  const ve3dLocker = await VE3DLocker.deployed();\n  addContract(\"system\", \"ve3dLocker\", ve3dLocker.address);\n};"
    },
    {
      "filename": "contracts/VeTokenMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract VeTokenMinter is Ownable {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant maxSupply = 30 * 1000000 * 1e18; //30mil\n    ERC20 public veToken;\n    EnumerableSet.AddressSet internal operators;\n    uint256 public totalCliffs;\n    uint256 public reductionPerCliff;\n    uint256 public totalSupply;\n    mapping(address => uint256) public veAssetWeights;\n    uint256 public totalWeight;\n\n    event Withdraw(address destination, uint256 amount);\n\n    constructor(address veTokenAddress) {\n        veToken = ERC20(veTokenAddress);\n        totalCliffs = 1000;\n        reductionPerCliff = maxSupply.div(totalCliffs);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    ///@dev weight is 10**25 precision\n    function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner {\n        require(operators.contains(veAssetOperator), \"not an veAsset operator\");\n        totalWeight -= veAssetWeights[veAssetOperator];\n        veAssetWeights[veAssetOperator] = newWeight;\n        totalWeight += newWeight;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(operators.contains(_msgSender()), \"not an operator\");\n\n        uint256 supply = totalSupply;\n\n        //use current supply to gauge cliff\n        //this will cause a bit of overflow into the next cliff range\n        //but should be within reasonable levels.\n        //requires a max supply check though\n        uint256 cliff = supply.div(reductionPerCliff);\n        //mint if below total cliffs\n        if (cliff < totalCliffs) {\n            //for reduction% take inverse of current cliff\n            uint256 reduction = totalCliffs.sub(cliff);\n            //reduce\n            _amount = _amount.mul(reduction).div(totalCliffs);\n\n            //supply cap check\n            uint256 amtTillMax = maxSupply.sub(supply);\n            if (_amount > amtTillMax) {\n                _amount = amtTillMax;\n            }\n\n            //mint\n            veToken.safeTransfer(_to, _amount);\n            totalSupply += _amount;\n        }\n    }\n\n    function withdraw(address _destination, uint256 _amount) external onlyOwner {\n        veToken.safeTransfer(_destination, _amount);\n\n        emit Withdraw(_destination, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/VeTokenMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract VeTokenMinter is Ownable {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant maxSupply = 30 * 1000000 * 1e18; //30mil\n    ERC20 public veToken;\n    EnumerableSet.AddressSet internal operators;\n    uint256 public totalCliffs;\n    uint256 public reductionPerCliff;\n    uint256 public totalSupply;\n    mapping(address => uint256) public veAssetWeights;\n    uint256 public totalWeight;\n\n    event Withdraw(address destination, uint256 amount);\n\n    constructor(address veTokenAddress) {\n        veToken = ERC20(veTokenAddress);\n        totalCliffs = 1000;\n        reductionPerCliff = maxSupply.div(totalCliffs);\n    }\n\n    function addOperator(address _newOperator) public onlyOwner {\n        operators.add(_newOperator);\n    }\n\n    function removeOperator(address _operator) public onlyOwner {\n        operators.remove(_operator);\n    }\n\n    ///@dev weight is 10**25 precision\n    function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner {\n        require(operators.contains(veAssetOperator), \"not an veAsset operator\");\n        totalWeight -= veAssetWeights[veAssetOperator];\n        veAssetWeights[veAssetOperator] = newWeight;\n        totalWeight += newWeight;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(operators.contains(_msgSender()), \"not an operator\");\n\n        uint256 supply = totalSupply;\n\n        //use current supply to gauge cliff\n        //this will cause a bit of overflow into the next cliff range\n        //but should be within reasonable levels.\n        //requires a max supply check though\n        uint256 cliff = supply.div(reductionPerCliff);\n        //mint if below total cliffs\n        if (cliff < totalCliffs) {\n            //for reduction% take inverse of current cliff\n            uint256 reduction = totalCliffs.sub(cliff);\n            //reduce\n            _amount = _amount.mul(reduction).div(totalCliffs);\n\n            //supply cap check\n            uint256 amtTillMax = maxSupply.sub(supply);\n            if (_amount > amtTillMax) {\n                _amount = amtTillMax;\n            }\n\n            //mint\n            veToken.safeTransfer(_to, _amount);\n            totalSupply += _amount;\n        }\n    }\n\n    function withdraw(address _destination, uint256 _amount) external onlyOwner {\n        veToken.safeTransfer(_destination, _amount);\n\n        emit Withdraw(_destination, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/Booster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/ITokenFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\nimport \"./Interfaces/IStash.sol\";\nimport \"./Interfaces/IStashFactory.sol\";\n\ncontract Booster {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // ve3Token reward pool\n    uint256 public lockIncentive = 1000; //incentive to veAsset stakers\n    // veToken reward pool\n    uint256 public stakerIncentive = 450; //incentive to native token stakers\n    // veToken locking reward pool xVE3D\n    uint256 public stakerLockIncentive;\n    // caller reward\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    // platoform fee\n    uint256 public platformFee; //possible fee to build treasury\n    uint256 public constant MaxFees = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    uint256 public lockFeesIncentive = 10000; //ve3Token veVeAsset fees percentage\n    uint256 public stakerLockFeesIncentive; //xVE3D veVeAsset fees percentage\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public immutable veAsset;\n    address public immutable feeDistro;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //vetoken rewards\n    address public stakerLockRewards; // veToken lock rewards xVE3D\n    address public lockRewards; //ve3Token rewards(veAsset)\n    address public lockFees; //ve3Token veVeAsset fees\n    address public feeToken;\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address veAssetRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n    event OwnerUpdated(address indexed owner);\n    event FeeManagerUpdated(address indexed feeM);\n    event PoolManagerUpdated(address indexed poolM);\n    event FactoriesUpdated(address indexed rfactory, address indexed tfactory);\n    event ArbitratorUpdated(address indexed arb);\n    event VoteDelegateUpdated(address indexed voteDelegate);\n    event RewardContractsUpdated(\n        address indexed rewards,\n        address indexed stakerRewards,\n        address indexed stakerLockRewards\n    );\n    event FeesUpdated(\n        uint256 lockFees,\n        uint256 stakerFees,\n        uint256 stakerLockFee,\n        uint256 callerFees,\n        uint256 platform\n    );\n    event TreasuryUpdated(address indexed treasury);\n    event PoolAdded(\n        address indexed lptoken,\n        address indexed gauge,\n        address indexed token,\n        address rewardPool\n    );\n    event PoolShuttedDown(uint256 indexed pid);\n    event SystemShuttedDown();\n    event Voted(uint256 indexed voteId, address indexed votingAddress, bool support);\n\n    constructor(\n        address _staker,\n        address _minter,\n        address _veAsset,\n        address _feeDistro\n    ) {\n        isShutdown = false;\n        staker = _staker;\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        minter = _minter;\n        veAsset = _veAsset;\n        feeDistro = _feeDistro;\n    }\n\n    /// SETTER SECTION ///\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n        emit OwnerUpdated(_owner);\n    }\n\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n        emit FeeManagerUpdated(_feeM);\n    }\n\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n        emit PoolManagerUpdated(_poolM);\n    }\n\n    function setFactories(\n        address _rfactory,\n        address _sfactory,\n        address _tfactory\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if (rewardFactory == address(0)) {\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n            emit FactoriesUpdated(_rfactory, _tfactory);\n        }\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n    }\n\n    function setArbitrator(address _arb) external {\n        require(msg.sender == owner, \"!auth\");\n        rewardArbitrator = _arb;\n        emit ArbitratorUpdated(_arb);\n    }\n\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender == voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n        emit VoteDelegateUpdated(_voteDelegate);\n    }\n\n    function setRewardContracts(\n        address _rewards,\n        address _stakerRewards,\n        address _stakerLockRewards\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if (lockRewards == address(0)) {\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n            stakerLockRewards = _stakerLockRewards;\n        }\n\n        emit RewardContractsUpdated(_rewards, _stakerRewards, _stakerLockRewards);\n    }\n\n    // Set reward token and claim contract, get from Curve's registry\n    function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        lockFeesIncentive = _lockFeesIncentive;\n        stakerLockFeesIncentive = _stakerLockFeesIncentive;\n\n        address _feeToken = IFeeDistro(feeDistro).token();\n        if (feeToken != _feeToken) {\n            //create a new reward contract for the new token\n            lockFees = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken, lockRewards);\n\n            if (_feeToken != veAsset) {\n                IRewards(stakerLockRewards).addReward(\n                    _feeToken,\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(this),\n                    false\n                );\n            }\n\n            feeToken = _feeToken;\n        }\n    }\n\n    function setFees(\n        uint256 _lockFees,\n        uint256 _stakerFees,\n        uint256 _stakerLockIncentiveFee,\n        uint256 _callerFees,\n        uint256 _platform\n    ) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform).add(\n            _stakerLockIncentiveFee\n        );\n        require(total <= MaxFees, \">MaxFees\");\n\n        //values must be within certain ranges\n\n        lockIncentive = _lockFees;\n        stakerIncentive = _stakerFees;\n        stakerLockIncentive = _stakerLockIncentiveFee;\n        earmarkIncentive = _callerFees;\n        platformFee = _platform;\n        emit FeesUpdated(_lockFees, _stakerFees, _stakerLockIncentiveFee, _callerFees, _platform);\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender == feeManager, \"!auth\");\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// END SETTER SECTION ///\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool) {\n        require(msg.sender == poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0), \"!param\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for veAsset rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateVeAssetRewards(pid, token);\n\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(\n            pid,\n            veAsset,\n            _gauge,\n            staker,\n            _stashVersion\n        );\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                veAssetRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if (stash != address(0)) {\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash, true);\n            IRewardFactory(rewardFactory).setAccess(stash, true);\n        }\n        emit PoolAdded(_lptoken, _gauge, token, newRewardPool);\n\n        return true;\n    }\n\n    //shutdown pool\n    function shutdownPool(uint256 _pid) external returns (bool) {\n        require(msg.sender == poolManager, \"!auth\");\n        PoolInfo storage pool = poolInfo[_pid];\n\n        //withdraw from gauge\n        try IStaker(staker).withdrawAll(pool.lptoken, pool.gauge) {} catch {}\n\n        pool.shutdown = true;\n        gaugeMap[pool.gauge] = false;\n\n        emit PoolShuttedDown(_pid);\n        return true;\n    }\n\n    //shutdown this contract.\n    //  unstake and pull all lp tokens to this address\n    //  only allow withdrawals\n    function shutdownSystem() external {\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            PoolInfo storage pool = poolInfo[i];\n            if (pool.shutdown) continue;\n\n            address token = pool.lptoken;\n            address gauge = pool.gauge;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token, gauge) {\n                pool.shutdown = true;\n            } catch {}\n        }\n        emit SystemShuttedDown();\n    }\n\n    //deposit lp tokens and stake\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) public returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);\n\n        //stake\n        address gauge = pool.gauge;\n        require(gauge != address(0), \"!gauge setting\");\n        IStaker(staker).deposit(lptoken, gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            IStash(stash).stashRewards();\n        }\n\n        address token = pool.token;\n        if (_stake) {\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this), _amount);\n            address rewardContract = pool.veAssetRewards;\n            IERC20(token).safeApprove(rewardContract, _amount);\n            IRewards(rewardContract).stakeFor(msg.sender, _amount);\n        } else {\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender, _amount);\n        }\n\n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid, balance, _stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n        address gauge = pool.gauge;\n\n        //remove lp balance\n        address token = pool.token;\n        ITokenMinter(token).burn(_from, _amount);\n\n        //pull from gauge if not shutdown\n        // if shutdown tokens will be in this contract\n        if (!pool.shutdown) {\n            IStaker(staker).withdraw(lptoken, gauge, _amount);\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown since stashes wont have access\n        address stash = pool.stash;\n        if (stash != address(0) && !isShutdown && !pool.shutdown) {\n            IStash(stash).stashRewards();\n        }\n\n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns (bool) {\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    //allow reward contracts to send here and withdraw to user\n    function withdrawTo(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        _withdraw(_pid, _amount, msg.sender, _to);\n        return true;\n    }\n\n    /**\n     * @notice set valid vote hash on VoterProxy\n     */\n    function setVote(bytes32 _hash, bool valid) external returns (bool) {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).setVote(_hash, valid);\n        return true;\n    }\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).voteGaugeWeight(_gauge, _weight);\n\n        return true;\n    }\n\n    function claimRewards(uint256 _pid, address _gauge) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n\n        IStaker(staker).claimRewards(_gauge);\n        return true;\n    }\n\n    function setGaugeRedirect(uint256 _pid) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n        address gauge = poolInfo[_pid].gauge;\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(keccak256(\"set_rewards_receiver(address)\")),\n            stash\n        );\n        IStaker(staker).execute(gauge, uint256(0), data);\n        return true;\n    }\n\n    //claim veAsset and extra rewards and disperse to reward contracts\n    function _earmarkRewards(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        address gauge = pool.gauge;\n\n        //claim veAsset\n        IStaker(staker).claimVeAsset(gauge);\n\n        //check if there are extra rewards\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            //claim extra rewards\n            IStash(stash).claimRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\n        //veAsset balance\n        uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));\n\n        if (veAssetBal > 0) {\n            uint256 _lockIncentive = veAssetBal.mul(lockIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerIncentive = veAssetBal.mul(stakerIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerLockIncentive = veAssetBal.mul(stakerLockIncentive).div(\n                FEE_DENOMINATOR\n            );\n            uint256 _callIncentive = veAssetBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);\n\n            //send treasury\n            if (treasury != address(0) && treasury != address(this) && platformFee > 0) {\n                //only subtract after address condition check\n                uint256 _platform = veAssetBal.mul(platformFee).div(FEE_DENOMINATOR);\n                veAssetBal = veAssetBal.sub(_platform);\n                IERC20(veAsset).safeTransfer(treasury, _platform);\n            }\n\n            //remove incentives from balance\n            veAssetBal = veAssetBal\n                .sub(_lockIncentive)\n                .sub(_callIncentive)\n                .sub(_stakerIncentive)\n                .sub(_stakerLockIncentive);\n\n            //send incentives for calling\n            if (_callIncentive > 0) {\n                IERC20(veAsset).safeTransfer(msg.sender, _callIncentive);\n            }\n\n            //send veAsset to lp provider reward contract\n            address rewardContract = pool.veAssetRewards;\n            IERC20(veAsset).safeTransfer(rewardContract, veAssetBal);\n            IRewards(rewardContract).queueNewRewards(veAssetBal);\n\n            //send lockers' share of veAsset to reward contract\n            if (_lockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(lockRewards, _lockIncentive);\n                IRewards(lockRewards).queueNewRewards(_lockIncentive);\n            }\n            //send stakers's share of veAsset to VE3D reward contract\n            if (_stakerIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerRewards, _stakerIncentive);\n                IRewards(stakerRewards).queueNewRewards(veAsset, _stakerIncentive);\n            }\n\n            //send stakers's lock share of veAsset to VE3D locker reward contract\n            if (_stakerLockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerLockRewards, _stakerLockIncentive);\n                IRewards(stakerLockRewards).queueNewRewards(veAsset, _stakerLockIncentive);\n            }\n        }\n    }\n\n    function earmarkRewards(uint256 _pid) external returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        _earmarkRewards(_pid);\n        return true;\n    }\n\n    //claim fees from fee distro contract, put in lockers' reward contract\n    function earmarkFees() external returns (bool) {\n        //claim fee rewards\n        IStaker(staker).claimFees(feeDistro, feeToken);\n        //send fee rewards to reward contract\n        uint256 _balance = IERC20(feeToken).balanceOf(address(this));\n\n        uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);\n        uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(\n            FEE_DENOMINATOR\n        );\n        if (_lockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);\n            IRewards(lockFees).queueNewRewards(_lockFeesIncentive);\n        }\n        if (_stakerLockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);\n            IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);\n        }\n        return true;\n    }\n\n    //callback from reward contract when veAsset is received.\n    function rewardClaimed(\n        uint256 _pid,\n        address _address,\n        uint256 _amount\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");\n        ITokenMinter veTokenMinter = ITokenMinter(minter);\n        //calc the amount of veAssetEarned\n        uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(\n            veTokenMinter.totalWeight()\n        );\n        //mint reward tokens\n        ITokenMinter(minter).mint(_address, _veAssetEarned);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/IDeposit.sol\";\n\ncontract BaseRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 constant BLOCKS_PER_DAY = 6450;\n    uint256 constant BLOCKS_PER_YEAR = BLOCKS_PER_DAY * 365;\n    uint256 constant EXTRA_REWARD_POOLS = 3;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event ExtraRewardAdded(address indexed reward);\n    event ExtraRewardCleared();\n    event RewardUpdated(\n        address indexed user,\n        uint256 reward,\n        uint256 rewardPerTokenStored,\n        uint256"
    }
  ]
}