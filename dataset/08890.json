{
  "Title": "[N-08] Inconsistent spacing in comments",
  "Content": "Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file\n\n*There are 3 instances of this issue:*\n```solidity\nFile: protocol/contracts/utils/CvxMintAmount.sol   #1\n\n11:       uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L11\n\n```solidity\nFile: protocol/contracts/utils/CvxMintAmount.sol   #2\n\n14:           IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L14\n\n```solidity\nFile: protocol/contracts/tokenomics/InflationManager.sol   #3\n\n532:      //TOOD: See if this is still needed somewhere\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/utils/CvxMintAmount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nabstract contract CvxMintAmount {\n    using UncheckedMath for uint256;\n\n    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens\n    uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs\n    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply\n    IERC20 private constant _CVX_TOKEN =\n        IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token\n\n    function getCvxMintAmount(uint256 crvEarned) public view returns (uint256) {\n        //first get total supply\n        uint256 cvxTotalSupply = _CVX_TOKEN.totalSupply();\n\n        //get current cliff\n        uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE;\n\n        //if current cliff is under the max\n        if (currentCliff >= _CLIFF_COUNT) return 0;\n\n        //get remaining cliffs\n        uint256 remaining = _CLIFF_COUNT.uncheckedSub(currentCliff);\n\n        //multiply ratio of remaining cliffs to total cliffs against amount CRV received\n        uint256 cvxEarned = (crvEarned * remaining) / _CLIFF_COUNT;\n\n        //double check we have not gone over the max supply\n        uint256 amountTillMax = _MAX_SUPPLY - cvxTotalSupply;\n        if (cvxEarned > amountTillMax) cvxEarned = amountTillMax;\n        return cvxEarned;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/utils/CvxMintAmount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nabstract contract CvxMintAmount {\n    using UncheckedMath for uint256;\n\n    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens\n    uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs\n    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply\n    IERC20 private constant _CVX_TOKEN =\n        IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token\n\n    function getCvxMintAmount(uint256 crvEarned) public view returns (uint256) {\n        //first get total supply\n        uint256 cvxTotalSupply = _CVX_TOKEN.totalSupply();\n\n        //get current cliff\n        uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE;\n\n        //if current cliff is under the max\n        if (currentCliff >= _CLIFF_COUNT) return 0;\n\n        //get remaining cliffs\n        uint256 remaining = _CLIFF_COUNT.uncheckedSub(currentCliff);\n\n        //multiply ratio of remaining cliffs to total cliffs against amount CRV received\n        uint256 cvxEarned = (crvEarned * remaining) / _CLIFF_COUNT;\n\n        //double check we have not gone over the max supply\n        uint256 amountTillMax = _MAX_SUPPLY - cvxTotalSupply;\n        if (cvxEarned > amountTillMax) cvxEarned = amountTillMax;\n        return cvxEarned;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/tokenomics/IKeeperGauge.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/EnumerableMapping.sol\";\nimport \"../../libraries/EnumerableExtensions.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nimport \"./Minter.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract InflationManager is Authorization, IInflationManager, Preparable {\n    using UncheckedMath for uint256;\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable addressProvider;\n\n    bytes32 internal constant _KEEPER_WEIGHT_KEY = \"keeperWeight\";\n    bytes32 internal constant _AMM_WEIGHT_KEY = \"ammWeight\";\n    bytes32 internal constant _LP_WEIGHT_KEY = \"lpWeight\";\n\n    address public minter;\n    bool public weightBasedKeeperDistributionDeactivated;\n    uint256 public totalKeeperPoolWeight;\n    uint256 public totalLpPoolWeight;\n    uint256 public totalAmmTokenWeight;\n\n    // Pool -> keeperGauge\n    EnumerableMapping.AddressToAddressMap private _keeperGauges;\n    // AMM token -> ammGauge\n    EnumerableMapping.AddressToAddressMap private _ammGauges;\n\n    mapping(address => bool) public gauges;\n\n    event NewKeeperWeight(address indexed pool, uint256 newWeight);\n    event NewLpWeight(address indexed pool, uint256 newWeight);\n    event NewAmmTokenWeight(address indexed token, uint256 newWeight);\n\n    modifier onlyGauge() {\n        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setMinter(address _minter) external override onlyGovernance returns (bool) {\n        require(minter == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_minter != address(0), Error.INVALID_MINTER);\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Advance the keeper gauge for a pool by on epoch.\n     * @param pool Pool for which the keeper gauge is advanced.\n     * @return `true` if successful.\n     */\n    function advanceKeeperGaugeEpoch(address pool) external override onlyGovernance returns (bool) {\n        IKeeperGauge(_keeperGauges.get(pool)).advanceEpoch();\n        return true;\n    }\n\n    /**\n     * @notice Mints BKD tokens.\n     * @param beneficiary Address to receive the tokens.\n     * @param amount Amount of tokens to mint.\n     */\n    function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {\n        Minter(minter).mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Deactivates the weight-based distribution of keeper inflation.\n     * @dev This can only be done once, when the keeper inflation mechanism is altered.\n     * @return `true` if successful.\n     */\n    function deactivateWeightBasedKeeperDistribution()\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(!weightBasedKeeperDistributionDeactivated, \"Weight-based dist. deactivated.\");\n        address[] memory liquidityPools = addressProvider.allPools();\n        uint256 length = liquidityPools.length;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            _removeKeeperGauge(address(liquidityPools[i]));\n        }\n        weightBasedKeeperDistributionDeactivated = true;\n        return true;\n    }\n\n    /**\n     * @notice Checkpoints all gauges.\n     * @dev This is mostly used upon inflation rate updates.\n     * @return `true` if successful.\n     */\n    function checkpointAllGauges() external override returns (bool) {\n        uint256 length = _keeperGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();\n        }\n        address[] memory stakerVaults = addressProvider.allStakerVaults();\n        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {\n            IStakerVault(stakerVaults[i]).poolCheckpoint();\n        }\n\n        length = _ammGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a keeper pool weight (with time delay enforced).\n     * @param pool Pool to update the keeper weight for.\n     * @param newPoolWeight New weight for the keeper inflation for the pool.\n     * @return `true` if successful.\n     */\n    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of keeper pool weight (with time delay enforced).\n     * @param pool Pool to execute the keeper weight update for.\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New keeper pool weight.\n     */\n    function executeKeeperPoolWeight(address pool) external override returns (uint256) {\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _executeKeeperPoolWeight(key, pool, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of keeperGauge weights (with time delay enforced).\n     * @dev Each entry in the pools array corresponds to an entry in the weights array.\n     * @param pools Pools to update the keeper weight for.\n     * @param weights New weights for the keeper inflation for the pools.\n     * @return `true` if successful.\n     */\n    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        require(length == weights.length, Error.INVALID_ARGUMENT);\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);\n            key = _getKeeperGaugeKey(pools[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    function whitelistGauge(address gauge) external override onlyRole(Roles.CONTROLLER) {\n        gauges[gauge] = true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of _keeperGauges.\n     * @param pools Pools to execute the keeper weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteKeeperPoolWeights(address[] calldata pools)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            key = _getKeeperGaugeKey(pools[i]);\n            _executeKeeperPoolWeight(key, pools[i], isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    function removeStakerVaultFromInflation(address stakerVault, address lpToken)\n        external\n        override\n        onlyRole(Roles.CONTROLLER)\n    {\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, 0);\n        _executeLpPoolWeight(key, lpToken, stakerVault, true);\n    }\n\n    /**\n     * @notice Prepare update of a lp pool weight (with time delay enforced).\n     * @param lpToken LP token to update the weight for.\n     * @param newPoolWeight New LP inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeLpPoolWeight(address lpToken) external override returns (uint256) {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of LP token weights (with time delay enforced).\n     * @dev Each entry in the lpTokens array corresponds to an entry in the weights array.\n     * @param lpTokens LpTokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the LpTokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        require(length == weights.length, \"Invalid length of arguments\");\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            address stakerVault = addressProvider.getStakerVault(lpTokens[i]);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpTokens[i]);\n            key = _getLpStakerVaultKey(stakerVault);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of LpTokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param lpTokens LpTokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteLpPoolWeights(address[] calldata lpTokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            address lpToken = lpTokens[i];\n            address stakerVault = addressProvider.getStakerVault(lpToken);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpToken);\n            bytes32 key = _getLpStakerVaultKey(stakerVault);\n            _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare an inflation weight update for an AMM token (with time delay enforced).\n     * @param token AMM token to update the weight for.\n     * @param newTokenWeight New AMM token inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareAmmTokenWeight(address token, uint256 newTokenWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        require(_ammGauges.contains(token), \"amm gauge not found\");\n        bytes32 key = _getAmmGaugeKey(token);\n        _prepare(key, newTokenWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeAmmTokenWeight(address token) external override returns (uint256) {\n        bytes32 key = _getAmmGaugeKey(token);\n        _executeAmmTokenWeight(token, key, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Registers a pool's strategy with the stakerVault of the pool where the strategy deposits.\n     * @dev This simply avoids the strategy accumulating tokens in the deposit pool.\n     * @param depositStakerVault StakerVault of the pool where the strategy deposits.\n     * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses).\n     * @return `true` if successful.\n     */\n    function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        IVault _vault = ILiquidityPool(strategyPool).getVault();\n        IStakerVault(depositStakerVault).addStrategy(address(_vault.getStrategy()));\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a batch of AMM token weights (with time delay enforced).\n     * @dev Each entry in the tokens array corresponds to an entry in the weights array.\n     * @param tokens AMM tokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the AMM tokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = tokens.length;\n        bytes32 key;\n        require(length == weights.length, \"Invalid length of arguments\");\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            require(_ammGauges.contains(tokens[i]), \"amm gauge not found\");\n            key = _getAmmGaugeKey(tokens[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of AMM tokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param tokens AMM tokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteAmmTokenWeights(address[] calldata tokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = tokens.length;\n        bool isWeightManager = isInflationWeightManager(msg.sender);\n        bytes32 key;\n        address token;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            token = tokens[i];\n            key = _getAmmGaugeKey(token);\n            _executeAmmTokenWeight(token, key, isWeightManager);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Sets the KeeperGauge for a pool.\n     * @dev Multiple pools can have the same KeeperGauge.\n     * @param pool Address of pool to set the KeeperGauge for.\n     * @param _keeperGauge Address of KeeperGauge.\n     * @return `true` if successful.\n     */\n    function setKeeperGauge(address pool, address _keeperGauge)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = _keeperGauges.length();\n        bool keeperGaugeExists = false;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            if (address(_keeperGauges.valueAt(i)) == _keeperGauge) {\n                keeperGaugeExists = true;\n                break;\n            }\n        }\n        // Check to make sure that once weight-based dist is deactivated, only one gauge can exist\n        if (!keeperGaugeExists && weightBasedKeeperDistributionDeactivated && length >= 1) {\n            return false;\n        }\n        (bool exists, address keeperGauge) = _keeperGauges.tryGet(pool);\n        require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT);\n\n        if (exists && !IKeeperGauge(keeperGauge).killed()) {\n            IKeeperGauge(keeperGauge).poolCheckpoint();\n            IKeeperGauge(keeperGauge).kill();\n        }\n        _keeperGauges.set(pool, _keeperGauge);\n        gauges[_keeperGauge] = true;\n        return true;\n    }\n\n    function removeKeeperGauge(address pool) external onlyGovernance returns (bool) {\n        _removeKeeperGauge(pool);\n        return true;\n    }\n\n    /**\n     * @notice Sets the AmmGauge for a particular AMM token.\n     * @param token Address of the amm token.\n     * @param _ammGauge Address of AmmGauge.\n     * @return `true` if successful.\n     */\n    function setAmmGauge(address token, address _ammGauge)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED);\n        uint256 length = _ammGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            if (address(_ammGauges.valueAt(i)) == _ammGauge) {\n                return false;\n            }\n        }\n        if (_ammGauges.contains(token)) {\n            address ammGauge = _ammGauges.get(token);\n            IAmmGauge(ammGauge).poolCheckpoint();\n            IAmmGauge(ammGauge).kill();\n        }\n        _ammGauges.set(token, _ammGauge);\n        gauges[_ammGauge] = true;\n        return true;\n    }\n\n    function removeAmmGauge(address token) external override onlyGovernance returns (bool) {\n        if (!_ammGauges.contains(token)) return false;\n        address ammGauge = _ammGauges.get(token);\n        bytes32 key = _getAmmGaugeKey(token);\n        _prepare(key, 0);\n        _executeAmmTokenWeight(token, key, true);\n        IAmmGauge(ammGauge).kill();\n        _ammGauges.remove(token);\n        // Do not delete from the gauges map to allow claiming of remaining balances\n        emit AmmGaugeDelisted(token, ammGauge);\n        return true;\n    }\n\n    function addGaugeForVault(address lpToken) external override returns (bool) {\n        IStakerVault _stakerVault = IStakerVault(msg.sender);\n        require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS);\n        address lpGauge = _stakerVault.getLpGauge();\n        require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST);\n        gauges[lpGauge] = true;\n        return true;\n    }\n\n    function getAllAmmGauges() external view override returns (address[] memory) {\n        return _ammGauges.valuesArray();\n    }\n\n    function getLpRateForStakerVault(address stakerVault) external view override returns (uint256) {\n        if (minter == address(0) || totalLpPoolWeight == 0) {\n            return 0;\n        }\n\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        uint256 lpInflationRate = Minter(minter).getLpInflationRate();\n        uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;\n\n        return poolInflationRate;\n    }\n\n    function getKeeperRateForPool(address pool) external view override returns (uint256) {\n        if (minter == address(0)) {\n            return 0;\n        }\n        uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();\n        // After deactivation of weight based dist, KeeperGauge handles the splitting\n        if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;\n        if (totalKeeperPoolWeight == 0) return 0;\n        bytes32 key = _getKeeperGaugeKey(pool);\n        uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /\n            totalKeeperPoolWeight;\n        return poolInflationRate;\n    }\n\n    function getAmmRateForToken(address token) external view override returns (uint256) {\n        if (minter == address(0) || totalAmmTokenWeight == 0) {\n            return 0;\n        }\n        bytes32 key = _getAmmGaugeKey(token);\n        uint256 ammInflationRate = Minter(minter).getAmmInflationRate();\n        uint256 ammTokenInflationRate = (currentUInts256[key] * ammInflationRate) /\n            totalAmmTokenWeight;\n        return ammTokenInflationRate;\n    }\n\n    //TOOD: See if this is still needed somewhere\n    function getKeeperWeightForPool(address pool) external view override returns (uint256) {\n        bytes32 key = _getKeeperGaugeKey(pool);\n        return currentUInts256[key];\n    }\n\n    function getAmmWeightForToken(address token) external view override returns (uint256) {\n        bytes32 key = _getAmmGaugeKey(token);\n        return currentUInts256[key];\n    }\n\n    function getLpPoolWeight(address lpToken) external view override returns (uint256) {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        return currentUInts256[key];\n    }\n\n    function getKeeperGaugeForPool(address pool) external view override returns (address) {\n        (, address keeperGauge) = _keeperGauges.tryGet(pool);\n        return keeperGauge;\n    }\n\n    function getAmmGaugeForToken(address token) external view override returns (address) {\n        (, address ammGauge) = _ammGauges.tryGet(token);\n        return ammGauge;\n    }\n\n    /**\n     * @notice Check if an account is governance proxy.\n     * @param account Address to check.\n     * @return `true` if account is governance proxy.\n     */\n    function isInflationWeightManager(address account) public view override returns (bool) {\n        return _roleManager().hasRole(Roles.INFLATION_MANAGER, account);\n    }\n\n    function _executeKeeperPoolWeight(\n        bytes32 key,\n        address pool,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IKeeperGauge(_keeperGauges.get(pool)).poolCheckpoint();\n        totalKeeperPoolWeight = totalKeeperPoolWeight - currentUInts256[key] + pendingUInts256[key];\n        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        emit NewKeeperWeight(pool, currentUInts256[key]);\n        return true;\n    }\n\n    function _executeLpPoolWeight(\n        bytes32 key,\n        address lpToken,\n        address stakerVault,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IStakerVault(stakerVault).poolCheckpoint();\n        totalLpPoolWeight = totalLpPoolWeight - currentUInts256[key] + pendingUInts256[key];\n        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        emit NewLpWeight(lpToken, currentUInts256[key]);\n        return true;\n    }\n\n    function _executeAmmTokenWeight(\n        address token,\n        bytes32 key,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IAmmGauge(_ammGauges.get(token)).poolCheckpoint();\n        totalAmmTokenWeight = totalAmmTokenWeight - currentUInts256[key] + pendingUInts256[key];\n        totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        // Do pool checkpoint to update the pool integrals\n        emit NewAmmTokenWeight(token, currentUInts256[key]);\n        return true;\n    }\n\n    function _removeKeeperGauge(address pool) internal {\n        address keeperGauge = _keeperGauges.get(pool);\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _prepare(key, 0);\n        _executeKeeperPoolWeight(key, pool, true);\n        _keeperGauges.remove(pool);\n        IKeeperGauge(keeperGauge).kill();\n        // Do not delete from the gauges map to allow claiming of remaining balances\n        emit KeeperGaugeDelisted(pool, keeperGauge);\n    }\n\n    function _ensurePoolExists(address lpToken) internal view {\n        require(\n            address(addressProvider.safeGetPoolForToken(lpToken)) != address(0),\n            Error.ADDRESS_NOT_FOUND\n        );\n    }\n\n    function _getKeeperGaugeKey(address pool) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_KEEPER_WEIGHT_KEY, pool));\n    }\n\n    function _getAmmGaugeKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_AMM_WEIGHT_KEY, token));\n    }\n\n    function _getLpStakerVaultKey(address vault) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_LP_WEIGHT_KEY, vault));\n    }\n}"
    }
  ]
}