{
  "Title": "[L-03] Safe.sol does not check contract existence",
  "Content": "\n`Safe.sol` is used to perform ERC20 transfers in the protocols contracts. It does not check for contract existence, meaning any call to an address with no bytecode (the address zero or an EOA) would not revert upon `Safe.transfer`.\n\nIf there is a market with an underlying token being an empty bytecode address, this means a user can initiate a position without actually transferring any token to `Swivel` - as all protocols except Aave do not check for the underlying token.\n\nAs only an admin can add a market, the risk of this issue affecting the protocols is low.\n\n### Proof of Concept\n\nIn [`Safe.transfer`()](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Swivel/Safe.sol#L79-L87) and [`Safe.transferFrom`](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Swivel/Safe.sol#L112-L119), `success` is set to 1 if the call returns `1`, which is the case if it made to an address with no bytecode.\n\n### Recommended Mitigation Steps\n\nUse `extcodesize()` in `Safe.sol` transfer functions to ensure the destination contract has bytecode.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-07-swivel-v3-contest",
  "Code": [
    {
      "filename": "Swivel/Safe.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Adapted from: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol\npragma solidity 0.8.13;\n\nimport {IErc20} from \"./Interfaces.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\nlibrary Safe {\n    \n    /*//////////////////////////////////////////////////////////////\n                              CUSTOM ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error ETHTransferFailed();\n\n    error TransferFailed();\n\n    error TransferFromFailed();\n\n    error ApproveFailed();\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function transferFrom(\n        IErc20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(4, from) // Append the \"from\" argument.\n            mstore(36, to) // Append the \"to\" argument.\n            mstore(68, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 100, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        if (!success) { revert TransferFromFailed(); }\n    }\n\n    function transfer(\n        IErc20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(4, to) // Append the \"to\" argument.\n            mstore(36, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 68, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        if (!success) { revert TransferFailed(); }\n    }\n\n    function approve(\n        IErc20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(4, to) // Append the \"to\" argument.\n            mstore(36, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 68, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        if (!success) { revert ApproveFailed(); }\n    }\n}"
    }
  ]
}