{
  "Title": "M-3: RFPSimpleStrategy milestones can be set multiple times",
  "Content": "# Issue M-3: RFPSimpleStrategy milestones can be set multiple times \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/176 \n\n## Found by \nGimelSec, HChang26, Martians, WATCHPUG, ace13567, fibonacci, jkoppel, lemonmon, osmanozdemir1\nUntil the first distribution is completed, it's possible to call `setMilestones` function multiple times. New milestones are added to the previous ones. The `totalAmountPercentage` of all milestones in this case will be greater than 100%. It also affects all the contracts that are inherited from RFPSimpleStrategy.\n\n## Vulnerability Detail\n\nThe `setMilestones` function in `RFPSimpleStrategy` contract checks if `MILESTONES_ALREADY_SET` or not by `upcomingMilestone` index.\n\n```solidity\nif (upcomingMilestone != 0) revert MILESTONES_ALREADY_SET();\n```\n\nBut `upcomingMilestone` increases only after distribution, and until this time will always be equal to 0.\n\n## Impact\n\nIt can accidentally break the pool state or be used with malicious intentions.\n\n1. Two managers accidentally set the same milestones. Milestones are duplicated and can't be reset, the pool needs to be recreated.\n2. The manager, in cahoots with the recipient, sets milestones one by one, thereby bypassing `totalAmountPercentage` check and increasing the payout amount.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol#L224-L247\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFix condition if milestones should only be set once. \n\n```solidity\nif (milestones.length > 0) revert MILESTONES_ALREADY_SET();\n```\n\nOr allow milestones to be reset while they are not in use.\n\n\n```solidity\nif (milestones.length > 0) {\n    if (milestones[0].milestoneStatus != Status.None) revert MILESTONES_ALREADY_IN_USE();\n    delete milestones;\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n> Escalate\n> This is invalid. \n> I cannot accept that a pool manager can be malicious\n\n    You've deleted an escalation for this issue.\n\n**jkoppel**\n\n#376 explains how this can cause an issue without a malicious pool owner.\n\n**MLON33**\n\nhttps://github.com/allo-protocol/allo-v2/pull/341\n\n**jack-the-pug**\n\nFixed.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {ReentrancyGuard} from \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n// Interfaces\nimport {IAllo} from \"../../core/interfaces/IAllo.sol\";\nimport {IRegistry} from \"../../core/interfaces/IRegistry.sol\";\n// Core Contracts\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n// Internal Libraries\nimport {Metadata} from \"../../core/libraries/Metadata.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title RFP Simple Strategy\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Strategy for Request for Proposal (RFP) allocation with milestone submission and management.\ncontract RFPSimpleStrategy is BaseStrategy, ReentrancyGuard {\n    /// ================================\n    /// ========== Struct ==============\n    /// ================================\n\n    /// @notice Stores the details of the recipients.\n    struct Recipient {\n        bool useRegistryAnchor;\n        address recipientAddress;\n        uint256 proposalBid;\n        Status recipientStatus;\n    }\n\n    /// @notice Stores the details of the milestone\n    struct Milestone {\n        uint256 amountPercentage;\n        Metadata metadata;\n        Status milestoneStatus;\n    }\n\n    /// @notice Stores the details needed for initializing strategy\n    struct InitializeParams {\n        uint256 maxBid;\n        bool useRegistryAnchor;\n        bool metadataRequired;\n    }\n\n    /// ===============================\n    /// ========== Errors =============\n    /// ===============================\n\n    /// @notice Thrown when the milestone is invalid\n    error INVALID_MILESTONE();\n\n    /// @notice Thrown when the milestone is already accepted\n    error MILESTONE_ALREADY_ACCEPTED();\n\n    /// @notice Thrown when the proposal bid exceeds maximum bid\n    error EXCEEDING_MAX_BID();\n\n    /// @notice Thrown when the milestone are already approved and cannot be changed\n    error MILESTONES_ALREADY_SET();\n\n    /// @notice Thrown when the pool manager attempts to the lower the max bid\n    error AMOUNT_TOO_LOW();\n\n    /// ===============================\n    /// ========== Events =============\n    /// ===============================\n\n    /// @notice Emitted when the maximum bid is increased.\n    /// @param maxBid The mew maximum bid\n    event MaxBidIncreased(uint256 maxBid);\n\n    /// @notice Emitted when a milestone is submitted.\n    /// @param milestoneId Id of the milestone\n    event MilstoneSubmitted(uint256 milestoneId);\n\n    /// @notice Emitted for the status change of a milestone.\n    event MilestoneStatusChanged(uint256 milestoneId, Status status);\n\n    /// @notice Emitted when milestones are set.\n    event MilestonesSet();\n\n    /// @notice Emitted when a recipient updates their registration\n    /// @param recipientId Id of the recipient\n    /// @param data The encoded data - (address recipientId, address recipientAddress, Metadata metadata)\n    /// @param sender The sender of the transaction\n    event UpdatedRegistration(address indexed recipientId, bytes data, address sender);\n\n    /// ================================\n    /// ========== Storage =============\n    /// ================================\n\n    /// @notice Flag to indicate whether to use the registry anchor or not.\n    bool public useRegistryAnchor;\n\n    /// @notice Flag to indicate whether metadata is required or not.\n    bool public metadataRequired;\n\n    /// @notice The accepted recipient who can submit milestones.\n    address public acceptedRecipientId;\n\n    /// @notice The registry contract interface.\n    IRegistry private _registry;\n\n    /// @notice The maximum bid for the RFP pool.\n    uint256 public maxBid;\n\n    /// @notice The upcoming milestone which is to be paid.\n    uint256 public upcomingMilestone;\n\n    /// @notice Internal collection of recipients\n    address[] private _recipientIds;\n\n    /// @notice Collection of milestones submitted by the 'acceptedRecipientId'\n    Milestone[] public milestones;\n\n    /// @notice This maps accepted recipients to their details\n    /// @dev 'recipientId' to 'Recipient'\n    mapping(address => Recipient) internal _recipients;\n\n    /// ===============================\n    /// ======== Constructor ==========\n    /// ===============================\n\n    /// @notice Constructor for the RFP Simple Strategy\n    /// @param _allo The 'Allo' contract\n    /// @param _name The name of the strategy\n    constructor(address _allo, string memory _name) BaseStrategy(_allo, _name) {}\n\n    /// ===============================\n    /// ========= Initialize ==========\n    /// ===============================\n\n    // @notice Initialize the strategy\n    /// @param _poolId ID of the pool\n    /// @param _data The data to be decoded\n    /// @custom:data (uint256 _maxBid, bool registryGating, bool metadataRequired)\n    function initialize(uint256 _poolId, bytes memory _data) external virtual override {\n        (InitializeParams memory initializeParams) = abi.decode(_data, (InitializeParams));\n        __RFPSimpleStrategy_init(_poolId, initializeParams);\n    }\n\n    /// @notice This initializes the BaseStrategy\n    /// @dev You only need to pass the 'poolId' to initialize the BaseStrategy and the rest is specific to the strategy\n    /// @param _initializeParams The initialize params\n    function __RFPSimpleStrategy_init(uint256 _poolId, InitializeParams memory _initializeParams) internal {\n        // Initialize the BaseStrategy\n        __BaseStrategy_init(_poolId);\n\n        // Set the strategy specific variables\n        useRegistryAnchor = _initializeParams.useRegistryAnchor;\n        metadataRequired = _initializeParams.metadataRequired;\n        _registry = allo.getRegistry();\n        _increaseMaxBid(_initializeParams.maxBid);\n\n        // Set the pool to active - this is required for the strategy to work and distribute funds\n        // NOTE: There may be some cases where you may want to not set this here, but will be strategy specific\n        _setPoolActive(true);\n    }\n\n    /// ===============================\n    /// ============ Views ============\n    /// ===============================\n\n    /// @notice Get the recipient\n    /// @param _recipientId ID of the recipient\n    /// @return Recipient Returns the recipient\n    function getRecipient(address _recipientId) external view returns (Recipient memory) {\n        return _getRecipient(_recipientId);\n    }\n\n    /// @notice Checks if msg.sender is eligible for RFP allocation\n    /// @param _recipientId Id of the recipient\n    function _getRecipientStatus(address _recipientId) internal view override returns (Status) {\n        return _getRecipient(_recipientId).recipientStatus;\n    }\n\n    /// @notice Return the payout for acceptedRecipientId\n    function getPayouts(address[] memory, bytes[] memory) external view override returns (PayoutSummary[] memory) {\n        PayoutSummary[] memory payouts = new PayoutSummary[](1);\n        payouts[0] = _getPayout(acceptedRecipientId, \"\");\n\n        return payouts;\n    }\n\n    /// @notice Get the milestone\n    /// @param _milestoneId ID of the milestone\n    /// @return Milestone Returns the milestone\n    function getMilestone(uint256 _milestoneId) external view returns (Milestone memory) {\n        return milestones[_milestoneId];\n    }\n\n    /// @notice Get the status of the milestone\n    /// @param _milestoneId Id of the milestone\n    function getMilestoneStatus(uint256 _milestoneId) external view returns (Status) {\n        return milestones[_milestoneId].milestoneStatus;\n    }\n\n    /// ===============================\n    /// ======= External/Custom =======\n    /// ===============================\n\n    /// @notice Toggle the status between active and inactive.\n    /// @dev 'msg.sender' must be a pool manager to close the pool. Emits a 'PoolActive()' event.\n    /// @param _flag The flag to set the pool to active or inactive\n    function setPoolActive(bool _flag) external {\n        _setPoolActive(_flag);\n        emit PoolActive(_flag);\n    }\n\n    /// @notice Set the milestones for the acceptedRecipientId.\n    /// @dev 'msg.sender' must be a pool manager to set milestones. Emits 'MilestonesSet' event\n    /// @param _milestones Milestone[] The milestones to be set\n    function setMilestones(Milestone[] memory _milestones) external onlyPoolManager(msg.sender) {\n        if (upcomingMilestone != 0) revert MILESTONES_ALREADY_SET();\n\n        uint256 totalAmountPercentage;\n\n        // Loop through the milestones and add them to the milestones array\n        uint256 milestonesLength = _milestones.length;\n        for (uint256 i; i < milestonesLength;) {\n            totalAmountPercentage += _milestones[i].amountPercentage;\n            milestones.push(_milestones[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        // Check if the all milestone amount percentage totals to 1e18(100%)\n        if (totalAmountPercentage != 1e18) revert INVALID_MILESTONE();\n\n        emit MilestonesSet();\n    }\n\n    /// @notice Submit milestone by the acceptedRecipientId.\n    /// @dev 'msg.sender' must be the 'acceptedRecipientId' and must be a member\n    ///      of a 'Profile' to sumbit a milestone. Emits a 'MilestonesSubmitted()' event.\n    /// @param _metadata The proof of work\n    function submitUpcomingMilestone(Metadata calldata _metadata) external {\n        // Check if the 'msg.sender' is the 'acceptedRecipientId' and is a member of the 'Profile'\n        if (acceptedRecipientId != msg.sender && !_isProfileMember(acceptedRecipientId, msg.sender)) {\n            revert UNAUTHORIZED();\n        }\n\n        // Check if the upcoming milestone is in fact upcoming\n        if (upcomingMilestone >= milestones.length) revert INVALID_MILESTONE();\n\n        // Get the milestone and update the metadata and status\n        Milestone storage milestone = milestones[upcomingMilestone];\n        milestone.metadata = _metadata;\n\n        // Set the milestone status to 'Pending' to indicate that the milestone is submitted\n        milestone.milestoneStatus = Status.Pending;\n\n        // Emit event for the milestone\n        emit MilstoneSubmitted(upcomingMilestone);\n    }\n\n    /// @notice Update max bid for RFP pool\n    /// @dev 'msg.sender' must be a pool manager to update the max bid.\n    /// @param _maxBid The max bid to be set\n    function increaseMaxBid(uint256 _maxBid) external onlyPoolManager(msg.sender) {\n        _increaseMaxBid(_maxBid);\n    }\n\n    /// @notice Reject pending milestone submmited by the acceptedRecipientId.\n    /// @dev 'msg.sender' must be a pool manager to reject a milestone. Emits a 'MilestoneStatusChanged()' event.\n    /// @param _milestoneId ID of the milestone\n    function rejectMilestone(uint256 _milestoneId) external onlyPoolManager(msg.sender) {\n        // Check if the milestone is already accepted\n        if (milestones[_milestoneId].milestoneStatus == Status.Accepted) revert MILESTONE_ALREADY_ACCEPTED();\n\n        milestones[_milestoneId].milestoneStatus = Status.Rejected;\n\n        emit MilestoneStatusChanged(_milestoneId, milestones[_milestoneId].milestoneStatus);\n    }\n\n    /// @notice Withdraw funds from pool.\n    /// @dev 'msg.sender' must be a pool manager to withdraw funds.\n    /// @param _amount The amount to be withdrawn\n    function withdraw(uint256 _amount) external onlyPoolManager(msg.sender) onlyInactivePool {\n        // Decrement the pool amount\n        poolAmount -= _amount;\n\n        // Transfer the amount to the pool manager\n        _transferAmount(allo.getPool(poolId).token, msg.sender, _amount);\n    }\n\n    /// ====================================\n    /// ============ Internal ==============\n    /// ====================================\n\n    /// @notice Submit a proposal to RFP pool\n    /// @dev Emits a 'Registered()' event\n    /// @param _data The data to be decoded\n    /// @custom:data when 'useRegistryAnchor' is 'true' -> (address recipientId, uint256 proposalBid, Metadata metadata)\n    ///              when 'useRegistryAnchor' is 'false' -> (address recipientAddress, address registryAnchor, uint256 proposalBid, Metadata metadata)\n    /// @param _sender The sender of the transaction\n    /// @return recipientId The id of the recipient\n    function _registerRecipient(bytes memory _data, address _sender)\n        internal\n        override\n        onlyActivePool\n        returns (address recipientId)\n    {\n        bool isUsingRegistryAnchor;\n        address recipientAddress;\n        address registryAnchor;\n        uint256 proposalBid;\n        Metadata memory metadata;\n\n        // Decode '_data' depending on the 'useRegistryAnchor' flag\n        if (useRegistryAnchor) {\n            /// @custom:data when 'true' -> (address recipientId, uint256 proposalBid, Metadata metadata)\n            (recipientId, proposalBid, metadata) = abi.decode(_data, (address, uint256, Metadata));\n\n            // If the sender is not a profile member this will revert\n            if (!_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        } else {\n            //  @custom:data when 'false' -> (address recipientAddress, address registryAnchor, uint256 proposalBid, Metadata metadata)\n            (recipientAddress, registryAnchor, proposalBid, metadata) =\n                abi.decode(_data, (address, address, uint256, Metadata));\n\n            // Check if the registry anchor is valid so we know whether to use it or not\n            isUsingRegistryAnchor = registryAnchor != address(0);\n\n            // Ternerary to set the recipient id based on whether or not we are using the 'registryAnchor' or '_sender'\n            recipientId = isUsingRegistryAnchor ? registryAnchor : _sender;\n\n            // Checks if the '_sender' is a member of the profile 'anchor' being used and reverts if not\n            if (isUsingRegistryAnchor && !_isProfileMember(recipientId, _sender)) revert UNAUTHORIZED();\n        }\n\n        // Check if the metadata is required and if it is, check if it is valid, otherwise revert\n        if (metadataRequired && (bytes(metadata.pointer).length == 0 || metadata.protocol == 0)) {\n            revert INVALID_METADATA();\n        }\n\n        if (proposalBid > maxBid) {\n            // If the proposal bid is greater than the max bid this will revert\n            revert EXCEEDING_MAX_BID();\n        } else if (proposalBid == 0) {\n            // If the proposal bid is 0, set it to the max bid\n            proposalBid = maxBid;\n        }\n\n        // If the recipient address is the zero address this will revert\n        if (recipientAddress == address(0)) revert RECIPIENT_ERROR(recipientId);\n\n        // Get the recipient\n        Recipient storage recipient = _recipients[recipientId];\n\n        if (recipient.recipientStatus == Status.None) {\n            // If the recipient status is 'None' add the recipient to the '_recipientIds' array\n            _recipientIds.push(recipientId);\n            emit Registered(recipientId, _data, _sender);\n        } else {\n            emit UpdatedRegistration(recipientId, _data, _sender);\n        }\n\n        // update the recipients data\n        recipient.recipientAddress = recipientAddress;\n        recipient.useRegistryAnchor = isUsingRegistryAnchor ? true : recipient.useRegistryAnchor;\n        recipient.proposalBid = proposalBid;\n        recipient.recipientStatus = Status.Pending;\n    }\n\n    /// @notice Select recipient for RFP allocation\n    /// @dev '_sender' must be a pool manager to allocate.\n    /// @param _data The data to be decoded\n    /// @param _sender The sender of the allocation\n    function _allocate(bytes memory _data, address _sender)\n        internal\n        virtual\n        override\n        nonReentrant\n        onlyActivePool\n        onlyPoolManager(_sender)\n    {\n        // Decode the '_data'\n        acceptedRecipientId = abi.decode(_data, (address));\n\n        Recipient storage recipient = _recipients[acceptedRecipientId];\n\n        if (acceptedRecipientId == address(0) || recipient.recipientStatus != Status.Pending) {\n            revert RECIPIENT_ERROR(acceptedRecipientId);\n        }\n\n        // Update status of acceptedRecipientId to accepted\n        recipient.recipientStatus = Status.Accepted;\n\n        _setPoolActive(false);\n\n        IAllo.Pool memory pool = allo.getPool(poolId);\n\n        // Emit event for the allocation\n        emit Allocated(acceptedRecipientId, recipient.proposalBid, pool.token, _sender);\n    }\n\n    /// @notice Distribute the upcoming milestone to acceptedRecipientId.\n    /// @dev '_sender' must be a pool manager to distribute.\n    /// @param _sender The sender of the distribution\n    function _distribute(address[] memory, bytes memory, address _sender)\n        internal\n        virtual\n        override\n        onlyInactivePool\n        onlyPoolManager(_sender)\n    {\n        // check to make sure there is a pending milestone\n        if (upcomingMilestone >= milestones.length) revert INVALID_MILESTONE();\n\n        IAllo.Pool memory pool = allo.getPool(poolId);\n        Milestone storage milestone = milestones[upcomingMilestone];\n        Recipient memory recipient = _recipients[acceptedRecipientId];\n\n        // make sure has enough funds to distribute based on the proposal bid\n        if (recipient.proposalBid > poolAmount) revert NOT_ENOUGH_FUNDS();\n\n        // Calculate the amount to be distributed for the milestone\n        uint256 amount = (recipient.proposalBid * milestone.amountPercentage) / 1e18;\n\n        // Get the pool, subtract the amount and transfer to the recipient\n        poolAmount -= amount;\n        _transferAmount(pool.token, recipient.recipientAddress, amount);\n\n        // Set the milestone status to 'Accepted'\n        milestone.milestoneStatus = Status.Accepted;\n\n        // Increment the upcoming milestone\n        upcomingMilestone++;\n\n        // Emit events for the milestone and the distribution\n        emit MilestoneStatusChanged(upcomingMilestone, Status.Accepted);\n        emit Distributed(acceptedRecipientId, recipient.recipientAddress, amount, _sender);\n    }\n\n    /// @notice Check if sender is a profile owner or member.\n    /// @param _anchor Anchor of the profile\n    /// @param _sender The sender of the transaction\n    /// @return 'true' if the sender is the owner or member of the profile, otherwise 'false'\n    function _isProfileMember(address _anchor, address _sender) internal view returns (bool) {\n        IRegistry.Profile memory profile = _registry.getProfileByAnchor(_anchor);\n        return _registry.isOwnerOrMemberOfProfile(profile.id, _sender);\n    }\n\n    /// @notice Get the recipient.\n    /// @param _recipientId ID of the recipient\n    /// @return recipient Returns the recipient information\n    function _getRecipient(address _recipientId) internal view returns (Recipient memory recipient) {\n        recipient = _recipients[_recipientId];\n\n        if (acceptedRecipientId != address(0) && acceptedRecipientId != _recipientId) {\n            recipient.recipientStatus = recipient.recipientStatus > Status.None ? Status.Rejected : Status.None;\n        }\n    }\n\n    /// @notice Increase max bid for RFP pool\n    /// @param _maxBid The new max bid to be set\n    function _increaseMaxBid(uint256 _maxBid) internal {\n        // make sure the new max bid is greater than the current max bid\n        if (_maxBid < maxBid) revert AMOUNT_TOO_LOW();\n\n        maxBid = _maxBid;\n\n        // emit the new max mid\n        emit MaxBidIncreased(maxBid);\n    }\n\n    /// @notice Get the payout summary for the accepted recipient.\n    /// @return Returns the payout summary for the accepted recipient\n    function _getPayout(address _recipientId, bytes memory) internal view override returns (PayoutSummary memory) {\n        Recipient memory recipient = _recipients[_recipientId];\n        return PayoutSummary(recipient.recipientAddress, recipient.proposalBid);\n    }\n\n    /// @notice Checks if address is eligible allocator.\n    /// @dev This is used to check if the allocator is a pool manager and able to allocate funds from the pool\n    /// @param _allocator Address of the allocator\n    /// @return 'true' if the allocator is a pool manager, otherwise false\n    function _isValidAllocator(address _allocator) internal view override returns (bool) {\n        return allo.isPoolManager(poolId, _allocator);\n    }\n\n    /// @notice This contract should be able to receive native token\n    receive() external payable {}\n}"
    }
  ]
}