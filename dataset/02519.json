{
  "Title": "M-4: Incorrect MOMP calculation in neutral price calculation",
  "Content": "# Issue M-4: Incorrect MOMP calculation in neutral price calculation \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/148 \n\n## Found by \nJeiwan\n\n## Summary\nWhen calculating MOMP to find the neutral price of a borrower, borrower's accrued debt is divided by the total number of loans in the pool, but it's total pool's debt that should be divided. The mistake will result in lower neutral prices and more lost bonds to kickers.\n## Vulnerability Detail\nAs per the whitepaper:\n> MOMP: is the price at which the amount of deposit above it is equal to the average loan size of\nthe pool. MOMP is short for “Most Optimistic Matching Price”, as it’s the price at which a loan of\naverage size would match with the most favorable lenders on the book.\n\nI.e. MOMP is calculated on the total number of loans of a pool (so that the average loan size could be found).\n\nMOMP calculation is [implemented correctly when kicking a debt](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/Auctions.sol#L799), however it's implementation in the [Loans.update](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/internal/Loans.sol#L76) function is not correct:\n```solidity\nuint256 loansInPool = loans_.loans.length - 1 + auctions_.noOfAuctions;\nuint256 curMomp     = _priceAt(Deposits.findIndexOfSum(deposits_, Maths.wdiv(borrowerAccruedDebt_, loansInPool * 1e18)));\n```\nHere, only borrower's debt (`borrowerAccruedDebt_`) is divided, not the entire debt of the pool.\n## Impact\nThe miscalculation affects only borrower's neutral price calculation. Since MOMP is calculated on a smaller debt (borrower's debt will almost always be smaller than total pool's debt), the value of MOMP will be smaller than expected, and the neutral price will also be smaller (from the whitepaper: \"The NP of a loan is the interest-adjusted MOMP...\"). This will cause kickers to lose their bonds more often than expected, as per the whitepaper:\n> If the liquidation auction yields a value that is over the “Neutral Price,” NP, the\nkicker forfeits a portion or all of their bond. \n## Code Snippet\n[Loans.sol#L113-L114](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/internal/Loans.sol#L113-L114)\n## Tool used\nManual Review\n## Recommendation\nConsider using total pool's debt in the MOMP calculation in `Loans.update`.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/libraries/external/Auctions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Lender,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                                    from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    BucketTakeResult,\n    KickResult,\n    SettleParams,\n    TakeResult\n}                                    from '../../interfaces/pool/commons/IPoolInternals.sol';\nimport { StartReserveAuctionParams } from '../../interfaces/pool/commons/IPoolReserveAuctionActions.sol';\n\nimport {\n    _claimableReserves,\n    _indexOf,\n    _isCollateralized,\n    _priceAt,\n    _reserveAuctionPrice,\n    _roundToScale,\n    MAX_FENWICK_INDEX,\n    MAX_PRICE,\n    MIN_PRICE\n}                           from '../helpers/PoolHelper.sol';\nimport { _revertOnMinDebt } from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auctions library\n    @notice External library containing actions involving auctions within pool:\n            - Kickers: kick undercollateralized loans; settle auctions; claim bond rewards\n            - Bidders: take auctioned collateral\n            - Reserve purchasers: start auctions; take reserves\n */\nlibrary Auctions {\n\n    /*******************************/\n    /*** Function Params Structs ***/\n    /*******************************/\n\n    struct BucketTakeParams {\n        address borrower;        // borrower address to take from\n        uint256 collateral;      // [WAD] borrower available collateral to take\n        bool    depositTake;     // deposit or arb take, used by bucket take\n        uint256 index;           // bucket index, used by bucket take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 t0Debt;          // [WAD] borrower t0 debt\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n    struct TakeParams {\n        address borrower;        // borrower address to take from\n        uint256 collateral;      // [WAD] borrower available collateral to take\n        uint256 t0Debt;          // [WAD] borrower t0 debt\n        uint256 takeCollateral;  // [WAD] desired amount to take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 poolType;        // pool type (ERC20 or NFT)\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    struct KickWithDepositLocalVars {\n        uint256 amountToDebitFromDeposit; // [WAD] the amount of quote tokens used to kick and debited from lender deposit\n        uint256 bucketCollateral;         // [WAD] amount of collateral in bucket\n        uint256 bucketDeposit;            // [WAD] amount of quote tokens in bucket\n        uint256 bucketLPs;                // [RAY] LPs of the bucket\n        uint256 bucketPrice;              // [WAD] bucket price\n        uint256 bucketRate;               // [RAY] bucket exchange rate\n        uint256 bucketScale;              // [WAD] bucket scales\n        uint256 bucketUnscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n        uint256 lenderLPs;                // [RAY] LPs of lender in bucket\n        uint256 redeemedLPs;              // [RAY] LPs used by kick action\n    }\n    struct SettleLocalVars {\n        uint256 collateralUsed;    // [WAD] collateral used to settle debt\n        uint256 debt;              // [WAD] debt to settle\n        uint256 depositToRemove;   // [WAD] deposit used by settle auction\n        uint256 index;             // index of settling bucket\n        uint256 maxSettleableDebt; // [WAD] max amount that can be settled with existing collateral\n        uint256 price;             // [WAD] price of settling bucket\n        uint256 scaledDeposit;     // [WAD] scaled amount of quote tokens in bucket\n        uint256 scale;             // [WAD] scale of settling bucket\n        uint256 unscaledDeposit;   // [WAD] unscaled amount of quote tokens in bucket\n    }\n    struct TakeLocalVars {\n        uint256 auctionPrice;             // [WAD] The price of auction.\n        uint256 bondChange;               // [WAD] The change made on the bond size (beeing reward or penalty).\n        uint256 borrowerDebt;             // [WAD] The accrued debt of auctioned borrower.\n        int256  bpf;                      // The bond penalty factor.\n        uint256 bucketPrice;              // [WAD] The bucket price.\n        uint256 bucketScale;              // [WAD] The bucket scale.\n        uint256 collateralAmount;         // [WAD] The amount of collateral taken.\n        uint256 excessQuoteToken;         // [WAD] Difference of quote token that borrower receives after take (for fractional NFT only)\n        uint256 factor;                   // The take factor, calculated based on bond penalty factor.\n        bool    isRewarded;               // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).\n        address kicker;                   // Address of auction kicker.\n        uint256 scaledQuoteTokenAmount;   // [WAD] Unscaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral\n        uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.\n        uint256 t0Debt;                   // [WAD] Borrower's t0 debt.\n        uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.\n        uint256 unscaledDeposit;          // [WAD] Unscaled bucket quantity\n        uint256 unscaledQuoteTokenAmount; // [WAD] The unscaled token amount that taker should pay for collateral taken.\n    }\n    struct TakeLoanLocalVars {\n        uint256 repaidDebt;   // [WAD] the amount of debt repaid to th epool by take auction\n        uint256 borrowerDebt; // [WAD] the amount of borrower debt\n        bool    inAuction;    // true if loan in auction\n    }\n    struct TakeFromLoanLocalVars {\n        uint256 borrowerDebt;          // [WAD] borrower's accrued debt\n        bool    inAuction;             // true if loan still in auction after auction is taken, false otherwise\n        uint256 newLup;                // [WAD] LUP after auction is taken\n        uint256 repaidDebt;            // [WAD] debt repaid when auction is taken\n        uint256 t0DebtInAuction;       // [WAD] t0 pool debt in auction\n        uint256 t0DebtInAuctionChange; // [WAD] t0 change amount of debt after auction is taken\n        uint256 t0PoolDebt;            // [WAD] t0 pool debt\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AuctionSettle(address indexed borrower, uint256 collateral);\n    event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lps, uint256 index);\n    event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);\n    event Kick(address indexed borrower, uint256 debt, uint256 collateral, uint256 bond);\n    event Take(address indexed borrower, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);\n    event ReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice);\n    event Settle(address indexed borrower, uint256 settledDebt);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    error AuctionActive();\n    error AuctionNotClearable();\n    error AuctionPriceGtBucketPrice();\n    error BorrowerOk();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error NoAuction();\n    error NoReserves();\n    error NoReservesAuction();\n    error PriceBelowLUP();\n    error TakeNotPastCooldown();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Settles the debt of the given loan / borrower.\n     *  @dev    write state:\n     *          - Deposits.unscaledRemove() (remove amount in Fenwick tree, from index):\n     *              - update values array state\n     *          - Buckets.addCollateral:\n     *              - increment bucket.collateral and bucket.lps accumulator\n     *              - addLenderLPs:\n     *                  - increment lender.lps accumulator and lender.depositTime state\n     *          - update borrower state\n     *  @dev    reverts on:\n     *              - loan is not in auction NoAuction()\n     *              - 72 hours didn't pass and auction still has collateral AuctionNotClearable()\n     *  @dev    emit events:\n     *              - Settle\n     *              - BucketBankruptcy\n     *  @param  params_ Settle params\n     *  @return collateralRemaining_ The amount of borrower collateral left after settle.\n     *  @return t0DebtRemaining_     The amount of t0 debt left after settle.\n     *  @return collateralSettled_   The amount of collateral settled.\n     *  @return t0DebtSettled_       The amount of t0 debt settled.\n     */\n    function settlePoolDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        SettleParams memory params_\n    ) external returns (\n        uint256 collateralRemaining_,\n        uint256 t0DebtRemaining_,\n        uint256 collateralSettled_,\n        uint256 t0DebtSettled_\n    ) {\n        uint256 kickTime = auctions_.liquidations[params_.borrower].kickTime;\n        if (kickTime == 0) revert NoAuction();\n\n        Borrower memory borrower = loans_.borrowers[params_.borrower];\n        if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n\n        t0DebtSettled_     = borrower.t0Debt;\n        collateralSettled_ = borrower.collateral;\n\n        // auction has debt to cover with remaining collateral\n        while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {\n            SettleLocalVars memory vars;\n\n            (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            vars.unscaledDeposit = Deposits.unscaledValueAt(deposits_, vars.index);\n            vars.price           = _priceAt(vars.index);\n\n            if (vars.unscaledDeposit != 0) {\n                vars.debt              = Maths.wmul(borrower.t0Debt, params_.inflator);       // current debt to be settled\n                vars.maxSettleableDebt = Maths.wmul(borrower.collateral, vars.price);         // max debt that can be settled with existing collateral\n                vars.scaledDeposit     = Maths.wmul(vars.scale, vars.unscaledDeposit);\n\n                // enough deposit in bucket and collateral avail to settle entire debt\n                if (vars.scaledDeposit >= vars.debt && vars.maxSettleableDebt >= vars.debt) {\n                    borrower.t0Debt      = 0;                                                 // no remaining debt to settle\n\n                    vars.unscaledDeposit = Maths.wdiv(vars.debt, vars.scale);                 // remove only what's needed to settle the debt\n                    vars.collateralUsed  = Maths.wdiv(vars.debt, vars.price);\n                }\n\n                // enough collateral, therefore not enough deposit to settle entire debt, we settle only deposit amount\n                else if (vars.maxSettleableDebt >= vars.scaledDeposit) {\n                    borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t0 amount of deposit\n\n                    vars.collateralUsed = Maths.wdiv(vars.scaledDeposit, vars.price);\n                } \n\n                // settle constrained by collateral available\n                else {\n                    borrower.t0Debt      -= Maths.wdiv(vars.maxSettleableDebt, params_.inflator);\n\n                    vars.unscaledDeposit = Maths.wdiv(vars.maxSettleableDebt, vars.scale);\n                    vars.collateralUsed  = borrower.collateral;\n                }\n\n                borrower.collateral             -= vars.collateralUsed;               // move settled collateral from loan into bucket\n                buckets_[vars.index].collateral += vars.collateralUsed;\n\n                Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit); // remove amount to settle debt from bucket (could be entire deposit or only the settled debt)\n            }\n\n            else {\n                // Deposits in the tree is zero, insert entire collateral into lowest bucket 7388\n                Buckets.addCollateral(\n                    buckets_[vars.index],\n                    params_.borrower,\n                    0,  // zero deposit in bucket\n                    borrower.collateral,\n                    vars.price\n                );\n                borrower.collateral = 0; // entire collateral added into bucket\n            }\n\n            --params_.bucketDepth;\n        }\n\n        // if there's still debt and no collateral\n        if (borrower.t0Debt != 0 && borrower.collateral == 0) {\n            // settle debt from reserves -- round reserves down however\n            borrower.t0Debt -= Maths.min(borrower.t0Debt, (params_.reserves / params_.inflator) * 1e18);\n\n            // if there's still debt after settling from reserves then start to forgive amount from next HPB\n            // loop through remaining buckets if there's still debt to settle\n            while (params_.bucketDepth != 0 && borrower.t0Debt != 0) {\n                SettleLocalVars memory vars;\n\n                (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n                vars.unscaledDeposit = Deposits.unscaledValueAt(deposits_, vars.index);\n                vars.depositToRemove = Maths.wmul(vars.scale, vars.unscaledDeposit);\n                vars.debt            = Maths.wmul(borrower.t0Debt, params_.inflator);\n\n                // enough deposit in bucket to settle entire debt\n                if (vars.depositToRemove >= vars.debt) {\n                    Deposits.unscaledRemove(deposits_, vars.index, Maths.wdiv(vars.debt, vars.scale));\n                    borrower.t0Debt  = 0;                                                              // no remaining debt to settle\n\n                // not enough deposit to settle entire debt, we settle only deposit amount\n                } else {\n                    borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit\n\n                    Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);              // Remove all deposit from bucket\n                    Bucket storage hpbBucket = buckets_[vars.index];\n                    \n                    if (hpbBucket.collateral == 0) {                                                   // existing LPB and LP tokens for the bucket shall become unclaimable.\n                        emit BucketBankruptcy(vars.index, hpbBucket.lps);\n                        hpbBucket.lps            = 0;\n                        hpbBucket.bankruptcyTime = block.timestamp;\n                    }\n                }\n\n                --params_.bucketDepth;\n            }\n        }\n\n        t0DebtRemaining_ =  borrower.t0Debt;\n        t0DebtSettled_   -= t0DebtRemaining_;\n\n        emit Settle(params_.borrower, t0DebtSettled_);\n\n        if (borrower.t0Debt == 0) {\n            // settle auction\n            borrower.collateral = _settleAuction(\n                auctions_,\n                buckets_,\n                deposits_,\n                params_.borrower,\n                borrower.collateral,\n                params_.poolType\n            );\n        }\n\n        collateralRemaining_ =  borrower.collateral;\n        collateralSettled_   -= collateralRemaining_;\n\n        // update borrower state\n        loans_.borrowers[params_.borrower] = borrower;\n    }\n\n    /**\n     *  @notice Called to start borrower liquidation and to update the auctions queue.\n     *  @param  poolState_       Current state of the pool.\n     *  @param  borrowerAddress_ Address of the borrower to kick.\n     *  @return kickResult_      The result of the kick action.\n     */\n    function kick(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_\n    ) external returns (\n        KickResult memory\n    ) {\n        return _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrowerAddress_,\n            0\n        );\n    }\n\n    /**\n     *  @notice Called by lenders to kick loans using their deposits.\n     *  @dev    write state:\n     *              - Deposits.unscaledRemove (remove amount in Fenwick tree, from index):\n     *                  - update values array state\n     *              - decrement lender.lps accumulator\n     *              - decrement bucket.lps accumulator\n     *  @dev    emit events:\n     *              - RemoveQuoteToken\n     *  @param  poolState_           Current state of the pool.\n     *  @param  index_               The deposit index from where lender removes liquidity.\n     *  @return kickResult_ The result of the kick action.\n     */\n    function kickWithDeposit(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        mapping(uint256 => Bucket) storage buckets_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        uint256 index_\n    ) external returns (\n        KickResult memory kickResult_\n    ) {\n        Bucket storage bucket = buckets_[index_];\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        KickWithDepositLocalVars memory vars;\n\n        if (bucket.bankruptcyTime < lender.depositTime) vars.lenderLPs = lender.lps;\n\n        vars.bucketLPs             = bucket.lps;\n        vars.bucketCollateral      = bucket.collateral;\n        vars.bucketPrice           = _priceAt(index_);\n        vars.bucketUnscaledDeposit = Deposits.unscaledValueAt(deposits_, index_);\n        vars.bucketScale           = Deposits.scale(deposits_, index_);\n        vars.bucketDeposit         = Maths.wmul(vars.bucketUnscaledDeposit, vars.bucketScale);\n\n        // calculate max amount that can be removed (constrained by lender LPs in bucket, bucket deposit and the amount lender wants to remove)\n        vars.bucketRate = Buckets.getExchangeRate(\n            vars.bucketCollateral,\n            vars.bucketLPs,\n            vars.bucketDeposit,\n            vars.bucketPrice\n        );\n\n        vars.amountToDebitFromDeposit = Maths.rayToWad(Maths.rmul(vars.lenderLPs, vars.bucketRate));  // calculate amount to remove based on lender LPs in bucket\n\n        if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit\n\n        // revert if no amount that can be removed\n        if (vars.amountToDebitFromDeposit == 0) revert InsufficientLiquidity();\n\n        // kick top borrower\n        kickResult_ = _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            Loans.getMax(loans_).borrower,\n            vars.amountToDebitFromDeposit\n        );\n\n        // amount to remove from deposit covers entire bond amount\n        if (vars.amountToDebitFromDeposit > kickResult_.amountToCoverBond) {\n            vars.amountToDebitFromDeposit = kickResult_.amountToCoverBond;                      // cap amount to remove from deposit at amount to cover bond\n\n            kickResult_.lup = _lup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit); // recalculate the LUP with the amount to cover bond\n            kickResult_.amountToCoverBond = 0;                                                  // entire bond is covered from deposit, no additional amount to be send by lender\n        } else {\n            kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;                     // lender should send additional amount to cover bond\n        }\n\n        // revert if the bucket price used to kick and remove is below new LUP\n        if (vars.bucketPrice < kickResult_.lup) revert PriceBelowLUP();\n\n        // remove amount from deposits\n        if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {\n            // In this case we are redeeming the entire bucket exactly, and need to ensure bucket LPs are set to 0\n            vars.redeemedLPs = vars.bucketLPs;\n\n            Deposits.unscaledRemove(deposits_, index_, vars.bucketUnscaledDeposit);\n\n        } else {\n            vars.redeemedLPs = Maths.wrdivr(vars.amountToDebitFromDeposit, vars.bucketRate);\n\n            Deposits.unscaledRemove(\n                deposits_,\n                index_,\n                Maths.wdiv(vars.amountToDebitFromDeposit, vars.bucketScale)\n            );\n        }\n\n        // remove bucket LPs coresponding to the amount removed from deposits\n        lender.lps -= vars.redeemedLPs;\n        bucket.lps -= vars.redeemedLPs;\n\n        emit RemoveQuoteToken(msg.sender, index_, vars.amountToDebitFromDeposit, vars.redeemedLPs, kickResult_.lup);\n    }\n\n    /**\n     *  @notice Performs bucket take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    reverts on:\n     *              - insufficient collateral InsufficientCollateral()\n     *  @param  borrowerAddress_ Borrower address to take.\n     *  @param  depositTake_     If true then the take will happen at an auction price equal with bucket price. Auction price is used otherwise.\n     *  @param  index_           Index of a bucket, likely the HPB, in which collateral will be deposited.\n     *  @return result_          BucketTakeResult struct containing details of take.\n    */\n    function bucketTake(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_,\n        uint256 collateralScale_\n    ) external returns (BucketTakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0\n\n        (\n            result_.collateralAmount,\n            result_.t0RepayAmount,\n            borrower.t0Debt,\n            result_.t0DebtPenalty \n        ) = _takeBucket(\n            auctions_,\n            buckets_,\n            deposits_,\n            BucketTakeParams({\n                borrower:        borrowerAddress_,\n                collateral:      borrower.collateral,\n                t0Debt:          borrower.t0Debt,\n                inflator:        poolState_.inflator,\n                depositTake:     depositTake_,\n                index:           index_,\n                collateralScale: collateralScale_\n            })\n        );\n\n        borrower.collateral -= result_.collateralAmount;\n\n        if (result_.t0DebtPenalty != 0) {\n            poolState_.debt += Maths.wmul(result_.t0DebtPenalty, poolState_.inflator);\n        }\n\n        (\n            result_.poolDebt,\n            result_.newLup,\n            result_.t0DebtInAuctionChange,\n            result_.settledAuction\n        ) = _takeLoan(\n            auctions_,\n            buckets_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrower,\n            borrowerAddress_,\n            result_.t0RepayAmount\n        );\n    }\n\n    /**\n     *  @notice Performs take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    reverts on:\n     *              - insufficient collateral InsufficientCollateral()\n     *  @param  borrowerAddress_ Borrower address to take.\n     *  @param  collateral_      Max amount of collateral that will be taken from the auction (max number of NFTs in case of ERC721 pool).\n     *  @return result_          TakeResult struct containing details of take.\n    */\n    function take(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        uint256 collateral_,\n        uint256 collateralScale_\n    ) external returns (TakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        // revert if borrower's collateral is 0 or if maxCollateral to be taken is 0\n        if (borrower.collateral == 0 || collateral_ == 0) revert InsufficientCollateral();\n\n        (\n            result_.collateralAmount,\n            result_.quoteTokenAmount,\n            result_.t0RepayAmount,\n            borrower.t0Debt,\n            result_.t0DebtPenalty,\n            result_.excessQuoteToken\n        ) = _take(\n            auctions_,\n            TakeParams({\n                borrower:        borrowerAddress_,\n                collateral:      borrower.collateral,\n                t0Debt:          borrower.t0Debt,\n                takeCollateral:  collateral_,\n                inflator:        poolState_.inflator,\n                poolType:        poolState_.poolType,\n                collateralScale: collateralScale_\n            })\n        );\n\n        borrower.collateral -= result_.collateralAmount;\n\n        if (result_.t0DebtPenalty != 0) {\n            poolState_.debt += Maths.wmul(result_.t0DebtPenalty, poolState_.inflator);\n        }\n\n        (\n            result_.poolDebt,\n            result_.newLup,\n            result_.t0DebtInAuctionChange,\n            result_.settledAuction\n        ) = _takeLoan(\n            auctions_,\n            buckets_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrower,\n            borrowerAddress_,\n            result_.t0RepayAmount\n        );\n    }\n\n    /**\n     *  @notice See `IPoolReserveAuctionActions` for descriptions.\n     *  @dev    write state:\n     *              - update reserveAuction.unclaimed accumulator\n     *              - update reserveAuction.kicked timestamp state\n     *  @dev    reverts on:\n     *          - no reserves to claim NoReserves()\n     *  @dev    emit events:\n     *              - ReserveAuction\n     */\n    function startClaimableReserveAuction(\n        AuctionsState storage auctions_,\n        ReserveAuctionState storage reserveAuction_,\n        StartReserveAuctionParams calldata params_\n    ) external returns (uint256 kickerAward_) {\n        uint256 curUnclaimedAuctionReserve = reserveAuction_.unclaimed;\n\n        uint256 claimable = _claimableReserves(\n            Maths.wmul(params_.poolDebt, params_.inflator),\n            params_.poolSize,\n            auctions_.totalBondEscrowed,\n            curUnclaimedAuctionReserve,\n            params_.poolBalance\n        );\n\n        kickerAward_ = Maths.wmul(0.01 * 1e18, claimable);\n\n        curUnclaimedAuctionReserve += claimable - kickerAward_;\n\n        if (curUnclaimedAuctionReserve == 0) revert NoReserves();\n\n        reserveAuction_.unclaimed = curUnclaimedAuctionReserve;\n        reserveAuction_.kicked    = block.timestamp;\n\n        emit ReserveAuction(curUnclaimedAuctionReserve, _reserveAuctionPrice(block.timestamp));\n    }\n\n    /**\n     *  @notice See `IPoolReserveAuctionActions` for descriptions.\n     *  @dev    write state:\n     *              - decrement reserveAuction.unclaimed accumulator\n     *  @dev    reverts on:\n     *              - not kicked or 72 hours didn't pass NoReservesAuction()\n     *  @dev    emit events:\n     *              - ReserveAuction\n     */\n    function takeReserves(\n        ReserveAuctionState storage reserveAuction_,\n        uint256 maxAmount_\n    ) external returns (uint256 amount_, uint256 ajnaRequired_) {\n        uint256 kicked = reserveAuction_.kicked;\n\n        if (kicked != 0 && block.timestamp - kicked <= 72 hours) {\n            uint256 unclaimed = reserveAuction_.unclaimed;\n            uint256 price     = _reserveAuctionPrice(kicked);\n\n            amount_       = Maths.min(unclaimed, maxAmount_);\n            ajnaRequired_ = Maths.wmul(amount_, price);\n\n            unclaimed -= amount_;\n\n            reserveAuction_.unclaimed = unclaimed;\n\n            emit ReserveAuction(unclaimed, price);\n        } else {\n            revert NoReservesAuction();\n        }\n    }\n\n    /***************************/\n    /***  Internal Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Performs auction settle based on pool type, emits settle event and removes auction from auctions queue.\n     *  @dev    emit events:\n     *              - AuctionNFTSettle or AuctionSettle\n     *  @param  borrowerAddress_     Address of the borrower that exits auction.\n     *  @param  borrowerCollateral_  Borrower collateral amount before auction exit (in NFT could be fragmented as result of partial takes).\n     *  @param  poolType_            Type of the pool (can be ERC20 or NFT).\n     *  @return remainingCollateral_ Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).\n     */\n    function _settleAuction(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        address borrowerAddress_,\n        uint256 borrowerCollateral_,\n        uint256 poolType_\n    ) internal returns (uint256 remainingCollateral_) {\n        if (poolType_ == uint8(PoolType.ERC721)) {\n            uint256 lps;\n            uint256 bucketIndex;\n\n            (remainingCollateral_, lps, bucketIndex) = _settleNFTCollateral(\n                auctions_,\n                buckets_,\n                deposits_,\n                borrowerAddress_,\n                borrowerCollateral_\n            );\n\n            emit AuctionNFTSettle(borrowerAddress_, remainingCollateral_, lps, bucketIndex);\n\n        } else {\n            remainingCollateral_ = borrowerCollateral_;\n\n            emit AuctionSettle(borrowerAddress_, remainingCollateral_);\n        }\n\n        _removeAuction(auctions_, borrowerAddress_);\n    }\n\n    /**\n     *  @notice Performs NFT collateral settlement by rounding down borrower's collateral amount and by moving borrower's token ids to pool claimable array.\n     *  @param borrowerAddress_    Address of the borrower that exits auction.\n     *  @param borrowerCollateral_ Borrower collateral amount before auction exit (could be fragmented as result of partial takes).\n     *  @return floorCollateral_   Rounded down collateral, the number of NFT tokens borrower can pull after auction exit.\n     *  @return lps_               LPs given to the borrower to compensate fractional collateral (if any).\n     *  @return bucketIndex_       Index of the bucket with LPs to compensate.\n     */\n    function _settleNFTCollateral(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        address borrowerAddress_,\n        uint256 borrowerCollateral_\n    ) internal returns (uint256 floorCollateral_, uint256 lps_, uint256 bucketIndex_) {\n        floorCollateral_ = (borrowerCollateral_ / Maths.WAD) * Maths.WAD; // floor collateral of borrower\n\n        // if there's fraction of NFTs remaining then reward difference to borrower as LPs in auction price bucket\n        if (floorCollateral_ != borrowerCollateral_) {\n            // cover borrower's fractional amount with LPs in auction price bucket\n            uint256 fractionalCollateral = borrowerCollateral_ - floorCollateral_;\n\n            uint256 auctionPrice = _auctionPrice(\n                auctions_.liquidati"
    }
  ]
}