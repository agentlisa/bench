{
  "Title": "[H-18] `multiHopSellCollateral()` will fail due to call on an invalid market address causing bridged collateral to be locked up",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/Singularity.sol#L409-L427> \n\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L81> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L79-L108> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L227>\n\n`multiHopSellCollateral()` allows users to leverage down by selling the `TOFT` collateral on another chain and then send it to host chain (Arbitrum) for repayment of USDO loan.\n\nHowever, it will fail as it tries to obtain the `repayableAmount` on the destination chain by calling `IMagnetar.getBorrowPartForAmount()` on a non-existing market. That is because Singularity/BigBang markets are only deployed on the host chain.\n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L205-L227>\n\n```Solidity\n    function leverageDownInternal(\n        uint256 amount,\n        IUSDOBase.ILeverageSwapData memory swapData,\n        IUSDOBase.ILeverageExternalContractsData memory externalData,\n        IUSDOBase.ILeverageLZData memory lzData,\n        address leverageFor\n    ) public payable {\n        _unwrap(address(this), amount);\n\n        //swap to USDO\n        IERC20(erc20).approve(externalData.swapper, amount);\n        ISwapper.SwapData memory _swapperData = ISwapper(externalData.swapper)\n            .buildSwapData(erc20, swapData.tokenOut, amount, 0, false, false);\n        (uint256 amountOut, ) = ISwapper(externalData.swapper).swap(\n            _swapperData,\n            swapData.amountOutMin,\n            address(this),\n            swapData.data\n        );\n\n        //@audit this call will fail as there is no market in destination chain\n        //repay\n        uint256 repayableAmount = IMagnetar(externalData.magnetar)\n            .getBorrowPartForAmount(externalData.srcMarket, amountOut);\n```\n\n### Impact\n\nThe issue will prevent users from using `multiHopSellCollateral()` to leverage down.\n\nFurthermore the failure of the cross-chain transaction will cause the bridged collateral to be locked in the TOFT contract on a non-host chain as the refund mechanism will also revert and `retryMessage()` will continue to fail as this is a permanent error.\n\n### Proof of Concept\n\nConsider the following scenario where a user leverage down by selling the collateral on Ethereum (a non-host chain).\n\n1.  User first triggers `Singularity.multiHopSellCollateral()` on host chain Arbitrum.\n2.  That will call `SGLLeverage.multiHopSellCollateral()`, which will conduct a cross chain message via `ITapiocaOFT(address(collateral)).sendForLeverage()` to bridge over and sell the collateral on Ethereum mainnet.\n3.  The collateral TOFT contract on Ethereum mainnet will receive the bridged collateral and cross-chain message via `_nonBlockingLzReceive()` and then `BaseTOFTLeverageModule.leverageDown()`.\n4.  The execution continues with `BaseTOFTLeverageModule.leverageDownInternal()`, but it will revert as it attempt to call `getBorrowPartForAmount()` for a non-existing market in Ethereum.\n5.  The bridgex collateral will be locked in the TOFT contract on Ethereum mainnet as the refund mechanism will also revert and `retryMessage()` will continue to fail as this is a permanent error.\n\n### Recommended Mitigation Steps\n\nObtain the repayable amount on the Arbitrum (host chain) where the BigBang/Singularity markets are deployed.\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1202#issuecomment-1702967048)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/singularity/Singularity.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./SGLCommon.sol\";\nimport \"./SGLLiquidation.sol\";\nimport \"./SGLCollateral.sol\";\nimport \"./SGLBorrow.sol\";\nimport \"./SGLLeverage.sol\";\n\nimport \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n// solhint-disable max-line-length\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Singularity market\n/// @notice Main Tapioca market\n/// @dev owner of the contract is Penrose\n///     - contract is split in modules because of the size limit\n///         - each module is responsible with a specific part of the market\n///     - when action is executed, a `delegatecall` is performed to the right module\n///     - adding assets to the contract, mints shares to the `to` address which can later be used in the oTap & twTap system\n///     - interest rate is automatically updated based on the interest elasticity time and it's bounded by `minimumInterestPerSecond` and `maximumInterestPerSecond`\ncontract Singularity is SGLCommon {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice enum representing each type of module associated with a Singularity market\n    /// @dev modules are contracts that holds a portion of the market's logic\n    enum Module {\n        Base,\n        Borrow,\n        Collateral,\n        Liquidation,\n        Leverage\n    }\n    /// @notice returns the liquidation module\n    SGLLiquidation public liquidationModule;\n    /// @notice returns the borrow module\n    SGLBorrow public borrowModule;\n    /// @notice returns the collateral module\n    SGLCollateral public collateralModule;\n    /// @notice returns the leverage module\n    SGLLeverage public leverageModule;\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata data) external onlyOnce {\n        (\n            address _liquidationModule,\n            address _borrowModule,\n            address _collateralModule,\n            address _leverageModule,\n            IPenrose tapiocaBar_,\n            IERC20 _asset,\n            uint256 _assetId,\n            IERC20 _collateral,\n            uint256 _collateralId,\n            IOracle _oracle,\n            uint256 _exchangeRatePrecision\n        ) = abi.decode(\n                data,\n                (\n                    address,\n                    address,\n                    address,\n                    address,\n                    IPenrose,\n                    IERC20,\n                    uint256,\n                    IERC20,\n                    uint256,\n                    IOracle,\n                    uint256\n                )\n            );\n\n        liquidationModule = SGLLiquidation(_liquidationModule);\n        collateralModule = SGLCollateral(_collateralModule);\n        borrowModule = SGLBorrow(_borrowModule);\n        leverageModule = SGLLeverage(_leverageModule);\n        penrose = tapiocaBar_;\n        yieldBox = YieldBox(tapiocaBar_.yieldBox());\n        owner = address(penrose);\n\n        require(\n            address(_collateral) != address(0) &&\n                address(_asset) != address(0) &&\n                address(_oracle) != address(0),\n            \"SGL: bad pair\"\n        );\n        asset = _asset;\n        collateral = _collateral;\n        assetId = _assetId;\n        collateralId = _collateralId;\n        oracle = _oracle;\n\n        minimumInterestPerSecond = 951293760; // approx 3% APR\n        maximumInterestPerSecond = 2536783360; // approx 8% APR\n        interestElasticity = 7200e36; // Half or double in 28800 seconds (1 hours) if linear\n        startingInterestPerSecond = minimumInterestPerSecond;\n\n        accrueInfo.interestPerSecond = uint64(startingInterestPerSecond); // 1% APR, with 1e18 being 100%\n\n        updateExchangeRate();\n\n        //default fees\n        callerFee = 1000; // 1%\n        protocolFee = 10000; // 10%\n        borrowOpeningFee = 50; // 0.05%\n\n        //liquidation\n        liquidationMultiplier = 12000; //12%\n\n        collateralizationRate = 75000;\n        lqCollateralizationRate = 25000;\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0\n            ? _exchangeRatePrecision\n            : 1e18;\n\n        minLiquidatorReward = 1e3;\n        maxLiquidatorReward = 1e4;\n        liquidationBonusAmount = 1e4;\n\n        minimumTargetUtilization = 3e17;\n        maximumTargetUtilization = 5e17;\n        fullUtilizationMinusMax = FULL_UTILIZATION - maximumTargetUtilization;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice transforms amount to shares for a market's permit operation\n    /// @param amount the amount to transform\n    /// @param tokenId the YieldBox asset id\n    /// @return share amount transformed into shares\n    function computeAllowedLendShare(\n        uint256 amount,\n        uint256 tokenId\n    ) external view returns (uint256 share) {\n        uint256 allShare = totalAsset.elastic +\n            yieldBox.toShare(tokenId, totalBorrow.elastic, true);\n        share = (amount * allShare) / totalAsset.base;\n    }\n\n    /// @notice returns Total yieldBox shares for user\n    /// @param _user The user to check shares for\n    /// @param _assetId The asset id to check shares for\n    /// @return shares value\n    function yieldBoxShares(\n        address _user,\n        uint256 _assetId\n    ) external view returns (uint256) {\n        bytes32 sig = _assetId == assetId ? ASSET_SIG : COLLATERAL_SIG;\n        return\n            yieldBox.balanceOf(_user, _assetId) + _yieldBoxShares[_user][sig];\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Allows batched call to Singularity.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    /// @return successes count of successful operations\n    /// @return results array of revert messages\n    function execute(\n        bytes[] calldata calls,\n        bool revertOnFail\n    ) external returns (bool[] memory successes, string[] memory results) {\n        successes = new bool[](calls.length);\n        results = new string[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                calls[i]\n            );\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = _getRevertMsg(result);\n        }\n    }\n\n    /// @notice Adds assets to the lending pair.\n    /// @param from Address to add asset from.\n    /// @param to The address of the user to receive the assets.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add.\n    /// @return fraction Total fractions added.\n    function addAsset(\n        address from,\n        address to,\n        bool skim,\n        uint256 share\n    ) public notPaused allowedLend(from, share) returns (uint256 fraction) {\n        _accrue();\n        fraction = _addAsset(from, to, skim, share);\n    }\n\n    /// @notice Removes an asset from msg.sender and transfers it to `to`.\n    /// @param from Account to debit Assets from.\n    /// @param to The user that receives the removed assets.\n    /// @param fraction The amount/fraction of assets held to remove.\n    /// @return share The amount of shares transferred to `to`.\n    function removeAsset(\n        address from,\n        address to,\n        uint256 fraction\n    ) public notPaused returns (uint256 share) {\n        _accrue();\n        share = _removeAsset(from, to, fraction, true);\n        _allowedLend(from, share);\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 amount,\n        uint256 share\n    ) public {\n        _executeModule(\n            Module.Collateral,\n            abi.encodeWithSelector(\n                SGLCollateral.addCollateral.selector,\n                from,\n                to,\n                skim,\n                amount,\n                share\n            )\n        );\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param from Account to debit collateral from.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(address from, address to, uint256 share) public {\n        _executeModule(\n            Module.Collateral,\n            abi.encodeWithSelector(\n                SGLCollateral.removeCollateral.selector,\n                from,\n                to,\n                share\n            )\n        );\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (uint256 part, uint256 share) {\n        bytes memory result = _executeModule(\n            Module.Borrow,\n            abi.encodeWithSelector(SGLBorrow.borrow.selector, from, to, amount)\n        );\n        (part, share) = abi.decode(result, (uint256, uint256));\n    }\n\n    /// @notice Repays a loan.\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address from,\n        address to,\n        bool skim,\n        uint256 part\n    ) public returns (uint256 amount) {\n        bytes memory result = _executeModule(\n            Module.Borrow,\n            abi.encodeWithSelector(\n                SGLBorrow.repay.selector,\n                from,\n                to,\n                skim,\n                part\n            )\n        );\n        amount = abi.decode(result, (uint256));\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param minAmountOut Mininal proceeds required for the sale\n    /// @param swapper Swapper to execute the sale\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(\n        address from,\n        uint256 share,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external returns (uint256 amountOut) {\n        bytes memory result = _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                SGLLeverage.sellCollateral.selector,\n                from,\n                share,\n                minAmountOut,\n                swapper,\n                dexData\n            )\n        );\n        amountOut = abi.decode(result, (uint256));\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param minAmountOut Mininal collateral amount to receive\n    /// @param swapper Swapper to execute the purchase\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(\n        address from,\n        uint256 borrowAmount,\n        uint256 supplyAmount,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external returns (uint256 amountOut) {\n        bytes memory result = _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                SGLLeverage.buyCollateral.selector,\n                from,\n                borrowAmount,\n                supplyAmount,\n                minAmountOut,\n                swapper,\n                dexData\n            )\n        );\n        amountOut = abi.decode(result, (uint256));\n    }\n\n    /// @notice Level up cross-chain: Borrow more and buy collateral with it.\n    /// @param from The user who sells\n    /// @param collateralAmount Extra collateral to be added\n    /// @param borrowAmount Borrowed amount that will be swapped into collateral\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    function multiHopBuyCollateral(\n        address from,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                SGLLeverage.multiHopBuyCollateral.selector,\n                from,\n                collateralAmount,\n                borrowAmount,\n                swapData,\n                lzData,\n                externalData\n            )\n        );\n    }\n\n    /// @notice Level up cross-chain: Borrow more and buy collateral with it.\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    function multiHopSellCollateral(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                SGLLeverage.multiHopSellCollateral.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData\n            )\n        );\n    }\n\n    /// @notice Entry point for liquidations.\n    /// @dev Will call `closedLiquidation()` if not LQ exists or no LQ bid avail exists. Otherwise use LQ.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param collateralToAssetSwapData Extra swap data\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param usdoToBorrowedSwapData Extra swap data\n    ///        Ignore for `closedLiquidation()`\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        ISwapper swapper,\n        bytes calldata collateralToAssetSwapData,\n        bytes calldata usdoToBorrowedSwapData\n    ) external {\n        _executeModule(\n            Module.Liquidation,\n            abi.encodeWithSelector(\n                SGLLiquidation.liquidate.selector,\n                users,\n                maxBorrowParts,\n                swapper,\n                collateralToAssetSwapData,\n                usdoToBorrowedSwapData\n            )\n        );\n    }\n\n    /// @notice Withdraw the fees accumulated in `accrueInfo.feesEarnedFraction` to the balance of `feeTo`.\n    function withdrawFeesEarned() public {\n        _accrue();\n        address _feeTo = penrose.feeTo();\n        uint256 _feesEarnedFraction = accrueInfo.feesEarnedFraction;\n        balanceOf[_feeTo] += _feesEarnedFraction;\n        emit Transfer(address(0), _feeTo, _feesEarnedFraction);\n        accrueInfo.feesEarnedFraction = 0;\n        emit LogWithdrawFees(_feeTo, _feesEarnedFraction);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Transfers fees to penrose\n    /// @dev can only be called by the owner\n    /// @param feeTo fees receiver\n    function refreshPenroseFees(\n        address feeTo\n    ) external onlyOwner notPaused returns (uint256 feeShares) {\n        if (accrueInfo.feesEarnedFraction > 0) {\n            withdrawFeesEarned();\n        }\n\n        feeShares = _removeAsset(feeTo, msg.sender, balanceOf[feeTo], false);\n    }\n\n    /// @notice sets Singularity specific configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setSingularityConfig(\n        uint256 _lqCollateralizationRate,\n        uint256 _liquidationMultiplier,\n        uint256 _minimumTargetUtilization,\n        uint256 _maximumTargetUtilization,\n        uint64 _minimumInterestPerSecond,\n        uint64 _maximumInterestPerSecond,\n        uint256 _interestElasticity\n    ) external onlyOwner {\n        if (_minimumTargetUtilization > 0) {\n            emit MinimumTargetUtilizationUpdated(\n                minimumTargetUtilization,\n                _minimumTargetUtilization\n            );\n            minimumTargetUtilization = _minimumTargetUtilization;\n        }\n\n        if (_maximumTargetUtilization > 0) {\n            require(\n                _maximumTargetUtilization < FULL_UTILIZATION,\n                \"SGL: not valid\"\n            );\n            emit MaximumTargetUtilizationUpdated(\n                maximumTargetUtilization,\n                _maximumTargetUtilization\n            );\n            maximumTargetUtilization = _maximumTargetUtilization;\n            fullUtilizationMinusMax =\n                FULL_UTILIZATION -\n                maximumTargetUtilization;\n        }\n\n        if (_minimumInterestPerSecond > 0) {\n            require(\n                _minimumInterestPerSecond < maximumInterestPerSecond,\n                \"SGL: not valid\"\n            );\n            emit MinimumInterestPerSecondUpdated(\n                minimumInterestPerSecond,\n                _minimumInterestPerSecond\n            );\n            minimumInterestPerSecond = _minimumInterestPerSecond;\n        }\n\n        if (_maximumInterestPerSecond > 0) {\n            require(\n                _maximumInterestPerSecond > minimumInterestPerSecond,\n                \"SGL: not valid\"\n            );\n            emit MaximumInterestPerSecondUpdated(\n                maximumInterestPerSecond,\n                _maximumInterestPerSecond\n            );\n            maximumInterestPerSecond = _maximumInterestPerSecond;\n        }\n\n        if (_interestElasticity > 0) {\n            emit InterestElasticityUpdated(\n                interestElasticity,\n                _interestElasticity\n            );\n            interestElasticity = _interestElasticity;\n        }\n\n        if (_lqCollateralizationRate > 0) {\n            require(\n                _lqCollateralizationRate <= FEE_PRECISION,\n                \"SGL: not valid\"\n            );\n            emit LqCollateralizationRateUpdated(\n                lqCollateralizationRate,\n                _lqCollateralizationRate\n            );\n            lqCollateralizationRate = _lqCollateralizationRate;\n        }\n\n        if (_liquidationMultiplier > 0) {\n            require(_liquidationMultiplier < FEE_PRECISION, \"SGL: not valid\");\n            emit LiquidationMultiplierUpdated(\n                liquidationMultiplier,\n                _liquidationMultiplier\n            );\n            liquidationMultiplier = _liquidationMultiplier;\n        }\n    }\n\n    /// @notice sets LQ specific confinguration\n    function setLiquidationQueueConfig(\n        ILiquidationQueue _liquidationQueue,\n        address _bidExecutionSwapper,\n        address _usdoSwapper\n    ) external onlyOwner {\n        if (address(_liquidationQueue) != address(0)) {\n            require(_liquidationQueue.onlyOnce(), \"SGL: LQ not initalized\");\n            liquidationQueue = _liquidationQueue;\n        }\n\n        if (_bidExecutionSwapper != address(0)) {\n            emit BidExecutionSwapperUpdated(_bidExecutionSwapper);\n            liquidationQueue.setBidExecutionSwapper(_bidExecutionSwapper);\n        }\n\n        if (_usdoSwapper != address(0)) {\n            emit UsdoSwapperUpdated(_usdoSwapper);\n            liquidationQueue.setUsdoSwapper(_usdoSwapper);\n        }\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Borrow) {\n            module = address(borrowModule);\n        } else if (_module == Module.Collateral) {\n            module = address(collateralModule);\n        } else if (_module == Module.Liquidation) {\n            module = address(liquidationModule);\n        } else if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        }\n        if (module == address(0)) {\n            revert(\"SGL: module not set\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data\n    ) private returns (bytes memory returnData) {\n        bool success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeViewModule(\n        Module _module,\n        bytes memory _data\n    ) private view returns (bytes memory returnData) {\n        bool success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.staticcall(_data);\n        if (!success) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./SGLLendingCommon.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport {ITapiocaOFT} from \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\n\n/// @title Singularity leverage module\n/// @notice Singularity module for leverage type actions\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    /// @notice Level up cross-chain: Borrow more and buy collateral with it.\n    /// @param from The user who sells\n    /// @param collateralAmount Extra collateral to be added\n    /// @param borrowAmount Borrowed amount that will be swapped into collateral\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    function multiHopBuyCollateral(\n        address from,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable notPaused solvent(from) {\n        require(\n            penrose.swappers(ISwapper(externalData.swapper)),\n            \"SGL: Invalid swapper\"\n        );\n\n        //add collateral\n        uint256 collateralShare = yieldBox.toShare(\n            collateralId,\n            collateralAmount,\n            false\n        );\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n\n        //borrow\n        (, uint256 borrowShare) = _borrow(from, from, borrowAmount);\n\n        //withdraw\n        yieldBox.withdraw(assetId, from, address(this), 0, borrowShare);\n\n        IUSDOBase(address(asset)).sendForLeverage{value: msg.value}(\n            borrowAmount,\n            from,\n            lzData,\n            swapData,\n            externalData\n        );\n    }\n\n    function multiHopSellCollateral(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable notPaused solvent(from) {\n        require(\n            penrose.swappers(ISwapper(externalData.swapper)),\n            \"SGL: Invalid swapper\"\n        );\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n        (uint256 amountOut, ) = yieldBox.withdraw(\n            collateralId,\n            address(this),\n            address(this),\n            0,\n            share\n        );\n\n        //send for unwrap\n        ITapiocaOFT(address(collateral)).sendForLeverage{value: msg.value}(\n            amountOut,\n            from,\n            lzData,\n            swapData,\n            externalData\n        );\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param minAmountOut Mininal proceeds required for the sale\n    /// @param swapper Swapper to execute the sale\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(\n        address from,\n        uint256 share,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(swapper), share);\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            share,\n            true,\n            true\n        );\n        uint256 shareOut;\n        (amountOut, shareOut) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        // As long as the ratio is correct, we trust `amountOut` resp.\n        // `shareOut`, because all money received by the swapper gets used up\n        // one way or another, or the transaction will revert.\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n        uint256 partOwed = userBorrowPart[from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(from, from, false, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, false, partOut);\n        }\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param minAmountOut Mininal collateral amount to receive\n    /// @param swapper Swapper to execute the purchase\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(\n        address from,\n        uint256 borrowAmount,\n        uint256 supplyAmount,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, supplyAmount, true);\n        if (supplyShare > 0) {\n            yieldBox.transfer(from, address(swapper), assetId, supplyShare);\n        }\n\n        uint256 borrowShare;\n        (, borrowShare) = _borrow(from, address(swapper), borrowAmount);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            assetId,\n            collateralId,\n            0,\n            supplyShare + borrowShare,\n            true,\n            true\n        );\n\n        uint256 collateralShare;\n        (amountOut, collateralShare) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/modules/BaseTOFTLeverageModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/libraries/LzLib.sol\";\n\n//TAPIOCA\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISwapper.sol\";\nimport \"tapioca-periph/contracts/interfaces/IMagnetar.sol\";\nimport \"tapioca-periph/contracts/interfaces/ISingularity.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitBorrow.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPermitAll.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol\";\nimport \"tapioca-periph/contracts/interfaces/ITapiocaOptionLiquidityProvision.sol\";\n\nimport \"../BaseTOFTStorage.sol\";\n\n/// @title tOFT leverage module\n/// @notice tOFT module for leverage type actions\ncontract BaseTOFTLeverageModule is BaseTOFTStorage {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n    {}\n\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        bytes32 senderBytes = LzLib.addressToBytes32(from);\n\n        bytes memory lzPayload = abi.encode(\n            PT_MARKET_MULTIHOP_SELL,\n            senderBytes,\n            from,\n            share,\n            swapData,\n            lzData,\n            externalData,"
    }
  ]
}