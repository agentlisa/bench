{
  "Title": "M-2: TrueFiStrategy: Too little withdrawn when used with AlphaBetaSplitter",
  "Content": "# Issue M-2: TrueFiStrategy: Too little withdrawn when used with AlphaBetaSplitter \n\nSource: https://github.com/sherlock-audit/2022-09-sherlock-judging/tree/main/003-M \n\n## Found by \nLambda\n\n## Summary\n`AlphaBetaSplitter` implicitly assumes that `withdrawAll` returns the whole balance, which is not true for `TrueFiStrategy`.\n\n## Vulnerability Detail\nWhen `_amount` is withdrawn from `AlphaBetaSplitter` and this value is larger than the balance of the first child (which was retrieved earlier with a `_balanceOf` call on the child), `withdrawAll` is called. Then, `_amount - childOneBalance` is withdrawn on the second child. This assumes that the `withdrawAll()` call on the first child in fact returned `childOneBalance`, i.e. the whole balance. However, this is not necessarily true for `TrueFiStrategy`. This strategy only returns the USDC that are currently held in the contract, whereas `_balanceOf()` returns the amount that is locked in TrueFi (but where a call to `liquidExit` is necessary to get the USDC into the strategy).\n\n## Impact\nBecause of this issue, it can happen that significantly less tokens are returned than requested when TrueFi is used within an `AlphaBetaSplitter`. Let's say that 950,000 USDC are locked in TrueFi and 50,000 USDC are currently in the `TrueFiStrategy` contract. We assume that the `TrueFiStrategy` is the first child of an `AlphaBetaSplitter` and `_withdraw` is called with 1,000,050 USDC. Then, only 50,000 USDC (from TrueFi) + 50,000 USDC (from the second child) will be transferred to core, i.e. 100,000 USDC instead of 1,000,050 USDC.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-09-sherlock/blob/main/sherlock-v2-core/contracts/strategy/splitters/AlphaBetaSplitter.sol#L38\nhttps://github.com/sherlock-audit/2022-09-sherlock/blob/main/sherlock-v2-core/contracts/strategy/TrueFiStrategy.sol#L111\nhttps://github.com/sherlock-audit/2022-09-sherlock/blob/main/sherlock-v2-core/contracts/strategy/TrueFiStrategy.sol#L134\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCheck the actual amount that was returned by `_withdrawAll` in `AlphaBetaSplitter`. This value is already returned by all strategies, so refactoring the Splitter to incorporate it should be easy.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/5",
  "Code": [
    {
      "filename": "sherlock-v2-core/contracts/strategy/splitters/AlphaBetaSplitter.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '../base/BaseSplitter.sol';\n\n/**\n  ChildOne is the first node that is being used to withdraw from\n  Only when ChildOne balance = 0 it will start withdrawing from ChildTwo\n\n  It will deposit in the child that returns the lowest balance (childOne first)\n*/\ncontract AlphaBetaSplitter is BaseSplitter {\n  using SafeERC20 for IERC20;\n\n  /// @param _initialParent Contract that will be the parent in the tree structure\n  /// @param _initialChildOne Contract that will be the initial childOne in the tree structure\n  /// @param _initialChildTwo Contract that will be the initial childTwo in the tree structure\n  constructor(\n    IMaster _initialParent,\n    INode _initialChildOne,\n    INode _initialChildTwo\n  ) BaseSplitter(_initialParent, _initialChildOne, _initialChildTwo) {}\n\n  /// @notice Signal to withdraw `_amount` of USDC from the underlying nodes into core\n  /// @param _amount Amount of USDC to withdraw\n  function _withdraw(uint256 _amount) internal virtual override {\n    // First in line for liquidations\n    uint256 childOneBalance = cachedChildOneBalance;\n\n    // If the amount exceeds childOne balance, it will start withdrawing from childTwo\n    if (_amount > childOneBalance) {\n      // Withdraw all USDC from childOne\n      if (childOneBalance != 0) childOne.withdrawAll();\n\n      // Withdraw USDC from childTwo when childOne balance hits zero\n      childTwo.withdraw(_amount - childOneBalance);\n    } else {\n      // Withdraw from childOne\n      childOne.withdraw(_amount);\n    }\n  }\n\n  /// @notice Transfer USDC to childOne and call deposit\n  /// @param _amount Amount of USDC to deposit\n  function _childOneDeposit(uint256 _amount) internal virtual {\n    // Transfer USDC to childOne\n    want.safeTransfer(address(childOne), _amount);\n\n    // Signal childOne it received a deposit\n    childOne.deposit();\n  }\n\n  /// @notice Transfer USDC to childTwo and call deposit\n  /// @param _amount Amount of USDC to deposit\n  function _childTwoDeposit(uint256 _amount) internal virtual {\n    // Transfer USDC to childTwo\n    want.safeTransfer(address(childTwo), _amount);\n\n    // Signal childOne it received a deposit\n    childTwo.deposit();\n  }\n\n  /// @notice Deposit USDC into one child\n  function _deposit() internal virtual override {\n    // Deposit USDC into strategy that has the lowest balance\n    if (cachedChildOneBalance <= cachedChildTwoBalance) {\n      _childOneDeposit(want.balanceOf(address(this)));\n    } else {\n      _childTwoDeposit(want.balanceOf(address(this)));\n    }\n  }\n}"
    },
    {
      "filename": "sherlock-v2-core/contracts/strategy/TrueFiStrategy.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport './base/BaseStrategy.sol';\n\nimport '../interfaces/truefi/ITrueFiPool2.sol';\nimport '../interfaces/truefi/ITrueMultiFarm.sol';\n\n// This contract contains logic for depositing staker funds into TrueFi as a yield strategy\n// https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol\n// https://docs.truefi.io/faq/main-lending-pools/pool#lending-pools-smart-contracts\n\n// TRU farming\n// https://docs.truefi.io/faq/main-lending-pools/farming-liquidity-mining\n\n// Joining fee is currently 0, is able to change\n\n/*\nThoughts on adding `liquidExitPenalty` to `balanceOf()`\n\nIn the most extreme example where all our money is in TrueFi and we don't assume the exit fee,\npeople will see balance = 100 USDC, but when actually withdrawing it will be 90 USDC\n(because of the exit fee)\n\nIn the other most extreme example where all our money is not yet in TrueFi and we do assume the exit fee,\npeople can see balance = 100 USDC but when we deposit it, it will be 90 USDC (because of the exit fee)\n(note: this affects the exit fee in a positive way as it adds liquidity)\n\n^ these extremes assume our deposits/withdraws don't have any effect on the exit fee.\nBut with the current 180m$ pool it will take 9m$ to move the poolLiquidty 5%,\nwhich is 0.91% -> 10% in the most extreme scenario\n\nTakeaways\n- We want to account the exit fee to not 'surprise' people on withdraw with a lower balance\n- We want to be a small part of the pool (<=5%?) to keep it liquid and not move the exitFee to 10% on exit.\n\nWhat happen if we are a large part of the pool?\n\nFor example if balanceOf = totalSupply and we have deposited 100 USDC\nOnly 10 USDC is liquid (10%) which makes the exit fee 0.48%\n\n`balanceOf()` would show 99,52 USDC as the exit fee is applied\nIf we call `liquidExit()` with 10 USDC, 0% will be liquid and the exit fee jumps up to 10%\n`balanceOf()` would show 10 USDC + 81 (90 USDC - 10% exit fee) = 91 USDC\n*/\n\n// All tfUSDC will be staked in the farm at any time (except runtime of a transaction)\ncontract TrueFiStrategy is BaseStrategy {\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ITrueFiPool2;\n\n  // Value copied from https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L487\n  uint256 private constant BASIS_PRECISION = 10000;\n\n  // the tfUSDC pool\n  ITrueFiPool2 public constant tfUSDC = ITrueFiPool2(0xA991356d261fbaF194463aF6DF8f0464F8f1c742);\n  // TrueFi farm, used to stake tfUSDC and earn TrueFi tokens\n  ITrueMultiFarm public constant tfFarm =\n    ITrueMultiFarm(0xec6c3FD795D6e6f202825Ddb56E01b3c128b0b10);\n  // The TrueFi token\n  IERC20 public constant rewardToken = IERC20(0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784);\n\n  // Address to receive rewards\n  address public constant LIQUIDITY_MINING_RECEIVER = 0x666B8EbFbF4D5f0CE56962a25635CfF563F13161;\n\n  /// @param _initialParent Contract that will be the parent in the tree structure\n  constructor(IMaster _initialParent) BaseNode(_initialParent) {\n    // Approve tfUSDC max amount of USDC\n    want.safeIncreaseAllowance(address(tfUSDC), type(uint256).max);\n    // Approve tfFarm max amount of tfUSDC\n    tfUSDC.safeIncreaseAllowance(address(tfFarm), type(uint256).max);\n  }\n\n  /// @notice Signal if strategy is ready to be used\n  /// @return Boolean indicating if strategy is ready\n  function setupCompleted() external view override returns (bool) {\n    return true;\n  }\n\n  /// @notice Deposit all USDC in this contract in TrueFi\n  /// @notice Joining fee may apply, this will lower the balance of the system on deposit\n  /// @notice Works under the assumption this contract contains USDC\n  function _deposit() internal override whenNotPaused {\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L469\n    tfUSDC.join(want.balanceOf(address(this)));\n\n    // Don't stake in the tfFarm if shares are 0\n    // This would make the function call revert\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueMultiFarm.sol#L101\n    if (tfFarm.getShare(tfUSDC) == 0) return;\n\n    // How much tfUSDC is in this contract\n    // Could both be tfUSDC that was already in here before the `_deposit()` call\n    // And new tfUSDC that was minted in the `tfUSDC.join()` call\n    uint256 tfUsdcBalance = tfUSDC.balanceOf(address(this));\n\n    // Stake all tfUSDC in the tfFarm\n    tfFarm.stake(tfUSDC, tfUsdcBalance);\n  }\n\n  /// @notice Send all USDC in this contract to core\n  /// @notice Funds need to be withdrawn using `liquidExit()` first\n  /// @return amount Amount of USDC withdrawn\n  function _withdrawAll() internal override returns (uint256 amount) {\n    // Amount of USDC in the contract\n    amount = want.balanceOf(address(this));\n    // Transfer USDC to core\n    if (amount != 0) want.safeTransfer(core, amount);\n  }\n\n  /// @notice Send `_amount` USDC in this contract to core\n  /// @notice Funds need to be withdrawn using `liquidExit()` first\n  /// @param _amount Amount of USDC to withdraw\n  function _withdraw(uint256 _amount) internal override {\n    // Transfer USDC to core\n    want.safeTransfer(core, _amount);\n  }\n\n  /// @notice View how much tfUSDC is staked in the farm\n  /// @return Amount of tfUSDC staked\n  function _viewTfUsdcStaked() private view returns (uint256) {\n    // Amount of tfUSDC staked in the tfFarm\n    return tfFarm.staked(tfUSDC, address(this));\n  }\n\n  /// @notice View USDC in this contract + USDC in TrueFi\n  /// @notice Takes into account exit penalty for liquidating full tfUSDC balance\n  /// @return Amount of USDC in this strategy\n  function _balanceOf() internal view override returns (uint256) {\n    // https://docs.truefi.io/faq/main-lending-pools/developer-guide/truefipool2-contract#calculating-lending-pool-token-prices\n\n    // How much USDC is locked in TrueFi\n    // Based on staked tfUSDC + tfUSDC in this contract\n    uint256 tfUsdcBalance = (tfUSDC.poolValue() *\n      (_viewTfUsdcStaked() + tfUSDC.balanceOf(address(this)))) / tfUSDC.totalSupply();\n\n    // How much USDC we get if we liquidate the full position\n    tfUsdcBalance = (tfUsdcBalance * tfUSDC.liquidExitPenalty(tfUsdcBalance)) / BASIS_PRECISION;\n\n    // Return USDC in contract + USDC we can get from TrueFi\n    return want.balanceOf(address(this)) + tfUsdcBalance;\n  }\n\n  /// @notice Exit `_amount` of tfUSDC (pool LP tokens)\n  /// @notice Up to 10% exit fee may apply.\n  /// @notice There are two situations in which the pool will not let you withdraw via Liquid Exit:\n  /// @notice 1) If there is no liquid asset in the lending pool and no liquid exit is deployed in Curve.\n  /// @notice 2) If the pool needs to liquidate its position in Curve and will incur a loss of more than 10 basis points.\n  /// @dev Can only be called by owner\n  function liquidExit(uint256 _amount) external onlyOwner {\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L487\n    // here's a spreadsheet that shows the exit penalty at different liquidRatio levels ( = liquidValue / poolValue):\n    // https://docs.google.com/spreadsheets/d/1ZXGRxunIwe0eYPu7j4QjCwXxe63tNKtpCvRiJnqK0jo/edit#gid=0\n\n    // Exiting 0 tokens doesn't make sense\n    if (_amount == 0) revert ZeroArg();\n\n    // Amount of tfUSDC in this contract\n    uint256 tfUsdcBalance = tfUSDC.balanceOf(address(this));\n    uint256 tfUsdcStaked = _viewTfUsdcStaked();\n\n    // Exit MAX amount of tokens\n    if (_amount == type(uint256).max) {\n      _amount = tfUsdcBalance + tfUsdcStaked;\n      // Exiting 0 tokens doesn't make sense\n      if (_amount == 0) revert InvalidState();\n    }\n    // We can not withdraw more tfUSDC than we have access to\n    else if (_amount > tfUsdcBalance + tfUsdcStaked) revert InvalidArg();\n\n    // Unstake tfUSDC if it isn't in the contract already\n    if (_amount > tfUsdcBalance) {\n      // Unstake tfUSDC from tfFarm so we are able to exit `_amount`\n      tfFarm.unstake(tfUSDC, _amount - tfUsdcBalance);\n    }\n\n    // At this point there should be at least `_amount` of tfUSDC in the contract\n    // Unstake tfUSDC tokens from the pool, this will send USDC to this contract\n    tfUSDC.liquidExit(_amount);\n  }\n\n  /// @notice Claim TrueFi tokens earned by farming\n  /// @dev TrueFi tokens will be send to LIQUIDITY_MINING_RECEIVER\n  function claimReward() external {\n    IERC20[] memory tokens = new IERC20[](1);\n    tokens[0] = tfUSDC;\n\n    // Claim TrueFi tokens for tfUSDC\n    tfFarm.claim(tokens);\n\n    // How much TrueFi tokens does this contract hold\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    // Send all TrueFi tokens to LIQUIDITY_MINING_RECEIVER\n    if (rewardBalance != 0) rewardToken.safeTransfer(LIQUIDITY_MINING_RECEIVER, rewardBalance);\n  }\n}"
    },
    {
      "filename": "sherlock-v2-core/contracts/strategy/TrueFiStrategy.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport './base/BaseStrategy.sol';\n\nimport '../interfaces/truefi/ITrueFiPool2.sol';\nimport '../interfaces/truefi/ITrueMultiFarm.sol';\n\n// This contract contains logic for depositing staker funds into TrueFi as a yield strategy\n// https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol\n// https://docs.truefi.io/faq/main-lending-pools/pool#lending-pools-smart-contracts\n\n// TRU farming\n// https://docs.truefi.io/faq/main-lending-pools/farming-liquidity-mining\n\n// Joining fee is currently 0, is able to change\n\n/*\nThoughts on adding `liquidExitPenalty` to `balanceOf()`\n\nIn the most extreme example where all our money is in TrueFi and we don't assume the exit fee,\npeople will see balance = 100 USDC, but when actually withdrawing it will be 90 USDC\n(because of the exit fee)\n\nIn the other most extreme example where all our money is not yet in TrueFi and we do assume the exit fee,\npeople can see balance = 100 USDC but when we deposit it, it will be 90 USDC (because of the exit fee)\n(note: this affects the exit fee in a positive way as it adds liquidity)\n\n^ these extremes assume our deposits/withdraws don't have any effect on the exit fee.\nBut with the current 180m$ pool it will take 9m$ to move the poolLiquidty 5%,\nwhich is 0.91% -> 10% in the most extreme scenario\n\nTakeaways\n- We want to account the exit fee to not 'surprise' people on withdraw with a lower balance\n- We want to be a small part of the pool (<=5%?) to keep it liquid and not move the exitFee to 10% on exit.\n\nWhat happen if we are a large part of the pool?\n\nFor example if balanceOf = totalSupply and we have deposited 100 USDC\nOnly 10 USDC is liquid (10%) which makes the exit fee 0.48%\n\n`balanceOf()` would show 99,52 USDC as the exit fee is applied\nIf we call `liquidExit()` with 10 USDC, 0% will be liquid and the exit fee jumps up to 10%\n`balanceOf()` would show 10 USDC + 81 (90 USDC - 10% exit fee) = 91 USDC\n*/\n\n// All tfUSDC will be staked in the farm at any time (except runtime of a transaction)\ncontract TrueFiStrategy is BaseStrategy {\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ITrueFiPool2;\n\n  // Value copied from https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L487\n  uint256 private constant BASIS_PRECISION = 10000;\n\n  // the tfUSDC pool\n  ITrueFiPool2 public constant tfUSDC = ITrueFiPool2(0xA991356d261fbaF194463aF6DF8f0464F8f1c742);\n  // TrueFi farm, used to stake tfUSDC and earn TrueFi tokens\n  ITrueMultiFarm public constant tfFarm =\n    ITrueMultiFarm(0xec6c3FD795D6e6f202825Ddb56E01b3c128b0b10);\n  // The TrueFi token\n  IERC20 public constant rewardToken = IERC20(0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784);\n\n  // Address to receive rewards\n  address public constant LIQUIDITY_MINING_RECEIVER = 0x666B8EbFbF4D5f0CE56962a25635CfF563F13161;\n\n  /// @param _initialParent Contract that will be the parent in the tree structure\n  constructor(IMaster _initialParent) BaseNode(_initialParent) {\n    // Approve tfUSDC max amount of USDC\n    want.safeIncreaseAllowance(address(tfUSDC), type(uint256).max);\n    // Approve tfFarm max amount of tfUSDC\n    tfUSDC.safeIncreaseAllowance(address(tfFarm), type(uint256).max);\n  }\n\n  /// @notice Signal if strategy is ready to be used\n  /// @return Boolean indicating if strategy is ready\n  function setupCompleted() external view override returns (bool) {\n    return true;\n  }\n\n  /// @notice Deposit all USDC in this contract in TrueFi\n  /// @notice Joining fee may apply, this will lower the balance of the system on deposit\n  /// @notice Works under the assumption this contract contains USDC\n  function _deposit() internal override whenNotPaused {\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L469\n    tfUSDC.join(want.balanceOf(address(this)));\n\n    // Don't stake in the tfFarm if shares are 0\n    // This would make the function call revert\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueMultiFarm.sol#L101\n    if (tfFarm.getShare(tfUSDC) == 0) return;\n\n    // How much tfUSDC is in this contract\n    // Could both be tfUSDC that was already in here before the `_deposit()` call\n    // And new tfUSDC that was minted in the `tfUSDC.join()` call\n    uint256 tfUsdcBalance = tfUSDC.balanceOf(address(this));\n\n    // Stake all tfUSDC in the tfFarm\n    tfFarm.stake(tfUSDC, tfUsdcBalance);\n  }\n\n  /// @notice Send all USDC in this contract to core\n  /// @notice Funds need to be withdrawn using `liquidExit()` first\n  /// @return amount Amount of USDC withdrawn\n  function _withdrawAll() internal override returns (uint256 amount) {\n    // Amount of USDC in the contract\n    amount = want.balanceOf(address(this));\n    // Transfer USDC to core\n    if (amount != 0) want.safeTransfer(core, amount);\n  }\n\n  /// @notice Send `_amount` USDC in this contract to core\n  /// @notice Funds need to be withdrawn using `liquidExit()` first\n  /// @param _amount Amount of USDC to withdraw\n  function _withdraw(uint256 _amount) internal override {\n    // Transfer USDC to core\n    want.safeTransfer(core, _amount);\n  }\n\n  /// @notice View how much tfUSDC is staked in the farm\n  /// @return Amount of tfUSDC staked\n  function _viewTfUsdcStaked() private view returns (uint256) {\n    // Amount of tfUSDC staked in the tfFarm\n    return tfFarm.staked(tfUSDC, address(this));\n  }\n\n  /// @notice View USDC in this contract + USDC in TrueFi\n  /// @notice Takes into account exit penalty for liquidating full tfUSDC balance\n  /// @return Amount of USDC in this strategy\n  function _balanceOf() internal view override returns (uint256) {\n    // https://docs.truefi.io/faq/main-lending-pools/developer-guide/truefipool2-contract#calculating-lending-pool-token-prices\n\n    // How much USDC is locked in TrueFi\n    // Based on staked tfUSDC + tfUSDC in this contract\n    uint256 tfUsdcBalance = (tfUSDC.poolValue() *\n      (_viewTfUsdcStaked() + tfUSDC.balanceOf(address(this)))) / tfUSDC.totalSupply();\n\n    // How much USDC we get if we liquidate the full position\n    tfUsdcBalance = (tfUsdcBalance * tfUSDC.liquidExitPenalty(tfUsdcBalance)) / BASIS_PRECISION;\n\n    // Return USDC in contract + USDC we can get from TrueFi\n    return want.balanceOf(address(this)) + tfUsdcBalance;\n  }\n\n  /// @notice Exit `_amount` of tfUSDC (pool LP tokens)\n  /// @notice Up to 10% exit fee may apply.\n  /// @notice There are two situations in which the pool will not let you withdraw via Liquid Exit:\n  /// @notice 1) If there is no liquid asset in the lending pool and no liquid exit is deployed in Curve.\n  /// @notice 2) If the pool needs to liquidate its position in Curve and will incur a loss of more than 10 basis points.\n  /// @dev Can only be called by owner\n  function liquidExit(uint256 _amount) external onlyOwner {\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L487\n    // here's a spreadsheet that shows the exit penalty at different liquidRatio levels ( = liquidValue / poolValue):\n    // https://docs.google.com/spreadsheets/d/1ZXGRxunIwe0eYPu7j4QjCwXxe63tNKtpCvRiJnqK0jo/edit#gid=0\n\n    // Exiting 0 tokens doesn't make sense\n    if (_amount == 0) revert ZeroArg();\n\n    // Amount of tfUSDC in this contract\n    uint256 tfUsdcBalance = tfUSDC.balanceOf(address(this));\n    uint256 tfUsdcStaked = _viewTfUsdcStaked();\n\n    // Exit MAX amount of tokens\n    if (_amount == type(uint256).max) {\n      _amount = tfUsdcBalance + tfUsdcStaked;\n      // Exiting 0 tokens doesn't make sense\n      if (_amount == 0) revert InvalidState();\n    }\n    // We can not withdraw more tfUSDC than we have access to\n    else if (_amount > tfUsdcBalance + tfUsdcStaked) revert InvalidArg();\n\n    // Unstake tfUSDC if it isn't in the contract already\n    if (_amount > tfUsdcBalance) {\n      // Unstake tfUSDC from tfFarm so we are able to exit `_amount`\n      tfFarm.unstake(tfUSDC, _amount - tfUsdcBalance);\n    }\n\n    // At this point there should be at least `_amount` of tfUSDC in the contract\n    // Unstake tfUSDC tokens from the pool, this will send USDC to this contract\n    tfUSDC.liquidExit(_amount);\n  }\n\n  /// @notice Claim TrueFi tokens earned by farming\n  /// @dev TrueFi tokens will be send to LIQUIDITY_MINING_RECEIVER\n  function claimReward() external {\n    IERC20[] memory tokens = new IERC20[](1);\n    tokens[0] = tfUSDC;\n\n    // Claim TrueFi tokens for tfUSDC\n    tfFarm.claim(tokens);\n\n    // How much TrueFi tokens does this contract hold\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    // Send all TrueFi tokens to LIQUIDITY_MINING_RECEIVER\n    if (rewardBalance != 0) rewardToken.safeTransfer(LIQUIDITY_MINING_RECEIVER, rewardBalance);\n  }\n}"
    }
  ]
}