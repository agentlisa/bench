{
  "Title": "[L-02] `areAddressArraysEqual()` isn't foolproof when both arrays have duplicate elements",
  "Content": "\nThe `areAddressArraysEqual()` function is used to check if `array1` and `array2` contain the same elements. It does so by checking that each element in `array1` exists in `array2`, and vice versa:\n\n[SecurityCouncilMgmtUpgradeLib.sol#L61-L85](https://github.com/ArbitrumFoundation/governance/blob/c18de53820c505fc459f766c1b224810eaeaabc5/src/gov-action-contracts/AIPs/SecurityCouncilMgmt/SecurityCouncilMgmtUpgradeLib.sol#L61-L85)\n\n```solidity\n        for (uint256 i = 0; i < array1.length; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < array2.length; j++) {\n                if (array1[i] == array2[j]) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n\n        for (uint256 i = 0; i < array2.length; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < array1.length; j++) {\n                if (array2[i] == array1[j]) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n```\n\nHowever, this method isn't foolproof when both `array1` and `array2` contain duplicate elements. For example:\n- `array1 = [1, 1, 2]`\n- `array2 = [1, 2, 2]` \n\nEven though both arrays are not equal, `areAddressArraysEqual()` will return true as they have the same length and all elements in one array exist in the other.\n\n### Recommendation\n\nConsider checking that both arrays do not contain duplicate elements.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-arbitrum",
  "Code": [
    {
      "filename": "src/gov-action-contracts/AIPs/SecurityCouncilMgmt/SecurityCouncilMgmtUpgradeLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"../../../security-council-mgmt/interfaces/IGnosisSafe.sol\";\nimport \"../../../interfaces/IUpgradeExecutor.sol\";\n\nlibrary SecurityCouncilMgmtUpgradeLib {\n    function replaceEmergencySecurityCouncil(\n        IGnosisSafe _prevSecurityCouncil,\n        IGnosisSafe _newSecurityCouncil,\n        uint256 _threshold,\n        IUpgradeExecutor _upgradeExecutor\n    ) internal {\n        requireSafesEquivalent(_prevSecurityCouncil, _newSecurityCouncil, _threshold);\n        bytes32 EXECUTOR_ROLE = _upgradeExecutor.EXECUTOR_ROLE();\n        require(\n            _upgradeExecutor.hasRole(EXECUTOR_ROLE, address(_prevSecurityCouncil)),\n            \"SecurityCouncilMgmtUpgradeLib: prev council not executor\"\n        );\n        require(\n            !_upgradeExecutor.hasRole(EXECUTOR_ROLE, address(_newSecurityCouncil)),\n            \"SecurityCouncilMgmtUpgradeLib: new council already executor\"\n        );\n\n        _upgradeExecutor.revokeRole(EXECUTOR_ROLE, address(_prevSecurityCouncil));\n        _upgradeExecutor.grantRole(EXECUTOR_ROLE, address(_newSecurityCouncil));\n    }\n\n    function requireSafesEquivalent(\n        IGnosisSafe _safe1,\n        IGnosisSafe safe2,\n        uint256 _expectedThreshold\n    ) internal view {\n        uint256 newSecurityCouncilThreshold = safe2.getThreshold();\n        require(\n            _safe1.getThreshold() == newSecurityCouncilThreshold,\n            \"SecurityCouncilMgmtUpgradeLib: threshold mismatch\"\n        );\n        require(\n            newSecurityCouncilThreshold == _expectedThreshold,\n            \"SecurityCouncilMgmtUpgradeLib: unexpected threshold\"\n        );\n\n        address[] memory prevOwners = _safe1.getOwners();\n        address[] memory newOwners = safe2.getOwners();\n        require(\n            areAddressArraysEqual(prevOwners, newOwners),\n            \"SecurityCouncilMgmtUpgradeLib: owners mismatch\"\n        );\n    }\n\n    function areAddressArraysEqual(address[] memory array1, address[] memory array2)\n        public\n        pure\n        returns (bool)\n    {\n        if (array1.length != array2.length) {\n            return false;\n        }\n\n        for (uint256 i = 0; i < array1.length; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < array2.length; j++) {\n                if (array1[i] == array2[j]) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n\n        for (uint256 i = 0; i < array2.length; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < array1.length; j++) {\n                if (array2[i] == array1[j]) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}"
    }
  ]
}