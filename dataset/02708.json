{
  "Title": "M-1: Transferring Ownership Might Break The Market",
  "Content": "# Issue M-1: Transferring Ownership Might Break The Market \n\nSource: https://github.com/sherlock-audit/2022-11-bond-judging/issues/41 \n\n## Found by \nxiaoming90\n\n## Summary\n\nAfter the transfer of the market ownership, the market might stop working, and no one could purchase any bond token from the market leading to a loss of sale for the market makers.\n\n## Vulnerability Detail\n\nThe `callbackAuthorized` mapping contains a list of whitelisted market owners authorized to use the callback. When the users call the `purchaseBond` function, it will check at Line 390 if the current market owner is still authorized to use a callback. Otherwise, the function will revert.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L379\n\n```solidity\nFile: BondBaseSDA.sol\n379:     function purchaseBond(\n380:         uint256 id_,\n381:         uint256 amount_,\n382:         uint256 minAmountOut_\n383:     ) external override returns (uint256 payout) {\n384:         if (msg.sender != address(_teller)) revert Auctioneer_NotAuthorized();\n385: \n386:         BondMarket storage market = markets[id_];\n387:         BondTerms memory term = terms[id_];\n388: \n389:         // If market uses a callback, check that owner is still callback authorized\n390:         if (market.callbackAddr != address(0) && !callbackAuthorized[market.owner])\n391:             revert Auctioneer_NotAuthorized();\n```\n\nHowever, if the market owner transfers the market ownership to someone else. The market will stop working because the new market owner might not be on the list of whitelisted market owners (`callbackAuthorized` mapping). As such, no one can purchase any bond token.\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L336\n\n```solidity\nFile: BondBaseSDA.sol\n336:     function pushOwnership(uint256 id_, address newOwner_) external override {\n337:         if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n338:         newOwners[id_] = newOwner_;\n339:     }\n```\n\n## Impact\n\nAfter the transfer of the market ownership, the market might stop working, and no one could purchase any bond token from the market leading to a loss of sale for the market makers.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L379\n\nhttps://github.com/sherlock-audit/2022-11-bond/blob/main/src/bases/BondBaseSDA.sol#L336\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBefore pushing the ownership, if the market uses a callback, implement an additional validation check to ensure that the new market owner has been whitelisted to use the callback. This will ensure that transferring the market ownership will not break the market due to the new market owner not being whitelisted.\n\n```diff\nfunction pushOwnership(uint256 id_, address newOwner_) external override {\n    if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n+   if (markets[id_].callbackAddr != address(0) && !callbackAuthorized[newOwner_])\n+   \trevert newOwnerNotAuthorizedToUseCallback();\n    newOwners[id_] = newOwner_;\n}\n```\n\n## Discussion\n\n**Evert0x**\n\nMessage from sponsor\n\n----\n\nAcknowledged. We added the check for the owner to be whitelisted for a callback on purchase to provide a shutdown mechanism in the event of a malicious callback. The ownership transfer functionality is meant to be used when a callback isn't being used to payout market purchases. E.g. create a market with an EOA from a script and transfer ownership to a multisig for payouts (would also require multisig to approve the teller for the capacity in payout tokens).\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/20",
  "Code": [
    {
      "filename": "src/bases/BondBaseSDA.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\n\nimport {IBondSDA, IBondAuctioneer} from \"../interfaces/IBondSDA.sol\";\nimport {IBondTeller} from \"../interfaces/IBondTeller.sol\";\nimport {IBondCallback} from \"../interfaces/IBondCallback.sol\";\nimport {IBondAggregator} from \"../interfaces/IBondAggregator.sol\";\n\nimport {TransferHelper} from \"../lib/TransferHelper.sol\";\nimport {FullMath} from \"../lib/FullMath.sol\";\n\n/// @title Bond Sequential Dutch Auctioneer (SDA)\n/// @notice Bond Sequential Dutch Auctioneer Base Contract\n/// @dev Bond Protocol is a system to create Olympus-style bond markets\n///      for any token pair. The markets do not require maintenance and will manage\n///      bond prices based on activity. Bond issuers create BondMarkets that pay out\n///      a Payout Token in exchange for deposited Quote Tokens. Users can purchase\n///      future-dated Payout Tokens with Quote Tokens at the current market price and\n///      receive Bond Tokens to represent their position while their bond vests.\n///      Once the Bond Tokens vest, they can redeem it for the Quote Tokens.\n///\n/// @dev The Auctioneer contract allows users to create and manage bond markets.\n///      All bond pricing logic and market data is stored in the Auctioneer.\n///      A Auctioneer is dependent on a Teller to serve external users and\n///      an Aggregator to register new markets. This implementation of the Auctioneer\n///      uses a Sequential Dutch Auction pricing system to buy a target amount of quote\n///      tokens or sell a target amount of payout tokens over the duration of a market.\n///\n/// @author Oighty, Zeus, Potted Meat, indigo\nabstract contract BondBaseSDA is IBondSDA, Auth {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS ========== */\n\n    error Auctioneer_OnlyMarketOwner();\n    error Auctioneer_InitialPriceLessThanMin();\n    error Auctioneer_MarketConcluded(uint256 conclusion_);\n    error Auctioneer_MaxPayoutExceeded();\n    error Auctioneer_AmountLessThanMinimum();\n    error Auctioneer_NotEnoughCapacity();\n    error Auctioneer_InvalidCallback();\n    error Auctioneer_BadExpiry();\n    error Auctioneer_InvalidParams();\n    error Auctioneer_NotAuthorized();\n    error Auctioneer_NewMarketsNotAllowed();\n\n    /* ========== EVENTS ========== */\n\n    event MarketCreated(\n        uint256 indexed id,\n        address indexed payoutToken,\n        address indexed quoteToken,\n        uint48 vesting,\n        uint256 initialPrice\n    );\n    event MarketClosed(uint256 indexed id);\n    event Tuned(uint256 indexed id, uint256 oldControlVariable, uint256 newControlVariable);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Main information pertaining to bond market\n    mapping(uint256 => BondMarket) public markets;\n\n    /// @notice Information used to control how a bond market changes\n    mapping(uint256 => BondTerms) public terms;\n\n    /// @notice Data needed for tuning bond market\n    mapping(uint256 => BondMetadata) public metadata;\n\n    /// @notice Control variable changes\n    mapping(uint256 => Adjustment) public adjustments;\n\n    /// @notice New address to designate as market owner. They must accept ownership to transfer permissions.\n    mapping(uint256 => address) public newOwners;\n\n    /// @notice Whether or not the auctioneer allows new markets to be created\n    /// @dev    Changing to false will sunset the auctioneer after all active markets end\n    bool public allowNewMarkets;\n\n    /// @notice Whether or not the market creator is authorized to use a callback address\n    mapping(address => bool) public callbackAuthorized;\n\n    /// Sane defaults for tuning. Can be adjusted for a specific market via setters.\n    uint32 public defaultTuneInterval;\n    uint32 public defaultTuneAdjustment;\n    /// Minimum values for decay, deposit interval, market duration and debt buffer.\n    uint32 public minDebtDecayInterval;\n    uint32 public minDepositInterval;\n    uint32 public minMarketDuration;\n    uint32 public minDebtBuffer;\n\n    // A 'vesting' param longer than 50 years is considered a timestamp for fixed expiry.\n    uint48 internal constant MAX_FIXED_TERM = 52 weeks * 50;\n    uint48 internal constant FEE_DECIMALS = 1e5; // one percent equals 1000.\n\n    // BondAggregator contract with utility functions\n    IBondAggregator internal immutable _aggregator;\n\n    // BondTeller contract that handles interactions with users and issues tokens\n    IBondTeller internal immutable _teller;\n\n    constructor(\n        IBondTeller teller_,\n        IBondAggregator aggregator_,\n        address guardian_,\n        Authority authority_\n    ) Auth(guardian_, authority_) {\n        _aggregator = aggregator_;\n        _teller = teller_;\n\n        defaultTuneInterval = 24 hours;\n        defaultTuneAdjustment = 1 hours;\n        minDebtDecayInterval = 3 days;\n        minDepositInterval = 1 hours;\n        minMarketDuration = 1 days;\n        minDebtBuffer = 10000; // 10%\n\n        allowNewMarkets = true;\n    }\n\n    /* ========== MARKET FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAuctioneer\n    function createMarket(bytes calldata params_) external virtual returns (uint256);\n\n    /// @notice core market creation logic, see IBondSDA.MarketParams documentation\n    function _createMarket(MarketParams memory params_) internal returns (uint256) {\n        {\n            // Check that the auctioneer is allowing new markets to be created\n            if (!allowNewMarkets) revert Auctioneer_NewMarketsNotAllowed();\n\n            // Ensure params are in bounds\n            uint8 payoutTokenDecimals = params_.payoutToken.decimals();\n            uint8 quoteTokenDecimals = params_.quoteToken.decimals();\n\n            if (payoutTokenDecimals < 6 || payoutTokenDecimals > 18)\n                revert Auctioneer_InvalidParams();\n            if (quoteTokenDecimals < 6 || quoteTokenDecimals > 18)\n                revert Auctioneer_InvalidParams();\n            if (params_.scaleAdjustment < -24 || params_.scaleAdjustment > 24)\n                revert Auctioneer_InvalidParams();\n\n            // Restrict the use of a callback address unless allowed\n            if (!callbackAuthorized[msg.sender] && params_.callbackAddr != address(0))\n                revert Auctioneer_NotAuthorized();\n        }\n\n        // Unit to scale calculation for this market by to ensure reasonable values\n        // for price, debt, and control variable without under/overflows.\n        // See IBondSDA for more details.\n        //\n        // scaleAdjustment should be equal to (payoutDecimals - quoteDecimals) - ((payoutPriceDecimals - quotePriceDecimals) / 2)\n        uint256 scale;\n        unchecked {\n            scale = 10**uint8(36 + params_.scaleAdjustment);\n        }\n\n        if (params_.formattedInitialPrice < params_.formattedMinimumPrice)\n            revert Auctioneer_InitialPriceLessThanMin();\n\n        // Register new market on aggregator and get marketId\n        uint256 marketId = _aggregator.registerMarket(params_.payoutToken, params_.quoteToken);\n\n        uint32 secondsToConclusion;\n        uint32 debtDecayInterval;\n        {\n            // Conclusion must be later than the current block timestamp or will revert\n            secondsToConclusion = uint32(params_.conclusion - block.timestamp);\n            if (\n                secondsToConclusion < minMarketDuration ||\n                params_.depositInterval < minDepositInterval ||\n                params_.depositInterval > secondsToConclusion\n            ) revert Auctioneer_InvalidParams();\n\n            // The debt decay interval is how long it takes for price to drop to 0 from the last decay timestamp.\n            // In reality, a 50% drop is likely a guaranteed bond sale. Therefore, debt decay interval needs to be\n            // long enough to allow a bond to adjust if oversold. It also needs to be some multiple of deposit interval\n            // because you don't want to go from 100 to 0 during the time frame you expected to sell a single bond.\n            // A multiple of 5 is a sane default observed from running OP v1 bond markets.\n            uint32 userDebtDecay = params_.depositInterval * 5;\n            debtDecayInterval = minDebtDecayInterval > userDebtDecay\n                ? minDebtDecayInterval\n                : userDebtDecay;\n\n            uint256 tuneIntervalCapacity = params_.capacity.mulDiv(\n                uint256(\n                    params_.depositInterval > defaultTuneInterval\n                        ? params_.depositInterval\n                        : defaultTuneInterval\n                ),\n                uint256(secondsToConclusion)\n            );\n\n            metadata[marketId] = BondMetadata({\n                lastTune: uint48(block.timestamp),\n                lastDecay: uint48(block.timestamp),\n                length: secondsToConclusion,\n                depositInterval: params_.depositInterval,\n                tuneInterval: params_.depositInterval > defaultTuneInterval\n                    ? params_.depositInterval\n                    : defaultTuneInterval,\n                tuneAdjustmentDelay: defaultTuneAdjustment,\n                debtDecayInterval: debtDecayInterval,\n                tuneIntervalCapacity: tuneIntervalCapacity,\n                tuneBelowCapacity: params_.capacity - tuneIntervalCapacity,\n                lastTuneDebt: (\n                    params_.capacityInQuote\n                        ? params_.capacity.mulDiv(scale, params_.formattedInitialPrice)\n                        : params_.capacity\n                ).mulDiv(uint256(debtDecayInterval), uint256(secondsToConclusion))\n            });\n        }\n\n        // Initial target debt is equal to capacity scaled by the ratio of the debt decay interval and the length of the market.\n        // This is the amount of debt that should be decayed over the decay interval if no purchases are made.\n        // Note price should be passed in a specific format:\n        // price = (payoutPriceCoefficient / quotePriceCoefficient)\n        //         * 10**(36 + scaleAdjustment + quoteDecimals - payoutDecimals + payoutPriceDecimals - quotePriceDecimals)\n        // See IBondSDA for more details and variable definitions.\n        uint256 targetDebt;\n        uint256 maxPayout;\n        {\n            uint256 capacity = params_.capacityInQuote\n                ? params_.capacity.mulDiv(scale, params_.formattedInitialPrice)\n                : params_.capacity;\n\n            targetDebt = capacity.mulDiv(uint256(debtDecayInterval), uint256(secondsToConclusion));\n\n            // Max payout is the amount of capacity that should be utilized in a deposit\n            // interval. for example, if capacity is 1,000 TOKEN, there are 10 days to conclusion,\n            // and the preferred deposit interval is 1 day, max payout would be 100 TOKEN.\n            // Additionally, max payout is the maximum amount that a user can receive from a single\n            // purchase at that moment in time.\n            maxPayout = capacity.mulDiv(\n                uint256(params_.depositInterval),\n                uint256(secondsToConclusion)\n            );\n        }\n\n        markets[marketId] = BondMarket({\n            owner: msg.sender,\n            payoutToken: params_.payoutToken,\n            quoteToken: params_.quoteToken,\n            callbackAddr: params_.callbackAddr,\n            capacityInQuote: params_.capacityInQuote,\n            capacity: params_.capacity,\n            totalDebt: targetDebt,\n            minPrice: params_.formattedMinimumPrice,\n            maxPayout: maxPayout,\n            purchased: 0,\n            sold: 0,\n            scale: scale\n        });\n\n        // Max debt serves as a circuit breaker for the market. let's say the quote token is a stablecoin,\n        // and that stablecoin depegs. without max debt, the market would continue to buy until it runs\n        // out of capacity. this is configurable with a 3 decimal buffer (1000 = 1% above initial price).\n        // Note that its likely advisable to keep this buffer wide.\n        // Note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\n        // 1e5 = 100,000. 10,000 / 100,000 = 10%.\n        // See IBondSDA.MarketParams for more information on determining a reasonable debt buffer.\n        uint256 minDebtBuffer_ = maxPayout.mulDiv(FEE_DECIMALS, targetDebt) > minDebtBuffer\n            ? maxPayout.mulDiv(FEE_DECIMALS, targetDebt)\n            : minDebtBuffer;\n        uint256 maxDebt = targetDebt +\n            targetDebt.mulDiv(\n                uint256(params_.debtBuffer > minDebtBuffer_ ? params_.debtBuffer : minDebtBuffer_),\n                1e5\n            );\n\n        // The control variable is set as the ratio of price to the initial targetDebt, scaled to prevent under/overflows.\n        // It determines the price of the market as the debt decays and is tuned by the market based on user activity.\n        // See _tune() for more information.\n        //\n        // price = control variable * debt / scale\n        // therefore, control variable = price * scale / debt\n        uint256 controlVariable = params_.formattedInitialPrice.mulDiv(scale, targetDebt);\n\n        terms[marketId] = BondTerms({\n            controlVariable: controlVariable,\n            maxDebt: maxDebt,\n            vesting: params_.vesting,\n            conclusion: params_.conclusion\n        });\n\n        emit MarketCreated(\n            marketId,\n            address(params_.payoutToken),\n            address(params_.quoteToken),\n            params_.vesting,\n            params_.formattedInitialPrice\n        );\n\n        return marketId;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function setIntervals(uint256 id_, uint32[3] calldata intervals_) external override {\n        // Check that the market is live\n        if (!isLive(id_)) revert Auctioneer_InvalidParams();\n\n        // Check that the intervals are non-zero\n        if (intervals_[0] == 0 || intervals_[1] == 0 || intervals_[2] == 0)\n            revert Auctioneer_InvalidParams();\n\n        // Check that tuneInterval >= tuneAdjustmentDelay\n        if (intervals_[0] < intervals_[1]) revert Auctioneer_InvalidParams();\n\n        BondMetadata storage meta = metadata[id_];\n        // Check that tuneInterval >= depositInterval\n        if (intervals_[0] < meta.depositInterval) revert Auctioneer_InvalidParams();\n\n        // Check that debtDecayInterval >= minDebtDecayInterval\n        if (intervals_[2] < minDebtDecayInterval) revert Auctioneer_InvalidParams();\n\n        // Check that sender is market owner\n        BondMarket memory market = markets[id_];\n        if (msg.sender != market.owner) revert Auctioneer_OnlyMarketOwner();\n\n        // Update intervals\n        meta.tuneInterval = intervals_[0];\n        meta.tuneIntervalCapacity = market.capacity.mulDiv(\n            uint256(intervals_[0]),\n            uint256(terms[id_].conclusion) - block.timestamp\n        ); // don't have a stored value for market duration, this will update tuneIntervalCapacity based on time remaining\n        meta.tuneAdjustmentDelay = intervals_[1];\n        meta.debtDecayInterval = intervals_[2];\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function pushOwnership(uint256 id_, address newOwner_) external override {\n        if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n        newOwners[id_] = newOwner_;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function pullOwnership(uint256 id_) external override {\n        if (msg.sender != newOwners[id_]) revert Auctioneer_NotAuthorized();\n        markets[id_].owner = newOwners[id_];\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function setDefaults(uint32[6] memory defaults_) external override requiresAuth {\n        // Restricted to authorized addresses\n        defaultTuneInterval = defaults_[0];\n        defaultTuneAdjustment = defaults_[1];\n        minDebtDecayInterval = defaults_[2];\n        minDepositInterval = defaults_[3];\n        minMarketDuration = defaults_[4];\n        minDebtBuffer = defaults_[5];\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function setAllowNewMarkets(bool status_) external override requiresAuth {\n        // Restricted to authorized addresses\n        allowNewMarkets = status_;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function setCallbackAuthStatus(address creator_, bool status_) external override requiresAuth {\n        // Restricted to authorized addresses\n        callbackAuthorized[creator_] = status_;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function closeMarket(uint256 id_) external override {\n        if (msg.sender != markets[id_].owner) revert Auctioneer_OnlyMarketOwner();\n        _close(id_);\n    }\n\n    /* ========== TELLER FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAuctioneer\n    function purchaseBond(\n        uint256 id_,\n        uint256 amount_,\n        uint256 minAmountOut_\n    ) external override returns (uint256 payout) {\n        if (msg.sender != address(_teller)) revert Auctioneer_NotAuthorized();\n\n        BondMarket storage market = markets[id_];\n        BondTerms memory term = terms[id_];\n\n        // If market uses a callback, check that owner is still callback authorized\n        if (market.callbackAddr != address(0) && !callbackAuthorized[market.owner])\n            revert Auctioneer_NotAuthorized();\n\n        // Markets end at a defined timestamp\n        uint48 currentTime = uint48(block.timestamp);\n        if (currentTime >= term.conclusion) revert Auctioneer_MarketConcluded(term.conclusion);\n\n        uint256 price;\n        (price, payout) = _decayAndGetPrice(id_, amount_, uint48(block.timestamp)); // Debt and the control variable decay over time\n\n        // Payout must be greater than user inputted minimum\n        if (payout < minAmountOut_) revert Auctioneer_AmountLessThanMinimum();\n\n        // Markets have a max payout amount, capping size because deposits\n        // do not experience slippage. max payout is recalculated upon tuning\n        if (payout > market.maxPayout) revert Auctioneer_MaxPayoutExceeded();\n\n        // Update Capacity and Debt values\n\n        // Capacity is either the number of payout tokens that the market can sell\n        // (if capacity in quote is false),\n        //\n        // or the number of quote tokens that the market can buy\n        // (if capacity in quote is true)\n\n        // If amount/payout is greater than capacity remaining, revert\n        if (market.capacityInQuote ? amount_ > market.capacity : payout > market.capacity)\n            revert Auctioneer_NotEnoughCapacity();\n        // Capacity is decreased by the deposited or paid amount\n        market.capacity -= market.capacityInQuote ? amount_ : payout;\n\n        // Markets keep track of how many quote tokens have been\n        // purchased, and how many payout tokens have been sold\n        market.purchased += amount_;\n        market.sold += payout;\n\n        // Circuit breaker. If max debt is breached, the market is closed\n        if (term.maxDebt < market.totalDebt) {\n            _close(id_);\n        } else {\n            // If market will continue, the control variable is tuned to to expend remaining capacity over remaining market duration\n            _tune(id_, currentTime, price);\n        }\n    }\n\n    /* ========== INTERNAL DEPO FUNCTIONS ========== */\n\n    /// @notice          Close a market\n    /// @dev             Closing a market sets capacity to 0 and immediately stops bonding\n    function _close(uint256 id_) internal {\n        terms[id_].conclusion = uint48(block.timestamp);\n        markets[id_].capacity = 0;\n\n        emit MarketClosed(id_);\n    }\n\n    /// @notice                 Decay debt, and adjust control variable if there is an active change\n    /// @param id_              ID of market\n    /// @param amount_          Amount of quote tokens being purchased\n    /// @param time_            Current timestamp (saves gas when passed in)\n    /// @return marketPrice_    Current market price of bond, accounting for decay\n    /// @return payout_         Amount of payout tokens received at current price\n    function _decayAndGetPrice(\n        uint256 id_,\n        uint256 amount_,\n        uint48 time_\n    ) internal returns (uint256 marketPrice_, uint256 payout_) {\n        BondMarket memory market = markets[id_];\n\n        // Debt is a time-decayed sum of tokens spent in a market\n        // Debt is added when deposits occur and removed over time\n        // |\n        // |    debt falls with\n        // |   / \\  inactivity        / \\\n        // | /     \\              /\\ /   \\\n        // |         \\           /        \\ / \\\n        // |           \\      /\\/\n        // |             \\  /  and rises\n        // |                with deposits\n        // |\n        // |------------------------------------| t\n\n        // Decay debt by the amount of time since the last decay\n        uint256 decayedDebt = currentDebt(id_);\n        markets[id_].totalDebt = decayedDebt;\n\n        // Control variable decay\n\n        // The bond control variable is continually tuned. When it is lowered (which\n        // lowers the market price), the change is carried out smoothly over time.\n        if (adjustments[id_].active) {\n            Adjustment storage adjustment = adjustments[id_];\n\n            (uint256 adjustBy, uint48 secondsSince, bool stillActive) = _controlDecay(id_);\n            terms[id_].controlVariable -= adjustBy;\n\n            if (stillActive) {\n                adjustment.change -= adjustBy;\n                adjustment.timeToAdjusted -= secondsSince;\n                adjustment.lastAdjustment = time_;\n            } else {\n                adjustment.active = false;\n            }\n        }\n\n        // Price is not allowed to be lower than the minimum price\n        marketPrice_ = _currentMarketPrice(id_);\n        uint256 minPrice = market.minPrice;\n        if (marketPrice_ < minPrice) marketPrice_ = minPrice;\n\n        // Payout for the deposit = amount / price\n        //\n        // where:\n        // payout = payout tokens out\n        // amount = quote tokens in\n        // price = quote tokens : payout token (i.e. 200 QUOTE : BASE), adjusted for scaling\n        payout_ = amount_.mulDiv(market.scale, marketPrice_);\n\n        // Cache storage variables to memory\n        uint256 debtDecayInterval = uint256(metadata[id_].debtDecayInterval);\n        uint256 lastTuneDebt = metadata[id_].lastTuneDebt;\n        uint256 lastDecay = uint256(metadata[id_].lastDecay);\n\n        // Set last decay timestamp based on size of purchase to linearize decay\n        uint256 lastDecayIncrement = debtDecayInterval.mulDiv(payout_, lastTuneDebt);\n        metadata[id_].lastDecay += uint48(lastDecayIncrement);\n\n        // Update total debt following the purchase\n        // Goal is to have the same decayed debt post-purchase as pre-purchase so that price is the same as before purchase and then add new debt to increase price\n        // 1. Adjust total debt so that decayed debt is equal to the current debt after updating the last decay timestamp.\n        //    This is the currentDebt function solved for totalDebt and adding lastDecayIncrement (the number of seconds lastDecay moves forward in time)\n        //    to the number of seconds used to calculate the previous currentDebt.\n        // 2. Add the payout to the total debt to increase the price.\n        uint256 decayOffset = time_ > lastDecay\n            ? (\n                debtDecayInterval > (time_ - lastDecay)\n                    ? debtDecayInterval - (time_ - lastDecay)\n                    : 0\n            )\n            : debtDecayInterval + (lastDecay - time_);\n        markets[id_].totalDebt =\n            decayedDebt.mulDiv(debtDecayInterval, decayOffset + lastDecayIncrement) +\n            payout_ +\n            1; // add 1 to satisfy price inequality\n    }\n\n    /// @notice             Auto-adjust control variable to hit capacity/spend target\n    /// @param id_          ID of market\n    /// @param time_        Timestamp (saves gas when passed in)\n    /// @param price_       Current price of the market\n    function _tune(\n        uint256 id_,\n        uint48 time_,\n        uint256 price_\n    ) internal {\n        BondMetadata memory meta = metadata[id_];\n        BondMarket memory market = markets[id_];\n\n        // Market tunes in 2 situations:\n        // 1. If capacity has exceeded target since last tune adjustment and the market is oversold\n        // 2. If a tune interval has passed since last tune adjustment and the market is undersold\n        //\n        // Markets are created with a target capacity with the expectation that capacity will\n        // be utilized evenly over the duration of the market.\n        // The intuition with tuning is:\n        // - When the market is ahead of target capacity, we should tune based on capacity.\n        // - When the market is behind target capacity, we should tune based on time.\n\n        // Compute seconds remaining until market will conclude\n        uint256 timeRemaining = uint256(terms[id_].conclusion - time_);\n\n        // Standardize capacity into an payout token amount\n        uint256 capacity = market.capacityInQuote\n            ? market.capacity.mulDiv(market.scale, price_)\n            : market.capacity;\n        // Calculate initial capacity based on remaining capacity and amount sold/purchased up to this point\n        uint256 initialCapacity = capacity +\n            (market.capacityInQuote ? market.purchased.mulDiv(market.scale, price_) : market.sold);\n\n        // Calculate timeNeutralCapacity as the capacity expected to be sold up to this point and the current capacity\n        // Higher than initial capacity means the market is undersold, lower than initial capacity means the market is oversold\n        uint256 timeNeutralCapacity = initialCapacity.mulDiv(\n            uint256(meta.length) - timeRemaining,\n            uint256(meta.length)\n        ) + capacity;\n\n        if (\n            (market.capacity < meta.tuneBelowCapacity && timeNeutralCapacity < initialCapacity) ||\n            (time_ >= meta.lastTune + meta.tuneInterval && timeNeutralCapacity > initialCapacity)\n        ) {\n            // Calculate the correct payout to complete on time assuming each bond\n            // will be max size in the desired deposit interval for the remaining time\n            //\n            // i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n            // is 10,000 TOKEN. max payout would be 1,000 TOKEN (10,000 * 1 / 10).\n            markets[id_].maxPayout = capacity.mulDiv(uint256(meta.depositInterval), timeRemaining);\n\n            // Calculate ideal target debt to satisty capacity in the remaining time\n            // The target debt is based on whether the market is under or oversold at this point in time\n            // This target debt will ensure price is reactive while ensuring the magnitude of being over/undersold\n            // doesn't cause larger fluctuations towards the end of the market.\n            //\n            // Calculate target debt from the timeNeutralCapacity and the ratio of debt decay interval and the length of the market\n            uint256 targetDebt = timeNeutralCapacity.mulDiv(\n                uint256(meta.debtDecayInterval),\n                uint256(meta.length)\n            );\n\n            // Derive a new control variable from the target debt\n            uint256 controlVariable = terms[id_].controlVariable;\n            uint256 newControlVariable = price_.mulDivUp(market.scale, targetDebt);\n\n            emit Tuned(id_, controlVariable, newControlVariable);\n\n            if (newControlVariable < controlVariable) {\n                // If decrease, control variable change will be carried out over the tune interval\n                // this is because price will be lowered\n                uint256 change = controlVariable - newControlVariable;\n                adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true);\n            } else {\n                // Tune up immediately\n                terms[id_].controlVariable = newControlVariable;\n                // Set current adjustment to inactive (e.g. if we are re-tuning early)\n                adjustments[id_].active = false;\n            }\n\n            metadata[id_].lastTune = time_;\n            metadata[id_].tuneBelowCapacity = market.capacity > meta.tuneIntervalCapacity\n                ? market.capacity - meta.tuneIntervalCapacity\n                : 0;\n            metadata[id_].lastTuneDebt = targetDebt;\n        }\n    }\n\n    /* ========== INTERNAL VIEW FUNCTIONS ========== */\n\n    /// @notice             Calculate current market price of payout token in quote tokens\n    /// @dev                See marketPrice() in IBondSDA for explanation of price computation\n    /// @dev                Uses info from storage because data has been updated before call (vs marketPrice())\n    /// @param id_          Market ID\n    /// @return             Price for market in payout token decimals\n    function _currentMarketPrice(uint256 id_) internal view returns (uint256) {\n        BondMarket memory market = markets[id_];\n        return terms[id_].controlVariable.mulDiv(market.totalDebt, market.scale);\n    }\n\n    /// @notice                 Amount to decay control variable by\n    /// @param id_              ID of market\n    /// @return decay           change in control variable\n    /// @return secondsSince    seconds since last change in control variable\n    /// @return active          whether or not change remains active\n    function _controlDecay(uint256 id_)\n        internal\n        view\n        returns (\n            uint256 decay,\n            uint48 secondsSince,\n            bool active\n        )\n    {\n        Adjustment memory info = adjustments[id_];\n        if (!info.active) return (0, 0, false);\n\n        secondsSince = uint48(block.timestamp) - info.lastAdjustment;\n        active = secondsSince < info.timeToAdjusted;\n        decay = active\n            ? info.change.mulDiv(uint256(secondsSince), uint256(info.timeToAdjusted))\n            : info.change;\n    }\n\n    /* ========== EXTERNAL VIEW FUNCTIONS ========== */\n\n    /// @inheritdoc IBondAuctioneer\n    function getMarketInfoForPurchase(uint256 id_)\n        external\n        view\n        returns (\n            address owner,\n            address callbackAddr,\n            ERC20 payoutToken,\n            ERC20 quoteToken,\n            uint48 vesting,\n            uint256 maxPayout\n        )\n    {\n        BondMarket memory market = markets[id_];\n        return (\n            market.owner,\n            market.callbackAddr,\n            market.payoutToken,\n            market.quoteToken,\n            terms[id_].vesting,\n            market.maxPayout\n        );\n    }\n\n    /// @inheritdoc IBondSDA\n    function marketPrice(uint256 id_) public view override returns (uint256) {\n        uint256 price = currentControlVariable(id_).mulDivUp(currentDebt(id_), markets[id_].scale);\n\n        return (price > markets[id_].minPrice) ? price : markets[id_].minPrice;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function marketScale(uint256 id_) external view override returns (uint256) {\n        return markets[id_].scale;\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function payoutFor(\n        uint256 amount_,\n        uint256 id_,\n        address referrer_\n    ) public view override returns (uint256) {\n        // Calculate the payout for the given amount of tokens\n        uint256 fee = amount_.mulDiv(_teller.getFee(referrer_), 1e5);\n        uint256 payout = (amount_ - fee).mulDiv(markets[id_].scale, marketPrice(id_));\n\n        // Check that the payout is less than or equal to the maximum payout,\n        // Revert if not, otherwise return the payout\n        if (payout > markets[id_].maxPayout) {\n            revert Auctioneer_MaxPayoutExceeded();\n        } else {\n            return payout;\n        }\n    }\n\n    /// @inheritdoc IBondAuctioneer\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256) {\n        // Calculate maximum amount of quote tokens that correspond to max bond size\n        // Maximum of the maxPayout and the remaining capacity converted to quote tokens\n        BondMarket memory market = markets[id_];\n        uint256 price = marketPrice(id_);\n        uint256 quoteCapacity = market.capacityInQuote\n            ? market.capacity\n            : market.capacity.mulDiv(price, market.scale);\n        uint256 maxQuote = market.maxPayout.mulDiv(price, market.scale);\n        uint256 amountAccepted = quoteCapacity < maxQuote ? quoteCapacity : maxQuote;\n\n        // Take into account teller fees and return\n        // Estimate fee ba"
    }
  ]
}