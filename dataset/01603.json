{
  "Title": "M-12: No `minAnswer/maxAnswer` Circuit Breaker Checks while Querying Prices in Oracle.sol",
  "Content": "# Issue M-12: No `minAnswer/maxAnswer` Circuit Breaker Checks while Querying Prices in Oracle.sol \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/241 \n\n## Found by \nBauchibred, BugBusters, Hama, crimson-rat-reach, ni8mare, rogue-lion-0619\n\n\n## Summary\n\nThe Oracle.sol contract, while currently applying a safety check (this can be side stepped, check my other submission ) to ensure returned prices are greater than zero, which is commendable, as it effectively mitigates the risk of using negative prices, there should be an implementation to ensure the returned prices are not at the extreme boundaries (`minAnswer` and `maxAnswer`).\nWithout such a mechanism, the contract could operate based on incorrect prices, which could lead to an over- or under-representation of the asset's value, potentially causing significant harm to the protocol.\n\n## Vulnerability Details\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. This is exactly what happened to [Venus on BSC when LUNA imploded](https://rekt.news/venus-blizz-rekt/).\nIn its current form, the `getUnderlyingPrice()` function within the Oracle.sol contract retrieves the latest round data from Chainlink, if the asset's market price plummets below `minAnswer` or skyrockets above `maxAnswer`, the returned price will still be `minAnswer` or `maxAnswer`, respectively, rather than the actual market price. This could potentially lead to an exploitation scenario where the protocol interacts with the asset using incorrect price information.\n\nTake a look at [Oracle.sol#L106-L123](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/1f9a5ed0ca8f6004bbb7b099ecbb8ae796557849/hubble-protocol/contracts/Oracle.sol#L106-L123):\n\n```solidity\n\n    function getLatestRoundData(AggregatorV3Interface _aggregator)\n        internal\n        view\n        returns (\n            uint80,\n            uint256 finalPrice,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice <= 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n```\n\n### Illustration:\n\n- Present price of TokenA is $10\n- TokenA has a minimum price set at $1 on chainlink\n- The actual price of TokenA dips to $0.10\n- The aggregator continues to report $1 as the price.\n\nConsequently, users can interact with protocol using TokenA as though it were still valued at $1, which is a tenfold overestimate of its real market value.\n\n## Impact\n\nThe potential for misuse arises when the actual price of an asset drastically changes but the oracle continues to operate using the `minAnswer` or `maxAnswer` as the asset's price. In the case of it going under the `minAnswer` malicious actors obviously have the upperhand and could give their potential _going to zero_ worth tokens to protocol\n\n## Code Snippet\n\n[PriceOracle.sol#L60-L72](https://github.com/sherlock-audit/2023-05-ironbank/blob/9ebf1702b2163b55479624794ab7999392367d2a/ib-v2/src/protocol/oracle/PriceOracle.sol#L60-L72)\n\n## Tool used\nManual Audit\n## Recommendation\n\nSince there is going to be a whitelist of tokens to be added, the minPrice/maxPrice could be checked and a revert could be made when this is returned by chainlink or a fallback oracle that does not have circuit breakers could be implemented in that case\n\n\n\n\n## Discussion\n\n**asquare08**\n\nThis is a valid concern. But we will fix this in later releases as initially, we are launching with blue chip tokens only and single collateral (USDC).  \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { AggregatorV3Interface } from \"./Interfaces.sol\";\n\ncontract Oracle is Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    mapping(address => address) public chainLinkAggregatorMap;\n    mapping(address => int256) public stablePrice;\n\n    uint256[50] private __gap;\n\n    function initialize(address _governance) external initializer {\n        _setGovernace(_governance);\n    }\n\n    function getUnderlyingPrice(address underlying)\n        virtual\n        external\n        view\n        returns(int256 answer)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        (,answer,,,) = AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData();\n        require(answer > 0, \"Oracle.getUnderlyingPrice.non_positive\");\n        answer /= 100;\n    }\n\n    function getUnderlyingTwapPrice(address underlying, uint256 intervalInSeconds)\n        virtual\n        public\n        view\n        returns (int256)\n    {\n        if (stablePrice[underlying] != 0) {\n            return stablePrice[underlying];\n        }\n        AggregatorV3Interface aggregator = AggregatorV3Interface(chainLinkAggregatorMap[underlying]);\n        requireNonEmptyAddress(address(aggregator));\n        require(intervalInSeconds != 0, \"interval can't be 0\");\n\n        // 3 different timestamps, `previous`, `current`, `target`\n        // `base` = now - intervalInSeconds\n        // `current` = current round timestamp from aggregator\n        // `previous` = previous round timestamp from aggregator\n        // now >= previous > current > = < base\n        //\n        //  while loop i = 0\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base                 current  now(previous)\n        //\n        //  while loop i = 1\n        //  --+------+-----+-----+-----+-----+-----+\n        //         base           current previous now\n\n        (uint80 round, uint256 latestPrice, uint256 latestTimestamp) = getLatestRoundData(aggregator);\n        uint256 baseTimestamp = _blockTimestamp() - intervalInSeconds;\n        // if latest updated timestamp is earlier than target timestamp, return the latest price.\n        if (latestTimestamp < baseTimestamp || round == 0) {\n            return formatPrice(latestPrice);\n        }\n\n        // rounds are like snapshots, latestRound means the latest price snapshot. follow chainlink naming\n        uint256 previousTimestamp = latestTimestamp;\n        uint256 cumulativeTime = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = latestPrice * cumulativeTime;\n        while (true) {\n            if (round == 0) {\n                // if cumulative time is less than requested interval, return current twap price\n                return formatPrice(weightedPrice / cumulativeTime);\n            }\n\n            round = round - 1; // check round sanity\n            (, uint256 currentPrice, uint256 currentTimestamp) = getRoundData(aggregator, round);\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentTimestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, intervalInSeconds is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentTimestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            cumulativeTime = cumulativeTime + timeFraction;\n            previousTimestamp = currentTimestamp;\n        }\n        return formatPrice(weightedPrice / intervalInSeconds);\n    }\n\n    //\n    // INTERNAL VIEW FUNCTIONS\n    //\n\n    function getLatestRoundData(AggregatorV3Interface _aggregator)\n        internal\n        view\n        returns (\n            uint80,\n            uint256 finalPrice,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice <= 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n\n    function getRoundData(AggregatorV3Interface _aggregator, uint80 _round)\n        internal\n        view\n        returns (\n            uint80,\n            uint256,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.getRoundData(_round);\n        while (latestPrice <= 0) {\n            requireEnoughHistory(round);\n            round = round - 1;\n            (, latestPrice, , latestTimestamp, ) = _aggregator.getRoundData(round);\n        }\n        return (round, uint256(latestPrice), latestTimestamp);\n    }\n\n    function formatPrice(uint256 _price) internal pure returns (int256) {\n        return (_price / 100).toInt256(); // 6 decimals\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    // Internal\n\n    function requireEnoughHistory(uint80 _round) internal pure {\n        require(_round > 0, \"Not enough history\");\n    }\n\n    function requireNonEmptyAddress(address _addr) internal pure {\n        require(_addr != address(0), \"empty address\");\n    }\n\n    // Governance\n\n    function setAggregator(address underlying, address aggregator) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        requireNonEmptyAddress(aggregator);\n        // oracle answer should be in 8 decimals\n        require(AggregatorV3Interface(aggregator).decimals() == 8, 'Expected oracle to have 8 decimals');\n        chainLinkAggregatorMap[underlying] = aggregator;\n        // AggregatorV3Interface(chainLinkAggregatorMap[underlying]).latestRoundData(); // sanity check\n    }\n\n    function setStablePrice(address underlying, int256 price) external onlyGovernance {\n        requireNonEmptyAddress(underlying);\n        require(price > 0, \"stablePrice=0\");\n        stablePrice[underlying] = price;\n    }\n}"
    },
    {
      "filename": "ib-v2/src/protocol/oracle/PriceOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\nimport \"chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../extensions/interfaces/WstEthInterface.sol\";\nimport \"../../interfaces/PriceOracleInterface.sol\";\n\ncontract PriceOracle is Ownable2Step, PriceOracleInterface {\n    /// @notice The Chainlink feed registry\n    FeedRegistryInterface public immutable registry;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    struct AggregatorInfo {\n        address base;\n        address quote;\n    }\n\n    /// @notice The mapping from asset to aggregator\n    mapping(address => AggregatorInfo) public aggregators;\n\n    constructor(address registry_, address steth_, address wsteth_) {\n        registry = FeedRegistryInterface(registry_);\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @dev The price returned will be normalized by asset's decimals.\n     * @param asset The asset to get the price of\n     * @return The price of the asset in USD\n     */\n    function getPrice(address asset) external view returns (uint256) {\n        if (asset == wsteth) {\n            uint256 stEthPrice = getPriceFromChainlink(steth, Denominations.USD);\n            uint256 stEthPerToken = WstEthInterface(wsteth).stEthPerToken();\n            uint256 wstEthPrice = (stEthPrice * stEthPerToken) / 1e18;\n            return getNormalizedPrice(wstEthPrice, asset);\n        }\n\n        AggregatorInfo memory aggregatorInfo = aggregators[asset];\n        uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n        if (aggregatorInfo.quote == Denominations.ETH) {\n            // Convert the price to USD based if it's ETH based.\n            uint256 ethUsdPrice = getPriceFromChainlink(Denominations.ETH, Denominations.USD);\n            price = (price * ethUsdPrice) / 1e18;\n        }\n        return getNormalizedPrice(price, asset);\n    }\n\n    /**\n     * @notice Get price from Chainlink.\n     * @param base The base asset\n     * @param quote The quote asset\n     * @return The price\n     */\n    function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n        (, int256 price,,,) = registry.latestRoundData(base, quote);\n        require(price > 0, \"invalid price\");\n\n        // Extend the decimals to 1e18.\n        return uint256(price) * 10 ** (18 - uint256(registry.decimals(base, quote)));\n    }\n\n    /**\n     * @dev Get the normalized price.\n     * @param price The price\n     * @param asset The asset\n     * @return The normalized price\n     */\n    function getNormalizedPrice(uint256 price, address asset) internal view returns (uint256) {\n        uint8 decimals = IERC20Metadata(asset).decimals();\n        return price * 10 ** (18 - decimals);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    struct Aggregator {\n        address asset;\n        address base;\n        address quote;\n    }\n\n    /**\n     * @notice Set the aggregators.\n     * @param aggrs The aggregators\n     */\n    function _setAggregators(Aggregator[] calldata aggrs) external onlyOwner {\n        uint256 length = aggrs.length;\n        for (uint256 i = 0; i < length;) {\n            if (aggrs[i].base != address(0)) {\n                require(aggrs[i].quote == Denominations.ETH || aggrs[i].quote == Denominations.USD, \"unsupported quote\");\n\n                // Make sure the aggregator works.\n                address aggregator = address(registry.getFeed(aggrs[i].base, aggrs[i].quote));\n                require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n\n                (, int256 price,,,) = registry.latestRoundData(aggrs[i].base, aggrs[i].quote);\n                require(price > 0, \"invalid price\");\n            }\n            aggregators[aggrs[i].asset] = AggregatorInfo({base: aggrs[i].base, quote: aggrs[i].quote});\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}"
    }
  ]
}