{
  "Title": "[H-06] Bond operations will always revert at certain time when `putOptionsRequired` is true",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L481-L483> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L286> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L539-L551>\n\nwhen `putOptionsRequired` is `true`, there is period of time where bond operations will always revert when try to purchase options from perp atlantic vault.\n\n### Proof of Concept\n\nWhen `bond` is called and `putOptionsRequired` is `true`, it will call `_purchaseOptions` providing the calculated `rdpxRequired`.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L920-L922>\n\n```solidity\n  function bond(\n    uint256 _amount,\n    uint256 rdpxBondId,\n    address _to\n  ) public returns (uint256 receiptTokenAmount) {\n    _whenNotPaused();\n    // Validate amount\n    _validate(_amount > 0, 4);\n\n    // Compute the bond cost\n    (uint256 rdpxRequired, uint256 wethRequired) = calculateBondCost(\n      _amount,\n      rdpxBondId\n    );\n\n    IERC20WithBurn(weth).safeTransferFrom(\n      msg.sender,\n      address(this),\n      wethRequired\n    );\n\n    // update weth reserve\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance += wethRequired;\n\n    // purchase options\n    uint256 premium;\n    if (putOptionsRequired) {\n>>>   premium = _purchaseOptions(rdpxRequired);\n    }\n\n    _transfer(rdpxRequired, wethRequired - premium, _amount, rdpxBondId);\n\n    // Stake the ETH in the ReceiptToken contract\n    receiptTokenAmount = _stake(_to, _amount);\n\n    // reLP\n    if (isReLPActive) IReLP(addresses.reLPContract).reLP(_amount);\n\n    emit LogBond(rdpxRequired, wethRequired, receiptTokenAmount);\n  }\n```\n\nInside `_purchaseOptions`, it will call `PerpetualAtlanticVault.purchase` providing the amount and `address(this)` as receiver :\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L471-L487>\n\n```solidity\n  function _purchaseOptions(\n    uint256 _amount\n  ) internal returns (uint256 premium) {\n    /**\n     * Purchase options and store ERC721 option id\n     * Note that the amount of options purchased is the amount of rDPX received\n     * from the user to sufficiently collateralize the underlying DpxEth stored in the bond\n     **/\n    uint256 optionId;\n\n>>> (premium, optionId) = IPerpetualAtlanticVault(\n      addresses.perpetualAtlanticVault\n    ).purchase(_amount, address(this));\n\n    optionsOwned[optionId] = true;\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= premium;\n  }\n```\n\nThen inside `purchase`, it will calculate `premium` using `calculatePremium` function, providing `strike`, `amount`, `timeToExpiry`.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L286>\n\n```solidity\n  function purchase(\n    uint256 amount,\n    address to\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 premium, uint256 tokenId)\n  {\n    _whenNotPaused();\n    _validate(amount > 0, 2);\n\n    updateFunding();\n\n    uint256 currentPrice = getUnderlyingPrice(); // price of underlying wrt collateralToken\n    uint256 strike = roundUp(currentPrice - (currentPrice / 4)); // 25% below the current price\n    IPerpetualAtlanticVaultLP perpetualAtlanticVaultLp = IPerpetualAtlanticVaultLP(\n        addresses.perpetualAtlanticVaultLP\n      );\n\n    // Check if vault has enough collateral to write the options\n    uint256 requiredCollateral = (amount * strike) / 1e8;\n\n    _validate(\n      requiredCollateral <= perpetualAtlanticVaultLp.totalAvailableCollateral(),\n      3\n    );\n\n    uint256 timeToExpiry = nextFundingPaymentTimestamp() - block.timestamp;\n\n    // Get total premium for all options being purchased\n>>> premium = calculatePremium(strike, amount, timeToExpiry, 0);\n\n    // ... rest of operations\n  }\n```\n\nInside this `calculatePremium`, it will get price from option pricing :\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L539-L551>\n\n```solidity\n  function calculatePremium(\n    uint256 _strike,\n    uint256 _amount,\n    uint256 timeToExpiry,\n    uint256 _price\n  ) public view returns (uint256 premium) {\n    premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n      _strike,\n      _price > 0 ? _price : getUnderlyingPrice(),\n      getVolatility(_strike),\n      timeToExpiry\n    ) * _amount) / 1e8);\n  }\n```\n\nThe provided `OptionPricingSimple.getOptionPrice` will use Black-Scholes model to calculate the price :\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/libraries/BlackScholes.sol#L33-L89>\n\n```solidity\n  function calculate(\n    uint8 optionType,\n    uint256 price,\n    uint256 strike,\n    uint256 timeToExpiry,\n    uint256 riskFreeRate,\n    uint256 volatility\n  ) internal pure returns (uint256) {\n    bytes16 S = ABDKMathQuad.fromUInt(price);\n    bytes16 X = ABDKMathQuad.fromUInt(strike);\n    bytes16 T = ABDKMathQuad.div(\n      ABDKMathQuad.fromUInt(timeToExpiry),\n      ABDKMathQuad.fromUInt(36500) // 365 * 10 ^ DAYS_PRECISION\n    );\n    bytes16 r = ABDKMathQuad.div(\n      ABDKMathQuad.fromUInt(riskFreeRate),\n      ABDKMathQuad.fromUInt(10000)\n    );\n    bytes16 v = ABDKMathQuad.div(\n      ABDKMathQuad.fromUInt(volatility),\n      ABDKMathQuad.fromUInt(100)\n    );\n    bytes16 d1 = ABDKMathQuad.div(\n      ABDKMathQuad.add(\n        ABDKMathQuad.ln(ABDKMathQuad.div(S, X)),\n        ABDKMathQuad.mul(\n          ABDKMathQuad.add(\n            r,\n            ABDKMathQuad.mul(v, ABDKMathQuad.div(v, ABDKMathQuad.fromUInt(2)))\n          ),\n          T\n        )\n      ),\n      ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\n    );\n    bytes16 d2 = ABDKMathQuad.sub(\n      d1,\n      ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\n    );\n    if (optionType == OPTION_TYPE_CALL) {\n      return\n        ABDKMathQuad.toUInt(\n          ABDKMathQuad.mul(\n            _calculateCallTimeDecay(S, d1, X, r, T, d2),\n            ABDKMathQuad.fromUInt(DIVISOR)\n          )\n        );\n    } else if (optionType == OPTION_TYPE_PUT) {\n      return\n        ABDKMathQuad.toUInt(\n          ABDKMathQuad.mul(\n            _calculatePutTimeDecay(X, r, T, d2, S, d1),\n            ABDKMathQuad.fromUInt(DIVISOR)\n          )\n        );\n    } else return 0;\n  }\n```\n\nThe problem lies inside `calculatePremium` due to not properly check if current time less than 864 seconds (around 14 minutes). because `getOptionPrice` will use time expiry in days multiply by 100.\n\n<https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/libraries/OptionPricingSimple.sol#L72>\n\n```solidity\nuint256 timeToExpiry = (expiry * 100) / 86400;\n```\n\nIf `nextFundingPaymentTimestamp() - block.timestamp` is less than 864 seconds, it will cause `timeToExpiry` inside option pricing is 0 and the call will always revert. This will cause an unexpected revert period around 14 minutes every funding epoch (in this case every week).\n\nFoundry PoC :\n\nTry to simulate `calculatePremium` when `nextFundingPaymentTimestamp() - block.timestamp` is less than 864 seconds.\n\nAdd this test to `Unit` contract inside `/tests/rdpxV2-core/Unit.t.sol`, also add `import \"forge-std/console.sol\";` and `import {OptionPricingSimple} from \"contracts/libraries/OptionPricingSimple.sol\";` in the contract  :\n\n```solidity\n    function testOptionPricingRevert() public {\n        OptionPricingSimple optionPricingSimple;\n        optionPricingSimple = new OptionPricingSimple(100, 5e6);\n\n        (uint256 rdpxRequired, uint256 wethRequired) = rdpxV2Core\n            .calculateBondCost(1 * 1e18, 0);\n\n        uint256 currentPrice = vault.getUnderlyingPrice(); // price of underlying wrt collateralToken\n        uint256 strike = vault.roundUp(currentPrice - (currentPrice / 4)); // 25% below the current price\n        // around 14 minutes before next funding payment\n        vm.warp(block.timestamp + 7 days - 863 seconds);\n        uint256 timeToExpiry = vault.nextFundingPaymentTimestamp() -\n            block.timestamp;\n        console.log(\"What is the current price\");\n        console.log(currentPrice);\n        console.log(\"What is the strike\");\n        console.log(strike);\n        console.log(\"What is time to expiry\");\n        console.log(timeToExpiry);\n        uint256 price = vault.getUnderlyingPrice();\n        // will revert\n        vm.expectRevert();\n        optionPricingSimple.getOptionPrice(strike, price, 100, timeToExpiry);\n    }\n```\n### Recommended Mitigation Steps\n\nSet minimum `timeToExpiry` inside `calculatePremium` :\n\n```diff\n  function calculatePremium(\n    uint256 _strike,\n    uint256 _amount,\n    uint256 timeToExpiry,\n    uint256 _price\n  ) public view returns (uint256 premium) {\n    premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n      _strike,\n      _price > 0 ? _price : getUnderlyingPrice(),\n      getVolatility(_strike),\n-      timeToExpiry\n+      timeToExpiry < 864 ? 864 : timeToExpiry\n    ) * _amount) / 1e8);\n  }\n```\n\n**[psytama (Dopex) confirmed and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/756#issuecomment-1733776614):**\n > Modify time to expiry with a check for less than 864 seconds and make it more robust.\n\n**[Alex the Entreprenerd (Judge) commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/756#issuecomment-1773703004):**\n > The DOS is not conditional on an external requirement because it consistently happens, I'll ask judges, but am maintaining High Severity at this time.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/core/RdpxV2Core.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { RdpxV2Bond } from \"./RdpxV2Bond.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IStableSwap } from \"../interfaces/IStableSwap.sol\";\nimport { IRdpxDecayingBonds } from \"../decaying-bonds/IRdpxDecayingBonds.sol\";\nimport { IDpxEthToken } from \"../dpxETH/IDpxEthToken.sol\";\nimport { IPerpetualAtlanticVault } from \"../perp-vault/IPerpetualAtlanticVault.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IDpxEthOracle } from \"../oracles/IDpxEthOracle.sol\";\nimport { IRdpxReserve } from \"../reserve/IRdpxReserve.sol\";\nimport { IRdpxV2Core } from \"./IRdpxV2Core.sol\";\nimport { IRdpxV2ReceiptToken } from \"../interfaces/IRdpxV2ReceiptToken.sol\";\nimport { IReLP } from \"../interfaces/IReLP.sol\";\n\n// Libraries\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title Rdpx V2 Core contract\n/// @author Dopex\n/// @notice The Rdpx V2 Corecontracts handles the bonding mechanism and peg of DpxEth\ncontract RdpxV2Core is\n  IRdpxV2Core,\n  AccessControl,\n  ContractWhitelist,\n  ERC721Holder,\n  Pausable\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20WithBurn;\n  using SafeERC20 for IDpxEthToken;\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @notice Addresses used by the contract\n  Addresses public addresses;\n\n  /// @notice The pricing oracle addresses\n  PricingOracleAddresses public pricingOracleAddresses;\n\n  /* Inital tokens in the reserve\n     index0: ZERO address\n     index1: weth\n     index2: rdpx\n     index3: dpxEth\n     index4: crv\n  */\n\n  /// @notice Array containg the reserve assets\n  ReserveAsset[] public reserveAsset;\n\n  /// @notice Array that contains the addresses of the AMO\n  address[] public amoAddresses;\n\n  /// @notice Token address that dpxEth is pegged to\n  address public weth;\n\n  /// @notice Array that contains the symbol of the reserve tokens\n  string[] public reserveTokens;\n\n  /// @notice Mapping that contains the index for a specific token in the reserves\n  mapping(string => uint256) public reservesIndex;\n\n  /// @dev Bond id => Bond\n  mapping(uint256 => Bond) public bonds;\n\n  /// @dev Option id => owned or not (boolean)\n  mapping(uint256 => bool) public optionsOwned;\n\n  /// @dev Funding paid for epoch\n  mapping(uint256 => bool) public fundingPaidFor;\n\n  /// @notice Precision used for prices, percentages and other calculations\n  uint256 public constant DEFAULT_PRECISION = 1e8;\n\n  /// @notice rDPX Ratio required when bonding\n  uint256 public constant RDPX_RATIO_PERCENTAGE = 25 * DEFAULT_PRECISION;\n\n  /// @notice ETH Ratio required when bonding\n  uint256 public constant ETH_RATIO_PERCENTAGE = 75 * DEFAULT_PRECISION;\n\n  /// @notice The % of rdpx to burn while bonding\n  uint256 public rdpxBurnPercentage = 50 * DEFAULT_PRECISION;\n\n  /// @notice The % of rdpx sent to fee distributor while bonding\n  uint256 public rdpxFeePercentage = 50 * DEFAULT_PRECISION;\n\n  /// @notice The slippage tolernce in swaps in 1e8 precision\n  uint256 public slippageTolerance = 5e5; // 0.5%\n\n  /// @notice Liquidity slippage tolerance\n  uint256 public liquiditySlippageTolerance = 5e5; // 0.5%\n\n  /// @notice Bond maturity\n  uint256 public bondMaturity;\n\n  /// @notice rDPX LP bond discount factor\n  uint256 public bondDiscountFactor;\n\n  /// @notice Total weth delegated\n  uint256 public totalWethDelegated;\n\n  /// @notice Whether reLP is active or not\n  bool public isReLPActive;\n\n  /// @notice Whether put options are requred\n  bool public putOptionsRequired;\n\n  /// @notice Delegates array\n  Delegate[] public delegates;\n\n  // ================================ CONSTRUCTOR ================================ //\n  constructor(address _weth) {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    weth = _weth;\n\n    // add Zero asset to reserveAsset\n    ReserveAsset memory zeroAsset = ReserveAsset({\n      tokenAddress: address(0),\n      tokenBalance: 0,\n      tokenSymbol: \"ZERO\"\n    });\n    reserveAsset.push(zeroAsset);\n    putOptionsRequired = true;\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit LogEmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Sets the rdpx burn percentage\n   * @dev    Can only be called by admin\n   * @param  _rdpxBurnPercentage the burn percentage to set in 1e8 precision\n   **/\n  function setRdpxBurnPercentage(\n    uint256 _rdpxBurnPercentage\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxBurnPercentage > 0, 3);\n    rdpxBurnPercentage = _rdpxBurnPercentage;\n    emit LogSetRdpxBurnPercentage(_rdpxBurnPercentage);\n  }\n\n  /**\n   * @notice Sets the rdpx fee percentage\n   * @dev    Can only be called by admin\n   * @param  _rdpxFeePercentage the fee percentage to set in 1e8 precision\n   **/\n  function setRdpxFeePercentage(\n    uint256 _rdpxFeePercentage\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxFeePercentage > 0, 3);\n    rdpxFeePercentage = _rdpxFeePercentage;\n    emit LogSetRdpxFeePercentage(_rdpxFeePercentage);\n  }\n\n  /**\n   * @notice Sets whether reLP is true or false\n   * @dev    Can only be called by admin\n   * @param  _isReLPActive the value to set\n   */\n  function setIsreLP(bool _isReLPActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    isReLPActive = _isReLPActive;\n    emit LogSetIsReLPActive(_isReLPActive);\n  }\n\n  /**\n   * @notice Sets whether put options are required or not\n   * @dev    Can only be called by admin\n   * @param  _putOptionsRequired the value to set\n   */\n  function setPutOptionsRequired(\n    bool _putOptionsRequired\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    putOptionsRequired = _putOptionsRequired;\n    emit LogSetputOptionsRequired(_putOptionsRequired);\n  }\n\n  /**\n   * @notice Update the bond maturity\n   * @dev    Can only be called by admin\n   * @param  _bondMaturity bond maturity\n   **/\n  function setBondMaturity(\n    uint256 _bondMaturity\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_bondMaturity > 0, 3);\n    bondMaturity = _bondMaturity;\n    emit LogSetBondMaturity(_bondMaturity);\n  }\n\n  /**\n   * @notice Adds a asset to the reserves tokens\n   * @dev    Can only be called by admin\n   **/\n  function addAssetTotokenReserves(\n    address _asset,\n    string memory _assetSymbol\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_asset != address(0), \"RdpxV2Core: asset cannot be 0 address\");\n\n    for (uint256 i = 1; i < reserveAsset.length; i++) {\n      require(\n        reserveAsset[i].tokenAddress != _asset,\n        \"RdpxV2Core: asset already exists\"\n      );\n    }\n\n    ReserveAsset memory asset = ReserveAsset({\n      tokenAddress: _asset,\n      tokenBalance: 0,\n      tokenSymbol: _assetSymbol\n    });\n    reserveAsset.push(asset);\n    reserveTokens.push(_assetSymbol);\n\n    reservesIndex[_assetSymbol] = reserveAsset.length - 1;\n\n    emit LogAssetAddedTotokenReserves(_asset, _assetSymbol);\n  }\n\n  /**\n   * @notice Removes a asset from the reserves tokens\n   * @dev    Can only be called by admin\n   **/\n  function removeAssetFromtokenReserves(\n    string memory _assetSymbol\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 index = reservesIndex[_assetSymbol];\n    _validate(index != 0, 18);\n\n    // remove the asset from the mapping\n    reservesIndex[_assetSymbol] = 0;\n\n    // add new index for the last element\n    reservesIndex[reserveTokens[reserveTokens.length - 1]] = index;\n\n    // update the index of reserveAsset with the last element\n    reserveAsset[index] = reserveAsset[reserveAsset.length - 1];\n\n    // remove the last element\n    reserveAsset.pop();\n    reserveTokens.pop();\n\n    emit LogAssetRemovedFromtokenReserves(_assetSymbol, index);\n  }\n\n  /**\n   * @notice Update contract addresses\n   * @dev    Can only be called by admin\n   * @param  _dopexAMMRouter dopex AMM router address\n   * @param  _dpxEthCurvePool DpxEth curve pool address\n   * @param  _rdpxDecayingBonds rdpx decaying bonds address\n   * @param  _perpetualAtlanticVault perpetual atlantic vault address\n   * @param  _perpetualAtlanticVaultLP perpetual atlantic vault LP address\n   * @param  _rdpxReserve rdpx reserve address\n   * @param  _rdpxV2ReceiptToken rdpxV2ReceiptToken contract address\n   * @param  _feeDistributor fee distributor address\n   **/\n  function setAddresses(\n    address _dopexAMMRouter,\n    address _dpxEthCurvePool,\n    address _rdpxDecayingBonds,\n    address _perpetualAtlanticVault,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxReserve,\n    address _rdpxV2ReceiptToken,\n    address _feeDistributor,\n    address _reLPContract,\n    address _receiptTokenBonds\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_dopexAMMRouter != address(0), 17);\n    _validate(_dpxEthCurvePool != address(0), 17);\n    _validate(_rdpxDecayingBonds != address(0), 17);\n    _validate(_perpetualAtlanticVault != address(0), 17);\n    _validate(_perpetualAtlanticVaultLP != address(0), 17);\n    _validate(_rdpxReserve != address(0), 17);\n    _validate(_rdpxV2ReceiptToken != address(0), 17);\n    _validate(_feeDistributor != address(0), 17);\n    _validate(_reLPContract != address(0), 17);\n    _validate(_receiptTokenBonds != address(0), 17);\n\n    addresses = Addresses({\n      dopexAMMRouter: _dopexAMMRouter,\n      dpxEthCurvePool: _dpxEthCurvePool,\n      rdpxDecayingBonds: _rdpxDecayingBonds,\n      perpetualAtlanticVault: _perpetualAtlanticVault,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxReserve: _rdpxReserve,\n      rdpxV2ReceiptToken: _rdpxV2ReceiptToken,\n      feeDistributor: _feeDistributor,\n      reLPContract: _reLPContract,\n      receiptTokenBonds: _receiptTokenBonds\n    });\n    IERC20WithBurn(weth).approve(\n      addresses.perpetualAtlanticVault,\n      type(uint256).max\n    );\n    IERC20WithBurn(weth).approve(addresses.dopexAMMRouter, type(uint256).max);\n    IERC20WithBurn(weth).approve(addresses.dpxEthCurvePool, type(uint256).max);\n    IERC20WithBurn(weth).approve(\n      addresses.rdpxV2ReceiptToken,\n      type(uint256).max\n    );\n    emit LogSetAddresses(addresses);\n  }\n\n  /**\n   * @notice Update token contract addresses\n   * @dev    Can only be called by admin\n   * @param  _rdpxPriceOracle rdpx price oracle address\n   * @param  _dpxEthPriceOracle DpxEth price oracle address\n   **/\n  function setPricingOracleAddresses(\n    address _rdpxPriceOracle,\n    address _dpxEthPriceOracle\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_rdpxPriceOracle != address(0), 17);\n    _validate(_dpxEthPriceOracle != address(0), 17);\n\n    pricingOracleAddresses = PricingOracleAddresses({\n      rdpxPriceOracle: _rdpxPriceOracle,\n      dpxEthPriceOracle: _dpxEthPriceOracle\n    });\n\n    emit LogSetPricingOracleAddresses(pricingOracleAddresses);\n  }\n\n  /**\n   * @notice Adds a AMO contract to the AMO address array\n   * @dev    Can only be called by admin\n   * @param  _addr the address to add to the AMO address array\n   */\n  function addAMOAddress(address _addr) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_addr != address(0), 17);\n    amoAddresses.push(_addr);\n  }\n\n  /**\n   * @notice Removes a AMO contract from the AMO address array\n   * @dev    Can only be called by admin\n   * @param  _index the index of the address to remove from the AMO address array\n   */\n  function removeAMOAddress(\n    uint256 _index\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_index < amoAddresses.length, 18);\n    amoAddresses[_index] = amoAddresses[amoAddresses.length - 1];\n    amoAddresses.pop();\n  }\n\n  /**\n   * @notice Approve a contract to spend a certain amount of tokens\n   * @dev    Can only be called by admin\n   * @param  _token the address of the token to approve\n   * @param  _spender the address of the contract to approve\n   * @param  _amount the amount to approve\n   */\n  function approveContractToSpend(\n    address _token,\n    address _spender,\n    uint256 _amount\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_token != address(0), 17);\n    _validate(_spender != address(0), 17);\n    _validate(_amount > 0, 17);\n    IERC20WithBurn(_token).approve(_spender, _amount);\n  }\n\n  /**\n   * @notice Adds a contract to the contract whitelist\n   * @dev    Can only be called by admin\n   * @param  _addr the address to add to the contract whitelist\n   **/\n  function addToContractWhitelist(\n    address _addr\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_addr);\n  }\n\n  /**\n   * @notice Removes a contract from the contract whitelist\n   * @dev    Can only be called by admin\n   * @param  _addr the address to remove from the contract whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _addr\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_addr);\n  }\n\n  /**\n   * @notice Set the rDPX LP bond discount factor\n   * @dev    Can only be called by admin\n   * @param  _bondDiscountFactor the bond discount factor\n   **/\n  function setBondDiscount(\n    uint256 _bondDiscountFactor\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_bondDiscountFactor > 0, 3);\n    bondDiscountFactor = _bondDiscountFactor;\n\n    emit LogSetBondDiscountFactor(_bondDiscountFactor);\n  }\n\n  /**\n   * @notice Set the slippage tolerance\n   * @dev    Can only be called by admin\n   * @param  _slippageTolerance the slipage tolerance\n   **/\n  function setSlippageTolerance(\n    uint256 _slippageTolerance\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_slippageTolerance > 0, 3);\n    slippageTolerance = _slippageTolerance;\n\n    emit LogSetSlippageTolerance(_slippageTolerance);\n  }\n\n  // ================================ INTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Purchase rdpx put options\n   * @param _amount amount of rdpx to purchase\n   * @return premium amount of premium paid\n   */\n  function _purchaseOptions(\n    uint256 _amount\n  ) internal returns (uint256 premium) {\n    /**\n     * Purchase options and store ERC721 option id\n     * Note that the amount of options purchased is the amount of rDPX received\n     * from the user to sufficiently collateralize the underlying DpxEth stored in the bond\n     **/\n    uint256 optionId;\n\n    (premium, optionId) = IPerpetualAtlanticVault(\n      addresses.perpetualAtlanticVault\n    ).purchase(_amount, address(this));\n\n    optionsOwned[optionId] = true;\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= premium;\n  }\n\n  /**\n   * @notice issue bonds\n   * @param  _to The address to send the bond to\n   * @param  _amount The bond amount\n   * @return bondId The bond id\n   **/\n  function _issueBond(\n    address _to,\n    uint256 _amount\n  ) internal returns (uint256 bondId) {\n    bondId = RdpxV2Bond(addresses.receiptTokenBonds).mint(_to);\n    bonds[bondId] = Bond({\n      amount: _amount,\n      maturity: block.timestamp + bondMaturity,\n      timestamp: block.timestamp\n    });\n  }\n\n  /**\n   * @notice Swaps _amount of token a to token b\n   * @param _amount amount to swap\n   * @param _ethToDpxEth whether to swap ETH to dpxETH or dpxETH to ETH\n   * @param validate whether to validate the swap\n   * @param minAmount minimum amount of token b to receive\n   * @return amountOut amount of token b received\n   */\n  function _curveSwap(\n    uint256 _amount,\n    bool _ethToDpxEth,\n    bool validate,\n    uint256 minAmount\n  ) internal returns (uint256 amountOut) {\n    IStableSwap dpxEthCurvePool = IStableSwap(addresses.dpxEthCurvePool);\n\n    // First compute a reverse swapping of dpxETH to ETH to compute the amount of ETH required\n    address coin0 = dpxEthCurvePool.coins(0);\n    (uint256 a, uint256 b) = coin0 == weth ? (0, 1) : (1, 0);\n\n    // validate the swap for peg functions\n    if (validate) {\n      uint256 ethBalance = IStableSwap(addresses.dpxEthCurvePool).balances(a);\n      uint256 dpxEthBalance = IStableSwap(addresses.dpxEthCurvePool).balances(\n        b\n      );\n      _ethToDpxEth\n        ? _validate(\n          ethBalance + _amount <= (ethBalance + dpxEthBalance) / 2,\n          14\n        )\n        : _validate(\n          dpxEthBalance + _amount <= (ethBalance + dpxEthBalance) / 2,\n          14\n        );\n    }\n\n    // calculate minimum amount out\n    uint256 minOut = _ethToDpxEth\n      ? (((_amount * getDpxEthPrice()) / 1e8) -\n        (((_amount * getDpxEthPrice()) * slippageTolerance) / 1e16))\n      : (((_amount * getEthPrice()) / 1e8) -\n        (((_amount * getEthPrice()) * slippageTolerance) / 1e16));\n\n    // Swap the tokens\n    amountOut = dpxEthCurvePool.exchange(\n      _ethToDpxEth ? int128(int256(a)) : int128(int256(b)),\n      _ethToDpxEth ? int128(int256(b)) : int128(int256(a)),\n      _amount,\n      minAmount > 0 ? minAmount : minOut\n    );\n  }\n\n  /**\n   * @notice Deposits ETH and dpxETH to the ReceiptToken contract\n   * @param  _to The address to send the bond to\n   * @param  _amount The amount of ETH to add liquidity with\n   * @return receiptTokenAmount The amount of receipt token received\n   **/\n  function _stake(\n    address _to,\n    uint256 _amount\n  ) internal returns (uint256 receiptTokenAmount) {\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= _amount / 2;\n\n    IDpxEthToken(reserveAsset[reservesIndex[\"DPXETH\"]].tokenAddress).mint(\n      address(this),\n      _amount / 2\n    );\n\n    // deposit into the rdpxV2ReceiptToken contract\n    receiptTokenAmount = IRdpxV2ReceiptToken(addresses.rdpxV2ReceiptToken)\n      .deposit(_amount / 2);\n\n    // mint receipt token bonds\n    _issueBond(_to, receiptTokenAmount);\n  }\n\n  /**\n   * @notice Calculate the amounts received by delegate and delegatee after accounting for\n   *         delegate fee.\n   * @dev    Mint receipt tokens based on its respective share with a discount % in 1e8 precision.\n   *         The delegate fee is the percentage of the discount received by the delegatee\n   *         that is cut for them.\n   * @param  _wethRequired The wethRequired to bond\n   * @param  _rdpxRequired The rdpxRequired to bond\n   * @param  _amount The bond amount\n   * @param  _delegateFee The delegate fee\n   * @return amount1 The amount received by the delegate\n   * @return amount2 The amount received by the delegatee\n   **/\n  function _calculateAmounts(\n    uint256 _wethRequired,\n    uint256 _rdpxRequired,\n    uint256 _amount,\n    uint256 _delegateFee\n  ) internal view returns (uint256 amount1, uint256 amount2) {\n    // Commented below for better clarity\n    uint256 rdpxRequiredInWeth = (_rdpxRequired * getRdpxPrice()) / 1e8;\n\n    // amount required for delegatee\n    amount1 = ((rdpxRequiredInWeth * _amount) /\n      (rdpxRequiredInWeth + _wethRequired));\n\n    // account for delegate fee\n    amount1 = (amount1 * (100e8 - _delegateFee)) / 1e10;\n\n    amount2 = _amount - amount1;\n  }\n\n  /**\n   * @notice Transfers rdpx or burns the equivalent in rDPX Decaying bonds\n   * @param  _rdpxAmount The rdpx amount\n   * @param  _wethAmount The weth amount\n   * @param  _bondAmount The bond amount\n   * @param  _bondId The bond id of the rdpx decaying bond\n   **/\n  function _transfer(\n    uint256 _rdpxAmount,\n    uint256 _wethAmount,\n    uint256 _bondAmount,\n    uint256 _bondId\n  ) internal {\n    if (_bondId != 0) {\n      (, uint256 expiry, uint256 amount) = IRdpxDecayingBonds(\n        addresses.rdpxDecayingBonds\n      ).bonds(_bondId);\n\n      _validate(amount >= _rdpxAmount, 1);\n      _validate(expiry >= block.timestamp, 2);\n      _validate(\n        IRdpxDecayingBonds(addresses.rdpxDecayingBonds).ownerOf(_bondId) ==\n          msg.sender,\n        9\n      );\n\n      IRdpxDecayingBonds(addresses.rdpxDecayingBonds).decreaseAmount(\n        _bondId,\n        amount - _rdpxAmount\n      );\n\n      IRdpxReserve(addresses.rdpxReserve).withdraw(_rdpxAmount);\n\n      reserveAsset[reservesIndex[\"RDPX\"]].tokenBalance += _rdpxAmount;\n    } else {\n      // Transfer rDPX and ETH token from user\n      IERC20WithBurn(reserveAsset[reservesIndex[\"RDPX\"]].tokenAddress)\n        .safeTransferFrom(msg.sender, address(this), _rdpxAmount);\n\n      // burn the rdpx\n      IERC20WithBurn(reserveAsset[reservesIndex[\"RDPX\"]].tokenAddress).burn(\n        (_rdpxAmount * rdpxBurnPercentage) / 1e10\n      );\n\n      // transfer the rdpx to the fee distributor\n      IERC20WithBurn(reserveAsset[reservesIndex[\"RDPX\"]].tokenAddress)\n        .safeTransfer(\n          addresses.feeDistributor,\n          (_rdpxAmount * rdpxFeePercentage) / 1e10\n        );\n\n      // calculate extra rdpx to withdraw to compensate for discount\n      uint256 rdpxAmountInWeth = (_rdpxAmount * getRdpxPrice()) / 1e8;\n      uint256 discountReceivedInWeth = _bondAmount -\n        _wethAmount -\n        rdpxAmountInWeth;\n      uint256 extraRdpxToWithdraw = (discountReceivedInWeth * 1e8) /\n        getRdpxPrice();\n\n      // withdraw the rdpx\n      IRdpxReserve(addresses.rdpxReserve).withdraw(\n        _rdpxAmount + extraRdpxToWithdraw\n      );\n\n      reserveAsset[reservesIndex[\"RDPX\"]].tokenBalance +=\n        _rdpxAmount +\n        extraRdpxToWithdraw;\n    }\n  }\n\n  /**\n   * @notice Internal function to bond with delegates\n   * @param  _amount The amount of DpxEth to bond\n   * @param  rdpxBondId The bond id\n   * @param  delegateId The id of the delegate position being used\n   * @return  returnValues {\n    uint256 delegateReceiptTokenAmount;\n    uint256 bondAmountForUser;\n    uint256 rdpxRequired;\n    uint256 wethRequired;\n  }\n   **/\n  function _bondWithDelegate(\n    uint256 _amount,\n    uint256 rdpxBondId,\n    uint256 delegateId\n  ) internal returns (BondWithDelegateReturnValue memory returnValues) {\n    // Compute the bond cost\n    (uint256 rdpxRequired, uint256 wethRequired) = calculateBondCost(\n      _amount,\n      rdpxBondId\n    );\n\n    // update ETH token reserve\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance += wethRequired;\n\n    Delegate storage delegate = delegates[delegateId];\n\n    // update delegate active collateral\n    _validate(delegate.amount - delegate.activeCollateral >= wethRequired, 5);\n    delegate.activeCollateral += wethRequired;\n\n    // update total weth delegated\n    totalWethDelegated -= wethRequired;\n\n    // Calculate the amount of bond token to mint for the delegate and user based on the fee\n    (uint256 amount1, uint256 amount2) = _calculateAmounts(\n      wethRequired,\n      rdpxRequired,\n      _amount,\n      delegate.fee\n    );\n\n    // update user amounts\n    // ETH token amount remaining after LP for the user\n    uint256 bondAmountForUser = amount1;\n\n    // Mint bond token for delegate\n    // ETH token amount remaining after LP for the delegate\n    uint256 delegateReceiptTokenAmount = _stake(delegate.owner, amount2);\n\n    returnValues = BondWithDelegateReturnValue(\n      delegateReceiptTokenAmount,\n      bondAmountForUser,\n      rdpxRequired,\n      wethRequired\n    );\n  }\n\n  /**\n   * @dev    Internal function to validate checks\n   * @param  _clause the boolean clause to validate\n   * @param  _errorCode error code for error mapping below\n   **/\n  function _validate(bool _clause, uint256 _errorCode) internal pure {\n    if (!_clause) revert RdpxV2CoreError(_errorCode);\n  }\n\n  // ================================ CORE ================================ //\n\n  /**\n   * @notice Settles the options\n   * @dev    Can only be called by admin\n   * @param  optionIds the ids of the option to be settled\n   * @return amountOfWeth the amount of eth received\n   * @return rdpxAmount the amount of rdpx sent out\n   */\n  function settle(\n    uint256[] memory optionIds\n  )\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 amountOfWeth, uint256 rdpxAmount)\n  {\n    _whenNotPaused();\n    (amountOfWeth, rdpxAmount) = IPerpetualAtlanticVault(\n      addresses.perpetualAtlanticVault\n    ).settle(optionIds);\n    for (uint256 i = 0; i < optionIds.length; i++) {\n      optionsOwned[optionIds[i]] = false;\n    }\n\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance += amountOfWeth;\n    reserveAsset[reservesIndex[\"RDPX\"]].tokenBalance -= rdpxAmount;\n\n    emit LogSettle(optionIds);\n  }\n\n  /**\n   * @notice Calculates and sends the funding amount to the vault\n   * @dev    Can only be called by admin\n   * @return fundingAmount the amount of funding paid\n   **/\n  function provideFunding()\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    returns (uint256 fundingAmount)\n  {\n    _whenNotPaused();\n    uint256 pointer = IPerpetualAtlanticVault(addresses.perpetualAtlanticVault)\n      .latestFundingPaymentPointer();\n    _validate(fundingPaidFor[pointer] == false, 16);\n\n    fundingAmount = IPerpetualAtlanticVault(addresses.perpetualAtlanticVault)\n      .payFunding();\n\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance -= fundingAmount;\n\n    fundingPaidFor[pointer] = true;\n\n    emit LogProvideFunding(pointer, fundingAmount);\n  }\n\n  /**\n   * @notice The Bonding function to bond with delegates\n   * @param  _to The address to send the bond to\n   * @param  _amounts The amounts of DpxEth to lock in the bond\n   * @param  _delegateIds the id of the delegate position's being used\n   * @param  rdpxBondId The bond id\n   * @return receiptTokenAmount The amount of receipt tokens recieved\n   * @return delegateTokenAmounts The amount of receipt tokens recieved for each delegate\n   **/\n  function bondWithDelegate(\n    address _to,\n    uint256[] memory _amounts,\n    uint256[] memory _delegateIds,\n    uint256 rdpxBondId\n  ) public returns (uint256 receiptTokenAmount, uint256[] memory) {\n    _whenNotPaused();\n    // Validate amount\n    _validate(_amounts.length == _delegateIds.length, 3);\n\n    uint256 userTotalBondAmount;\n    uint256 totalBondAmount;\n\n    uint256[] memory delegateReceiptTokenAmounts = new uint256[](\n      _amounts.length\n    );\n\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      // Validate amount\n      _validate(_amounts[i] > 0, 4);\n\n      BondWithDelegateReturnValue\n        memory returnValues = BondWithDelegateReturnValue(0, 0, 0, 0);\n\n      returnValues = _bondWithDelegate(\n        _amounts[i],\n        rdpxBondId,\n        _delegateIds[i]\n      );\n\n      delegateReceiptTokenAmounts[i] = returnValues.delegateReceiptTokenAmount;\n\n      userTotalBondAmount += returnValues.bondAmountForUser;\n      totalBondAmount += _amounts[i];\n\n      // purchase options\n      uint256 premium;\n      if (putOptionsRequired) {\n        premium = _purchaseOptions(returnValues.rdpxRequired);\n      }\n\n      // transfer the required rdpx\n      _transfer(\n        returnValues.rdpxRequired,\n        returnValues.wethRequired - premium,\n        _amounts[i],\n        rdpxBondId\n      );\n    }\n\n    // Mint bond token for user\n    receiptTokenAmount = _stake(_to, userTotalBondAmount);\n\n    // reLP\n    if (isReLPActive) IReLP(addresses.reLPContract).reLP(totalBondAmount);\n\n    emit LogBondWithDelegate(\n      _to,\n      _delegateIds,\n      _amounts,\n      rdpxBondId,\n      receiptTokenAmount,\n      delegateReceiptTokenAmounts\n    );\n\n    return (receiptTokenAmount, delegateReceiptTokenAmounts);\n  }\n\n  /**\n   * @notice The primary bonding function\n   * @param  _amount The amount of DpxEth to bond for\n   * @param  rdpxBondId The bond id\n   * @param  _to The address to send the bond to\n   * @return receiptTokenAmount the amount of receipt tokens received\n   **/\n  function bond(\n    uint256 _amount,\n    uint256 rdpxBondId,\n    address _to\n  ) public returns (uint256 receiptTokenAmount) {\n    _whenNotPaused();\n    // Validate amount\n    _validate(_amount > 0, 4);\n\n    // Compute the bond cost\n    (uint256 rdpxRequired, uint256 wethRequired) = calculateBondCost(\n      _amount,\n      rdpxBondId\n    );\n\n    IERC20WithBurn(weth).safeTransferFrom(\n      msg.sender,\n      address(this),\n      wethRequired\n    );\n\n    // update weth reserve\n    reserveAsset[reservesIndex[\"WETH\"]].tokenBalance += wethRequired;\n\n    // purchase options\n    uint256 premium;\n    if (putOptionsRequired) {\n      premium = _purchaseOptions(rdpxRequired);\n    }\n\n    _transfer(rdpxRequired, wethRequired - premium, _amount, rdpxBondId);\n\n    // Stake the ETH in the ReceiptToken contract\n    receiptTokenAmount = _stake(_to, _amount);\n\n    // reLP\n    if (isReLPActive) IReLP(addresses.reLPContract).reLP(_amount);\n\n    emit LogBond(rdpxRequired, wethRequired, receiptTokenAmount);\n  }\n\n  /**\n   * @notice Lets users delegate WETH\n   * @param  _amount The amount of WETH to delegate\n   * @param  _fee The fee to charge for the delegated WETH\n   * @return uint256 the ID of the delegate\n   **/\n  function addToDelegate(\n    uint256 _amount,\n    uint256 _fee\n  ) external returns (uint256) {\n    _whenNotPaused();\n    // fee less than 100%\n    _validate(_fee < 100e8, 8);\n    // amount greater than 0.01 WETH\n    _validate(_amount > 1e16, 4);\n    // fee greater than 1%\n    _validate(_fee >= 1e8, 8);\n\n    IERC20WithBurn(weth).safeTransferFrom(msg.sender, address(this), _amount);\n\n    Delegate memory delegatePosition = Delegate({\n      amount: _amount,\n      fee: _fee,\n      owner: msg.sender,\n      activeCollateral: 0\n    });\n    delegates.push(delegatePosition);\n\n    // add amount to total weth delegated\n    totalWethDelegated += _amount;\n\n    emit LogAddToDelegate(_amount, _fee, delegates.length - 1);\n    return (delegates.length - 1);\n  }\n\n  /**\n   * @notice Lets the delegate withdraw unused WETH\n   * @param  delegateId The ID of the delegate\n   * @return amountWithdrawn The amount of WETH withdrawn\n   **/\n  function withdraw(\n    uint256 delegateId\n  ) external returns (uint256 amountWithdrawn) {\n    _whenNotPaused();\n    _validate(delegateId < delegates.length, 14);\n    Delegate storage delegate = delegates[delegateId];\n    _validate(delegate.owner == msg.sender, 9);\n\n    amountWithdrawn = delegate.amount - delegate.activeCollateral;\n    _validate(amountWithdrawn > 0, 15);\n    delegate.amount = delegate.activeCollateral;\n\n    IERC20WithBurn(weth).safeTransfer(msg.sender, amountWithdrawn);\n\n    emit LogDelegateWithdraw(delegateId, amountWithdrawn);\n  }\n\n  /**\n   * @notice Syncs asset reserves with contract balances\n   **/\n  function sync() external {\n    for (uint256 i = 1; i < reserveAsset.length; i++) {\n      uint256 balance = IERC20WithBurn(reserveAsset[i].tokenAddress).balanceOf(\n        address(this)\n      );\n\n      if (weth == reserveAsset[i].tokenAddress) {\n        balance = balance - totalWethDelegated;\n      }\n      reserveAsset[i].tokenBalance = balance;\n    }\n\n    emit LogSync();\n  }\n\n   /**\n   * @notice Withdraws DSC from a matured bond\n   * @param  id bond ID\n   * @param  to the address to send the DSC too\n   * @return receiptTokenAmount the amount of receipt Tokens to transfer\n   **/\n  function redeem(\n    uint256 id,\n    address to\n  ) external returns (uint256 receiptTokenAmount) {\n    // Validate bond ID\n    _validate(bonds[id].timestamp > 0, 6);\n    // Validate if bond has matured\n    _validate(block.timestamp > bonds[id].maturity, 7);\n\n    _validate(\n      msg.sender == RdpxV2Bond(addresses.receiptTokenBonds).ownerOf(id),\n      9\n    );\n\n    // Burn the bond token\n    // Note requires an approval of the bond token to this contract\n    RdpxV2Bond(addresses.receiptTokenBonds).burn(id);\n\n    // transfer receipt tokens to user\n    receiptTokenAmount = bonds[id].amount;\n    IERC20WithBurn(addresses.rdpxV2ReceiptToken).safeTransfer(\n      to,\n      receiptTokenAmount\n    );\n\n    emit LogRedeem(to, receiptTokenAmount);\n  }\n\n  // ================================ REPEG FUNCTIONS =========================="
    }
  ]
}