{
  "Title": "[M-02] Tokens yeild can not be set to claimable.",
  "Content": "\nThe enabling of yeild on rebasing tokens can be permanently DOS-ed.\n\n### Proof of Concept\n\nAbracadabra uses this signature for the configure function for the rebasing function of WETH and USDB\n\n```solidity\nfunction configure(YieldMode) external returns (YieldMode);\n```\n\nBut the actual signature for this is:\n\n```solidity\nfunction configure(YieldMode yieldMode) external returns (uint256)\n```\n\nAnd it returns the balance of caller\n\n<https://github.com/blast-io/blast/blob/c39cdf1fa7ef9e0d4eaf64a7a5cf7b3c46c739fd/blast-optimism/packages/contracts-bedrock/src/L2/ERC20Rebasing.sol#L220C2-L226>\n\nSo if the balance of contract is above 2, this function becomes unusable and can't configure the yeild to be claimable.\n\nThe following function always fails:\n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/blast/libraries/BlastYields.sol#L20-L27>\n\nThis can be exploited by attacker by donating a very little amount of eth to the magicLP, blastOnBoarding and now the blastOnBoarding can't make yeild claimable when the following function is invoked.\n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/blast/BlastOnboarding.sol#L175C14-L183>\n\n### Recommended Mitigation Steps\n\nUse the correct signature used in blast codebase.\n\n**[0xCalibur (Abracadabra) confirmed and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/236#issuecomment-1997742323):**\n > This is a valid report. We already fixed it before the audit ended.\n> \n> The fix is here in IBlast.sol:\n> \n> https://github.com/Abracadabra-money/abracadabra-money-contracts/commit/12f07da03c0adaff123d7e6c684b757855521d61#diff-8f7d8246c1e6d7928012209792b0b3f0a9684a94a40bd802e2b22e5032db04bc\n> \n> Also fixed in the BlastMock.sol file.\n\n**[cccz (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/236#issuecomment-2025611151):**\n > Downgrade to M because the problematic function will be called when deployed. An attacker can just exploit it to prevent the contract from being deployed.\n> And if the attacker wants to exploit it after the contract is deployed, since the mode is fixed to YieldMode.CLAIMABLE, it will just return even if it is called again by the Owner.\n>\n> ```solidity\n>     function enableTokenClaimable(address token) internal {\n>         if (IERC20Rebasing(token).getConfiguration(address(this)) == YieldMode.CLAIMABLE) {\n>             return;\n>         }\n> ```\n>\n > This is the deployment script for blastOnboarding.sol, which shows that setTokenSupported will be called immediately after deployment.\n>\n> ```solidity\n> contract BlastOnboardingScript is BaseScript {\n>     function deploy() public returns (BlastOnboarding onboarding) {\n>         address owner = toolkit.getAddress(block.chainid, \"safe.ops\");\n>         address feeTo = toolkit.getAddress(block.chainid, \"safe.ops\");\n>         address blastGovernor = toolkit.getAddress(block.chainid, \"blastGovernor\");\n>         address blastTokenRegistry = toolkit.getAddress(block.chainid, \"blastTokenRegistry\");\n> \n>         vm.startBroadcast();\n> \n>         onboarding = BlastOnboarding(\n>             payable(deploy(\"Onboarding\", \"BlastOnboarding.sol:BlastOnboarding\", abi.encode(blastTokenRegistry, feeTo, tx.origin)))\n>         );\n> \n>         if (!testing()) {\n>             address usdb = toolkit.getAddress(block.chainid, \"usdb\");\n>             address mim = toolkit.getAddress(block.chainid, \"mim\");\n>             if (!onboarding.supportedTokens(usdb)) {\n>                 onboarding.setTokenSupported(usdb, true);\n>             }\n>             if (!onboarding.supportedTokens(mim)) {\n>                 onboarding.setTokenSupported(mim, true);\n>             }\n>             if (onboarding.owner() != owner) {\n>                 onboarding.transferOwnership(owner);\n>             }\n>         }\n> \n>         vm.stopBroadcast();\n>     }\n> }\n> ```\n>\n> Also, even without the deployment script, I think this is a DOS of M severity and there is no loss of funds because the user cannot deposit tokens until setTokenSupported is called.\n\n_Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/236)._\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "blast-optimism/packages/contracts-bedrock/src/L2/ERC20Rebasing.sol",
      "content": "// SPDX-License-Identifier: BSL 1.1 - Copyright 2024 MetaLayer Labs Ltd.\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nimport { SharesBase } from \"src/L2/Shares.sol\";\nimport { YieldMode } from \"src/L2/Blast.sol\";\nimport { ERC20PermitUpgradeable } from \"src/L2/ERC20PermitUpgradeable.sol\";\n\n/// @custom:upgradeable\n/// @title ERC20Rebasing\n/// @notice ERC20 implementation with rebasing token balances. There are 3 yield\n/// modes with different rebasing behaviors.\n///\n/// AUTOMATIC dynamically updates the balance as the share price increases.\n///\n/// VOID fixes the balance and exempts the account from receiving yields.\n///\n/// CLAIMABLE fixes the balance and allows the account to claim yields to\n/// another account.\n///\n/// The child implementation is responsible for deciding how the share price is set.\nabstract contract ERC20Rebasing is ERC20PermitUpgradeable, SharesBase, IERC20 {\n    /// @notice Number of decimals.\n    uint8 public immutable decimals;\n\n    /// @notice Name of the token.\n    string public name;\n    /// @notice Symbol of the token.\n    string public symbol;\n\n    /// @notice Mapping that stores the number of shares for each account.\n    mapping(address => uint256) private _shares;\n\n    /// @notice Total number of shares distributed.\n    uint256 internal _totalShares;\n\n    /// @notice Mapping that stores the number of remainder tokens for each account.\n    mapping(address => uint256) private _remainders;\n\n    /// @notice Mapping that stores the number of fixed tokens for each account.\n    mapping(address => uint256) private _fixed;\n\n    /// @notice Total number of non-rebasing tokens.\n    uint256 internal _totalVoidAndRemainders;\n\n    /// @notice Mapping that stores the configured yield mode for each account.\n    mapping(address => YieldMode) private _yieldMode;\n\n    /// @notice Mapping that stores the allowance for a given spender and operator pair.\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /// @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n    ///         A gap size of 41 was chosen here, so that the first slot used in a child contract\n    ///         would be a multiple of 50.\n    uint256[41] private __gap;\n\n    /// @notice Emitted when an account configures their yield mode.\n    /// @param account   Address of the account.\n    /// @param yieldMode Yield mode that was configured.\n    event Configure(address indexed account, YieldMode yieldMode);\n\n    /// @notice Emitted when a CLAIMABLE account claims their yield.\n    /// @param account   Address of the account.\n    /// @param recipient Address of the recipient.\n    /// @param amount    Amount of yield claimed.\n    event Claim(address indexed account, address indexed recipient, uint256 amount);\n\n    error InsufficientBalance();\n    error InsufficientAllowance();\n    error TransferFromZeroAddress();\n    error TransferToZeroAddress();\n    error ApproveFromZeroAddress();\n    error ApproveToZeroAddress();\n    error ClaimToZeroAddress();\n    error NotClaimableAccount();\n\n    /// @param _decimals Number of decimals.\n    constructor(address _reporter, uint8 _decimals) SharesBase(_reporter) {\n        decimals = _decimals;\n    }\n\n    /// @param _name     Token name.\n    /// @param _symbol   Token symbol.\n    /// @param _price    Initial share price.\n    function __ERC20Rebasing_init(string memory _name, string memory _symbol, uint256 _price) internal onlyInitializing {\n        __ERC20Permit_init(_name);\n        __SharesBase_init({ _price: _price });\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /// @inheritdoc SharesBase\n    function count() public view override returns (uint256) {\n        return _totalShares;\n    }\n\n    /// @notice --- ERC20 Interface ---\n\n    /// @inheritdoc IERC20\n    function totalSupply() external view returns (uint256) {\n        return price * _totalShares + _totalVoidAndRemainders;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        returns (uint256 value)\n    {\n        YieldMode yieldMode = _yieldMode[account];\n        if (yieldMode == YieldMode.AUTOMATIC) {\n            value = _computeShareValue(_shares[account], _remainders[account]);\n        } else {\n            value = _fixed[account];\n        }\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /// @inheritdoc IERC20\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        address owner = msg.sender;\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice --- Blast Interface ---\n\n    /// @notice Query an account's configured yield mode.\n    /// @param account Address to query the configuration.\n    /// @return Configured yield mode.\n    function getConfiguration(address account) public view returns (YieldMode) {\n        return _yieldMode[account];\n    }\n\n    /// @notice Query an CLAIMABLE account's claimable yield.\n    /// @param account Address to query the claimable amount.\n    /// @return amount Claimable amount.\n    function getClaimableAmount(address account) public view returns (uint256) {\n        if (getConfiguration(account) != YieldMode.CLAIMABLE) {\n            revert NotClaimableAccount();\n        }\n\n        uint256 shareValue = _computeShareValue(_shares[account], _remainders[account]);\n        return shareValue - _fixed[account];\n    }\n\n    /// @notice Claim yield from a CLAIMABLE account and send to\n    ///         a recipient.\n    /// @param recipient Address to receive the claimed balance.\n    /// @param amount    Amount to claim.\n    /// @return Amount claimed.\n    function claim(address recipient, uint256 amount) external returns (uint256) {\n        address account = msg.sender;\n        if (recipient == address(0)) {\n            revert ClaimToZeroAddress();\n        }\n\n        if (getConfiguration(account) != YieldMode.CLAIMABLE) {\n            revert NotClaimableAccount();\n        }\n\n        uint256 shareValue = _computeShareValue(_shares[account], _remainders[account]);\n\n        uint256 claimableAmount = shareValue - _fixed[account];\n        if (amount > claimableAmount) {\n            revert InsufficientBalance();\n        }\n\n        (uint256 newShares, uint256 newRemainder) = _computeSharesAndRemainder(shareValue - amount);\n\n        _updateBalance(account, newShares, newRemainder, _fixed[account]);\n        _deposit(recipient, amount);\n\n        emit Claim(msg.sender, recipient, amount);\n\n        return amount;\n    }\n\n    /// @notice Change the yield mode of the caller and update the\n    ///         balance to reflect the configuration.\n    /// @param yieldMode Yield mode to configure\n    /// @return Current user balance\n    function configure(YieldMode yieldMode) external returns (uint256) {\n        _configure(msg.sender, yieldMode);\n\n        emit Configure(msg.sender, yieldMode);\n\n        return balanceOf(msg.sender);\n    }\n\n    /// @notice Moves `amount` of tokens from `from` to `to`.\n    /// @param from   Address of the sender.\n    /// @param to     Address of the recipient.\n    /// @param amount Amount of tokens to send.\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (from == address(0)) revert TransferFromZeroAddress();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _withdraw(from, amount);\n        _deposit(to, amount);\n\n        emit Transfer(from, to, amount);\n    }\n\n    /// @notice Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n    /// @param owner   Address of the owner.\n    /// @param spender Address of the spender.\n    /// @param amount  Amount of tokens to approve.\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal override {\n        if (owner == address(0)) revert ApproveFromZeroAddress();\n        if (spender == address(0)) revert ApproveToZeroAddress();\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /// @notice Updates `owner` s allowance for `spender` based on spent `amount`.\n    /// @param owner   Address of the owner.\n    /// @param spender Address of the spender.\n    /// @param amount  Amount of tokens to spender.\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (amount > currentAllowance) revert InsufficientAllowance();\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /// @notice Deposit to an account.\n    /// @param account Address of the account to deposit to.\n    /// @param amount  Amount to deposit to the account.\n    function _deposit(address account, uint256 amount) internal {\n        uint256 balanceAfter = balanceOf(account) + amount;\n        _setBalance(account, balanceAfter, false);\n\n        /// If the user is configured as VOID, then the amount\n        /// is added to the total voided funds.\n        YieldMode yieldMode = getConfiguration(account);\n        if (yieldMode == YieldMode.VOID) {\n            _totalVoidAndRemainders += amount;\n        }\n    }\n\n    /// @notice Withdraw from an account.\n    /// @param account Address of the account to withdraw from.\n    /// @param amount  Amount to withdraw to the account.\n    function _withdraw(address account, uint256 amount) internal {\n        uint256 balance = balanceOf(account);\n        if (amount > balance) {\n            revert InsufficientBalance();\n        }\n\n        unchecked {\n            _setBalance(account, balance - amount, false);\n        }\n\n        /// If the user is configured as VOID, then the amount\n        /// is deducted from the total voided funds.\n        YieldMode yieldMode = getConfiguration(account);\n        if (yieldMode == YieldMode.VOID) {\n            _totalVoidAndRemainders -= amount;\n        }\n    }\n\n    /// @notice Configures a new yield mode for an account and updates\n    ///         the balance storage to reflect the change.\n    /// @param account      Address of the account to configure.\n    /// @param newYieldMode New yield mode to configure.\n    function _configure(address account, YieldMode newYieldMode) internal {\n        YieldMode prevYieldMode = getConfiguration(account);\n\n        uint256 balance;\n        if (prevYieldMode == YieldMode.CLAIMABLE) {\n            /// If the balance is claimable, we need to use their share balance so they\n            /// don't lose their claimable yield.\n            balance = _computeShareValue(_shares[account], _remainders[account]);\n        } else {\n            balance = balanceOf(account);\n        }\n\n        _yieldMode[account] = newYieldMode;\n\n        uint256 prevFixed = _fixed[account];\n\n        _setBalance(account, balance, true);\n\n        /// If the previous yield mode was VOID, then the amount\n        /// is deducted from the total voided funds.\n        if (prevYieldMode == YieldMode.VOID) {\n            _totalVoidAndRemainders -= prevFixed;\n        }\n\n        /// If the new yield mode is VOID, then the amount\n        /// is added to the total voided funds.\n        if (newYieldMode == YieldMode.VOID) {\n            _totalVoidAndRemainders += balance;\n        }\n    }\n\n    /// @notice Sets the balance of an account according to its yield mode\n    ///         configuration.\n    /// @param account           Address of the account to set the balance of.\n    /// @param amount            Balance to set for the account.\n    /// @param resetClaimable    If the account is CLAIMABLE, true if the share\n    ///                          balance should be set to the amount. Should only be true when\n    ///                          configuring the account.\n    function _setBalance(address account, uint256 amount, bool resetClaimable) internal {\n        uint256 newShares; uint256 newRemainder; uint256 newFixed;\n        YieldMode yieldMode = getConfiguration(account);\n        if (yieldMode == YieldMode.AUTOMATIC) {\n            (newShares, newRemainder) = _computeSharesAndRemainder(amount);\n        } else if (yieldMode == YieldMode.VOID) {\n            newFixed = amount;\n        } else if (yieldMode == YieldMode.CLAIMABLE) {\n            newFixed = amount;\n            uint256 shareValue = amount;\n            if (!resetClaimable) {\n                /// In order to not reset the claimable balance, we have to compute\n                /// the user's current share balance and add or subtract the change in\n                /// fixed balance before computing the new shares balance parameters.\n                shareValue = _computeShareValue(_shares[account], _remainders[account]);\n                shareValue = shareValue + amount - _fixed[account];\n            }\n            (newShares, newRemainder) = _computeSharesAndRemainder(shareValue);\n        }\n\n        _updateBalance(account, newShares, newRemainder, newFixed);\n    }\n\n    /// @notice Update the balance parameters of an account and appropriately refresh the global sums\n    ///         to reflect the change of allocation.\n    /// @param account      Address of account to update.\n    /// @param newShares    New shares value for account.\n    /// @param newRemainder New remainder value for account.\n    /// @param newFixed     New fixed value for account.\n    function _updateBalance(address account, uint256 newShares, uint256 newRemainder, uint256 newFixed) internal {\n        _totalShares = _totalShares + newShares - _shares[account];\n        _totalVoidAndRemainders = _totalVoidAndRemainders + newRemainder - _remainders[account];\n\n        _shares[account] = newShares;\n        _remainders[account] = newRemainder;\n        _fixed[account] = newFixed;\n    }\n\n    /// @notice Convert nominal value to number of shares with remainder.\n    /// @param value Amount to convert to shares (wad).\n    /// @return shares Number of shares (wad), remainder Remainder (wad).\n    function _computeSharesAndRemainder(uint256 value) internal view returns (uint256 shares, uint256 remainder) {\n        if (price == 0) {\n            remainder = value;\n        } else {\n            shares = value / price;\n            remainder = value % price;\n        }\n    }\n\n    /// @notice Compute nominal value from number of shares.\n    /// @param shares     Number of shares (wad).\n    /// @param remainders Amount of remainder (wad).\n    /// @return value (wad).\n    function _computeShareValue(uint256 shares, uint256 remainders) internal view returns (uint256) {\n        return price * shares + remainders;\n    }\n}"
    },
    {
      "filename": "src/blast/libraries/BlastYields.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {IBlast, IERC20Rebasing, YieldMode, GasMode} from \"interfaces/IBlast.sol\";\nimport {Address} from \"openzeppelin-contracts/utils/Address.sol\";\n\nlibrary BlastYields {\n    event LogBlastGasClaimed(address indexed recipient, uint256 amount);\n    event LogBlastETHClaimed(address indexed recipient, uint256 amount);\n    event LogBlastTokenClaimed(address indexed recipient, address indexed token, uint256 amount);\n    event LogBlastTokenClaimableEnabled(address indexed contractAddress, address indexed token);\n    event LogBlastNativeClaimableEnabled(address indexed contractAddress);\n\n    IBlast constant BLAST_YIELD_PRECOMPILE = IBlast(0x4300000000000000000000000000000000000002);\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    // CONFIGURATION\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function enableTokenClaimable(address token) internal {\n        if (IERC20Rebasing(token).getConfiguration(address(this)) == YieldMode.CLAIMABLE) {\n            return;\n        }\n\n        IERC20Rebasing(token).configure(YieldMode.CLAIMABLE);\n        emit LogBlastTokenClaimableEnabled(address(this), token);\n    }\n\n    function configureDefaultClaimables(address governor_) internal {\n        BLAST_YIELD_PRECOMPILE.configure(YieldMode.CLAIMABLE, GasMode.CLAIMABLE, governor_);\n        emit LogBlastNativeClaimableEnabled(address(this));\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    // GAS CLAIMING\n    //////////////////////////////////////////////////////////////////////////////////////\n    \n    function claimMaxGasYields(address recipient) internal returns (uint256) {\n        return claimMaxGasYields(address(this), recipient);\n    }\n\n    function claimMaxGasYields(address contractAddress, address recipient) internal returns (uint256 amount) {\n        amount = BLAST_YIELD_PRECOMPILE.claimMaxGas(contractAddress, recipient);\n        emit LogBlastGasClaimed(recipient, amount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    // NATIVE CLAIMING\n    //////////////////////////////////////////////////////////////////////////////////////<\n\n    function claimAllNativeYields(address recipient) internal returns (uint256 amount) {\n        return claimAllNativeYields(address(this), recipient);\n    }\n\n    function claimAllNativeYields(address contractAddress, address recipient) internal returns (uint256 amount) {\n        amount = BLAST_YIELD_PRECOMPILE.claimAllYield(contractAddress, recipient);\n        emit LogBlastETHClaimed(recipient, amount);\n    }\n\n    function claimNativeYields(address contractAddress, uint256 amount, address recipient) internal returns (uint256) {\n        amount = BLAST_YIELD_PRECOMPILE.claimYield(contractAddress, recipient, amount);\n        emit LogBlastETHClaimed(recipient, amount);\n        return amount;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    // TOKENS CLAIMING\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function claimAllTokenYields(address token, address recipient) internal returns (uint256 amount) {\n        amount = IERC20Rebasing(token).claim(recipient, IERC20Rebasing(token).getClaimableAmount(address(this)));\n        emit LogBlastTokenClaimed(recipient, address(token), amount);\n    }\n\n    function claimTokenYields(address token, uint256 amount, address recipient) internal returns (uint256) {\n        amount = IERC20Rebasing(token).claim(recipient, amount);\n        emit LogBlastTokenClaimed(recipient, address(token), amount);\n        return amount;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    // ARBITRARY PRECOMPILE CALLS\n    // Meant to be used for any other calls to the precompile not covered by the above\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function callPrecompile(bytes calldata data) internal {\n        Address.functionCall(address(BLAST_YIELD_PRECOMPILE), data);\n    }\n}"
    },
    {
      "filename": "src/blast/BlastOnboarding.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {BlastYields} from \"/blast/libraries/BlastYields.sol\";\nimport {BlastTokenRegistry} from \"/blast/BlastTokenRegistry.sol\";\nimport {Proxy} from \"openzeppelin-contracts/proxy/Proxy.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {BlastPoints} from \"/blast/libraries/BlastPoints.sol\";\nimport {Pausable} from \"openzeppelin-contracts/security/Pausable.sol\";\n\ncontract BlastOnboardingData is Owned, Pausable {\n    error ErrZeroAddress();\n    error ErrWrongState();\n    error ErrUnsupportedToken();\n    error ErrNotAllowed();\n\n    enum State {\n        Idle,\n        Opened,\n        Closed\n    }\n\n    struct Balances {\n        uint256 unlocked;\n        uint256 locked;\n        uint256 total;\n    }\n\n    State public state;\n    address public bootstrapper;\n    address public feeTo;\n    BlastTokenRegistry public registry;\n\n    // Global\n    mapping(address token => bool) public supportedTokens;\n    mapping(address token => Balances) public totals;\n    mapping(address token => uint256 cap) public caps;\n\n    // Per-user\n    mapping(address user => mapping(address token => Balances)) public balances;\n\n    modifier onlyState(State _state) {\n        if (state != _state) {\n            revert ErrWrongState();\n        }\n        _;\n    }\n\n    modifier onlySupportedTokens(address token) {\n        if (!supportedTokens[token]) {\n            revert ErrUnsupportedToken();\n        }\n\n        _;\n    }\n\n    constructor() Owned(msg.sender) {\n        BlastYields.configureDefaultClaimables(address(this));\n        BlastPoints.configure();\n    }\n}\n\ncontract BlastOnboarding is BlastOnboardingData, Proxy {\n    using SafeTransferLib for address;\n\n    event LogBootstrapperChanged(address indexed bootstrapper);\n    event LogTokenSupported(address indexed token, bool supported);\n    event LogDeposit(address indexed user, address indexed token, uint256 amount, bool lock);\n    event LogLock(address indexed user, address indexed token, uint256 amount);\n    event LogFeeToChanged(address indexed feeTo);\n    event LogWithdraw(address indexed user, address indexed token, uint256 amount);\n    event LogTokenCapChanged(address indexed token, uint256 cap);\n    event LogStateChange(State state);\n    event LogTokenRescue(address indexed token, address indexed to, uint256 amount);\n\n    error ErrUnsupported();\n    error ErrCapReached();\n\n    receive() external payable override {\n        revert ErrUnsupported();\n    }\n\n    constructor(BlastTokenRegistry registry_, address feeTo_) {\n        if (address(registry_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        if (feeTo_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        registry = registry_;\n        feeTo = feeTo_;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function deposit(address token, uint256 amount, bool lock_) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (lock_) {\n            totals[token].locked += amount;\n            balances[msg.sender][token].locked += amount;\n        } else {\n            totals[token].unlocked += amount;\n            balances[msg.sender][token].unlocked += amount;\n        }\n\n        totals[token].total += amount;\n\n        if (caps[token] > 0 && totals[token].total > caps[token]) {\n            revert ErrCapReached();\n        }\n\n        balances[msg.sender][token].total += amount;\n\n        emit LogDeposit(msg.sender, token, amount, lock_);\n    }\n\n    function lock(address token, uint256 amount) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        balances[msg.sender][token].unlocked -= amount;\n        balances[msg.sender][token].locked += amount;\n        totals[token].unlocked -= amount;\n        totals[token].locked += amount;\n\n        emit LogLock(msg.sender, token, amount);\n    }\n\n    function withdraw(address token, uint256 amount) external whenNotPaused onlySupportedTokens(token) {\n        balances[msg.sender][token].unlocked -= amount;\n        balances[msg.sender][token].total -= amount;\n        totals[token].unlocked -= amount;\n        totals[token].total -= amount;\n\n        token.safeTransfer(msg.sender, amount);\n\n        emit LogWithdraw(msg.sender, token, amount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setFeeTo(address feeTo_) external onlyOwner {\n        if (feeTo_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        feeTo = feeTo_;\n        emit LogFeeToChanged(feeTo_);\n    }\n\n    function callBlastPrecompile(bytes calldata data) external onlyOwner {\n        BlastYields.callPrecompile(data);\n    }\n\n    function claimGasYields() external onlyOwner returns (uint256) {\n        return BlastYields.claimMaxGasYields(feeTo);\n    }\n\n    function claimTokenYields(address[] memory tokens) external onlyOwner {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (!supportedTokens[tokens[i]]) {\n                revert ErrUnsupportedToken();\n            }\n            if (registry.nativeYieldTokens(tokens[i])) {\n                BlastYields.claimAllTokenYields(tokens[i], feeTo);\n            }\n        }\n    }\n\n    function setTokenSupported(address token, bool supported) external onlyOwner {\n        supportedTokens[token] = supported;\n\n        if (registry.nativeYieldTokens(token)) {\n            BlastYields.enableTokenClaimable(token);\n        }\n\n        emit LogTokenSupported(token, supported);\n    }\n\n    function setCap(address token, uint256 cap) external onlyOwner onlySupportedTokens(token) {\n        caps[token] = cap;\n        emit LogTokenCapChanged(token, cap);\n    }\n\n    function setBootstrapper(address bootstrapper_) external onlyOwner {\n        bootstrapper = bootstrapper_;\n        emit LogBootstrapperChanged(bootstrapper_);\n    }\n\n    function open() external onlyOwner onlyState(State.Idle) {\n        state = State.Opened;\n        emit LogStateChange(State.Opened);\n    }\n\n    function close() external onlyOwner onlyState(State.Opened) {\n        state = State.Closed;\n        emit LogStateChange(State.Closed);\n    }\n\n    function rescue(address token, address to, uint256 amount) external onlyOwner {\n        if (supportedTokens[token]) {\n            revert ErrNotAllowed();\n        }\n\n        token.safeTransfer(to, amount);\n        emit LogTokenRescue(token, to, amount);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PROXY IMPLEMENTATION\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _implementation() internal view override returns (address) {\n        return address(bootstrapper);\n    }\n}"
    }
  ]
}