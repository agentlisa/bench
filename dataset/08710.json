{
  "Title": "[G-05] Splitting `require()` statements that use `&&` saves gas",
  "Content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper.\n\n*There are 7 instances of this issue:*\n\n```solidity\nFile: contracts/operators/Beefy/BeefyVaultOperator.sol\n\n54:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BVO: INVALID_AMOUNT_RECEIVED\");\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54\n\n```solidity\nFile: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol\n\n64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n\n65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64\n\n```solidity\nFile: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol\n\n64:           require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n\n65:           require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64\n\n```solidity\nFile: contracts/operators/Paraswap/ParaswapOperator.sol\n\n16:           require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\");\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16\n\n```solidity\nFile: contracts/NestedFactory.sol\n\n66            require(\n67                address(_nestedAsset) != address(0) &&\n68                    address(_nestedRecords) != address(0) &&\n69                    address(_reserve) != address(0) &&\n70                    address(_feeSplitter) != address(0) &&\n71                    address(_weth) != address(0) &&\n72                    _operatorResolver != address(0) &&\n73                    address(_withdrawer) != address(0),\n74                \"NF: INVALID_ADDRESS\"\n75:           );\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L75\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-06-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/operators/Beefy/BeefyVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./BeefyVaultStorage.sol\";\nimport \"./../../libraries/ExchangeHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Beefy Single Vault Operator\n/// @notice Deposit/Withdraw in a Beefy vault (native or non-native).\ncontract BeefyVaultOperator {\n    BeefyVaultStorage public immutable operatorStorage;\n\n    constructor(address[] memory vaults, address[] memory tokens) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == tokens.length, \"BVO: INVALID_VAULTS_LENGTH\");\n        operatorStorage = new BeefyVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], tokens[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n    }\n\n    /// @notice Deposit the asset in the Beefy vault and receive\n    ///         the vault token (moo).\n    /// @param vault The vault address to deposit into\n    /// @param amount The token amount to deposit\n    /// @param minVaultAmount The minimum vault token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"BVO: INVALID_AMOUNT\");\n        IERC20 token = IERC20(operatorStorage.vaults(vault));\n        require(address(token) != address(0), \"BVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(token, vault);\n        (bool success, ) = vault.call(abi.encodeWithSignature(\"deposit(uint256)\", amount));\n        require(success, \"BVO: DEPOSIT_CALL_FAILED\");\n\n        uint256 vaultAmount = IERC20(vault).balanceOf(address(this)) - vaultBalanceBefore;\n        uint256 tokenAmount = tokenBalanceBefore - token.balanceOf(address(this));\n        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BVO: INVALID_AMOUNT_RECEIVED\");\n        require(amount == tokenAmount, \"BVO: INVALID_AMOUNT_DEPOSITED\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = vaultAmount;\n        amounts[1] = tokenAmount;\n\n        // Output token\n        tokens[0] = vault;\n        tokens[1] = address(token);\n    }\n\n    /// @notice Withdraw the vault token (moo) from Beefy and receive\n    ///         the underlying token.\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw(address vault, uint256 amount)\n        external\n        returns (uint256[] memory amounts, address[] memory tokens)\n    {\n        require(amount != 0, \"BVO: INVALID_AMOUNT\");\n        IERC20 token = IERC20(operatorStorage.vaults(vault));\n        require(address(token) != address(0), \"BVO: INVALID_VAULT\");\n\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n\n        (bool success, ) = vault.call(abi.encodeWithSignature(\"withdraw(uint256)\", amount));\n        require(success, \"BVO: WITHDRAW_CALL_FAILED\");\n\n        uint256 tokenAmount = token.balanceOf(address(this)) - tokenBalanceBefore;\n        uint256 vaultAmount = vaultBalanceBefore - IERC20(vault).balanceOf(address(this));\n        require(vaultAmount == amount, \"BVO: INVALID_AMOUNT_WITHDRAWED\");\n        require(tokenAmount != 0, \"BVO: INVALID_AMOUNT\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = tokenAmount;\n        amounts[1] = amount;\n\n        // Output token\n        tokens[0] = address(token);\n        tokens[1] = vault;\n    }\n}"
    },
    {
      "filename": "contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../BeefyVaultStorage.sol\";\nimport \"./../../../libraries/ExchangeHelpers.sol\";\nimport \"./../../../interfaces/external/IBeefyVaultV6.sol\";\nimport \"./../../../interfaces/external/IBiswapRouter02.sol\";\nimport \"./../../../interfaces/external/IBiswapPair.sol\";\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title (Zapper) Beefy Biswap LP Vault Operator.\n/// @notice Deposit/Withdraw in a Beefy Biswap LP vault using zapper\n/// Note: \"Zap\" means that the asset is converted for the LP Token by\n///       swapping and adding liquidity.\ncontract BeefyZapBiswapLPVaultOperator {\n    using SafeERC20 for IERC20;\n\n    BeefyVaultStorage public immutable operatorStorage;\n\n    constructor(address[] memory vaults, address[] memory routers) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == routers.length, \"BLVO: INVALID_VAULTS_LENGTH\");\n\n        operatorStorage = new BeefyVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], routers[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n    }\n\n    /// @notice Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo).\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amountToDeposit The token amount to deposit\n    /// @param minVaultAmount The minimum vault token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        IERC20 token,\n        uint256 amountToDeposit,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amountToDeposit != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n        _zapAndStakeLp(router, IBeefyVaultV6(vault), address(token), amountToDeposit);\n\n        uint256 vaultAmount = IERC20(vault).balanceOf(address(this)) - vaultBalanceBefore;\n        uint256 depositedAmount = tokenBalanceBefore - token.balanceOf(address(this));\n\n        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = vaultAmount;\n        amounts[1] = depositedAmount;\n\n        // Output token\n        tokens[0] = vault;\n        tokens[1] = address(token);\n    }\n\n    /// @notice Withdraw the vault token (moo) from Beefy and receive\n    ///         one of the paired tokens\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    /// @param minTokenAmount The minimum token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw(\n        address vault,\n        uint256 amount,\n        IERC20 token,\n        uint256 minTokenAmount\n    ) external returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n\n        _withdrawAndSwap(router, vault, amount, address(token));\n\n        uint256 tokenAmount = token.balanceOf(address(this)) - tokenBalanceBefore;\n        uint256 vaultAmount = vaultBalanceBefore - IERC20(vault).balanceOf(address(this));\n        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\n        require(tokenAmount >= minTokenAmount, \"BLVO: INVALID_OUTPUT_AMOUNT\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = tokenAmount;\n        amounts[1] = amount;\n\n        // Output token\n        tokens[0] = address(token);\n        tokens[1] = vault;\n    }\n\n    /// @notice Perform a vault token withdraw (moo) from Beefy, and\n    ///         transfer the rest as one of the paired token\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    function _withdrawAndSwap(\n        address router,\n        address vault,\n        uint256 amount,\n        address token\n    ) private {\n        address pair = IBeefyVaultV6(vault).want();\n\n        uint256 pairBalanceBefore = IERC20(pair).balanceOf(address(this));\n        IBeefyVaultV6(vault).withdraw(amount);\n\n        address token0 = IUniswapV2Pair(pair).token0();\n        address token1 = IUniswapV2Pair(pair).token1();\n        require(token0 == token || token1 == token, \"BLVO: INVALID_TOKEN\");\n\n        // LP Tokens needs to be sent back to the pair address to be burned\n        IERC20(pair).safeTransfer(pair, IERC20(pair).balanceOf(address(this)) - pairBalanceBefore);\n\n        // Remove liquidity by burning the LP Token and not\n        // by calling `removeLiquidity` since we are checking the final\n        // output amount (minTokenAmount).\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(address(this));\n        uint256 tokenAmountIn;\n\n        address swapToken;\n        if (token1 == token) {\n            swapToken = token0;\n            tokenAmountIn = amount0;\n        } else {\n            swapToken = token1;\n            tokenAmountIn = amount1;\n        }\n\n        ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);\n\n        address[] memory path = new address[](2);\n        path[0] = swapToken;\n        path[1] = token;\n\n        // Slippage 100% since we are checking the final amount (minTokenAmount) for the slippage\n        IBiswapRouter02(router).swapExactTokensForTokens(tokenAmountIn, 0, path, address(this), block.timestamp);\n    }\n\n    /// @dev Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo)\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amount The token amount to deposit\n    function _zapAndStakeLp(\n        address router,\n        IBeefyVaultV6 vault,\n        address token,\n        uint256 amount\n    ) private {\n        IBiswapRouter02 biswapRouter = IBiswapRouter02(router);\n        IBiswapPair pair = IBiswapPair(vault.want());\n\n        require(pair.factory() == biswapRouter.factory(), \"BLVO: INVALID_VAULT\");\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));\n\n        address cachedToken0 = pair.token0();\n        address cachedToken1 = pair.token1();\n\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken0), router);\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken1), router);\n\n        bool isInput0 = cachedToken0 == token;\n        require(isInput0 || cachedToken1 == token, \"BLVO: INVALID_INPUT_TOKEN\");\n\n        address[] memory path = new address[](2);\n        path[0] = token;\n\n        if (isInput0) {\n            path[1] = cachedToken1;\n        } else {\n            path[1] = cachedToken0;\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        // The amount of input token to swap\n        // to get the same value of output token\n        uint256 swapAmountIn;\n        if (isInput0) {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve0, reserve1, biswapRouter, pair);\n        } else {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve1, reserve0, biswapRouter, pair);\n        }\n\n        uint256 lpAmount = _swapAndAddLiquidity(amount, swapAmountIn, path, biswapRouter);\n        vault.deposit(lpAmount);\n    }\n\n    /// @dev Swap input tokenA into TokenB to get the same value in tokenA\n    ///         as in tokenB to then add liquidity and store the obtained LP\n    ///         token in the vault beefy.\n    /// Note : path.length must be equal to 2 with path[0] = tokenA and path[1] = tokenB\n    /// @param amount The amount of tokenA to invest\n    /// @param swapAmountIn The amount of tokenA to swap for tokenB\n    /// @param path An array of the two paired token addresses\n    /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition\n    function _swapAndAddLiquidity(\n        uint256 amount,\n        uint256 swapAmountIn,\n        address[] memory path,\n        IBiswapRouter02 biswapRouter\n    ) private returns (uint256 mintedLpAmount) {\n        uint256[] memory swappedAmounts = biswapRouter.swapExactTokensForTokens(\n            swapAmountIn,\n            1,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        (, , mintedLpAmount) = biswapRouter.addLiquidity(\n            path[0],\n            path[1],\n            amount - swappedAmounts[0],\n            swappedAmounts[1],\n            1,\n            1,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /// @dev Calculate the optimal amount of tokenA to swap to obtain\n    ///         the same market value of tokenB after the trade.\n    ///         This allows to add as many tokensA and tokensB as possible\n    ///         to the liquidity to minimize the remaining amount.\n    /// @param investmentA The total amount of tokenA to invest\n    /// @param pair The IBiswapPair to be used\n    function _getOptimalSwapAmount(\n        uint256 investmentA,\n        uint256 reserveA,\n        uint256 reserveB,\n        IBiswapRouter02 router,\n        IBiswapPair pair\n    ) private view returns (uint256 swapAmount) {\n        require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n        require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n\n        // The initial plan is to swap half of tokenA total amount to add liquidity\n        uint256 halfInvestment = investmentA / 2;\n\n        // Get the tokenB output for swapping tokenA (with the given reserves)\n        uint256 nominator = router.getAmountOut(halfInvestment, reserveA, reserveB, pair.swapFee());\n\n        // Get the amount of reserveB token representing equivalent value after swapping\n        // tokenA for tokenB (previous operation).\n        uint256 denominator = router.quote(halfInvestment, reserveA + halfInvestment, reserveB - nominator);\n\n        // Equivalent of the simplification of a quadratic equation (ax² + bx + c = 0)\n        // See : \"optimal swap amount\" in readme\n        swapAmount = investmentA - Babylonian.sqrt((halfInvestment * halfInvestment * nominator) / denominator);\n    }\n}"
    },
    {
      "filename": "contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../BeefyVaultStorage.sol\";\nimport \"./../../../libraries/ExchangeHelpers.sol\";\nimport \"./../../../interfaces/external/IBeefyVaultV6.sol\";\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title (Zapper) Beefy UniswapV2 LP Vault Operator.\n/// @notice Deposit/Withdraw in a Beefy UniswapV2 LP vault using zapper\n/// Note: \"Zap\" means that the asset is converted for the LP Token by\n///       swapping and adding liquidity.\ncontract BeefyZapUniswapLPVaultOperator {\n    using SafeERC20 for IERC20;\n\n    BeefyVaultStorage public immutable operatorStorage;\n\n    constructor(address[] memory vaults, address[] memory routers) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == routers.length, \"BLVO: INVALID_VAULTS_LENGTH\");\n\n        operatorStorage = new BeefyVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], routers[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n    }\n\n    /// @notice Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo).\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amountToDeposit The token amount to deposit\n    /// @param minVaultAmount The minimum vault token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        IERC20 token,\n        uint256 amountToDeposit,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amountToDeposit != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n        _zapAndStakeLp(router, IBeefyVaultV6(vault), address(token), amountToDeposit);\n\n        uint256 vaultAmount = IERC20(vault).balanceOf(address(this)) - vaultBalanceBefore;\n        uint256 depositedAmount = tokenBalanceBefore - token.balanceOf(address(this));\n\n        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = vaultAmount;\n        amounts[1] = depositedAmount;\n\n        // Output token\n        tokens[0] = vault;\n        tokens[1] = address(token);\n    }\n\n    /// @notice Withdraw the vault token (moo) from Beefy and receive\n    ///         one of the paired tokens\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    /// @param minTokenAmount The minimum token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw(\n        address vault,\n        uint256 amount,\n        IERC20 token,\n        uint256 minTokenAmount\n    ) external returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n\n        _withdrawAndSwap(router, vault, amount, address(token));\n\n        uint256 tokenAmount = token.balanceOf(address(this)) - tokenBalanceBefore;\n        uint256 vaultAmount = vaultBalanceBefore - IERC20(vault).balanceOf(address(this));\n        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\n        require(tokenAmount >= minTokenAmount, \"BLVO: INVALID_OUTPUT_AMOUNT\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = tokenAmount;\n        amounts[1] = amount;\n\n        // Output token\n        tokens[0] = address(token);\n        tokens[1] = vault;\n    }\n\n    /// @notice Perform a vault token withdraw (moo) from Beefy, and\n    ///         transfer the rest as one of the paired token\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    function _withdrawAndSwap(\n        address router,\n        address vault,\n        uint256 amount,\n        address token\n    ) private {\n        address pair = IBeefyVaultV6(vault).want();\n\n        uint256 pairBalanceBefore = IERC20(pair).balanceOf(address(this));\n        IBeefyVaultV6(vault).withdraw(amount);\n\n        address token0 = IUniswapV2Pair(pair).token0();\n        address token1 = IUniswapV2Pair(pair).token1();\n        require(token0 == token || token1 == token, \"BLVO: INVALID_TOKEN\");\n\n        // LP Tokens needs to be sent back to the pair address to be burned\n        IERC20(pair).safeTransfer(pair, IERC20(pair).balanceOf(address(this)) - pairBalanceBefore);\n\n        // Remove liquidity by burning the LP Token and not\n        // by calling `removeLiquidity` since we are checking the final\n        // output amount (minTokenAmount).\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(address(this));\n        uint256 tokenAmountIn;\n\n        address swapToken;\n        if (token1 == token) {\n            swapToken = token0;\n            tokenAmountIn = amount0;\n        } else {\n            swapToken = token1;\n            tokenAmountIn = amount1;\n        }\n\n        ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);\n\n        address[] memory path = new address[](2);\n        path[0] = swapToken;\n        path[1] = token;\n\n        // Slippage 100% since we are checking the final amount (minTokenAmount) for the slippage\n        IUniswapV2Router02(router).swapExactTokensForTokens(tokenAmountIn, 0, path, address(this), block.timestamp);\n    }\n\n    /// @dev Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo)\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amount The token amount to deposit\n    function _zapAndStakeLp(\n        address router,\n        IBeefyVaultV6 vault,\n        address token,\n        uint256 amount\n    ) private {\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(router);\n        IUniswapV2Pair pair = IUniswapV2Pair(vault.want());\n\n        require(pair.factory() == uniswapRouter.factory(), \"BLVO: INVALID_VAULT\");\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));\n\n        address cachedToken0 = pair.token0();\n        address cachedToken1 = pair.token1();\n\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken0), router);\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken1), router);\n\n        bool isInput0 = cachedToken0 == token;\n        require(isInput0 || cachedToken1 == token, \"BLVO: INVALID_INPUT_TOKEN\");\n\n        address[] memory path = new address[](2);\n        path[0] = token;\n\n        if (isInput0) {\n            path[1] = cachedToken1;\n        } else {\n            path[1] = cachedToken0;\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        // The amount of input token to swap\n        // to get the same value of output token\n        uint256 swapAmountIn;\n        if (isInput0) {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve0, reserve1, uniswapRouter);\n        } else {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve1, reserve0, uniswapRouter);\n        }\n\n        uint256 lpAmount = _swapAndAddLiquidity(amount, swapAmountIn, path, uniswapRouter);\n        vault.deposit(lpAmount);\n    }\n\n    /// @dev Swap input tokenA into TokenB to get the same value in tokenA\n    ///         as in tokenB to then add liquidity and store the obtained LP\n    ///         token in the vault beefy.\n    /// Note : path.length must be equal to 2 with path[0] = tokenA and path[1] = tokenB\n    /// @param amount The amount of tokenA to invest\n    /// @param swapAmountIn The amount of tokenA to swap for tokenB\n    /// @param path An array of the two paired token addresses\n    /// @param uniswapRouter The uniswapV2 router to be used for swap and liquidity addition\n    function _swapAndAddLiquidity(\n        uint256 amount,\n        uint256 swapAmountIn,\n        address[] memory path,\n        IUniswapV2Router02 uniswapRouter\n    ) private returns (uint256 mintedLpAmount) {\n        uint256[] memory swappedAmounts = uniswapRouter.swapExactTokensForTokens(\n            swapAmountIn,\n            1,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        (, , mintedLpAmount) = uniswapRouter.addLiquidity(\n            path[0],\n            path[1],\n            amount - swappedAmounts[0],\n            swappedAmounts[1],\n            1,\n            1,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /// @dev Calculate the optimal amount of tokenA to swap to obtain\n    ///         the same market value of tokenB after the trade.\n    ///         This allows to add as many tokensA and tokensB as possible\n    ///         to the liquidity to minimize the remaining amount.\n    /// @param investmentA The total amount of tokenA to invest\n    function _getOptimalSwapAmount(\n        uint256 investmentA,\n        uint256 reserveA,\n        uint256 reserveB,\n        IUniswapV2Router02 router\n    ) private pure returns (uint256 swapAmount) {\n        require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n        require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n\n        // The initial plan is to swap half of tokenA total amount to add liquidity\n        uint256 halfInvestment = investmentA / 2;\n\n        // Get the tokenB output for swapping tokenA (with the given reserves)\n        uint256 nominator = router.getAmountOut(halfInvestment, reserveA, reserveB);\n\n        // Get the amount of reserveB token representing equivalent value after swapping\n        // tokenA for tokenB (previous operation).\n        uint256 denominator = router.quote(halfInvestment, reserveA + halfInvestment, reserveB - nominator);\n\n        // Equivalent of the simplification of a quadratic equation (ax² + bx + c = 0)\n        // See : \"optimal swap amount\" in readme\n        swapAmount = investmentA - Babylonian.sqrt((halfInvestment * halfInvestment * nominator) / denominator);\n    }\n}"
    },
    {
      "filename": "contracts/operators/Paraswap/ParaswapOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./IParaswapOperator.sol\";\nimport \"../../libraries/ExchangeHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title The paraswap operator to execute swap with the aggregator\n/// @dev see documentation => https://developers.paraswap.network/smart-contracts\ncontract ParaswapOperator is IParaswapOperator {\n    address public immutable tokenTransferProxy;\n    address public immutable augustusSwapper;\n\n    /// @dev No storage, only immutable\n    constructor(address _tokenTransferProxy, address _augustusSwapper) {\n        require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\");\n        tokenTransferProxy = _tokenTransferProxy;\n        augustusSwapper = _augustusSwapper;\n    }\n\n    /// @inheritdoc IParaswapOperator\n    function performSwap(\n        IERC20 sellToken,\n        IERC20 buyToken,\n        bytes calldata swapCallData\n    ) external payable override returns (uint256[] memory amounts, address[] memory tokens) {\n        require(sellToken != buyToken, \"PSO: SAME_INPUT_OUTPUT\");\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n        uint256 buyBalanceBeforePurchase = buyToken.balanceOf(address(this));\n        uint256 sellBalanceBeforePurchase = sellToken.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(sellToken, tokenTransferProxy);\n        (bool success, ) = augustusSwapper.call(swapCallData);\n        require(success, \"PSO: SWAP_FAILED\");\n\n        uint256 amountBought = buyToken.balanceOf(address(this)) - buyBalanceBeforePurchase;\n        uint256 amountSold = sellBalanceBeforePurchase - sellToken.balanceOf(address(this));\n        require(amountBought != 0, \"PSO: INVALID_AMOUNT_BOUGHT\");\n        require(amountSold != 0, \"PSO: INVALID_AMOUNT_SOLD\");\n\n        // Output amounts\n        amounts[0] = amountBought;\n        amounts[1] = amountSold;\n        // Output token\n        tokens[0] = address(buyToken);\n        tokens[1] = address(sellToken);\n    }\n}"
    },
    {
      "filename": "contracts/NestedFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\nimport \"./Withdrawer.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /// @dev Helper to withdraw native tokens from wrapper\n    Withdrawer private immutable withdrawer;\n\n    /// @dev Fees when funds stay in portfolios\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public entryFees;\n\n    /// @dev Fees when funds are withdrawed\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public exitFees;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver,\n        Withdrawer _withdrawer\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset"
    }
  ]
}