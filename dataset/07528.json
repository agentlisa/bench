{
  "Title": "[H-07] User can pass auction recovery health check easily with flashloan",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolParameters.sol#L281>\n\nParaSpace features an auction mechanism to liquidate user's NFT holdings and receive fair value. User has the option, before liquidation actually happens but after auction started, to top up their account to above recovery factor (> 1.5 instead of > 1) and use `setAuctionValidityTime()` to invalidate the auction.\n\n    require(\n        erc721HealthFactor > ps._auctionRecoveryHealthFactor,\n        Errors.ERC721_HEALTH_FACTOR_NOT_ABOVE_THRESHOLD\n    );\n    userConfig.auctionValidityTime = block.timestamp;\n\nThe issue is that the check validates the account is topped in the moment the TX is executed. Therefore, user may very easily make it appear they have fully recovered by borrowing a large amount of funds, depositing them as collateral, registering auction invalidation, removing the collateral and repaying the flash loan. Reentrancy guards are not effective to prevent this attack because all these actions are done in a sequence, one finishes before the other begins. However, it is clear user cannot immediately finish this attack below liquidation threshold because health factor check will not allow it.\n\nStill, the recovery feature is a very important feature of the protocol and a large part of what makes it unique, which is why I think it is very significant that it can be bypassed.<br>\nI am on the fence on whether this should be HIGH or MED level impact, would support judge's verdict either way.\n\n### Impact\n\nUser can pass auction recovery health check easily with flashloan.\n\n### Proof of Concept\n\n1.  User places NFT as collateral in the protocol\n2.  User borrows using the NFT as collateral\n3.  NFT price drops and health factor is lower than liquidation threshold\n4.  Auction to sell NFT initiates\n5.  User deposits just enough to be above liquidation threshold\n6.  User now flashloans 1000 WETH\n    1.  supply 1000 WETH to the protocol\n    2.  call setAuctionValidityTime(), cancelling the auction\n    3.  withdraw the 1000 WETH from the protocol\n    4.  pay back the 1000 WETH flashloan\n7.  End result is bypassing of recovery health check\n\n### Recommended Mitigation Steps\n\nIn order to know user has definitely recovered, implement it as a function which holds the user's assets for X time (at least 5 minutes), then releases it back to the user and cancelling all their auctions.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/478#issuecomment-1400967168):**\n > I agree with high risk for this. It's a direct attack on the intended functionality of the protocol that can result in a liquidation delay and potential loss of funds.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/pool/PoolParameters.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {ParaVersionedInitializable} from \"../libraries/paraspace-upgradeability/ParaVersionedInitializable.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {PoolLogic} from \"../libraries/logic/PoolLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {MarketplaceLogic} from \"../libraries/logic/MarketplaceLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidationLogic} from \"../libraries/logic/LiquidationLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IERC20WithPermit} from \"../../interfaces/IERC20WithPermit.sol\";\nimport {IPoolAddressesProvider} from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport {IPoolParameters} from \"../../interfaces/IPoolParameters.sol\";\nimport {INToken} from \"../../interfaces/INToken.sol\";\nimport {IACLManager} from \"../../interfaces/IACLManager.sol\";\nimport {PoolStorage} from \"./PoolStorage.sol\";\nimport {FlashClaimLogic} from \"../libraries/logic/FlashClaimLogic.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC721Receiver} from \"../../dependencies/openzeppelin/contracts/IERC721Receiver.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ParaReentrancyGuard} from \"../libraries/paraspace-upgradeability/ParaReentrancyGuard.sol\";\nimport {IAuctionableERC721} from \"../../interfaces/IAuctionableERC721.sol\";\nimport {IReserveAuctionStrategy} from \"../../interfaces/IReserveAuctionStrategy.sol\";\n\n/**\n * @title Pool Parameters contract\n *\n * @notice Main point of interaction with an ParaSpace protocol's market\n * - Users can:\n *   - mintToTreasury\n *   - ...\n * @dev To be covered by a proxy contract, owned by the PoolAddressesProvider of the specific market\n * @dev All admin functions are callable by the PoolConfigurator contract defined also in the\n *   PoolAddressesProvider\n **/\ncontract PoolParameters is\n    ParaVersionedInitializable,\n    ParaReentrancyGuard,\n    PoolStorage,\n    IPoolParameters\n{\n    using ReserveLogic for DataTypes.ReserveData;\n\n    IPoolAddressesProvider internal immutable ADDRESSES_PROVIDER;\n    uint256 internal constant POOL_REVISION = 1;\n    uint256 internal constant MAX_AUCTION_HEALTH_FACTOR = 2e18;\n    uint256 internal constant MIN_AUCTION_HEALTH_FACTOR = 1e18;\n\n    /**\n     * @dev Only pool configurator can call functions marked by this modifier.\n     **/\n    modifier onlyPoolConfigurator() {\n        _onlyPoolConfigurator();\n        _;\n    }\n\n    /**\n     * @dev Only pool admin can call functions marked by this modifier.\n     **/\n    modifier onlyPoolAdmin() {\n        _onlyPoolAdmin();\n        _;\n    }\n\n    function _onlyPoolConfigurator() internal view virtual {\n        require(\n            ADDRESSES_PROVIDER.getPoolConfigurator() == msg.sender,\n            Errors.CALLER_NOT_POOL_CONFIGURATOR\n        );\n    }\n\n    function _onlyPoolAdmin() internal view virtual {\n        require(\n            IACLManager(ADDRESSES_PROVIDER.getACLManager()).isPoolAdmin(\n                msg.sender\n            ),\n            Errors.CALLER_NOT_POOL_ADMIN\n        );\n    }\n\n    /**\n     * @dev Constructor.\n     * @param provider The address of the PoolAddressesProvider contract\n     */\n    constructor(IPoolAddressesProvider provider) {\n        ADDRESSES_PROVIDER = provider;\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return POOL_REVISION;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function mintToTreasury(address[] calldata assets)\n        external\n        virtual\n        override\n        nonReentrant\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        PoolLogic.executeMintToTreasury(ps._reserves, assets);\n    }\n\n    /// @inheritdoc IPoolParameters\n    function initReserve(\n        address asset,\n        address xTokenAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress,\n        address auctionStrategyAddress\n    ) external virtual override onlyPoolConfigurator {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        if (\n            PoolLogic.executeInitReserve(\n                ps._reserves,\n                ps._reservesList,\n                DataTypes.InitReserveParams({\n                    asset: asset,\n                    xTokenAddress: xTokenAddress,\n                    variableDebtAddress: variableDebtAddress,\n                    interestRateStrategyAddress: interestRateStrategyAddress,\n                    auctionStrategyAddress: auctionStrategyAddress,\n                    reservesCount: ps._reservesCount,\n                    maxNumberReserves: ReserveConfiguration.MAX_RESERVES_COUNT\n                })\n            )\n        ) {\n            ps._reservesCount++;\n        }\n    }\n\n    /// @inheritdoc IPoolParameters\n    function dropReserve(address asset)\n        external\n        virtual\n        override\n        onlyPoolConfigurator\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        PoolLogic.executeDropReserve(ps._reserves, ps._reservesList, asset);\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setReserveInterestRateStrategyAddress(\n        address asset,\n        address rateStrategyAddress\n    ) external virtual override onlyPoolConfigurator {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(\n            ps._reserves[asset].id != 0 || ps._reservesList[0] == asset,\n            Errors.ASSET_NOT_LISTED\n        );\n        ps._reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setReserveAuctionStrategyAddress(\n        address asset,\n        address auctionStrategyAddress\n    ) external virtual override onlyPoolConfigurator {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(\n            ps._reserves[asset].id != 0 || ps._reservesList[0] == asset,\n            Errors.ASSET_NOT_LISTED\n        );\n        ps._reserves[asset].auctionStrategyAddress = auctionStrategyAddress;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setConfiguration(\n        address asset,\n        DataTypes.ReserveConfigurationMap calldata configuration\n    ) external virtual override onlyPoolConfigurator {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(\n            ps._reserves[asset].id != 0 || ps._reservesList[0] == asset,\n            Errors.ASSET_NOT_LISTED\n        );\n        ps._reserves[asset].configuration = configuration;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function rescueTokens(\n        DataTypes.AssetType assetType,\n        address token,\n        address to,\n        uint256 amountOrTokenId\n    ) external virtual override onlyPoolAdmin {\n        PoolLogic.executeRescueTokens(assetType, token, to, amountOrTokenId);\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setAuctionRecoveryHealthFactor(uint64 value)\n        external\n        virtual\n        override\n        onlyPoolConfigurator\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(value != 0, Errors.INVALID_AMOUNT);\n\n        require(\n            value > MIN_AUCTION_HEALTH_FACTOR &&\n                value <= MAX_AUCTION_HEALTH_FACTOR,\n            Errors.INVALID_AMOUNT\n        );\n\n        ps._auctionRecoveryHealthFactor = value;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function getUserAccountData(address user)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor,\n            uint256 erc721HealthFactor\n        )\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return\n            PoolLogic.executeGetUserAccountData(\n                user,\n                ps,\n                ADDRESSES_PROVIDER.getPriceOracle()\n            );\n    }\n\n    function getAssetLtvAndLT(address asset, uint256 tokenId)\n        external\n        view\n        virtual\n        override\n        returns (uint256 ltv, uint256 lt)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n        return PoolLogic.executeGetAssetLtvAndLT(ps, asset, tokenId);\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setAuctionValidityTime(address user)\n        external\n        virtual\n        override\n        nonReentrant\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(user != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        DataTypes.UserConfigurationMap storage userConfig = ps._usersConfig[\n            user\n        ];\n        (, , , , , , uint256 erc721HealthFactor) = PoolLogic\n            .executeGetUserAccountData(\n                user,\n                ps,\n                ADDRESSES_PROVIDER.getPriceOracle()\n            );\n        require(\n            erc721HealthFactor > ps._auctionRecoveryHealthFactor,\n            Errors.ERC721_HEALTH_FACTOR_NOT_ABOVE_THRESHOLD\n        );\n        userConfig.auctionValidityTime = block.timestamp;\n    }\n}"
    }
  ]
}