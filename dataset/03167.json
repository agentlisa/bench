{
  "Title": "Some functions not marked nonReentrant",
  "Content": "We have not identified any security issues relating to reentrancy. However, out of an abundance of caution, consider marking the following `public` functions in the [`HubPool`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol) contract as `nonReentrant`. Consider that the `nonReentrant` modifier only works if both the original function, and the re-entered function are marked `nonReentrant`.\n\n\n* [`setProtocolFeeCapture`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L254)\n* [`setBond`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L270)\n* [`setLiveness`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L287)\n* [`setIdentifier`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L297)\n* [`whitelistRoute`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L329)\n* [`enableL1TokenForLiquidityProvision`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L350)\n* [`disableL1TokenForLiquidityProvision`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L364)\n* [`addLiquidity`](https://github.com/across-protocol/contracts-v2/blob/bf03255cbd1db3045cd2fbf1580f24081f46b43a/contracts/HubPool.sol#L384)\n\n\n**Update**: *Fixed. Partially addressed in [pull request #62](https://github.com/across-protocol/contracts-v2/pull/62) as of commit [`a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6`](https://github.com/across-protocol/contracts-v2/pull/62/commits/a3b5b5600e53d2ae877a4c1c18d78aadb01ff2e6) and then fully addressed in [pull request #92](https://github.com/across-protocol/contracts-v2/pull/92) as of commit [`7aa2fa8f46f8d40512857f35dd3ac64587c61f18`](https://github.com/across-protocol/contracts-v2/pull/92/commits/7aa2fa8f46f8d40512857f35dd3ac64587c61f18).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/HubPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./MerkleLib.sol\";\nimport \"./HubPoolInterface.sol\";\nimport \"./Lockable.sol\";\n\nimport \"./interfaces/AdapterInterface.sol\";\nimport \"./interfaces/LpTokenFactoryInterface.sol\";\nimport \"./interfaces/WETH9.sol\";\n\nimport \"@uma/core/contracts/common/implementation/Testable.sol\";\nimport \"@uma/core/contracts/common/implementation/MultiCaller.sol\";\nimport \"@uma/core/contracts/oracle/implementation/Constants.sol\";\nimport \"@uma/core/contracts/common/implementation/AncillaryData.sol\";\nimport \"@uma/core/contracts/common/interfaces/AddressWhitelistInterface.sol\";\nimport \"@uma/core/contracts/oracle/interfaces/IdentifierWhitelistInterface.sol\";\n\nimport \"@uma/core/contracts/oracle/interfaces/FinderInterface.sol\";\nimport \"@uma/core/contracts/oracle/interfaces/StoreInterface.sol\";\nimport \"@uma/core/contracts/oracle/interfaces/SkinnyOptimisticOracleInterface.sol\";\nimport \"@uma/core/contracts/common/interfaces/ExpandedIERC20.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @notice Contract deployed on Ethereum that houses L1 token liquidity for all SpokePools. A dataworker can interact\n * with merkle roots stored in this contract via inclusion proofs to instruct this contract to send tokens to L2\n * SpokePools via \"pool rebalances\" that can be used to pay out relayers on those networks. This contract is also\n * responsible for publishing relayer refund and slow relay merkle roots to SpokePools.\n * @notice This contract is meant to act as the cross chain administrator and owner of all L2 spoke pools, so all\n * governance actions and pool rebalances originate from here and bridge instructions to L2s.\n */\ncontract HubPool is HubPoolInterface, Testable, Lockable, MultiCaller, Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // A data worker can optimistically store several merkle roots on this contract by staking a bond and calling\n    // proposeRootBundle. By staking a bond, the data worker is alleging that the merkle roots all\n    // contain valid leaves that can be executed later to:\n    // - Send funds from this contract to a SpokePool or vice versa\n    // - Send funds from a SpokePool to Relayer as a refund for a relayed deposit\n    // - Send funds from a SpokePool to a deposit recipient to fulfill a \"slow\" relay\n    // Anyone can dispute this struct if the merkle roots contain invalid leaves before the\n    // requestExpirationTimestamp. Once the expiration timestamp is passed, executeRootBundle to execute a leaf\n    // from the poolRebalanceRoot on this contract and it will simultaneously publish the relayerRefundRoot and\n    // slowRelayRoot to a SpokePool. The latter two roots, once published to the SpokePool, contain\n    // leaves that can be executed on the SpokePool to pay relayers or recipients.\n    struct RootBundle {\n        // When root bundle challenge period passes and this root bundle becomes executable.\n        uint64 requestExpirationTimestamp;\n        // Number of pool rebalance leaves to execute in the poolRebalanceRoot. After this number\n        // of leaves are executed, a new root bundle can be proposed\n        uint64 unclaimedPoolRebalanceLeafCount;\n        // Contains leaves instructing this contract to send funds to SpokePools.\n        bytes32 poolRebalanceRoot;\n        // Relayer refund merkle root to be published to a SpokePool.\n        bytes32 relayerRefundRoot;\n        // Slow relay merkle root to be published to a SpokePool.\n        bytes32 slowRelayRoot;\n        // This is a 1D bitmap, with max size of 256 elements, limiting us to 256 chainsIds.\n        uint256 claimedBitMap;\n        // Proposer of this root bundle.\n        address proposer;\n        // Whether bond has been repaid to successful root bundle proposer.\n        bool proposerBondRepaid;\n    }\n\n    // Only one root bundle can be stored at a time. Once all pool rebalance leaves are executed, a new proposal\n    // can be submitted.\n    RootBundle public rootBundleProposal;\n\n    // Whitelist of origin token + ID to destination token routings to be used by off-chain agents. The notion of a\n    // route does not need to include L1; it can be L2->L2 route. i.e USDC on Arbitrum -> USDC on Optimism as a \"route\".\n    mapping(bytes32 => address) private whitelistedRoutes;\n\n    struct PooledToken {\n        // LP token given to LPs of a specific L1 token.\n        address lpToken;\n        // True if accepting new LP's.\n        bool isEnabled;\n        // Timestamp of last LP fee update.\n        uint32 lastLpFeeUpdate;\n        // Number of LP funds sent via pool rebalances to SpokePools and are expected to be sent\n        // back later.\n        int256 utilizedReserves;\n        // Number of LP funds held in contract less utilized reserves.\n        uint256 liquidReserves;\n        // Number of LP funds reserved to pay out to LPs as fees.\n        uint256 undistributedLpFees;\n    }\n\n    // Mapping of L1 token addresses to the associated pool information.\n    mapping(address => PooledToken) public pooledTokens;\n\n    // Heler contracts to facilitate cross chain actions between HubPool and SpokePool for a specific network.\n    struct CrossChainContract {\n        AdapterInterface adapter;\n        address spokePool;\n    }\n    // Mapping of chainId to the associated adapter and spokePool contracts.\n    mapping(uint256 => CrossChainContract) public crossChainContracts;\n\n    // WETH contract for Ethereum.\n    WETH9 public weth;\n\n    // Helper factory to deploy new LP tokens for enabled L1 tokens\n    LpTokenFactoryInterface public lpTokenFactory;\n\n    // Finder contract for this network.\n    FinderInterface public finder;\n\n    // When root bundles are disputed a price request is enqueued with the DVM to resolve the resolution.\n    bytes32 public identifier = \"IS_ACROSS_V2_BUNDLE_VALID\";\n\n    // Interest rate payment that scales the amount of pending fees per second paid to LPs. 0.0000015e18 will pay out\n    // the full amount of fees entitled to LPs in ~ 7.72 days, just over the standard L2 7 day liveness.\n    uint256 public lpFeeRatePerSecond = 1500000000000;\n\n    mapping(address => uint256) public unclaimedAccumulatedProtocolFees;\n\n    // Address that captures protocol fees. Accumulated protocol fees can be claimed by this address.\n    address public protocolFeeCaptureAddress;\n\n    // Percentage of lpFees that are captured by the protocol and claimable by the protocolFeeCaptureAddress.\n    uint256 public protocolFeeCapturePct;\n\n    // Token used to bond the data worker for proposing relayer refund bundles.\n    IERC20 public bondToken;\n\n    // The computed bond amount as the UMA Store's final fee multiplied by the bondTokenFinalFeeMultiplier.\n    uint256 public bondAmount;\n\n    // Each root bundle proposal must stay in liveness for this period of time before it can be considered finalized.\n    // It can be disputed only during this period of time. Defaults to 2 hours, like the rest of the UMA ecosystem.\n    uint64 public liveness = 7200;\n\n    event ProtocolFeeCaptureSet(address indexed newProtocolFeeCaptureAddress, uint256 indexed newProtocolFeeCapturePct);\n\n    event ProtocolFeesCapturedClaimed(address indexed l1Token, uint256 indexed accumulatedFees);\n\n    event BondSet(address indexed newBondToken, uint256 newBondAmount);\n\n    event LivenessSet(uint256 newLiveness);\n\n    event IdentifierSet(bytes32 newIdentifier);\n\n    event CrossChainContractsSet(uint256 l2ChainId, address adapter, address spokePool);\n\n    event L1TokenEnabledForLiquidityProvision(address l1Token, address lpToken);\n\n    event L2TokenDisabledForLiquidityProvision(address l1Token, address lpToken);\n\n    event LiquidityAdded(\n        address indexed l1Token,\n        uint256 amount,\n        uint256 lpTokensMinted,\n        address indexed liquidityProvider\n    );\n    event LiquidityRemoved(\n        address indexed l1Token,\n        uint256 amount,\n        uint256 lpTokensBurnt,\n        address indexed liquidityProvider\n    );\n    event WhitelistRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        address destinationToken\n    );\n\n    event ProposeRootBundle(\n        uint64 requestExpirationTimestamp,\n        uint64 unclaimedPoolRebalanceLeafCount,\n        uint256[] bundleEvaluationBlockNumbers,\n        bytes32 indexed poolRebalanceRoot,\n        bytes32 indexed relayerRefundRoot,\n        bytes32 slowRelayRoot,\n        address indexed proposer\n    );\n    event RootBundleExecuted(\n        uint256 indexed leafId,\n        uint256 indexed chainId,\n        address[] l1Token,\n        uint256[] bundleLpFees,\n        int256[] netSendAmount,\n        int256[] runningBalance,\n        address indexed caller\n    );\n    event SpokePoolAdminFunctionTriggered(uint256 indexed chainId, bytes message);\n\n    event RootBundleDisputed(address indexed disputer, uint256 requestTime, bytes disputedAncillaryData);\n\n    event RootBundleCanceled(address indexed disputer, uint256 requestTime, bytes disputedAncillaryData);\n\n    modifier noActiveRequests() {\n        require(!_activeRequest(), \"proposal has unclaimed leafs\");\n        _;\n    }\n\n    modifier zeroOptimisticOracleApproval() {\n        _;\n        bondToken.safeApprove(address(_getOptimisticOracle()), 0);\n    }\n\n    /**\n     * @notice Construct HubPool.\n     * @param _lpTokenFactory LP Token factory address used to deploy LP tokens for new collateral types.\n     * @param _finder Finder address.\n     * @param _weth WETH address.\n     * @param _timer Timer address.\n     */\n    constructor(\n        LpTokenFactoryInterface _lpTokenFactory,\n        FinderInterface _finder,\n        WETH9 _weth,\n        address _timer\n    ) Testable(_timer) {\n        lpTokenFactory = _lpTokenFactory;\n        finder = _finder;\n        weth = _weth;\n        protocolFeeCaptureAddress = owner();\n    }\n\n    /*************************************************\n     *                ADMIN FUNCTIONS                *\n     *************************************************/\n\n    /**\n     * @notice Sends message to SpokePool from this contract. Callable only by owner.\n     * @dev This function has permission to call onlyAdmin functions on the SpokePool, so its imperative\n     * that this contract only allows the owner to call this method directly or indirectly.\n     * @param chainId Chain with SpokePool to send message to.\n     * @param functionData ABI encoded function call to send to SpokePool, but can be any arbitrary data technically.\n     */\n    function relaySpokePoolAdminFunction(uint256 chainId, bytes memory functionData)\n        public\n        override\n        onlyOwner\n        nonReentrant\n    {\n        _relaySpokePoolAdminFunction(chainId, functionData);\n    }\n\n    /**\n     * @notice Sets protocolFeeCaptureAddress and protocolFeeCapturePct. Callable only by owner.\n     * @param newProtocolFeeCaptureAddress New protocol fee capture address.\n     * @param newProtocolFeeCapturePct New protocol fee capture %.\n     */\n    function setProtocolFeeCapture(address newProtocolFeeCaptureAddress, uint256 newProtocolFeeCapturePct)\n        public\n        override\n        onlyOwner\n    {\n        require(newProtocolFeeCapturePct <= 1e18, \"Bad protocolFeeCapturePct\");\n        protocolFeeCaptureAddress = newProtocolFeeCaptureAddress;\n        protocolFeeCapturePct = newProtocolFeeCapturePct;\n        emit ProtocolFeeCaptureSet(newProtocolFeeCaptureAddress, newProtocolFeeCapturePct);\n    }\n\n    /**\n     * @notice Sets bond token and amount. Callable only by owner.\n     * @param newBondToken New bond currency.\n     * @param newBondAmount New bond amount.\n     */\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) public override onlyOwner noActiveRequests {\n        // Check that this token is on the whitelist.\n        AddressWhitelistInterface addressWhitelist = AddressWhitelistInterface(\n            finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist)\n        );\n        require(addressWhitelist.isOnWhitelist(address(newBondToken)), \"Not on whitelist\");\n\n        // The bond should be the passed in bondAmount + the final fee.\n        bondToken = newBondToken;\n        bondAmount = newBondAmount + _getBondTokenFinalFee();\n        emit BondSet(address(newBondToken), bondAmount);\n    }\n\n    /**\n     * @notice Sets root bundle proposal liveness period. Callable only by owner.\n     * @param newLiveness New liveness period.\n     */\n    function setLiveness(uint64 newLiveness) public override onlyOwner {\n        require(newLiveness > 10 minutes, \"Liveness too short\");\n        liveness = newLiveness;\n        emit LivenessSet(newLiveness);\n    }\n\n    /**\n     * @notice Sets identifier for root bundle disputes.. Callable only by owner.\n     * @param newIdentifier New identifier.\n     */\n    function setIdentifier(bytes32 newIdentifier) public override onlyOwner noActiveRequests {\n        IdentifierWhitelistInterface identifierWhitelist = IdentifierWhitelistInterface(\n            finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist)\n        );\n        require(identifierWhitelist.isIdentifierSupported(newIdentifier), \"Identifier not supported\");\n        identifier = newIdentifier;\n        emit IdentifierSet(newIdentifier);\n    }\n\n    /**\n     * @notice Sets cross chain relay helper contracts for L2 chain ID. Callable only by owner.\n     * @param l2ChainId Chain to set contracts for.\n     * @param adapter Adapter used to relay messages and tokens to spoke pool.\n     * @param spokePool Recipient of relayed messages and tokens on SpokePool.\n     */\n\n    function setCrossChainContracts(\n        uint256 l2ChainId,\n        address adapter,\n        address spokePool\n    ) public override onlyOwner noActiveRequests {\n        crossChainContracts[l2ChainId] = CrossChainContract(AdapterInterface(adapter), spokePool);\n        emit CrossChainContractsSet(l2ChainId, adapter, spokePool);\n    }\n\n    /**\n     * @notice Whitelist an origin chain ID + token <-> destination token route. Callable only by owner.\n     * @param originChainId Chain where deposit occurs.\n     * @param destinationChainId Chain where depositor wants to receive funds.\n     * @param originToken Deposited token.\n     * @param destinationToken Token that depositor wants to receive on destination chain.\n     */\n    function whitelistRoute(\n        uint256 originChainId,\n        uint256 destinationChainId,\n        address originToken,\n        address destinationToken\n    ) public override onlyOwner {\n        whitelistedRoutes[_whitelistedRouteKey(originChainId, originToken, destinationChainId)] = destinationToken;\n\n        // Whitelist the same route on the origin network.\n        _relaySpokePoolAdminFunction(\n            originChainId,\n            abi.encodeWithSignature(\"setEnableRoute(address,uint256,bool)\", originToken, destinationChainId, true)\n        );\n        emit WhitelistRoute(originChainId, destinationChainId, originToken, destinationToken);\n    }\n\n    /**\n     * @notice Enables LPs to provide liquidity for L1 token. Deploys new LP token for L1 token if appropriate.\n     * Callable only by owner.\n     * @param l1Token Token to provide liquidity for.\n     */\n    function enableL1TokenForLiquidityProvision(address l1Token) public override onlyOwner {\n        if (pooledTokens[l1Token].lpToken == address(0))\n            pooledTokens[l1Token].lpToken = lpTokenFactory.createLpToken(l1Token);\n\n        pooledTokens[l1Token].isEnabled = true;\n        pooledTokens[l1Token].lastLpFeeUpdate = uint32(getCurrentTime());\n\n        emit L1TokenEnabledForLiquidityProvision(l1Token, pooledTokens[l1Token].lpToken);\n    }\n\n    /**\n     * @notice Disables LPs from providing liquidity for L1 token. Callable only by owner.\n     * @param l1Token Token to disable liquidity provision for.\n     */\n    function disableL1TokenForLiquidityProvision(address l1Token) public override onlyOwner {\n        pooledTokens[l1Token].isEnabled = false;\n        emit L2TokenDisabledForLiquidityProvision(l1Token, pooledTokens[l1Token].lpToken);\n    }\n\n    /*************************************************\n     *          LIQUIDITY PROVIDER FUNCTIONS         *\n     *************************************************/\n\n    /**\n     * @notice Deposit liquidity into this contract to earn LP fees in exchange for funding relays on SpokePools.\n     * Caller is essentially loaning their funds to be sent from this contract to the SpokePool, where it will be used\n     * to repay a relayer, and ultimately receives their loan back after the tokens are bridged back to this contract\n     * via the canonical token bridge. Then, the caller's loans are used for again. This loan cycle repeats continuously\n     * and the caller, or \"liquidity provider\" earns a continuous fee for their credit that they are extending relayers.\n     * @notice Caller will receive an LP token representing their share of this pool. The LP token's redemption value\n     * increments from the time that they enter the pool to reflect their accrued fees.\n     * @param l1Token Token to deposit into this contract.\n     * @param l1TokenAmount Amount of liquidity to provide.\n     */\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) public payable override {\n        require(pooledTokens[l1Token].isEnabled, \"Token not enabled\");\n        // If this is the weth pool and the caller sends msg.value then the msg.value must match the l1TokenAmount.\n        // Else, msg.value must be set to 0.\n        require(((address(weth) == l1Token) && msg.value == l1TokenAmount) || msg.value == 0, \"Bad msg.value\");\n\n        // Since _exchangeRateCurrent() reads this contract's balance and updates contract state using it, it must be\n        // first before transferring any tokens to this contract to ensure synchronization.\n        uint256 lpTokensToMint = (l1TokenAmount * 1e18) / _exchangeRateCurrent(l1Token);\n        ExpandedIERC20(pooledTokens[l1Token].lpToken).mint(msg.sender, lpTokensToMint);\n        pooledTokens[l1Token].liquidReserves += l1TokenAmount;\n\n        if (address(weth) == l1Token && msg.value > 0) WETH9(address(l1Token)).deposit{ value: msg.value }();\n        else IERC20(l1Token).safeTransferFrom(msg.sender, address(this), l1TokenAmount);\n\n        emit LiquidityAdded(l1Token, l1TokenAmount, lpTokensToMint, msg.sender);\n    }\n\n    /**\n     * @notice Burns LP share to redeem for underlying l1Token original deposit amount plus fees.\n     * @param l1Token Token to redeem LP share for.\n     * @param lpTokenAmount Amount of LP tokens to burn. Exchange rate between L1 token and LP token can be queried\n     * via public exchangeRateCurrent method.\n     * @param sendEth Set to True if L1 token is WETH and user wants to receive ETH.\n     */\n    function removeLiquidity(\n        address l1Token,\n        uint256 lpTokenAmount,\n        bool sendEth\n    ) public override nonReentrant {\n        require(address(weth) == l1Token || !sendEth, \"Cant send eth\");\n        uint256 l1TokensToReturn = (lpTokenAmount * _exchangeRateCurrent(l1Token)) / 1e18;\n\n        ExpandedIERC20(pooledTokens[l1Token].lpToken).burnFrom(msg.sender, lpTokenAmount);\n        // Note this method does not make any liquidity utilization checks before letting the LP redeem their LP tokens.\n        // If they try access more funds that available (i.e l1TokensToReturn > liquidReserves) this will underflow.\n        pooledTokens[l1Token].liquidReserves -= l1TokensToReturn;\n\n        if (sendEth) _unwrapWETHTo(payable(msg.sender), l1TokensToReturn);\n        else IERC20(l1Token).safeTransfer(msg.sender, l1TokensToReturn);\n\n        emit LiquidityRemoved(l1Token, l1TokensToReturn, lpTokenAmount, msg.sender);\n    }\n\n    /**\n     * @notice Returns exchange rate of L1 token to LP token.\n     * @param l1Token L1 token redeemable by burning LP token.\n     * @return Amount of L1 tokens redeemable for 1 unit LP token.\n     */\n    function exchangeRateCurrent(address l1Token) public override nonReentrant returns (uint256) {\n        return _exchangeRateCurrent(l1Token);\n    }\n\n    /**\n     * @notice Returns % of liquid reserves currently being \"used\" and sitting in SpokePools.\n     * @param l1Token L1 token to query utilization for.\n     * @return % of liquid reserves currently being \"used\" and sitting in SpokePools.\n     */\n    function liquidityUtilizationCurrent(address l1Token) public override nonReentrant returns (uint256) {\n        return _liquidityUtilizationPostRelay(l1Token, 0);\n    }\n\n    /**\n     * @notice Returns % of liquid reserves currently being \"used\" and sitting in SpokePools and accounting for\n     * relayedAmount of tokens to be withdrawn from the pool.\n     * @param l1Token L1 token to query utilization for.\n     * @param relayedAmount The higher this amount, the higher the utilization.\n     * @return % of liquid reserves currently being \"used\" and sitting in SpokePools plus the relayedAmount.\n     */\n    function liquidityUtilizationPostRelay(address l1Token, uint256 relayedAmount)\n        public\n        nonReentrant\n        returns (uint256)\n    {\n        return _liquidityUtilizationPostRelay(l1Token, relayedAmount);\n    }\n\n    /**\n     * @notice Synchronize any balance changes in this contract with the utilized & liquid reserves. This should be done\n     * at the conclusion of a L2->L1 token transfer via the canonical token bridge, when this contract's reserves do not\n     * reflect its true balance due to new tokens being dropped onto the contract at the conclusion of a bridging action.\n     */\n    function sync(address l1Token) public override nonReentrant {\n        _sync(l1Token);\n    }\n\n    /*************************************************\n     *             DATA WORKER FUNCTIONS             *\n     *************************************************/\n\n    /**\n     * @notice Publish a new root bundle to along with all of the block numbers that the merkle roots are relevant for.\n     * This is used to aid off-chain validators in evaluating the correctness of this bundle. Caller stakes a bond that\n     * can be slashed if the root bundle proposal is invalid, and they will receive it back if accepted.\n     * @notice After proposeRootBundle is called, if the any props are wrong then this proposal can be challenged.\n     * Once the challenge period passes, then the roots are no longer disputable, and only executeRootBundle can be\n     * called; moreover, this method can't be called again until all leafs are executed.\n     * @param bundleEvaluationBlockNumbers should contain the latest block number for all chains, even if there are no\n     * relays contained on some of them. The usage of this variable should be defined in an off chain UMIP.\n     * @param poolRebalanceLeafCount Number of leaves contained in pool rebalance root. Max is the number of whitelisted chains.\n     * @param poolRebalanceRoot Pool rebalance root containing leaves that will send tokens from this contract to a SpokePool.\n     * @param relayerRefundRoot Relayer refund root to publish to SpokePool where a data worker can execute leaves to\n     * refund relayers on their chosen refund chainId.\n     * @param slowRelayRoot Slow relay root to publish to Spoke Pool where a data worker can execute leaves to\n     * fulfill slow relays.\n     */\n    function proposeRootBundle(\n        uint256[] memory bundleEvaluationBlockNumbers,\n        uint8 poolRebalanceLeafCount,\n        bytes32 poolRebalanceRoot,\n        bytes32 relayerRefundRoot,\n        bytes32 slowRelayRoot\n    ) public override nonReentrant noActiveRequests {\n        // Note: this is to prevent \"empty block\" style attacks where someone can make empty proposals that are\n        // technically valid but not useful. This could also potentially be enforced at the UMIP-level.\n        require(poolRebalanceLeafCount > 0, \"Bundle must have at least 1 leaf\");\n\n        uint64 requestExpirationTimestamp = uint64(getCurrentTime() + liveness);\n\n        delete rootBundleProposal; // Only one bundle of roots can be executed at a time.\n\n        rootBundleProposal.requestExpirationTimestamp = requestExpirationTimestamp;\n        rootBundleProposal.unclaimedPoolRebalanceLeafCount = poolRebalanceLeafCount;\n        rootBundleProposal.poolRebalanceRoot = poolRebalanceRoot;\n        rootBundleProposal.relayerRefundRoot = relayerRefundRoot;\n        rootBundleProposal.slowRelayRoot = slowRelayRoot;\n        rootBundleProposal.proposer = msg.sender;\n\n        // Pull bondAmount of bondToken from the caller.\n        bondToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n\n        emit ProposeRootBundle(\n            requestExpirationTimestamp,\n            poolRebalanceLeafCount,\n            bundleEvaluationBlockNumbers,\n            poolRebalanceRoot,\n            relayerRefundRoot,\n            slowRelayRoot,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Executes a pool rebalance leaf as part of the currently published root bundle. Will bridge any tokens\n     * from this contract to the SpokePool designated in the leaf, and will also publish relayer refund and slow\n     * relay roots to the SpokePool on the network specified in the leaf.\n     * @dev In some cases, will instruct spokePool to send funds back to L1.\n     * @notice Deletes the published root bundle if this is the last leaf to be executed in the root bundle.\n     * @param poolRebalanceLeaf Contains all data neccessary to reconstruct leaf contained in root bundle and to\n     * bridge tokens to HubPool. This data structure is explained in detail in the HubPoolInterface.\n     * @param proof Inclusion proof for this leaf in pool rebalance root in root bundle.\n     */\n    function executeRootBundle(PoolRebalanceLeaf memory poolRebalanceLeaf, bytes32[] memory proof) public nonReentrant {\n        require(getCurrentTime() > rootBundleProposal.requestExpirationTimestamp, \"Not passed liveness\");\n\n        // Verify the leafId in the poolRebalanceLeaf has not yet been claimed.\n        require(!MerkleLib.isClaimed1D(rootBundleProposal.claimedBitMap, poolRebalanceLeaf.leafId), \"Already claimed\");\n\n        // Verify the props provided generate a leaf that, along with the proof, are included in the merkle root.\n        require(\n            MerkleLib.verifyPoolRebalance(rootBundleProposal.poolRebalanceRoot, poolRebalanceLeaf, proof),\n            \"Bad Proof\"\n        );\n\n        // Before interacting with a particular chain's adapter, ensure that the adapter is set.\n        require(address(crossChainContracts[poolRebalanceLeaf.chainId].adapter) != address(0), \"No adapter for chain\");\n\n        // Set the leafId in the claimed bitmap.\n        rootBundleProposal.claimedBitMap = MerkleLib.setClaimed1D(\n            rootBundleProposal.claimedBitMap,\n            poolRebalanceLeaf.leafId\n        );\n\n        // Decrement the unclaimedPoolRebalanceLeafCount.\n        rootBundleProposal.unclaimedPoolRebalanceLeafCount--;\n\n        _sendTokensToChainAndUpdatePooledTokenTrackers(\n            poolRebalanceLeaf.chainId,\n            poolRebalanceLeaf.l1Tokens,\n            poolRebalanceLeaf.netSendAmounts,\n            poolRebalanceLeaf.bundleLpFees\n        );\n        _relayRootBundleToSpokePool(poolRebalanceLeaf.chainId);\n\n        // Transfer the bondAmount to back to the proposer, if this the last executed leaf. Only sending this once all\n        // leafs have been executed acts to force the data worker to execute all bundles or they wont receive their bond.\n        if (rootBundleProposal.unclaimedPoolRebalanceLeafCount == 0)\n            bondToken.safeTransfer(rootBundleProposal.proposer, bondAmount);\n\n        emit RootBundleExecuted(\n            poolRebalanceLeaf.leafId,\n            poolRebalanceLeaf.chainId,\n            poolRebalanceLeaf.l1Tokens,\n            poolRebalanceLeaf.bundleLpFees,\n            poolRebalanceLeaf.netSendAmounts,\n            poolRebalanceLeaf.runningBalances,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Caller stakes a bond to dispute the current root bundle proposal assuming it has not passed liveness\n     * yet. The proposal is deleted, allowing a follow-up proposal to be submitted, and the dispute is sent to the\n     * optimistic oracle to be adjudicated. Can only be called within the liveness period of the current proposal.\n     */\n    function disputeRootBundle() public nonReentrant zeroOptimisticOracleApproval {\n        uint32 currentTime = uint32(getCurrentTime());\n        require(currentTime <= rootBundleProposal.requestExpirationTimestamp, \"Request passed liveness\");\n\n        // Request price from OO and dispute it.\n        bytes memory requestAncillaryData = getRootBundleProposalAncillaryData();\n        uint256 finalFee = _getBondTokenFinalFee();\n\n        // If the finalFee is larger than the bond amount, the bond amount needs to be reset before a request can go\n        // through. Cancel to avoid a revert.\n        if (finalFee > bondAmount) {\n            _cancelBundle(requestAncillaryData);\n            return;\n        }\n\n        SkinnyOptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n\n        // Only approve exact tokens to avoid more tokens than expected being pulled into the OptimisticOracle.\n        bondToken.safeIncreaseAllowance(address(optimisticOracle), bondAmount);\n        try\n            optimisticOracle.requestAndProposePriceFor(\n                identifier,\n                currentTime,\n                requestAncillaryData,\n                bondToken,\n                // Set reward to 0, since we'll settle proposer reward payouts directly from this contract after a root\n                // proposal has passed the challenge period.\n                0,\n                // Set the Optimistic oracle proposer bond for the price request.\n                bondAmount - finalFee,\n                // Set the Optimistic oracle liveness for the price request.\n                liveness,\n                rootBundleProposal.proposer,\n                // Canonical value representing \"True\"; i.e. the proposed relay is valid.\n                int256(1e18)\n            )\n        returns (uint256) {\n            // Ensure that approval == 0 after the call so the increaseAllowance call below doesn't allow more tokens\n            // to transfer than intended.\n            bondToken.safeApprove(address(optimisticOracle), 0);\n        } catch {\n            // Cancel the bundle since the proposal failed.\n            _cancelBundle(requestAncillaryData);\n            return;\n        }\n\n        // Dispute the request that we just sent.\n        SkinnyOptimisticOracleInterface.Request memory ooPriceRequest = SkinnyOptimisticOracleInterface.Request({\n            proposer: rootBundleProposal.proposer,\n            disputer: address(0),\n            currency: bondToken,\n            settled: false,\n            proposedPrice: int256(1e18),\n            resolvedPrice: 0,\n            expirationTime: currentTime + liveness,\n            reward: 0,\n            finalFee: finalFee,\n            bond: bondAmount - finalFee,\n            customLiveness: liveness\n        });\n\n        bondToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        bondToken.safeIncreaseAllowance(address(optimisticOracle), bondAmount);\n        optimisticOracle.disputePriceFor(\n            identifier,\n            currentTime,\n            requestAncillaryData,\n            ooPriceRequest,\n            msg.sender,\n            address(this)\n        );\n\n        emit RootBundleDisputed(msg.sender, currentTime, requestAncillaryData);\n\n        // Finally, delete the state pertaining to the active proposal so that another proposer can submit a new bundle.\n        delete rootBundleProposal;\n    }\n\n    /**\n     * @notice Send unclaimed accumulated protocol fees to fee capture address.\n     * @param l1Token Token whose protocol fees the caller wants to disburse.\n     */\n    function claimProtocolFeesCaptured(address l1Token) public override nonReentrant {\n        IERC20(l1Token).safeTransfer(protocolFeeCaptureAddress, unclaimedAccumulatedProtocolFees[l1Token]);\n        emit ProtocolFeesCapturedClaimed(l1Token, unclaimedAccumulatedProtocolFees[l1Token]);\n        unclaimedAccumulatedProtocolFees[l1Token] = 0;\n    }\n\n    /**\n     * @notice Returns ancillary data containing all relevant root bundle data that voters can format into UTF8 and\n     * use to determine if the root bundle proposal is valid.\n     * @return ancillaryData Ancillary data that can be decoded into UTF8.\n     */\n    function getRootBundleProposalAncillaryData() public view override returns (bytes memory ancilla"
    }
  ]
}