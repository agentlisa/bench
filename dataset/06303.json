{
  "Title": "[G-15] Using fixed bytes is cheaper than using string",
  "Content": "\nAs a rule of thumb, use bytes for arbitrary-length raw byte data and string for arbitrary-length string (UTF-8) data.\nIf you can limit the length to a certain number of bytes, always use one of bytes1 to bytes32 because they are much cheaper.\n\n\n\n```solidity\nfile: src/functions/ConstantProduct2.sol\n\n69    function name() external pure override returns (string memory) {\n        return \"Constant Product 2\";\n    }\n\n\n73    function symbol() external pure override returns (string memory) {\n        return \"CP2\";\n    }\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/functions/ConstantProduct2.sol#L69-L71\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/functions/ConstantProduct2.sol#L73-L75\n\n\n```solidity\nFile: src/Aquifer.sol\n\n62                revert InitFailed(abi.decode(returnData, (string)));\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Aquifer.sol#L62\n\n\n```solidity\nfile: src/libraries/LibContractInfo.sol\n\n16    function getSymbol(address _contract) internal view returns (string memory symbol) {\n\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibContractInfo.sol#L16\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/functions/ConstantProduct2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IBeanstalkWellFunction} from \"src/interfaces/IBeanstalkWellFunction.sol\";\nimport {ProportionalLPToken2} from \"src/functions/ProportionalLPToken2.sol\";\nimport {LibMath} from \"src/libraries/LibMath.sol\";\n\n/**\n * @title ConstantProduct2\n * @author Publius\n * @notice Gas efficient Constant Product pricing function for Wells with 2 tokens.\n * @dev Constant Product Wells with 2 tokens use the formula:\n *  `b_0 * b_1 = s^2`\n *\n * Where:\n *  `s` is the supply of LP tokens\n *  `b_i` is the reserve at index `i`\n */\ncontract ConstantProduct2 is ProportionalLPToken2, IBeanstalkWellFunction {\n    using LibMath for uint256;\n\n    uint256 constant EXP_PRECISION = 1e12;\n\n    /**\n     * @dev `s = (b_0 * b_1)^(1/2)`\n     *\n     * When does this function overflow?\n     * ---------------------------------\n     *\n     * Let N be the length of the reserves array, and P be the precision multiplier\n     * defined in `EXP_PRECISION`.\n     *\n     * Assuming all tokens in reserves are at their maximum value simultaneously,\n     * this function will overflow when:\n     *\n     *  (10^X)^N * P >= MAX_UINT256 (~10^77)\n     *  10^(X*N) >= 10^77/P\n     *  (X*N)*ln(10) >= 77*ln(10) - ln(P)\n     *\n     *  ∴ X >= (1/N) * (77 - ln(P)/ln(10))\n     *\n     * ConstantProduct2 sets the constraints `N = 2` and `EXP_PRECISION = 1e12`,\n     * resulting in an upper bound of X = 32.5.\n     *\n     * In other words, {calcLpTokenSupply} overflows if all reserves are simultaneously\n     * >= 10^32.5, or about 100 trillion if tokens are measured to 18 decimal precision.\n     */\n    function calcLpTokenSupply(\n        uint256[] calldata reserves,\n        bytes calldata\n    ) external pure override returns (uint256 lpTokenSupply) {\n        lpTokenSupply = (reserves[0] * reserves[1] * EXP_PRECISION).sqrt();\n    }\n\n    /// @dev `b_j = s^2 / b_{i | i != j}`\n    /// @dev rounds up\n    function calcReserve(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256 lpTokenSupply,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        // Note: potential optimization is to use unchecked math here\n        reserve = lpTokenSupply ** 2;\n        reserve = LibMath.roundUpDiv(reserve, reserves[j == 1 ? 0 : 1] * EXP_PRECISION);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Constant Product 2\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"CP2\";\n    }\n\n    /// @dev `b_j = (b_0 * b_1 * r_j / r_i)^(1/2)`\n    /// Note: Always rounds down\n    function calcReserveAtRatioSwap(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        // use 512 muldiv for last mul to avoid overflow\n        reserve = (reserves[i] * reserves[j]).mulDiv(ratios[j], ratios[i]).sqrt();\n    }\n\n    /// @dev `b_j = b_i * r_j / r_i`\n    /// Note: Always rounds down\n    function calcReserveAtRatioLiquidity(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        reserve = reserves[i] * ratios[j] / ratios[i];\n    }\n}"
    },
    {
      "filename": "src/functions/ConstantProduct2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IBeanstalkWellFunction} from \"src/interfaces/IBeanstalkWellFunction.sol\";\nimport {ProportionalLPToken2} from \"src/functions/ProportionalLPToken2.sol\";\nimport {LibMath} from \"src/libraries/LibMath.sol\";\n\n/**\n * @title ConstantProduct2\n * @author Publius\n * @notice Gas efficient Constant Product pricing function for Wells with 2 tokens.\n * @dev Constant Product Wells with 2 tokens use the formula:\n *  `b_0 * b_1 = s^2`\n *\n * Where:\n *  `s` is the supply of LP tokens\n *  `b_i` is the reserve at index `i`\n */\ncontract ConstantProduct2 is ProportionalLPToken2, IBeanstalkWellFunction {\n    using LibMath for uint256;\n\n    uint256 constant EXP_PRECISION = 1e12;\n\n    /**\n     * @dev `s = (b_0 * b_1)^(1/2)`\n     *\n     * When does this function overflow?\n     * ---------------------------------\n     *\n     * Let N be the length of the reserves array, and P be the precision multiplier\n     * defined in `EXP_PRECISION`.\n     *\n     * Assuming all tokens in reserves are at their maximum value simultaneously,\n     * this function will overflow when:\n     *\n     *  (10^X)^N * P >= MAX_UINT256 (~10^77)\n     *  10^(X*N) >= 10^77/P\n     *  (X*N)*ln(10) >= 77*ln(10) - ln(P)\n     *\n     *  ∴ X >= (1/N) * (77 - ln(P)/ln(10))\n     *\n     * ConstantProduct2 sets the constraints `N = 2` and `EXP_PRECISION = 1e12`,\n     * resulting in an upper bound of X = 32.5.\n     *\n     * In other words, {calcLpTokenSupply} overflows if all reserves are simultaneously\n     * >= 10^32.5, or about 100 trillion if tokens are measured to 18 decimal precision.\n     */\n    function calcLpTokenSupply(\n        uint256[] calldata reserves,\n        bytes calldata\n    ) external pure override returns (uint256 lpTokenSupply) {\n        lpTokenSupply = (reserves[0] * reserves[1] * EXP_PRECISION).sqrt();\n    }\n\n    /// @dev `b_j = s^2 / b_{i | i != j}`\n    /// @dev rounds up\n    function calcReserve(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256 lpTokenSupply,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        // Note: potential optimization is to use unchecked math here\n        reserve = lpTokenSupply ** 2;\n        reserve = LibMath.roundUpDiv(reserve, reserves[j == 1 ? 0 : 1] * EXP_PRECISION);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Constant Product 2\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"CP2\";\n    }\n\n    /// @dev `b_j = (b_0 * b_1 * r_j / r_i)^(1/2)`\n    /// Note: Always rounds down\n    function calcReserveAtRatioSwap(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        // use 512 muldiv for last mul to avoid overflow\n        reserve = (reserves[i] * reserves[j]).mulDiv(ratios[j], ratios[i]).sqrt();\n    }\n\n    /// @dev `b_j = b_i * r_j / r_i`\n    /// Note: Always rounds down\n    function calcReserveAtRatioLiquidity(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        reserve = reserves[i] * ratios[j] / ratios[i];\n    }\n}"
    },
    {
      "filename": "src/Aquifer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuard} from \"oz/security/ReentrancyGuard.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {IAquifer} from \"src/interfaces/IAquifer.sol\";\nimport {Well, IWell, Call, IERC20} from \"src/Well.sol\";\nimport {LibClone} from \"src/libraries/LibClone.sol\";\n\n/**\n * @title Aquifer\n * @author Publius, Silo Chad, Brean\n * @notice Aquifer is a permissionless Well registry and factory.\n * @dev Aquifer deploys Wells by cloning a pre-deployed Well implementation.\n */\ncontract Aquifer is IAquifer, ReentrancyGuard {\n    using SafeCast for uint256;\n    using LibClone for address;\n\n    // A mapping of Well address to the Well implementation addresses\n    // Mapping gets set on Well deployment\n    mapping(address => address) wellImplementations;\n\n    constructor() ReentrancyGuard() {}\n\n    /**\n     * @dev\n     * Use `salt == 0` to deploy a new Well with `create`\n     * Use `salt > 0` to deploy a new Well with `create2`\n     */\n    function boreWell(\n        address implementation,\n        bytes calldata immutableData,\n        bytes calldata initFunctionCall,\n        bytes32 salt\n    ) external nonReentrant returns (address well) {\n        if (immutableData.length > 0) {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(immutableData, salt);\n            } else {\n                well = implementation.clone(immutableData);\n            }\n        } else {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(salt);\n            } else {\n                well = implementation.clone();\n            }\n        }\n\n        if (initFunctionCall.length > 0) {\n            (bool success, bytes memory returnData) = well.call(initFunctionCall);\n            if (!success) {\n                // Next 5 lines are based on https://ethereum.stackexchange.com/a/83577\n                if (returnData.length < 68) revert InitFailed(\"\");\n                assembly {\n                    returnData := add(returnData, 0x04)\n                }\n                revert InitFailed(abi.decode(returnData, (string)));\n            }\n        }\n\n        // The Aquifer address MUST be set, either (a) via immutable data during cloning,\n        // or (b) as a storage variable during an init function call. In either case,\n        // the address MUST match the address of the Aquifer that performed deployment.\n        if (IWell(well).aquifer() != address(this)) {\n            revert InvalidConfig();\n        }\n\n        // Save implementation\n        wellImplementations[well] = implementation;\n\n        emit BoreWell(\n            well,\n            implementation,\n            IWell(well).tokens(),\n            IWell(well).wellFunction(),\n            IWell(well).pumps(),\n            IWell(well).wellData()\n        );\n    }\n\n    function wellImplementation(address well) external view returns (address implementation) {\n        return wellImplementations[well];\n    }\n}"
    },
    {
      "filename": "src/libraries/LibContractInfo.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title LibContractInfo\n * @notice Contains logic to call functions that return information about a given contract.\n */\nlibrary LibContractInfo {\n    /**\n     * @notice gets the symbol of a given contract\n     * @param _contract The contract to get the symbol of\n     * @return symbol The symbol of the contract\n     * @dev if the contract does not have a symbol function, the first 4 bytes of the address are returned\n     */\n    function getSymbol(address _contract) internal view returns (string memory symbol) {\n        (bool success, bytes memory data) = _contract.staticcall(abi.encodeWithSignature(\"symbol()\"));\n        symbol = new string(4);\n        if (success) {\n            symbol = abi.decode(data, (string));\n        } else {\n            assembly {\n                mstore(add(symbol, 0x20), shl(224, shr(128, _contract)))\n            }\n        }\n    }\n\n    /**\n     * @notice gets the name of a given contract\n     * @param _contract The contract to get the name of\n     * @return name The name of the contract\n     * @dev if the contract does not have a name function, the first 8 bytes of the address are returned\n     */\n    function getName(address _contract) internal view returns (string memory name) {\n        (bool success, bytes memory data) = _contract.staticcall(abi.encodeWithSignature(\"name()\"));\n        name = new string(8);\n        if (success) {\n            name = abi.decode(data, (string));\n        } else {\n            assembly {\n                mstore(add(name, 0x20), shl(224, shr(128, _contract)))\n            }\n        }\n    }\n\n    /**\n     * @notice gets the decimals of a given contract\n     * @param _contract The contract to get the decimals of\n     * @return decimals The decimals of the contract\n     * @dev if the contract does not have a decimals function, 18 is returned\n     */\n    function getDecimals(address _contract) internal view returns (uint8 decimals) {\n        (bool success, bytes memory data) = _contract.staticcall(abi.encodeWithSignature(\"decimals()\"));\n        decimals = success ? abi.decode(data, (uint8)) : 18; // default to 18 decimals\n    }\n}"
    }
  ]
}