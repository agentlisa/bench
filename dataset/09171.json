{
  "Title": "[G-21] `abi.encode()` is less efficient than `abi.encodePacked()`",
  "Content": "\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/CrvDepositorWrapper.sol   #1\n\n93:                   abi.encode(IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, minOut),\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/CrvDepositorWrapper.sol#L93>\n\n```solidity\nFile: convex-platform/contracts/contracts/StashFactoryV2.sol   #2\n\n88:           bytes memory data = abi.encode(rewarded_token);\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/StashFactoryV2.sol#L88>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/CrvDepositorWrapper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { IVault, IPriceOracle, IAsset } from \"./Interfaces.sol\";\nimport { IVault } from \"./Interfaces.sol\";\n\ninterface ICrvDepositor {\n    function depositFor(\n        address to,\n        uint256 _amount,\n        bool _lock,\n        address _stakeAddress\n    ) external;\n}\n\n/**\n * @title   BalInvestor\n * @notice  Deposits $BAL into a BAL/WETH BPT. Hooks into TWAP to determine minOut.\n * @dev     Abstract contract for depositing BAL -> balBPT -> auraBAL via crvDepositor\n */\nabstract contract BalInvestor {\n    using SafeERC20 for IERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    address public immutable BAL;\n    address public immutable WETH;\n    address public immutable BALANCER_POOL_TOKEN;\n    bytes32 public immutable BAL_ETH_POOL_ID;\n\n    constructor(\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) {\n        (\n            address poolAddress, /* */\n\n        ) = _balancerVault.getPool(_balETHPoolId);\n        require(poolAddress != address(0), \"!poolAddress\");\n\n        BALANCER_VAULT = _balancerVault;\n        BAL = _bal;\n        WETH = _weth;\n        BALANCER_POOL_TOKEN = poolAddress;\n        BAL_ETH_POOL_ID = _balETHPoolId;\n    }\n\n    function _setApprovals() internal {\n        IERC20(WETH).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        IERC20(BAL).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _getBptPrice() internal view returns (uint256) {\n        IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);\n\n        queries[0].variable = IPriceOracle.Variable.BPT_PRICE;\n        queries[0].secs = 3600; // last hour\n        queries[0].ago = 0; // now\n\n        // Gets the balancer time weighted average price denominated in BAL\n        return IPriceOracle(BALANCER_POOL_TOKEN).getTimeWeightedAverage(queries)[0];\n    }\n\n    function _getMinOut(uint256 amount, uint256 minOutBps) internal view returns (uint256) {\n        // Gets the balancer time weighted average price denominated in BAL\n        // e.g.  if 1 BAL == 0.4 BPT, bptOraclePrice == 2.5\n        uint256 bptOraclePrice = _getBptPrice();\n        // e.g. minOut = (((100e18 * 1e18) / 2.5e18) * 9980) / 10000;\n        // e.g. minout = 39.92e18\n        uint256 minOut = (((amount * 1e18) / bptOraclePrice) * minOutBps) / 10000;\n        return minOut;\n    }\n\n    function _investBalToPool(uint256 amount, uint256 minOut) internal {\n        IERC20(BAL).safeTransferFrom(msg.sender, address(this), amount);\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(BAL);\n        assets[1] = IAsset(WETH);\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = amount;\n        maxAmountsIn[1] = 0;\n\n        BALANCER_VAULT.joinPool(\n            BAL_ETH_POOL_ID,\n            address(this),\n            address(this),\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, minOut),\n                false // Don't use internal balances\n            )\n        );\n    }\n}\n\n/**\n * @title   CrvDepositorWrapper\n * @notice  Converts BAL -> balBPT and then wraps to auraBAL via the crvDepositor\n */\ncontract CrvDepositorWrapper is BalInvestor {\n    address public immutable crvDeposit;\n\n    constructor(\n        address _crvDeposit,\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) BalInvestor(_balancerVault, _bal, _weth, _balETHPoolId) {\n        crvDeposit = _crvDeposit;\n    }\n\n    function setApprovals() external {\n        _setApprovals();\n        require(IERC20(BALANCER_POOL_TOKEN).approve(crvDeposit, type(uint256).max), \"!approval\");\n    }\n\n    /**\n     * @dev Gets minimum output based on BPT oracle price\n     * @param _amount Units of BAL to deposit\n     * @param _outputBps Multiplier where 100% == 10000, 99.5% == 9950 and 98% == 9800\n     * @return minOut Units of BPT to expect as output\n     */\n    function getMinOut(uint256 _amount, uint256 _outputBps) external view returns (uint256) {\n        return _getMinOut(_amount, _outputBps);\n    }\n\n    function deposit(\n        uint256 _amount,\n        uint256 _minOut,\n        bool _lock,\n        address _stakeAddress\n    ) external {\n        _investBalToPool(_amount, _minOut);\n        uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));\n        ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/StashFactoryV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/IProxyFactory.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   StashFactoryV2\n * @author  ConvexFinance\n * @notice  Factory to deploy reward stash contracts that handle extra rewards\n */\ncontract StashFactoryV2 {\n    using Address for address;\n\n    bytes4 private constant rewarded_token = 0x16fa50b1; //rewarded_token()\n    bytes4 private constant reward_tokens = 0x54c49fe9; //reward_tokens(uint256)\n    bytes4 private constant rewards_receiver = 0x01ddabf1; //rewards_receiver(address)\n\n    address public immutable operator;\n    address public immutable rewardFactory;\n    address public immutable proxyFactory;\n\n    address public v1Implementation;\n    address public v2Implementation;\n    address public v3Implementation;\n\n    event StashCreated(address stash, uint256 stashVersion);\n\n    /**\n     * @param _operator       Operator is Booster\n     * @param _rewardFactory  Factory that creates reward contract that are \n     *                        VirtualBalanceRewardPool's used for extra pool rewards\n     * @param _proxyFactory   Deploy proxies with stash implementation\n     */\n    constructor(address _operator, address _rewardFactory, address _proxyFactory) public {\n        operator = _operator;\n        rewardFactory = _rewardFactory;\n        proxyFactory = _proxyFactory;\n    }\n\n    function setImplementation(address _v1, address _v2, address _v3) external{\n        require(msg.sender == IDeposit(operator).owner(),\"!auth\");\n\n        v1Implementation = _v1;\n        v2Implementation = _v2;\n        v3Implementation = _v3;\n    }\n\n    //Create a stash contract for the given gauge.\n    //function calls are different depending on the version of curve gauges so determine which stash type is needed\n    function CreateStash(uint256 _pid, address _gauge, address _staker, uint256 _stashVersion) external returns(address){\n        require(msg.sender == operator, \"!authorized\");\n\n        if(_stashVersion == uint256(3) && IsV3(_gauge)){\n            //v3\n            require(v3Implementation!=address(0),\"0 impl\");\n            address stash = IProxyFactory(proxyFactory).clone(v3Implementation);\n            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);\n            emit StashCreated(stash, _stashVersion);\n            return stash;\n        }else if(_stashVersion == uint256(1) && IsV1(_gauge)){\n            //v1\n            require(v1Implementation!=address(0),\"0 impl\");\n            address stash = IProxyFactory(proxyFactory).clone(v1Implementation);\n            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);\n            emit StashCreated(stash, _stashVersion);\n            return stash;\n        }else if(_stashVersion == uint256(2) && !IsV3(_gauge) && IsV2(_gauge)){\n            //v2\n            require(v2Implementation!=address(0),\"0 impl\");\n            address stash = IProxyFactory(proxyFactory).clone(v2Implementation);\n            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);\n            emit StashCreated(stash, _stashVersion);\n            return stash;\n        }\n        bool isV1 = IsV1(_gauge);\n        bool isV2 = IsV2(_gauge);\n        bool isV3 = IsV3(_gauge);\n        require(!isV1 && !isV2 && !isV3,\"stash version mismatch\");\n        return address(0);\n    }\n\n    function IsV1(address _gauge) private returns(bool){\n        bytes memory data = abi.encode(rewarded_token);\n        (bool success,) = _gauge.call(data);\n        return success;\n    }\n\n    function IsV2(address _gauge) private returns(bool){\n        bytes memory data = abi.encodeWithSelector(reward_tokens,uint256(0));\n        (bool success,) = _gauge.call(data);\n        return success;\n    }\n\n    function IsV3(address _gauge) private returns(bool){\n        bytes memory data = abi.encodeWithSelector(rewards_receiver,address(0));\n        (bool success,) = _gauge.call(data);\n        return success;\n    }\n}"
    }
  ]
}