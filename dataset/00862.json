{
  "Title": "H-1: Lowering the gauge weight can disrupt accounting, potentially leading to both excessive fund distribution and a loss of funds.",
  "Content": "# Issue H-1: Lowering the gauge weight can disrupt accounting, potentially leading to both excessive fund distribution and a loss of funds. \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/94 \n\n## Found by \n0xDetermination, ZanyBonzy, bitsurfer, bughuntoor, hash\n## Summary\nSimilar issues were found by users [0xDetermination](https://github.com/code-423n4/2023-08-verwa-findings/issues/386) and [bart1e](https://github.com/code-423n4/2023-08-verwa-findings/issues/206) in the Canto veRWA audit, which uses a similar gauge controller type.\n## Vulnerability Detail\n - When the _change_gauge_weight function is called, the `points_weight[addr][next_time].bias` and`time_weight[addr]` are updated - the slope is not.  \n```L568\ndef _change_gauge_weight(addr: address, weight: uint256):\n    # Change gauge weight\n    # Only needed when testing in reality\n    gauge_type: int128 = self.gauge_types_[addr] - 1\n    old_gauge_weight: uint256 = self._get_weight(addr)\n    type_weight: uint256 = self._get_type_weight(gauge_type)\n    old_sum: uint256 = self._get_sum(gauge_type)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    self.points_weight[addr][next_time].bias = weight\n    self.time_weight[addr] = next_time\n\n    new_sum: uint256 = old_sum + weight - old_gauge_weight\n    self.points_sum[gauge_type][next_time].bias = new_sum\n    self.time_sum[gauge_type] = next_time\n\n    _total_weight = _total_weight + new_sum * type_weight - old_sum * type_weight\n    self.points_total[next_time] = _total_weight\n    self.time_total = next_time\n\n    log NewGaugeWeight(addr, block.timestamp, weight, _total_weight)\n  ```  \n  \n - The equation  ***f(t) = c - mx*** represents the gauge's decay equation before the weight is reduced. In this equation, `m` is the slope. After the weight is reduced by an amount `k` using the `change_gauge_weight` function, the equation becomes ***f(t) = c - k - mx*** The slope m remains unchanged, but the t-axis intercept changes from ***t<sub>1</sub> = c/m*** to ***t<sub>2</sub>  = (c-k)/m***.\n - Slope adjustments that should be applied to the global slope when decay reaches 0 are stored in the `changes_sum` hashmap. And is not affected by changes in gauge weight. Consequently, there's a time window ***t<sub>1</sub> - t<sub>2</sub>*** during which the earlier slope changes applied to the global state when user called `vote_for_gauge_weights` function remains applied even though they should have been subtracted. This in turn creates a situation in which the global weightis less than the sum of the individual gauge weights, resulting in an accounting error.\n - So, in the `CvgRewards` contract when the `writeStakingRewards` function invokes the `_checkpoint`, which subsequently triggers the `gauge_relative_weight_writes` function for the relevant time period, the calculated relative weight becomes inflated, leading to an increase in the distributed rewards. If all available rewards are distributed before the entire array is processed, the remaining users will receive no rewards.\"\n - The issue mainly arises when a gauge's weight has completely diminished to zero. This is certain to happen if a gauge with a non-zero bias, non-zero slope, and a t-intercept exceeding the current time  is killed using `kill_gauge` function.\n - Additionally, decreasing a gauge's weight introduces inaccuracies in its decay equation, as is evident in the t-intercept.\n## Impact\nThe way rewards are calculated is broken, leading to an uneven distribution of rewards, with some users receiving too much and others receiving nothing.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/GaugeController.vy#L568C1-L590C1\n\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Rewards/CvgRewards.sol#L189\n\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Rewards/CvgRewards.sol#L235C1-L235C91\n\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/GaugeController.vy#L493\n\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/GaugeController.vy#L456C1-L475C17\n\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/GaugeController.vy#L603C1-L611C54\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDisable weight reduction, or only allow reset to 0.\n\n\n\n## Discussion\n\n**0xR3vert**\n\nHello,\n\nThanks a lot for your attention.\n\nThank you for your insightful observation. Upon thorough examination, we acknowledge that such an occurrence could indeed jeopardize the protocol. We are currently exploring multiple solutions to address this issue.\nWe are considering removing the function change_gauge_weight entirely and not distributing CVG inflation on killed gauges, similar to how Curve Protocol handles their gauges.\n\nTherefore, in conclusion, we must consider your issue as valid.\n\nRegards,\nConvergence Team\n\n**CergyK**\n\nEscalate\n\nThe severity of this issue is low for two reasons:\n\n- Admin endpoint, the admin can be trusted to not use this feature lightly, and take preventative measures to ensure that accounting is not disrupted, such as ensuring that there is no current votes for a gauge and locking voting to set a weight.\n\n- _change_gauge_weight has this exact implementation in the battle-tested curve dao contract (in usage for more than 3 years now without notable issue):\nhttps://github.com/curvefi/curve-dao-contracts/blob/master/contracts/GaugeController.vy\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The severity of this issue is low for two reasons:\n> \n> - Admin endpoint, the admin can be trusted to not use this feature lightly, and take preventative measures to ensure that accounting is not disrupted, such as ensuring that there is no current votes for a gauge and locking voting to set a weight.\n> \n> - _change_gauge_weight has this exact implementation in the battle-tested curve dao contract (in usage for more than 3 years now without notable issue):\n> https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/GaugeController.vy\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xDetermination**\n\nAddressing the escalation points:\n1. If there are no current votes for a gauge, the weight can't be lowered. Also, locking voting is not really relevant for this issue. I don't think there are any preventative measures that can be taken other than never lowering the gauge weight.\n2. This function is in the live Curve contract, but it has never been called (see https://etherscan.io/advanced-filter?fadd=0x2f50d538606fa9edd2b11e2446beb18c9d5846bb&tadd=0x2f50d538606fa9edd2b11e2446beb18c9d5846bb&mtd=0xd4d2646e%7eChange_gauge_weight)\n\n**nevillehuang**\n\nI think all issues regarding killing and changing weight for gauges (#18, #94, #122,#192), all the arguments are assuming the following:\n\n1. The admin would perform appropriate measures before executing admin gated functions - To me, this is not clear cut like the way admin input would be. From sponsor confirmation, you would understand that they did not understand the severity of performing such issues so it wouldn't be unreasonable to say they are not aware enough to perform such preventive measures before this functions are called. If not, I think this should have been explicitly mentioned in known design considerations in the contest details and/or the contract details [here](https://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/technical-docs/lock/GaugeController.md#lock-all-gauges-vote), where the purpose of locking and pausing votes are stated.\n\n2. Afaik, when @CergyK mentions the admin can take preventive measures such as ensuring no current vote and locking votes, then what would happen during a scenario when the current gauge that an admin wants to change weight or kill gauge (e.g. malicious token) has votes assigned. Wouldn't that essentially mean admin can never do so, and therefore breaks core functionality?\n\n3. The admin would never call `change_gauge_weight` because it has never been called in a live curve contract - This is pure speculation, just because curve doesn't call it, it does not mean convergence would never call it.\n\n\n**Czar102**\n\nSee my comment [here](https://github.com/sherlock-audit/2023-11-convergence-judging/issues/192#issuecomment-1889099971).\n\nPlanning to reject the escalation.\n\n**nevillehuang**\n\n@0xDetermination @deadrosesxyz @10xhash\n\nDo you think this is a duplicate of #192 because they seem similar. I am unsure if fixing one issue will fix another, given at the point of contest, it is intended to invoke both functions.\n\n**0xDetermination**\n\n@nevillehuang I think any issue with a root cause of 'lowering gauge weight' should be considered the same if I understand the duplication rules correctly. So it seems like these are all dupes.\n\n**Czar102**\n\nAs long as an issue is valid and the root cause is the same, they are currently considered duplicates. Both #192 and #94 have a root cause of not handling the slope in `_change_gauge_weight`, despite having different impacts.\n\n**Czar102**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [CergyK](https://github.com/sherlock-audit/2023-11-convergence-judging/issues/94/#issuecomment-1869547286): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Locking/GaugeController.vy",
      "content": "# @version 0.3.7\n\n\"\"\"\n@title Cvg-Finance - Gauge Controller\n@license MIT\n@notice Controls liquidity gauges and the issuance of coins through the gauges.\n\"\"\"\n# Adpated fork from: Curve Finance's gauge controller\n# Many thanks to Curve Finance\n# https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/GaugeController.vy\n\n# 7 * 86400 seconds - all future times are rounded by week\nWEEK: constant(uint256) = 604800\n\n# Cannot change weight votes more often than once in 10 days\nWEIGHT_VOTE_DELAY: constant(uint256) = 10 * 86400\n\n\nstruct Point:\n    bias: uint256\n    slope: uint256\n\nstruct VotedSlope:\n    slope: uint256\n    power: uint256\n    end: uint256\n\nstruct WeightType:\n    weight: uint256\n    type_weight: uint256\n    gauge_type: int128\n\nstruct TokenData:\n    gaugeAddress : address\n    nft_slopes : VotedSlope\n    last_nft_vote: uint256\n\nstruct TokenViewInput:\n    tokenId : uint256\n    gaugeAddresses: DynArray[address, 100]\n\nstruct TokenViewOutput:\n    tokenId : uint256\n    nft_power : uint256\n    balanceOf  : uint256\n    gaugeData: DynArray[TokenData, 100]\n\n\n\ninterface CvgRewards:\n    def addGauge(gaugeAddress : address):nonpayable\n    def removeGauge(gaugeAddress : address):nonpayable\n\ninterface VotingPowerEscrow:\n    def get_last_nft_slope(tokenId: uint256) -> int128: view\n    def locked__end(tokenId: uint256) -> uint256: view\n    def balanceOf(tokenId: uint256) -> uint256: view\n    \n\ninterface LockingPositionManager:\n    def ownerOf(tokenId: uint256) -> address: view\n    def unlockingTimestampPerToken(tokenId:uint256) -> uint256:view\n\ninterface LockingPositionService:\n    def isContractLocker(contract: address) -> bool: view\n\ninterface LockingPositionDelegate:\n    def delegatedVeCvg(tokenId: uint256) -> address : view\n\ninterface CvgControlTower:\n    def lockingPositionManager() -> LockingPositionManager: view\n    def lockingPositionService() -> LockingPositionService: view\n    def lockingPositionDelegate() -> LockingPositionDelegate: view\n    def votingPowerEscrow() -> VotingPowerEscrow: view\n    def treasuryDao() -> address:view\n    def cvgRewards() -> CvgRewards: view\n\n    def isStakingContract(addr: address) -> bool:view\n    \nevent CommitOwnership:\n    admin: address\n\nevent ApplyOwnership:\n    admin: address\n\nevent AddType:\n    name: String[64]\n    type_id: int128\n\nevent NewTypeWeight:\n    type_id: int128\n    time: uint256\n    weight: uint256\n    total_weight: uint256\n\nevent NewGaugeWeight:\n    gauge_address: address\n    time: uint256\n    weight: uint256\n    total_weight: uint256\n\nevent VoteForGauge:\n    time: uint256\n    tokenId: uint256\n    gauge_addr: address\n    weight: uint256\n\nevent NewGauge:\n    addr: address\n    gauge_type: int128\n    weight: uint256\n\n\nMULTIPLIER: constant(uint256) = 10 ** 18\n\nadmin: public(address)  # Can and will be a smart contract\nfuture_admin: public(address)  # Can and will be a smart contract\n\ncontrol_tower: public(CvgControlTower) #Control tower\n\n# Gauge parameters\n# All numbers are \"fixed point\" on the basis of 1e18\nn_gauge_types: public(int128)\nn_gauges: public(int128)\ngauge_type_names: public(HashMap[int128, String[64]])\n\n# Needed for enumeration\ngauges: public(address[1000000000])\n\n# we increment values by 1 prior to storing them here so we can rely on a value\n# of zero as meaning the gauge has not been set\ngauge_types_: HashMap[address, int128]\n\nvote_nft_slopes: public(HashMap[uint256, HashMap[address, VotedSlope]])  # nft -> gauge_addr -> VotedSlope\nvote_nft_power: public(HashMap[uint256, uint256])  # Total vote power used by nft\nlast_nft_vote: public(HashMap[uint256, HashMap[address, uint256]])  # Last nft vote's timestamp for each gauge address\n\n# Past and scheduled points for gauge weight, sum of weights per type, total weight\n# Point is for bias+slope\n# changes_* are for changes in slope\n# time_* are for the last change timestamp\n# timestamps are rounded to whole weeks\n\npoints_weight: public(HashMap[address, HashMap[uint256, Point]])  # gauge_addr -> time -> Point\nchanges_weight: HashMap[address, HashMap[uint256, uint256]]  # gauge_addr -> time -> slope\ntime_weight: public(HashMap[address, uint256])  # gauge_addr -> last scheduled time (next week)\n\npoints_sum: public(HashMap[int128, HashMap[uint256, Point]])  # type_id -> time -> Point\nchanges_sum: HashMap[int128, HashMap[uint256, uint256]]  # type_id -> time -> slope\ntime_sum: public(uint256[1000000000])  # type_id -> last scheduled time (next week)\n\npoints_total: public(HashMap[uint256, uint256])  # time -> total weight\ntime_total: public(uint256)  # last scheduled time\n\npoints_type_weight: public(HashMap[int128, HashMap[uint256, uint256]])  # type_id -> time -> type weight\ntime_type_weight: public(uint256[1000000000])  # type_id -> last scheduled time (next week)\n# @notice Determines whether the vote is locked or not; when it is locked, all the gauges are not available for the vote.\nisLock: public(bool)\n# @notice Allowed addresses to lock votes.\nlockers: public(HashMap[address, bool])\n# @notice Determine whether  gauge is killed: killed gauges weigh 0.  Users cannot vote on a gauge but can remove their votes from it.\nkilled_gauges: public(HashMap[address, bool])\n\n# @notice Determining whether a gauge has its vote activated.\nvote_activated: public(HashMap[address, bool])\n\ninitialized: public(bool)\n\n@external\ndef __init__():\n    \"\"\"\n    @notice Contract constructor.\n    @dev The contract has an initializer to prevent the take over of the implementation.\n    \"\"\"\n    assert self.initialized == False, \"ALREADY_INIT\" #dev: contract is already initialized\n    self.initialized = True\n\n@external\ndef initialize(setControlTower: CvgControlTower):\n    \"\"\"\n    @notice Contract Initializer.\n    @param setControlTower Convergence ControlTower contract address\n    \"\"\"\n    assert self.initialized == False, \"ALREADY_INIT\" #dev: contract is already initialized\n    self.initialized = True\n    assert setControlTower.address != ZERO_ADDRESS, \"ZERO_ADDRESS\"\n\n    self.control_tower = setControlTower\n    self.admin = msg.sender\n    self.time_total = block.timestamp / WEEK * WEEK\n\n\n@external\ndef set_lock(isLock: bool):\n    \"\"\"\n    @notice Lock the vote on all gauges.\n    @dev This function is called every cycle by CvgRewards to block votes during the weekly distribution of Cvg.\n    @param isLock state of lock\n    \"\"\"\n    assert self.lockers[msg.sender], \"NOT_LOCKER\"\n    self.isLock = isLock\n\n@external\ndef toggle_locker(lockerAddress: address):\n    \"\"\"\n    @notice Add/remove an address as vote locker.\n    @param lockerAddress address to add/remove\n    \"\"\"\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\n    self.lockers[lockerAddress] =  not self.lockers[lockerAddress]\n\n@external\ndef toggle_vote_pause(gaugeAddress: address):\n    \"\"\"\n    @notice Toggle the vote pause for a gauge.\n    @dev Will be used when we deploy a staking contract after the protocol GENESIS.\n        The staking contract will be deployed in a paused state, then we will activate votes on it ONLY after cycle N+1\n        cycle of deployment to avoid burning CVG rewards.\n    @param gaugeAddress address to pause/unpause\n    \"\"\"\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\n    self.vote_activated[gaugeAddress] =  not self.vote_activated[gaugeAddress]\n\n@external\ndef toggle_votes_pause(gaugeAddresses: DynArray[address, 40]):\n    \"\"\"\n    @notice Toggle the pause state for a list of gauges.\n    @param gaugeAddresses list of gauge address.\n    \"\"\"\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\n    for gaugeAddr in gaugeAddresses:\n        self.vote_activated[gaugeAddr] =  not self.vote_activated[gaugeAddr]\n\n@external\ndef commit_transfer_ownership(addr: address):\n    \"\"\"\n    @notice Transfer ownership of GaugeController to `addr`.\n    @param addr Address to have ownership transferred to\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.future_admin = addr\n    log CommitOwnership(addr)\n\n\n@external\ndef apply_transfer_ownership():\n    \"\"\"\n    @notice Apply pending ownership transfer.\n    \"\"\"\n    assert msg.sender == self.future_admin  # dev: future admin only\n    _admin: address = self.future_admin\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\n    self.admin = _admin\n    log ApplyOwnership(_admin)\n\n\n@external\n@view\ndef gauge_types(_addr: address) -> int128:\n    \"\"\"\n    @notice Get gauge type for address.\n    @param _addr Gauge address\n    @return Gauge type id\n    \"\"\"\n    gauge_type: int128 = self.gauge_types_[_addr]\n    assert gauge_type != 0\n\n    return gauge_type - 1\n\n\n@internal\ndef _get_type_weight(gauge_type: int128) -> uint256:\n    \"\"\"\n    @notice Fill historic type weights week-over-week for missed checkins.\n            and return the type weight for the future week\n    @param gauge_type Gauge type id\n    @return Type weight\n    \"\"\"\n    t: uint256 = self.time_type_weight[gauge_type]\n    if t > 0:\n        w: uint256 = self.points_type_weight[gauge_type][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            self.points_type_weight[gauge_type][t] = w\n            if t > block.timestamp:\n                self.time_type_weight[gauge_type] = t\n        return w\n    else:\n        return 0\n\n\n@internal\ndef _get_sum(gauge_type: int128) -> uint256:\n    \"\"\"\n    @notice Fill sum of gauge weights for the same type week-over-week for.\n            missed checkins and return the sum for the future week\n    @param gauge_type Gauge type id\n    @return Sum of weights\n    \"\"\"\n    t: uint256 = self.time_sum[gauge_type]\n    if t > 0:\n        pt: Point = self.points_sum[gauge_type][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            d_bias: uint256 = pt.slope * WEEK\n            if pt.bias > d_bias:\n                pt.bias -= d_bias\n                d_slope: uint256 = self.changes_sum[gauge_type][t]\n                pt.slope -= d_slope\n            else:\n                pt.bias = 0\n                pt.slope = 0\n            self.points_sum[gauge_type][t] = pt\n            if t > block.timestamp:\n                self.time_sum[gauge_type] = t\n        return pt.bias\n    else:\n        return 0\n\n\n@internal\ndef _get_total() -> uint256:\n    \"\"\"\n    @notice Fill historic total weights week-over-week for missed checkins.\n            and return the total for the future week\n    @return Total weight\n    \"\"\"\n    t: uint256 = self.time_total\n    _n_gauge_types: int128 = self.n_gauge_types\n    if t > block.timestamp:\n        # If we have already checkpointed - still need to change the value\n        t -= WEEK\n    pt: uint256 = self.points_total[t]\n\n    for gauge_type in range(100):\n        if gauge_type == _n_gauge_types:\n            break\n        self._get_sum(gauge_type)\n        self._get_type_weight(gauge_type)\n\n    for i in range(500):\n        if t > block.timestamp:\n            break\n        t += WEEK\n        pt = 0\n        # Scales as n_types * n_unchecked_weeks (hopefully 1 at most)\n        for gauge_type in range(100):\n            if gauge_type == _n_gauge_types:\n                break\n            type_sum: uint256 = self.points_sum[gauge_type][t].bias\n            type_weight: uint256 = self.points_type_weight[gauge_type][t]\n            pt += type_sum * type_weight\n        self.points_total[t] = pt\n\n        if t > block.timestamp:\n            self.time_total = t\n    return pt\n\n\n@internal\ndef _get_weight(gauge_addr: address) -> uint256:\n    \"\"\"\n    @notice Fill historic gauge weights week-over-week for missed checkins\n            and return the total for the future week.\n    @param gauge_addr Address of the gauge\n    @return Gauge weight\n    \"\"\"\n    t: uint256 = self.time_weight[gauge_addr]\n    if t > 0:\n        pt: Point = self.points_weight[gauge_addr][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            d_bias: uint256 = pt.slope * WEEK\n            if pt.bias > d_bias:\n                pt.bias -= d_bias\n                d_slope: uint256 = self.changes_weight[gauge_addr][t]\n                pt.slope -= d_slope\n            else:\n                pt.bias = 0\n                pt.slope = 0\n            self.points_weight[gauge_addr][t] = pt\n            if t > block.timestamp:\n                self.time_weight[gauge_addr] = t\n        return pt.bias\n    else:\n        return 0\n\n\n@external\ndef add_gauge(addr: address, gauge_type: int128, weight: uint256):\n    \"\"\"\n    @notice Add gauge `addr` of type `gauge_type` with weight `weight`.\n    @param addr Gauge address\n    @param gauge_type Gauge type\n    @param weight Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin\n    assert (gauge_type >= 0) and (gauge_type < self.n_gauge_types)\n    assert self.gauge_types_[addr] == 0 , \"GAUGE_ALREADY_ADDED\" # dev: cannot add the same gauge twice\n    assert (self.control_tower).isStakingContract(addr), \"NOT_A_STAKING_CONTRACT\"\n\n    n: int128 = self.n_gauges\n    self.n_gauges = n + 1\n    self.gauges[n] = addr\n\n    self.gauge_types_[addr] = gauge_type + 1\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    if weight > 0:\n        _type_weight: uint256 = self._get_type_weight(gauge_type)\n        _old_sum: uint256 = self._get_sum(gauge_type)\n        _old_total: uint256 = self._get_total()\n\n        self.points_sum[gauge_type][next_time].bias = weight + _old_sum\n        self.time_sum[gauge_type] = next_time\n        self.points_total[next_time] = _old_total + _type_weight * weight\n        self.time_total = next_time\n\n        self.points_weight[addr][next_time].bias = weight\n\n    if self.time_sum[gauge_type] == 0:\n        self.time_sum[gauge_type] = next_time\n    self.time_weight[addr] = next_time\n\n\n    self.control_tower.cvgRewards().addGauge(addr)\n    log NewGauge(addr, gauge_type, weight)\n\n\n@external\ndef checkpoint():\n    \"\"\"\n    @notice Checkpoint to fill data common for all gauges.\n    \"\"\"\n    self._get_total()\n\n\n@external\ndef checkpoint_gauge(addr: address):\n    \"\"\"\n    @notice Checkpoint to fill data for both a specific gauge and common for all gauges.\n    @param addr Gauge address\n    \"\"\"\n    self._get_weight(addr)\n    self._get_total()\n\n\n@internal\n@view\ndef _gauge_relative_weight(addr: address, time: uint256) -> uint256:\n    \"\"\"\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18.\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\n            inflation_rate * relative_weight / 1e18\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    t: uint256 = time / WEEK * WEEK\n    _total_weight: uint256 = self.points_total[t]\n\n    if _total_weight > 0:\n        gauge_type: int128 = self.gauge_types_[addr] - 1\n        _type_weight: uint256 = self.points_type_weight[gauge_type][t]\n        _gauge_weight: uint256 = self.points_weight[addr][t].bias\n        return MULTIPLIER * _type_weight * _gauge_weight / _total_weight\n\n    else:\n        return 0\n\n\n@external\n@view\ndef gauge_relative_weight(addr: address, time: uint256) -> uint256:\n    \"\"\"\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18.\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\n            inflation_rate * relative_weight / 1e18\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    return self._gauge_relative_weight(addr, time)\n\n\n@external\ndef gauge_relative_weight_write(addr: address) -> uint256:\n    \"\"\"\n    @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n            values for type and gauge records.\n    @dev Any address can call, however nothing is recorded if the values are filled already.\n    @param addr Gauge address\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    self._get_weight(addr)\n    self._get_total()  # Also calculates get_sum\n    return self._gauge_relative_weight(addr, block.timestamp)\n\n\n@external\ndef gauge_relative_weight_writes(addrs: DynArray[address, 100]) :\n    \"\"\"\n    @notice Get gauge weight normalized to 1e18 and also fill all the unfilled.\n            values for type and gauge records\n    @dev Any address can call, however nothing is recorded if the values are filled already.\n    @param addrs Gauge address\n    \"\"\"\n    for addr in addrs:\n        self._get_weight(addr)\n        self._get_total()  # Also calculates get_sum\n\n\n@internal\ndef _change_type_weight(type_id: int128, weight: uint256):\n    \"\"\"\n    @notice Change type weight.\n    @param type_id Type id\n    @param weight New type weight\n    \"\"\"\n    old_weight: uint256 = self._get_type_weight(type_id)\n    old_sum: uint256 = self._get_sum(type_id)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    _total_weight = _total_weight + old_sum * weight - old_sum * old_weight\n    self.points_total[next_time] = _total_weight\n    self.points_type_weight[type_id][next_time] = weight\n    self.time_total = next_time\n    self.time_type_weight[type_id] = next_time\n\n    log NewTypeWeight(type_id, next_time, weight, _total_weight)\n\n\n@external\ndef add_type(_name: String[64], weight: uint256):\n    \"\"\"\n    @notice Add gauge type with name `_name` and weight `weight`.\n    @param _name Name of gauge type\n    @param weight Weight of gauge type\n    \"\"\"\n    assert msg.sender == self.admin\n    type_id: int128 = self.n_gauge_types\n    self.gauge_type_names[type_id] = _name\n    self.n_gauge_types = type_id + 1\n    if weight != 0:\n        self._change_type_weight(type_id, weight)\n        log AddType(_name, type_id)\n\n\n@external\ndef change_type_weight(type_id: int128, weight: uint256):\n    \"\"\"\n    @notice Change gauge type `type_id` weight to `weight`.\n    @param type_id Gauge type id\n    @param weight New Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin\n    self._change_type_weight(type_id, weight)\n\n\n@internal\ndef _change_gauge_weight(addr: address, weight: uint256):\n    # Change gauge weight\n    # Only needed when testing in reality\n    gauge_type: int128 = self.gauge_types_[addr] - 1\n    old_gauge_weight: uint256 = self._get_weight(addr)\n    type_weight: uint256 = self._get_type_weight(gauge_type)\n    old_sum: uint256 = self._get_sum(gauge_type)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    self.points_weight[addr][next_time].bias = weight\n    self.time_weight[addr] = next_time\n\n    new_sum: uint256 = old_sum + weight - old_gauge_weight\n    self.points_sum[gauge_type][next_time].bias = new_sum\n    self.time_sum[gauge_type] = next_time\n\n    _total_weight = _total_weight + new_sum * type_weight - old_sum * type_weight\n    self.points_total[next_time] = _total_weight\n    self.time_total = next_time\n\n    log NewGaugeWeight(addr, block.timestamp, weight, _total_weight)\n\n\n@external\ndef change_gauge_weight(addr: address, weight: uint256):\n    \"\"\"\n    @notice Change weight of gauge `addr` to `weight`.\n    @param addr `GaugeController` contract address\n    @param weight New Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\n    self._change_gauge_weight(addr, weight)\n\n@external\ndef kill_gauge(addr: address):\n    \"\"\"\n    @notice Change weight of gauge `addr` to `weight`.\n    @param addr `GaugeController` contract address\n    \"\"\"\n    assert msg.sender == self.admin, \"NOT_ADMIN\"\n    self._change_gauge_weight(addr, 0)\n    self.killed_gauges[addr] = True\n    self.control_tower.cvgRewards().removeGauge(addr)\n\n\n@internal\ndef vote_for_gauge_weights(tokenId: uint256, _gauge_addr: address, _user_weight: uint256):\n    \"\"\"\n    @notice Assign/update voting power to a gauge to add to its weight, and drag more/less inflation onto it.\n    @dev For a killed gauges on.\n    @param _gauge_addr Gauge which `msg.sender` votes for\n    @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    \"\"\"\n    assert not self.isLock, \"VOTE_LOCKED\"\n    assert not self.killed_gauges[_gauge_addr] or _user_weight == 0 , \"KILLED_GAUGE\"\n    assert self.vote_activated[_gauge_addr], \"VOTE_GAUGE_PAUSED\"\n\n    lockingManager: LockingPositionManager = self.control_tower.lockingPositionManager()\n    lockingDelegate: LockingPositionDelegate = self.control_tower.lockingPositionDelegate()\n\n    # Check if the sender is the owner or a delegatee for the token.\n    assert (lockingManager.ownerOf(tokenId) == msg.sender or lockingDelegate.delegatedVeCvg(tokenId) == msg.sender), \"TOKEN_NOT_OWNED\"\n    # Check whether the token is time-locked: a token can be time-locked by its owner to protect a potential buyer from a malicious front run.\n    assert (lockingManager.unlockingTimestampPerToken(tokenId) < block.timestamp), \"TOKEN_TIMELOCKED\"\n    escrow: VotingPowerEscrow = self.control_tower.votingPowerEscrow()\n    slope: uint256 = convert(escrow.get_last_nft_slope(tokenId), uint256)\n    lock_end: uint256 = escrow.locked__end(tokenId)\n    _n_gauges: int128 = self.n_gauges\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n    assert lock_end > next_time, \"Your token lock expires too soon\"\n    assert (_user_weight >= 0) and (_user_weight <= 10000), \"You used all your voting power\"\n    assert block.timestamp >= self.last_nft_vote[tokenId][_gauge_addr] + WEIGHT_VOTE_DELAY, \"Cannot vote so often\"\n\n    gauge_type: int128 = self.gauge_types_[_gauge_addr] - 1\n    assert gauge_type >= 0, \"Gauge not added\"\n    # Prepare slopes and biases in memory.\n    old_slope: VotedSlope = self.vote_nft_slopes[tokenId][_gauge_addr]\n    old_dt: uint256 = 0\n    if old_slope.end > next_time:\n        old_dt = old_slope.end - next_time\n    old_bias: uint256 = old_slope.slope * old_dt\n    new_slope: VotedSlope = VotedSlope({\n        slope: slope * _user_weight / 10000,\n        power: _user_weight,\n        end: lock_end,\n    })\n    new_dt: uint256 = lock_end - next_time  # dev: raises when expired\n    new_bias: uint256 = new_slope.slope * new_dt\n\n    # Check and update powers (weights) used.\n    power_used: uint256 = self.vote_nft_power[tokenId]\n    power_used = power_used + new_slope.power - old_slope.power\n    self.vote_nft_power[tokenId] = power_used\n    assert (power_used >= 0) and (power_used <= 10000), 'Used too much power'\n\n    ## Remove old and schedule new slope changes.\n    # Remove slope changes for old slopes.\n    # Schedule recording of initial slope for next_time.\n    old_weight_bias: uint256 = self._get_weight(_gauge_addr)\n    old_weight_slope: uint256 = self.points_weight[_gauge_addr][next_time].slope\n    old_sum_bias: uint256 = self._get_sum(gauge_type)\n    old_sum_slope: uint256 = self.points_sum[gauge_type][next_time].slope\n\n    self.points_weight[_gauge_addr][next_time].bias = max(old_weight_bias + new_bias, old_bias) - old_bias\n    self.points_sum[gauge_type][next_time].bias = max(old_sum_bias + new_bias, old_bias) - old_bias\n    if old_slope.end > next_time:\n        self.points_weight[_gauge_addr][next_time].slope = max(old_weight_slope + new_slope.slope, old_slope.slope) - old_slope.slope\n        self.points_sum[gauge_type][next_time].slope = max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope\n    else:\n        self.points_weight[_gauge_addr][next_time].slope += new_slope.slope\n        self.points_sum[gauge_type][next_time].slope += new_slope.slope\n    if old_slope.end > block.timestamp:\n        # Cancel old slope changes if they still didn't happen\n        self.changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope\n        self.changes_sum[gauge_type][old_slope.end] -= old_slope.slope\n    # Add slope changes for new slopes\n    self.changes_weight[_gauge_addr][new_slope.end] += new_slope.slope\n    self.changes_sum[gauge_type][new_slope.end] += new_slope.slope\n\n    self._get_total()\n\n    self.vote_nft_slopes[tokenId][_gauge_addr] = new_slope\n\n    # Record last action time\n    self.last_nft_vote[tokenId][_gauge_addr] = block.timestamp\n\n    log VoteForGauge(block.timestamp, tokenId, _gauge_addr, _user_weight)\n\n\n\nstruct Votes:\n    gauge_address: address\n    weight: uint256\n\nstruct MultiVote:\n    tokenId: uint256\n    votes: DynArray[Votes, 50]\n\n@external\ndef multi_vote(param: DynArray[MultiVote, 10]):\n    \"\"\"\n    @notice Allocate votes to several gauges.\n    @dev Only a wallet or a WL contract can call the function in order to avoid voting concentration.\n    @param param list of vote structure  : [tokenId, [gauge_address, weight]]\n    \"\"\"\n    lockingService: LockingPositionService = self.control_tower.lockingPositionService()\n    assert (msg.sender == tx.origin or lockingService.isContractLocker(msg.sender)), \"NOT_ALLOWED\"\n\n    for token in param:\n        for vote in token.votes:\n            self.vote_for_gauge_weights(token.tokenId, vote.gauge_address , vote.weight )\n\n@external\ndef simple_vote(tokenId: uint256, _gauge_addr: address, _user_weight: uint256):\n    \"\"\"\n    @notice Allocate vote to one gauge.\n    @dev Only a wallet or a WL contract can call the function in order to avoid voting concentration.\n    @param tokenId source token\n    @param _gauge_addr  gauge address\n    @param _user_weight source weight to allocate\n    \"\"\"\n    lockingService: LockingPositionService = self.control_tower.lockingPositionService()\n    assert (msg.sender == tx.origin or lockingService.isContractLocker(msg.sender)), \"NOT_ALLOWED\"\n\n    self.vote_for_gauge_weights(tokenId, _gauge_addr, _user_weight)\n\n@external\n@view\ndef get_gauge_weight_normal(addr: address) -> uint256:\n    \"\"\"\n    @notice Get current gauge weight.\n    @param addr Gauge address\n    @return Gauge weight\n    \"\"\"\n    return self.points_weight[addr][self.time_weight[addr]].bias\n\n\n@external\n@view\ndef get_gauge_weight(addr: address) -> uint256:\n    \"\"\"\n    @notice Get current gauge weight weighted by the gauge type.\n    @param addr Gauge address\n    @return Gauge weight\n    \"\"\"\n    typeId: int128 = self.gauge_types_[addr] - 1 \n    typeWeight: uint256 = self.points_type_weight[typeId][self.time_type_weight[typeId]]\n    return self.points_weight[addr][self.time_weight[addr]].bias * typeWeight\n\n@external\n@view\ndef get_gauge_weight_sum(addrs: DynArray[address, 100]) -> uint256:\n    \"\"\"\n    @notice Get sum of current gauge weights.\n    @param addrs Gauge addresses\n    @return Gauge weight sumed\n    \"\"\"\n    weight_sum: uint256 = 0\n    for addr in addrs:\n        typeId: int128 = self.gauge_types_[addr] - 1 \n        typeWeight: uint256 = self.points_type_weight[typeId][self.time_type_weight[typeId]]\n        weight_sum += self.points_weight[addr][self.time_weight[addr]].bias * typeWeight\n    return  weight_sum\n\n@external\n@view\ndef get_gauge_weights(addrs: DynArray[address, 100]) -> DynArray[uint256, 100]:\n    \"\"\"\n    @notice Get several gauge weights weighted by the gauge type.\n    @param addrs Gauge addresses\n    @return Gauge weights \n    \"\"\"\n\n    weights: DynArray[uint256, 100] = []\n    for addr in addrs:\n        typeId: int128 = self.gauge_types_[addr] - 1 \n        typeWeight: uint256 = self.points_type_weight[typeId][self.time_type_weight[typeId]]\n        weights.append(self.points_weight[addr][self.time_weight[addr]].bias * typeWeight)\n    return weights\n\n@external\n@view\ndef get_gauge_weights_and_types(addrs: DynArray[address, 100]) -> DynArray[WeightType, 100]:\n    \"\"\"\n    @notice Get several gauge weights weighted by the gauge type.\n    @param addrs Gauge addresses\n    @return Gauge weights and types\n    \"\"\"\n    weights_type: DynArray[WeightType, 100] = []\n    for addr in addrs:\n        typeId: int128 = self.gauge_types_[addr] - 1 \n        typeWeight: uint256 = self.points_type_weight[typeId][self.time_type_weight[typeId]]\n        weights_type.append(WeightType({weight :self.points_weight[addr][self.time_weight[addr]].bias * typeWeight, type_weight: typeWeight, gauge_type : typeId }))\n    return weights_type\n\n\n@external\n@view\ndef get_nft_datas(inputParams: DynArray[TokenViewInput, 50]) -> DynArray[TokenViewOutput, 50]:\n    \"\"\"\n    @notice View function to get token weights deployed on each gauges.\n    @param inputParams Gauge addresses\n    @return nft data params \n    \"\"\"\n    escrow: VotingPowerEscrow = self.control_tower.votingPowerEscrow()\n    result: DynArray[TokenViewOutput, 10] = []\n    for inputParam in inputParams:\n        token_id : uint256 = inputParam.tokenId\n        tokenData: DynArray[TokenData, 100] = []\n        for gauge_address in inputParam.gaugeAddresses:\n            tokenData.append(TokenData({\n                gaugeAddress : gauge_address,\n                nft_slopes : self.vote_nft_slopes[token_id][gauge_address],\n                last_nft_vote: self.last_nft_vote[token_id][gauge_address]\n            }))\n        result.append(TokenViewOutput({\n            tokenId : token_id,\n            nft_power: self.vote_nft_power[token_id],\n            balanceOf: escrow.balanceOf(token_id),\n            gaugeData: tokenData\n        }))\n    return result        \n\n\n@external\n@view\ndef get_type_weight(type_id: int128) -> uint256:\n    \"\"\"\n    @notice Get current type weight.\n    @param type_id Type id\n    @return Type weight\n    \"\"\"\n    return self.points_type_weight[type_id][self.time_type_weight[type_id]]\n\n\n@external\n@view\ndef get_total_weight() -> uint256:\n    \"\"\"\n    @notice Get current total (type-weighted) weight.\n    @return Total weight\n    \"\"\"\n    return self.points_total[self.time_total]\n\n\n@external\n@view\ndef get_weights_sum_per_type(type_id: int128) -> uint256:\n    \"\"\"\n    @notice Get sum of gauge weights per type.\n    @param type_id Type id\n    @return Sum of gauge weights\n    \"\"\"\n    return self.points_sum[type_id][self.time_sum[type_id]].bias"
    },
    {
      "filename": "sherlock-cvg/contracts/Rewards/CvgRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICvgControlTower.sol\";\nimport \"../interfaces/ICvgAssetStaking.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\n/// @title Cvg-Finance - CvgRewards\n/// @notice Distribute rewards among staking contracts\n/// @dev The function in charge of distributing CVG rewards is following th estate machine pattern\ncontract CvgRewards is Ownable2StepUpgradeable {\n    enum State {\n        CHECKPOINT,\n        LOCK_TOTAL_WEIGHT,\n        DISTRIBUTE,\n        CONTROL_TOWER_SYNC\n    }\n\n    struct InflationInfo {\n        address gauge;\n        uint256 cvgDistributed;\n        uint256 gaugeWeight;\n    }\n\n    struct CvgRewardsConfig {\n        uint88 maxChunkCheckpoint;\n        uint88 maxLoopSetTotalWeight;\n        uint80 maxChunkDistribute;\n    }\n\n    event Checkpoints(uint256 cvgCycle);\n    event SetTotalWeight(uint256 cvgCycle, uint256 totalWeight);\n    event EventChunkWriteStakingRewards(uint256 cvgCycle, uint256 totalGaugeWeight, InflationInfo[] inflationInfos);\n    event InflationAdjustment(uint256 indexed cycleId, uint256 adjustment);\n    event StakingDistribution(uint256 indexed cycleId, address indexed gaugeAddress, uint256 amount);\n\n    /// @dev 60,576.46 CVG distributed each cycle on the first 105 cycles\n    uint256 public constant INITIAL_CYCLE_INFLATION = 60576923076923076923076;\n\n    /// @dev On cycle 1041, inflation doesn't reduce anymore\n    uint256 public constant END_INFLATION_CYCLE = 1041;\n\n    /// @dev After the 1561 cycle, 923.2354137 CVG are distributed by cycle\n    uint256 public constant END_INFLATION_AMOUNT = 1893028846153846164575;\n\n    /// @dev approximation value for square root of 2\n    uint256 private constant SQRT_2 = 1414213562373095048;\n\n    /// @dev each 105 cycles, inflation is reduced by SRQT2\n    uint256 private constant INFLATION_CHANGE_INTERVAL_CYCLE = 105;\n\n    /// @dev convergence ecosystem address\n    ICvgControlTower public cvgControlTower;\n\n    /// @dev Percentage of CVG to distribute weekly. Can be between 80% and 120% of the planned inflation.\n    ///      This can be used to augment or reduce the APR in CVG after votes from the DAO.\n    uint256 public inflationRatio;\n\n    /// @dev current rewards distribution state\n    State public state;\n\n    /// @dev current cursor, used to determine the starting index of the next chunk\n    uint128 public cursor;\n\n    /// @dev timestamp corresponding to the last update of the cvg cycle\n    uint256 public lastUpdatedTimestamp;\n\n    /// @dev sum of all gaug"
    }
  ]
}