{
  "Title": "[M-04] ConfigTimeLockController will put QuantConfig in a stalemate (rendering it unusable) ",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27\n\n\n# Vulnerability details\n\nThe QuantConfig contract has these important setters, setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole(). This contract is subjected to a timelock before all such processes above are executed. But, the issue arises in the fact that in configTimeLockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max(cannot assume what value will be set) and could potentially render the QuantConfig contract unusable . All the previous values and addresses would not be able to be changed because of a very high delay being set:\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28\n\n I discussed with one of the devs about the use of this specific mapping :\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27\n\nAfter discussions with one of the devs(#0xca11.eth) , it was understood  that these values are for the rollaOrderFee which is a part of their limit order protocol contract(outside of the scope of the contest) but given the argument above,  its configuration will be severely impacted (old percentage fees won't be able to be changed).Rolla limit order protocol depends on this configuration setting within QuantConfig.\n\nIt is recommended that a constant be declared with a MAXIMUM_DELAY and whatever ‘minimum delay’ that is set thereafter should be below this value since there's another function setDelay () which can also be of high arbitrary value:\n\nrequire(minimum delay ≤MAXIMUM_DELAY, “ too high”)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/timelock/ConfigTimelockController.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"./TimelockController.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../libraries/ProtocolValue.sol\";\n\n/// @title Timelock controller contract for setting values in the QuantConfig and scheduling calls\n/// to external contracts.\n/// @author Rolla\n/// @dev Built on top of OpenZeppelin's TimelockController.\ncontract ConfigTimelockController is TimelockController {\n    mapping(bytes32 => uint256) public delays;\n\n    mapping(bytes32 => uint256) private _timestamps;\n\n    /// @notice The minimum delay for scheduled executions\n    uint256 public minDelay;\n\n    constructor(\n        uint256 _minDelay,\n        address[] memory _proposers,\n        address[] memory _executors\n    )\n        TimelockController(_minDelay, _proposers, _executors)\n    // solhint-disable-next-line no-empty-blocks\n    {\n        minDelay = _minDelay;\n    }\n\n    /// @notice Sets the delay for a specific protocol value\n    /// @param _protocolValue the bytes32 encoded representation of the protocol value\n    /// @param _newDelay the delay in seconds\n    function setDelay(bytes32 _protocolValue, uint256 _newDelay)\n        external\n        onlyRole(EXECUTOR_ROLE)\n    {\n        // Delays must be greater than or equal to the minimum delay\n        delays[_protocolValue] = _newDelay >= minDelay ? _newDelay : minDelay;\n    }\n\n    /// @inheritdoc TimelockController\n    function schedule(\n        address target,\n        uint256 value,\n        bytes memory data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay,\n        bool\n    ) public virtual override onlyRole(PROPOSER_ROLE) {\n        require(\n            !_isProtocoValueSetter(data),\n            \"ConfigTimelockController: Can not schedule changes to a protocol value with an arbitrary delay\"\n        );\n\n        super.schedule(target, value, data, predecessor, salt, delay, false);\n    }\n\n    /// @notice Schedule a call to set a protocol address in the QuantConfig contract\n    /// @param protocolAddress the encoded name of the protocol address variable to set in the config\n    /// @param newAddress the new address value to set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function scheduleSetProtocolAddress(\n        bytes32 protocolAddress,\n        address newAddress,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        bytes memory data = _encodeSetProtocolAddress(\n            protocolAddress,\n            newAddress,\n            quantConfig\n        );\n\n        uint256 delay = _getProtocolValueDelay(\n            quantConfig,\n            protocolAddress,\n            ProtocolValue.Type.Address\n        );\n\n        require(\n            eta >= delay + block.timestamp,\n            \"ConfigTimelockController: Estimated execution block must satisfy delay\"\n        );\n\n        super.schedule(\n            quantConfig,\n            0,\n            data,\n            bytes32(0),\n            bytes32(eta),\n            delay,\n            true\n        );\n    }\n\n    /// @notice Schedule a call to set a protocol uint256 in the QuantConfig contract\n    /// @param protocolUint256 the encoded name of the protocol uint256 variable to set in the config\n    /// @param newUint256 the new uint256 value to set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function scheduleSetProtocolUint256(\n        bytes32 protocolUint256,\n        uint256 newUint256,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        bytes memory data = _encodeSetProtocolUint256(\n            protocolUint256,\n            newUint256,\n            quantConfig\n        );\n\n        uint256 delay = _getProtocolValueDelay(\n            quantConfig,\n            protocolUint256,\n            ProtocolValue.Type.Uint256\n        );\n\n        require(\n            eta >= delay + block.timestamp,\n            \"ConfigTimelockController: Estimated execution block must satisfy delay\"\n        );\n\n        super.schedule(\n            quantConfig,\n            0,\n            data,\n            bytes32(0),\n            bytes32(eta),\n            delay,\n            true\n        );\n    }\n\n    /// @notice Schedule a call to set a protocol boolean in the QuantConfig contract\n    /// @param protocolBoolean the encoded name of the protocol boolean variable to set in the config\n    /// @param newBoolean the new boolean value to set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function scheduleSetProtocolBoolean(\n        bytes32 protocolBoolean,\n        bool newBoolean,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        bytes memory data = _encodeSetProtocolBoolean(\n            protocolBoolean,\n            newBoolean,\n            quantConfig\n        );\n\n        uint256 delay = _getProtocolValueDelay(\n            quantConfig,\n            protocolBoolean,\n            ProtocolValue.Type.Bool\n        );\n\n        require(\n            eta >= delay + block.timestamp,\n            \"ConfigTimelockController: Estimated execution block must satisfy delay\"\n        );\n        super.schedule(\n            quantConfig,\n            0,\n            data,\n            bytes32(0),\n            bytes32(eta),\n            delay,\n            true\n        );\n    }\n\n    /// @notice Schedule a call to set a protocol role in the QuantConfig contract\n    /// @param protocolRole the name of the protocol role variable to set in the config\n    /// @param roleAdmin address to be the role admin\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function scheduleSetProtocolRole(\n        string calldata protocolRole,\n        address roleAdmin,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        bytes memory data = _encodeSetProtocolRole(\n            protocolRole,\n            roleAdmin,\n            quantConfig\n        );\n\n        uint256 delay = _getProtocolValueDelay(\n            quantConfig,\n            keccak256(abi.encodePacked(protocolRole)),\n            ProtocolValue.Type.Role\n        );\n\n        require(\n            eta >= delay + block.timestamp,\n            \"ConfigTimelockController: Estimated execution block must satisfy delay\"\n        );\n\n        super.schedule(\n            quantConfig,\n            0,\n            data,\n            bytes32(0),\n            bytes32(eta),\n            delay,\n            true\n        );\n    }\n\n    /// @notice Schedule multiple contract calls\n    /// @dev Cannot schedule calls to set protocol values in the QuantConfig\n    /// @param targets array of contracts to receive the scheduled calls\n    /// @param values array of values to be sent to the contracts\n    /// @param datas array of data to be sent to the contracts\n    /// @param predecessor extra 32 bytes to be used when hashing the operation batch\n    /// @param salt salt to be used when hashing the operation batch\n    /// @param delay execution delay in seconds\n    function scheduleBatch(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual override onlyRole(PROPOSER_ROLE) {\n        uint256 length = targets.length;\n        for (uint256 i = 0; i < length; ) {\n            require(\n                !_isProtocoValueSetter(datas[i]),\n                \"ConfigTimelockController: Can not schedule changes to a protocol value with an arbitrary delay\"\n            );\n            unchecked {\n                ++i;\n            }\n        }\n\n        super.scheduleBatch(targets, values, datas, predecessor, salt, delay);\n    }\n\n    /// @notice Schedule multiple calls to set protocol address values in the QuantConfig\n    /// @param protocolValues array of protocol address values to be set\n    /// @param newAddresses array of new addresses to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function scheduleBatchSetProtocolAddress(\n        bytes32[] calldata protocolValues,\n        address[] calldata newAddresses,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newAddresses.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            scheduleSetProtocolAddress(\n                protocolValues[i],\n                newAddresses[i],\n                quantConfig,\n                eta\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Schedule multiple calls to set protocol uint256 values in the QuantConfig\n    /// @param protocolValues array of protocol uint256 values to be set\n    /// @param newUints array of new uints to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function scheduleBatchSetProtocolUints(\n        bytes32[] calldata protocolValues,\n        uint256[] calldata newUints,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newUints.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            scheduleSetProtocolUint256(\n                protocolValues[i],\n                newUints[i],\n                quantConfig,\n                eta\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Schedule multiple calls to set protocol boolean values in the QuantConfig\n    /// @param protocolValues array of protocol boolean values to be set\n    /// @param newBooleans array of new booleans to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function scheduleBatchSetProtocolBooleans(\n        bytes32[] calldata protocolValues,\n        bool[] calldata newBooleans,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newBooleans.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            scheduleSetProtocolBoolean(\n                protocolValues[i],\n                newBooleans[i],\n                quantConfig,\n                eta\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Schedule multiple calls to set protocol roles in the QuantConfig\n    /// @param protocolRoles array of protocol roles to be set\n    /// @param roleAdmins array of role admins to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function scheduleBatchSetProtocolRoles(\n        string[] calldata protocolRoles,\n        address[] calldata roleAdmins,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(PROPOSER_ROLE) {\n        uint256 length = protocolRoles.length;\n\n        require(\n            length == roleAdmins.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            scheduleSetProtocolRole(\n                protocolRoles[i],\n                roleAdmins[i],\n                quantConfig,\n                eta\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Execute a scheduled call to set a protocol address value in the QuantConfig\n    /// @param protocolAddress the protocol address value to be set\n    /// @param newAddress the new address to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function executeSetProtocolAddress(\n        bytes32 protocolAddress,\n        address newAddress,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        execute(\n            quantConfig,\n            0,\n            _encodeSetProtocolAddress(protocolAddress, newAddress, quantConfig),\n            bytes32(0),\n            bytes32(eta)\n        );\n    }\n\n    /// @notice Execute a scheduled call to set a protocol uint256 value in the QuantConfig\n    /// @param protocolUint256 the protocol uint256 value to be set\n    /// @param newUint256 the new uint to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function executeSetProtocolUint256(\n        bytes32 protocolUint256,\n        uint256 newUint256,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        execute(\n            quantConfig,\n            0,\n            _encodeSetProtocolUint256(protocolUint256, newUint256, quantConfig),\n            bytes32(0),\n            bytes32(eta)\n        );\n    }\n\n    /// @notice Execute a scheduled call to set a protocol boolean value in the QuantConfig\n    /// @param protocolBoolean the protocol boolean value to be set\n    /// @param newBoolean the new boolean to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function executeSetProtocolBoolean(\n        bytes32 protocolBoolean,\n        bool newBoolean,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        execute(\n            quantConfig,\n            0,\n            _encodeSetProtocolBoolean(protocolBoolean, newBoolean, quantConfig),\n            bytes32(0),\n            bytes32(eta)\n        );\n    }\n\n    /// @notice Execute a scheduled call to set a protocol role in the QuantConfig\n    /// @param protocolRole the protocol role to be set\n    /// @param roleAdmin the role admin to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled call can be executed\n    function executeSetProtocolRole(\n        string calldata protocolRole,\n        address roleAdmin,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        execute(\n            quantConfig,\n            0,\n            _encodeSetProtocolRole(protocolRole, roleAdmin, quantConfig),\n            bytes32(0),\n            bytes32(eta)\n        );\n    }\n\n    /// @notice Execute multiple scheduled calls to set protocol address values in the QuantConfig\n    /// @param protocolValues array of protocol address values to be set\n    /// @param newAddresses array of new addresses to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function executeBatchSetProtocolAddress(\n        bytes32[] calldata protocolValues,\n        address[] calldata newAddresses,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newAddresses.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            execute(\n                quantConfig,\n                0,\n                _encodeSetProtocolAddress(\n                    protocolValues[i],\n                    newAddresses[i],\n                    quantConfig\n                ),\n                bytes32(0),\n                bytes32(eta)\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Execute multiple scheduled calls to set protocol uint256 values in the QuantConfig\n    /// @param protocolValues array of protocol uint256 values to be set\n    /// @param newUints array of new uints to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function executeBatchSetProtocolUint256(\n        bytes32[] calldata protocolValues,\n        uint256[] calldata newUints,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newUints.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            execute(\n                quantConfig,\n                0,\n                _encodeSetProtocolUint256(\n                    protocolValues[i],\n                    newUints[i],\n                    quantConfig\n                ),\n                bytes32(0),\n                bytes32(eta)\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Execute multiple scheduled calls to set protocol boolean values in the QuantConfig\n    /// @param protocolValues array of protocol boolean values to be set\n    /// @param newBooleans array of new booleans to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function executeBatchSetProtocolBoolean(\n        bytes32[] calldata protocolValues,\n        bool[] calldata newBooleans,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        uint256 length = protocolValues.length;\n\n        require(\n            length == newBooleans.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            execute(\n                quantConfig,\n                0,\n                _encodeSetProtocolBoolean(\n                    protocolValues[i],\n                    newBooleans[i],\n                    quantConfig\n                ),\n                bytes32(0),\n                bytes32(eta)\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Execute multiple scheduled calls to set protocol roles in the QuantConfig\n    /// @param protocolRoles array of protocol roles to be set\n    /// @param roleAdmins array of role admins to be set\n    /// @param quantConfig the address of the QuantConfig contract\n    /// @param eta timestamp from which the scheduled calls can be executed\n    function executeBatchSetProtocolRoles(\n        string[] calldata protocolRoles,\n        address[] calldata roleAdmins,\n        address quantConfig,\n        uint256 eta\n    ) public onlyRole(EXECUTOR_ROLE) {\n        uint256 length = protocolRoles.length;\n\n        require(\n            length == roleAdmins.length,\n            \"ConfigTimelockController: length mismatch\"\n        );\n\n        for (uint256 i = 0; i < length; ) {\n            execute(\n                quantConfig,\n                0,\n                _encodeSetProtocolRole(\n                    protocolRoles[i],\n                    roleAdmins[i],\n                    quantConfig\n                ),\n                bytes32(0),\n                bytes32(eta)\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the delay to set a specific protocol value using the timelock\n    /// @param quantConfig  the address of the QuantConfig contract\n    /// @param protocolValue the protocol value to get the delay for\n    /// @return the delay required to set the protocol value\n    function _getProtocolValueDelay(\n        address quantConfig,\n        bytes32 protocolValue,\n        ProtocolValue.Type protocolValueType\n    ) internal view returns (uint256) {\n        // There shouldn't be a delay when setting a protocol value for the first time\n        if (\n            !IQuantConfig(quantConfig).isProtocolValueSet(\n                protocolValue,\n                protocolValueType\n            )\n        ) {\n            return 0;\n        }\n\n        uint256 storedDelay = delays[protocolValue];\n        return storedDelay != 0 ? storedDelay : minDelay;\n    }\n\n    /// @notice Checks if a given calldata is for setting a protocol value, which could be used\n    /// to bypass the minimum delay required to set a protocol value of a specific type\n    /// @param data the calldata to check\n    /// @return true if the calldata is for setting a protocol value, false otherwise\n    /// @dev There could be a clash between the 4-byte selector for `setProtocolValue` functions\n    /// and other external functions. That's unlikely to happen, but if it does, scheduling calls\n    /// to those functions will always revert.\n    function _isProtocoValueSetter(bytes memory data)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes4 selector;\n\n        assembly {\n            selector := mload(add(data, 32))\n        }\n\n        return\n            selector == IQuantConfig(address(0)).setProtocolAddress.selector ||\n            selector == IQuantConfig(address(0)).setProtocolUint256.selector ||\n            selector == IQuantConfig(address(0)).setProtocolBoolean.selector;\n    }\n\n    /// @notice Encodes the calldata for setting a protocol address value\n    /// @param _protocolAddress the protocol address value to be set\n    /// @param _newAddress the new address to be set\n    /// @param _quantConfig the address of the QuantConfig contract\n    function _encodeSetProtocolAddress(\n        bytes32 _protocolAddress,\n        address _newAddress,\n        address _quantConfig\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                IQuantConfig(_quantConfig).setProtocolAddress.selector,\n                _protocolAddress,\n                _newAddress\n            );\n    }\n\n    /// @notice Encodes the calldata for setting a protocol uint256 value\n    /// @param _protocolUint256 the protocol uint256 value to be set\n    /// @param _newUint256 the new uint to be set\n    /// @param _quantConfig the address of the QuantConfig contract\n    function _encodeSetProtocolUint256(\n        bytes32 _protocolUint256,\n        uint256 _newUint256,\n        address _quantConfig\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                IQuantConfig(_quantConfig).setProtocolUint256.selector,\n                _protocolUint256,\n                _newUint256\n            );\n    }\n\n    /// @notice Encodes the calldata for setting a protocol boolean value\n    /// @param _protocolBoolean the protocol boolean value to be set\n    /// @param _newBoolean the new boolean to be set\n    /// @param _quantConfig the address of the QuantConfig contract\n    function _encodeSetProtocolBoolean(\n        bytes32 _protocolBoolean,\n        bool _newBoolean,\n        address _quantConfig\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                IQuantConfig(_quantConfig).setProtocolBoolean.selector,\n                _protocolBoolean,\n                _newBoolean\n            );\n    }\n\n    /// @notice Encodes the calldata for setting a protocol role\n    /// @param _protocolRole the protocol role to be set\n    /// @param _roleAdmin the role admin to be set\n    /// @param _quantConfig the address of the QuantConfig contract\n    function _encodeSetProtocolRole(\n        string memory _protocolRole,\n        address _roleAdmin,\n        address _quantConfig\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                IQuantConfig(_quantConfig).setProtocolRole.selector,\n                _protocolRole,\n                _roleAdmin\n            );\n    }\n}"
    },
    {
      "filename": "quant-protocol/contracts/QuantConfig.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./libraries/ProtocolValue.sol\";\nimport \"./interfaces/ITimelockedConfig.sol\";\n\n/// @title A central config for the Quant Protocol. Also acts as a central access control manager.\n/// @author Rolla\n/// @notice For storing constants, variables and allowing them to be changed by the admin (governance)\n/// @dev This should be used as a central access control manager which other contracts use to check permissions\ncontract QuantConfig is\n    AccessControlUpgradeable,\n    OwnableUpgradeable,\n    ITimelockedConfig\n{\n    /// @inheritdoc ITimelockedConfig\n    address payable public override timelockController;\n\n    /// @inheritdoc ITimelockedConfig\n    mapping(bytes32 => address) public override protocolAddresses;\n    /// @inheritdoc ITimelockedConfig\n    bytes32[] public override configuredProtocolAddresses;\n\n    /// @inheritdoc ITimelockedConfig\n    mapping(bytes32 => uint256) public override protocolUints256;\n    /// @inheritdoc ITimelockedConfig\n    bytes32[] public override configuredProtocolUints256;\n\n    /// @inheritdoc ITimelockedConfig\n    mapping(bytes32 => bool) public override protocolBooleans;\n    /// @inheritdoc ITimelockedConfig\n    bytes32[] public override configuredProtocolBooleans;\n\n    /// @inheritdoc ITimelockedConfig\n    mapping(string => bytes32) public override quantRoles;\n    /// @inheritdoc ITimelockedConfig\n    bytes32[] public override configuredQuantRoles;\n\n    /// @inheritdoc ITimelockedConfig\n    mapping(bytes32 => mapping(ProtocolValue.Type => bool))\n        public\n        override isProtocolValueSet;\n\n    /// @inheritdoc ITimelockedConfig\n    function setProtocolAddress(bytes32 _protocolAddress, address _newValue)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _protocolAddress != ProtocolValue.encode(\"priceRegistry\") ||\n                !protocolBooleans[ProtocolValue.encode(\"isPriceRegistrySet\")],\n            \"QuantConfig: priceRegistry can only be set once\"\n        );\n        address previousValue = protocolAddresses[_protocolAddress];\n        protocolAddresses[_protocolAddress] = _newValue;\n        configuredProtocolAddresses.push(_protocolAddress);\n        isProtocolValueSet[_protocolAddress][ProtocolValue.Type.Address] = true;\n\n        if (_protocolAddress == ProtocolValue.encode(\"priceRegistry\")) {\n            protocolBooleans[ProtocolValue.encode(\"isPriceRegistrySet\")] = true;\n        }\n\n        emit SetProtocolAddress(_protocolAddress, previousValue, _newValue);\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function setProtocolUint256(bytes32 _protocolUint256, uint256 _newValue)\n        external\n        override\n        onlyOwner\n    {\n        uint256 previousValue = protocolUints256[_protocolUint256];\n        protocolUints256[_protocolUint256] = _newValue;\n        configuredProtocolUints256.push(_protocolUint256);\n        isProtocolValueSet[_protocolUint256][ProtocolValue.Type.Uint256] = true;\n\n        emit SetProtocolUint256(_protocolUint256, previousValue, _newValue);\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function setProtocolBoolean(bytes32 _protocolBoolean, bool _newValue)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            _protocolBoolean != ProtocolValue.encode(\"isPriceRegistrySet\") ||\n                !protocolBooleans[ProtocolValue.encode(\"isPriceRegistrySet\")],\n            \"QuantConfig: can only change isPriceRegistrySet once\"\n        );\n        bool previousValue = protocolBooleans[_protocolBoolean];\n        protocolBooleans[_protocolBoolean] = _newValue;\n        configuredProtocolBooleans.push(_protocolBoolean);\n        isProtocolValueSet[_protocolBoolean][ProtocolValue.Type.Bool] = true;\n\n        emit SetProtocolBoolean(_protocolBoolean, previousValue, _newValue);\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function setProtocolRole(string calldata _protocolRole, address _roleAdmin)\n        external\n        override\n        onlyOwner\n    {\n        _setProtocolRole(_protocolRole, _roleAdmin);\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function setRoleAdmin(bytes32 role, bytes32 adminRole)\n        external\n        override\n        onlyOwner\n    {\n        _setRoleAdmin(role, adminRole);\n\n        emit SetRoleAdmin(role, adminRole);\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function protocolAddressesLength()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return configuredProtocolAddresses.length;\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function protocolUints256Length() external view override returns (uint256) {\n        return configuredProtocolUints256.length;\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function protocolBooleansLength() external view override returns (uint256) {\n        return configuredProtocolBooleans.length;\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function quantRolesLength() external view override returns (uint256) {\n        return configuredQuantRoles.length;\n    }\n\n    /// @inheritdoc ITimelockedConfig\n    function initialize(address payable _timelockController)\n        public\n        override\n        initializer\n    {\n        require(\n            _timelockController != address(0),\n            \"QuantConfig: invalid TimelockController address\"\n        );\n\n        __AccessControl_init();\n        __Ownable_init_unchained();\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(DEFAULT_ADMIN_ROLE, _timelockController);\n\n        string memory oracleManagerRole = \"ORACLE_MANAGER_ROLE\";\n        _setProtocolRole(oracleManagerRole, _timelockController);\n        _setProtocolRole(oracleManagerRole, _msgSender());\n        timelockController = _timelockController;\n    }\n\n    /// @notice Sets a new protocol role, while also assigning a role admin\n    /// @dev If the role already exists in the config, only the role admin will be changed\n    function _setProtocolRole(string memory _protocolRole, address _roleAdmin)\n        internal\n    {\n        bytes32 role = keccak256(abi.encodePacked(_protocolRole));\n        grantRole(role, _roleAdmin);\n        if (quantRoles[_protocolRole] == bytes32(0)) {\n            quantRoles[_protocolRole] = role;\n            configuredQuantRoles.push(role);\n            isProtocolValueSet[role][ProtocolValue.Type.Role] = true;\n        }\n\n        emit SetProtocolRole(_protocolRole, role, _roleAdmin);\n    }\n}"
    }
  ]
}