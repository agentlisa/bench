{
  "Title": "H-4: Auction creators have the ability to lock bidders' funds.",
  "Content": "# Issue H-4: Auction creators have the ability to lock bidders' funds. \n\nSource: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/66 \n\n## Found by \nKiroBrejka, ether\\_sky, hash, jecikpo, lemonmon, novaman33, qbs, sl1, underdog\n## Summary\n`Auction creators` have the ability to cancel an `auction` before it starts.\nHowever, once the `auction` begins, they should not be allowed to cancel it.\nDuring the `auction`, `bidders` can place `bids` and send `quote` tokens to the `auction house`.\nAfter the `auction` concludes, `bidders` can either receive `base` tokens or retrieve their `quote` tokens.\nUnfortunately, `batch auction creators` can cancel an `auction` when it ends.\nThis means that `auction creators` can cancel their `auctions` if they anticipate `losses`.\nThis should not be allowed.\nThe significant risk is that `bidders' funds` could become locked in the `auction house`.\n## Vulnerability Detail\n`Auction creators` can not cancel an `auction` once it concludes.\n```solidity\nfunction cancelAuction(uint96 lotId_) external override onlyInternal {\n    _revertIfLotConcluded(lotId_);\n}\n```\nThey also can not cancel it while it is active.\n```solidity\nfunction _cancelAuction(uint96 lotId_) internal override {\n    _revertIfLotActive(lotId_);\n\n    auctionData[lotId_].status = Auction.Status.Claimed;\n}\n```\nWhen the `block.timestamp` aligns with the `conclusion` time of the `auction`, we can bypass these checks.\n```solidity\nfunction _revertIfLotConcluded(uint96 lotId_) internal view virtual {\n    if (lotData[lotId_].conclusion < uint48(block.timestamp)) {\n        revert Auction_MarketNotActive(lotId_);\n    }\n\n    if (lotData[lotId_].capacity == 0) revert Auction_MarketNotActive(lotId_);\n}\nfunction _revertIfLotActive(uint96 lotId_) internal view override {\n    if (\n        auctionData[lotId_].status == Auction.Status.Created\n            && lotData[lotId_].start <= block.timestamp\n            && lotData[lotId_].conclusion > block.timestamp\n    ) revert Auction_WrongState(lotId_);\n}\n```\nSo `Auction creators` can cancel an `auction` when it concludes.\nThen the `capacity` becomes `0` and the `auction status` transitions to `Claimed`.\n\n`Bidders` can not `refund` their `bids`.\n```solidity\nfunction refundBid(\n    uint96 lotId_,\n    uint64 bidId_,\n    address caller_\n) external override onlyInternal returns (uint96 refund) {\n    _revertIfLotConcluded(lotId_);\n}\n function _revertIfLotConcluded(uint96 lotId_) internal view virtual {\n    if (lotData[lotId_].capacity == 0) revert Auction_MarketNotActive(lotId_);\n}\n```\nThe only way for `bidders` to reclaim their tokens is by calling the `claimBids` function.\nHowever, `bidders` can only claim `bids` when the `auction status` is `Settled`.\n```solidity\nfunction claimBids(\n    uint96 lotId_,\n    uint64[] calldata bidIds_\n) {\n    _revertIfLotNotSettled(lotId_);\n}\n```\nTo `settle` the `auction`, the `auction status` should be `Decrypted`.\nThis requires submitting the `private key`.\nThe `auction creator` can not submit the `private key` or submit it without decrypting any `bids` by calling `submitPrivateKey(lotId, privateKey, 0)`.\nThen nobody can decrypt the `bids` using the `decryptAndSortBids` function which always reverts.\n```solidity\nfunction decryptAndSortBids(uint96 lotId_, uint64 num_) external {\n    if (\n        auctionData[lotId_].status != Auction.Status.Created     // @audit, here\n            || auctionData[lotId_].privateKey == 0\n    ) {\n        revert Auction_WrongState(lotId_);\n    }\n\n    _decryptAndSortBids(lotId_, num_);\n}\n```\nAs a result, the `auction status` remains unchanged, preventing it from transitioning to `Settled`.\nThis leaves the `bidders'` `quote` tokens locked in the `auction house`.\n\nPlease add below test to the `test/modules/Auction/cancel.t.sol`.\n```solidity\nfunction test_cancel() external whenLotIsCreated {\n    Auction.Lot memory lot = _mockAuctionModule.getLot(_lotId);\n\n    console2.log(\"lot.conclusion before   ==> \", lot.conclusion);\n    console2.log(\"block.timestamp before  ==> \", block.timestamp);\n    console2.log(\"isLive                  ==> \", _mockAuctionModule.isLive(_lotId));\n\n    vm.warp(lot.conclusion - block.timestamp + 1);\n    console2.log(\"lot.conclusion after    ==> \", lot.conclusion);\n    console2.log(\"block.timestamp after   ==> \", block.timestamp);\n    console2.log(\"isLive                  ==> \", _mockAuctionModule.isLive(_lotId));\n\n    vm.prank(address(_auctionHouse));\n    _mockAuctionModule.cancelAuction(_lotId);\n}\n```\nThe log is\n```solidity\nlot.conclusion before   ==>  86401\nblock.timestamp before  ==>  1\nisLive                  ==>  true\nlot.conclusion after    ==>  86401\nblock.timestamp after   ==>  86401\nisLive                  ==>  false\n```\n## Impact\nUsers' funds can be locked.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/modules/Auction.sol#L354\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/modules/auctions/EMPAM.sol#L204\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/modules/Auction.sol#L512\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/modules/Auction.sol#L556\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/cadf331f12b485bac184111cdc9ba1344d9fbf01/moonraker/src/modules/auctions/EMPAM.sol#L449\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\nfunction _revertIfLotConcluded(uint96 lotId_) internal view virtual {\n-     if (lotData[lotId_].conclusion < uint48(block.timestamp)) {\n+     if (lotData[lotId_].conclusion <= uint48(block.timestamp)) {\n        revert Auction_MarketNotActive(lotId_);\n    }\n\n    // Capacity is sold-out, or cancelled\n    if (lotData[lotId_].capacity == 0) revert Auction_MarketNotActive(lotId_);\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Axis-Fi/moonraker/pull/105\n\n\n**10xhash**\n\n> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#105](https://github.com/Axis-Fi/moonraker/pull/105)\n\nFixed\nstart and conclusion timestamps of auction is now made consistent across all functions\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/206",
  "Code": [
    {
      "filename": "moonraker/src/modules/Auction.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {Module} from \"src/modules/Modules.sol\";\n\nabstract contract Auction {\n    // ========== ERRORS ========== //\n\n    error Auction_MarketNotActive(uint96 lotId);\n    error Auction_MarketActive(uint96 lotId);\n    error Auction_InvalidStart(uint48 start_, uint48 minimum_);\n    error Auction_InvalidDuration(uint48 duration_, uint48 minimum_);\n    error Auction_InvalidLotId(uint96 lotId);\n    error Auction_InvalidBidId(uint96 lotId, uint96 bidId);\n    error Auction_OnlyMarketOwner();\n    error Auction_AmountLessThanMinimum();\n    error Auction_NotEnoughCapacity();\n    error Auction_InvalidParams();\n    error Auction_NotAuthorized();\n    error Auction_NotImplemented();\n    error Auction_NotBidder();\n    error Auction_InsufficientCapacity();\n\n    // ========== EVENTS ========== //\n\n    // ========== DATA STRUCTURES ========== //\n\n    /// @notice     The type of auction lot\n    /// @dev        Auction modules specify their type in the `auctionType()` function\n    enum AuctionType {\n        Atomic,\n        Batch\n    }\n\n    /// @notice     The status of an auction lot\n    enum Status {\n        Created,\n        Decrypted,\n        Settled,\n        Claimed\n    }\n\n    /// @notice     Core data for an auction lot\n    ///\n    /// @param      start               The timestamp when the auction starts\n    /// @param      conclusion          The timestamp when the auction ends\n    /// @param      quoteTokenDecimals  The quote token decimals\n    /// @param      baseTokenDecimals   The base token decimals\n    /// @param      capacityInQuote     Whether or not the capacity is in quote tokens\n    /// @param      capacity            The capacity of the lot\n    /// @param      sold                The amount of base tokens sold\n    /// @param      purchased           The amount of quote tokens purchased\n    /// @param      partialPayout       The amount of partial payout (in base tokens)\n    // TODO pack slots\n    struct Lot {\n        uint48 start; // 6 +\n        uint48 conclusion; //\n        uint8 quoteTokenDecimals;\n        uint8 baseTokenDecimals;\n        bool capacityInQuote;\n        uint96 capacity;\n        uint96 sold;\n        uint96 purchased;\n        uint96 partialPayout;\n    }\n\n    /// @notice     Parameters when creating an auction lot\n    ///\n    /// @param      start           The timestamp when the auction starts\n    /// @param      duration        The duration of the auction (in seconds)\n    /// @param      capacityInQuote Whether or not the capacity is in quote tokens\n    /// @param      capacity        The capacity of the lot\n    /// @param      implParams      Abi-encoded implementation-specific parameters\n    struct AuctionParams {\n        uint48 start;\n        uint48 duration;\n        bool capacityInQuote;\n        uint96 capacity;\n        bytes implParams;\n    }\n\n    /// @dev Only used in memory so doesn't need to be packed\n    struct Settlement {\n        uint96 totalIn;\n        uint96 totalOut;\n        address pfBidder;\n        address pfReferrer;\n        uint96 pfRefund;\n        uint96 pfPayout;\n        bytes auctionOutput;\n    }\n\n    /// @dev Only used in memory so doesn't need to be packed\n    struct BidClaim {\n        address bidder;\n        address referrer;\n        uint96 paid;\n        uint96 payout;\n    }\n\n    // ========= STATE ========== //\n\n    /// @notice Minimum auction duration in seconds\n    uint48 public minAuctionDuration;\n\n    /// @notice Constant for percentages\n    /// @dev    1% = 1_000 or 1e3. 100% = 100_000 or 1e5.\n    uint48 internal constant _ONE_HUNDRED_PERCENT = 100_000;\n\n    /// @notice General information pertaining to auction lots\n    mapping(uint96 id => Lot lot) public lotData;\n\n    // ========== ATOMIC AUCTIONS ========== //\n\n    /// @notice     Purchase tokens from an auction lot\n    /// @dev        The implementing function should handle the following:\n    ///             - Validate the purchase parameters\n    ///             - Store the purchase data\n    ///\n    /// @param      lotId_             The lot id\n    /// @param      amount_         The amount of quote tokens to purchase\n    /// @param      auctionData_    The auction-specific data\n    /// @return     payout          The amount of payout tokens to receive\n    /// @return     auctionOutput   The auction-specific output\n    function purchase(\n        uint96 lotId_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) external virtual returns (uint96 payout, bytes memory auctionOutput);\n\n    // ========== BATCH AUCTIONS ========== //\n\n    /// @notice     Bid on an auction lot\n    /// @dev        The implementing function should handle the following:\n    ///             - Validate the bid parameters\n    ///             - Store the bid data\n    ///\n    /// @param      lotId_          The lot id\n    /// @param      bidder_         The bidder of the purchased tokens\n    /// @param      referrer_       The referrer of the bid\n    /// @param      amount_         The amount of quote tokens to bid\n    /// @param      auctionData_    The auction-specific data\n    function bid(\n        uint96 lotId_,\n        address bidder_,\n        address referrer_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) external virtual returns (uint64 bidId);\n\n    /// @notice     Refund a bid\n    /// @dev        The implementing function should handle the following:\n    ///             - Validate the bid parameters\n    ///             - Authorize `caller_`\n    ///             - Update the bid data\n    ///\n    /// @param      lotId_      The lot id\n    /// @param      bidId_      The bid id\n    /// @param      caller_     The caller\n    /// @return     refund   The amount of quote tokens to refund\n    function refundBid(\n        uint96 lotId_,\n        uint64 bidId_,\n        address caller_\n    ) external virtual returns (uint96 refund);\n\n    /// @notice     Claim multiple bids\n    /// @dev        The implementing function should handle the following:\n    ///             - Validate the bid parameters\n    ///             - Update the bid data\n    ///\n    /// @param      lotId_          The lot id\n    /// @param      bidIds_         The bid ids\n    /// @return     bidClaims       The bid claim data\n    /// @return     auctionOutput   The auction-specific output\n    function claimBids(\n        uint96 lotId_,\n        uint64[] calldata bidIds_\n    ) external virtual returns (BidClaim[] memory bidClaims, bytes memory auctionOutput);\n\n    /// @notice     Settle a batch auction lot with on-chain storage and settlement\n    /// @dev        The implementing function should handle the following:\n    ///             - Validate the lot parameters\n    ///             - Determine the winning bids\n    ///             - Update the lot data\n    ///\n    /// @param      lotId_          The lot id\n    /// @return     settlement      The settlement data\n    function settle(uint96 lotId_)\n        external\n        virtual\n        returns (Settlement memory settlement, bytes memory auctionOutput);\n\n    /// @notice     Claim the seller proceeds from a settled auction lot\n    /// @dev        The implementing function should handle the following:\n    ///             - Validate the lot parameters\n    ///             - Update the lot data\n    ///\n    /// @param      lotId_          The lot id\n    /// @return     purchased       The amount of quote tokens purchased\n    /// @return     sold            The amount of base tokens sold\n    /// @return     payoutSent      The amount of base tokens that have already been paid out\n    function claimProceeds(uint96 lotId_)\n        external\n        virtual\n        returns (uint96 purchased, uint96 sold, uint96 payoutSent);\n\n    // ========== AUCTION MANAGEMENT ========== //\n\n    /// @notice     Create an auction lot\n    ///\n    /// @param      lotId_                  The lot id\n    /// @param      params_                 The auction parameters\n    /// @param      quoteTokenDecimals_     The quote token decimals\n    /// @param      baseTokenDecimals_      The base token decimals\n    /// @return     capacity                The capacity of the lot\n    function auction(\n        uint96 lotId_,\n        AuctionParams memory params_,\n        uint8 quoteTokenDecimals_,\n        uint8 baseTokenDecimals_\n    ) external virtual returns (uint96 capacity);\n\n    /// @notice     Cancel an auction lot\n    /// @dev        The implementing function should handle the following:\n    ///             - Validate the lot parameters\n    ///             - Update the lot data\n    ///             - Return the remaining capacity (so that the AuctionHouse can refund the seller)\n    ///\n    /// @param      lotId_              The lot id\n    function cancelAuction(uint96 lotId_) external virtual;\n\n    // ========== AUCTION INFORMATION ========== //\n\n    function payoutFor(uint96 lotId_, uint96 amount_) public view virtual returns (uint96) {}\n\n    function priceFor(uint96 lotId_, uint96 payout_) public view virtual returns (uint96) {}\n\n    function maxPayout(uint96 lotId_) public view virtual returns (uint96) {}\n\n    function maxAmountAccepted(uint96 lotId_) public view virtual returns (uint96) {}\n\n    /// @notice     Returns whether the auction is currently accepting bids or purchases\n    /// @dev        The implementing function should handle the following:\n    ///             - Return true if the lot is accepting bids/purchases\n    ///             - Return false if the lot has ended, been cancelled, or not started yet\n    ///\n    /// @param      lotId_  The lot id\n    /// @return     bool    Whether or not the lot is active\n    function isLive(uint96 lotId_) public view virtual returns (bool);\n\n    /// @notice     Returns whether the auction has ended\n    /// @dev        The implementing function should handle the following:\n    ///             - Return true if the lot is not accepting bids/purchases and will not at any point\n    ///             - Return false if the lot hasn't started or is actively accepting bids/purchases\n    ///\n    /// @param      lotId_  The lot id\n    /// @return     bool    Whether or not the lot is active\n    function hasEnded(uint96 lotId_) public view virtual returns (bool);\n\n    /// @notice     Get the remaining capacity of a lot\n    /// @dev        The implementing function should handle the following:\n    ///             - Return the remaining capacity of the lot\n    ///\n    /// @param      lotId_  The lot id\n    /// @return     uint96 The remaining capacity of the lot\n    function remainingCapacity(uint96 lotId_) external view virtual returns (uint96);\n\n    /// @notice     Get whether or not the capacity is in quote tokens\n    /// @dev        The implementing function should handle the following:\n    ///             - Return true if the capacity is in quote tokens\n    ///             - Return false if the capacity is in base tokens\n    ///\n    /// @param      lotId_  The lot id\n    /// @return     bool    Whether or not the capacity is in quote tokens\n    function capacityInQuote(uint96 lotId_) external view virtual returns (bool);\n\n    /// @notice     Get the type of an auction\n    ///\n    /// @return     AuctionType     The type of auction\n    function auctionType() external pure virtual returns (AuctionType);\n}\n\nabstract contract AuctionModule is Auction, Module {\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(address auctionHouse_) Module(auctionHouse_) {}\n\n    // ========== AUCTION MANAGEMENT ========== //\n\n    /// @inheritdoc Auction\n    /// @dev        If the start time is zero, the auction will have a start time of the current block timestamp\n    ///\n    /// @dev        This function reverts if:\n    ///             - the caller is not the parent of the module\n    ///             - the start time is in the past\n    ///             - the duration is less than the minimum\n    function auction(\n        uint96 lotId_,\n        AuctionParams memory params_,\n        uint8 quoteTokenDecimals_,\n        uint8 baseTokenDecimals_\n    ) external override onlyInternal returns (uint96 capacity) {\n        // Start time must be zero or in the future\n        if (params_.start > 0 && params_.start < uint48(block.timestamp)) {\n            revert Auction_InvalidStart(params_.start, uint48(block.timestamp));\n        }\n\n        // Duration must be at least min duration\n        if (params_.duration < minAuctionDuration) {\n            revert Auction_InvalidDuration(params_.duration, minAuctionDuration);\n        }\n\n        // Create core market data\n        Lot memory lot;\n        lot.start = params_.start == 0 ? uint48(block.timestamp) : params_.start;\n        lot.conclusion = lot.start + params_.duration;\n        lot.quoteTokenDecimals = quoteTokenDecimals_;\n        lot.baseTokenDecimals = baseTokenDecimals_;\n        lot.capacityInQuote = params_.capacityInQuote;\n        lot.capacity = params_.capacity;\n\n        // Call internal createAuction function to store implementation-specific data\n        _auction(lotId_, lot, params_.implParams);\n\n        // Store lot data\n        lotData[lotId_] = lot;\n\n        return (lot.capacity);\n    }\n\n    /// @notice     Implementation-specific auction creation logic\n    /// @dev        Auction modules should override this to perform any additional logic\n    ///\n    /// @param      lotId_              The lot ID\n    /// @param      lot_                The lot data\n    /// @param      params_             Additional auction parameters\n    function _auction(uint96 lotId_, Lot memory lot_, bytes memory params_) internal virtual;\n\n    /// @notice     Cancel an auction lot\n    /// @dev        Assumptions:\n    ///             - The parent will refund the seller the remaining capacity\n    ///             - The parent will verify that the caller is the seller\n    ///\n    ///             This function reverts if:\n    ///             - the caller is not the parent of the module\n    ///             - the lot id is invalid\n    ///             - the lot has concluded\n    ///\n    /// @param      lotId_      The lot id\n    function cancelAuction(uint96 lotId_) external override onlyInternal {\n        // Validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfLotConcluded(lotId_);\n\n        // Call internal closeAuction function to update any other required parameters\n        _cancelAuction(lotId_);\n\n        // Update lot\n        Lot storage lot = lotData[lotId_];\n\n        lot.conclusion = uint48(block.timestamp);\n        lot.capacity = 0;\n    }\n\n    /// @notice     Implementation-specific auction cancellation logic\n    /// @dev        Auction modules should override this to perform any additional logic\n    ///\n    /// @param      lotId_      The lot ID\n    function _cancelAuction(uint96 lotId_) internal virtual;\n\n    // ========== ATOMIC AUCTIONS ========== //\n\n    /// @inheritdoc Auction\n    /// @dev        Implements a basic purchase function that:\n    ///             - Calls implementation-specific validation logic\n    ///             - Calls the auction module\n    ///\n    ///             This function reverts if:\n    ///             - the lot id is invalid\n    ///             - the lot is inactive\n    ///             - the caller is not an internal module\n    ///             - the payout is greater than the remaining capacity\n    ///\n    ///             Inheriting contracts should override _purchase to implement auction-specific logic, such as:\n    ///             - Validating the auction-specific parameters\n    ///             - Storing the purchase data\n    function purchase(\n        uint96 lotId_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) external override onlyInternal returns (uint96 payout, bytes memory auctionOutput) {\n        // Standard validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfLotInactive(lotId_);\n\n        // Call implementation-specific logic\n        (payout, auctionOutput) = _purchase(lotId_, amount_, auctionData_);\n\n        // Update capacity\n        Lot storage lot = lotData[lotId_];\n        // Revert if the capacity is insufficient\n        if (lot.capacityInQuote ? amount_ > lot.capacity : payout > lot.capacity) {\n            revert Auction_InsufficientCapacity();\n        }\n        unchecked {\n            lot.capacity -= lot.capacityInQuote ? amount_ : payout;\n        }\n\n        // Update the purchased and sold amounts for the lot\n        lot.purchased += amount_;\n        lot.sold += payout;\n    }\n\n    /// @notice     Implementation-specific purchase logic\n    /// @dev        Auction modules should override this to perform any additional logic\n    ///\n    /// @param      lotId_          The lot ID\n    /// @param      amount_         The amount of quote tokens to purchase\n    /// @param      auctionData_    The auction-specific data\n    /// @return     payout          The amount of payout tokens to receive\n    /// @return     auctionOutput   The auction-specific output\n    function _purchase(\n        uint96 lotId_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal virtual returns (uint96 payout, bytes memory auctionOutput);\n\n    // ========== BATCH AUCTIONS ========== //\n\n    /// @inheritdoc Auction\n    /// @dev        Implements a basic bid function that:\n    ///             - Calls implementation-specific validation logic\n    ///             - Calls the auction module\n    ///\n    ///             This function reverts if:\n    ///             - the lot id is invalid\n    ///             - the lot has not started\n    ///             - the lot has concluded\n    ///             - the lot is already settled\n    ///             - the caller is not an internal module\n    ///\n    ///             Inheriting contracts should override _bid to implement auction-specific logic, such as:\n    ///             - Validating the auction-specific parameters\n    ///             - Storing the bid data\n    function bid(\n        uint96 lotId_,\n        address bidder_,\n        address referrer_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) external override onlyInternal returns (uint64 bidId) {\n        // Standard validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n        _revertIfLotConcluded(lotId_);\n        _revertIfLotSettled(lotId_);\n\n        // Call implementation-specific logic\n        return _bid(lotId_, bidder_, referrer_, amount_, auctionData_);\n    }\n\n    /// @notice     Implementation-specific bid logic\n    /// @dev        Auction modules should override this to perform any additional logic\n    ///             The returned `bidId` should be a unique and persistent identifier for the bid,\n    ///             which can be used in subsequent calls (e.g. `cancelBid()` or `settle()`).\n    ///\n    /// @param      lotId_          The lot ID\n    /// @param      bidder_         The bidder of the purchased tokens\n    /// @param      referrer_       The referrer of the bid\n    /// @param      amount_         The amount of quote tokens to bid\n    /// @param      auctionData_    The auction-specific data\n    /// @return     bidId           The bid ID\n    function _bid(\n        uint96 lotId_,\n        address bidder_,\n        address referrer_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal virtual returns (uint64 bidId);\n\n    /// @inheritdoc Auction\n    /// @dev        Implements a basic refundBid function that:\n    ///             - Calls implementation-specific validation logic\n    ///             - Calls the auction module\n    ///\n    ///             This function reverts if:\n    ///             - the lot id is invalid\n    ///             - the lot is not settled\n    ///             - the bid id is invalid\n    ///             - `caller_` is not the bid owner\n    ///             - the bid is cancelled\n    ///             - the bid is already refunded\n    ///             - the caller is not an internal module\n    ///\n    ///             Inheriting contracts should check for lot cancellation, if needed.\n    ///\n    ///             Inheriting contracts should override _refundBid to implement auction-specific logic, such as:\n    ///             - Validating the auction-specific parameters\n    ///             - Updating the bid data\n    function refundBid(\n        uint96 lotId_,\n        uint64 bidId_,\n        address caller_\n    ) external override onlyInternal returns (uint96 refund) {\n        // Standard validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n        _revertIfBidInvalid(lotId_, bidId_);\n        _revertIfNotBidOwner(lotId_, bidId_, caller_);\n        _revertIfBidClaimed(lotId_, bidId_);\n        _revertIfLotConcluded(lotId_);\n\n        // Call implementation-specific logic\n        return _refundBid(lotId_, bidId_, caller_);\n    }\n\n    /// @notice     Implementation-specific bid refund logic\n    /// @dev        Auction modules should override this to perform any additional logic\n    ///\n    /// @param      lotId_      The lot ID\n    /// @param      bidId_      The bid ID\n    /// @param      caller_     The caller\n    /// @return     refund   The amount of quote tokens to refund\n    function _refundBid(\n        uint96 lotId_,\n        uint64 bidId_,\n        address caller_\n    ) internal virtual returns (uint96 refund);\n\n    /// @inheritdoc Auction\n    /// @dev        Implements a basic claimBids function that:\n    ///             - Calls implementation-specific validation logic\n    ///             - Calls the auction module\n    ///\n    ///             This function reverts if:\n    ///             - the lot id is invalid\n    ///             - the lot is not settled\n    ///             - the caller is not an internal module\n    ///\n    ///             Inheriting contracts should override _claimBids to implement auction-specific logic, such as:\n    ///             - Validating the auction-specific parameters\n    ///             - Validating the validity and status of each bid\n    ///             - Updating the bid data\n    function claimBids(\n        uint96 lotId_,\n        uint64[] calldata bidIds_\n    )\n        external\n        override\n        onlyInternal\n        returns (BidClaim[] memory bidClaims, bytes memory auctionOutput)\n    {\n        // Standard validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfLotNotSettled(lotId_);\n\n        // Call implementation-specific logic\n        return _claimBids(lotId_, bidIds_);\n    }\n\n    /// @notice     Implementation-specific bid claim logic\n    /// @dev        Auction modules should override this to perform any additional logic\n    ///\n    /// @param      lotId_          The lot ID\n    /// @param      bidIds_         The bid IDs\n    /// @return     bidClaims       The bid claim data\n    /// @return     auctionOutput   The auction-specific output\n    function _claimBids(\n        uint96 lotId_,\n        uint64[] calldata bidIds_\n    ) internal virtual returns (BidClaim[] memory bidClaims, bytes memory auctionOutput);\n\n    /// @inheritdoc Auction\n    /// @dev        Implements a basic settle function that:\n    ///             - Calls common validation logic\n    ///             - Calls the implementation-specific function for the auction module\n    ///\n    ///             This function reverts if:\n    ///             - the lot id is invalid\n    ///             - the lot is still active\n    ///             - the lot has already been settled\n    ///             - the caller is not an internal module\n    ///\n    ///             Inheriting contracts should override _settle to implement auction-specific logic, such as:\n    ///             - Validating the auction-specific parameters\n    ///             - Determining the winning bids\n    ///             - Updating the lot data\n    function settle(uint96 lotId_)\n        external\n        virtual\n        override\n        onlyInternal\n        returns (Settlement memory settlement, bytes memory auctionOutput)\n    {\n        // Standard validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n        _revertIfLotActive(lotId_);\n        _revertIfLotSettled(lotId_);\n\n        // Call implementation-specific logic\n        (settlement, auctionOutput) = _settle(lotId_);\n\n        // Set lot capacity to zero\n        lotData[lotId_].capacity = 0;\n\n        // Store sold and purchased amounts\n        lotData[lotId_].purchased = settlement.totalIn;\n        lotData[lotId_].sold = settlement.totalOut;\n        lotData[lotId_].partialPayout = settlement.pfPayout;\n    }\n\n    /// @notice     Implementation-specific lot settlement logic\n    /// @dev        Auction modules should override this to perform any additional logic,\n    ///             such as determining the winning bids and updating the lot data\n    ///\n    /// @param      lotId_          The lot ID\n    /// @return     settlement      The settlement data\n    function _settle(uint96 lotId_)\n        internal\n        virtual\n        returns (Settlement memory settlement, bytes memory auctionOutput);\n\n    /// @inheritdoc Auction\n    /// @dev        Implements a basic claimProceeds function that:\n    ///             - Calls common validation logic\n    ///             - Calls the implementation-specific function for the auction module\n    ///\n    ///             This function reverts if:\n    ///             - the lot id is invalid\n    ///             - the lot is not settled\n    ///             - the lot proceeds have already been claimed\n    ///             - the lot is cancelled\n    ///             - the caller is not an internal module\n    ///\n    ///             Inheriting contracts should override _claimProceeds to implement auction-specific logic, such as:\n    ///             - Validating the auction-specific parameters\n    ///             - Updating the lot data\n    function claimProceeds(uint96 lotId_)\n        external\n        virtual\n        override\n        onlyInternal\n        returns (uint96 purchased, uint96 sold, uint96 payoutSent)\n    {\n        // Standard validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfLotProceedsClaimed(lotId_);\n        _revertIfLotNotSettled(lotId_);\n\n        // Call implementation-specific logic\n        return _claimProceeds(lotId_);\n    }\n\n    /// @notice     Implementation-specific claim proceeds logic\n    /// @dev        Auction modules should override this to perform any additional logic,\n    ///             such as updating the lot data\n    ///\n    /// @param      lotId_          The lot ID\n    /// @return     purchased       The amount of quote tokens purchased\n    /// @return     sold            The amount of base tokens sold\n    /// @return     payoutSent      The amount of base tokens that have already been paid out\n    function _claimProceeds(uint96 lotId_)\n        internal\n        virtual\n        returns (uint96 purchased, uint96 sold, uint96 payoutSent);\n\n    // ========== AUCTION INFORMATION ========== //\n\n    /// @inheritdoc Auction\n    /// @dev        A lot is active if:\n    ///             - The lot has not concluded\n    ///             - The lot has started\n    ///             - The lot has not sold out or been cancelled (capacity > 0)\n    ///\n    /// @param      lotId_  The lot ID\n    /// @return     bool    Whether or not the lot is active\n    function isLive(uint96 lotId_) public view override returns (bool) {\n        return (\n            lotData[lotId_].capacity != 0 && lotData[lotId_].conclusion > uint48(block.timestamp)\n                && lotData[lotId_].start <= uint48(block.timestamp)\n        );\n    }\n\n    /// @inheritdoc Auction\n    function hasEnded(uint96 lotId_) public view override returns (bool) {\n        return lotData[lotId_].conclusion < uint48(block.timestamp) || lotData[lotId_].capacity == 0;\n    }\n\n    /// @inheritdoc Auction\n    function remainingCapacity(uint96 lotId_) external view override returns (uint96) {\n        return lotData[lotId_].capacity;\n    }\n\n    /// @inheritdoc Auction\n    function capacityInQuote(uint96 lotId_) external view override returns (bool) {\n        return lotData[lotId_].capacityInQuote;\n    }\n\n    /// @notice    Get the lot data for a given lot ID\n    ///\n    /// @param     lotId_  The lot ID\n    function getLot(uint96 lotId_) external view returns (Lot memory) {\n        return lotData[lotId_];\n    }\n\n    // ========== MODIFIERS ========== //\n\n    /// @notice     Checks that `lotId_` is valid\n    /// @dev        Should revert if the lot ID is invalid\n    ///             Inheriting contracts can override this to implement custom logic\n    ///\n    /// @param      lotId_  The lot ID\n    function _revertIfLotInvalid(uint96 lotId_) internal view virtual {\n        if (lotData[lotId_].start == 0) revert Auction_InvalidLotId(lotId_);\n    }\n\n    /// @notice     Checks that the lot represented by `lotId_` has not started\n    /// @dev        Should revert if the lot has not started\n    function _revertIfBeforeLotStart(uint96 lotId_) internal view virtual {\n        if (lotData[lotId_].start > uint48(block.timestamp)) revert Auction_MarketNotActive(lotId_);\n    }\n\n    /// @notice     Checks that the lot represented by `lotId_` has started\n    /// @dev        Should revert if the lot has started\n    function _revertIfLotStarted(uint96 lotId_) internal view virtual {\n        if (lotData[lotId_].start <= uint48(block.timestamp)) revert Auction_MarketActive(lotId_);\n    }\n\n    /// @notice     Checks that the lot represented by `lotId_` has not concluded\n    /// @dev        Should revert if the lot has concluded\n    function _revertIfLotConcluded(uint96 lotId_) internal view virtual {\n        // Beyond the conclusion time\n        if (lotData[lotId_].conclusion < uint48(block.timestamp)) {\n            revert Auction_MarketNotActive(lotId_);\n        }\n\n        // Capacity is sold-out, or cancelled\n        if (lotData[lotId_].capacity == 0) revert Auction_MarketNotActive(lotId_);\n    }\n\n    /// @notice     Checks that the lot represented by `lotId_` is active\n    /// @dev        Should revert if the lot is not active\n    ///             Inheriting contracts can override this to implement custom logic\n    ///\n    /// @param      lotId_  The lot ID\n    function _revertIfLotInactive(uint96 lotId_) internal view virtual {\n        if (!isLive(lotId_)) revert Auction_MarketNotActive(lotId_);\n    }\n\n    /// @notice     Checks that the lot represented by `lotId_` is active\n    /// @dev        Should revert if the lot is active\n    ///             Inheriting contracts can override this to implement custom logic\n    ///\n    /// @param      lotId_  The lot ID\n    function _revertIfLotActive(uint96 lotId_) internal view virtual {\n        if (isLive(lotId_)) revert Auction_MarketActive(lotId_);\n    }\n\n    /// @notice     Checks that the lot represented by `lotId_` is not settled\n    /// @dev        Should revert if the lot is settled\n    ///             Inheriting contracts must override this to implement custom logic\n    ///\n    /// @param      lotId_  The lot ID\n    function _revertIfLotSettled(uint96 lotId_) internal view virtual;\n\n    /// @notice     Checks that the lot represented by `lotId_` is settled\n    /// @dev        Should revert if the lot is not settled\n    ///             Inheriting contracts must override this to implement custom logic\n    ///\n    /// @param      lotId_  The lot ID\n    function _revertIfLotNotSettled(uint96 lotId_) internal view virtual;\n\n    /// @notice     Checks if the lot represented by `lotId_` has had its proceeds claimed\n    /// @dev        Should revert if the lot proceeds have been claimed\n    ///             Inheriting contracts must override this to implement custom logic\n    ///\n    /// @param      lotId_  The lot ID\n    function _revertIfLotProceedsClaimed(uint96 lotId_) internal view virtual;\n\n    /// @notice     Checks that the lot and bid combination is valid\n    /// @dev        Should revert if the bid is invalid\n    ///             Inheriting contracts must override this to implement custom logic\n    ///\n    /// @param      lotId_  The lot ID\n    /// @param      bidId_  The bid ID\n    function _revertIfBidInvalid(uint96 lotId_, uint64 bidId_) internal view virtual;\n\n    /// @notice     Checks that `caller_` is the bid owner\n    /// @dev        Should revert if `caller_` is not the bid owner\n    ///             Inheriting contracts must override this to implement custom logic\n    ///\n    /// @param      lotId_      The lot ID\n    /// @param      bidId_      The bid ID\n    /// @param      caller_     The caller\n    function _revertIfNotBidOwner(\n        uint96 lotId_,\n        uint64 bidId_,\n        address caller_\n    ) internal view virtual;\n\n    /// @notice     Checks that the bid is not claimed\n    /// @dev        Should revert if th"
    }
  ]
}