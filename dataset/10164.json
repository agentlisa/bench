{
  "Title": "[M-01] Incorrect internal balance bookkeeping",
  "Content": "_Submitted by walker, also found by cmichel and shw_\n\nThe sherlock smart contract system uses internal bookkeeping of arbitrary ERC20 token balances. It doesn't assert that the ERC20 doesn't implement some non-standard behavior. For example, deflationary tokens, or tokens with a transfer fee, will result in incorrect internal balances. In summary, an attacker can perform stake and deposit actions without actually depositing the amount that sherlock assumes. As a result, an attacker is unduly rewarded balance and yield.\n\n> Balancer had a similar vulnerability in their system https://blog.1inch.io/balancer-hack-2020-a8f7131c980e.\n\nAn example location where such internal bookkeeping happens can be found [here](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L271)\n\nMitigating the issue is possible by requiring the amount to be added to the contracts' balance. Alternatively, it's possible to update the pool based on actual balance changes.\n\n**[Evert0x (Sherlock) acknowledged and disagreed with severity](https://github.com/code-423n4/2021-07-sherlock-findings/issues/12#issuecomment-890312115):**\n > 2 med-risk, as extensive research will be done before adding certain tokens. This finding could even be noted a 0 non-critical if only 'standard' ERC20s are being used.\n>\n> med-risk because certain popular tokens are up-gradable and could potentially implement non-standard behavior\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-sherlock-findings/issues/12#issuecomment-907912401):**\n > since there will be a curation process, I agree with sponsor, this is medium risk\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-07-sherlock",
  "Code": [
    {
      "filename": "contracts/facets/PoolBase.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.4;\npragma abicoder v2;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '../interfaces/IPoolBase.sol';\n\nimport '../storage/GovStorage.sol';\n\nimport '../libraries/LibPool.sol';\n\ncontract PoolBase is IPoolBase {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ILock;\n\n  //\n  // View methods\n  //\n\n  function getCooldownFee(IERC20 _token) external view override returns (uint32) {\n    return baseData().activateCooldownFee;\n  }\n\n  function getSherXWeight(IERC20 _token) external view override returns (uint16) {\n    return baseData().sherXWeight;\n  }\n\n  function getGovPool(IERC20 _token) external view override returns (address) {\n    return baseData().govPool;\n  }\n\n  function isPremium(IERC20 _token) external view override returns (bool) {\n    return baseData().premiums;\n  }\n\n  function isStake(IERC20 _token) external view override returns (bool) {\n    return baseData().stakes;\n  }\n\n  function getProtocolBalance(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().protocolBalance[_protocol];\n  }\n\n  function getProtocolPremium(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().protocolPremium[_protocol];\n  }\n\n  function getLockToken(IERC20 _token) external view override returns (ILock) {\n    return baseData().lockToken;\n  }\n\n  function isProtocol(bytes32 _protocol, IERC20 _token) external view override returns (bool) {\n    return baseData().isProtocol[_protocol];\n  }\n\n  function getProtocols(IERC20 _token) external view override returns (bytes32[] memory) {\n    return baseData().protocols;\n  }\n\n  function getUnstakeEntry(\n    address _staker,\n    uint256 _id,\n    IERC20 _token\n  ) external view override returns (PoolStorage.UnstakeEntry memory) {\n    return baseData().unstakeEntries[_staker][_id];\n  }\n\n  function getTotalAccruedDebt(IERC20 _token) external view override returns (uint256) {\n    baseData();\n    return LibPool.getTotalAccruedDebt(_token);\n  }\n\n  function getFirstMoneyOut(IERC20 _token) external view override returns (uint256) {\n    return baseData().firstMoneyOut;\n  }\n\n  function getAccruedDebt(bytes32 _protocol, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    baseData();\n    return LibPool.accruedDebt(_protocol, _token);\n  }\n\n  function getTotalPremiumPerBlock(IERC20 _token) external view override returns (uint256) {\n    return baseData().totalPremiumPerBlock;\n  }\n\n  function getPremiumLastPaid(IERC20 _token) external view override returns (uint40) {\n    return baseData().totalPremiumLastPaid;\n  }\n\n  function getSherXUnderlying(IERC20 _token) external view override returns (uint256) {\n    return baseData().sherXUnderlying;\n  }\n\n  function getUnstakeEntrySize(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return baseData().unstakeEntries[_staker].length;\n  }\n\n  function getInitialUnstakeEntry(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) {\n      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) {\n        continue;\n      }\n      if (\n        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=\n        uint40(block.number)\n      ) {\n        continue;\n      }\n      return i;\n    }\n    return ps.unstakeEntries[_staker].length;\n  }\n\n  function getUnactivatedStakersPoolBalance(IERC20 _token) public view override returns (uint256) {\n    return baseData().stakeBalance;\n  }\n\n  function getStakersPoolBalance(IERC20 _token) public view override returns (uint256) {\n    return LibPool.stakeBalance(baseData());\n  }\n\n  function getStakerPoolBalance(address _staker, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    PoolStorage.Base storage ps = baseData();\n    if (ps.lockToken.totalSupply() == 0) {\n      return 0;\n    }\n    return\n      ps.lockToken.balanceOf(_staker).mul(getStakersPoolBalance(_token)).div(\n        ps.lockToken.totalSupply()\n      );\n  }\n\n  function getTotalUnmintedSherX(IERC20 _token) public view override returns (uint256) {\n    baseData();\n    return LibPool.getTotalUnmintedSherX(_token);\n  }\n\n  function getUnallocatedSherXStored(IERC20 _token) public view override returns (uint256) {\n    return baseData().unallocatedSherX;\n  }\n\n  function getUnallocatedSherXTotal(IERC20 _token) external view override returns (uint256) {\n    return getUnallocatedSherXStored(_token).add(LibPool.getTotalUnmintedSherX(_token));\n  }\n\n  function getUnallocatedSherXFor(address _user, IERC20 _token)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    baseData();\n    return LibPool.getUnallocatedSherXFor(_user, _token);\n  }\n\n  function getTotalSherXPerBlock(IERC20 _token) public view override returns (uint256) {\n    return SherXStorage.sx().sherXPerBlock.mul(baseData().sherXWeight).div(uint16(-1));\n  }\n\n  function getSherXPerBlock(IERC20 _token) external view override returns (uint256) {\n    return getSherXPerBlock(msg.sender, _token);\n  }\n\n  function getSherXPerBlock(address _user, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    if (ps.lockToken.totalSupply() == 0) {\n      return 0;\n    }\n    return\n      getTotalSherXPerBlock(_token).mul(ps.lockToken.balanceOf(_user)).div(\n        ps.lockToken.totalSupply()\n      );\n  }\n\n  function getSherXPerBlock(uint256 _lock, IERC20 _token) external view override returns (uint256) {\n    // simulates staking (adding lock)\n    return\n      getTotalSherXPerBlock(_token).mul(_lock).div(baseData().lockToken.totalSupply().add(_lock));\n  }\n\n  function getSherXLastAccrued(IERC20 _token) external view override returns (uint40) {\n    return baseData().sherXLastAccrued;\n  }\n\n  function LockToTokenXRate(IERC20 _token) external view override returns (uint256) {\n    return LockToToken(10**18, _token);\n  }\n\n  function LockToToken(uint256 _amount, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    uint256 balance = LibPool.stakeBalance(ps);\n    uint256 totalLock = ps.lockToken.totalSupply();\n    if (totalLock == 0 || balance == 0) {\n      revert('NO_DATA');\n    }\n    return balance.mul(_amount).div(totalLock);\n  }\n\n  function TokenToLockXRate(IERC20 _token) external view override returns (uint256) {\n    return TokenToLock(10**18, _token);\n  }\n\n  function TokenToLock(uint256 _amount, IERC20 _token) public view override returns (uint256) {\n    PoolStorage.Base storage ps = baseData();\n    uint256 balance = LibPool.stakeBalance(ps);\n    uint256 totalLock = ps.lockToken.totalSupply();\n    if (totalLock == 0 || balance == 0) {\n      return 10**18;\n    }\n    return totalLock.mul(_amount).div(balance);\n  }\n\n  //\n  // State changing methods\n  //\n\n  function setCooldownFee(uint32 _fee, IERC20 _token) external override {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n\n    baseData().activateCooldownFee = _fee;\n  }\n\n  function depositProtocolBalance(\n    bytes32 _protocol,\n    uint256 _amount,\n    IERC20 _token\n  ) external override {\n    require(_amount > 0, 'AMOUNT');\n    require(GovStorage.gs().protocolIsCovered[_protocol], 'PROTOCOL');\n    PoolStorage.Base storage ps = baseData();\n    require(ps.isProtocol[_protocol], 'NO_DEPOSIT');\n\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n    ps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].add(_amount);\n  }\n\n  function withdrawProtocolBalance(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    IERC20 _token\n  ) external override {\n    require(msg.sender == GovStorage.gs().protocolAgents[_protocol], 'SENDER');\n    require(_amount > 0, 'AMOUNT');\n    require(_receiver != address(0), 'RECEIVER');\n    PoolStorage.Base storage ps = baseData();\n\n    LibPool.payOffDebtAll(_token);\n\n    if (_amount == uint256(-1)) {\n      _amount = ps.protocolBalance[_protocol];\n    }\n\n    _token.safeTransfer(_receiver, _amount);\n    ps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].sub(_amount);\n  }\n\n  function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) {\n    require(_amount > 0, 'AMOUNT');\n    PoolStorage.Base storage ps = baseData();\n\n    ps.lockToken.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 fee = _amount.mul(ps.activateCooldownFee).div(uint32(-1));\n    if (fee > 0) {\n      // stake of user gets burned\n      // representative amount token get added to first money out pool\n      uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());\n      ps.firstMoneyOut = ps.firstMoneyOut.add(tokenAmount);\n\n      ps.lockToken.burn(address(this), fee);\n    }\n\n    ps.unstakeEntries[msg.sender].push(\n      PoolStorage.UnstakeEntry(uint40(block.number), _amount.sub(fee))\n    );\n\n    return ps.unstakeEntries[msg.sender].length - 1;\n  }\n\n  function cancelCooldown(uint256 _id, IERC20 _token) external override {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown >= uint40(block.number),\n      'COOLDOWN_EXPIRED'\n    );\n    delete ps.unstakeEntries[msg.sender][_id];\n    ps.lockToken.safeTransfer(msg.sender, withdraw.lock);\n  }\n\n  function unstakeWindowExpiry(\n    address _account,\n    uint256 _id,\n    IERC20 _token\n  ) external override {\n    PoolStorage.Base storage ps = baseData();\n    GovStorage.Base storage gs = GovStorage.gs();\n\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[_account][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow < uint40(block.number),\n      'UNSTAKE_WINDOW_NOT_EXPIRED'\n    );\n    delete ps.unstakeEntries[_account][_id];\n    ps.lockToken.safeTransfer(_account, withdraw.lock);\n  }\n\n  function unstake(\n    uint256 _id,\n    address _receiver,\n    IERC20 _token\n  ) external override returns (uint256 amount) {\n    PoolStorage.Base storage ps = baseData();\n    require(_receiver != address(0), 'RECEIVER');\n    GovStorage.Base storage gs = GovStorage.gs();\n    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[msg.sender][_id];\n    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');\n    // period is including\n    require(withdraw.blockInitiated + gs.unstakeCooldown < uint40(block.number), 'COOLDOWN_ACTIVE');\n    require(\n      withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow >= uint40(block.number),\n      'UNSTAKE_WINDOW_EXPIRED'\n    );\n    amount = withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());\n\n    ps.stakeBalance = ps.stakeBalance.sub(amount);\n    delete ps.unstakeEntries[msg.sender][_id];\n    ps.lockToken.burn(address(this), withdraw.lock);\n    _token.safeTransfer(_receiver, amount);\n  }\n\n  function payOffDebtAll(IERC20 _token) external override {\n    baseData();\n    LibPool.payOffDebtAll(_token);\n  }\n\n  function cleanProtocol(\n    bytes32 _protocol,\n    uint256 _index,\n    bool _forceDebt,\n    address _receiver,\n    IERC20 _token\n  ) external override {\n    require(msg.sender == GovStorage.gs().govMain, 'NOT_GOV_MAIN');\n    require(_receiver != address(0), 'RECEIVER');\n\n    PoolStorage.Base storage ps = baseData();\n    require(ps.protocols[_index] == _protocol, 'INDEX');\n\n    // If protocol has 0 accrued debt, the premium should also be 0\n    // If protocol has >0 accrued debt, needs to be bigger then balance\n    // Otherwise just update premium to 0 for the protocol first and then delete\n    uint256 accrued = LibPool.accruedDebt(_protocol, _token);\n    if (accrued == 0) {\n      require(ps.protocolPremium[_protocol] == 0, 'CAN_NOT_DELETE');\n    } else {\n      require(accrued > ps.protocolBalance[_protocol], 'CAN_NOT_DELETE2');\n    }\n\n    // send the remainder of the protocol balance to the sherx underlying\n    if (_forceDebt && accrued > 0) {\n      ps.sherXUnderlying = ps.sherXUnderlying.add(ps.protocolBalance[_protocol]);\n      delete ps.protocolBalance[_protocol];\n    }\n\n    // send any leftovers back to the protocol receiver\n    if (ps.protocolBalance[_protocol] > 0) {\n      _token.safeTransfer(_receiver, ps.protocolBalance[_protocol]);\n      delete ps.protocolBalance[_protocol];\n    }\n\n    // move last index to index of _protocol\n    ps.protocols[_index] = ps.protocols[ps.protocols.length - 1];\n    // remove last index\n    ps.protocols.pop();\n    ps.isProtocol[_protocol] = false;\n    // could still be >0, if accrued more debt than needed.\n    if (ps.protocolPremium[_protocol] > 0) {\n      ps.totalPremiumPerBlock = ps.totalPremiumPerBlock.sub(ps.protocolPremium[_protocol]);\n      delete ps.protocolPremium[_protocol];\n    }\n  }\n\n  function baseData() internal view returns (PoolStorage.Base storage ps) {\n    ps = PoolStorage.ps(bps());\n    require(ps.govPool != address(0), 'INVALID_TOKEN');\n  }\n\n  function bps() internal pure returns (IERC20 rt) {\n    // These fields are not accessible from assembly\n    bytes memory array = msg.data;\n    uint256 index = msg.data.length;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n      rt := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n    }\n  }\n}"
    }
  ]
}