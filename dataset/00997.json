{
  "Title": "M-3: Index values selected in `_woundRequestFulfilled()` are not uniformly distributed.",
  "Content": "# Issue M-3: Index values selected in `_woundRequestFulfilled()` are not uniformly distributed. \n\nSource: https://github.com/sherlock-audit/2023-10-looksrare-judging/issues/84 \n\n## Found by \n0xGoodess, Tricko, cergyk, detectiveking\nIndex values selected in `_woundRequestFulfilled()` are not uniformly distributed. Indexes right next to wounded agents are more likely to be selected in the subsequent iterations, leading to bias in the distribution of wounded agents.\n\n## Vulnerability Detail\nAt the end of each round, the function `_woundRequestFulfilled()` is called, which uses uses the `randomWord` obtained from the VRF to select which agents should be marked as wounded. This selection process is carried out by performing a modulo operation on the `randomWord` with respect to the number of agents currently alive in the round, and then adding 1 to the result. The resulting value corresponds to the index of the agent to be designated as wounded, as illustrated in the code snippet section.\n\nHowever, if the resulting index corresponds to an agent who is already wounded, the `else` branch is executed, where 1 is added to the `randomWord` for the next iteration of the loop. **This is where the bias is introduced, because in the next iteration, the `woundedAgentIndex` will be the current `woundedAgentIndex` plus 1**. As can be seen below:\n\n$$ (A + 1) \\bmod M $$\n\n$$ ((A \\bmod  M) + (1 \\bmod  M)) \\bmod  M $$\n\nAs M > 1, we can simplify to\n\n$$ ((A \\bmod  M) + 1) \\bmod  M $$\n\nFor $(A \\bmod M) + 1$ less than $M$, we have \n\n$$ (A + 1) \\bmod M  = (A \\bmod M) + 1 $$\n\nSo with the exception of when `randomWord` overflows or (`randomWord` % `currentRoundAgentsAlive` + 1) >= `currentRoundAgentsAlive`,  (`randomWord` + 1) % `currentRoundAgentsAlive` will be equal to\n(`randomWord` % `currentRoundAgentsAlive`) + 1.\n\nConsequently, when the `else` branch is triggered, the next `woundedAgentIndex` will be ( previous `woundedAgentIndex`+ 1) from the last loop iteration (besides the two exceptions specified above). Therefore the agent at the next index will also be marked as wounded. As a result of this pattern, **agents whose indexes are immediately next to an already wounded agent are more likely to be wounded than the remaining agents**.\n\nConsider the representative example below, albeit on a smaller scale (8 agents) to facilitate explanation. The initial state is represented in the table below:\n\n| Index       | 1      | 2      | 3      | 4      | 5      | 6      | 7      | 8      |\n|----------------|--------|--------|--------|--------|--------|--------|--------|--------|\n| Agents         | Active | Active | Active | Active | Active | Active | Active | Active |\n| Probabilities  | 0.125  | 0.125  | 0.125  | 0.125  | 0.125  | 0.125  | 0.125  | 0.125  |\n\nIn the initial iteration of `_woundRequestFulfilled()`, assume that index 2 is selected. As expected from function logic, for the next iteration a new `randomWord` will be generated, resulting in a new index within the range of 1 to 8, all with equal probabilities. However now not all agents have an equal likelihood of being wounded. This disparity arises because both 3 and 2 (due to the `else` branch in the code above) will lead to the agent at index 3 being wounded.\n\n| Index       | 1      | 2       | 3      | 4      | 5      | 6      | 7      | 8      |\n|----------------|--------|---------|--------|--------|--------|--------|--------|--------|\n| Agents         | Active | Wounded | Active | Active | Active | Active | Active | Active |\n| Probabilities  | 0.125  | -       | 0.25   | 0.125  | 0.125  | 0.125  | 0.125  | 0.125  |\n\nNow suppose that agents at index 2 and 3 are wounded. Following from the explanations above, index 4 has three times the chance of being wounded.\n\n| Index       | 1      | 2       | 3       | 4      | 5      | 6      | 7      | 8      |\n|----------------|--------|---------|---------|--------|--------|--------|--------|--------|\n| Agents         | Active | Wounded | Wounded | Active | Active | Active | Active | Active |\n| Probabilities  | 0.125  | -       | -       | 0.375  | 0.125  | 0.125  | 0.125  | 0.125  |\n\n## Impact\nThe distribution of wounded status among indexes is not uniform. Indexes subsequent to agents already wounded are more likely to be selected, introducing unfairness in the distribution of wounded agents. \n\nThis is particularly problematic because indexes that are close to each other are more likely to owned by the same address, due to the fact that when minting multiple agents, they are created in sequential indexes. Consequently, if an address has one of its agents marked as wounded, it becomes more probable that additional agents owned by the same address will also be marked as wounded. This creates an unfair situation to users.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-looksrare/blob/main/contracts-infiltration/contracts/Infiltration.sol#L1404-L1468\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider eliminating the `else` and calling `_nextRandomWord(randomWord)` at the end of the loop iteration, so a new `randomWord` is generated each time. As shown in the diff below:\n\n```diff\ndiff --git a/Infiltration.sol b/Infiltration.mod.sol\nindex 31af961..1c43c31 100644\n--- a/Infiltration.sol\n+++ b/Infiltration.mod.sol\n@@ -1451,15 +1451,9 @@ contract Infiltration is\n                     ++i;\n                     currentRoundWoundedAgentIds[i] = uint16(woundedAgentId);\n                 }\n-\n-                randomWord = _nextRandomWord(randomWord);\n-            } else {\n-                // If no agent is wounded using the current random word, increment by 1 and retry.\n-                // If overflow, it will wrap around to 0.\n-                unchecked {\n-                    ++randomWord;\n-                }\n             }\n+\n+            randomWord = _nextRandomWord(randomWord);\n         }\n\n         currentRoundWoundedAgentIds[0] = uint16(woundedAgentsCount);\n```\n\n\n\n## Discussion\n\n**0xhiroshi**\n\nhttps://github.com/LooksRare/contracts-infiltration/pull/152\n\n**SergeKireev**\n\nFix LGTM\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/122",
  "Code": [
    {
      "filename": "contracts-infiltration/contracts/Infiltration.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IInfiltration} from \"./interfaces/IInfiltration.sol\";\n\nimport {OwnableTwoSteps} from \"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\";\nimport {IERC20} from \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\";\n\nimport {ProtocolFee} from \"@looksrare/contracts-libs/contracts/ProtocolFee.sol\";\nimport {PackableReentrancyGuard} from \"@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\";\nimport {LowLevelERC20Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelWETH} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\";\nimport {ITransferManager} from \"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\";\n\nimport {VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"erc721a/contracts/ERC721A.sol\";\n\nimport {UnsafeMathUint256} from \"./libraries/UnsafeMathUint256.sol\";\n\n//                                            .:^^^^^^:::::::::::::::::::::::::::::::::::::::::::::.\n//                                          :~7777!!!77?JJ??????!?YYYYYYYYJ?7~~!!!!!!!!!7???7~~~!~~^:.\n//                                        :~!!!~~77JYYYJJYJJJJJ7J5PPPPP55?!!!!!!!7!!~~~~~~!77??7?!7!!~^.\n//                                      .^~!!!7JYYYYYYJJJJJJJJJ7Y5PPPY?!!!!!!~~~~~~!7!!~~~~~~!????J??7!!^.\n//                                   .:^!!?JYYYYYYYYJJJJJJJYJJ!J55YJ?!!!!!~~~~~~~~~~~!!7!!!!!7!!!!!77?JJ?!~:.\n//                                 .:^~?YYYYYYYYYJJJJJJJJJJJJ??YYJ?!!!77!!!!!!!!!!!!!!~~!!!77!!!!!!!!!!!7?J7~:.\n//                               .^~~!~JYYYYYYYYYJJJJJJJJ???~^??7^.........:::::::^^^^!!!!!77!!!!!!!!!!~~!!7?7!^.\n//                             :^!!!!!~~JYYYYYYJJJJJJJ7!~^:::!????~....    ...:::::::::::^^~77!!!!!!!!!~~~!!!77!!^.\n//                           :~77~!7!!~!JYJJJJJJJJJ!^^^^^^^:^JJ???7!^^::::::::..::::::::::::.:~!!!!!~7?!~~~~!!!!~~!^.\n//                         :!?7!!!77!~~JJJJJJJJ?!^^^^^^^^^::J???5PPG##GPPP5555?77!::::::::.....::^!!!J5Y?!~~~~!77~~~!~:\n//                      .:7J?!~!77!~~~!JJJJJ?~^^^^^^^^^^^::~?5##&@@@@@&BGBGPPPP555YJ!^::......:::...^?55YJ?!~~!!!!~~!!!~:\n//                    .^7J?7!!!!!!~~~~JJJJ7~^^^^^^^^^^^^:^J##@@@@@@@@@@@&#GGPPP555PPP55?:...::::::.. :!?JJJJ7!~~!77!~!!~!~:.\n//                  .:!?77!!!!!!~~~~~7JJ7~^^^^^^^^^^^^::~J#@@@@@@@@@@@@@@@#BGP55PPPPPGGGJ^......:::. ^~:^7???7!!!!!!~~!!!~!~:.\n//                .:!7!~~!!!!!!!~~~~!J7~^^^^^^^^^^^^^::7PB&@@@@@@@@&&B55555YGGPPPPPPGGBBBG7......:::..:^::^!7777!!!!!~~!!!!~!~^.\n//              .:^~!?J!~!7!!!!!~~~!~~^^~^^^^^:::::::.7PGB&&&&@@@&G?~~~!!!!~~~75GBBBBBBBB#B?  ......   .... :~!7!!!!~~!!!!!7!~7?~.\n//            .:^~!?5PPJ!~!!!!!~!!^::!~!!!^:....... .^JPB&&&&&&&G?~~!!7?JJ7!~^:^!5###&#####P~       :^^:      .^!!~~!7777!!!!~7Y5J!.\n//          .:^~!JY5PPPPY!~~~~!!^.   .:^!!^.       ::YBB####&&&P~^~!~~~^^^^:::::.^P&&&&&#&&&5    .:!????7!^::.  .^!!77777777!~!J5PPY!:\n//        .:~~~?Y5555PP5Y?~~!!^.        .^:..^^^!77?!5BB######B~:^^^::::::::......^#&&&&&&&&5  .:!???????????7!!^::~7?7?77777777?Y555J~.\n//       .:^~!!7?J??????7!!!7~.       .......:^77?JJ!5BBBBBBB#B^:::::....::::::::.~&@@@@&&&&5...^^^^^^^^^^^~^^^^^^:.~7!!~~~~~!!!!!77?7~:.\n//         .:^~!~!77!!!!!~~~!!!^:..... .::~~:....:^^:?GBBBGPPP5~.....:::::::::::.:7&&&&&&&&&P:::^:^^^^^:. .:.    .^~~~~~~~~~~~~~!77!~:.\n//           .:^~!!!77!!!~~~~~~!!^.   .::!77~^:......!Y555555555!:..::::::::::..:?#&&&&&&@@&5!7???????!. :~:.. .^!!~~~~~~~~~~~!!7!~:.\n//            ..:^~!!7?!!~~~~~~~~!!~:.:^!7!^.:^: .....755PPPPPPGG57:..::::::..:7P#&&&&&&@@@P!7????JJJ!. :^::.:~!!~~~~~~~~!!!!!7!~:..\n//           .....:^~!!77!~~~~~~~!!!!!^!7!:....^^  .. :?PPGGGGGBBBBPYJ^^^^^^JYG####&&&#&@@G?7????JJJ~. :^:.:!777!!!!!!!!!!!!7!~:.....\n//         .........:^~!!77!~~~~~~!??JY?!:...  .^^  .. :?PGBBBB####&@&######&&&#######&&#P?7????JJ7~. :^:^!?77777777777!!!7!^:.........\n//        ..........:::^~!!77!!~~~~!JJ5J7!:.    .^^. ....~PBB#####&&@@@@@@@@&&########&#J77????J?7:  :^^!?77777777??7!!!7!^:::...........\n//      ..........:::::::^~~!7?7~~~~~7JY7!~~^.   .^^. .   ^7?G###&&&@@@@@@@@&&######GJY?77????J?7:  :!!!J?777777??7!!!!~^:::::::..........\n//    ..........::::::::^^^^~~?J7!~~~~~??7^757^^. .^^.       :7?PBB#&&&&&&&&&&#BBP?7^!777????J?7..~~?5?!????????7!!!!~^^^^::::::::..........\n//   ..........:::::::^^^^^^^^^!???!~~~~!?77J?:~~^^:^:  .       .::!JJJJJJJJJJ!^^^:..777??????!~^7J!JY77JJJJ??7!!!!~^^^^^^^^:::::::..........\n//  .........:::::::^^^^^^~~~~^^^!7J?!!~~~77!^:~~!~~~~:...    .  .. .::::::::::::::.^777?77??7~~7J5!!7?JJJJ?7!!!!~^^~~~~^^^^^^:::::::.........\n// .........:::::::^^^^^~~~~~~!~~^^!JJ?7!~!!!~^^^~~~~!??!^~^.... .. .:::::::::::::::77???Y5Y7~~?Y5YJJJJJJ??7~!!~~~!!~~~~~~^^^^^:::::::.........\n// ........::::::^^^^^^~~~~~!!!!!!!~~!??77!!!~~~~:^~~~!?J???7777~^~^~~~~!!~~~~~~~!7JYYP5PG57^!?Y55YYYJJJJ7!!!~~!!!!!!!~~~~~^^^^^^::::::........\n// ......:::::::^^^^^~~~~~~!!!!!7777!~~!??7777!~!~^^~!^!??J??????????555PP5555555J?55P5PP57^!?Y55P5YYYJ?!!!~~!7777!!!!!~~~~~~^^^^^:::::::......\n// .....:::::::^^^^^~~~~~!!!!!!77777??7~~!???7?777!^~!!7???77???????JY55GG555555Y??5555PY?77JY55PPP5Y?!!!~!7??777777!!!!!~~~~~^^^^^^::::::.....\n// ....::::::^^^^^^~~~~~!!!!!77777??????!^^!?YY??!!!^~!777!^!??7!!!!!7Y5PP5YYYYJ7~Y5P55?7?JJY5555PPY7!!^^!??????77777!!!!!~~~~~^^^^^^::::::....\n// ...::::::^^^^^~~~~~!!!!!!77777??77!~~~~^:~7JP5J7^~~!!!7!7??!7777?JJ5YYYYPPP5J77555PJ77?JY555PP5J?7~^^~~~~!77??77777!!!!!!~~~~~^^^^^::::::...\n// ..::::::^^^^^~~~~~!!!!!777777!!~~~~~!!!!!~^~?5PY7~~!77!!?7!!7????JJ55555555Y?7JP5YJ?7JJY55555Y?7~^~!!!!!~~~~~!!777777!!!!!~~~~~^^^^^::::::..\n// ..::::::^^^^~~~~~!!!!!77!!~~~~~~~~7?JJJ?77!^:~?Y5Y!~!7!^7J7~~!7777?YYYYYYYYJ7?55J7JJ7J55555Y?!^:^!77?JJJ?7~~~~~~~~!!77!!!!!~~~~~^^^^^:::::..\n// .::::::^^^^^~~~~!!!!!!!^^^^^^~!!7777JJY?77!!~^.^7YY?~^!!^?J7~^^!77?YYYYYYYY7~75Y7JJ?JY555Y?!^:^~!!77?YJJ7777!!~^^^^^^!!!!!!!~~~~^^^^^::::::.\n// ::::::^^^^^~~~~~!!!!7!:!!^:^~~!!!7!777?JJ?77!~.::^7JJ7^^~~~????77?Y5PP5P55Y7?5Y?J???Y55Y?!^:::~!77?JJ?777!7!!!~~^:^!!^!7!!!!~~~~~^^^^^::::::\n// :::::^^^^^~~~~~!!!!77!:J?!^^^~~~!!!!!777??777~.^^::^7YJ!^^!!77!!7JJY555555J7!!77J??JYY?!^::^^:!777??777!!!!!~~~^^^!?J^!77!!!!~~~~~^^^^^:::::\n// :::::^^^^^~~~~!!!!!777~^!???7~^~~~!!!!!777777!.^~~~^^~?J!~^~~~!7??JJ55555Y?77!!???J?~^^:^~~~^:!777777!!!!!~~~^~7???!^~777!!!!!~~~~^^^^^:::::\n// ::::^^^^^~~~~~!!!!77777~^^~!??7~^~~~~~!!!!!777!.^!!~!!^^!?7!77!~!?JJ5555YJ7~^7JJJ!~:.:!!~!!^:!777!!!!!~~~~~^~7??!~^^~77777!!!!~~~~~^^^^^::::\n// ::::^^^^^~~~~!!!!!7777??7!^^^!??7~^~~~~~~!!!!!!.^~!!7??^.^!????????YPPPPJ~^~7JJ?!^:.^??7!!~^:!!!!!!~~~~~~^~7??!^^^!7??7777!!!!!~~~~^^^^^::::\n// ::::^^^^~~~~~!!!!77777777??~^^^~7?7~^~^~~~~!~!~.:!!7!75J::::!7????7?PPP5!^~7777~::::J57!7!!^:!!~!~~~~^~^~7?7~^^^~??77777777!!!!~~~~~^^^^::::\n// :::^^^^^~~~~!!!!!~~~^:::^^~7^:^^^~7?7!^^^^~~~~~..!!!77?5J:^^::~7?J?7JPPJ:~77!^::^^:J5?77!!!..~~~~~^^^^!7?7~^^^^~7~^^:::^~~~!!!!!~~~~^^^^^:::\n// ::::^^^^~~~~!!!~^^^^~^^^^:.::::^~^:~7??!^::^^^: :~!!!77?5J:^~~::~?JJ?P5~!??~::~~^:J5?77!!!~: :^^^::^!??7~:^~^::::.:^^^^~^^^^~!!!~~~~^^^^::::\n// ::::::^^~~~~!!~^^^~~~~^^^^:.::::^~^::~7??!^::::.::!7!!!7?5J^^~!!~^~?YPP?7~^~!!~^^J5?7!!!7!::.::::^!??7~::^~^::::.:^^^^~~~~^^^~!!~~~~^^::::::\n// ^^^^~~^^^^~~!~:^^~~!~~~^^^^:.::^~~^^:::^!??!:~!~::^!!!!!7?5J^^~!77~^~??~^~77!~^^J5?7!!!!!^::~!~:!??!^:::^^~~^::.:^^^^~~~!~~^^:~!~~^^^^~~^^^^\n// ^^^~~^:^^^^^~:^^~~!!!!!!!~~~^::~^^^^^^:::!J?!^!7!^::~!!!!7?5Y!^~!!7!~^^~!7!!~^!Y5?7!!!!~::^!7!^!?J!:::^^^^^^~::^~~~!!!!!!!~~^^:~^^^^::^~~^^^\n// !!~!7^.::^^::.^~~!!!!!77?JJJJ?!~^::^^^^^^~7?~:!!77!^^~~!!!7?J5Y7~^^~!~~!~^^~7Y5J?7!!!~~^^!77!!:~?7~^^^^^^::^~!?JJJJ?77!!!!!~~^.::^^::.^7!~!!\n// 777J?:.:^^^...:^~!!!7Y??7?777???!.:^~^^^~!~~!!!!!!7?7~^^^~~!77?JJ??~~~~~~??JJ?77!~~^^^~7?7!!!!!!~~!~^^^~^:.!??7777?7??Y7!!!~^:...^^^:.:?J777\n// !!7Y?::!77~:^^:.:^~7J??!!!7^~!!77~.:~7~~~~^^?J?!^^~~!7??!~^^^~~!!7????????7!!~~^^^~!??7!~~^^!?J?^^~~~~7~:.~777~^~~7!!??J7~^:.:^^:~77!::?Y7!!\n// !!7Y?::!!~:~?7~^:::^~~7!!7!^~~~7!!~.:~!!~~~^^^~: .:^^^^~~!7!~~~^:^^^^^^^^^^:^~~~!7!~~^^^^:. :~^^^~~~!!~:.~!!7!^~!~~7!7~~^:::^~7?~:~!!::?Y7!!\n// ?77?Y7^:^:~!??J?7!^::^~!!!~~~~!!!!~^.:^7?!~~^^^^::.:^^~!!~~~~~~^^^^^^^^^^^^^^~~~~~~!!~^^:.::^^^^~~!?7^:.^~!!!!~~~~!!!~^::^!7?J??!~:^:^7Y?77?\n// ??!7YJ^.:^!7???YYJ?7~~^^~~7!!!~~~~~~^::^~7??777!~!^^^^:::^~~~!!!!!!!!!!!!!!!!!!~~~^:::^^^^!~!777??7~^::^~~~~~~!!!7~~^^~~7?JYY???7!^:.^JY7!??\n// ??77YJ~.^~!77?JJJYYYYJ7!^^^~!777!!~~~~^::^^~!77????77?7!!~~~~^::::::::::::::::^~~~~!!7?77????77!~^^::^~~~~!!777!~^^^!7JYYYYJJJ?77!~^.~JY77??\n// J??77YJ~.^!!!JJ??777??YYJJ7!~^^~!77!~~~~~~~^^^^^~~!7777??????777777777777777777??????7777!~~^^^^^~~~~~~~!77!~^^~!7JJYY??777??JJ!!!^.~JY77??J\n// YY?77JY!:^!!!YJ?7!!!~~!!??JYJJ7!~^~~!!!~!!!!7777~~~~^^^~~~~~!777777777777777777!~~~~~^^^~~~~7777!!!!~!!!~~^~!7JJYJ??!!~~!!!7?JY!!!^:!YJ77?YY\n// YYJ?77JY!:~!!?Y?7!!!~~~~~~!!7?JYJ?7~^^~~!!!!7????????777777~~~~~~~~~~~~~~~~~~~~~~777777????????7!!!!~~^^~7?JYJ?7!!~~~~~~!!!7?Y?!!~:!YJ77?JYY\n// YJYJJ?7?J?^:!!?J?!!!~~~~~~~~~~~!7JJYY?~^^~!!77!7777?????????JJJJJJJJJJJJJJJJJJJJ?????????7777!77!!~^^~?YYJJ7!~~~~~~~~~~~!!!?J?!!:^?J?7?JJYJY\ncontract Infiltration is\n    IInfiltration,\n    OwnableTwoSteps,\n    ERC721A,\n    VRFConsumerBaseV2,\n    LowLevelERC20Transfer,\n    LowLevelWETH,\n    ProtocolFee,\n    PackableReentrancyGuard\n{\n    using UnsafeMathUint256 for uint256;\n\n    /**\n     * @notice When the frontrun lock is unlocked, agents can escape or heal.\n     */\n    uint8 private constant FRONTRUN_LOCK__UNLOCKED = 1;\n\n    /**\n     * @notice When the frontrun lock is locked, agents cannot escape or heal.\n     */\n    uint8 private constant FRONTRUN_LOCK__LOCKED = 2;\n\n    /**\n     * @notice When VRF is being requested, agents cannot escape or heal. It unlocks when the randomness is fulfilled.\n     * @dev frontrunLock is initially set as locked so that agents cannot escape or heal before the game starts.\n     *      It is unlocked when the first round's randomness is fulfilled.\n     */\n    uint8 private frontrunLock = FRONTRUN_LOCK__LOCKED;\n\n    /**\n     * @notice 100% in basis points.\n     */\n    uint256 private constant ONE_HUNDRED_PERCENT_IN_BASIS_POINTS = 10_000;\n\n    /**\n     * @notice 100% in basis points squared.\n     */\n    uint256 private constant ONE_HUNDRED_PERCENT_IN_BASIS_POINTS_SQUARED = 10_000 ** 2;\n\n    /**\n     * @notice The number of secondary prize pool winners. Their entitled shares are based on their placements.\n     *         When the number of active agents is less than or equal to this number, 1 agent is instantly killed\n     *         in each round.\n     */\n    uint256 private constant NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS = 50;\n\n    uint256 private constant PROBABILITY_PRECISION = 100_000_000;\n\n    /**\n     * @notice Max agent supply.\n     */\n    uint256 public immutable MAX_SUPPLY;\n\n    /**\n     * @notice Max mint per address.\n     */\n    uint256 public immutable MAX_MINT_PER_ADDRESS;\n\n    /**\n     * @notice The price of minting 1 agent.\n     */\n    uint256 public immutable PRICE;\n\n    /**\n     * @notice The number of blocks per round.\n     */\n    uint256 public immutable BLOCKS_PER_ROUND;\n\n    /**\n     * @notice The percentage of agents to wound per round in basis points.\n     */\n    uint256 public immutable AGENTS_TO_WOUND_PER_ROUND_IN_BASIS_POINTS;\n\n    /**\n     * @notice The number of rounds for agents to be wounded before getting killed.\n     */\n    uint256 public immutable ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD;\n\n    /**\n     * @notice This value is used as the denominator in healProbability.\n     */\n    uint256 private immutable ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE;\n\n    /**\n     * @notice This value is used as the minuend in healProbability.\n     */\n    uint256 private immutable HEAL_PROBABILITY_MINUEND;\n\n    /**\n     * @notice The base cost of healing an agent. The cost increases for each successful heal.\n     */\n    uint256 public immutable HEAL_BASE_COST;\n\n    /**\n     * @notice WETH address.\n     */\n    address private immutable WETH;\n\n    /**\n     * @notice LOOKS address.\n     */\n    address private immutable LOOKS;\n\n    /**\n     * @notice Chainlink VRF key hash.\n     */\n\n    bytes32 private immutable KEY_HASH;\n\n    /**\n     * @notice Chainlink VRF coordinator.\n     */\n    VRFCoordinatorV2Interface private immutable VRF_COORDINATOR;\n\n    /**\n     * @notice Chainlink VRF subscription ID.\n     */\n    uint64 private immutable SUBSCRIPTION_ID;\n\n    /**\n     * @notice The transfer manager contract that manages LOOKS approvals.\n     */\n    ITransferManager private immutable TRANSFER_MANAGER;\n\n    /**\n     * @notice The timestamp at which the mint period starts.\n     */\n    uint40 public mintStart;\n\n    /**\n     * @notice The timestamp at which the mint period ends.\n     */\n    uint40 public mintEnd;\n\n    /**\n     * @notice The bitmap of the placements of the secondary prize pool winners.\n     * @dev Only bit 1 to 50 are used. Bit 0 is not used.\n     */\n    uint56 private prizesClaimedBitmap;\n\n    /**\n     * @notice The base URI of the collection.\n     */\n    string private baseURI;\n\n    /**\n     * @notice Amount of agents minted per address.\n     */\n    mapping(address minter => uint256 amount) public amountMintedPerAddress;\n\n    /**\n     * @notice Chainlink randomness requests.\n     */\n    mapping(uint256 requestId => RandomnessRequest) public randomnessRequests;\n\n    /**\n     * @notice The mapping agents acts as an \"array\". In the beginning of the game, the \"length\" of the \"array\"\n     *         is the total supply. As the game progresses, the \"length\" of the \"array\" decreases\n     *         as agents are killed. The function agentsAlive() returns the \"length\" of the \"array\".\n     *\n     *         When an Agent struct has 0 value for every field with its index within the total supply,\n     *         it means that the agent is active.\n     *\n     *         Index 0 is not used as agent ID starts from 1.\n     */\n    mapping(uint256 index => Agent) private agents;\n\n    /**\n     * @notice It is used to find the index of an agent in the agents mapping given its agent ID.\n     *         If the index is 0, it means the agent's index is the same as its agent ID as no swaps\n     *         have been made.\n     */\n    mapping(uint256 agentId => uint256 index) private agentIdToIndex;\n\n    /**\n     * @notice The maximum healing or wounded agents allowed per round.\n     */\n    uint256 private constant MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND = 30;\n\n    /**\n     * @notice The maximum healing or wounded agents allowed per round + 1 for storing the array length.\n     */\n    uint256 private constant MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH = 31;\n\n    /**\n     * @notice The first element of the array is the length of the array.\n     */\n    mapping(uint256 roundId => uint16[MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH] agentIds)\n        private woundedAgentIdsPerRound;\n\n    /**\n     * @notice The first element of the array is the length of the array.\n     */\n    mapping(uint256 roundId => uint16[MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND_AND_LENGTH] agentIds)\n        private healingAgentIdsPerRound;\n\n    /**\n     * @notice Game information.\n     */\n    GameInfo public gameInfo;\n\n    /**\n     * @dev Agent struct status offset for bitwise operations.\n     */\n    uint256 private constant AGENT__STATUS_OFFSET = 16;\n\n    /**\n     * @dev Agent struct wounded at offset for bitwise operations.\n     */\n    uint256 private constant AGENT__WOUNDED_AT_OFFSET = 24;\n\n    /**\n     * @dev Agent struct heal count offset for bitwise operations.\n     */\n    uint256 private constant AGENT__HEAL_COUNT_OFFSET = 64;\n\n    /**\n     * @dev GameInfo struct wounded agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__WOUNDED_AGENTS_OFFSET = 16;\n\n    /**\n     * @dev GameInfo struct healing agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__HEALING_AGENTS_OFFSET = 32;\n\n    /**\n     * @dev GameInfo struct dead agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__DEAD_AGENTS_OFFSET = 48;\n\n    /**\n     * @dev GameInfo struct escaped agents offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__ESCAPED_AGENTS_OFFSET = 64;\n\n    /**\n     * @dev GameInfo struct current round ID offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__CURRENT_ROUND_ID_OFFSET = 80;\n\n    /**\n     * @dev GameInfo struct current round block number offset for bitwise operations.\n     */\n    uint256 private constant GAME_INFO__CURRENT_ROUND_BLOCK_NUMBER_OFFSET = 120;\n\n    /**\n     * @dev RandomnessRequest struct exists offset for bitwise operations.\n     */\n    uint256 private constant RANDOMNESS_REQUESTS__EXISTS_OFFSET = 8;\n\n    /**\n     * @dev 2 bytes bitmask.\n     */\n    uint256 private constant TWO_BYTES_BITMASK = 0xffff;\n\n    /**\n     * @dev 5 bytes bitmask.\n     */\n    uint256 private constant FIVE_BYTES_BITMASK = 0xffffffffff;\n\n    /**\n     * @param constructorCalldata Constructor calldata. See IInfiltration.ConstructorCalldata for its key values.\n     */\n    constructor(\n        ConstructorCalldata memory constructorCalldata\n    )\n        OwnableTwoSteps(constructorCalldata.owner)\n        ERC721A(constructorCalldata.name, constructorCalldata.symbol)\n        VRFConsumerBaseV2(constructorCalldata.vrfCoordinator)\n    {\n        if (\n            constructorCalldata.maxSupply <= NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS ||\n            constructorCalldata.maxSupply > type(uint16).max\n        ) {\n            revert InvalidMaxSupply();\n        }\n\n        if (\n            (constructorCalldata.maxSupply * constructorCalldata.agentsToWoundPerRoundInBasisPoints) >\n            MAXIMUM_HEALING_OR_WOUNDED_AGENTS_PER_ROUND * ONE_HUNDRED_PERCENT_IN_BASIS_POINTS\n        ) {\n            revert WoundedAgentIdsPerRoundExceeded();\n        }\n\n        if (constructorCalldata.roundsToBeWoundedBeforeDead < 3) {\n            revert RoundsToBeWoundedBeforeDeadTooLow();\n        }\n\n        PRICE = constructorCalldata.price;\n        MAX_SUPPLY = constructorCalldata.maxSupply;\n        MAX_MINT_PER_ADDRESS = constructorCalldata.maxMintPerAddress;\n        BLOCKS_PER_ROUND = constructorCalldata.blocksPerRound;\n        AGENTS_TO_WOUND_PER_ROUND_IN_BASIS_POINTS = constructorCalldata.agentsToWoundPerRoundInBasisPoints;\n        ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD = constructorCalldata.roundsToBeWoundedBeforeDead;\n\n        // The next 2 values are used in healProbability\n        ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE = ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD.unsafeSubtract(1);\n        HEAL_PROBABILITY_MINUEND =\n            ((ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD * 99 - 80) * PROBABILITY_PRECISION) /\n            ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD_MINUS_ONE;\n\n        LOOKS = constructorCalldata.looks;\n        HEAL_BASE_COST = constructorCalldata.healBaseCost;\n\n        KEY_HASH = constructorCalldata.keyHash;\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(constructorCalldata.vrfCoordinator);\n        SUBSCRIPTION_ID = constructorCalldata.subscriptionId;\n\n        TRANSFER_MANAGER = ITransferManager(constructorCalldata.transferManager);\n        WETH = constructorCalldata.weth;\n\n        baseURI = constructorCalldata.baseURI;\n\n        _updateProtocolFeeRecipient(constructorCalldata.protocolFeeRecipient);\n        _updateProtocolFeeBp(constructorCalldata.protocolFeeBp);\n    }\n\n    /**\n     * @dev updateProtocolFeeBp is not implemented in this contract.\n     */\n    function updateProtocolFeeBp(uint16) external pure override {\n        revert Immutable();\n    }\n\n    /**\n     * @dev updateProtocolFeeRecipient is not implemented in this contract.\n     */\n    function updateProtocolFeeRecipient(address) external pure override {\n        revert Immutable();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function setMintPeriod(uint40 newMintStart, uint40 newMintEnd) external onlyOwner {\n        if (newMintStart >= newMintEnd) {\n            revert InvalidMintPeriod();\n        }\n\n        if (newMintStart != 0) {\n            if (block.timestamp > newMintStart) {\n                revert MintStartIsInThePast();\n            }\n\n            uint256 currentMintStart = mintStart;\n            if (currentMintStart != 0) {\n                if (block.timestamp >= currentMintStart) {\n                    revert MintAlreadyStarted();\n                }\n            }\n\n            mintStart = newMintStart;\n        }\n\n        if (block.timestamp > newMintEnd || newMintEnd < mintEnd) {\n            revert MintCanOnlyBeExtended();\n        }\n\n        mintEnd = newMintEnd;\n\n        emit MintPeriodUpdated(newMintStart == 0 ? mintStart : newMintStart, newMintEnd);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @notice As long as the game has not started (after mint end), the owner can still mint.\n     */\n    function premint(address to, uint256 quantity) external payable onlyOwner {\n        if (quantity * PRICE != msg.value) {\n            revert InsufficientNativeTokensSupplied();\n        }\n\n        if (totalSupply() + quantity > MAX_SUPPLY) {\n            revert ExceededTotalSupply();\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        _mintERC2309(to, quantity);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function mint(uint256 quantity) external payable nonReentrant {\n        if (block.timestamp < mintStart || block.timestamp > mintEnd) {\n            revert NotInMintPeriod();\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        uint256 amountMinted = amountMintedPerAddress[msg.sender] + quantity;\n        if (amountMinted > MAX_MINT_PER_ADDRESS) {\n            revert TooManyMinted();\n        }\n\n        if (quantity * PRICE != msg.value) {\n            revert InsufficientNativeTokensSupplied();\n        }\n\n        if (totalSupply() + quantity > MAX_SUPPLY) {\n            revert ExceededTotalSupply();\n        }\n\n        amountMintedPerAddress[msg.sender] = amountMinted;\n        _mintERC2309(msg.sender, quantity);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @dev If Chainlink randomness callback does not come back after 1 day, we can call\n     *      startNewRound to trigger a new randomness request.\n     */\n    function startGame() external onlyOwner {\n        uint256 numberOfAgents = totalSupply();\n        if (numberOfAgents < MAX_SUPPLY) {\n            if (block.timestamp < mintEnd) {\n                revert StillMinting();\n            }\n        }\n\n        if (gameInfo.currentRoundId != 0) {\n            revert GameAlreadyBegun();\n        }\n\n        gameInfo.currentRoundId = 1;\n        gameInfo.activeAgents = uint16(numberOfAgents);\n        uint256 balance = address(this).balance;\n        uint256 protocolFee = balance.unsafeMultiply(protocolFeeBp).unsafeDivide(ONE_HUNDRED_PERCENT_IN_BASIS_POINTS);\n        unchecked {\n            gameInfo.prizePool = balance - protocolFee;\n        }\n\n        emit RoundStarted(1);\n\n        _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFee, gasleft());\n        _requestForRandomness();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function emergencyWithdraw() external onlyOwner {\n        uint256 activeAgents;\n        uint256 woundedAgents;\n        uint256 healingAgents;\n        uint256 escapedAgents;\n        uint256 deadAgents;\n        uint256 currentRoundId;\n        uint256 currentRoundBlockNumber;\n\n        assembly {\n            let gameInfoSlot0Value := sload(gameInfo.slot)\n            activeAgents := and(gameInfoSlot0Value, TWO_BYTES_BITMASK)\n            woundedAgents := and(shr(GAME_INFO__WOUNDED_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            healingAgents := and(shr(GAME_INFO__HEALING_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            escapedAgents := and(shr(GAME_INFO__ESCAPED_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            deadAgents := and(shr(GAME_INFO__DEAD_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n            currentRoundId := and(shr(GAME_INFO__CURRENT_ROUND_ID_OFFSET, gameInfoSlot0Value), FIVE_BYTES_BITMASK)\n            currentRoundBlockNumber := and(\n                shr(GAME_INFO__CURRENT_ROUND_BLOCK_NUMBER_OFFSET, gameInfoSlot0Value),\n                FIVE_BYTES_BITMASK\n            )\n        }\n\n        bool conditionOne = currentRoundId != 0 &&\n            activeAgents + woundedAgents + healingAgents + escapedAgents + deadAgents != totalSupply();\n\n        // 50 blocks per round * 216 = 10,800 blocks which is roughly 36 hours\n        // Prefer not to hard code this number as BLOCKS_PER_ROUND is not always 50\n        bool conditionTwo = currentRoundId != 0 &&\n            activeAgents > 1 &&\n            block.number > currentRoundBlockNumber + BLOCKS_PER_ROUND * 216;\n\n        // Just in case startGame reverts, we can withdraw the ETH balance and redistribute to addresses that participated in the mint.\n        bool conditionThree = currentRoundId == 0 && block.timestamp > uint256(mintEnd).unsafeAdd(36 hours);\n\n        if (conditionOne || conditionTwo || conditionThree) {\n            uint256 ethBalance = address(this).balance;\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethBalance, gasleft());\n\n            uint256 looksBalance = IERC20(LOOKS).balanceOf(address(this));\n            _executeERC20DirectTransfer(LOOKS, msg.sender, looksBalance);\n\n            emit EmergencyWithdrawal(ethBalance, looksBalance);\n        }\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     * @dev If Chainlink randomness callback does not come back after 1 day, we can try by calling\n     *      startNewRound again.\n     */\n    function startNewRound() external nonReentrant {\n        uint256 currentRoundId = gameInfo.currentRoundId;\n        if (currentRoundId == 0) {\n            revert GameNotYetBegun();\n        }\n\n        if (block.number < uint256(gameInfo.currentRoundBlockNumber).unsafeAdd(BLOCKS_PER_ROUND)) {\n            revert TooEarlyToStartNewRound();\n        }\n\n        uint256 activeAgents = gameInfo.activeAgents;\n        if (activeAgents == 1) {\n            revert GameOver();\n        }\n\n        if (block.timestamp < uint256(gameInfo.randomnessLastRequestedAt).unsafeAdd(1 days)) {\n            revert TooEarlyToRetryRandomnessRequest();\n        }\n\n        if (activeAgents <= NUMBER_OF_SECONDARY_PRIZE_POOL_WINNERS) {\n            uint256 woundedAgents = gameInfo.woundedAgents;\n\n            if (woundedAgents != 0) {\n                uint256 killRoundId = currentRoundId > ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD\n                    ? currentRoundId.unsafeSubtract(ROUNDS_TO_BE_WOUNDED_BEFORE_DEAD)\n                    : 1;\n                uint256 agentsRemaining = agentsAlive();\n                uint256 totalDeadAgentsFromKilling;\n                while (woundedAgentIdsPerRound[killRoundId][0] != 0) {\n                    uint256 deadAgentsFromKilling = _killWoundedAgents({\n                        roundId: killRoundId,\n                        currentRoundAgentsAlive: agentsRemaining\n                    });\n                    unchecked {\n                        totalDeadAgentsFromKilling += deadAgentsFromKilling;\n                        agentsRemaining -= deadAgentsFromKilling;\n                        ++killRoundId;\n                    }\n                }\n\n                // This is equivalent to\n                // unchecked {\n                //     gameInfo.deadAgents += uint16(totalDeadAgentsFromKilling);\n                // }\n                // gameInfo.woundedAgents = 0;\n                assembly {\n                    let gameInfoSlot0Value := sload(gameInfo.slot)\n                    let deadAgents := and(shr(GAME_INFO__DEAD_AGENTS_OFFSET, gameInfoSlot0Value), TWO_BYTES_BITMASK)\n\n                    gameInfoSlot0Value := and(\n                        gameInfoSlot0Value,\n                        // This is equivalent to\n                        // not(\n                        //     or(\n                        //         shl(GAME_INFO__WOUNDED_AGENTS_OFFSET, TWO_BYTES_BITMASK),\n                        //         shl(GAME_INFO__DEAD_AGENTS_OFFSET, TWO_BYTES_BITMASK)\n                        //     )\n                        // )\n                        0xffffffffffffffffffffffffffffffffffffffffffffffff0000ffff0000ffff\n                    )\n\n                    gameInfoSlot0Value := or(\n                        gameInfoSlot0Value,\n                        shl(GAME_INFO__DEAD_AGENTS_OFFSET, add(deadAgents, totalDeadAgentsFromKilling))\n                    )\n\n                    sstore(gameInfo.slot, gameInfoSlot0Value)\n                }\n            }\n        }\n\n        _requestForRandomness();\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function claimGrandPrize() external nonReentrant {\n        _assertGameOver();\n        uint256 agentId = agents[1].agentId;\n        _assertAgentOwnership(agentId);\n\n        uint256 prizePool = gameInfo.prizePool;\n\n        if (prizePool == 0) {\n            revert NothingToClaim();\n        }\n\n        gameInfo.prizePool = 0;\n\n        _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, prizePool, gasleft());\n\n        emit PrizeClaimed(agentId, address(0), prizePool);\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function claimSecondaryPrizes(uint256 agentId) external nonReentrant {\n        _assertGameOver();\n        _assertAgentOwnership(agentId);\n\n        uint256 placement = agentIndex(agentId);\n        _assertValidPlacement(placement);\n\n        uint56 _prizesClaimedBitmap = prizesClaimedBitmap;\n        if ((_prizesClaimedBitmap >> placement) & 1 != 0) {\n            revert NothingToClaim();\n        }\n\n        prizesClaimedBitmap = _prizesClaimedBitmap | uint56(1 << placement);\n\n        uint256 ethAmount = secondaryPrizePoolShareAmount(gameInfo.secondaryPrizePool, placement);\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n            emit PrizeClaimed(agentId, address(0), ethAmount);\n        }\n\n        uint256 secondaryLooksPrizePool = gameInfo.secondaryLooksPrizePool;\n        if (secondaryLooksPrizePool == 0) {\n            secondaryLooksPrizePool = IERC20(LOOKS).balanceOf(address(this));\n            if (secondaryLooksPrizePool == 0) {\n                return;\n            }\n            gameInfo.secondaryLooksPrizePool = secondaryLooksPrizePool;\n        }\n\n        uint256 looksAmount = secondaryPrizePoolShareAmount(secondaryLooksPrizePool, placement);\n        if (looksAmount != 0) {\n            _executeERC20DirectTransfer(LOOKS, msg.sender, looksAmount);\n            emit PrizeClaimed(agentId, LOOKS, looksAmount);\n        }\n    }\n\n    /**\n     * @inheritdoc IInfiltration\n     */\n    function escape(uint256[] calldata agentIds) external nonReentrant {\n        _assertFrontrunLockIsOff();\n\n        uint256 agentIdsCount = agentIds.length;\n        _assertNotEmptyAgentIdsArrayProvided(agentIdsCount);\n\n        uint256 activeAgents = gameInfo.activeAgents;\n        uint256 activeAgentsAfterEscape = activeAgents - agentIdsCount;\n        _assertGameIsNotOverAfterEscape(activeAgentsAfterEscape);\n\n        uint256 currentRoundAgentsAlive = agentsAlive();\n\n        uint256 prizePool = gameInfo.prizePool;\n        uint256 secondaryPrizePool = gameInfo.secondaryPrizePool;\n        uint256 reward;\n        uint256[] memory rewards = new uint256[](agentIdsCount);\n\n        for (uint256 i; i < agentIdsCount; ) {\n            uint256 agentId = agentIds[i];\n            _assertAgentOwnership(agentId);\n\n            uint256 index = agentIndex(agentId);\n            _assertAgentStatus(agents[index], agentId, AgentStatus.Active);\n\n            uint256 totalEscapeValue = prizePool / currentRoundAgentsAlive;\n            uint256 rewardForPlayer = (totalEscapeValue * _escapeMultiplier(currentRoundAgentsAlive)) /\n                ONE_HUNDRED_PERCENT_IN_BASIS_POINTS;\n            rewards[i] = rewardForPlayer;\n            reward += rewardForPlayer;\n\n            uint256 rewardToSecondaryPrizePool = (totalEscapeValue.unsafeSubtract(rewardForPlayer) *\n                _escapeRewardSplitForSecondaryPrizePool(currentRoundAgentsAlive)) / ONE_HUNDRED_PERCENT_IN_BASIS_POINTS;\n\n            unchecked {\n                prizePool = prizePool - rewardForPlayer - rewardToSecondaryPrizePool;\n            }\n            secondaryPrizePool += rewardToSecondaryPrizePool;\n\n            _swap({\n                currentAgentIndex: index,\n                lastAgentIn"
    }
  ]
}