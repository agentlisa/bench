{
  "Title": "Use of hardcoded price deviation in baseOracleCircuitBreaker()",
  "Content": "# Use of hardcoded price deviation in baseOracleCircuitBreaker()\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L77-L78\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L77-L78</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L81\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L81</a>\n\n\n## Summary\n\nThe `LibOracle::baseOracleCircuitBreaker()` uses the hardcoded value of 50% price deviation, which might be too large when using the ETH as a base price reference. Moreover, the fixed % deviation is considered too risky because the protocol's DAO or admin will not be able to update it in production.\n\n## Vulnerability Details\n\n> **This report raises an issue regarding the `priceDeviation` variable only**, as the `invalidFetchData` (2-hour stale check) was flagged as a known issue.\n\nThe `baseOracleCircuitBreaker()` is used for verifying the price reported by Chainlink. If the reported price is invalid or its [price deviation when compared to the protocol's cached oracle price is more than 50%](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L77-L78), the function will fall back to get Uniswap's TWAP price instead.\n\nHowever, the `baseOracleCircuitBreaker()` uses a [hardcoded value of 50% price deviation](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L78) (`0.5 ether`), which might be too large when using the ETH as a base price reference. Moreover, the fixed % deviation is considered too risky because the protocol's DAO or admin will not be able to update it in production.\n\n```solidity\n    //@audit -- this report raises an issue regarding the priceDeviation variable only, as the invalidFetchData (2-hour stale check) was flagged as a known issue\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n@>      bool priceDeviation =\n@>          protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n@>      if (invalidFetchData || priceDeviation) { //@audit -- this report raises an issue regarding the priceDeviation variable only, as the invalidFetchData (2-hour stale check) was flagged as a known issue\n            ...\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n```\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L77-L78\n\n- https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L81\n\n## Impact\n\n> **This report raises an issue regarding the `priceDeviation` variable only**, as the `invalidFetchData` (2-hour stale check) was flagged as a known issue.\n\nThe use of the hardcoded value of 50% price deviation (`0.5 ether`) might be too large when using the ETH as a base price reference. Moreover, the fixed % deviation is considered too risky because the protocol's DAO or admin will not be able to update it in production.\n\nConsequently, the [check for price deviation](https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOracle.sol#L81) in the `baseOracleCircuitBreaker()` might not be effective enough for filtering out the stale price in production, directly affecting the quality of the oracle price that will be consumed by the core functions of the `Ditto` protocol (HIGH impact).\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nThe % price deviation should be a variable updatable by the protocol's DAO or admin in production.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n            return getPrice(asset);\n        } else {\n            return getOraclePrice(asset);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AggregatorV3Interface} from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOracle {\n    using U256 for uint256;\n\n    function getOraclePrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = appStorage();\n        AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n        uint256 protocolPrice = getPrice(asset);\n        // prettier-ignore\n        (\n            uint80 baseRoundID,\n            int256 basePrice,\n            /*uint256 baseStartedAt*/\n            ,\n            uint256 baseTimeStamp,\n            /*uint80 baseAnsweredInRound*/\n        ) = baseOracle.latestRoundData();\n\n        AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n        if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n\n        if (oracle == baseOracle) {\n            //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n            uint256 basePriceInEth = basePrice > 0\n                ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n                : 0;\n            basePriceInEth = baseOracleCircuitBreaker(\n                protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n            );\n            return basePriceInEth;\n        } else {\n            // prettier-ignore\n            (\n                uint80 roundID,\n                int256 price,\n                /*uint256 startedAt*/\n                ,\n                uint256 timeStamp,\n                /*uint80 answeredInRound*/\n            ) = oracle.latestRoundData();\n            uint256 priceInEth = uint256(price).div(uint256(basePrice));\n            oracleCircuitBreaker(\n                roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n            );\n            return priceInEth;\n        }\n    }\n\n    function baseOracleCircuitBreaker(\n        uint256 protocolPrice,\n        uint80 roundId,\n        int256 chainlinkPrice,\n        uint256 timeStamp,\n        uint256 chainlinkPriceInEth\n    ) private view returns (uint256 _protocolPrice) {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0\n            || block.timestamp > 2 hours + timeStamp;\n        uint256 chainlinkDiff = chainlinkPriceInEth > protocolPrice\n            ? chainlinkPriceInEth - protocolPrice\n            : protocolPrice - chainlinkPriceInEth;\n        bool priceDeviation =\n            protocolPrice > 0 && chainlinkDiff.div(protocolPrice) > 0.5 ether;\n\n        //@dev if there is issue with chainlink, get twap price. Compare twap and chainlink\n        if (invalidFetchData || priceDeviation) {\n            uint256 twapPrice = IDiamond(payable(address(this))).estimateWETHInUSDC(\n                Constants.UNISWAP_WETH_BASE_AMT, 30 minutes\n            );\n            uint256 twapPriceInEther = (twapPrice / Constants.DECIMAL_USDC) * 1 ether;\n            uint256 twapPriceInv = twapPriceInEther.inv();\n            if (twapPriceInEther == 0) {\n                revert Errors.InvalidTwapPrice();\n            }\n\n            if (invalidFetchData) {\n                return twapPriceInv;\n            } else {\n                uint256 twapDiff = twapPriceInv > protocolPrice\n                    ? twapPriceInv - protocolPrice\n                    : protocolPrice - twapPriceInv;\n                //@dev save the price that is closest to saved oracle price\n                if (chainlinkDiff <= twapDiff) {\n                    return chainlinkPriceInEth;\n                }\n                //@dev In case USDC_WETH suddenly has no liquidity\n                IERC20 weth = IERC20(Constants.WETH);\n                uint256 wethBal = weth.balanceOf(Constants.USDC_WETH);\n                if (wethBal < 100 ether) revert Errors.InsufficientEthInLiquidityPool();\n                return twapPriceInv;\n            }\n        } else {\n            return chainlinkPriceInEth;\n        }\n    }\n\n    function oracleCircuitBreaker(\n        uint80 roundId,\n        uint80 baseRoundId,\n        int256 chainlinkPrice,\n        int256 baseChainlinkPrice,\n        uint256 timeStamp,\n        uint256 baseTimeStamp\n    ) private view {\n        bool invalidFetchData = roundId == 0 || timeStamp == 0\n            || timeStamp > block.timestamp || chainlinkPrice <= 0 || baseRoundId == 0\n            || baseTimeStamp == 0 || baseTimeStamp > block.timestamp\n            || baseChainlinkPrice <= 0;\n\n        if (invalidFetchData) revert Errors.InvalidPrice();\n    }\n\n    /* \n    @dev Constants.HEAD to marks the start/end of the linked list, so the only properties needed are id/nextId/prevId.\n    Helper methods are used to set the values of oraclePrice and oracleTime since they are set to different properties\n    */\n    function setPriceAndTime(address asset, uint256 oraclePrice, uint32 oracleTime)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        s.bids[asset][Constants.HEAD].ercAmount = uint80(oraclePrice);\n        s.bids[asset][Constants.HEAD].creationTime = oracleTime;\n    }\n\n    //@dev Intentionally using creationTime for oracleTime.\n    function getTime(address asset) internal view returns (uint256 creationTime) {\n        AppStorage storage s = appStorage();\n        return s.bids[asset][Constants.HEAD].creationTime;\n    }\n\n    //@dev Intentionally using ercAmount for oraclePrice. Storing as price may lead to bugs in the match algos.\n    function getPrice(address asset) internal view returns (uint80 oraclePrice) {\n        AppStorage storage s = appStorage();\n        return uint80(s.bids[asset][Constants.HEAD].ercAmount);\n    }\n\n    //@dev allows caller to save gas since reading spot price costs ~16K\n    function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n        if (LibOrd"
    }
  ]
}