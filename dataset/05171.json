{
  "Title": "[M-07] Erroneous probability calculation in physical attributes can lead to significant issues",
  "Content": "\nTo determine what physical attributes a user gets first we obtain a `rarityRank` which is computed from the DNA.\n\n[AiArenaHelper.sol#L106-L110](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L106C1-L110C18)\n\n```solidity\n                } else {\n                    uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\n                    uint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);\n                    finalAttributeProbabilityIndexes[i] = attributeIndex;\n                }\n```\n\nHere since we use `% 100` operation is used, the range of `rarityRank` would be \\[0,99].\n\nThis `rarityRank` is used in the `dnaToIndex` to determine the final attribute of the part.\n\n[AiArenaHelper.sol#L165-L186](https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/AiArenaHelper.sol#L165C1-L186C6)\n\n```solidity\n     /// @dev Convert DNA and rarity rank into an attribute probability index.\n     /// @param attribute The attribute name.\n     /// @param rarityRank The rarity rank.\n     /// @return attributeProbabilityIndex attribute probability index.\n    function dnaToIndex(uint256 generation, uint256 rarityRank, string memory attribute) \n        public \n        view \n        returns (uint256 attributeProbabilityIndex) \n    {\n        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);\n        \n        uint256 cumProb = 0;\n        uint256 attrProbabilitiesLength = attrProbabilities.length;\n        for (uint8 i = 0; i < attrProbabilitiesLength; i++) {\n            cumProb += attrProbabilities[i];\n            if (cumProb >= rarityRank) {\n                attributeProbabilityIndex = i + 1;\n                break;\n            }\n        }\n        return attributeProbabilityIndex;\n    }\n```\n\nThere is however, a very subtle bug in the calculation above due to the use of `cumProb >= rarityRank` as opposed to `cumProb > rarityRank`.\n\nTo explain the above, I will perform a calculation using a simple example. Let's say we only have 2 possible attributes and the `attrProbabilities` is \\[50, 50].\n\n1.  First iteration, when `i = 0`, we have `cumProb = 50`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[0, 50]. Therefore there is a 51\\% chance of obtaining this attribute\n\n2.  Next iteration, when `i = 1`, we have `cumProb = 100`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[51, 99]. Therefore there is a 49\\% chance of obtaining this attribute.\n\nThis means that for values in the first index, the probability is 1\\% greater than intended and for values in the last index the probability is 1\\% lesser than intended. This can be significant in certain cases, let us run through two of them.\n\n**Case 1: The first value in `attrProbabilities` is 1.**\n\nIf the first value in `attrProbabilities` is 1. Let's say \\[1, 99].\n\nThen in reality if we perform the calculation above we get the following results:\n\n1.  First iteration, when `i = 0`, we have `cumProb = 1`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[0, 1]. Therefore there is a 2\\% chance of obtaining this attribute\n\n2.  Next iteration, when `i = 1`, we have `cumProb = 100`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[2, 99]. Therefore there is a 98\\% chance of obtaining this attribute.\n\nThen we have twice the chance of getting the rarer item, which would make it twice as common, thus devaluing it.\n\n**Case 2: The last value in `attrProbabilities` is 1.**\n\nIf the last value in `attrProbabilities` is 1. Let's say \\[99, 1].\n\nThen in reality if we perform the calculation above we get the following results:\n\n1.  First iteration, when `i = 0`, we have `cumProb = 99`, for the `if (cumProb >= rarityRank)` to be entered the range of values `rarityRank` can be is \\[0, 99]. Therefore we will always enter the `if (cumProb >= rarityRank)` block.\n\nThen it would be impossible (0\\% chance) to obtain the 1\\% item.\n\n### Recommended Mitigation Steps\n\nIt should be `cumProb > rarityRank`. Going back to our example of \\[50, 50], if it were `cumProb > rarityRank`. Then we will get the following results:\n\n1.  First iteration, when `i = 0`, we have `cumProb = 50`, for the `if (cumProb > rarityRank)` to be entered the range of values `rarityRank` can be is \\[0, 49]. Therefore there is a 50\\% chance of obtaining this attribute\n\n2.  Next iteration, when `i = 1`, we have `cumProb = 100`, for the `if (cumProb > rarityRank)` to be entered the range of values `rarityRank` can be is \\[50, 99]. Therefore there is a 50\\% chance of obtaining this attribute.\n\nThus the above recommended mitigation is correct.\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/112#issuecomment-1977903075):**\n > Valid issue: wrong inclusion of boundary skews the probability to one-side by 1\\%.<br>\n > The shift in probabilities will affect trait generation, which affects fighter valuations.\n\n_Note: For full discussion, see [here](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/112)._\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/AiArenaHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.20;\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterOps } from \"./FighterOps.sol\";\n\n/// @title AI Arena Helper\n/// @author ArenaX Labs Inc.\n/// @notice This contract generates and manages an AI Arena fighters physical attributes.\ncontract AiArenaHelper {\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of attributes\n    string[] public attributes = [\"head\", \"eyes\", \"mouth\", \"body\", \"hands\", \"feet\"];\n\n    /// @notice Default DNA divisors for attributes\n    uint8[] public defaultAttributeDivisor = [2, 3, 5, 7, 11, 13];\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/    \n    \n    /// @notice Mapping tracking fighter generation to attribute probabilities\n    mapping(uint256 => mapping(string => uint8[])) public attributeProbabilities;\n\n    /// @notice Mapping of attribute to DNA divisors\n    mapping(string => uint8) public attributeToDnaDivisor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructor to initialize the contract with the attribute probabilities for gen 0.\n    /// @param probabilities An array of attribute probabilities for the generation.\n    constructor(uint8[][] memory probabilities) {\n        _ownerAddress = msg.sender;\n\n        // Initialize the probabilities for each attribute\n        addAttributeProbabilities(0, probabilities);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[0][attributes[i]] = probabilities[i];\n            attributeToDnaDivisor[attributes[i]] = defaultAttributeDivisor[i];\n        }\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Add attribute divisors for attributes.\n    /// @param attributeDivisors An array of attribute divisors.\n    function addAttributeDivisor(uint8[] memory attributeDivisors) external {\n        require(msg.sender == _ownerAddress);\n        require(attributeDivisors.length == attributes.length);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeToDnaDivisor[attributes[i]] = attributeDivisors[i];\n        }\n    }    \n\n    /// @notice Create physical attributes for a fighter based on DNA.\n    /// @param dna The DNA of the fighter.\n    /// @param iconsType Type of icons fighter (0 means it's not an icon).\n    /// @param dendroidBool Whether the fighter is a dendroid or not\n    /// @return Fighter physical attributes.\n    function createPhysicalAttributes(\n        uint256 dna, \n        uint8 generation, \n        uint8 iconsType, \n        bool dendroidBool\n    ) \n        external \n        view \n        returns (FighterOps.FighterPhysicalAttributes memory) \n    {\n        if (dendroidBool) {\n            return FighterOps.FighterPhysicalAttributes(99, 99, 99, 99, 99, 99);\n        } else {\n            uint256[] memory finalAttributeProbabilityIndexes = new uint[](attributes.length);\n\n            uint256 attributesLength = attributes.length;\n            for (uint8 i = 0; i < attributesLength; i++) {\n                if (\n                  i == 0 && iconsType == 2 || // Custom icons head (beta helmet)\n                  i == 1 && iconsType > 0 || // Custom icons eyes (red diamond)\n                  i == 4 && iconsType == 3 // Custom icons hands (bowling ball)\n                ) {\n                    finalAttributeProbabilityIndexes[i] = 50;\n                } else {\n                    uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\n                    uint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);\n                    finalAttributeProbabilityIndexes[i] = attributeIndex;\n                }\n            }\n            return FighterOps.FighterPhysicalAttributes(\n                finalAttributeProbabilityIndexes[0],\n                finalAttributeProbabilityIndexes[1],\n                finalAttributeProbabilityIndexes[2],\n                finalAttributeProbabilityIndexes[3],\n                finalAttributeProbabilityIndexes[4],\n                finalAttributeProbabilityIndexes[5]\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n     /// @notice Add attribute probabilities for a given generation.\n     /// @dev Only the owner can call this function.\n     /// @param generation The generation number.\n     /// @param probabilities An array of attribute probabilities for the generation.\n    function addAttributeProbabilities(uint256 generation, uint8[][] memory probabilities) public {\n        require(msg.sender == _ownerAddress);\n        require(probabilities.length == 6, \"Invalid number of attribute arrays\");\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[generation][attributes[i]] = probabilities[i];\n        }\n    }\n\n     /// @notice Delete attribute probabilities for a given generation. \n     /// @dev Only the owner can call this function.\n     /// @param generation The generation number.\n    function deleteAttributeProbabilities(uint8 generation) public {\n        require(msg.sender == _ownerAddress);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[generation][attributes[i]] = new uint8[](0);\n        }\n    }\n\n     /// @dev Get the attribute probabilities for a given generation and attribute.\n     /// @param generation The generation number.\n     /// @param attribute The attribute name.\n     /// @return Attribute probabilities.\n    function getAttributeProbabilities(uint256 generation, string memory attribute) \n        public \n        view \n        returns (uint8[] memory) \n    {\n        return attributeProbabilities[generation][attribute];\n    }    \n\n     /// @dev Convert DNA and rarity rank into an attribute probability index.\n     /// @param attribute The attribute name.\n     /// @param rarityRank The rarity rank.\n     /// @return attributeProbabilityIndex attribute probability index.\n    function dnaToIndex(uint256 generation, uint256 rarityRank, string memory attribute) \n        public \n        view \n        returns (uint256 attributeProbabilityIndex) \n    {\n        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);\n        \n        uint256 cumProb = 0;\n        uint256 attrProbabilitiesLength = attrProbabilities.length;\n        for (uint8 i = 0; i < attrProbabilitiesLength; i++) {\n            cumProb += attrProbabilities[i];\n            if (cumProb >= rarityRank) {\n                attributeProbabilityIndex = i + 1;\n                break;\n            }\n        }\n        return attributeProbabilityIndex;\n    }\n}"
    },
    {
      "filename": "src/AiArenaHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.20;\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterOps } from \"./FighterOps.sol\";\n\n/// @title AI Arena Helper\n/// @author ArenaX Labs Inc.\n/// @notice This contract generates and manages an AI Arena fighters physical attributes.\ncontract AiArenaHelper {\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of attributes\n    string[] public attributes = [\"head\", \"eyes\", \"mouth\", \"body\", \"hands\", \"feet\"];\n\n    /// @notice Default DNA divisors for attributes\n    uint8[] public defaultAttributeDivisor = [2, 3, 5, 7, 11, 13];\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/    \n    \n    /// @notice Mapping tracking fighter generation to attribute probabilities\n    mapping(uint256 => mapping(string => uint8[])) public attributeProbabilities;\n\n    /// @notice Mapping of attribute to DNA divisors\n    mapping(string => uint8) public attributeToDnaDivisor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructor to initialize the contract with the attribute probabilities for gen 0.\n    /// @param probabilities An array of attribute probabilities for the generation.\n    constructor(uint8[][] memory probabilities) {\n        _ownerAddress = msg.sender;\n\n        // Initialize the probabilities for each attribute\n        addAttributeProbabilities(0, probabilities);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[0][attributes[i]] = probabilities[i];\n            attributeToDnaDivisor[attributes[i]] = defaultAttributeDivisor[i];\n        }\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Add attribute divisors for attributes.\n    /// @param attributeDivisors An array of attribute divisors.\n    function addAttributeDivisor(uint8[] memory attributeDivisors) external {\n        require(msg.sender == _ownerAddress);\n        require(attributeDivisors.length == attributes.length);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeToDnaDivisor[attributes[i]] = attributeDivisors[i];\n        }\n    }    \n\n    /// @notice Create physical attributes for a fighter based on DNA.\n    /// @param dna The DNA of the fighter.\n    /// @param iconsType Type of icons fighter (0 means it's not an icon).\n    /// @param dendroidBool Whether the fighter is a dendroid or not\n    /// @return Fighter physical attributes.\n    function createPhysicalAttributes(\n        uint256 dna, \n        uint8 generation, \n        uint8 iconsType, \n        bool dendroidBool\n    ) \n        external \n        view \n        returns (FighterOps.FighterPhysicalAttributes memory) \n    {\n        if (dendroidBool) {\n            return FighterOps.FighterPhysicalAttributes(99, 99, 99, 99, 99, 99);\n        } else {\n            uint256[] memory finalAttributeProbabilityIndexes = new uint[](attributes.length);\n\n            uint256 attributesLength = attributes.length;\n            for (uint8 i = 0; i < attributesLength; i++) {\n                if (\n                  i == 0 && iconsType == 2 || // Custom icons head (beta helmet)\n                  i == 1 && iconsType > 0 || // Custom icons eyes (red diamond)\n                  i == 4 && iconsType == 3 // Custom icons hands (bowling ball)\n                ) {\n                    finalAttributeProbabilityIndexes[i] = 50;\n                } else {\n                    uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;\n                    uint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);\n                    finalAttributeProbabilityIndexes[i] = attributeIndex;\n                }\n            }\n            return FighterOps.FighterPhysicalAttributes(\n                finalAttributeProbabilityIndexes[0],\n                finalAttributeProbabilityIndexes[1],\n                finalAttributeProbabilityIndexes[2],\n                finalAttributeProbabilityIndexes[3],\n                finalAttributeProbabilityIndexes[4],\n                finalAttributeProbabilityIndexes[5]\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n     /// @notice Add attribute probabilities for a given generation.\n     /// @dev Only the owner can call this function.\n     /// @param generation The generation number.\n     /// @param probabilities An array of attribute probabilities for the generation.\n    function addAttributeProbabilities(uint256 generation, uint8[][] memory probabilities) public {\n        require(msg.sender == _ownerAddress);\n        require(probabilities.length == 6, \"Invalid number of attribute arrays\");\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[generation][attributes[i]] = probabilities[i];\n        }\n    }\n\n     /// @notice Delete attribute probabilities for a given generation. \n     /// @dev Only the owner can call this function.\n     /// @param generation The generation number.\n    function deleteAttributeProbabilities(uint8 generation) public {\n        require(msg.sender == _ownerAddress);\n\n        uint256 attributesLength = attributes.length;\n        for (uint8 i = 0; i < attributesLength; i++) {\n            attributeProbabilities[generation][attributes[i]] = new uint8[](0);\n        }\n    }\n\n     /// @dev Get the attribute probabilities for a given generation and attribute.\n     /// @param generation The generation number.\n     /// @param attribute The attribute name.\n     /// @return Attribute probabilities.\n    function getAttributeProbabilities(uint256 generation, string memory attribute) \n        public \n        view \n        returns (uint8[] memory) \n    {\n        return attributeProbabilities[generation][attribute];\n    }    \n\n     /// @dev Convert DNA and rarity rank into an attribute probability index.\n     /// @param attribute The attribute name.\n     /// @param rarityRank The rarity rank.\n     /// @return attributeProbabilityIndex attribute probability index.\n    function dnaToIndex(uint256 generation, uint256 rarityRank, string memory attribute) \n        public \n        view \n        returns (uint256 attributeProbabilityIndex) \n    {\n        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);\n        \n        uint256 cumProb = 0;\n        uint256 attrProbabilitiesLength = attrProbabilities.length;\n        for (uint8 i = 0; i < attrProbabilitiesLength; i++) {\n            cumProb += attrProbabilities[i];\n            if (cumProb >= rarityRank) {\n                attributeProbabilityIndex = i + 1;\n                break;\n            }\n        }\n        return attributeProbabilityIndex;\n    }\n}"
    }
  ]
}