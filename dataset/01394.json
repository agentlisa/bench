{
  "Title": "Events missing",
  "Content": "##### Description\nThe function should emit an event for better UX in possible integrations:\n- https://github.com/prisma-fi/prisma-contracts/blob/c0122d27677cd4e1aaee7f1e21f807ccadf46ac8/contracts/dao/Treasury.sol#L173.\n\n##### Recommendation\nWe recommend emitting events.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/dao/Treasury.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../dependencies/PrismaOwnable.sol\";\nimport \"../dependencies/SystemStart.sol\";\nimport \"../interfaces/IPrismaToken.sol\";\nimport \"../interfaces/IEmissionSchedule.sol\";\nimport \"../interfaces/IIncentiveVoting.sol\";\nimport \"../interfaces/ITokenLocker.sol\";\nimport \"../interfaces/IBoostDelegate.sol\";\nimport \"../interfaces/IBoostCalculator.sol\";\n\ninterface IEmissionReceiver {\n    function notifyRegisteredId(uint256[] memory assignedIds) external returns (bool);\n}\n\ninterface IRewards {\n    function treasuryClaimReward(address claimant, address receiver) external returns (uint256);\n\n    function claimableReward(address account) external view returns (uint256);\n}\n\n/**\n    @title Prisma Treasury\n    @notice The total supply of PRISMA is initially minted to this contract.\n            The token balance held here can be considered \"uncirculating\". The\n            treasury gradually releases tokens to registered emissions receivers\n            as determined by `EmissionSchedule` and `BoostCalculator`.\n */\ncontract PrismaTreasury is PrismaOwnable, SystemStart {\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    IPrismaToken public immutable prismaToken;\n    ITokenLocker public immutable locker;\n    IIncentiveVoting public immutable voter;\n    uint256 immutable lockToTokenRatio;\n\n    IEmissionSchedule public emissionSchedule;\n    IBoostCalculator public boostCalculator;\n\n    // `prismaToken` balance within the treasury that is not yet allocated.\n    // Starts as `prismaToken.totalSupply()` and decreases over time.\n    uint128 public unallocatedTotal;\n    // most recent week that `unallocatedTotal` was reduced by a call to\n    // `emissionSchedule.getTotalWeeklyEmissions`\n    uint64 public totalUpdateWeek;\n    // number of weeks that PRISMA is locked for when transferred using\n    // `transferAllocatedTokens`. updated weekly by the emission schedule.\n    uint64 public lockWeeks;\n\n    // id -> receiver data\n    uint16[65535] public receiverUpdatedWeek;\n    // id -> address of receiver\n    // not bi-directional, one receiver can have multiple ids\n    mapping(uint256 => address) public idToReceiver;\n\n    // week -> total amount of tokens to be released in that week\n    uint128[65535] public weeklyEmissions;\n\n    // receiver -> remaining tokens which have been allocated but not yet distributed\n    mapping(address => uint256) public allocated;\n\n    // account -> week -> PRISMA amount claimed in that week (used for calculating boost)\n    mapping(address => uint128[65535]) accountWeeklyEarned;\n\n    // pending rewards for an address (dust after locking, fees from delegation)\n    mapping(address => uint256) public pendingRewardFor;\n\n    mapping(address => Delegation) public boostDelegation;\n\n    struct Delegation {\n        bool isEnabled;\n        uint16 feePct;\n        IBoostDelegate callback;\n    }\n\n    struct InitialAllowance {\n        address receiver;\n        uint256 amount;\n    }\n\n    event NewReceiverRegistered(address receiver, uint256 id);\n    event UnallocatedSupplyReduced(uint256 reducedAmount, uint256 unallocatedTotal);\n    event UnallocatedSupplyIncreased(uint256 increasedAmount, uint256 unallocatedTotal);\n    event IncreasedAllocation(address indexed receiver, uint256 increasedAmount);\n    event EmissionScheduleSet(address emissionScheduler);\n    event BoostDelegationSet(address indexed boostDelegate, bool isEnabled, uint256 feePct, address callback);\n\n    constructor(\n        address _prismaCore,\n        IPrismaToken _token,\n        ITokenLocker _locker,\n        IIncentiveVoting _voter,\n        IEmissionSchedule _emissionSchedule,\n        IBoostCalculator _boostCalculator,\n        address _stabilityPool,\n        uint64 initialLockWeeks,\n        uint128[] memory _fixedInitialAmounts,\n        InitialAllowance[] memory initialAllowances\n    ) PrismaOwnable(_prismaCore) SystemStart(_prismaCore) {\n        prismaToken = _token;\n        locker = _locker;\n        voter = _voter;\n        emissionSchedule = _emissionSchedule;\n        boostCalculator = _boostCalculator;\n\n        _token.approve(address(_locker), type(uint256).max);\n\n        // ensure the stability pool is registered with receiver ID 0\n        _voter.registerNewReceiver();\n        idToReceiver[0] = _stabilityPool;\n        emit NewReceiverRegistered(_stabilityPool, 0);\n\n        for (uint256 i = 0; i < _fixedInitialAmounts.length; i++) {\n            weeklyEmissions[i + 1] = _fixedInitialAmounts[i];\n        }\n        lockWeeks = initialLockWeeks;\n\n        // set initial transfer allowances for airdrops, vests, bribes\n        uint256 total;\n        for (uint256 i = 0; i < initialAllowances.length; i++) {\n            uint256 amount = initialAllowances[i].amount;\n            address receiver = initialAllowances[i].receiver;\n            total += amount;\n            // initial allocations are given as approvals\n            _token.increaseAllowance(receiver, amount);\n        }\n\n        unallocatedTotal = uint128(_token.totalSupply() - total);\n        lockToTokenRatio = _locker.lockToTokenRatio();\n\n        emit UnallocatedSupplyReduced(total, unallocatedTotal);\n    }\n\n    /**\n        @notice Register a new emission receiver\n        @dev Once this function is called, the receiver ID is immediately\n             eligible for votes within `IncentiveVoting`\n        @param receiver Address of the receiver\n        @param count Number of IDs to assign to the receiver\n     */\n    function registerReceiver(address receiver, uint256 count) external onlyOwner returns (bool) {\n        uint256[] memory assignedIds = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            uint256 id = voter.registerNewReceiver();\n            assignedIds[i] = id;\n            receiverUpdatedWeek[id] = uint16(getWeek());\n            idToReceiver[id] = receiver;\n            emit NewReceiverRegistered(receiver, id);\n        }\n        // notify the receiver contract of the newly registered ID\n        // also serves as a sanity check to ensure the contract is capable of receiving emissions\n        IEmissionReceiver(receiver).notifyRegisteredId(assignedIds);\n\n        return true;\n    }\n\n    /**\n        @notice Set the `emissionSchedule` contract\n        @dev Callable only by the owner (the DAO admin voter, to change the emission schedule)\n     */\n    function setEmissionSchedule(IEmissionSchedule _emissionSchedule) external onlyOwner returns (bool) {\n        emissionSchedule = _emissionSchedule;\n        emit EmissionScheduleSet(address(_emissionSchedule));\n\n        return true;\n    }\n\n    function setBoostCalculator(IBoostCalculator _boostCalculator) external onlyOwner returns (bool) {\n        boostCalculator = _boostCalculator;\n\n        return true;\n    }\n\n    /**\n        @notice Transfer tokens out of the treasury\n     */\n    function transferTokens(IERC20 token, address receiver, uint256 amount) external onlyOwner returns (bool) {\n        if (address(token) == address(prismaToken)) {\n            uint256 unallocated = unallocatedTotal - amount;\n            unallocatedTotal = uint128(unallocated);\n            emit UnallocatedSupplyReduced(amount, unallocated);\n        }\n        token.safeTransfer(receiver, amount);\n\n        return true;\n    }\n\n    /**\n        @notice Receive PRISMA tokens and add them to the unallocated supply\n     */\n    function increaseUnallocatedSupply(uint256 amount) external returns (bool) {\n        prismaToken.transferFrom(msg.sender, address(this), amount);\n        uint256 unallocated = unallocatedTotal + amount;\n        unallocatedTotal = uint128(unallocated);\n        emit UnallocatedSupplyIncreased(amount, unallocated);\n\n        return true;\n    }\n\n    /**\n        @notice Allocate additional `prismaToken` allowance to an emission reciever\n                based on the emission schedule\n        @param id Receiver ID. The caller must be the receiver mapped to this ID.\n        @return uint256 Additional `prismaToken` allowance for the receiver. The receiver\n                        accesses the tokens using `Treasury.transferAllocatedTokens`\n     */\n    function allocateNewEmissions(uint256 id) external returns (uint256) {\n        require(idToReceiver[id] == msg.sender, \"Receiver not registered\");\n        uint256 receiverWeek = receiverUpdatedWeek[id];\n        uint256 currentWeek = getWeek();\n        if (receiverWeek == currentWeek) return 0;\n\n        uint256 totalWeek = totalUpdateWeek;\n        uint256 week = receiverWeek < totalWeek ? receiverWeek : totalWeek;\n        uint256 amount;\n        while (week < currentWeek) {\n            ++week;\n            uint256 weeklyAmount = weeklyEmissions[week];\n            if (totalWeek < week) {\n                ++totalWeek;\n                uint256 unallocated = unallocatedTotal;\n                if (weeklyAmount == 0) {\n                    uint256 lock;\n                    (weeklyAmount, lock) = emissionSchedule.getTotalWeeklyEmissions(week, unallocated);\n                    weeklyEmissions[week] = uint128(weeklyAmount);\n                    lockWeeks = uint64(lock);\n                }\n                unallocated = unallocated - weeklyAmount;\n                unallocatedTotal = uint128(unallocated);\n\n                // very unlikely that this function is not called at least weekly,\n                // so we directly update the storage variable on each iteration\n                totalUpdateWeek = uint64(week);\n\n                emit UnallocatedSupplyReduced(weeklyAmount, unallocated);\n            }\n            if (receiverWeek < week) {\n                ++receiverWeek;\n                amount = amount + emissionSchedule.getReceiverWeeklyEmissions(id, receiverWeek, weeklyAmount);\n            }\n        }\n\n        receiverUpdatedWeek[id] = uint16(currentWeek);\n        if (amount > 0) allocated[msg.sender] = allocated[msg.sender] + amount;\n        emit IncreasedAllocation(msg.sender, amount);\n\n        return amount;\n    }\n\n    /**\n        @notice Transfer `prismaToken` tokens previously allocated to the caller\n        @dev Callable only by registered receiver contracts which were previously\n             allocated tokens using `allocateNewEmissions`.\n        @param claimant Address that is claiming the tokens\n        @param receiver Address to transfer tokens to\n        @param amount Desired amount of tokens to transfer. This value always assumes max boost.\n        @return claimed Actual amount of tokens transferred, plus the sum left behind due to\n                        insufficient boost. May be less than `amount` if tokens were locked.\n     */\n    function transferAllocatedTokens(\n        address claimant,\n        address receiver,\n        uint256 amount\n    ) external returns (uint256 claimed) {\n        if (amount > 0) {\n            allocated[msg.sender] -= amount;\n            amount += pendingRewardFor[claimant];\n            pendingRewardFor[claimant] = 0;\n            claimed = _transferAllocated(0, claimant, receiver, address(0), amount);\n            pendingRewardFor[claimant] += amount - claimed;\n        }\n        return claimed;\n    }\n\n    /**\n        @notice Claim earned tokens from multiple reward contracts, optionally with delegated boost\n        @param receiver Address to transfer tokens to. Any earned 3rd-party rewards\n                        are also sent to this address.\n        @param boostDelegate Address to delegate boost from during this claim. Set as\n                             `address(0)` to use the boost of the claimer.\n        @param rewardContracts Array of addresses of registered receiver contracts where\n                               the caller has pending rewards to claim.\n        @param maxFeePct Maximum fee percent to pay to delegate, as a whole number out of 10000\n        @return uint256 Actual amount of tokens transferred, plus the sum left behind due to\n                        insufficient boost. May be less than `amount` if tokens were locked.\n     */\n    function batchClaimRewards(\n        address receiver,\n        address boostDelegate,\n        IRewards[] calldata rewardContracts,\n        uint256 maxFeePct\n    ) external returns (uint256) {\n        require(maxFeePct <= 10000, \"Invalid maxFeePct\");\n        uint256 total = pendingRewardFor[msg.sender];\n        pendingRewardFor[msg.sender] = 0;\n\n        uint256 length = rewardContracts.length;\n        for (uint256 i = 0; i < length; i++) {\n            uint256 amount = rewardContracts[i].treasuryClaimReward(msg.sender, receiver);\n            allocated[address(rewardContracts[i])] -= amount;\n            total += amount;\n        }\n        uint256 claimed = _transferAllocated(maxFeePct, msg.sender, receiver, boostDelegate, total);\n        pendingRewardFor[msg.sender] += total - claimed;\n        return claimed;\n    }\n\n    function _transferAllocated(\n        uint256 maxFeePct,\n        address account,\n        address receiver,\n        address boostDelegate,\n        uint256 amount\n    ) internal returns (uint256) {\n        if (amount > 0) {\n            uint256 week = getWeek();\n            uint256 totalWeekly = weeklyEmissions[week];\n            address claimant = boostDelegate == address(0) ? account : boostDelegate;\n            uint256 previousAmount = accountWeeklyEarned[claimant][week];\n\n            // if boost delegation is active, get the fee and optional callback address\n            uint256 fee;\n            IBoostDelegate delegateCallback;\n            if (boostDelegate != address(0)) {\n                Delegation memory data = boostDelegation[boostDelegate];\n                delegateCallback = data.callback;\n                require(data.isEnabled, \"Invalid delegate\");\n                if (data.feePct == type(uint16).max) {\n                    fee = delegateCallback.getFeePct(account, amount, previousAmount, totalWeekly);\n                    require(fee <= 10000, \"Invalid delegate fee\");\n                } else fee = data.feePct;\n                require(fee <= maxFeePct, \"fee exceeds maxFeePct\");\n            }\n\n            // calculate adjusted amount with actual boost applied\n            uint256 adjustedAmount = boostCalculator.getBoostedAmountWrite(\n                claimant,\n                amount,\n                previousAmount,\n                totalWeekly\n            );\n            uint256 boostUnclaimed = amount - adjustedAmount;\n\n            // apply boost delegation fee\n            if (fee != 0) {\n                fee = (adjustedAmount * fee) / 10000;\n                adjustedAmount -= fee;\n            }\n\n            // transfer or lock tokens\n            uint256 _lockWeeks = lockWeeks;\n            if (_lockWeeks == 0) prismaToken.transfer(receiver, adjustedAmount);\n            else {\n                // if token lock ratio reduces amount to zero, do nothing\n                uint256 lockAmount = adjustedAmount / lockToTokenRatio;\n                if (lockAmount == 0) return 0;\n\n                // lock for receiver, and adjust amounts based on token lock ratio\n                locker.lock(receiver, lockAmount, _lockWeeks);\n                adjustedAmount = lockAmount * lockToTokenRatio;\n                amount = adjustedAmount + boostUnclaimed + fee;\n            }\n\n            // remaining tokens from unboosted claims are added to the unallocated total\n            if (boostUnclaimed > 0) {\n                uint256 unallocated = unallocatedTotal + boostUnclaimed;\n                unallocatedTotal = uint128(unallocated);\n                emit UnallocatedSupplyIncreased(boostUnclaimed, unallocated);\n            }\n            accountWeeklyEarned[claimant][week] = uint128(previousAmount + amount);\n\n            // apply delegate fee and optionally perform callback\n            if (fee != 0) pendingRewardFor[boostDelegate] += fee;\n            if (address(delegateCallback) != address(0)) {\n                require(\n                    delegateCallback.delegatedBoostCallback(\n                        account,\n                        amount,\n                        adjustedAmount,\n                        fee,\n                        previousAmount,\n                        totalWeekly\n                    ),\n                    \"Delegate callback rejected\"\n                );\n            }\n        }\n\n        return amount;\n    }\n\n    /**\n        @notice Claimable PRISMA amount for `account` in `rewardContract` after applying boost\n        @dev Returns (0, 0) if the boost delegate is invalid, or the delgate's callback fee\n             function is incorrectly configured.\n        @param account Address claiming rewards\n        @param boostDelegate Address to delegate boost from when claiming. Set as\n                             `address(0)` to use the boost of the claimer.\n        @param rewardContract Address of the contract where rewards are being claimed\n        @return adjustedAmount Amount received after boost and delegate fees\n        @return feeToDelegate Fee amount paid to `boostDelegate`\n\n     */\n    function claimableRewardAfterBoost(\n        address account,\n        address boostDelegate,\n        IRewards rewardContract\n    ) external view returns (uint256 adjustedAmount, uint256 feeToDelegate) {\n        uint256 amount = rewardContract.claimableReward(account);\n        uint256 week = getWeek();\n        uint256 totalWeekly = weeklyEmissions[week];\n        address claimant = boostDelegate == address(0) ? account : boostDelegate;\n        uint256 previousAmount = accountWeeklyEarned[claimant][week];\n\n        uint256 fee;\n        if (boostDelegate != address(0)) {\n            Delegation memory data = boostDelegation[boostDelegate];\n            if (!data.isEnabled) return (0, 0);\n            fee = data.feePct;\n            if (fee == type(uint16).max) {\n                try data.callback.getFeePct(claimant, amount, previousAmount, totalWeekly) returns (uint256) {} catch {\n                    return (0, 0);\n                }\n            }\n            if (fee >= 10000) return (0, 0);\n        }\n\n        adjustedAmount = boostCalculator.getBoostedAmount(claimant, amount, previousAmount, totalWeekly);\n        fee = (adjustedAmount * fee) / 10000;\n\n        return (adjustedAmount, fee);\n    }\n\n    /**\n        @notice Enable or disable boost delegation, and set boost delegation parameters\n        @param isEnabled is boost delegation enabled?\n        @param feePct Fee % charged when claims are made that delegate to the caller's boost.\n                      Given as a whole number out of 10000. If set to type(uint16).max, the fee\n                      is set by calling `IBoostDelegate(callback).getFeePct` prior to each claim.\n        @param callback Optional contract address to receive a callback each time a claim is\n                        made which delegates to the caller's boost.\n     */\n    function setBoostDelegationParams(bool isEnabled, uint256 feePct, address callback) external returns (bool) {\n        if (isEnabled) {\n            require(feePct <= 10000 || feePct == type(uint16).max, \"Invalid feePct\");\n            if (callback != address(0) || feePct == type(uint16).max) {\n                require(callback.isContract(), \"Callback must be a contract\");\n            }\n            boostDelegation[msg.sender] = Delegation({\n                isEnabled: true,\n                feePct: uint16(feePct),\n                callback: IBoostDelegate(callback)\n            });\n        } else {\n            delete boostDelegation[msg.sender];\n        }\n        emit BoostDelegationSet(msg.sender, isEnabled, feePct, callback);\n\n        return true;\n    }\n\n    /**\n        @notice Get the remaining claimable amounts this week that will receive boost\n        @param claimant address to query boost amounts for\n        @return maxBoosted remaining claimable amount that will receive max boost\n        @return boosted remaining claimable amount that will receive some amount of boost (including max boost)\n     */\n    function getClaimableWithBoost(address claimant) external view returns (uint256 maxBoosted, uint256 boosted) {\n        uint256 week = getWeek();\n        uint256 totalWeekly = weeklyEmissions[week];\n        uint256 previousAmount = accountWeeklyEarned[claimant][week];\n        return boostCalculator.getClaimableWithBoost(claimant, previousAmount, totalWeekly);\n    }\n}"
    }
  ]
}