{
  "Title": "H-2: Missing input validation for _rewardProportion parameter allows keeper to escalate his privileges and pay back all loans",
  "Content": "# Issue H-2: Missing input validation for _rewardProportion parameter allows keeper to escalate his privileges and pay back all loans \n\nSource: https://github.com/sherlock-audit/2023-03-taurus-judging/issues/11 \n\n## Found by \nroguereddwarf, cducrest-brainbot\n\n## Summary\nAccording to the Contest page and discussion with the sponsor, the role of a `keeper` is to perform liquidations and to swap yield token for `TAU` using the `SwapHandler.swapForTau` function:\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/SwapHandler.sol#L45-L52\n\nThey are also able to choose how much yield token to swap and what the proportion of the resulting TAU is that is distributed to users vs. not distributed in order to erase bad debt.\n\nSo a `keeper` is not trusted to perform any actions that go beyond swapping yield / performing liquidations.\n\nHowever there is a missing input validation for the `_rewardProportion` parameter in the `SwapHandler.swapForTau` function.\nThis allows a keeper to \"erase\" all debt of users.\nSo users can withdraw their collateral without paying any of the debt.\n\n## Vulnerability Detail\nBy looking at the code we can see that `_rewardProportion` is used to determine the amount of `TAU` that `_withholdTau` is called with:\n[Link](https://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/SwapHandler.sol#L91)\n```solidity\n_withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION);\n```\n\nAny value of `_rewardProportion` greater than `1e18` means that more `TAU` will be distributed to users than has been burnt (aka erasing debt).\n\nIt is easy to see how the `keeper` can chose the number so big that `_withholdTau` is called with a value close to `type(uint256).max` which will certainly be enough to erase all debt.\n\n## Impact\nA `keeper` can escalate his privileges and erase all debt.\nThis means that `TAU` will not be backed by any collateral anymore and will be worthless.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-03-taurus/blob/main/taurus-contracts/contracts/Vault/SwapHandler.sol#L45-L101\n\n## Tool used\nManual Review\n\n## Recommendation\nI discussed this issue with the sponsor and it is intended that the `keeper` role can freely chose the value of the `_rewardProportion` parameter within the `[0,1e18]` range, i.e. 0%-100%.\n\nTherefore the fix is to simply check that `_rewardProportion` is not bigger than `1e18`:\n```diff\ndiff --git a/taurus-contracts/contracts/Vault/SwapHandler.sol b/taurus-contracts/contracts/Vault/SwapHandler.sol\nindex c04e3a4..ab5064b 100644\n--- a/taurus-contracts/contracts/Vault/SwapHandler.sol\n+++ b/taurus-contracts/contracts/Vault/SwapHandler.sol\n@@ -59,6 +59,10 @@ abstract contract SwapHandler is FeeMapping, TauDripFeed {\n             revert zeroAmount();\n         }\n \n+        if (_rewardProportion > Constants.PERCENT_PRECISION) [\n+            revert invalidRewardProportion();\n+        ]\n+\n         // Get and validate swap adapter address\n         address swapAdapterAddress = SwapAdapterRegistry(controller).swapAdapters(_swapAdapterHash);\n         if (swapAdapterAddress == address(0)) {\n```\n\n## Discussion\n\n**Sierraescape**\n\nhttps://github.com/protokol/taurus-contracts/pull/121\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/45",
  "Code": [
    {
      "filename": "taurus-contracts/contracts/Vault/SwapHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Controller } from \"../Controller/Controller.sol\";\nimport { BaseSwapAdapter } from \"../SwapAdapters/BaseSwapAdapter.sol\";\nimport { FeeMapping } from \"./FeeMapping.sol\";\nimport { PriceOracleManager } from \"../Oracle/PriceOracleManager.sol\";\nimport { SwapAdapterRegistry } from \"../Controller/SwapAdapterRegistry.sol\";\nimport { TauDripFeed } from \"./TauDripFeed.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20Burnable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport { Constants } from \"../Libs/Constants.sol\";\n\nabstract contract SwapHandler is FeeMapping, TauDripFeed {\n    using SafeERC20 for IERC20;\n\n    // Errors\n    error notContract();\n    error oracleCorrupt();\n    error tokenCannotBeSwapped();\n    error tooMuchSlippage(uint256 actualTauReturned, uint256 _minTauReturned);\n    error unregisteredSwapAdapter();\n    error zeroAmount();\n\n    event Swap(address indexed fromToken, uint256 feesToProtocol, uint256 fromAmount, uint256 tauReturned);\n\n    /**\n     * @dev function called as part of the yield pull process. This will fetch swap modules from the Controller, use them \n        to handle a swap from vault yield to tau, then validate that the swap did not encounter too much slippage.\n     * @param _yieldTokenAddress is the address of the token to be swapped. Must be a yield token, so cannot be the vault's collateral token or tau.\n     * @param _yieldTokenAmount is the amount of yield token. Some will be transferred to the FeeSplitter for use by the protocol. The rest will be swapped for tau.\n     * note that slippage parameters must be built based on the amount to be swapped, not based on _yieldTokenAmount above (some of which will not be swapped).\n     * @param _swapAdapterHash is the hash of the swap adapter to be used, i.e. keccak256(\"UniswapSwapAdapter\") for the UniswapSwapAdapter.\n     * @param _rewardProportion refers to the proportion of received tau which will be rewarded (i.e. pay back user loans). The remainder will simply be burned without\n     * being distributed to users. This undistributed tau cancels out bad debt in the vault. All vaults retain a growing reserve of yield to ensure bad debt\n     * will always be covered.\n     * _rewardProportion has a precision of 1e18. If _rewardProportion = 1e18, all tau will be disbursed to users. If _rewardProportion = 0, none of the burned tau will be disbursed.\n     * @param _swapParams is the params to be passed to the SwapAdapter.\n     * note that this function may only be called by a registered keeper.\n     */\n    function swapForTau(\n        address _yieldTokenAddress,\n        uint256 _yieldTokenAmount,\n        uint256 _minTauReturned,\n        bytes32 _swapAdapterHash,\n        uint256 _rewardProportion,\n        bytes calldata _swapParams\n    ) external onlyKeeper whenNotPaused {\n        // Ensure keeper is allowed to swap this token\n        if (_yieldTokenAddress == collateralToken) {\n            revert tokenCannotBeSwapped();\n        }\n\n        if (_yieldTokenAmount == 0) {\n            revert zeroAmount();\n        }\n\n        // Get and validate swap adapter address\n        address swapAdapterAddress = SwapAdapterRegistry(controller).swapAdapters(_swapAdapterHash);\n        if (swapAdapterAddress == address(0)) {\n            // The given hash has not yet been approved as a swap adapter.\n            revert unregisteredSwapAdapter();\n        }\n\n        // Calculate portion of tokens which will be swapped for TAU and disbursed to the vault, and portion which will be sent to the protocol.\n        uint256 protocolFees = (feeMapping[Constants.GLP_VAULT_PROTOCOL_FEE] * _yieldTokenAmount) /\n            Constants.PERCENT_PRECISION;\n        uint256 swapAmount = _yieldTokenAmount - protocolFees;\n\n        // Transfer tokens to swap adapter\n        IERC20(_yieldTokenAddress).safeTransfer(swapAdapterAddress, swapAmount);\n\n        // Call swap function, which will transfer resulting tau back to this contract and return the amount transferred.\n        // Note that this contract does not check that the swap adapter has transferred the correct amount of tau. This check\n        // is handled by the swap adapter, and for this reason any registered swap adapter must be a completely trusted contract.\n        uint256 tauReturned = BaseSwapAdapter(swapAdapterAddress).swap(tau, _swapParams);\n\n        if (tauReturned < _minTauReturned) {\n            revert tooMuchSlippage(tauReturned, _minTauReturned);\n        }\n\n        // Burn received Tau\n        ERC20Burnable(tau).burn(tauReturned);\n\n        // Add Tau rewards to withheldTAU to avert sandwich attacks\n        _disburseTau();\n        _withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION);\n\n        // Send protocol fees to FeeSplitter\n        IERC20(_yieldTokenAddress).safeTransfer(\n            Controller(controller).addressMapper(Constants.FEE_SPLITTER),\n            protocolFees\n        );\n\n        // Emit event\n        emit Swap(_yieldTokenAddress, protocolFees, swapAmount, tauReturned);\n    }\n\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "taurus-contracts/contracts/Vault/SwapHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Controller } from \"../Controller/Controller.sol\";\nimport { BaseSwapAdapter } from \"../SwapAdapters/BaseSwapAdapter.sol\";\nimport { FeeMapping } from \"./FeeMapping.sol\";\nimport { PriceOracleManager } from \"../Oracle/PriceOracleManager.sol\";\nimport { SwapAdapterRegistry } from \"../Controller/SwapAdapterRegistry.sol\";\nimport { TauDripFeed } from \"./TauDripFeed.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20Burnable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport { Constants } from \"../Libs/Constants.sol\";\n\nabstract contract SwapHandler is FeeMapping, TauDripFeed {\n    using SafeERC20 for IERC20;\n\n    // Errors\n    error notContract();\n    error oracleCorrupt();\n    error tokenCannotBeSwapped();\n    error tooMuchSlippage(uint256 actualTauReturned, uint256 _minTauReturned);\n    error unregisteredSwapAdapter();\n    error zeroAmount();\n\n    event Swap(address indexed fromToken, uint256 feesToProtocol, uint256 fromAmount, uint256 tauReturned);\n\n    /**\n     * @dev function called as part of the yield pull process. This will fetch swap modules from the Controller, use them \n        to handle a swap from vault yield to tau, then validate that the swap did not encounter too much slippage.\n     * @param _yieldTokenAddress is the address of the token to be swapped. Must be a yield token, so cannot be the vault's collateral token or tau.\n     * @param _yieldTokenAmount is the amount of yield token. Some will be transferred to the FeeSplitter for use by the protocol. The rest will be swapped for tau.\n     * note that slippage parameters must be built based on the amount to be swapped, not based on _yieldTokenAmount above (some of which will not be swapped).\n     * @param _swapAdapterHash is the hash of the swap adapter to be used, i.e. keccak256(\"UniswapSwapAdapter\") for the UniswapSwapAdapter.\n     * @param _rewardProportion refers to the proportion of received tau which will be rewarded (i.e. pay back user loans). The remainder will simply be burned without\n     * being distributed to users. This undistributed tau cancels out bad debt in the vault. All vaults retain a growing reserve of yield to ensure bad debt\n     * will always be covered.\n     * _rewardProportion has a precision of 1e18. If _rewardProportion = 1e18, all tau will be disbursed to users. If _rewardProportion = 0, none of the burned tau will be disbursed.\n     * @param _swapParams is the params to be passed to the SwapAdapter.\n     * note that this function may only be called by a registered keeper.\n     */\n    function swapForTau(\n        address _yieldTokenAddress,\n        uint256 _yieldTokenAmount,\n        uint256 _minTauReturned,\n        bytes32 _swapAdapterHash,\n        uint256 _rewardProportion,\n        bytes calldata _swapParams\n    ) external onlyKeeper whenNotPaused {\n        // Ensure keeper is allowed to swap this token\n        if (_yieldTokenAddress == collateralToken) {\n            revert tokenCannotBeSwapped();\n        }\n\n        if (_yieldTokenAmount == 0) {\n            revert zeroAmount();\n        }\n\n        // Get and validate swap adapter address\n        address swapAdapterAddress = SwapAdapterRegistry(controller).swapAdapters(_swapAdapterHash);\n        if (swapAdapterAddress == address(0)) {\n            // The given hash has not yet been approved as a swap adapter.\n            revert unregisteredSwapAdapter();\n        }\n\n        // Calculate portion of tokens which will be swapped for TAU and disbursed to the vault, and portion which will be sent to the protocol.\n        uint256 protocolFees = (feeMapping[Constants.GLP_VAULT_PROTOCOL_FEE] * _yieldTokenAmount) /\n            Constants.PERCENT_PRECISION;\n        uint256 swapAmount = _yieldTokenAmount - protocolFees;\n\n        // Transfer tokens to swap adapter\n        IERC20(_yieldTokenAddress).safeTransfer(swapAdapterAddress, swapAmount);\n\n        // Call swap function, which will transfer resulting tau back to this contract and return the amount transferred.\n        // Note that this contract does not check that the swap adapter has transferred the correct amount of tau. This check\n        // is handled by the swap adapter, and for this reason any registered swap adapter must be a completely trusted contract.\n        uint256 tauReturned = BaseSwapAdapter(swapAdapterAddress).swap(tau, _swapParams);\n\n        if (tauReturned < _minTauReturned) {\n            revert tooMuchSlippage(tauReturned, _minTauReturned);\n        }\n\n        // Burn received Tau\n        ERC20Burnable(tau).burn(tauReturned);\n\n        // Add Tau rewards to withheldTAU to avert sandwich attacks\n        _disburseTau();\n        _withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION);\n\n        // Send protocol fees to FeeSplitter\n        IERC20(_yieldTokenAddress).safeTransfer(\n            Controller(controller).addressMapper(Constants.FEE_SPLITTER),\n            protocolFees\n        );\n\n        // Emit event\n        emit Swap(_yieldTokenAddress, protocolFees, swapAmount, tauReturned);\n    }\n\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "taurus-contracts/contracts/Vault/SwapHandler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Controller } from \"../Controller/Controller.sol\";\nimport { BaseSwapAdapter } from \"../SwapAdapters/BaseSwapAdapter.sol\";\nimport { FeeMapping } from \"./FeeMapping.sol\";\nimport { PriceOracleManager } from \"../Oracle/PriceOracleManager.sol\";\nimport { SwapAdapterRegistry } from \"../Controller/SwapAdapterRegistry.sol\";\nimport { TauDripFeed } from \"./TauDripFeed.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20Burnable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Libraries\nimport { Constants } from \"../Libs/Constants.sol\";\n\nabstract contract SwapHandler is FeeMapping, TauDripFeed {\n    using SafeERC20 for IERC20;\n\n    // Errors\n    error notContract();\n    error oracleCorrupt();\n    error tokenCannotBeSwapped();\n    error tooMuchSlippage(uint256 actualTauReturned, uint256 _minTauReturned);\n    error unregisteredSwapAdapter();\n    error zeroAmount();\n\n    event Swap(address indexed fromToken, uint256 feesToProtocol, uint256 fromAmount, uint256 tauReturned);\n\n    /**\n     * @dev function called as part of the yield pull process. This will fetch swap modules from the Controller, use them \n        to handle a swap from vault yield to tau, then validate that the swap did not encounter too much slippage.\n     * @param _yieldTokenAddress is the address of the token to be swapped. Must be a yield token, so cannot be the vault's collateral token or tau.\n     * @param _yieldTokenAmount is the amount of yield token. Some will be transferred to the FeeSplitter for use by the protocol. The rest will be swapped for tau.\n     * note that slippage parameters must be built based on the amount to be swapped, not based on _yieldTokenAmount above (some of which will not be swapped).\n     * @param _swapAdapterHash is the hash of the swap adapter to be used, i.e. keccak256(\"UniswapSwapAdapter\") for the UniswapSwapAdapter.\n     * @param _rewardProportion refers to the proportion of received tau which will be rewarded (i.e. pay back user loans). The remainder will simply be burned without\n     * being distributed to users. This undistributed tau cancels out bad debt in the vault. All vaults retain a growing reserve of yield to ensure bad debt\n     * will always be covered.\n     * _rewardProportion has a precision of 1e18. If _rewardProportion = 1e18, all tau will be disbursed to users. If _rewardProportion = 0, none of the burned tau will be disbursed.\n     * @param _swapParams is the params to be passed to the SwapAdapter.\n     * note that this function may only be called by a registered keeper.\n     */\n    function swapForTau(\n        address _yieldTokenAddress,\n        uint256 _yieldTokenAmount,\n        uint256 _minTauReturned,\n        bytes32 _swapAdapterHash,\n        uint256 _rewardProportion,\n        bytes calldata _swapParams\n    ) external onlyKeeper whenNotPaused {\n        // Ensure keeper is allowed to swap this token\n        if (_yieldTokenAddress == collateralToken) {\n            revert tokenCannotBeSwapped();\n        }\n\n        if (_yieldTokenAmount == 0) {\n            revert zeroAmount();\n        }\n\n        // Get and validate swap adapter address\n        address swapAdapterAddress = SwapAdapterRegistry(controller).swapAdapters(_swapAdapterHash);\n        if (swapAdapterAddress == address(0)) {\n            // The given hash has not yet been approved as a swap adapter.\n            revert unregisteredSwapAdapter();\n        }\n\n        // Calculate portion of tokens which will be swapped for TAU and disbursed to the vault, and portion which will be sent to the protocol.\n        uint256 protocolFees = (feeMapping[Constants.GLP_VAULT_PROTOCOL_FEE] * _yieldTokenAmount) /\n            Constants.PERCENT_PRECISION;\n        uint256 swapAmount = _yieldTokenAmount - protocolFees;\n\n        // Transfer tokens to swap adapter\n        IERC20(_yieldTokenAddress).safeTransfer(swapAdapterAddress, swapAmount);\n\n        // Call swap function, which will transfer resulting tau back to this contract and return the amount transferred.\n        // Note that this contract does not check that the swap adapter has transferred the correct amount of tau. This check\n        // is handled by the swap adapter, and for this reason any registered swap adapter must be a completely trusted contract.\n        uint256 tauReturned = BaseSwapAdapter(swapAdapterAddress).swap(tau, _swapParams);\n\n        if (tauReturned < _minTauReturned) {\n            revert tooMuchSlippage(tauReturned, _minTauReturned);\n        }\n\n        // Burn received Tau\n        ERC20Burnable(tau).burn(tauReturned);\n\n        // Add Tau rewards to withheldTAU to avert sandwich attacks\n        _disburseTau();\n        _withholdTau((tauReturned * _rewardProportion) / Constants.PERCENT_PRECISION);\n\n        // Send protocol fees to FeeSplitter\n        IERC20(_yieldTokenAddress).safeTransfer(\n            Controller(controller).addressMapper(Constants.FEE_SPLITTER),\n            protocolFees\n        );\n\n        // Emit event\n        emit Swap(_yieldTokenAddress, protocolFees, swapAmount, tauReturned);\n    }\n\n    uint256[50] private __gap;\n}"
    }
  ]
}