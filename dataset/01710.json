{
  "Title": "M-6: KickerActions uses wrong check to prevent Kickers from using deposits below LUP for KIckWithDeposit",
  "Content": "# Issue M-6: KickerActions uses wrong check to prevent Kickers from using deposits below LUP for KIckWithDeposit \n\nSource: https://github.com/sherlock-audit/2023-04-ajna-judging/issues/113 \n\n## Found by \nChinmay\n## Summary\nThe ```kickWithDeposit``` function in ```KickerActions``` has a check to prevent users having deposits below the LUP to use those deposits for kicking loans, but this check is implemented incorrectly.\n\n## Vulnerability Detail\nThe mentioned check evaluates if the ```bucketPrice``` used by the kicker is below the LUP. But the problem here is that the LUP used in this check is the new LUP that is calculated after incorporating the removal of the deposit itself and the debt changes. Thus, this check can be easily bypassed because the new LUP is bound to move lower and thus may cross past the ```bucketPrice``` used.\n\nConsider a situation :\n1. The kicker has deposits in a bucketPrice below LUP\n2. Now he calls kickWithDeposit using this deposit\n3. The new LUP is calculated after removing this deposit and adding the debt changes for kickPenalty etc. \n4. This will make the LUP decrease and thus now LUP < bucketPrice that the user input\n\nThis way this check can be bypassed. According to the developers, the check was in place to prevent kickers from using deposits below the LUP to kick loans but this is not fulfilled.\n\n\n## Impact\nThis breaks protocol functionality because now anyone can deposit below LUP and use that to kick valid user loans. The ```kickWithDeposit``` function was only made to help depositors get their deposits back if some loans are blocking the withdrawl due to the LUP movement. But the current implementation allows anyone to kick those loans that were originally not eligible for liquidation. \n\nThis is a high severity issue because it griefs users off their funds by liquidating them, even when they were not eligible for liquidation.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L216\n## Tool used\n\nManual Review\n\n## Recommendation\nRefactor the code and move this check to the top of the kickWithDeposit function logic. \n\n\n\n## Discussion\n\n**hrishibhat**\n\nLead Watson comment: \n> Invalid as removal deposit from the bucket below the LUP can’t make LUP move, i.e. it can’t be vars.bucketPrice < kickResult_.lup before removal from bucket, but vars.bucketPrice >= kickResult_.lup after that.\n\n**chinmay-farkya**\n\nEscalate for 10 USDC\nThe lead watson's comment \"removal deposit from the bucket below the LUP can’t make LUP move\" is incorrect.\n\nFollowing up with the explanation above, see that at [KickerActions#216](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L216) the LUP that is used for the check has been calculated at [KickerActions#207](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L207). Here, the DepositState \"deposits_\" is the actual old state of deposits which means that kicker's deposit is still stored at whatever index it was. This deposit is actually only removed from \"deposits_\" at [KickerActions#223](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L223) and [KickerActions#241](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L241) which means the deposits used for kick is only removed from the \"deposits_\" after the check at Line 216.\n\nNow look at the values in Line 207 : the LUP calculation using \"deposits_\" state where the user's deposit he is going to use to kick exists, but see the second function argument : ``kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit)``\n\nThe LUP is being calculated as if the debt has increased by an amount, ``amountToDebitFromDeposit`` which is mirroring the removal of the deposit. But think about when the deposit index used (vars.bucketPrice) was originally below the LUP. In this case, the use of increased debt in the calculation doesn't mirror the removal of deposits.\n\nfor example : \n1. LUP = 100 and kicker uses bucket price 90 where he has 100K deposits.\n2. Now this shouldn't move the LUP but it does move the LUP in calculation at Line 207 because it uses the same old Deposit but increased Debt(by whole of the deposits used for kick) in the calculation. Since LUP is calculated by summing up the deposits from top and matching it against the debt value passed to the getLup function, this will lower the LUP. This incorrect LUP will bypass the check and allow anyone to kick loans and grief users as explained in the original submission.  This can be seen in [Deposits.getLup](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/internal/Deposits.sol#L417) function.\n\nBecause the logic can move the LUP below despite of a deposit from below the LUP being removed, this is a valid High severity finding as explained in impact above.\n\n\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> The lead watson's comment \"removal deposit from the bucket below the LUP can’t make LUP move\" is incorrect.\n> \n> Following up with the explanation above, see that at [KickerActions#216](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L216) the LUP that is used for the check has been calculated at [KickerActions#207](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L207). Here, the DepositState \"deposits_\" is the actual old state of deposits which means that kicker's deposit is still stored at whatever index it was. This deposit is actually only removed from \"deposits_\" at [KickerActions#223](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L223) and [KickerActions#241](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L241) which means the deposits used for kick is only removed from the \"deposits_\" after the check at Line 216.\n> \n> Now look at the values in Line 207 : the LUP calculation using \"deposits_\" state where the user's deposit he is going to use to kick exists, but see the second function argument : ``kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit)``\n> \n> The LUP is being calculated as if the debt has increased by an amount, ``amountToDebitFromDeposit`` which is mirroring the removal of the deposit. But think about when the deposit index used (vars.bucketPrice) was originally below the LUP. In this case, the use of increased debt in the calculation doesn't mirror the removal of deposits.\n> \n> for example : \n> 1. LUP = 100 and kicker uses bucket price 90 where he has 100K deposits.\n> 2. Now this shouldn't move the LUP but it does move the LUP in calculation at Line 207 because it uses the same old Deposit but increased Debt(by whole of the deposits used for kick) in the calculation. Since LUP is calculated by summing up the deposits from top and matching it against the debt value passed to the getLup function, this will lower the LUP. This incorrect LUP will bypass the check and allow anyone to kick loans and grief users as explained in the original submission.  This can be seen in [Deposits.getLup](https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/internal/Deposits.sol#L417) function.\n> \n> Because the logic can move the LUP below despite of a deposit from below the LUP being removed, this is a valid High severity finding as explained in impact above.\n> \n> \n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**dmitriia**\n\nEscalate for 10 USDC\nDespite some misunderstandings, the take that `kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit)` is incorrect when `bucketPrice` is initially below LUP is a right one, i.e. the control do not filter out some `bucketPrice < initial_LUP` situations as LUP for the check isn't calculated correctly in this case.\nHowever, the filtering of `bucketPrice < LUP` is a more a convenience approach. There is no impact here that justify high severity, so valid medium looks the most suitable in this case.\n\nTo clarify:\n\n1. \"removal deposit from the bucket below the LUP can’t make LUP move\" is correct all the time, this follows from the definition of LUP, which is the last utilized price, while `bucketPrice < LUP` deposits aren't utilized.\n2. The `kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit)` check isn't correct exactly because of (1)\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> Despite some misunderstandings, the take that `kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit)` is incorrect when `bucketPrice` is initially below LUP is a right one, i.e. the control do not filter out some `bucketPrice < initial_LUP` situations as LUP for the check isn't calculated correctly in this case.\n> However, the filtering of `bucketPrice < LUP` is a more a convenience approach. There is no impact here that justify high severity, so valid medium looks the most suitable in this case.\n> \n> To clarify:\n> \n> 1. \"removal deposit from the bucket below the LUP can’t make LUP move\" is correct all the time, this follows from the definition of LUP, which is the last utilized price, while `bucketPrice < LUP` deposits aren't utilized.\n> 2. The `kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit)` check isn't correct exactly because of (1)\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**chinmay-farkya**\n\nI'd like to elaborate the impact to justify High severity :\n1. Firstly, this allows an attacker to intentionally deposit below the LUP and force illegal liquidations on users. Since the loan with max TP is kicked first in order, this may cause a material loss of funds for that borrower depending upon his borrowed amounts.\n2. The attacker can do this repeatedly to grief multiple users one by one. This may cause a material loss of funds for multiple users.\n3. The attacker controls the deposited amount ie. ``amountToDebitFromDeposit`` above based on how much LP he holds in that bucket. This way he can move the LUP (for the intermediate calculation) lower to any price he desires. This is because larger the  ``amountToDebitFromDeposit`` more the LUP will move. This means he can forcefully liquidate users even if they were far from underwater.\n\n\n**0xffff11**\n\nThere are several points were the watson was mistaken. I really appreciate the comment from the senior exposing them. I do agree with a medium in the current landscape, but I would like a third opinion from @grandizzy \n\n**grandizzy**\n\nAgree with @dmitriia explanation and medium severity.\n\n**chinmay-farkya**\n\nHey @grandizzy with regards to the Senior Watson's comments, I think I have justified the severity enough in my comment [here](https://github.com/sherlock-audit/2023-04-ajna-judging/issues/113#issuecomment-1617420829)\n\nDo have a look. Won't take this further.\n\nAlso, Hey @0xffff11 would like to ask for more clarification on why the points I made in the last comment above aren't fulfilling to high severity.\n\n**grandizzy**\n\nfixed with https://github.com/ajna-finance/contracts/pull/894\n\n**dmitriia**\n\n> https://github.com/sherlock-audit/2023-04-ajna/blob/e2439305cc093204a0d927aac19d898f4a0edb3d/ajna-core/src/libraries/external/KickerActions.sol#L216\n\nLooks ok, as a result of refactoring (for this and other issues of this contest combined) `kickWithDeposit()` is now `lenderKick()` that performs `if (vars.bucketPrice < Deposits.getLup(deposits_, poolState_.debt)) revert PriceBelowLUP()` check on the initial pool state. \n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nIn addition to the comments above after further review and discussion of this issue, Considering this issue a valid medium based on to the following comments from the Lead Watson:\n> Depositing below LUP is definitely possible in general and is not enabled by this bug, what happens here is that LUP for kicking determined as Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit) is incorrect for deposits below LUP (and for them only, it is correct whenever bucket price >= LUP). This is actually an intermediary bug, I discussed it with the team early in the contest, but didn’t reported as it led to several others so the team decided to rewrite the function altogether (it’s now much lighter lenderKick()), and this requirement was initially introduced as a function separation matter, i.e. there is nothing wrong in using kicking with a bucket deposit when vars.bucketPrice < kickResult_.lup, it is just designed to handle an another case of a depositor pretending to remove the deposit and kicking as if they done that. I.e. that’s basically a helper function that can be replicated via others (withdraw, then kick).\n\n> Why it is medium: first of all kicking cannot be sniped and is always done in queue, one can kick only Loans.getMax(loans_).borrower, there is no optionality here, so if there are lots of bad borrowers the attacker will have to kick them first anyway, they can’t just reach a good one, that’s not possible, and, most importantly, kicking borrowers that aren’t supposed to be kicked is substantially unprofitable, as kicker have to post a bond, which is partially forfeited if resulting auction price (i.e. market price as market actors will participate there as long as it’s profitable) is higher than this borrower’s price. The loss of the kicker is proportional to this gap, i.e. there is a guaranteed (as long as there are other market participants) loss for the kicker is they kick healthy borrowers, and the healthier is the borrower, the bigger the loss.\n\n> So yes, an attacker can kick with this function, but it will be really costly griefing and nothing else. I.e. they will be required to post substantial bond and will lose a part of it, while borrower will not lose as they will be liquidated at market price, i.e. their position will be just closed at the current levels. I.e. nobody besides attacker will have any substantial losses, attacker will be penalized for kicking at out of the market levels, their penalty will be redistributed.\n\n> This way this can be categozed as costly griefing, so the probability of such attack is low, while damage cannot be made significant (i.e. there can be some medium damage for borrower if market is specifically illiquid, but active market is basically a precondition for oracle-less protocols, and this situation cannot be controlled by the attacker).\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [chinmay-farkya](https://github.com/sherlock-audit/2023-04-ajna-judging/issues/113/#issuecomment-1616731466): accepted\n- [dmitriia](https://github.com/sherlock-audit/2023-04-ajna-judging/issues/113/#issuecomment-1616937905): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/75",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/external/KickerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Math }     from '@openzeppelin/contracts/utils/math/Math.sol';\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Lender,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                             from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    KickReserveAuctionParams\n}                             from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    MAX_NEUTRAL_PRICE,\n    _auctionPrice,\n    _bondParams,\n    _bpf,\n    _claimableReserves,\n    _isCollateralized,\n    _priceAt,\n    _reserveAuctionPrice\n}                                   from '../helpers/PoolHelper.sol';\nimport {\n    _revertIfPriceDroppedBelowLimit\n}                                   from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auctions kicker actions library\n    @notice External library containing kicker actions involving auctions within pool:\n            - kick undercollateralized loans; start reserve auctions\n */\nlibrary KickerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `kick` function local vars.\n    struct KickLocalVars {\n        uint256 borrowerDebt;       // [WAD] the accrued debt of kicked borrower\n        uint256 borrowerCollateral; // [WAD] amount of kicked borrower collateral\n        uint256 neutralPrice;       // [WAD] neutral price recorded in kick action\n        uint256 noOfLoans;          // number of loans and auctions in pool (used to calculate MOMP)\n        uint256 momp;               // [WAD] MOMP of kicked auction\n        uint256 bondFactor;         // [WAD] bond factor of kicked auction\n        uint256 bondSize;           // [WAD] bond size of kicked auction\n        uint256 t0KickPenalty;      // [WAD] t0 debt added as kick penalty\n        uint256 kickPenalty;        // [WAD] current debt added as kick penalty\n    }\n\n    /// @dev Struct used for `kickWithDeposit` function local vars.\n    struct KickWithDepositLocalVars {\n        uint256 amountToDebitFromDeposit; // [WAD] the amount of quote tokens used to kick and debited from lender deposit\n        uint256 bucketCollateral;         // [WAD] amount of collateral in bucket\n        uint256 bucketDeposit;            // [WAD] amount of quote tokens in bucket\n        uint256 bucketLP;                 // [WAD] LP of the bucket\n        uint256 bucketPrice;              // [WAD] bucket price\n        uint256 bucketScale;              // [WAD] bucket scales\n        uint256 bucketUnscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n        uint256 lenderLP;                 // [WAD] LP of lender in bucket\n        uint256 redeemedLP;               // [WAD] LP used by kick action\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event Kick(address indexed borrower, uint256 debt, uint256 collateral, uint256 bond);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);\n    event KickReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice, uint256 currentBurnEpoch);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionActive();\n    error BorrowerOk();\n    error InsufficientLiquidity();\n    error InsufficientLP();\n    error InvalidAmount();\n    error NoReserves();\n    error PriceBelowLUP();\n    error ReserveAuctionTooSoon();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @return The `KickResult` struct result of the kick action.\n     */\n    function kick(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 limitIndex_\n    ) external returns (\n        KickResult memory\n    ) {\n        return _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrowerAddress_,\n            limitIndex_,\n            0\n        );\n    }\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @dev    === Write state ===\n     *  @dev   - `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index): update `values` array state\n     *  @dev   - decrement `lender.lps` accumulator\n     *  @dev   - decrement `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    insufficient deposit to kick auction `InsufficientLiquidity()`\n     *  @dev    no `LP` redeemed to kick auction `InsufficientLP()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RemoveQuoteToken`\n     *  @return kickResult_ The `KickResult` struct result of the kick action.\n     */\n    function kickWithDeposit(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        mapping(uint256 => Bucket) storage buckets_,\n        LoansState storage loans_,\n        PoolState calldata poolState_,\n        uint256 index_,\n        uint256 limitIndex_\n    ) external returns (\n        KickResult memory kickResult_\n    ) {\n        Bucket storage bucket = buckets_[index_];\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        KickWithDepositLocalVars memory vars;\n\n        if (bucket.bankruptcyTime < lender.depositTime) vars.lenderLP = lender.lps;\n\n        vars.bucketLP              = bucket.lps;\n        vars.bucketCollateral      = bucket.collateral;\n        vars.bucketPrice           = _priceAt(index_);\n        vars.bucketUnscaledDeposit = Deposits.unscaledValueAt(deposits_, index_);\n        vars.bucketScale           = Deposits.scale(deposits_, index_);\n        vars.bucketDeposit         = Maths.wmul(vars.bucketUnscaledDeposit, vars.bucketScale);\n\n        // calculate amount to remove based on lender LP in bucket\n        vars.amountToDebitFromDeposit = Buckets.lpToQuoteTokens(\n            vars.bucketCollateral,\n            vars.bucketLP,\n            vars.bucketDeposit,\n            vars.lenderLP,\n            vars.bucketPrice,\n            Math.Rounding.Down\n        );\n\n        // cap the amount to remove at bucket deposit\n        if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit;\n\n        // revert if no amount that can be removed\n        if (vars.amountToDebitFromDeposit == 0) revert InsufficientLiquidity();\n\n        // kick top borrower\n        kickResult_ = _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            Loans.getMax(loans_).borrower,\n            limitIndex_,\n            vars.amountToDebitFromDeposit\n        );\n\n        // amount to remove from deposit covers entire bond amount\n        if (vars.amountToDebitFromDeposit > kickResult_.amountToCoverBond) {\n            // cap amount to remove from deposit at amount to cover bond\n            vars.amountToDebitFromDeposit = kickResult_.amountToCoverBond;\n\n            // recalculate the LUP with the amount to cover bond\n            kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit);\n            // entire bond is covered from deposit, no additional amount to be send by lender\n            kickResult_.amountToCoverBond = 0;\n        } else {\n            // lender should send additional amount to cover bond\n            kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;\n        }\n\n        // revert if the bucket price used to kick and remove is below new LUP\n        if (vars.bucketPrice < kickResult_.lup) revert PriceBelowLUP();\n\n        // remove amount from deposits\n        if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {\n            // In this case we are redeeming the entire bucket exactly, and need to ensure bucket LP are set to 0\n            vars.redeemedLP = vars.bucketLP;\n\n            Deposits.unscaledRemove(deposits_, index_, vars.bucketUnscaledDeposit);\n            vars.bucketUnscaledDeposit = 0;\n\n        } else {\n            vars.redeemedLP = Buckets.quoteTokensToLP(\n                vars.bucketCollateral,\n                vars.bucketLP,\n                vars.bucketDeposit,\n                vars.amountToDebitFromDeposit,\n                vars.bucketPrice,\n                Math.Rounding.Up\n            );\n\n            uint256 unscaledAmountToRemove = Maths.floorWdiv(vars.amountToDebitFromDeposit, vars.bucketScale);\n\n            // revert if calculated unscaled amount is 0\n            if (unscaledAmountToRemove == 0) revert InsufficientLiquidity();\n\n            Deposits.unscaledRemove(deposits_, index_, unscaledAmountToRemove);\n            vars.bucketUnscaledDeposit -= unscaledAmountToRemove;\n        }\n\n        vars.redeemedLP = Maths.min(vars.lenderLP, vars.redeemedLP);\n\n        // revert if LP redeemed amount to kick auction is 0\n        if (vars.redeemedLP == 0) revert InsufficientLP();\n\n        uint256 bucketRemainingLP = vars.bucketLP - vars.redeemedLP;\n\n        if (vars.bucketCollateral == 0 && vars.bucketUnscaledDeposit == 0 && bucketRemainingLP != 0) {\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                index_,\n                bucketRemainingLP\n            );\n        } else {\n            // update lender and bucket LP balances\n            lender.lps -= vars.redeemedLP;\n            bucket.lps -= vars.redeemedLP;\n        }\n\n        emit RemoveQuoteToken(\n            msg.sender,\n            index_,\n            vars.amountToDebitFromDeposit,\n            vars.redeemedLP,\n            kickResult_.lup\n        );\n    }\n\n    /*************************/\n    /***  Reserve Auction  ***/\n    /*************************/\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @dev    === Write state ===\n     *  @dev    update `reserveAuction.unclaimed` accumulator\n     *  @dev    update `reserveAuction.kicked` timestamp state\n     *  @dev    === Reverts on ===\n     *  @dev    no reserves to claim `NoReserves()`\n     *  @dev    === Emit events ===\n     *  @dev    - `KickReserveAuction`\n     *  @return kickerAward_ The `LP`s awarded to reserve auction kicker.\n     */\n    function kickReserveAuction(\n        AuctionsState storage auctions_,\n        ReserveAuctionState storage reserveAuction_,\n        KickReserveAuctionParams calldata params_\n    ) external returns (uint256 kickerAward_) {\n        // retrieve timestamp of latest burn event and last burn timestamp\n        uint256 latestBurnEpoch   = reserveAuction_.latestBurnEventEpoch;\n        uint256 lastBurnTimestamp = reserveAuction_.burnEvents[latestBurnEpoch].timestamp;\n\n        // check that at least two weeks have passed since the last reserve auction completed, and that the auction was not kicked within the past 72 hours\n        if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {\n            revert ReserveAuctionTooSoon();\n        }\n\n        uint256 curUnclaimedAuctionReserve = reserveAuction_.unclaimed;\n\n        uint256 claimable = _claimableReserves(\n            Maths.wmul(params_.t0PoolDebt, params_.inflator),\n            params_.poolSize,\n            auctions_.totalBondEscrowed,\n            curUnclaimedAuctionReserve,\n            params_.poolBalance\n        );\n\n        kickerAward_ = Maths.wmul(0.01 * 1e18, claimable);\n\n        curUnclaimedAuctionReserve += claimable - kickerAward_;\n\n        if (curUnclaimedAuctionReserve == 0) revert NoReserves();\n\n        reserveAuction_.unclaimed = curUnclaimedAuctionReserve;\n        reserveAuction_.kicked    = block.timestamp;\n\n        // increment latest burn event epoch and update burn event timestamp\n        latestBurnEpoch += 1;\n\n        reserveAuction_.latestBurnEventEpoch = latestBurnEpoch;\n        reserveAuction_.burnEvents[latestBurnEpoch].timestamp = block.timestamp;\n\n        emit KickReserveAuction(\n            curUnclaimedAuctionReserve,\n            _reserveAuctionPrice(block.timestamp),\n            latestBurnEpoch\n        );\n    }\n\n    /***************************/\n    /***  Internal Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Called to start borrower liquidation and to update the auctions queue.\n     *  @dev    === Write state ===\n     *  @dev    - `_recordAuction`:\n     *  @dev      `borrower -> liquidation` mapping update\n     *  @dev      increment `auctions count` accumulator\n     *  @dev      increment `auctions.totalBondEscrowed` accumulator\n     *  @dev      updates auction queue state\n     *  @dev    - `_updateEscrowedBonds`:\n     *  @dev      update `locked` and `claimable` kicker accumulators\n     *  @dev    - `Loans.remove`:\n     *  @dev      delete borrower from `indices => borrower` address mapping\n     *  @dev      remove loan from loans array\n     *  @dev    === Emit events ===\n     *  @dev    - `Kick`\n     *  @param  auctions_        Struct for pool auctions state.\n     *  @param  deposits_        Struct for pool deposits state.\n     *  @param  loans_           Struct for pool loans state.\n     *  @param  poolState_       Current state of the pool.\n     *  @param  borrowerAddress_ Address of the borrower to kick.\n     *  @param  limitIndex_      Index of the lower bound of `NP` tolerated when kicking the auction.\n     *  @param  additionalDebt_  Additional debt to be used when calculating proposed `LUP`.\n     *  @return kickResult_      The `KickResult` struct result of the kick action.\n     */\n    function _kick(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 limitIndex_,\n        uint256 additionalDebt_\n    ) internal returns (\n        KickResult memory kickResult_\n    ) {\n        Liquidation storage liquidation = auctions_.liquidations[borrowerAddress_];\n        // revert if liquidation is active\n        if (liquidation.kickTime != 0) revert AuctionActive();\n\n        Borrower storage borrower = loans_.borrowers[borrowerAddress_];\n\n        kickResult_.debtPreAction       = borrower.t0Debt;\n        kickResult_.collateralPreAction = borrower.collateral;\n        kickResult_.t0KickedDebt        = kickResult_.debtPreAction ;\n        // add amount to remove to pool debt in order to calculate proposed LUP\n        kickResult_.lup          = Deposits.getLup(deposits_, poolState_.debt + additionalDebt_);\n\n        KickLocalVars memory vars;\n        vars.borrowerDebt       = Maths.wmul(kickResult_.t0KickedDebt, poolState_.inflator);\n        vars.borrowerCollateral = kickResult_.collateralPreAction;\n\n        // revert if kick on a collateralized borrower\n        if (_isCollateralized(vars.borrowerDebt, vars.borrowerCollateral, kickResult_.lup, poolState_.poolType)) {\n            revert BorrowerOk();\n        }\n\n        // calculate auction params\n        // neutral price is capped at 50 * max pool price\n        vars.neutralPrice = Maths.min(\n            Maths.wmul(borrower.t0Np, poolState_.inflator),\n            MAX_NEUTRAL_PRICE\n        );\n        // check if NP is not less than price at the limit index provided by the kicker - done to prevent frontrunning kick auction call with a large amount of loan\n        // which will make it harder for kicker to earn a reward and more likely that the kicker is penalized\n        _revertIfPriceDroppedBelowLimit(vars.neutralPrice, limitIndex_);\n\n        vars.noOfLoans = Loans.noOfLoans(loans_) + auctions_.noOfAuctions;\n\n        vars.momp = _priceAt(\n            Deposits.findIndexOfSum(\n                deposits_,\n                Maths.wdiv(poolState_.debt, vars.noOfLoans * 1e18)\n            )\n        );\n\n        (vars.bondFactor, vars.bondSize) = _bondParams(\n            vars.borrowerDebt,\n            vars.borrowerCollateral,\n            vars.momp\n        );\n\n        // record liquidation info\n        _recordAuction(\n            auctions_,\n            liquidation,\n            borrowerAddress_,\n            vars.bondSize,\n            vars.bondFactor,\n            vars.momp,\n            vars.neutralPrice\n        );\n\n        // update escrowed bonds balances and get the difference needed to cover bond (after using any kick claimable funds if any)\n        kickResult_.amountToCoverBond = _updateEscrowedBonds(auctions_, vars.bondSize);\n\n        // remove kicked loan from heap\n        Loans.remove(loans_, borrowerAddress_, loans_.indices[borrowerAddress_]);\n\n        // when loan is kicked, penalty of three months of interest is added\n        vars.t0KickPenalty = Maths.wdiv(Maths.wmul(kickResult_.t0KickedDebt, poolState_.rate), 4 * 1e18);\n        vars.kickPenalty   = Maths.wmul(vars.t0KickPenalty, poolState_.inflator);\n\n        kickResult_.t0PoolDebt   = poolState_.t0Debt + vars.t0KickPenalty;\n        kickResult_.t0KickedDebt += vars.t0KickPenalty;\n\n        // update borrower debt with kicked debt penalty\n        borrower.t0Debt = kickResult_.t0KickedDebt;\n\n        emit Kick(\n            borrowerAddress_,\n            vars.borrowerDebt + vars.kickPenalty,\n            vars.borrowerCollateral,\n            vars.bondSize\n        );\n    }\n\n    /**\n     *  @notice Updates escrowed bonds balances, reuse kicker claimable funds and calculates difference needed to cover new bond.\n     *  @dev    === Write state ===\n     *  @dev    update `locked` and `claimable` kicker accumulators\n     *  @dev    update `totalBondEscrowed` accumulator\n     *  @param  auctions_       Struct for pool auctions state.\n     *  @param  bondSize_       Bond size to cover newly kicked auction.\n     *  @return bondDifference_ The amount that kicker should send to pool to cover auction bond.\n     */\n    function _updateEscrowedBonds(\n        AuctionsState storage auctions_,\n        uint256 bondSize_\n    ) internal returns (uint256 bondDifference_){\n        Kicker storage kicker = auctions_.kickers[msg.sender];\n\n        kicker.locked += bondSize_;\n\n        uint256 kickerClaimable = kicker.claimable;\n\n        if (kickerClaimable >= bondSize_) {\n            // no need to update total bond escrowed as bond is covered by kicker claimable (which is already tracked by accumulator)\n            kicker.claimable -= bondSize_;\n        } else {\n            bondDifference_  = bondSize_ - kickerClaimable;\n            kicker.claimable = 0;\n\n            // increment total bond escrowed by amount needed to cover bond difference\n            auctions_.totalBondEscrowed += bondDifference_;\n        }\n    }\n\n    /**\n     *  @notice Saves in storage a new liquidation that was kicked.\n     *  @dev    === Write state ===\n     *  @dev    `borrower -> liquidation` mapping update\n     *  @dev    increment auctions count accumulator\n     *  @dev    updates auction queue state\n     *  @param  auctions_        Struct for pool auctions state.\n     *  @param  liquidation_     Struct for current auction state.\n     *  @param  borrowerAddress_ Address of the borrower that is kicked.\n     *  @param  bondSize_        Bond size to cover newly kicked auction.\n     *  @param  bondFactor_      Bond factor of the newly kicked auction.\n     *  @param  momp_            Current pool `MOMP`.\n     *  @param  neutralPrice_    Current pool `Neutral Price`.\n     */\n    function _recordAuction(\n        AuctionsState storage auctions_,\n        Liquidation storage liquidation_,\n        address borrowerAddress_,\n        uint256 bondSize_,\n        uint256 bondFactor_,\n        uint256 momp_,\n        uint256 neutralPrice_\n    ) internal {\n        // record liquidation info\n        liquidation_.kicker       = msg.sender;\n        liquidation_.kickTime     = uint96(block.timestamp);\n        liquidation_.kickMomp     = uint96(momp_); // cannot exceed max price enforced by _priceAt() function\n        liquidation_.bondSize     = SafeCast.toUint160(bondSize_);\n        liquidation_.bondFactor   = SafeCast.toUint96(bondFactor_);\n        liquidation_.neutralPrice = SafeCast.toUint96(neutralPrice_);\n\n        // increment number of active auctions\n        ++auctions_.noOfAuctions;\n\n        // update auctions queue\n        if (auctions_.head != address(0)) {\n            // other auctions in queue, liquidation doesn't exist or overwriting.\n            auctions_.liquidations[auctions_.tail].next = borrowerAddress_;\n            liquidation_.prev = auctions_.tail;\n        } else {\n            // first auction in queue\n            auctions_.head = borrowerAddress_;\n        }\n        // update liquidation with the new ordering\n        auctions_.tail = borrowerAddress_;\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/libraries/external/KickerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { Math }     from '@openzeppelin/contracts/utils/math/Math.sol';\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Lender,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                             from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    KickReserveAuctionParams\n}                             from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    MAX_NEUTRAL_PRICE,\n    _auctionPrice,\n    _bondParams,\n    _bpf,\n    _claimableReserves,\n    _isCollateralized,\n    _priceAt,\n    _reserveAuctionPrice\n}                                   from '../helpers/PoolHelper.sol';\nimport {\n    _revertIfPriceDroppedBelowLimit\n}                                   from '../helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auctions kicker actions library\n    @notice External library containing kicker actions involving auctions within pool:\n            - kick undercollateralized loans; start reserve auctions\n */\nlibrary KickerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `kick` function local vars.\n    struct KickLocalVars {\n        uint256 borrowerDebt;       // [WAD] the accrued debt of kicked borrower\n        uint256 borrowerCollateral; // [WAD] amount of kicked borrower collateral\n        uint256 neutralPrice;       // [WAD] neutral price recorded in kick action\n        uint256 noOfLoans;          // number of loans and auctions in pool (used to calculate MOMP)\n        uint256 momp;               // [WAD] MOMP of kicked auction\n        uint256 bondFactor;         // [WAD] bond factor of kicked auction\n        uint256 bondSize;           // [WAD] bond size of kicked auction\n        uint256 t0KickPenalty;      // [WAD] t0 debt added as kick penalty\n        uint256 kickPenalty;        // [WAD] current debt added as kick penalty\n    }\n\n    /// @dev Struct used for `kickWithDeposit` function local vars.\n    struct KickWithDepositLocalVars {\n        uint256 amountToDebitFromDeposit; // [WAD] the amount of quote tokens used to kick and debited from lender deposit\n        uint256 bucketCollateral;         // [WAD] amount of collateral in bucket\n        uint256 bucketDeposit;            // [WAD] amount of quote tokens in bucket\n        uint256 bucketLP;                 // [WAD] LP of the bucket\n        uint256 bucketPrice;              // [WAD] bucket price\n        uint256 bucketScale;              // [WAD] bucket scales\n        uint256 bucketUnscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n        uint256 lenderLP;                 // [WAD] LP of lender in bucket\n        uint256 redeemedLP;               // [WAD] LP used by kick action\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event Kick(address indexed borrower, uint256 debt, uint256 collateral, uint256 bond);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);\n    event KickReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice, uint256 currentBurnEpoch);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionActive();\n    error BorrowerOk();\n    error InsufficientLiquidity();\n    error InsufficientLP();\n    error InvalidAmount();\n    error NoReserves();\n    error PriceBelowLUP();\n    error ReserveAuctionTooSoon();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @return The `KickResult` struct result of the kick action.\n     */\n    function kick(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 limitIndex_\n    ) external returns (\n        KickResult memory\n    ) {\n        return _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            borrowerAddress_,\n            limitIndex_,\n            0\n        );\n    }\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @dev    === Write state ===\n     *  @dev   - `Deposits.unscaledRemove` (remove amount in `Fenwick` tree, from index): update `values` array state\n     *  @dev   - decrement `lender.lps` accumulator\n     *  @dev   - decrement `bucket.lps` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    insufficient deposit to kick auction `InsufficientLiquidity()`\n     *  @dev    no `LP` redeemed to kick auction `InsufficientLP()`\n     *  @dev    === Emit events ===\n     *  @dev    - `RemoveQuoteToken`\n     *  @return kickResult_ The `KickResult` struct result of the kick action.\n     */\n    function kickWithDeposit(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        mapping(uint256 => Bucket) storage buckets_,\n        LoansState storage loans_,\n        PoolState calldata poolState_,\n        uint256 index_,\n        uint256 limitIndex_\n    ) external returns (\n        KickResult memory kickResult_\n    ) {\n        Bucket storage bucket = buckets_[index_];\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        KickWithDepositLocalVars memory vars;\n\n        if (bucket.bankruptcyTime < lender.depositTime) vars.lenderLP = lender.lps;\n\n        vars.bucketLP              = bucket.lps;\n        vars.bucketCollateral      = bucket.collateral;\n        vars.bucketPrice           = _priceAt(index_);\n        vars.bucketUnscaledDeposit = Deposits.unscaledValueAt(deposits_, index_);\n        vars.bucketScale           = Deposits.scale(deposits_, index_);\n        vars.bucketDeposit         = Maths.wmul(vars.bucketUnscaledDeposit, vars.bucketScale);\n\n        // calculate amount to remove based on lender LP in bucket\n        vars.amountToDebitFromDeposit = Buckets.lpToQuoteTokens(\n            vars.bucketCollateral,\n            vars.bucketLP,\n            vars.bucketDeposit,\n            vars.lenderLP,\n            vars.bucketPrice,\n            Math.Rounding.Down\n        );\n\n        // cap the amount to remove at bucket deposit\n        if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit;\n\n        // revert if no amount that can be removed\n        if (vars.amountToDebitFromDeposit == 0) revert InsufficientLiquidity();\n\n        // kick top borrower\n        kickResult_ = _kick(\n            auctions_,\n            deposits_,\n            loans_,\n            poolState_,\n            Loans.getMax(loans_).borrower,\n            limitIndex_,\n            vars.amountToDebitFromDeposit\n        );\n\n        // amount to remove from deposit covers entire bond amount\n        if (vars.amountToDebitFromDeposit > kickResult_.amountToCoverBond) {\n            // cap amount to remove from deposit at amount to cover bond\n            vars.amountToDebitFromDeposit = kickResult_.amountToCoverBond;\n\n            // recalculate the LUP with the amount to cover bond\n            kickResult_.lup = Deposits.getLup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit);\n            // entire bond is covered from deposit, no additional amount to be send by lender\n            kickResult_.amountToCoverBond = 0;\n        } else {\n            // lender should send additional amount to cover bond\n            kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;\n        }\n\n        // revert if the bucket price used to kick and remove is below new LUP\n        if (vars.bucketPrice < kickResult_.lup) revert PriceBelowLUP();\n\n        // remove amount from deposits\n        if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {\n            // In this case we are redeeming the entire bucket exactly, and need to ensure bucket LP are set to 0\n            vars.redeemedLP = vars.bucketLP;\n\n            Deposits.unscaledRemove(deposits_, index_, vars.bucketUnscaledDeposit);\n            vars.bucketUnscaledDeposit = 0;\n\n        } else {\n            vars.redeemedLP = Buckets.quoteTokensToLP(\n                vars.bucketCollateral,\n                vars.bucketLP,\n                vars.bucketDeposit,\n                vars.amountToDebitFromDeposit,\n                vars.bucketPrice,\n                Math.Rounding.Up\n            );\n\n            uint256 unscaledAmountToRemove = Maths.floorWdiv(vars.amountToDebitFromDeposit, vars.bucketScale);\n\n            // revert if calculated unscaled amount is 0\n            if (unscaledAmountToRemove == 0) revert InsufficientLiquidity();\n\n            Deposits.unscaledRemove(deposits_, index_, unscaledAmountToRemove);\n            vars.bucketUnscaledDeposit -= unscaledAmountToRemove;\n        }\n\n        vars.redeemedLP = Maths.min(vars.lenderLP, vars.redeemedLP);\n\n        // revert if LP redeemed amount to kick auction is 0\n        if (vars.redeemedLP == 0) revert InsufficientLP();\n\n        uint256 bucketRemainingLP = vars.bucketLP - vars.redeemedLP;\n\n        if (vars.bucketCollateral == 0 && vars.bucketUnscaledDeposit == 0 && bucketRemainingLP != 0) {\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n\n            emit BucketBankruptcy(\n                index_,\n                bucketRemainingLP\n            );\n        } else {\n            // update lender and bucket LP balances\n            lender.lps -= vars.redeemedLP;\n            bucket.lps -= vars.redeemedLP;\n        }\n\n        emit RemoveQuoteToken(\n            msg.sender,\n            index_,\n            vars.amountToDebitFromDeposit,\n            vars.redeemedLP,\n            kickResult_.lup\n        );\n    }\n\n    /*************************/\n    /***  Reserve Auction  ***/\n    /*************************/\n\n    /**\n     *  @notice See `IPoolKickerActions` for descriptions.\n     *  @dev    === Write state ===\n     *  @dev    update `reserveAuction.unclaimed` accumulator\n     *  @dev    update `reserveAuction.kicked` timestamp state\n     *  @dev    === Reverts on ===\n     *  @dev    no reserves to claim `NoReserves()`\n     *  @dev    === Emit events ===\n     *  @dev    - `KickReserveAuction`\n     *  @return kickerAward_ The `LP`s awarded to reserve auction kicker.\n     */\n    function kickReserveAuction(\n        AuctionsState storage auctions_,\n        ReserveAuctionState storage reserveAuction_,\n        KickReserveAuctionParams calldata params_\n    ) external returns (uint256 kickerAward_) {\n        // retrieve timestamp of latest burn event and last burn timestamp\n        uint256 latestBurnEpoch   = reserveAuction_.latestBurnEventEpoch;\n        uint256 lastBurnTimestam"
    }
  ]
}