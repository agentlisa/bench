{
  "Title": "Privileges granted to accounts as `system contracts` cannot be revoked",
  "Content": "##### Description\nAccounts can be marked as [`isTroveManager`, `isBorrowerOperations` and `isStabilityPool`](https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/THUSDToken.sol#L58-L61). Such accounts have privileged access to some functionality: burn and arbitrary transfer between accounts. However, once granted, this privilege can't be revoked. If one of these accounts become compromised, there is no way to revoke its privileges.\n\n##### Recommendation\nIt is recommended to introduce functions to pause (temporarily disable)`TroveManager`, `BorrowerOperations` and `StabilityPool` privileges for specified accounts.\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts/contracts/THUSDToken.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"./Interfaces/ITHUSDToken.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/console.sol\";\n\n/*\n*\n* Based upon OpenZeppelin's ERC20 contract:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n*\n* and their EIP2612 (ERC20Permit / ERC712) functionality:\n* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n*\n*\n* --- Functionality added specific to the THUSDToken ---\n*\n* 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external\n* transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending THUSD directly to a Liquity\n* core contract, when they should rather call the right function.\n*\n* 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move THUSD tokens between Liquity <-> user.\n*/\n\ncontract THUSDToken is Ownable, CheckContract, ITHUSDToken {\n\n    uint256 private _totalSupply;\n    string constant internal _NAME = \"thUSD Stablecoin\";\n    string constant internal _SYMBOL = \"thUSD\";\n    string constant internal _VERSION = \"1\";\n    uint8 constant internal _DECIMALS = 18;\n\n    // --- Data for EIP2612 ---\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _TYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n\n    mapping (address => uint256) private _nonces;\n\n    // User data for THUSD token\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    // --- Addresses ---\n    mapping(address => bool) public isTroveManager;\n    mapping(address => bool) public isStabilityPools;\n    mapping(address => bool) public isBorrowerOperations;\n    mapping(address => bool) public mintList;\n\n    uint256 public immutable governanceTimeDelay;\n\n    address public pendingTroveManager;\n    address public pendingStabilityPool;\n    address public pendingBorrowerOperations;\n    address public pendingRevokedMintAddress;\n    address public pendingAddedMintAddress;\n    uint256 public revokeMintListInitiated;\n    uint256 public addContractsInitiated;\n    uint256 public addMintListInitiated;\n\n    constructor\n    (\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress,\n        uint256 _governanceTimeDelay\n    )\n    {\n        // when created its linked to one set of contracts and collateral, other collateral types can be added via governance\n        _addSystemContracts(_troveManagerAddress, _stabilityPoolAddress, _borrowerOperationsAddress);\n        bytes32 hashedName = keccak256(bytes(_NAME));\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\n\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _chainID();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\n        governanceTimeDelay = _governanceTimeDelay;\n    }\n\n    modifier onlyAfterGovernanceDelay(\n        uint256 _changeInitializedTimestamp\n    ) {\n        require(_changeInitializedTimestamp > 0, \"Change not initiated\");\n        require(\n            block.timestamp >= _changeInitializedTimestamp + governanceTimeDelay,\n            \"Governance delay has not elapsed\"\n        );\n        _;\n    }\n\n    // --- Governance ---\n\n    function startRevokeMintList(address _account)\n        external\n        onlyOwner\n    {\n        require(mintList[_account], \"Incorrect address to revoke\");\n\n        revokeMintListInitiated = block.timestamp;\n        pendingRevokedMintAddress = _account;\n    }\n\n    function cancelRevokeMintList() external onlyOwner {\n        require(revokeMintListInitiated != 0, \"Revoking from mint list is not started\");\n\n        revokeMintListInitiated = 0;\n        pendingRevokedMintAddress = address(0);\n    }\n\n    function finalizeRevokeMintList()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(revokeMintListInitiated)\n    {\n        mintList[pendingRevokedMintAddress] = false;\n        revokeMintListInitiated = 0;\n        pendingRevokedMintAddress = address(0);\n    }\n\n    function startAddMintList(address _account) external onlyOwner {\n        require(!mintList[_account], \"Incorrect address to add\");\n\n        addMintListInitiated = block.timestamp;\n        pendingAddedMintAddress = _account;\n    }\n\n    function cancelAddMintList() external onlyOwner {\n        require(addMintListInitiated != 0, \"Adding to mint list is not started\");\n\n        addMintListInitiated = 0;\n        pendingAddedMintAddress = address(0);\n    }\n\n    function finalizeAddMintList()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(addMintListInitiated)\n    {\n        mintList[pendingAddedMintAddress] = true;\n        addMintListInitiated = 0;\n        pendingAddedMintAddress = address(0);\n    }\n\n    function startAddContracts(address _troveManagerAddress, address _stabilityPoolAddress, address _borrowerOperationsAddress)\n        external\n        onlyOwner\n    {\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        // save as provisional contracts to add\n        pendingTroveManager = _troveManagerAddress;\n        pendingStabilityPool = _stabilityPoolAddress;\n        pendingBorrowerOperations = _borrowerOperationsAddress;\n\n        // save block number\n        addContractsInitiated = block.timestamp;\n    }\n\n    function cancelAddContracts() external onlyOwner {\n        require(addContractsInitiated != 0, \"Adding contracts is not started\");\n\n        addContractsInitiated = 0;\n        pendingTroveManager = address(0);\n        pendingStabilityPool = address(0);\n        pendingBorrowerOperations = address(0);\n    }\n\n    function finalizeAddContracts()\n        external\n        onlyOwner\n        onlyAfterGovernanceDelay(addContractsInitiated)\n    {\n        // make sure minimum blocks has passed\n        _addSystemContracts(pendingTroveManager, pendingStabilityPool, pendingBorrowerOperations);\n        addContractsInitiated = 0;\n        pendingTroveManager = address(0);\n        pendingStabilityPool = address(0);\n        pendingBorrowerOperations = address(0);\n    }\n\n    // --- Functions for intra-Liquity calls ---\n\n    function mint(address _account, uint256 _amount) external override {\n        require(mintList[msg.sender], \"THUSDToken: Caller not allowed to mint\");\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external override {\n        require(\n            isBorrowerOperations[msg.sender] ||\n            isTroveManager[msg.sender] ||\n            isStabilityPools[msg.sender],\n            \"THUSD: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(address _sender,  address _poolAddress, uint256 _amount) external override {\n        require(isStabilityPools[msg.sender], \"THUSD: Caller is not the StabilityPool\");\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {\n        require(\n            isTroveManager[msg.sender] || isStabilityPools[msg.sender],\n            \"THUSD: Caller is neither TroveManager nor StabilityPool\"\n        );\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- External functions ---\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    // --- EIP 2612 Functionality ---\n\n    function domainSeparator() public view override returns (bytes32) {\n        if (_chainID() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function permit\n    (\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n        override\n    {\n        require(deadline >= block.timestamp, 'THUSD: expired deadline');\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01',\n                         domainSeparator(), keccak256(abi.encode(\n                         _PERMIT_TYPEHASH, owner, spender, amount,\n                         _nonces[owner]++, deadline))));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, 'THUSD: invalid signature');\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) external view override returns (uint256) { // FOR EIP 2612\n        return _nonces[owner];\n    }\n\n    // --- Internal operations ---\n\n    function _chainID() private view returns (uint256 chainID) {\n        assembly {\n            chainID := chainid()\n        }\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 hashedName, bytes32 hashedVersion) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, hashedName, hashedVersion, _chainID(), address(this)));\n    }\n\n    // --- Internal operations ---\n\n    function _addSystemContracts(address _troveManagerAddress, address _stabilityPoolAddress, address _borrowerOperationsAddress) internal {\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        isTroveManager[_troveManagerAddress] = true;\n        emit TroveManagerAddressAdded(_troveManagerAddress);\n\n        isStabilityPools[_stabilityPoolAddress] = true;\n        emit StabilityPoolAddressAdded(_stabilityPoolAddress);\n\n        isBorrowerOperations[_borrowerOperationsAddress] = true;\n        emit BorrowerOperationsAddressAdded(_borrowerOperationsAddress);\n\n        mintList[_borrowerOperationsAddress] = true;\n    }\n\n    // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        assert(sender != address(0));\n        assert(recipient != address(0));\n\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        assert(account != address(0));\n\n        _totalSupply = _totalSupply + amount;\n        _balances[account] = _balances[account] + amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        assert(account != address(0));\n\n        require(_balances[account] >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] -= amount;\n        _totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        assert(owner != address(0));\n        assert(spender != address(0));\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) &&\n            _recipient != address(this),\n            \"THUSD: Cannot transfer tokens directly to the THUSD token contract or the zero address\"\n        );\n    }\n\n    // --- Optional functions ---\n\n    function name() external pure override returns (string memory) {\n        return _NAME;\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return _SYMBOL;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return _DECIMALS;\n    }\n\n    function version() external pure override returns (string memory) {\n        return _VERSION;\n    }\n\n    function permitTypeHash() external pure override returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n}"
    }
  ]
}