{
  "Title": "Missing Docstrings",
  "Content": "Throughout the [codebase](https://github.com/Ion-Protocol/ion-protocol/tree/5333fe3c49d8de302e93f097a836e5c1b5090f2d/), there are several parts that do not have docstrings:\n\n\n* [Lines 4-9](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/interfaces/IRedstone.sol#L4-L9) in [`IRedstone.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/interfaces/IRedstone.sol)\n* [Lines 72-80](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/IonHandlerBase.sol#L72-L80) in [`IonHandlerBase.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/IonHandlerBase.sol)\n* [Lines 6-116](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/interfaces/ProviderInterfaces.sol#L6-L116) in [`ProviderInterfaces.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/interfaces/ProviderInterfaces.sol)\n* [Lines 47-48](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L47-L48) in [`UniswapFlashswapDirectMintHandler.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol)\n* [Line 49](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapHandler.sol#L49) in [`UniswapFlashswapHandler.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapHandler.sol)\n* [Lines 15-39](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/WeEthHandler.sol#L15-L39) in [`WeEthHandler.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/WeEthHandler.sol)\n* [Lines 69-81](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/YieldOracle.sol#L69-L81) in [`YieldOracle.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/YieldOracle.sol).\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not `public`, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec).\n\n\n***Update:** Partially resolved in [pull request #54](https://github.com/Ion-Protocol/ion-protocol/pull/54). the following instances remain unresolved:*\n\n\n* [Lines 72-80](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/IonHandlerBase.sol#L72-L80) in `IonHandlerBase.sol`\n* [Lines 6-116](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/interfaces/ProviderInterfaces.sol#L6-L116) in `ProviderInterfaces.sol`\n* [Lines 47-48](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol#L47-L48) in `UniswapFlashswapDirectMintHandler.sol`\n* [Line 49](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/flash/handlers/base/UniswapFlashswapHandler.sol#L49) in `UniswapFlashswapHandler.sol`\n* [Lines 69-81](https://github.com/Ion-Protocol/ion-protocol/blob/5333fe3c49d8de302e93f097a836e5c1b5090f2d/src/YieldOracle.sol#L69-L81) in `YieldOracle.sol`\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/interfaces/IRedstone.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IRedstonePriceFeed {\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}"
    },
    {
      "filename": "src/flash/handlers/base/IonHandlerBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonPool } from \"../../../IonPool.sol\";\nimport { IWETH9 } from \"../../../interfaces/IWETH9.sol\";\nimport { GemJoin } from \"../../../join/GemJoin.sol\";\nimport { WadRayMath, RAY } from \"../../../libraries/math/WadRayMath.sol\";\nimport { Whitelist } from \"../../../Whitelist.sol\";\nimport { WETH_ADDRESS } from \"../../../Constants.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @notice The base handler contract for simpler interactions with the `IonPool`\n * core contract. It combines various individual interactions into one compound\n * interaction to faciliate reaching user end-goals in atomic fashion.\n *\n * @dev To actually borrow from `IonPool`, a user must submit a \"normalized\" borrow\n * amount. This contract is designed to be user-intuitive and, thus, allows a user\n * to submit a standard desired borrow amount, which this contract will then\n * convert into to the appropriate \"normalized\" borrow amount.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract IonHandlerBase {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH9;\n    using WadRayMath for uint256;\n\n    error CannotSendEthToContract();\n    error FlashloanRepaymentTooExpensive(uint256 repaymentAmount, uint256 maxRepaymentAmount);\n    error TransactionDeadlineReached(uint256 deadline);\n\n    /**\n     * @notice Checks if the tx is being executed before the designated deadline\n     * for execution.\n     * @dev This is used to prevent txs that have sat in the mempool for too\n     * long from executing at unintended prices.\n     */\n    modifier checkDeadline(uint256 deadline) {\n        if (deadline <= block.timestamp) revert TransactionDeadlineReached(deadline);\n        _;\n    }\n\n    /**\n     * @notice Checks if `msg.sender` is on the whitelist.\n     * @dev This contract will be on the `protocolControlledWhitelist`. As such,\n     * it will validate that users are on the whitelist itself and be able to\n     * bypass the whitelist check on `IonPool`.\n     * @param proof to validate the whitelist check.\n     */\n    modifier onlyWhitelistedBorrowers(bytes32[] memory proof) {\n        WHITELIST.isWhitelistedBorrower(ILK_INDEX, msg.sender, msg.sender, proof);\n        _;\n    }\n\n    /**\n     * @dev During conversion from borrow amount -> \"normalized\" borrow amount,\"\n     * there is division required. In certain scenarios, it may be desirable to\n     * round up during division, in others, to round down. This enum allows a\n     * developer to indicate the rounding direction by describing the\n     * `amountToBorrow`. If it `IS_MIN`, then the final borrowed amount should\n     * be larger than `amountToBorrow` (round up), and vice versa for `IS_MAX`\n     * (round down).\n     */\n    enum AmountToBorrow {\n        IS_MIN,\n        IS_MAX\n    }\n\n    IERC20 public immutable BASE;\n    // Will keep WETH for compatability with other strategies. But this should\n    // be removed eventually to remove dependence on WETH as a base asset.\n    IWETH9 public immutable WETH;\n    uint8 public immutable ILK_INDEX;\n    IonPool public immutable POOL;\n    GemJoin public immutable JOIN;\n    IERC20 public immutable LST_TOKEN;\n    Whitelist public immutable WHITELIST;\n\n    /**\n     * @notice Creates a new instance of `IonHandlerBase`\n     * @param _ilkIndex of the ilk for which this instance is associated with.\n     * @param _ionPool address of `IonPool` core contract.\n     * @param _gemJoin the `GemJoin` associated with the `ilkIndex` of this\n     * contract.\n     * @param _whitelist the `Whitelist` module address.\n     */\n    constructor(uint8 _ilkIndex, IonPool _ionPool, GemJoin _gemJoin, Whitelist _whitelist) {\n        POOL = _ionPool;\n        ILK_INDEX = _ilkIndex;\n\n        BASE = IERC20(_ionPool.underlying());\n\n        IWETH9 _weth = WETH_ADDRESS;\n        WETH = _weth;\n\n        address ilkAddress = POOL.getIlkAddress(_ilkIndex);\n        LST_TOKEN = IERC20(ilkAddress);\n\n        JOIN = _gemJoin;\n\n        WHITELIST = _whitelist;\n\n        BASE.approve(address(_ionPool), type(uint256).max);\n        IERC20(ilkAddress).approve(address(_gemJoin), type(uint256).max);\n    }\n\n    /**\n     * @notice Combines gem-joining and depositing collateral and then borrowing\n     * into one compound action.\n     * @param amountCollateral Amount of collateral to deposit. [WAD]\n     * @param amountToBorrow Amount of WETH to borrow. Due to rounding, true\n     * borrow amount might be slightly less. [WAD]\n     * @param proof that the user is whitelisted.\n     */\n    function depositAndBorrow(\n        uint256 amountCollateral,\n        uint256 amountToBorrow,\n        bytes32[] calldata proof\n    )\n        external\n        onlyWhitelistedBorrowers(proof)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), amountCollateral);\n        _depositAndBorrow(msg.sender, msg.sender, amountCollateral, amountToBorrow, AmountToBorrow.IS_MAX);\n    }\n\n    /**\n     * @notice Handles all logic to gem-join and deposit collateral, followed by\n     * a borrow. It is also possible to use this function simply to gem-join and\n     * deposit collateral atomically by setting `amountToBorrow` to 0.\n     * @param vaultHolder The user who will be responsible for repaying debt.\n     * @param receiver The user who receives the borrowed funds.\n     * @param amountCollateral to move into vault. [WAD]\n     * @param amountToBorrow out of the vault. [WAD]\n     * @param amountToBorrowType Whether the `amountToBorrow` is a min or max.\n     * This will dictate the rounding direction when converting to normalized\n     * amount. If it is a minimum, then the rounding will be rounded up. If it\n     * is a maximum, then the rounding will be rounded down.\n     */\n    function _depositAndBorrow(\n        address vaultHolder,\n        address receiver,\n        uint256 amountCollateral,\n        uint256 amountToBorrow,\n        AmountToBorrow amountToBorrowType\n    )\n        internal\n    {\n        JOIN.join(address(this), amountCollateral);\n\n        POOL.depositCollateral(ILK_INDEX, vaultHolder, address(this), amountCollateral, new bytes32[](0));\n\n        if (amountToBorrow == 0) return;\n\n        uint256 rate = POOL.rate(ILK_INDEX);\n\n        uint256 normalizedAmountToBorrow;\n        if (amountToBorrowType == AmountToBorrow.IS_MIN) {\n            normalizedAmountToBorrow = amountToBorrow.rayDivUp(rate);\n        } else {\n            normalizedAmountToBorrow = amountToBorrow.rayDivDown(rate);\n        }\n\n        POOL.borrow(ILK_INDEX, vaultHolder, receiver, normalizedAmountToBorrow, new bytes32[](0));\n    }\n\n    /**\n     * @notice Will repay all debt and withdraw desired collateral amount. This\n     * function can also simply be used for a full repayment (which may be\n     * difficult through a direct tx to the `IonPool`) by setting\n     * `collateralToWithdraw` to 0.\n     * @dev Will repay the debt belonging to `msg.sender`. This function is\n     * necessary because with `rate` updating every single block, it may be\n     * difficult to repay a full amount if a user uses the total debt from a\n     * previous block. If a user ends up repaying all but dust amounts of debt\n     * (due to a slight `rate` change), then they repayment will likely fail due\n     * to the `dust` parameter.\n     * @param collateralToWithdraw in collateral terms. [WAD]\n     */\n    function repayFullAndWithdraw(uint256 collateralToWithdraw) external {\n        (uint256 repayAmount, uint256 normalizedDebtToRepay) = _getFullRepayAmount(msg.sender);\n\n        BASE.safeTransferFrom(msg.sender, address(this), repayAmount);\n\n        POOL.repay(ILK_INDEX, msg.sender, address(this), normalizedDebtToRepay);\n\n        POOL.withdrawCollateral(ILK_INDEX, msg.sender, address(this), collateralToWithdraw);\n\n        JOIN.exit(msg.sender, collateralToWithdraw);\n    }\n\n    /**\n     * @notice Helper function to get the repayment amount for all the debt of a\n     * `user`.\n     * @dev This simply emulates the rounding behaviour of the `IonPool` to\n     * arrive at an accurate value.\n     * @param user Address of the user.\n     * @return repayAmount Amount of base asset required to repay all debt (this\n     * mimics IonPool's behavior). [WAD]\n     * @return normalizedDebt Total normalized debt held by `user`'s vault.\n     * [WAD]\n     */\n    function _getFullRepayAmount(address user) internal view returns (uint256 repayAmount, uint256 normalizedDebt) {\n        uint256 currentRate = POOL.rate(ILK_INDEX);\n\n        normalizedDebt = POOL.normalizedDebt(ILK_INDEX, user);\n\n        // This is exactly how IonPool calculates the amount of base asset\n        // required\n        uint256 amountRad = normalizedDebt * currentRate;\n        repayAmount = amountRad / RAY;\n        if (amountRad % RAY > 0) ++repayAmount;\n    }\n\n    /**\n     * @notice Combines repaying debt and then withdrawing and gem-exitting\n     * collateral into one compound action.\n     *\n     * If repaying **all** is the intention, use `repayFullAndWithdraw()`\n     * instead to prevent tx revert from dust amounts of debt in vault.\n     * @param debtToRepay In ETH terms. [WAD]\n     * @param collateralToWithdraw In collateral terms. [WAD]\n     */\n    function repayAndWithdraw(uint256 debtToRepay, uint256 collateralToWithdraw) external {\n        BASE.safeTransferFrom(msg.sender, address(this), debtToRepay);\n        _repayAndWithdraw(msg.sender, msg.sender, collateralToWithdraw, debtToRepay);\n    }\n\n    /**\n     * @notice Handles all logic to repay debt, followed by a collateral\n     * withdrawal and gem-exit. This function can also be used to just withdraw\n     * and gem-exit in atomic fashion by setting the `debtToRepay` to 0.\n     * @param vaultHolder The user whose debt will be repaid.\n     * @param receiver The user who receives the the withdrawn collateral.\n     * @param collateralToWithdraw to move into vault. [WAD]\n     * @param debtToRepay out of the vault. [WAD]\n     */\n    function _repayAndWithdraw(\n        address vaultHolder,\n        address receiver,\n        uint256 collateralToWithdraw,\n        uint256 debtToRepay\n    )\n        internal\n    {\n        uint256 currentRate = POOL.rate(ILK_INDEX);\n\n        uint256 normalizedDebtToRepay = debtToRepay.rayDivDown(currentRate);\n\n        POOL.repay(ILK_INDEX, vaultHolder, address(this), normalizedDebtToRepay);\n\n        POOL.withdrawCollateral(ILK_INDEX, vaultHolder, address(this), collateralToWithdraw);\n\n        JOIN.exit(receiver, collateralToWithdraw);\n    }\n\n    /**\n     * @notice ETH cannot be directly sent to this contract.\n     * @dev To allow unwrapping of WETH into ETH.\n     */\n    receive() external payable {\n        if (msg.sender != address(WETH_ADDRESS)) revert CannotSendEthToContract();\n    }\n}"
    },
    {
      "filename": "src/interfaces/ProviderInterfaces.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStEth is IERC20 {\n    function submit(address _referral) external payable returns (uint256);\n\n    function getTotalPooledEther() external view returns (uint256);\n\n    function getTotalShares() external view returns (uint256);\n\n    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);\n\n    function getCurrentStakeLimit() external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n}\n\ninterface IWstEth is IERC20 {\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n\n    /**\n     * @notice Exchanges wstETH to stETH\n     * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n     * @dev Requirements:\n     *  - `_wstETHAmount` must be non-zero\n     *  - msg.sender must have at least `_wstETHAmount` wstETH.\n     * @return Amount of stETH user receives after unwrap\n     */\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n\n    function getStETHByWstETH(uint256 _ETHAmount) external view returns (uint256);\n\n    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);\n\n    function stETH() external view returns (address);\n\n    function stEthPerToken() external view returns (uint256);\n\n    function tokensPerStEth() external view returns (uint256);\n}\n\ninterface IStaderStakePoolsManager {\n    function deposit(address _receiver) external payable returns (uint256);\n\n    function previewDeposit(uint256 _assets) external view returns (uint256);\n\n    function previewWithdraw(uint256 _shares) external view returns (uint256);\n\n    function getExchangeRate() external view returns (uint256);\n\n    function staderConfig() external view returns (IStaderConfig);\n\n    function totalAssets() external view returns (uint256);\n}\n\ninterface IStaderConfig {\n    function getMinDepositAmount() external view returns (uint256);\n\n    function getMaxDepositAmount() external view returns (uint256);\n\n    function getStaderOracle() external view returns (address);\n}\n\n/// @title ExchangeRate\n/// @notice This struct holds data related to the exchange rate between ETH and ETHx.\nstruct ExchangeRate {\n    /// @notice The block number when the exchange rate was last updated.\n    uint256 reportingBlockNumber;\n    /// @notice The total balance of Ether (ETH) in the system.\n    uint256 totalETHBalance;\n    /// @notice The total supply of the liquid staking token (ETHx) in the system.\n    uint256 totalETHXSupply;\n}\n\ninterface IStaderOracle {\n    function getExchangeRate() external view returns (ExchangeRate memory);\n}\n\ninterface IETHx is IERC20 { }\n\ninterface ISwEth {\n    function deposit() external payable;\n\n    function swETHToETHRate() external view returns (uint256);\n\n    function ethToSwETHRate() external view returns (uint256);\n\n    function getRate() external view returns (uint256);\n}\n\ninterface IWeEth is IERC20 {\n    function getRate() external view returns (uint256);\n    function getEETHByWeETH(uint256) external view returns (uint256);\n\n    // Official function technically returns the interface but we won't type it\n    // here\n    function eETH() external view returns (address);\n    function liquidityPool() external view returns (address);\n    function wrap(uint256 _eETHAmount) external returns (uint256);\n    function unwrap(uint256 _weETHAmount) external returns (uint256);\n}\n\ninterface IEEth is IERC20 {\n    function totalShares() external view returns (uint256);\n}\n\ninterface IEtherFiLiquidityPool {\n    function totalValueOutOfLp() external view returns (uint128);\n    function totalValueInLp() external view returns (uint128);\n    function amountForShare(uint256 _share) external view returns (uint256);\n    function sharesForAmount(uint256 _amount) external view returns (uint256);\n    function deposit() external payable returns (uint256);\n    function getTotalPooledEther() external view returns (uint256);\n    function getTotalEtherClaimOf(address _user) external view returns (uint256);\n}"
    },
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapDirectMintHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { IWETH9 } from \"../../../interfaces/IWETH9.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport { IERC20 as IERC20Balancer } from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { WSTETH_ADDRESS } from \"../../../Constants.sol\";\n\n/**\n * @notice This contract allows for easy creation of leverge positions through a\n * Uniswap flashswap and direct mint of the collateral from the provider. This\n * will be used when the collateral cannot be minted directly with the base\n * asset but can be directly minted by a token that the base asset has a\n * UniswapV3 pool with.\n *\n * This contract is to be used when there exists a UniswapV3 pool between the\n * base asset and the mint asset.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract UniswapFlashswapDirectMintHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH9;\n    using SafeCast for uint256;\n\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    uint256 private flashloanInitiated = 1;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n    IERC20 public immutable MINT_ASSET;\n    bool private immutable MINT_IS_TOKEN0;\n\n    /**\n     * @notice Creates a new `UniswapFlashswapDirectMintHandler` instance.\n     * @param _uniswapPool Pool to perform the flashswap on.\n     * @param _mintAsset The asset used to mint the collateral.\n     */\n    constructor(IUniswapV3Pool _uniswapPool, IERC20 _mintAsset) {\n        if (address(_uniswapPool) == address(0)) revert InvalidUniswapPool();\n\n        MINT_ASSET = _mintAsset;\n\n        address token0 = _uniswapPool.token0();\n        address token1 = _uniswapPool.token1();\n\n        if (token0 != address(MINT_ASSET) && token1 != address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n        if (token0 == address(MINT_ASSET) && token1 == address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n\n        UNISWAP_POOL = _uniswapPool;\n        MINT_IS_TOKEN0 = token0 == address(MINT_ASSET) ? true : false;\n\n        address baseAsset = MINT_IS_TOKEN0 ? token1 : token0;\n\n        if (baseAsset != address(BASE)) revert InvalidUniswapPool();\n    }\n\n    /**\n     * @notice Transfer collateral from user -> Initiate flashswap between from\n     * base asset to mint asset -> Use the mint asset to mint the collateral ->\n     * Deposit all collateral into `IonPool` -> Borrow the base asset -> Close\n     * the flashswap by sending the base asset to the Uniswap pool.\n     * @param initialDeposit in collateral terms. [WAD]\n     * @param resultingAdditionalCollateral in collateral terms. [WAD]\n     * @param maxResultingDebt in base asset terms. [WAD]\n     * @param proof used to validate the user is whitelisted.\n     */\n    function flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt,\n        uint256 deadline,\n        bytes32[] memory proof\n    )\n        external\n        onlyWhitelistedBorrowers(proof)\n        checkDeadline(deadline)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n        _flashswapAndMint(initialDeposit, resultingAdditionalCollateral, maxResultingDebt);\n    }\n\n    function _flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        internal\n    {\n        IERC20Balancer[] memory addresses = new IERC20Balancer[](1);\n        addresses[0] = IERC20Balancer(address(WETH));\n\n        uint256 amountLrt = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getAmountInForCollateralAmountOut(amountLrt);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        if (amountWethToFlashloan > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n\n        // We want to swap for ETH here\n        bool zeroForOne = MINT_IS_TOKEN0 ? false : true;\n        _initiateFlashSwap({\n            zeroForOne: zeroForOne,\n            amountOut: amountWethToFlashloan,\n            recipient: address(this),\n            data: abi.encode(msg.sender, resultingAdditionalCollateral, initialDeposit)\n        });\n    }\n\n    /**\n     * @notice Handles swap intiation logic. This function can only initiate\n     * exact output swaps.\n     * @param zeroForOne Direction of the swap.\n     * @param amountOut Desired amount of output.\n     * @param recipient of output tokens.\n     * @param data Arbitrary data to be passed through swap callback.\n     */\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        bytes memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient, zeroForOne, -amountOut.toInt256(), zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, data\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        if (amountOutReceived != amountOut) revert OutputAmountNotReceived(amountOutReceived, amountOut);\n    }\n\n    /**\n     * @notice From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * @dev One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        (address user, uint256 resultingAdditionalCollateral, uint256 initialDeposit) =\n            abi.decode(_data, (address, uint256, uint256));\n\n        // Code below this if statement will always assume token0 is MINT_ASSET. If it\n        // is not actually the case, we will flip the vars\n        if (!MINT_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n        }\n\n        address tokenIn = address(BASE);\n\n        // Sanity check that Uniswap is sending MINT_ASSET\n        assert(amount0Delta < 0 && amount1Delta > 0);\n\n        // MINT_ASSET needs to be converted into collateral asset\n        uint256 collateralFromDeposit = _mintCollateralAsset(uint256(-amount0Delta));\n\n        // Sanity check\n        assert(collateralFromDeposit + initialDeposit == resultingAdditionalCollateral);\n\n        // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed\n        // to cover the amount owed back to Uniswap\n        _depositAndBorrow(\n            user, address(this), resultingAdditionalCollateral, uint256(amount1Delta), AmountToBorrow.IS_MIN\n        );\n\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount1Delta));\n    }\n\n    /**\n     * @notice Deposits the mint asset into the a provider's collateral asset.\n     * @param amountMintAsset amount of \"mint asset\" to deposit. [WAD]\n     */\n    function _mintCollateralAsset(uint256 amountMintAsset) internal virtual returns (uint256);\n\n    /**\n     * @notice Calculates the amount of eth required to receive `amountLrt`.\n     * @dev Calculates the amount of eth required to receive `amountLrt`.\n     * @param amountLrt Desired output amount. [WAD]\n     * @return Amount mint asset required for desired output. [WAD]\n     */\n    function _getAmountInForCollateralAmountOut(uint256 amountLrt) internal view virtual returns (uint256);\n}"
    },
    {
      "filename": "src/flash/handlers/base/UniswapFlashswapHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { WadRayMath } from \"../../../libraries/math/WadRayMath.sol\";\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\n/**\n * @notice This contract allows for easy creation and closing of leverage\n * positions through Uniswap flashswaps--flashloan not necessary! In terms of\n * creation, this may be a more desirable path than directly minting from an LST\n * provider since market prices tend to be slightly lower than provider exchange\n * rates. DEXes also provide an avenue for atomic deleveraging since the LST ->\n * ETH exchange can be made.\n *\n * @dev When using the `UniswapFlashSwapHandler`, the `IUniswapV3Pool pool` fed to the\n * constructor should be the WETH/[LST] pool.\n *\n * Unlike Balancer flashloans, there is no concern here that somebody else could\n * initiate a flashswap, then direct the callback to be called on this contract.\n * Uniswap enforces that callback is only called on `msg.sender`.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract UniswapFlashswapHandler is IonHandlerBase, IUniswapV3SwapCallback {\n    using WadRayMath for *;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n    error InvalidSqrtPriceLimitX96(uint160 sqrtPriceLimitX96);\n\n    error FlashswapRepaymentTooExpensive(uint256 amountIn, uint256 maxAmountIn);\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n    bool private immutable WETH_IS_TOKEN0;\n\n    /**\n     * @notice Creates a new `UniswapFlashswapHandler` instance.\n     * @param _pool Pool to perform the flashswap on.\n     * @param _wethIsToken0 Whether WETH is token0 or token1 in the pool.\n     */\n    constructor(IUniswapV3Pool _pool, bool _wethIsToken0) {\n        if (address(_pool) == address(0)) revert InvalidUniswapPool();\n\n        address token0 = _pool.token0();\n        address token1 = _pool.token1();\n\n        if (token0 != address(WETH) && token1 != address(WETH)) revert InvalidUniswapPool();\n        if (token0 == address(WETH) && token1 == address(WETH)) revert InvalidUniswapPool();\n\n        UNISWAP_POOL = _pool;\n        WETH_IS_TOKEN0 = _wethIsToken0;\n    }\n\n    struct FlashSwapData {\n        address user;\n        // This value will be used for change in collateral during leveraging and change in (normalized) debt during\n        // deleveraging\n        uint256 changeInCollateralOrDebt;\n        bool zeroForOne;\n    }\n\n    /**\n     * @notice Transfer collateral from user -> initate swap for collateral from\n     * WETH on Uniswap (contract will receive collateral first) -> deposit all\n     * collateral into `IonPool` -> borrow WETH from `IonPool` -> complete swap\n     * by sending WETH to Uniswap.\n     *\n     * @param initialDeposit in collateral terms. [WAD]\n     * @param resultingAdditionalCollateral in collateral terms. [WAD]\n     * @param maxResultingAdditionalDebt in WETH terms. This value also allows\n     * the user to control slippage of the swap. [WAD]\n     * @param sqrtPriceLimitX96 for the swap. Recommended value is the current\n     * exchange rate to ensure the swap never costs more than a direct mint\n     * would. Passing the current exchange rate means swapping beyond that point\n     * is worse than direct minting.\n     * @param deadline timestamp for which the transaction must be executed.\n     * This prevents txs that have sat in the mempool for too long to be\n     * executed.\n     * @param proof that the user is whitelisted.\n     */\n    function flashswapLeverage(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingAdditionalDebt,\n        uint160 sqrtPriceLimitX96,\n        uint256 deadline,\n        bytes32[] memory proof\n    )\n        external\n        checkDeadline(deadline)\n        onlyWhitelistedBorrowers(proof)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n        _flashswapLeverage(initialDeposit, resultingAdditionalCollateral, maxResultingAdditionalDebt, sqrtPriceLimitX96);\n    }\n\n    /**\n     *\n     * @param initialDeposit in terms of swETH\n     * @param resultingAdditionalCollateral in terms of swETH. How much\n     * collateral to add to the position in the vault.\n     * @param maxResultingAdditionalDebt in terms of WETH. How much debt to add\n     * to the position in the vault.\n     * @param sqrtPriceLimitX96 for the swap. Recommended value is the current\n     * exchange rate to ensure the swap never costs more than a direct mint\n     * would.\n     */\n    function _flashswapLeverage(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingAdditionalDebt,\n        uint160 sqrtPriceLimitX96\n    )\n        internal\n    {\n        uint256 amountToLeverage = resultingAdditionalCollateral - initialDeposit; // in swETH\n\n        if (amountToLeverage == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        // Flashswap WETH for collateral. We will return the WETH inside the Uniswap\n        // callback\n        // zeroForOne is WETH -> collateral\n        bool zeroForOne = WETH_IS_TOKEN0;\n\n        FlashSwapData memory flashswapData = FlashSwapData({\n            user: msg.sender,\n            changeInCollateralOrDebt: resultingAdditionalCollateral,\n            zeroForOne: zeroForOne\n        });\n\n        uint256 amountIn =\n            _initiateFlashSwap(zeroForOne, amountToLeverage, address(this), sqrtPriceLimitX96, flashswapData);\n\n        // This protects against a potential sandwich attack\n        if (amountIn > maxResultingAdditionalDebt) {\n            revert FlashswapRepaymentTooExpensive(amountIn, maxResultingAdditionalDebt);\n        }\n    }\n\n    /**\n     * @notice Initiate swap for WETH from collateral (contract will receive\n     * WETH first) -> repay debt on `IonPool` -> withdraw (and gem-exit)\n     * collateral from `IonPool` -> complete swap by sending collateral to\n     * Uniswap.\n     *\n     * @dev The two function parameters must be chosen carefully. If\n     * `maxCollateralToRemove`'s ETH valuation were higher then `debtToRemove`,\n     * it would theoretically be possible to sell more collateral then was\n     * required for `debtToRemove` to be repaid (even if `debtToRemove` is worth\n     * nowhere near that valuation) due to the slippage of the sell.\n     * `maxCollateralToRemove` is essentially a slippage guard here.\n     * @param maxCollateral"
    }
  ]
}