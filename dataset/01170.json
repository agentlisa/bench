{
  "Title": "Unsafe ABI Encoding",
  "Content": "Throughout the [codebase](https://github.com/scroll-tech/scroll/tree/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2) there are several occurrences of unsafe ABI encodings through the use of `abi.encodeWithSelector`. It is not an uncommon practice to use either `abi.encodeWithSignature` or `abi.encodeWithSelector` to generate this calldata. However, the first option is not typo-safe and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe. These occurrences are outlined below:\n\n\n* On [line 132](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2CustomERC20Gateway.sol#L132) of [`L2CustomERC20Gateway.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2CustomERC20Gateway.sol)\n* On [line 173](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ERC1155Gateway.sol#L173) of [`L2ERC1155Gateway.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ERC1155Gateway.sol)\n* On [line 216](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ERC1155Gateway.sol#L216) of [`L2ERC1155Gateway.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ERC1155Gateway.sol)\n* On [line 166](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ERC721Gateway.sol#L166) of [`L2ERC721Gateway.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ERC721Gateway.sol)\n* On [line 205](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ERC721Gateway.sol#L205) of [`L2ERC721Gateway.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ERC721Gateway.sol)\n* On [line 100](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ETHGateway.sol#L100) of [`L2ETHGateway.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2ETHGateway.sol)\n* On [line 144](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2StandardERC20Gateway.sol#L144) of [`L2StandardERC20Gateway.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2StandardERC20Gateway.sol)\n* On [line 124](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2WETHGateway.sol#L124) of [`L2WETHGateway.sol`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/gateways/L2WETHGateway.sol)\n\n\nConsider replacing all the occurrences of unsafe ABI encodings with `abi.encodeCall`, which checks whether the supplied values actually match the types expected by the called function and also avoids errors caused by typos. Note that `abi.encodeCall` was not introduced until Solidity `0.8.11`. However, it is recommended to use Solidity `0.8.13` or above since there was a [bug detected](https://blog.soliditylang.org/2022/03/16/encodecall-bug/) regarding fixed-length bytes literals. Using an updated version will remove the possibility of future errors. In order to perform this safe encoding, consider upgrading all contracts from `^0.8.0` to Solidity version `0.8.13` at a minimum, but ideally to the latest version.\n\n\n***Update**: Acknowledged, will resolve. The Scroll team stated:*\n\n\n\n> *This issue was also reported in the Layer 1 report (N-02 Error-Prone Call Encoding). This is not a priority at the time. It will be addressed later on.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L2/gateways/L2CustomERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {IL2ERC20Gateway, L2ERC20Gateway} from \"./L2ERC20Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../IL2ScrollMessenger.sol\";\nimport {IL1ERC20Gateway} from \"../../L1/gateways/IL1ERC20Gateway.sol\";\nimport {ScrollGatewayBase, IScrollGateway} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IScrollERC20} from \"../../libraries/token/IScrollERC20.sol\";\n\n/// @title L2ERC20Gateway\n/// @notice The `L2ERC20Gateway` is used to withdraw custom ERC20 compatible tokens in layer 2 and\n/// finalize deposit the tokens from layer 1.\n/// @dev The withdrawn tokens tokens will be burned directly. On finalizing deposit, the corresponding\n/// tokens will be minted and transfered to the recipient.\ncontract L2CustomERC20Gateway is OwnableUpgradeable, ScrollGatewayBase, L2ERC20Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param _l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param _l1Token The address of ERC20 token in layer 1.\n    event UpdateTokenMapping(address _l2Token, address _l1Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from layer 2 token address to layer 1 token address for ERC20 token.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        OwnableUpgradeable.__Ownable_init();\n\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL1ERC20Address(address _l2Token) external view override returns (address) {\n        return tokenMapping[_l2Token];\n    }\n\n    /// @inheritdoc IL2ERC20Gateway\n    function getL2ERC20Address(address) public pure override returns (address) {\n        revert(\"unimplemented\");\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL2ERC20Gateway\n    function finalizeDepositERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == 0, \"nonzero msg.value\");\n        require(_l1Token != address(0), \"token address cannot be 0\");\n        require(_l1Token == tokenMapping[_l2Token], \"l1 token mismatch\");\n\n        IScrollERC20(_l2Token).mint(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeDepositERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 2 to layer 1 token mapping.\n    /// @param _l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param _l1Token The address of ERC20 token in layer 1.\n    function updateTokenMapping(address _l2Token, address _l1Token) external onlyOwner {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n\n        tokenMapping[_l2Token] = _l1Token;\n\n        emit UpdateTokenMapping(_l2Token, _l1Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @inheritdoc L2ERC20Gateway\n    function _withdraw(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual override nonReentrant {\n        address _l1Token = tokenMapping[_token];\n        require(_l1Token != address(0), \"no corresponding l1 token\");\n\n        require(_amount > 0, \"withdraw zero amount\");\n\n        // 1. Extract real sender if this call is from L2GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Burn token.\n        IScrollERC20(_token).burn(_from, _amount);\n\n        // 3. Generate message passed to L1StandardERC20Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL1ERC20Gateway.finalizeWithdrawERC20.selector,\n            _l1Token,\n            _token,\n            _from,\n            _to,\n            _amount,\n            _data\n        );\n\n        // 4. send message to L2ScrollMessenger\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit WithdrawERC20(_l1Token, _token, _from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/gateways/L2ERC1155Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport {ERC1155HolderUpgradeable, ERC1155ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\n\nimport {IL2ERC1155Gateway} from \"./IL2ERC1155Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../IL2ScrollMessenger.sol\";\nimport {IL1ERC1155Gateway} from \"../../L1/gateways/IL1ERC1155Gateway.sol\";\nimport {ScrollGatewayBase, IScrollGateway} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IScrollERC1155} from \"../../libraries/token/IScrollERC1155.sol\";\n\n/// @title L2ERC1155Gateway\n/// @notice The `L2ERC1155Gateway` is used to withdraw ERC1155 compatible NFTs in layer 2 and\n/// finalize deposit the NFTs from layer 1.\n/// @dev The withdrawn NFTs tokens will be burned directly. On finalizing deposit, the corresponding\n/// NFT will be minted and transfered to the recipient.\n///\n/// This will be changed if we have more specific scenarios.\ncontract L2ERC1155Gateway is OwnableUpgradeable, ERC1155HolderUpgradeable, ScrollGatewayBase, IL2ERC1155Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC1155 token is updated.\n    /// @param _l1Token The address of corresponding ERC1155 token in layer 2.\n    /// @param _l1Token The address of ERC1155 token in layer 1.\n    event UpdateTokenMapping(address _l2Token, address _l1Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from layer 2 token address to layer 1 token address for ERC1155 NFT.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(address _counterpart, address _messenger) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ERC1155HolderUpgradeable.__ERC1155Holder_init();\n        ERC1155ReceiverUpgradeable.__ERC1155Receiver_init();\n\n        ScrollGatewayBase._initialize(_counterpart, address(0), _messenger);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function withdrawERC1155(\n        address _token,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _withdrawERC1155(_token, msg.sender, _tokenId, _amount, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function withdrawERC1155(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _withdrawERC1155(_token, _to, _tokenId, _amount, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function batchWithdrawERC1155(\n        address _token,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchWithdrawERC1155(_token, msg.sender, _tokenIds, _amounts, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function batchWithdrawERC1155(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchWithdrawERC1155(_token, _to, _tokenIds, _amounts, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function finalizeDepositERC1155(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n        require(_l1Token == tokenMapping[_l2Token], \"l2 token mismatch\");\n\n        IScrollERC1155(_l2Token).mint(_to, _tokenId, _amount, \"\");\n\n        emit FinalizeDepositERC1155(_l1Token, _l2Token, _from, _to, _tokenId, _amount);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function finalizeBatchDepositERC1155(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n        require(_l1Token == tokenMapping[_l2Token], \"l2 token mismatch\");\n\n        IScrollERC1155(_l2Token).batchMint(_to, _tokenIds, _amounts, \"\");\n\n        emit FinalizeBatchDepositERC1155(_l1Token, _l2Token, _from, _to, _tokenIds, _amounts);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 2 to layer 1 token mapping.\n    /// @param _l1Token The address of corresponding ERC1155 token in layer 2.\n    /// @param _l1Token The address of ERC1155 token in layer 1.\n    function updateTokenMapping(address _l2Token, address _l1Token) external onlyOwner {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n\n        tokenMapping[_l2Token] = _l1Token;\n\n        emit UpdateTokenMapping(_l2Token, _l1Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to withdraw ERC1155 NFT to layer 2.\n    /// @param _token The address of ERC1155 NFT in layer 1.\n    /// @param _to The address of recipient in layer 2.\n    /// @param _tokenId The token id to withdraw.\n    /// @param _amount The amount of token to withdraw.\n    /// @param _gasLimit Estimated gas limit required to complete the withdraw on layer 2.\n    function _withdrawERC1155(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_amount > 0, \"withdraw zero amount\");\n\n        address _l1Token = tokenMapping[_token];\n        require(_l1Token != address(0), \"no corresponding l1 token\");\n\n        // 1. burn token\n        IScrollERC1155(_token).burn(msg.sender, _tokenId, _amount);\n\n        // 2. Generate message passed to L1ERC1155Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL1ERC1155Gateway.finalizeWithdrawERC1155.selector,\n            _l1Token,\n            _token,\n            msg.sender,\n            _to,\n            _tokenId,\n            _amount\n        );\n\n        // 3. Send message to L2ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit WithdrawERC1155(_l1Token, _token, msg.sender, _to, _tokenId, _amount);\n    }\n\n    /// @dev Internal function to batch withdraw ERC1155 NFT to layer 2.\n    /// @param _token The address of ERC1155 NFT in layer 1.\n    /// @param _to The address of recipient in layer 2.\n    /// @param _tokenIds The list of token ids to withdraw.\n    /// @param _amounts The list of corresponding number of token to withdraw.\n    /// @param _gasLimit Estimated gas limit required to complete the withdraw on layer 1.\n    function _batchWithdrawERC1155(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_tokenIds.length > 0, \"no token to withdraw\");\n        require(_tokenIds.length == _amounts.length, \"length mismatch\");\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            require(_amounts[i] > 0, \"withdraw zero amount\");\n        }\n\n        address _l1Token = tokenMapping[_token];\n        require(_l1Token != address(0), \"no corresponding l1 token\");\n\n        // 1. transfer token to this contract\n        IScrollERC1155(_token).batchBurn(msg.sender, _tokenIds, _amounts);\n\n        // 2. Generate message passed to L1ERC1155Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL1ERC1155Gateway.finalizeBatchWithdrawERC1155.selector,\n            _l1Token,\n            _token,\n            msg.sender,\n            _to,\n            _tokenIds,\n            _amounts\n        );\n\n        // 3. Send message to L2ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit BatchWithdrawERC1155(_l1Token, _token, msg.sender, _to, _tokenIds, _amounts);\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/gateways/L2ERC1155Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport {ERC1155HolderUpgradeable, ERC1155ReceiverUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\n\nimport {IL2ERC1155Gateway} from \"./IL2ERC1155Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../IL2ScrollMessenger.sol\";\nimport {IL1ERC1155Gateway} from \"../../L1/gateways/IL1ERC1155Gateway.sol\";\nimport {ScrollGatewayBase, IScrollGateway} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IScrollERC1155} from \"../../libraries/token/IScrollERC1155.sol\";\n\n/// @title L2ERC1155Gateway\n/// @notice The `L2ERC1155Gateway` is used to withdraw ERC1155 compatible NFTs in layer 2 and\n/// finalize deposit the NFTs from layer 1.\n/// @dev The withdrawn NFTs tokens will be burned directly. On finalizing deposit, the corresponding\n/// NFT will be minted and transfered to the recipient.\n///\n/// This will be changed if we have more specific scenarios.\ncontract L2ERC1155Gateway is OwnableUpgradeable, ERC1155HolderUpgradeable, ScrollGatewayBase, IL2ERC1155Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC1155 token is updated.\n    /// @param _l1Token The address of corresponding ERC1155 token in layer 2.\n    /// @param _l1Token The address of ERC1155 token in layer 1.\n    event UpdateTokenMapping(address _l2Token, address _l1Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from layer 2 token address to layer 1 token address for ERC1155 NFT.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(address _counterpart, address _messenger) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ERC1155HolderUpgradeable.__ERC1155Holder_init();\n        ERC1155ReceiverUpgradeable.__ERC1155Receiver_init();\n\n        ScrollGatewayBase._initialize(_counterpart, address(0), _messenger);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function withdrawERC1155(\n        address _token,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _withdrawERC1155(_token, msg.sender, _tokenId, _amount, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function withdrawERC1155(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _withdrawERC1155(_token, _to, _tokenId, _amount, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function batchWithdrawERC1155(\n        address _token,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchWithdrawERC1155(_token, msg.sender, _tokenIds, _amounts, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function batchWithdrawERC1155(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchWithdrawERC1155(_token, _to, _tokenIds, _amounts, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function finalizeDepositERC1155(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n        require(_l1Token == tokenMapping[_l2Token], \"l2 token mismatch\");\n\n        IScrollERC1155(_l2Token).mint(_to, _tokenId, _amount, \"\");\n\n        emit FinalizeDepositERC1155(_l1Token, _l2Token, _from, _to, _tokenId, _amount);\n    }\n\n    /// @inheritdoc IL2ERC1155Gateway\n    function finalizeBatchDepositERC1155(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n        require(_l1Token == tokenMapping[_l2Token], \"l2 token mismatch\");\n\n        IScrollERC1155(_l2Token).batchMint(_to, _tokenIds, _amounts, \"\");\n\n        emit FinalizeBatchDepositERC1155(_l1Token, _l2Token, _from, _to, _tokenIds, _amounts);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 2 to layer 1 token mapping.\n    /// @param _l1Token The address of corresponding ERC1155 token in layer 2.\n    /// @param _l1Token The address of ERC1155 token in layer 1.\n    function updateTokenMapping(address _l2Token, address _l1Token) external onlyOwner {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n\n        tokenMapping[_l2Token] = _l1Token;\n\n        emit UpdateTokenMapping(_l2Token, _l1Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to withdraw ERC1155 NFT to layer 2.\n    /// @param _token The address of ERC1155 NFT in layer 1.\n    /// @param _to The address of recipient in layer 2.\n    /// @param _tokenId The token id to withdraw.\n    /// @param _amount The amount of token to withdraw.\n    /// @param _gasLimit Estimated gas limit required to complete the withdraw on layer 2.\n    function _withdrawERC1155(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_amount > 0, \"withdraw zero amount\");\n\n        address _l1Token = tokenMapping[_token];\n        require(_l1Token != address(0), \"no corresponding l1 token\");\n\n        // 1. burn token\n        IScrollERC1155(_token).burn(msg.sender, _tokenId, _amount);\n\n        // 2. Generate message passed to L1ERC1155Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL1ERC1155Gateway.finalizeWithdrawERC1155.selector,\n            _l1Token,\n            _token,\n            msg.sender,\n            _to,\n            _tokenId,\n            _amount\n        );\n\n        // 3. Send message to L2ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit WithdrawERC1155(_l1Token, _token, msg.sender, _to, _tokenId, _amount);\n    }\n\n    /// @dev Internal function to batch withdraw ERC1155 NFT to layer 2.\n    /// @param _token The address of ERC1155 NFT in layer 1.\n    /// @param _to The address of recipient in layer 2.\n    /// @param _tokenIds The list of token ids to withdraw.\n    /// @param _amounts The list of corresponding number of token to withdraw.\n    /// @param _gasLimit Estimated gas limit required to complete the withdraw on layer 1.\n    function _batchWithdrawERC1155(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _amounts,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_tokenIds.length > 0, \"no token to withdraw\");\n        require(_tokenIds.length == _amounts.length, \"length mismatch\");\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            require(_amounts[i] > 0, \"withdraw zero amount\");\n        }\n\n        address _l1Token = tokenMapping[_token];\n        require(_l1Token != address(0), \"no corresponding l1 token\");\n\n        // 1. transfer token to this contract\n        IScrollERC1155(_token).batchBurn(msg.sender, _tokenIds, _amounts);\n\n        // 2. Generate message passed to L1ERC1155Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL1ERC1155Gateway.finalizeBatchWithdrawERC1155.selector,\n            _l1Token,\n            _token,\n            msg.sender,\n            _to,\n            _tokenIds,\n            _amounts\n        );\n\n        // 3. Send message to L2ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit BatchWithdrawERC1155(_l1Token, _token, msg.sender, _to, _tokenIds, _amounts);\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/gateways/L2ERC721Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\nimport {IL2ERC721Gateway} from \"./IL2ERC721Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../IL2ScrollMessenger.sol\";\nimport {IL1ERC721Gateway} from \"../../L1/gateways/IL1ERC721Gateway.sol\";\nimport {ScrollGatewayBase, IScrollGateway} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IScrollERC721} from \"../../libraries/token/IScrollERC721.sol\";\n\n/// @title L2ERC721Gateway\n/// @notice The `L2ERC721Gateway` is used to withdraw ERC721 compatible NFTs in layer 2 and\n/// finalize deposit the NFTs from layer 1.\n/// @dev The withdrawn NFTs tokens will be burned directly. On finalizing deposit, the corresponding\n/// NFT will be minted and transfered to the recipient.\n///\n/// This will be changed if we have more specific scenarios.\ncontract L2ERC721Gateway is OwnableUpgradeable, ERC721HolderUpgradeable, ScrollGatewayBase, IL2ERC721Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC721 token is updated.\n    /// @param _l1Token The address of corresponding ERC721 token in layer 2.\n    /// @param _l1Token The address of ERC721 token in layer 1.\n    event UpdateTokenMapping(address _l2Token, address _l1Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from layer 2 token address to layer 1 token address for ERC721 NFT.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(address _counterpart, address _messenger) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ERC721HolderUpgradeable.__ERC721Holder_init();\n\n        ScrollGatewayBase._initialize(_counterpart, address(0), _messenger);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL2ERC721Gateway\n    function withdrawERC721(\n        address _token,\n        uint256 _tokenId,\n        uint256 _gasLimit\n    ) external payable override {\n        _withdrawERC721(_token, msg.sender, _tokenId, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC721Gateway\n    function withdrawERC721(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _gasLimit\n    ) external payable override {\n        _withdrawERC721(_token, _to, _tokenId, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC721Gateway\n    function batchWithdrawERC721(\n        address _token,\n        uint256[] calldata _tokenIds,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchWithdrawERC721(_token, msg.sender, _tokenIds, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC721Gateway\n    function batchWithdrawERC721(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256 _gasLimit\n    ) external payable override {\n        _batchWithdrawERC721(_token, _to, _tokenIds, _gasLimit);\n    }\n\n    /// @inheritdoc IL2ERC721Gateway\n    function finalizeDepositERC721(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n        require(_l1Token == tokenMapping[_l2Token], \"l2 token mismatch\");\n\n        IScrollERC721(_l2Token).mint(_to, _tokenId);\n\n        emit FinalizeDepositERC721(_l1Token, _l2Token, _from, _to, _tokenId);\n    }\n\n    /// @inheritdoc IL2ERC721Gateway\n    function finalizeBatchDepositERC721(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256[] calldata _tokenIds\n    ) external override onlyCallByCounterpart nonReentrant {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n        require(_l1Token == tokenMapping[_l2Token], \"l2 token mismatch\");\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            IScrollERC721(_l2Token).mint(_to, _tokenIds[i]);\n        }\n\n        emit FinalizeBatchDepositERC721(_l1Token, _l2Token, _from, _to, _tokenIds);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update layer 2 to layer 1 token mapping.\n    /// @param _l1Token The address of corresponding ERC721 token in layer 2.\n    /// @param _l1Token The address of ERC721 token in layer 1.\n    function updateTokenMapping(address _l2Token, address _l1Token) external onlyOwner {\n        require(_l1Token != address(0), \"token address cannot be 0\");\n\n        tokenMapping[_l2Token] = _l1Token;\n\n        emit UpdateTokenMapping(_l2Token, _l1Token);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to withdraw ERC721 NFT to layer 1.\n    /// @param _token The address of ERC721 NFT in layer 2.\n    /// @param _to The address of recipient in layer 1.\n    /// @param _tokenId The token id to withdraw.\n    /// @param _gasLimit Estimated gas limit required to complete the withdraw on layer 1.\n    function _withdrawERC721(\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        address _l1Token = tokenMapping[_token];\n        require(_l1Token != address(0), \"no corresponding l1 token\");\n\n        // 1. burn token\n        // @note in case the token has given too much power to the gateway, we check owner here.\n        require(IScrollERC721(_token).ownerOf(_tokenId) == msg.sender, \"token not owned\");\n        IScrollERC721(_token).burn(_tokenId);\n\n        // 2. Generate message passed to L1ERC721Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL1ERC721Gateway.finalizeWithdrawERC721.selector,\n            _l1Token,\n            _token,\n            msg.sender,\n            _to,\n            _tokenId\n        );\n\n        // 3. Send message to L2ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit WithdrawERC721(_l1Token, _token, msg.sender, _to, _tokenId);\n    }\n\n    /// @dev Internal function to batch withdraw ERC721 NFT to layer 1.\n    /// @param _token The address of ERC721 NFT in layer 2.\n    /// @param _to The address of recipient in layer 1.\n    /// @param _tokenIds The list of token ids to withdraw.\n    /// @param _gasLimit Estimated gas limit required to complete the withdraw on layer 1.\n    function _batchWithdrawERC721(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        uint256 _gasLimit\n    ) internal nonReentrant {\n        require(_tokenIds.length > 0, \"no token to withdraw\");\n\n        address _l1Token = tokenMapping[_token];\n        require(_l1Token != address(0), \"no corresponding l1 token\");\n\n        // 1. transfer token to this contract\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            // @note in case the token has given too much power to the gateway, we check owner here.\n            require(IScrollERC721(_token).ownerOf(_tokenIds[i]) == msg.sender, \"token not owned\");\n            IScrollERC721(_token).burn(_tokenIds[i]);\n        }\n\n        // 2. Generate message passed to L1ERC721Gateway.\n        bytes memory _message = abi.encodeWithSelector(\n            IL1ERC721Gateway.finalizeBatchWithdrawERC721.selector,\n            _l1Token,\n            _token,\n            msg.sender,\n            _to,\n            _tokenIds\n        );\n\n        // 3. Send message to L2ScrollMessenger.\n        IL2ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, 0, _message, _gasLimit);\n\n        emit BatchWithdrawERC721(_l1Token, _token, msg.sender, _to, _tokenIds);\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/gateways/L2ERC721Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\nimport {IL2ERC721Gateway} from \"./IL2ERC721Gateway.sol\";\nimport {IL2ScrollMessenger} from \"../IL2ScrollMessenger.sol\";\nimport {IL1ERC721Gateway} from \"../../L1/gateways/IL1ERC721Gateway.sol\";\nimport {ScrollGatewayBase, IScrollGateway} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IScrollERC721} from \"../../libraries/token/IScrollERC721.sol\";\n\n/// @title L2ERC721Gateway\n/// @notice The `L2ERC721Gateway` is used to withdraw ERC721 compatible NFTs in layer 2 and\n/// finalize deposit the NFTs from layer 1.\n/// @dev The withdrawn NFTs tokens will be burned directly. On finalizing deposit, the corresponding\n/// NFT will be minted and transfered to the recipient.\n///\n/// This will be changed if we have more specific scenarios.\ncontract L2ERC721Gateway is OwnableUpgradeable, ERC721HolderUpgradeable, ScrollGatewayBase, IL2ERC721Gateway {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC721 token is updated.\n    /// @param _l1Token The address of corresponding ERC721 token in layer 2.\n    /// @param _l1Token The address of ERC721 token in layer 1.\n    event UpdateTokenMapping(address _l2Token, address _l1Token);\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from layer 2 token address to layer 1 token address for ERC721 NFT.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public tokenMapping;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    function initialize(address _counterpart, addres"
    }
  ]
}