{
  "Title": "[L-06] Uniswap DOS",
  "Content": "\nThe `README.md` talks about the fact that the orderer splits up orders to reduce price impact. This means that either the `orderer` has a slippage bounds which can DOSed with [sandwich attacks](https://github.com/code-423n4/2021-04-maple-findings/issues/105), or the code uses some sort of VWAP/TWAP, which can also be gamed with flash loans submitted for every slice of the order\n\n1.  File: contracts/IndexLogic.sol (line [142](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/IndexLogic.sol#L142))\n\n```solidity\n                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-phuture-finance-contest",
  "Code": [
    {
      "filename": "contracts/IndexLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IIndexLogic.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\nimport \"./PhutureIndex.sol\";\n\n/// @title Index logic\n/// @notice Contains common logic for index minting and burning\ncontract IndexLogic is PhutureIndex, IIndexLogic {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n    /// @notice Role granted for asset which should be skipped during burning\n    bytes32 internal constant SKIPPED_ASSET_ROLE = keccak256(\"SKIPPED_ASSET_ROLE\");\n\n    /// @notice Mints index to `_recipient` address\n    /// @param _recipient Recipient address\n    function mint(address _recipient) external override {\n        address feePool = IIndexRegistry(registry).feePool();\n        _chargeAUMFee(feePool);\n\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n\n        uint lastAssetBalanceInBase;\n        uint minAmountInBase = type(uint).max;\n        for (uint i; i < assets.length(); ++i) {\n            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), \"Index: INVALID_ASSET\");\n            if (weightOf[assets.at(i)] == 0) {\n                continue;\n            }\n            uint assetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));\n            // Q_b * w_i * p_i = Q_i\n            // Q_b = Q_i / (w_i * p_i)\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)));\n            uint amountInAsset = IERC20(assets.at(i)).balanceOf(address(vToken)) - vToken.lastBalance();\n            uint weightedPrice = assetPerBaseInUQ * weightOf[assets.at(i)];\n            uint _minAmountInBase = amountInAsset.mulDiv(FixedPoint112.Q112 * IndexLibrary.MAX_WEIGHT, weightedPrice);\n            if (_minAmountInBase < minAmountInBase) {\n                minAmountInBase = _minAmountInBase;\n            }\n            uint lastBalanceInAsset = vToken.lastAssetBalanceOf(address(this));\n            vToken.mint();\n            uint balanceInBase = lastBalanceInAsset.mulDiv(FixedPoint112.Q112, assetPerBaseInUQ);\n            lastAssetBalanceInBase += balanceInBase;\n        }\n\n        for (uint i; i < inactiveAssets.length(); ++i) {\n            if (!IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, inactiveAssets.at(i))) {\n                uint lastBalanceInAsset = IvToken(\n                    IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(inactiveAssets.at(i))\n                ).lastAssetBalanceOf(address(this));\n                lastAssetBalanceInBase += lastBalanceInAsset.mulDiv(\n                    FixedPoint112.Q112,\n                    oracle.refreshedAssetPerBaseInUQ(inactiveAssets.at(i))\n                );\n            }\n        }\n\n        assert(minAmountInBase != type(uint).max);\n\n        uint value;\n        if (totalSupply() != 0) {\n            require(lastAssetBalanceInBase > 0, \"Index: INSUFFICIENT_AMOUNT\");\n            value =\n                (oracle.convertToIndex(minAmountInBase, decimals()) * totalSupply()) /\n                oracle.convertToIndex(lastAssetBalanceInBase, decimals());\n        } else {\n            value = oracle.convertToIndex(minAmountInBase, decimals()) - IndexLibrary.INITIAL_QUANTITY;\n            _mint(address(0xdead), IndexLibrary.INITIAL_QUANTITY);\n        }\n\n        uint fee = (value * IFeePool(feePool).mintingFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n        if (fee > 0) {\n            _mint(feePool, fee);\n            value -= fee;\n        }\n\n        _mint(_recipient, value);\n    }\n\n    /// @notice Burns index and transfers assets to `_recipient` address\n    /// @param _recipient Recipient address\n    function burn(address _recipient) external override {\n        uint value = balanceOf(address(this));\n        require(value > 0, \"Index: INSUFFICIENT_AMOUNT\");\n        uint length = assets.length();\n\n        bool containsBlacklistedAssets;\n        for (uint i; i < length; ++i) {\n            if (!IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i))) {\n                containsBlacklistedAssets = true;\n                break;\n            }\n        }\n\n        if (!containsBlacklistedAssets) {\n            address feePool = IIndexRegistry(registry).feePool();\n\n            uint fee = (value * IFeePool(feePool).burningFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n\n            if (fee > 0) {\n                // AUM charged in _transfer method\n                _transfer(address(this), feePool, fee);\n                value -= fee;\n            } else {\n                _chargeAUMFee(feePool);\n            }\n        }\n\n        address orderer = IIndexRegistry(registry).orderer();\n        uint lastOrderId = IOrderer(orderer).lastOrderIdOf(address(this));\n        for (uint i; i < length + inactiveAssets.length(); ++i) {\n            address asset = i < length ? assets.at(i) : inactiveAssets.at(i - length);\n            if (containsBlacklistedAssets && IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, asset)) {\n                continue;\n            }\n\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset));\n            uint indexAssetBalance = vToken.balanceOf(address(this));\n            uint accountBalance = (value * indexAssetBalance) / totalSupply();\n            if (accountBalance == 0) {\n                continue;\n            }\n\n            // calculate index value in vault to be burned\n            vToken.transfer(address(vToken), accountBalance);\n            vToken.burn(_recipient);\n            if (lastOrderId > 0) {\n                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());\n            }\n        }\n\n        _burn(address(this), value);\n    }\n}"
    }
  ]
}