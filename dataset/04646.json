{
  "Title": "COSMOS address recording method not recommended",
  "Content": "[As mentioned in these notes](https://gist.github.com/mappum/428dc46afba73b2bf8c38f65272704d2#notes), COSMOS address recording mechanism uses pay-to-pubkey-hash outputs, which can be seen in [lines 102 to 104 of bitcoin.js of fundraiser-lib](https://github.com/cosmos/fundraiser-lib/blob/426425dfc296060a9b87830e69e19ae8a6d444c0/src/bitcoin.js#L102-L104). This is a very inefficient method, because it creates unspendable outputs, bloating the UTXO set forever. A better approach is to use OP\\_RETURN outputs, as mentioned in the notes linked above. See [how DFINITY did their address recording](https://github.com/dfinity/STIFTUNG-DFN-donations/blob/master/app/javascripts/btc.js#L323) for more info.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/bitcoin.js",
      "content": "const bs58check = require('bs58check')\nconst { Transaction, script, address } = require('bitcoinjs-lib')\nconst request = require('request')\nconst secp256k1 = require('secp256k1')\nconst { sha2, ripemd160 } = require('./hash.js')\nconst { byte, concat } = require('./util.js')\n\nconst DEV = process.env.NODE_ENV === 'development'\nconst EXODUS_ADDRESS = '1EaV33reN8XWWUfs5jkbGMD399vie5KQc4'\nconst FEE_RATE = 220 // satoshis per byte\nconst MINIMUM_AMOUNT = DEV ? 60000 : 1000000 // min satoshis to send to exodus\nconst ATOMS_PER_BTC = 2000\nconst MINIMUM_OUTPUT = 1000\n\n// exodus pubkey hash\n// TODO: exodus should be P2Sh\n// TODO: address prefix byte sanity check\nconst exodusPkh = bs58check.decode(EXODUS_ADDRESS).slice(1)\n\nfunction getAddress (pub) {\n  let pubkeyHash = ripemd160(sha2(pub))\n  let outputScript = script.pubKeyHashOutput(pubkeyHash)\n  return address.fromOutputScript(outputScript)\n}\n\nfunction bciRequest (method, url, data, cb) {\n  return request({\n    method,\n    url: `https://blockchain.info/${url}`,\n    qs: { cors: true },\n    form: data\n  }, (err, res, body) => {\n    if (err || res.statusCode !== 200) {\n      return cb(err || Error(res.statusCode), body)\n    }\n    try {\n      body = JSON.parse(body)\n    } catch (err) {}\n    cb(null, body)\n  })\n}\n\n// fetch all utxos for this address\nfunction fetchUtxos (address, cb) {\n  bciRequest('GET', `unspent?active=${address}`, null, (err, res) => {\n    // when there are no outputs for this address,\n    // blockchain API gives error 500 with this message:\n    if (err && res === 'No free outputs to spend') {\n      return cb(null, { utxos: [], amount: 0 })\n    }\n    if (err) return cb(err)\n    let amount = 0\n    for (let utxo of res.unspent_outputs) {\n      amount += utxo.value\n    }\n    cb(null, { utxos: res.unspent_outputs, amount })\n  })\n}\n\nfunction waitForPayment (address, cb) {\n  const done = (err, res) => {\n    clearInterval(interval)\n    cb(err, res)\n  }\n  const checkForUnspent = () => {\n    fetchUtxos(address, (err, res) => {\n      if (err) return done(err)\n      if (res.amount < MINIMUM_AMOUNT) return\n      done(null, res)\n    })\n  }\n  // poll once every 6 seconds\n  let interval = setInterval(checkForUnspent, 6000)\n  checkForUnspent()\n}\n\nfunction pushTx (tx, cb) {\n  bciRequest('POST', 'pushtx', { tx: tx.toHex() }, cb)\n}\n\nfunction createFinalTx (wallet, inputs) {\n  if (inputs.amount < MINIMUM_AMOUNT) {\n    throw Error(`Intermediate tx is smaller than minimum.\n      minimum=${MINIMUM_AMOUNT}\n      actual=${inputs.amount}`)\n  }\n\n  let tx = new Transaction()\n\n  // add inputs from intermediate tx\n  for (let output of inputs.utxos) {\n    let txid = Buffer(output.tx_hash, 'hex')\n    tx.addInput(txid, output.tx_output_n)\n  }\n\n  // pay to exodus address, spendable by Cosmos developers\n  // TODO: exodus should be P2SH\n  let payToExodus = script.pubKeyHashOutput(exodusPkh)\n  tx.addOutput(payToExodus, inputs.amount)\n\n  // output to specify user's Cosmos address\n  let cosmosAddress = Buffer(wallet.addresses.cosmos, 'hex')\n  let specifyCosmosAddress = script.pubKeyHashOutput(cosmosAddress)\n  tx.addOutput(specifyCosmosAddress, MINIMUM_OUTPUT)\n\n  // deduct fee from exodus output\n  let feeAmount = tx.byteLength() * FEE_RATE\n  if (tx.outs[0].value < MINIMUM_OUTPUT) {\n    throw Error(`Not enough coins given to pay fee.\n      tx length=${tx.byteLength()}\n      fee rate=${FEE_RATE} satoshi/byte\n      fee amount=${feeAmount} satoshis\n      output amount=${tx.outs[0].value} satoshis`)\n  }\n  tx.outs[0].value -= feeAmount\n\n  // sign inputs\n  let privKey = wallet.privateKeys.bitcoin\n  let pubKey = wallet.publicKeys.bitcoin\n  let sigHashType = Transaction.SIGHASH_ALL\n  for (let i = 0; i < tx.ins.length; i++) {\n    let input = tx.ins[i] // tx input\n    let prevOut = inputs.utxos[i] // utxo associated w/ this input\n    let scriptPubKey = Buffer(prevOut.script, 'hex') // utxo's script\n    let sigHash = tx.hashForSignature(i, scriptPubKey, sigHashType)\n    let signature = sign(privKey, sigHash)\n    signature = concat(signature, byte(sigHashType)) // append sighash type byte\n    input.script = script.pubKeyHashInput(signature, pubKey)\n  }\n\n  let paidAmount = inputs.amount\n  let atomAmount = (tx.outs[0].value * ATOMS_PER_BTC) / 1e8\n  return { tx, paidAmount, feeAmount, atomAmount }\n}\n\nfunction sign (privKey, sigHash) {\n  let { signature } = secp256k1.sign(sigHash, privKey)\n  signature = secp256k1.signatureNormalize(signature) // enforce low-S\n  return secp256k1.signatureExport(signature) // convert to DER encoding\n}\n\nmodule.exports = {\n  getAddress,\n  fetchUtxos,\n  pushTx,\n  waitForPayment,\n  createFinalTx,\n  MINIMUM_AMOUNT,\n  ATOMS_PER_BTC\n}"
    }
  ]
}