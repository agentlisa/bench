{
  "Title": "[M-08] collectLiquidity() Lack of can specify recipient leads to inability to retrieve token1 after entering the blacklist of token0",
  "Content": "\n`LP` has only one way to retrieve `token`, first `decreaseLiquidity()`, then retrieve through the `collectLiquidity()` method.\n\n`collectLiquidity()` only has one parameter, `tokenId`.\n\n```solidity\n    function collectLiquidity(\n        uint256 tokenId\n    ) external override nonReentrant returns (uint256 amount0Collected, uint256 amount1Collected) {\n        (amount0Collected, amount1Collected) = lps.collectLiquidity(tokenId);\n    }\n```\n\nSo `LP` can only transfer the retrieved `token` to himself: `msg.sender`.\n\nThis leads to a problem. If `LP` enters the blacklist of a certain `token`, such as the `USDC` blacklist,\n\nBecause the recipient cannot be specified (`lps[]` cannot be transferred), this will cause another `token` not to be retrieved, such as `WETH`.\n\nRefer to `NonfungiblePositionManager.collect()` and `UniswapV3Pool.collect()`, both can specify `recipient` to avoid this problem.\n\n### Impact\n\n`collectLiquidity()` cannot specify the recipient, causing `LP` to enter the blacklist of a certain token, and both tokens cannot be retrieved.\n\n### Recommended Mitigation\n\n```diff\n    function collectLiquidity(\n        uint256 tokenId,\n+      address recipient\n    ) external override nonReentrant returns (uint256 amount0Collected, uint256 amount1Collected) {\n...\n```\n\n**[wukong-particle (Particle) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/36#issuecomment-1868216251):**\n > Good suggestion, recipient should be added here too: https://github.com/code-423n4/2023-12-particle/blob/main/contracts/libraries/LiquidityPosition.sol#L329 \n\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/36#issuecomment-1868382997):**\n > I would argue this is good design and should not be changed to allow for arbitrary recipients. If a token is blacklisted, and a protocol allows the user to circumvent this blacklist, then they may potentially be liable for the behaviour of this individual. Better to take an agnostic approach and leave it as is unless liquidations are ultimately being limited because of this.\n\n**[wukong-particle (Particle) acknowledged and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/36#issuecomment-1868471782):**\n > I agree with the judge. We shouldn't facilitate to temper the blacklist. So only acknowledging the issue.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/libraries/LiquidityPosition.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {DataStruct} from \"./Structs.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {Base} from \"./Base.sol\";\n\n/// @title Liquidity Position\n/// @notice Represents a liquidity position's underlying owner and fee tokens accrued from lending\nlibrary LiquidityPosition {\n    struct Info {\n        address owner;\n        uint32 renewalCutoffTime; ///@dev loans before this time can't be renewed\n        uint128 token0Owed;\n        uint128 token1Owed;\n    }\n\n    event SupplyLiquidity(uint256 tokenId, address lp, uint128 liquidity);\n    event IncreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event DecreaseLiquidity(uint256 tokenId, uint128 liquidity);\n    event CollectLiquidity(address lp, address token0, address token1, uint256 amount0, uint256 amount1);\n\n    /*=============================================================\n                               Info Logic\n    ==============================================================*/\n\n    /**\n     * @notice Getter for a liquidity position's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return renewalCutoffTime renewal cutoff time for all previous loans\n     */\n    function getRenewalCutoffTime(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint32 renewalCutoffTime) {\n        renewalCutoffTime = self[tokenId].renewalCutoffTime;\n    }\n\n    /**\n     * @notice Getter for a liquidity position's tokens currently owed to owner\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @return token0Owed The amount of token0 owed to the owner\n     * @return token1Owed The amount of token1 owed to the owner\n     */\n    function getTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal view returns (uint128 token0Owed, uint128 token1Owed) {\n        Info memory info = self[tokenId];\n        token0Owed = info.token0Owed;\n        token1Owed = info.token1Owed;\n    }\n\n    /*=============================================================\n                            Tokens Owed Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's owed tokens\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     * @param token0Owed The amount of token0 owed to the owner to be added\n     * @param token1Owed The amount of token1 owed to the owner to be added\n     */\n    function addTokensOwed(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 token0Owed,\n        uint128 token1Owed\n    ) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed += token0Owed;\n        info.token1Owed += token1Owed;\n    }\n\n    /**\n     * @notice Reset a liquidity positon's owed tokens to 0\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function resetTokensOwed(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.token0Owed = 0;\n        info.token1Owed = 0;\n    }\n\n    /*=============================================================\n                           Renewal Time Logic\n    ==============================================================*/\n\n    /**\n     * @notice Update a liquidity positon's renewal cutoff time\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId The token id of the liquidity position NFT\n     */\n    function updateRenewalCutoffTime(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        Info storage info = self[tokenId];\n        info.renewalCutoffTime = uint32(block.timestamp);\n    }\n\n    /*=============================================================\n                               Mint Logic\n    ==============================================================*/\n\n    /**\n     * @notice Supply liquidity to mint position NFT to the contract\n     * @param self The mapping containing all liquidity positions\n     * @param params mint parameters containing token pairs, fee, tick info and amount to mint\n     * @return tokenId newly minted tokenId\n     * @return liquidity amount of liquidity minted\n     * @return amount0Minted amount of token 0 minted\n     * @return amount1Minted amount of token 1 minted\n     */\n\n    function mint(\n        mapping(uint256 => Info) storage self,\n        DataStruct.MintParams calldata params\n    ) internal returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted) {\n        // transfer in the tokens\n        TransferHelper.safeTransferFrom(params.token0, msg.sender, address(this), params.amount0ToMint);\n        TransferHelper.safeTransferFrom(params.token1, msg.sender, address(this), params.amount1ToMint);\n\n        // approve position manager to spend the tokens\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, params.amount0ToMint);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, params.amount1ToMint);\n\n        // mint the position\n        (tokenId, liquidity, amount0Minted, amount1Minted) = Base.UNI_POSITION_MANAGER.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: params.token0,\n                token1: params.token1,\n                fee: params.fee,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: params.amount0ToMint,\n                amount1Desired: params.amount1ToMint,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        // create the LP position\n        self[tokenId] = LiquidityPosition.Info({owner: msg.sender, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n\n        // reset the approval\n        TransferHelper.safeApprove(params.token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(params.token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n\n        // refund if necessary\n        Base.refund(msg.sender, params.token0, params.amount0ToMint, amount0Minted);\n        Base.refund(msg.sender, params.token1, params.amount1ToMint, amount1Minted);\n\n        emit SupplyLiquidity(tokenId, msg.sender, liquidity);\n    }\n\n    /*=============================================================\n                        Increase Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Increase liquidity to a liquidity position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param token0 The address of token0\n     * @param token1 The address of token1\n     * @param tokenId The token id of the liquidity position NFT\n     * @param amount0 The amount of token0 to add to the liquidity position\n     * @param amount1 The amount of token1 to add to the liquidity position\n     * @return liquidity The amount of liquidity added\n     * @return amount0Added The amount of token0 added\n     * @return amount1Added The amount of token1 added\n     */\n    function increaseLiquidity(\n        address token0,\n        address token1,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        // approve spending for uniswap's position manager\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, amount0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, amount1);\n\n        // increase liquidity via position manager\n        (liquidity, amount0Added, amount1Added) = Base.UNI_POSITION_MANAGER.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: tokenId,\n                amount0Desired: amount0,\n                amount1Desired: amount1,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        // reset approval\n        TransferHelper.safeApprove(token0, Base.UNI_POSITION_MANAGER_ADDR, 0);\n        TransferHelper.safeApprove(token1, Base.UNI_POSITION_MANAGER_ADDR, 0);\n    }\n\n    /**\n     * @notice Increase liquidity of a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0 amount to add for token 0\n     * @param amount1 amount to add for token 1\n     * @return liquidity amount of liquidity added\n     * @return amount0Added amount of token 0 added\n     * @return amount1Added amount of token 1 added\n     */\n    function increaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n\n        // get token0 and token1 from the position NFT\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n\n        // transfer in liquidity to add\n        TransferHelper.safeTransferFrom(token0, msg.sender, address(this), amount0);\n        TransferHelper.safeTransferFrom(token1, msg.sender, address(this), amount1);\n\n        // add liquidity\n        (liquidity, amount0Added, amount1Added) = increaseLiquidity(token0, token1, tokenId, amount0, amount1);\n\n        // refund if necessary\n        Base.refund(msg.sender, token0, amount0, amount0Added);\n        Base.refund(msg.sender, token1, amount1, amount1Added);\n\n        emit IncreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Decrease Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Decrease liquidity from an existing position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount to decrease\n     * @return amount0 amount decreased for token0\n     * @return amount1 amount decreased for token1\n     */\n    function decreaseLiquidity(uint256 tokenId, uint128 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n    }\n\n    /**\n     * @notice Decrease liquidity from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to add\n     * @return amount0Decreased amount of token 0 decreased\n     * @return amount1Decreased amount of token 1 decreased\n     */\n    function decreaseLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId,\n        uint128 liquidity\n    ) internal returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Decreased, amount1Decreased) = decreaseLiquidity(tokenId, liquidity);\n        emit DecreaseLiquidity(tokenId, liquidity);\n    }\n\n    /*=============================================================\n                        Collect Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice Collect fees from a position\n     * @dev Caller must check for authorization and non-reentrancy\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param amount0Max maximum amount of token0 to collect\n     * @param amount1Max maximum amount of token1 to collect\n     * @param recipient the address to collect the liquidity\n     * @return amount0 amount collected for token0\n     * @return amount1 amount collected for token1\n     */\n    function collectLiquidity(\n        uint256 tokenId,\n        uint128 amount0Max,\n        uint128 amount1Max,\n        address recipient\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.UNI_POSITION_MANAGER.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: recipient,\n                amount0Max: amount0Max,\n                amount1Max: amount1Max\n            })\n        );\n    }\n\n    /**\n     * @notice Collect fees from a position\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     * @return amount0Collected amount of fees collected in token 0\n     * @return amount1Collected amount of fees collected in token 1\n     */\n    function collectLiquidity(\n        mapping(uint256 => Info) storage self,\n        uint256 tokenId\n    ) internal returns (uint256 amount0Collected, uint256 amount1Collected) {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        (amount0Collected, amount1Collected) = LiquidityPosition.collectLiquidity(\n            tokenId,\n            type(uint128).max,\n            type(uint128).max,\n            msg.sender\n        );\n        (uint128 token0Owed, uint128 token1Owed) = getTokensOwed(self, tokenId);\n        resetTokensOwed(self, tokenId);\n        (, , address token0, address token1, , , , , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n        if (token0Owed > 0) {\n            amount0Collected += token0Owed;\n            TransferHelper.safeTransfer(token0, msg.sender, token0Owed);\n        }\n        if (token1Owed > 0) {\n            amount1Collected += token1Owed;\n            TransferHelper.safeTransfer(token1, msg.sender, token1Owed);\n        }\n\n        emit CollectLiquidity(msg.sender, token0, token1, amount0Collected, amount1Collected);\n    }\n\n    /*=============================================================\n                         Reclaim Liquidity Logic\n    ==============================================================*/\n\n    /**\n     * @notice LP reclaims borrowed liquidity from being renewed\n     * @param self The mapping containing all liquidity positions\n     * @param tokenId tokenId of the liquidity position NFT\n     */\n    function reclaimLiquidity(mapping(uint256 => Info) storage self, uint256 tokenId) internal {\n        if (self[tokenId].owner != msg.sender) revert Errors.Unauthorized();\n        updateRenewalCutoffTime(self, tokenId);\n    }\n}"
    }
  ]
}