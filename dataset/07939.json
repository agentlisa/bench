{
  "Title": "[G‑14] Division by two should use bit shifting",
  "Content": "\n`<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/core/contracts/libraries/AdaptiveFee.sol\n\n88:       res += (xLowestDegree * gHighestDegree) / 2;\n\n```\n\n<https://github.com/code-423n4/2022-09-quickswap/blob/15ea643c85ed936a92d2676a7aabf739b210af39/src/core/contracts/libraries/AdaptiveFee.sol#L88>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-09-quickswap",
  "Code": [
    {
      "filename": "src/core/contracts/libraries/AdaptiveFee.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.7.6;\n\nimport './Constants.sol';\n\n/// @title AdaptiveFee\n/// @notice Calculates fee based on combination of sigmoids\nlibrary AdaptiveFee {\n  // alpha1 + alpha2 + baseFee must be <= type(uint16).max\n  struct Configuration {\n    uint16 alpha1; // max value of the first sigmoid\n    uint16 alpha2; // max value of the second sigmoid\n    uint32 beta1; // shift along the x-axis for the first sigmoid\n    uint32 beta2; // shift along the x-axis for the second sigmoid\n    uint16 gamma1; // horizontal stretch factor for the first sigmoid\n    uint16 gamma2; // horizontal stretch factor for the second sigmoid\n    uint32 volumeBeta; // shift along the x-axis for the outer volume-sigmoid\n    uint16 volumeGamma; // horizontal stretch factor the outer volume-sigmoid\n    uint16 baseFee; // minimum possible fee\n  }\n\n  /// @notice Calculates fee based on formula:\n  /// baseFee + sigmoidVolume(sigmoid1(volatility, volumePerLiquidity) + sigmoid2(volatility, volumePerLiquidity))\n  /// maximum value capped by baseFee + alpha1 + alpha2\n  function getFee(\n    uint88 volatility,\n    uint256 volumePerLiquidity,\n    Configuration memory config\n  ) internal pure returns (uint16 fee) {\n    uint256 sumOfSigmoids = sigmoid(volatility, config.gamma1, config.alpha1, config.beta1) +\n      sigmoid(volatility, config.gamma2, config.alpha2, config.beta2);\n\n    if (sumOfSigmoids > type(uint16).max) {\n      // should be impossible, just in case\n      sumOfSigmoids = type(uint16).max;\n    }\n\n    return uint16(config.baseFee + sigmoid(volumePerLiquidity, config.volumeGamma, uint16(sumOfSigmoids), config.volumeBeta)); // safe since alpha1 + alpha2 + baseFee _must_ be <= type(uint16).max\n  }\n\n  /// @notice calculates α / (1 + e^( (β-x) / γ))\n  /// that is a sigmoid with a maximum value of α, x-shifted by β, and stretched by γ\n  /// @dev returns uint256 for fuzzy testing. Guaranteed that the result is not greater than alpha\n  function sigmoid(\n    uint256 x,\n    uint16 g,\n    uint16 alpha,\n    uint256 beta\n  ) internal pure returns (uint256 res) {\n    if (x > beta) {\n      x = x - beta;\n      if (x >= 6 * uint256(g)) return alpha; // so x < 19 bits\n      uint256 g8 = uint256(g)**8; // < 128 bits (8*16)\n      uint256 ex = exp(x, g, g8); // < 155 bits\n      res = (alpha * ex) / (g8 + ex); // in worst case: (16 + 155 bits) / 155 bits\n      // so res <= alpha\n    } else {\n      x = beta - x;\n      if (x >= 6 * uint256(g)) return 0; // so x < 19 bits\n      uint256 g8 = uint256(g)**8; // < 128 bits (8*16)\n      uint256 ex = g8 + exp(x, g, g8); // < 156 bits\n      res = (alpha * g8) / ex; // in worst case: (16 + 128 bits) / 156 bits\n      // g8 <= ex, so res <= alpha\n    }\n  }\n\n  /// @notice calculates e^(x/g) * g^8 in a series, since (around zero):\n  /// e^x = 1 + x + x^2/2 + ... + x^n/n! + ...\n  /// e^(x/g) = 1 + x/g + x^2/(2*g^2) + ... + x^(n)/(g^n * n!) + ...\n  function exp(\n    uint256 x,\n    uint16 g,\n    uint256 gHighestDegree\n  ) internal pure returns (uint256 res) {\n    // calculating:\n    // g**8 + x * g**7 + (x**2 * g**6) / 2 + (x**3 * g**5) / 6 + (x**4 * g**4) / 24 + (x**5 * g**3) / 120 + (x**6 * g^2) / 720 + x**7 * g / 5040 + x**8 / 40320\n\n    // x**8 < 152 bits (19*8) and g**8 < 128 bits (8*16)\n    // so each summand < 152 bits and res < 155 bits\n    uint256 xLowestDegree = x;\n    res = gHighestDegree; // g**8\n\n    gHighestDegree /= g; // g**7\n    res += xLowestDegree * gHighestDegree;\n\n    gHighestDegree /= g; // g**6\n    xLowestDegree *= x; // x**2\n    res += (xLowestDegree * gHighestDegree) / 2;\n\n    gHighestDegree /= g; // g**5\n    xLowestDegree *= x; // x**3\n    res += (xLowestDegree * gHighestDegree) / 6;\n\n    gHighestDegree /= g; // g**4\n    xLowestDegree *= x; // x**4\n    res += (xLowestDegree * gHighestDegree) / 24;\n\n    gHighestDegree /= g; // g**3\n    xLowestDegree *= x; // x**5\n    res += (xLowestDegree * gHighestDegree) / 120;\n\n    gHighestDegree /= g; // g**2\n    xLowestDegree *= x; // x**6\n    res += (xLowestDegree * gHighestDegree) / 720;\n\n    xLowestDegree *= x; // x**7\n    res += (xLowestDegree * g) / 5040 + (xLowestDegree * x) / (40320);\n  }\n}"
    }
  ]
}