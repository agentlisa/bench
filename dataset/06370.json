{
  "Title": "[M-14] No check for Individual mint amount surpassing 10% when the circulation reaches 10\\_000\\_000 in `mint()` of `LybraEUSDVaultBase` contract",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L124> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L126>\n\n### Impact\n\nThe mint functions in `LybraEUSDVaultBase` have no checks for when the supplied amount to mint is more than 10% if circulation reaches 10,000,000, as specified in the comments explaining the logic of the function.\n\n### Proof of Concept\n\nLets have a look at `mint()` code in the `LybraEUSDVaultBase` contract:\n\n        /**\n         * @notice The mint amount number of EUSD is minted to the address\n         * Emits a `Mint` event.\n         *\n         * Requirements:\n         * - `onBehalfOf` cannot be the zero address.\n         * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation \n              reaches 10_000_000\n         */\n        function mint(address onBehalfOf, uint256 amount) external {\n            require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n            require(amount > 0, \"ZERO_MINT\");\n            _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n        }\n\n        function _mintEUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n            require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n            try configurator.refreshMintReward(_provider) {} catch {}\n            borrowed[_provider] += _mintAmount;\n\n            EUSD.mint(_onBehalfOf, _mintAmount);\n            _saveReport();\n            poolTotalEUSDCirculation += _mintAmount;\n            _checkHealth(_provider, _assetPrice);\n            emit Mint(msg.sender, _onBehalfOf, _mintAmount, block.timestamp);\n        }\n\nFrom the code above, we can see there is no check prevent mint amount from being greater than 10% of 10,000,000 or more if the `poolTotalEUSDCirculation` is 10,000,000 or more as specified in the comments.\n\n### Tools Used\n\nVS CODE\n\n### Recommended Mitigation Steps\n\nAdd checks to the `mint()` to revert if mint amount is greater than 10% of the total supply, if total supply is >= 10,000,000.\n\n        function mint(address onBehalfOf, uint256 amount) external {\n            require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n            require(amount > 0, \"ZERO_MINT\");\n\n            if ( poolTotalEUSDCirculation >= 10_000_000 ) {\n             require(amount <= (10 * poolTotalEUSDCirculation) / 100, 'amount greater than 10% of circulation' );\n            }\n            _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n        }\n\n### Assessed type\n\nError\n\n**[LybraFinance acknowledged](https://github.com/code-423n4/2023-06-lybra-findings/issues/392#issuecomment-1635590843)**\n\n**[0xean (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/392#issuecomment-1650724520):**\n > @LybraFinance - this appears to be more of a M severity issue as it doesn't directly lead to assets being lost or stolen.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/pools/base/LybraEUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/IEUSD.sol\";\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface LbrStakingPool {\n    function notifyRewardAmount(uint256 amount) external;\n}\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraEUSDVaultBase {\n    IEUSD public immutable EUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public immutable badCollateralRatio = 150 * 1e18;\n    IPriceFeed immutable etherOracle;\n\n    uint256 public totalDepositedAsset;\n    uint256 public lastReportTime;\n    uint256 public poolTotalEUSDCirculation;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    uint8 immutable vaultType = 0;\n    uint256 public feeStored;\n    mapping(address => uint256) depositedTime;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n\n    event WithdrawAsset(address sponsor, address asset, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 liquidateEtherAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n    event LSDValueCaptured(uint256 stETHAdded, uint256 payoutEUSD, uint256 discountRate, uint256 timestamp);\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 eusdAmount, uint256 collateralAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _collateralAsset, address _etherOracle, address _configurator) {\n        collateralAsset = IERC20(_collateralAsset);\n        configurator = Iconfigurator(_configurator);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    /**\n     * @notice Allowing direct deposits of ETH, the pool may convert it into the corresponding collateral during the implementation.\n     * While depositing, it is possible to simultaneously mint eUSD for oneself.\n     * Emits a `DepositEther` event.\n     *\n     * Requirements:\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     * - msg.value Must be higher than 0.\n     */\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit collateral and allow minting eUSD for oneself.\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint EUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 stETH.\");\n\n        bool success = collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(success, \"TF\");\n\n        totalDepositedAsset += assetAmount;\n        depositedAsset[msg.sender] += assetAmount;\n        depositedTime[msg.sender] = block.timestamp;\n\n        if (mintAmount > 0) {\n            _mintEUSD(msg.sender, msg.sender, mintAmount, getAssetPrice());\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawEther` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check userâ€™s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZERO_WITHDRAW\");\n        require(depositedAsset[msg.sender] >= amount, \"Withdraw amount exceeds deposited amount.\");\n        totalDepositedAsset -= amount;\n        depositedAsset[msg.sender] -= amount;\n\n        uint256 withdrawal = checkWithdrawal(msg.sender, amount);\n\n        collateralAsset.transfer(onBehalfOf, withdrawal);\n        if (borrowed[msg.sender] > 0) {\n            _checkHealth(msg.sender, getAssetPrice());\n        }\n        emit WithdrawAsset(msg.sender, address(collateralAsset), onBehalfOf, withdrawal, block.timestamp);\n    }\n\n    function checkWithdrawal(address user, uint256 amount) internal view returns (uint256 withdrawal) {\n        withdrawal = block.timestamp - 3 days >= depositedTime[user] ? amount : (amount * 999) / 1000;\n    }\n\n    /**\n     * @notice The mint amount number of EUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n        require(amount > 0, \"ZERO_MINT\");\n        _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of EUSD and payback the amount of minted EUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external {\n        require(onBehalfOf != address(0), \"BURN_TO_THE_ZERO_ADDRESS\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using EUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - collateralAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize EUSD\n     * @dev After liquidation, borrower's debt is reduced by collateralAmount * etherPrice, collateral is reduced by the collateralAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < badCollateralRatio, \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(EUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, eusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        totalDepositedAsset -= reducedAsset;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is below badCollateralRatio, borrowers with collateralRatio below 125% could be fully liquidated.\n     * Emits a `LiquidationRecord` event.\n     *\n     * Requirements:\n     * - Current overallCollateralRatio should be below badCollateralRatio\n     * - `onBehalfOf`collateralRatio should be below 125%\n     * @dev After Liquidation, borrower's debt is reduced by collateralAmount * etherPrice, deposit is reduced by collateralAmount * borrower's collateralRatio. Keeper gets a liquidation reward of `keeperRatio / borrower's collateralRatio\n     */\n    function superLiquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        require((totalDepositedAsset * assetPrice * 100) / poolTotalEUSDCirculation < badCollateralRatio, \"overallCollateralRatio should below 150%\");\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / borrowed[onBehalfOf];\n        require(onBehalfOfCollateralRatio < 125 * 1e18, \"borrowers collateralRatio should below 125%\");\n        require(assetAmount <= depositedAsset[onBehalfOf], \"total of collateral can be liquidated at most\");\n        uint256 eusdAmount = (assetAmount * assetPrice) / 1e18;\n        if (onBehalfOfCollateralRatio >= 1e20) {\n            eusdAmount = (eusdAmount * 1e20) / onBehalfOfCollateralRatio;\n        }\n        require(EUSD.allowance(provider, address(this)) >= eusdAmount, \"provider should authorize to provide liquidation EUSD\");\n\n        _repay(provider, onBehalfOf, eusdAmount);\n\n        totalDepositedAsset -= assetAmount;\n        depositedAsset[onBehalfOf] -= assetAmount;\n        uint256 reward2keeper;\n        if (msg.sender != provider && onBehalfOfCollateralRatio >= 1e20 + configurator.vaultKeeperRatio(address(this)) * 1e18) {\n            reward2keeper = ((assetAmount * configurator.vaultKeeperRatio(address(this))) * 1e18) / onBehalfOfCollateralRatio;\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        collateralAsset.transfer(provider, assetAmount - reward2keeper);\n\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, eusdAmount, assetAmount, reward2keeper, true, block.timestamp);\n    }\n\n    /**\n     * @notice When stETH balance increases through LSD or other reasons, the excess income is sold for EUSD, allocated to EUSD holders through rebase mechanism.\n     * Emits a `LSDistribution` event.\n     *\n     * *Requirements:\n     * - stETH balance in the contract cannot be less than totalDepositedAsset after exchange.\n     * @dev Income is used to cover accumulated Service Fee first.\n     */\n    function excessIncomeDistribution(uint256 payAmount) external virtual;\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `eusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`eusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 eusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= eusdAmount, \"eusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, eusdAmount);\n        uint256 collateralAmount = (((eusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        totalDepositedAsset -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, eusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Mints eUSD tokens for a user.\n     * @param _provider The provider's address.\n     * @param _onBehalfOf The user's address.\n     * @param _mintAmount The amount of eUSD tokens to be minted.\n     * @param _assetPrice The current collateral asset price.\n     * @dev Mints eUSD tokens for the specified user, updates the total supply and borrowed balance,\n     * refreshes the mint reward for the provider, checks the health of the provider,\n     * and emits a Mint event.\n     * Requirements:\n     * The total supply plus mint amount must not exceed the maximum supply allowed for the vault.\n     * The provider must have sufficient borrowing capacity to mint the specified amount.\n     */\n    function _mintEUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalEUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        try configurator.refreshMintReward(_provider) {} catch {}\n        borrowed[_provider] += _mintAmount;\n\n        EUSD.mint(_onBehalfOf, _mintAmount);\n        _saveReport();\n        poolTotalEUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(msg.sender, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount EUSD to payback minted EUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalEUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        uint256 amount = borrowed[_onBehalfOf] >= _amount ? _amount : borrowed[_onBehalfOf];\n\n        EUSD.burn(_provider, amount);\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n\n        borrowed[_onBehalfOf] -= amount;\n        _saveReport();\n        poolTotalEUSDCirculation -= amount;\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address _user, uint256 _assetPrice) internal view {\n        if (((depositedAsset[_user] * _assetPrice * 100) / borrowed[_user]) < configurator.getSafeCollateralRatio(address(this))) revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _saveReport() internal {\n        feeStored += _newFee();\n        lastReportTime = block.timestamp;\n    }\n\n    function _newFee() internal view returns (uint256) {\n        return (poolTotalEUSDCirculation * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - lastReportTime)) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    function getBorrowedOf(address user) external view returns (uint256) {\n        return borrowed[user];\n    }\n\n    function getPoolTotalEUSDCirculation() external view returns (uint256) {\n        return poolTotalEUSDCirculation;\n    }\n\n    function getAsset() external view virtual returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    }
  ]
}