{
  "Title": "Math library is vulnerable to shadow overflow",
  "Content": "The [`AuxMath`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/AuxMath.sol) library is a custom auxiliary math library that performs multiplication and division with rounding specifications.\n\n\nThe implementation of [`mulDivUp`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/AuxMath.sol#L24-L32) and [`mulDivDown`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/AuxMath.sol#L15-L23) first compute the multiplication of a `uint256` with a `uint256` without taking into account the possibility of an overflow in the product. The product could overflow into a `uint512` in the multiplication step even if the result were to fit into a `uint256` after the subsequent division. Hence the [current implementation](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/AuxMath.sol#L21) will not give the right result in such a case.\n\n\nConsider using OpenZeppelin’s [Math library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol) which implements the [`mulDiv` function](https://xn--2-umb.com/21/muldiv/) that is developed especially considering these scenarios and is widely accepted in the ecosystem.\n\n\n**Update:** *Fixed in commit [2a8c58a](https://github.com/pods-finance/yield-contracts/commit/2a8c58a081f471fd31cffaed1c4cddde9856fc56).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libs/AuxMath.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nlibrary AuxMath {\n    using AuxMath for uint256;\n\n    error AuxMath__DivByZero();\n\n    struct Fractional {\n        uint256 numerator;\n        uint256 denominator;\n    }\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256) {\n        if (denominator == 0) revert AuxMath__DivByZero();\n        return (x * y) / denominator;\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256) {\n        if (denominator == 0) revert AuxMath__DivByZero();\n        uint256 numerator = x * y;\n        return numerator / denominator + (numerator % denominator > 0 ? 1 : 0);\n    }\n\n    function mulDivUp(uint256 x, Fractional memory y) internal pure returns (uint256) {\n        return x.mulDivUp(y.numerator, y.denominator);\n    }\n\n    function mulDivDown(uint256 x, Fractional memory y) internal pure returns (uint256) {\n        return x.mulDivDown(y.numerator, y.denominator);\n    }\n\n    function mulDivUp(Fractional memory x, uint256 y) internal pure returns (uint256) {\n        return x.numerator.mulDivUp(y, x.denominator);\n    }\n\n    function mulDivDown(Fractional memory x, uint256 y) internal pure returns (uint256) {\n        return x.numerator.mulDivDown(y, x.denominator);\n    }\n\n    function fractionRoundUp(Fractional memory x) internal pure returns (uint256) {\n        return x.numerator.mulDivUp(1, x.denominator);\n    }\n\n    function fractionRoundDown(Fractional memory x) internal pure returns (uint256) {\n        return x.numerator.mulDivDown(1, x.denominator);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x < y ? x : y;\n    }\n}"
    }
  ]
}