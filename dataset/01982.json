{
  "Title": "M-10: Issue 94 from previous contest has not been fixed",
  "Content": "# Issue M-10: Issue 94 from previous contest has not been fixed \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118 \n\n## Found by \n0x52, Bauchibred, cducrest-brainbot, deadrxsezzz, helpMePlease, kaysoft, peanuts, tsvetanovv\n## Summary\n\n[Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94) still exists exactly even though it was marked as \"will fix\".\n\n## Vulnerability Detail\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Impact\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n## Code Snippet\n\n[ChainlinkAdapterOracle.sol#L77-L97](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L77-L97)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSee [Issue 94](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\n/**\n * @author BlueberryProtocol\n * @title ChainlinkAdapterOracle\n * @notice Oracle Adapter contract which provides price feeds from Chainlink\n */\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    // Chainlink denominations\n    // (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    address public constant USD = address(840);\n\n    /// @dev Mapping from original token to remapped token for price querying (e.g. WBTC -> BTC, WETH -> ETH)\n    mapping(address => address) public remappedTokens;\n\n    event SetRegistry(address registry);\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /// @notice Set chainlink feed registry source\n    /// @param registry_ Chainlink feed registry source\n    function setFeedRegistry(IFeedRegistry registry_) external onlyOwner {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n        registry = registry_;\n        emit SetRegistry(address(registry_));\n    }\n\n    /// @notice Set token remapping\n    /// @param tokens_ List of tokens to set remapping\n    /// @param remappedTokens_ List of tokens to set remapping to\n    function setTokenRemappings(\n        address[] calldata tokens_,\n        address[] calldata remappedTokens_\n    ) external onlyOwner {\n        if (remappedTokens_.length != tokens_.length)\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens_.length; idx++) {\n            if (tokens_[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n\n            remappedTokens[tokens_[idx]] = remappedTokens_[idx];\n            emit SetTokenRemapping(tokens_[idx], remappedTokens_[idx]);\n        }\n    }\n\n    /**\n     * @notice Returns the USD price of given token, price value has 18 decimals\n     * @param token_ Token address to get price of\n     * @return price USD price of token in 18 decimal\n     */\n    function getPrice(address token_) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[token_];\n        if (token == address(0)) token = token_;\n\n        uint256 maxDelayTime = timeGaps[token];\n        if (maxDelayTime == 0) revert Errors.NO_MAX_DELAY(token_);\n\n        // Get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert Errors.PRICE_OUTDATED(token_);\n        if (answer <= 0) revert Errors.PRICE_NEGATIVE(token_);\n\n        return\n            (answer.toUint256() * Constants.PRICE_PRECISION) / 10 ** decimals;\n    }\n}"
    }
  ]
}