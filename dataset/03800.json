{
  "Title": "[H03] Users can add non-existent ERC20 tokens into the promotion reserve",
  "Content": "The [`Holdefi` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol) implements most of the functionalities of the Holdefi’s protocol, such as [the supply of assets](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L160-L181) into the system, [add collateral](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L234-L258), and to [borrow other assets](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L298) based on the collateral power that the account has, among others.\n\n\nIn particular, [the `depositPromotionReserve` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L741), allows any account to deposit ERC20 token assets into [the promotion reserve](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L57) for a particular market.\n\n\nThe problem is that [the `depositPromotionReserve` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L741) does not check whether the market that the caller is trying to interact with is actually whitelisted by checking [the `isActive` flag](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L43) which enables the possibility to pass any address (except the zero address) as a possible market.\n\n\nHere, an attacker could create a new contract that implements a simple `transferFrom` function that always returns `true`, so [the requirement that checks the output of the real `transferFrom` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L746) can be bypassed. By doing this, the attacker would be calling [the `depositPromotionReserveInternal` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L715) with a fake market address and number of tokens.\n\n\nThis last function will later call several other functions from the same and other contracts, such as [the `getCurrentPromotion` function](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L525) and [the `getInterests` function from the `HoldefiSettings` contract](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L100), but because the code also abuses the default zero values in several parts, all checks will be bypassed, including the protections that the usage of [the `SafeMath` library](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/SafeMath.sol) provides, ending up in [writing in storage](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/Holdefi.sol#L733-L737) not only a fake deposited value of the particular ERC20 token market but also it will update the timestamp from when the inexistent assets were deposited, emulating the behavior of a real ERC20 token.\n\n\nConsider restricting the call to the whitelisted markets by using the already implemented [`isActive` flag](https://github.com/holdefi/Holdefi/blob/f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/contracts/HoldefiSettings.sol#L43), and restricting who is able to deposit ERC20 assets into the promotion reserve.\n\n\n**Update**: *Not fixed. Holdefi’s statement for this issue:*\n\n\n\n> You have 2 suggestions for this issue: 1-implementing isActive flag 2-restricting who is able to deposit ERC20 assets first suggestion is good and we will implement it. But restricting users to deposit into promotion reserve will not change anything. Users can deposit their assets into promotion reserve and it’s good for us. Also updating indexes is not bad for the protocol.\n> \n> \n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Holdefi.sol",
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./HoldefiPauser.sol\";\r\n\r\n//"
    },
    {
      "filename": "contracts/HoldefiPrices.sol",
      "content": "interface HoldefiPricesInterface {\r\n\tfunction getPrice(address token) external view returns(uint price);\t\r\n}\r\n\r\n//"
    },
    {
      "filename": "contracts/HoldefiSettings.sol",
      "content": "interface HoldefiSettingsInterface {\r\n\tfunction getInterests(address market, uint totalSupply, uint totalBorrow) external view returns(uint borrowRate, uint supplyRate);\r\n\tfunction getMarket(address market) external view returns(bool isActive);\r\n\tfunction getCollateral(address collateral) external view returns(bool isActive, uint valueToLoanRate, uint penaltyRate, uint bonusRate);\r\n\tfunction getMarketsList() external view returns(address[] memory marketsList);\r\n}\r\n\r\n//"
    },
    {
      "filename": "contracts/CollateralsWallet.sol",
      "content": "interface CollateralsWalletInterface {\r\n\tfunction withdraw(address collateral, address payable recipient, uint amount) external;\r\n}\r\n\r\ninterface ERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns(bool success);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool success);\r\n}\r\n\r\n\r\n\r\n // Main Holdefi contract.\r\n // The address of ETH asset considered as 0x00 in this contract.\r\ncontract Holdefi is HoldefiPauser {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\t// All rates in this contract are scaled by ratesDecimal.\r\n\tuint constant public ratesDecimal = 10 ** 4;\r\n\r\n\t// All Indexes in this contract are scaled by (secondsPerYear * ratesDecimal) \r\n\tuint constant public secondsPerYear = 31536000;\r\n\r\n\tuint constant public maxPromotionRate = 3000;\r\n\r\n\t// Markets are assets that can be supplied and borrowed\r\n\tstruct Market {\r\n\t\tuint totalSupply;\r\n\t\tuint supplyIndex;      //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint supplyIndexUpdateTime;\r\n\r\n\t\tuint totalBorrow;\r\n\t\tuint borrowIndex;      //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint borrowIndexUpdateTime;\r\n\r\n\t\tuint promotionRate;\r\n\t\tuint promotionReserveScaled; //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint promotionReserveLastUpdateTime;\r\n\t\tuint promotionDebtScaled;    //Scaled by: secondsPerYear * ratesDecimal\r\n\t\tuint promotionDebtLastUpdateTime;\r\n\t}\r\n\r\n\t// Collaterals are assets that can be use only as collateral (no interest)\r\n\tstruct Collateral {\r\n\t\tuint totalCollateral;\r\n\t\tuint totalLiquidatedCollateral;\r\n\t}\r\n\r\n\t// Users profile for each market\r\n\tstruct MarketAccount {\r\n\t\tuint balance;\r\n\t\tuint accumulatedInterest; \r\n\t\tuint lastInterestIndex; //Scaled by: secondsPerYear * ratesDecimal\r\n\t}\r\n\t// Users profile for each collateral\r\n\tstruct CollateralAccount {\r\n\t\tuint balance;\r\n\t\tuint lastUpdateTime;\r\n\t}\r\n\r\n\t// Markets: marketAddress => Market\r\n\tmapping (address => Market) public marketAssets;\r\n\r\n\t// Collaterals: collateralAddress => Collateral\r\n\tmapping (address => Collateral) public collateralAssets;\r\n\r\n\t// Users Supplies: userAddress => marketAddress => supplyDetails\r\n\tmapping (address => mapping (address => MarketAccount)) private supplies;\r\n\r\n\t// Users Borrows: userAddress => collateralAddress => marketAddress => borrowDetails \r\n\tmapping (address => mapping (address => mapping (address => MarketAccount))) private borrows;\r\n\r\n\t// Users Collaterals: userAddress => collateralAddress => collateralDetails \r\n\tmapping (address => mapping (address => CollateralAccount)) private collaterals;\r\n\t\r\n\t// Markets Debt after liquidation: collateralAddress => marketAddress => marketDebtBalance \r\n\tmapping (address => mapping (address => uint)) public marketDebt;\r\n\r\n\r\n\t// Contract for getting markets supply rate and borrow rate \r\n\tHoldefiSettingsInterface public holdefiSettings;\r\n\r\n\t// Contract for getting token price \r\n\tHoldefiPricesInterface public holdefiPrices;\r\n\r\n\t// Wallet Contract for Collaterals \r\n\tCollateralsWalletInterface public holdefiCollaterals;\r\n\r\n\t// Price contract can be unchangeable\r\n\tbool public fixPrices = false;\r\n\r\n\t// ----------- Events -----------\r\n\r\n\tevent Supply(address supplier, address market, uint amount);\r\n\r\n\tevent WithdrawSupply(address supplier, address market, uint amount);\r\n\r\n\tevent Collateralize(address collateralizer, address collateral, uint amount);\r\n\r\n\tevent WithdrawCollateral(address collateralizer, address collateral, uint amount);\r\n\r\n\tevent Borrow(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent RepayBorrow(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent UpdateSupplyIndex(address market, uint newSupplyIndex, uint supplyRate);\r\n\r\n\tevent UpdateBorrowIndex(address market, uint newBorrowIndex);\r\n\r\n\tevent CollateralLiquidated(address borrower, address collateral, uint amount);\r\n\r\n\tevent NewMarketDebt(address borrower, address market, address collateral, uint amount);\r\n\r\n\tevent BuyLiquidatedCollateral(address market, address collateral, uint marketAmount);\r\n\r\n\tevent PromotionRateChanged(address market, uint newRate);\r\n\r\n\tevent HoldefiPricesContractChanged(HoldefiPricesInterface newAddress, HoldefiPricesInterface oldAddress);\r\n\t\r\n\tconstructor (address newOwnerChanger, CollateralsWalletInterface holdefiCollateralsAddress, HoldefiSettingsInterface holdefiSettingsAddress, HoldefiPricesInterface holdefiPricesAddress) HoldefiPauser(newOwnerChanger) public {\r\n\t\tholdefiCollaterals = holdefiCollateralsAddress;\r\n\t\tholdefiSettings = holdefiSettingsAddress;\r\n\t\tholdefiPrices = holdefiPricesAddress;\r\n\t}\r\n\t\r\n\tfunction supplyInternal (address market, uint amount) internal {\r\n\t\t(uint balance,uint interest,uint currentSupplyIndex) = getAccountSupply(msg.sender, market);\r\n\t\t\r\n\t\tsupplies[msg.sender][market].accumulatedInterest = interest;\r\n\t\tsupplies[msg.sender][market].balance = balance.add(amount);\r\n\t\tsupplies[msg.sender][market].lastInterestIndex = currentSupplyIndex;\r\n\r\n\t\tupdatePromotion(market);\r\n\t\t\r\n\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.add(amount);\r\n\r\n\t\temit Supply(msg.sender, market, amount);\r\n\t}\r\n\r\n\t// Deposit ERC20 assets for supplying (except ETH).\r\n\tfunction supply (address market, uint amount) external whenNotPaused(0) {\r\n\t\trequire (market != address(0), 'Supply asset should not be zero address');\r\n\t\tbool isActive = holdefiSettings.getMarket(market);\r\n\t\trequire (isActive,'Market is not active');\r\n\r\n\t\tERC20 token = ERC20(market);\r\n\t\tbool success = token.transferFrom(msg.sender, address(this), amount);\r\n\t\trequire (success, 'Cannot transfer token');\r\n\r\n\t\tsupplyInternal(market, amount);\r\n\t}\r\n\r\n\t// Deposit ETH for supplying\r\n\tfunction supply () payable external whenNotPaused(0) {\r\n\t\taddress market = address(0);\r\n\t\tuint amount = msg.value;\r\n\t\tbool isActive = holdefiSettings.getMarket(market);\r\n\t\trequire (isActive, 'Market is not active');\r\n\t\t\r\n\t\tsupplyInternal(market, amount);\r\n\t}\r\n\r\n\t// Withdraw ERC20 assets from a market (include interests).\r\n\tfunction withdrawSupply (address market, uint amount) external whenNotPaused(1) {\r\n\t\t(uint balance,uint interest,uint currentSupplyIndex) = getAccountSupply(msg.sender, market);\r\n\t\t\r\n\t\tuint transferAmount;\r\n\t\tuint totalBalance = balance.add(interest);\r\n\r\n\t\trequire (totalBalance != 0, 'Total balance should not be zero');\r\n\t\tif (amount <= totalBalance){\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = totalBalance;\r\n\t\t}\r\n\r\n\t\tuint remaining;\r\n\t\tif (transferAmount <= interest) {\r\n\t\t\tsupplies[msg.sender][market].accumulatedInterest = interest.sub(transferAmount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tremaining = transferAmount.sub(interest);\r\n\t\t\tsupplies[msg.sender][market].accumulatedInterest = 0;\r\n\t\t\tsupplies[msg.sender][market].balance = balance.sub(remaining);\r\n\t\t}\r\n\t\tsupplies[msg.sender][market].lastInterestIndex = currentSupplyIndex;\r\n\r\n\t\tupdatePromotion(market);\r\n\t\t\r\n\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.sub(remaining);\t\r\n\t\t\t\t\r\n\t\tif (market == address(0)){\r\n\t\t\tmsg.sender.transfer(transferAmount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tERC20 token = ERC20(market);\r\n\t\t\tbool success = token.transfer(msg.sender, transferAmount);\r\n\t\t\trequire (success, 'Cannot transfer token');\r\n\t\t}\r\n\t\r\n\t\temit WithdrawSupply(msg.sender, market, transferAmount);\r\n\t}\r\n\r\n\tfunction collateralizeInternal (address collateral, uint amount) internal {\r\n\t\tcollaterals[msg.sender][collateral].balance = collaterals[msg.sender][collateral].balance.add(amount);\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.add(amount);\t\r\n\t\t\r\n\t\temit Collateralize(msg.sender, collateral, amount);\r\n\t}\r\n\r\n\t// Deposit ERC20 assets as collateral(except ETH) \r\n\tfunction collateralize (address collateral, uint amount) external whenNotPaused(2) {\r\n\t\trequire (collateral != address(0), 'Collateral asset should not be zero address');\r\n\t\t(bool isActive,,,) = holdefiSettings.getCollateral(collateral);\r\n\t\trequire (isActive, 'Collateral asset is not active');\r\n\r\n\t\tERC20 token = ERC20(collateral);\r\n\t\tbool success = token.transferFrom(msg.sender, address(holdefiCollaterals), amount);\r\n\t\trequire (success, 'Cannot Transfer Token');\r\n\r\n\t\tcollateralizeInternal(collateral, amount);\r\n\t}\r\n\r\n\t// Deposit ETH as collateral\r\n\tfunction collateralize () payable external whenNotPaused(2) {\r\n\t\taddress collateral = address(0);\r\n\t\tuint amount = msg.value;\r\n\t\t(bool isActive,,,) = holdefiSettings.getCollateral(collateral);\r\n\t\trequire (isActive, 'Collateral asset is not active');\r\n\r\n\t\t(bool success, ) = address(holdefiCollaterals).call.value(amount)(\"\");\r\n\t\trequire (success, 'Cannot Transfer ETH');\r\n\r\n\t\tcollateralizeInternal(collateral, amount);\r\n\t}\r\n\r\n\t// Withdraw collateral assets\r\n\tfunction withdrawCollateral (address collateral, uint amount) external whenNotPaused(3) {\r\n\t\t(uint balance, ,uint borrowPowerScaled,uint totalBorrowValueScaled,) = getAccountCollateral(msg.sender, collateral);\t\r\n\t\trequire (borrowPowerScaled != 0, 'Borrow power should not be zero');\r\n\r\n\t\tuint maxWithdraw;\r\n\t\tif (totalBorrowValueScaled == 0) {\r\n\t\t\tmaxWithdraw = balance;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint collateralPriceScaled = holdefiPrices.getPrice(collateral);\r\n\t\t\t(,uint valueToLoanRate,,) = holdefiSettings.getCollateral(collateral);\r\n\t\t\tuint totalCollateralValueScaled = totalBorrowValueScaled.mul(valueToLoanRate);\t\r\n\t\t\tuint collateralNedeed = totalCollateralValueScaled.div(collateralPriceScaled);\r\n\t\t\tcollateralNedeed = collateralNedeed.div(ratesDecimal);\r\n\r\n\t\t\tmaxWithdraw = balance.sub(collateralNedeed);\r\n\t\t}\r\n\r\n\t\tuint transferAmount;\r\n\t\tif (amount < maxWithdraw){\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = maxWithdraw;\r\n\t\t}\r\n\r\n\t\tcollaterals[msg.sender][collateral].balance = balance.sub(transferAmount);\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.sub(transferAmount);\r\n\r\n\t\tholdefiCollaterals.withdraw(collateral, msg.sender, transferAmount);\r\n\r\n\t\temit WithdrawCollateral(msg.sender, collateral, transferAmount);\r\n\t}\r\n\r\n\t// Borrow a `market` asset based on a `collateral` power \r\n\tfunction borrow (address market, address collateral, uint amount) external whenNotPaused(4) {\r\n\t\tbool isActiveMarket = holdefiSettings.getMarket(market);\r\n\t\t(bool isActiveCollateral,,,) = holdefiSettings.getCollateral(collateral);\r\n\t\trequire (isActiveMarket && isActiveCollateral\r\n\t\t\t\t,'Market or Collateral asset is not active');\r\n\r\n\t\tuint maxAmount = marketAssets[market].totalSupply.sub(marketAssets[market].totalBorrow);\r\n\t\trequire (amount <= maxAmount, 'Amount should be less than cash');\r\n\r\n\t\t(,,uint borrowPowerScaled,,) = getAccountCollateral(msg.sender, collateral);\t\r\n\t\tuint assetToBorrowPrice = holdefiPrices.getPrice(market);\r\n\t\tuint assetToBorrowValueScaled = amount.mul(assetToBorrowPrice);\r\n\t\trequire (borrowPowerScaled > assetToBorrowValueScaled, 'Borrow power should be more than new borrow value');\r\n\r\n\t\t(,uint interest,uint currentBorrowIndex) = getAccountBorrow(msg.sender, market, collateral);\r\n\t\t\r\n\t\tborrows[msg.sender][collateral][market].accumulatedInterest = interest;\r\n\t\tborrows[msg.sender][collateral][market].balance = borrows[msg.sender][collateral][market].balance.add(amount);\r\n\t\tborrows[msg.sender][collateral][market].lastInterestIndex = currentBorrowIndex;\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tupdateSupplyIndex(market);\r\n\t\tupdatePromotionReserve(market);\r\n\r\n\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.add(amount);\r\n\r\n\t\tif (market == address(0)){\r\n\t\t\tmsg.sender.transfer(amount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tERC20 token = ERC20(market);\r\n\t\t\tbool success = token.transfer(msg.sender, amount);\r\n\t\t\trequire (success, 'Cannot transfer token');\r\n\t\t}\r\n\t\temit Borrow(msg.sender, market, collateral, amount);\r\n\t}\r\n\r\n\tfunction repayBorrowInternal (address market, address collateral, uint amount) internal {\r\n\t\t(uint balance,uint interest,uint currentBorrowIndex) = getAccountBorrow(msg.sender, market, collateral);\r\n\t\t\r\n\t\tuint remaining;\r\n\t\tif (amount <= interest) {\r\n\t\t\tborrows[msg.sender][collateral][market].accumulatedInterest = interest.sub(amount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tremaining = amount.sub(interest);\r\n\t\t\tborrows[msg.sender][collateral][market].accumulatedInterest = 0;\r\n\t\t\tborrows[msg.sender][collateral][market].balance = balance.sub(remaining);\r\n\t\t}\r\n\t\tborrows[msg.sender][collateral][market].lastInterestIndex = currentBorrowIndex;\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tupdateSupplyIndex(market);\r\n\t\tupdatePromotionReserve(market);\r\n\t\t\r\n\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.sub(remaining);\t\r\n\r\n\t\temit Borrow (msg.sender, market, collateral, amount);\r\n\t}\r\n\r\n\t// Repay borrow a `market` token based on a `collateral` power\r\n\tfunction repayBorrow (address market, address collateral, uint amount) external whenNotPaused(5) {\r\n\t\trequire (market != address(0), 'Borrow asset should not be zero address');\r\n\r\n\t\t(uint balance, uint interest,) = getAccountBorrow(msg.sender, market, collateral);\r\n\t\t\r\n\t\tuint transferAmount;\r\n\t\tuint totalBalance = balance.add(interest);\r\n\t\trequire (totalBalance != 0, 'Total balance should not be zero');\r\n\t\tif (amount <= totalBalance){\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = totalBalance;\r\n\t\t}\r\n\r\n\t\tERC20 token = ERC20(market);\r\n\t\tbool success = token.transferFrom(msg.sender, address(this), transferAmount);\r\n\t\trequire (success, 'Cannot transfer token');\r\n\r\n\t\trepayBorrowInternal(market, collateral, transferAmount);\r\n\t}\r\n\r\n\t// Repay borrow ETH based on a `collateral` power\r\n\tfunction repayBorrow (address collateral) payable external whenNotPaused(5) {\r\n\t\taddress market = address(0);\r\n\t\tuint amount = msg.value;\t\t\r\n\r\n\t\t(uint balance,uint interest,) = getAccountBorrow(msg.sender, market, collateral);\r\n\t\t\r\n\t\tuint transferAmount;\r\n\t\tuint totalBalance = balance.add(interest);\r\n\t\trequire (totalBalance != 0, 'Total balance should not be zero');\r\n\t\tif (amount <= totalBalance) {\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = totalBalance;\r\n\t\t\tuint extra = amount.sub(totalBalance);\r\n\t\t\tmsg.sender.transfer(extra);\r\n\t\t}\r\n\r\n\t\trepayBorrowInternal(market, collateral, transferAmount);\r\n\t}\r\n\r\n\tfunction clearDebts (address borrower, address collateral) internal {\r\n\t\taddress market;\r\n\t\tuint borrowBalance;\r\n\t\tuint borrowInterest;\r\n\t\tuint borrowInterestIndex;\r\n\t\tuint totalBalance;\r\n\t\taddress[] memory marketsList = holdefiSettings.getMarketsList();\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tmarket = marketsList[i];\r\n\t\t\t\r\n\t\t\t(borrowBalance,borrowInterest,borrowInterestIndex) = getAccountBorrow(borrower, market, collateral);\r\n\t\t\ttotalBalance = borrowBalance.add(borrowInterest);\r\n\t\t\tif (totalBalance > 0) {\r\n\t\t\t\tborrows[borrower][collateral][market].balance = 0;\r\n\t\t\t\tborrows[borrower][collateral][market].accumulatedInterest = 0;\r\n\t\t\t\tborrows[borrower][collateral][market].lastInterestIndex = borrowInterestIndex;\r\n\t\t\t\tupdateSupplyIndex(market);\r\n\t\t\t\tupdatePromotionReserve(market);\t\t\r\n\t\t\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.sub(borrowBalance);\r\n\t\t\t\tmarketDebt[collateral][market] = marketDebt[collateral][market].add(totalBalance);\r\n\t\t\t\temit NewMarketDebt(borrower, market, collateral, totalBalance);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Liquidate borrower's collateral\r\n\tfunction liquidateBorrowerCollateral (address borrower, address collateral) external whenNotPaused(6) {\r\n\t\t(,uint timeSinceLastActivity,,uint totalBorrowValueScaled,bool underCollateral) = getAccountCollateral(borrower, collateral);\r\n\t\t\r\n\t\trequire (underCollateral || (timeSinceLastActivity > secondsPerYear), 'User should be under collateral or time is over');\r\n\r\n\t\tuint collateralPrice = holdefiPrices.getPrice(collateral);\r\n\t\t(,,uint penaltyRate,) = holdefiSettings.getCollateral(collateral);\r\n\t\tuint liquidatedCollateralValue = totalBorrowValueScaled.mul(penaltyRate);\r\n\t\tuint liquidatedCollateral = liquidatedCollateralValue.div(collateralPrice);\r\n\t\tliquidatedCollateral = liquidatedCollateral.div(ratesDecimal);\r\n\r\n\t\tif (liquidatedCollateral > collaterals[borrower][collateral].balance) {\r\n\t\t\tliquidatedCollateral = collaterals[borrower][collateral].balance;\r\n\t\t}\r\n\r\n\t\tcollaterals[borrower][collateral].balance = collaterals[borrower][collateral].balance.sub(liquidatedCollateral);\r\n\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.sub(liquidatedCollateral);\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral = collateralAssets[collateral].totalLiquidatedCollateral.add(liquidatedCollateral);\r\n\t\tcollaterals[msg.sender][collateral].lastUpdateTime = block.timestamp;\r\n\r\n\t\tclearDebts(borrower, collateral);\r\n\r\n\t\temit CollateralLiquidated(borrower, collateral, liquidatedCollateral);\t\r\n\t}\r\n\r\n\tfunction buyLiquidatedCollateralInternal (address market, address collateral, uint marketAmount, uint collateralAmountWithDiscount) internal {\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral = collateralAssets[collateral].totalLiquidatedCollateral.sub(collateralAmountWithDiscount);\r\n\t\tmarketDebt[collateral][market] = marketDebt[collateral][market].sub(marketAmount);\r\n\r\n\t\tholdefiCollaterals.withdraw(collateral, msg.sender, collateralAmountWithDiscount);\r\n\r\n\t\temit BuyLiquidatedCollateral(market, collateral, marketAmount);\r\n\t}\r\n\r\n\t// Buy `collateral` in exchange for `market` token\r\n\tfunction buyLiquidatedCollateral (address market, address collateral, uint marketAmount) external whenNotPaused(7) {\r\n\t\trequire (market != address(0), 'Market should not be zero address');\r\n\t\r\n\t\trequire (marketAmount <= marketDebt[collateral][market], 'Amount should be less than total liquidated assets');\r\n\r\n\t\tuint collateralAmountWithDiscount = getDiscountedCollateralAmount(market, collateral, marketAmount);\r\n\r\n\t\trequire (collateralAmountWithDiscount <= collateralAssets[collateral].totalLiquidatedCollateral, 'Collateral amount with discount should be less than total liquidated assets');\r\n\r\n\t\tERC20 token = ERC20(market);\r\n\t\tbool success = token.transferFrom(msg.sender, address(this), marketAmount);\r\n\t\trequire (success, 'Cannot transfer token');\r\n\r\n\t\tbuyLiquidatedCollateralInternal(market, collateral, marketAmount, collateralAmountWithDiscount);\r\n\t}\r\n\r\n\t// Buy `collateral` in exchange for ETH \r\n\tfunction buyLiquidatedCollateral (address collateral) external payable whenNotPaused(7) {\r\n\t\taddress market = address(0);\r\n\t\tuint marketAmount = msg.value;\r\n\r\n\t\trequire (marketAmount <= marketDebt[collateral][market], 'Amount should be less than total liquidated assets');\r\n\r\n\t\tuint collateralAmountWithDiscount = getDiscountedCollateralAmount(market, collateral, marketAmount);\r\n\r\n\t\trequire (collateralAmountWithDiscount <= collateralAssets[collateral].totalLiquidatedCollateral, 'Collateral amount with discount should be less than total liquidated assets');\r\n\r\n\t\tbuyLiquidatedCollateralInternal(market, collateral, marketAmount, collateralAmountWithDiscount);\r\n\t}\r\n\r\n\t// Returns amount of discounted collateral that buyer can buy by paying `market` asset\r\n\tfunction getDiscountedCollateralAmount (address market, address collateral, uint marketAmount) public view returns(uint collateralAmountWithDiscount) {\r\n\t\tuint marketPrice = holdefiPrices.getPrice(market);\r\n\t\tuint marketValue = marketAmount.mul(marketPrice);\r\n\r\n\t\tuint collateralPrice = holdefiPrices.getPrice(collateral);\r\n\t\t(,,,uint bonusRate) = holdefiSettings.getCollateral(collateral);\r\n\t\tuint collateralAmountWithDiscountScaled = marketValue.mul(bonusRate);\r\n\t\tcollateralAmountWithDiscount = collateralAmountWithDiscountScaled.div(collateralPrice);\r\n\t\tcollateralAmountWithDiscount = collateralAmountWithDiscount.div(ratesDecimal);\r\n\t}\r\n\t\r\n\t// Returns supply and borrow index for a given `market` at current time \r\n\tfunction getCurrentInterestIndex (address market) public view returns(uint supplyIndex, uint supplyRate, uint borrowIndex, uint borrowRate, uint currentTime) {\r\n\t\tuint supplyRateBase;\r\n\t\t(borrowRate,supplyRateBase) = holdefiSettings.getInterests(market, marketAssets[market].totalSupply, marketAssets[market].totalBorrow);\r\n\t\t\r\n\t\tcurrentTime = block.timestamp;\r\n\t\tsupplyRate = supplyRateBase.add(marketAssets[market].promotionRate);\r\n\r\n\t\tuint deltaTimeSupply = currentTime.sub(marketAssets[market].supplyIndexUpdateTime);\r\n\r\n\t\tuint deltaTimeBorrow = currentTime.sub(marketAssets[market].borrowIndexUpdateTime);\r\n\r\n\t\tuint deltaTimeInterest = deltaTimeSupply.mul(supplyRate);\r\n\t\tsupplyIndex = marketAssets[market].supplyIndex.add(deltaTimeInterest);\r\n\r\n\t\tdeltaTimeInterest = deltaTimeBorrow.mul(borrowRate);\r\n\t\tborrowIndex = marketAssets[market].borrowIndex.add(deltaTimeInterest);\r\n\t}\r\n\r\n\tfunction getCurrentPromotion (address market) public view returns(uint promotionReserveScaled, uint promotionDebtScaled, uint currentTime) {\r\n\t\t(uint borrowRate, uint supplyRateBase) = holdefiSettings.getInterests(market, marketAssets[market].totalSupply, marketAssets[market].totalBorrow);\r\n\t\t\r\n\t\tcurrentTime = block.timestamp;\r\n\t\r\n\t\tuint allSupplyInterest = marketAssets[market].totalSupply.mul(supplyRateBase);\r\n\t\tuint allBorrowInterest = marketAssets[market].totalBorrow.mul(borrowRate);\r\n\r\n\t\tuint deltaTime = currentTime.sub(marketAssets[market].promotionReserveLastUpdateTime);\r\n\t\tuint currentInterest = allBorrowInterest.sub(allSupplyInterest);\r\n\t\tuint deltaTimeInterest = currentInterest.mul(deltaTime);\r\n\t\tpromotionReserveScaled = marketAssets[market].promotionReserveScaled.add(deltaTimeInterest);\r\n\r\n\t\tif (marketAssets[market].promotionRate != 0){\r\n\t\t\tdeltaTime = currentTime.sub(marketAssets[market].promotionDebtLastUpdateTime);\r\n\t\t\tcurrentInterest = marketAssets[market].totalSupply.mul(marketAssets[market].promotionRate);\r\n\t\t\tdeltaTimeInterest = currentInterest.mul(deltaTime);\r\n\t\t\tpromotionDebtScaled = marketAssets[market].promotionDebtScaled.add(deltaTimeInterest);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpromotionDebtScaled = marketAssets[market].promotionDebtScaled;\r\n\t\t}\r\n\t}\r\n\r\n\t// Update a `market` supply interest index and promotion reserve\r\n\tfunction updateSupplyIndex (address market) public {\r\n\t\t(uint currentSupplyIndex,uint supplyRate,,,uint currentTime) = getCurrentInterestIndex(market);\r\n\r\n\t\tmarketAssets[market].supplyIndex = currentSupplyIndex;\r\n\t\tmarketAssets[market].supplyIndexUpdateTime = currentTime;\r\n\r\n\t\temit UpdateSupplyIndex(market, currentSupplyIndex, supplyRate);\r\n\t}\r\n\r\n\t// Update a `market` borrow interest index \r\n\tfunction updateBorrowIndex (address market) public {\r\n\t\t(,,uint currentBorrowIndex,,uint currentTime) = getCurrentInterestIndex(market);\r\n\r\n\t\tmarketAssets[market].borrowIndex = currentBorrowIndex;\r\n\t\tmarketAssets[market].borrowIndexUpdateTime = currentTime;\r\n\r\n\t\temit UpdateBorrowIndex(market, currentBorrowIndex);\r\n\t}\r\n\r\n\tfunction updatePromotionReserve(address market) public {\r\n\t\t(uint reserveScaled,,uint currentTime) = getCurrentPromotion(market);\r\n\r\n\t\tmarketAssets[market].promotionReserveScaled = reserveScaled;\r\n\t\tmarketAssets[market].promotionReserveLastUpdateTime = currentTime;\r\n\t}\r\n\r\n\t// Subtract users promotion from promotionReserve for a `market` and update promotionDebt and promotionRate if needed\r\n\tfunction updatePromotion(address market) public {\r\n\t\tupdateSupplyIndex(market);\r\n\t\tupdatePromotionReserve(market);\r\n\t\t(uint reserveScaled,uint debtScaled,uint currentTime) = getCurrentPromotion(market);\r\n\t\tif (marketAssets[market].promotionRate != 0){\r\n\t\t\tmarketAssets[market].promotionDebtScaled = debtScaled;\r\n\t\t\tmarketAssets[market].promotionDebtLastUpdateTime = currentTime;\r\n\r\n\t\t\tif (debtScaled > reserveScaled) {\r\n\t\t\t\tmarketAssets[market].promotionRate = 0;\r\n\t\t\t\temit PromotionRateChanged(market, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns balance and interest of an `account` for a given `market`\r\n\tfunction getAccountSupply(address account, address market) public view returns(uint balance, uint interest, uint currentSupplyIndex) {\r\n\t\tbalance = supplies[account][market].balance;\r\n\r\n\t\t(currentSupplyIndex,,,,) = getCurrentInterestIndex(market);\r\n\r\n\t\tuint deltaInterestIndex = currentSupplyIndex.sub(supplies[account][market].lastInterestIndex);\r\n\t\tuint deltaInterestScaled = deltaInterestIndex.mul(balance);\r\n\t\tuint deltaInterest = deltaInterestScaled.div(secondsPerYear);\r\n\t\tdeltaInterest = deltaInterest.div(ratesDecimal);\r\n\t\t\r\n\t\tinterest = supplies[account][market].accumulatedInterest.add(deltaInterest);\r\n\t}\r\n\r\n\t// Returns balance and interest of an `account` for a given `market` based on a `collateral` power\r\n\tfunction getAccountBorrow(address account, address market, address collateral) public view returns(uint balance, uint interest, uint currentBorrowIndex) {\r\n\t\tbalance = borrows[account][collateral][market].balance;\r\n\r\n\t\t(,,currentBorrowIndex,,) = getCurrentInterestIndex(market);\r\n\r\n\t\tuint deltaInterestIndex = currentBorrowIndex.sub(borrows[account][collateral][market].lastInterestIndex);\r\n\t\tuint deltaInterestScaled = deltaInterestIndex.mul(balance);\r\n\t\tuint deltaInterest = deltaInterestScaled.div(secondsPerYear);\r\n\t\tdeltaInterest = deltaInterest.div(ratesDecimal);\r\n\t\tif (balance > 0) {\r\n\t\t\tdeltaInterest = deltaInterest.add(1);\r\n\t\t}\r\n\r\n\t\tinterest = borrows[account][collateral][market].accumulatedInterest.add(deltaInterest);\r\n\t}\r\n\r\n\t// Returns total borrow value of an `account` based on a `collateral` power\r\n\tfunction getAccountTotalBorrowValue (address account, address collateral) public view returns(uint totalBorrowValueScaled) {\r\n\t\taddress market;\r\n\t\tuint balance;\r\n\t\tuint interest;\r\n\t\tuint totalDebt;\r\n\t\tuint assetPrice;\r\n\t\tuint assetValueScaled;\r\n\t\t\r\n\t\taddress[] memory marketsList = holdefiSettings.getMarketsList();\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tmarket = marketsList[i];\r\n\t\t\t\r\n\t\t\t(balance, interest,) = getAccountBorrow(account, market, collateral);\r\n\t\t\ttotalDebt = balance.add(interest);\r\n\r\n\t\t\tassetPrice = holdefiPrices.getPrice(market);\r\n\t\t\tassetValueScaled = totalDebt.mul(assetPrice);\r\n\r\n\t\t\ttotalBorrowValueScaled = totalBorrowValueScaled.add(assetValueScaled); //scaled by: 18 (priceDecimal)\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns collateral balance, time since last activity, borrow power and total borrow value of an `account` for a given `collateral` \r\n\tfunction getAccountCollateral(address account, address collateral) public view returns(uint balance, uint timeSinceLastActivity, uint borrowPowerScaled, uint totalBorrowValueScaled, bool underCollateral) {\r\n\t\tbalance = collaterals[account][collateral].balance;\r\n\r\n\t\tuint collateralPriceScaled = holdefiPrices.getPrice(collateral);\r\n\t\tuint collateralValueScaled = balance.mul(collateralPriceScaled);\r\n\t\tcollateralValueScaled = collateralValueScaled.mul(ratesDecimal);\r\n\t\t(,uint valueToLoanRate,,) = holdefiSettings.getCollateral(collateral);\r\n\t\tuint totalBorrowPowerScaled = collateralValueScaled.div(valueToLoanRate);\r\n\t\tuint liquidationThresholdRate = valueToLoanRate.sub(500);\r\n\t\tuint totalBorrowPowerScaledL = collateralValueScaled.div(liquidationThresholdRate);\r\n\r\n\t\ttotalBorrowValueScaled = getAccountTotalBorrowValue(account, collateral);\r\n\r\n\t\tif (totalBorrowValueScaled > 0) {\r\n\t\t\ttimeSinceLastActivity = block.timestamp.sub(collaterals[account][collateral].lastUpdateTime);\r\n\t\t}\t\r\n\t\tif (totalBorrowPowerScaled >= totalBorrowValueScaled) {\r\n\t\t\tborrowPowerScaled = totalBorrowPowerScaled.sub(totalBorrowValueScaled);\r\n\t\t}\t\r\n\t\tif (totalBorrowPowerScaledL <= totalBorrowValueScaled) {\r\n\t\t\tunderCollateral = true;\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns liquidation reserve\r\n\tfunction getLiquidationReserve (address collateral) public view returns(uint reserve) {\r\n\t\taddress market;\r\n\t\tuint assetPrice;\r\n\t\tuint assetValueScaled;\r\n\t\tuint totalDebtValueScaled = 0;\r\n\r\n\t\taddress[] memory marketsList = holdefiSettings.getMarketsList();\r\n\t\tfor (uint i=0; i<marketsList.length; i++) {\r\n\t\t\tmarket = marketsList[i];\r\n\r\n\t\t\tassetPrice = holdefiPrices.getPrice(market);\r\n\t\t\tassetValueScaled = marketDebt[collateral][market].mul(assetPrice);\r\n\r\n\t\t\ttotalDebtValueScaled = totalDebtValueScaled.add(assetValueScaled); \r\n\t\t}\r\n\r\n\t\tuint collateralPriceScaled = holdefiPrices.getPrice(collateral);\r\n\t\t(,,,uint bonusRate) = holdefiSettings.getCollateral(collateral);\r\n\t\tuint totalDebtCollateralValueScaled = totalDebtValueScaled.mul(bonusRate);\r\n\t\tuint liquidatedCollateralNeeded = totalDebtCollateralValueScaled.div(collateralPriceScaled);\r\n\t\tliquidatedCollateralNeeded = liquidatedCollateralNeeded.div(ratesDecimal);\r\n\t\t\r\n\t\tif (collateralAssets[collateral].totalLiquidatedCollateral > liquidatedCollateralNeeded) {\r\n\t\t\treserve = collateralAssets[collateral].totalLiquidatedCollateral.sub(liquidatedCollateralNeeded);\r\n\t\t}\r\n\t}\r\n\r\n\t// Withdraw liquidation reserve by owner\r\n\tfunction withdrawLiquidationReserve (address collateral, uint amount) external onlyOwner {\r\n\t\tuint maxWithdraw = getLiquidationReserve(collateral);\r\n\t\tuint transferAmount;\r\n\t\t\r\n\t\tif (amount <= maxWithdraw){\r\n\t\t\ttransferAmount = amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttransferAmount = maxWithdraw;\r\n\t\t}\r\n\r\n\t\tcollateralAssets[collateral].totalLiquidatedCollateral = collateralAssets[collateral].totalLiquidatedCollateral.sub(transferAmount);\r\n\t\tholdefiCollaterals.withdraw(collateral, msg.sender, transferAmount);\r\n\t}\r\n\r\n\tfunction depositPromotionReserveInternal (address market, uint amount) internal {\r\n\t\t(uint reserveScaled,uint debtScaled,uint currentTime) = getCurrentPromotion(market);\r\n\r\n\t\tuint amountScaled = amount.mul(secondsPerYear);\r\n\t\tamountScaled = amountScaled.mul(ratesDecimal);\r\n\r\n\t\tuint totalReserve = reserveScaled.add(amountScaled);\r\n\r\n\t\tif (totalReserve <= debtScaled) {\r\n\t\t\tmarketAssets[market].promotionReserveScaled = 0;\r\n\t\t\tmarketAssets[market].promotionDebtScaled = debtScaled.sub(totalReserve);\t\r\n\t\t\tif (marketAssets[market].promotionRate != 0) {\r\n\t\t\t\tupdateSupplyIndex(market);\r\n\t\t\t\tmarketAssets[market].promotionRate = 0;\r\n\t\t\t\temit PromotionRateChanged(market, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmarketAssets[market].promotionReserveScaled = totalReserve.sub(debtScaled);\r\n\t\t\tmarketAssets[market].promotionDebtScaled = 0;\r\n\t\t}\r\n\t\tmarketAssets[market].promotionReserveLastUpdateTime = currentTime;\r\n\t\tmarketAssets[market].promotionDebtLastUpdateTime = currentTime;\r\n\t}\r\n\r\n\t// Deposit ERC20 asset as promotion reserve \r\n\tfunction depositPromotionReserve (address market, uint amount) external {\r\n\t\trequire (market != address(0), 'Market asset should not be zero address');\r\n\r\n\t\tERC20 token = ERC20(market);\r\n\t\tbool success = token.transferFrom(msg.sender, address(this), amount);\r\n\t\trequire (success, 'Cannot transfer token');\r\n\r\n\t\tdepositPromotionReserveInternal(market, amount);\r\n\t}\r\n\r\n\t// Deposit ETH as promotion reserve\r\n\tfunction depositPromotionReserve () payable external {\r\n\t\taddress market = address(0);\r\n\t\tuint amount = msg.value;\r\n\r\n\t\tdepositPromotionReserveInternal(market, amount);\r\n\t}\r\n\r\n\t// Withdraw promotion reserve by owner\r\n\tfunction withdrawPromotionReserve (address market, uint amount) external onlyOwner {\r\n\t\t(uint reserveScaled,uint debtScaled,uint currentTime) = getCurrentPromotion(market);\r\n\r\n\t\trequire (reserveScaled > debtScaled, 'Promotion reserve should be more than promotion debt');\r\n\t\t\r\n\t\tuint maxWithdrawScaled = reserveScaled.sub(debtScaled);\r\n\r\n\t\tuint amountScaled = amount.mul(secondsPerYear);\r\n\t    amountScaled = amountScaled.mul(ratesDecimal);\r\n\r\n\t    require (amountScaled < maxWithdrawScaled, 'Amount should be less than max');\r\n\r\n\t    marketAssets[market].promotionReserveScaled = maxWithdrawScaled.sub(amountScaled);\r\n\t    marketAssets[market].promotionReserveLastUpdateTime = currentTime;\r\n\t\tmarketAssets[market].promotionDebtScaled = 0;\r\n\t\tmarketAssets[market].promotionDebtLastUpdateTime = currentTime;\t\r\n\r\n\t    if (market == address(0)){\r\n\t\t\tmsg.sender.transfer(amount);\r\n\t    }\r\n\t    else {\r\n\t\t\tERC20 token = ERC20(market);\r\n\t\t\tbool success = token.transfer(msg.sender, amount);\r\n\t\t\trequire (success, 'Cannot transfer token');\r\n\t    }\r\n\t}\r\n\r\n\t// Set promotion rate by owner\r\n\tfunction setPromotionRate (addr"
    }
  ]
}