{
  "Title": "M-14: Title: Inadequate Allowance Handling in convertAndForward Function of `OCT_DAO` & `OCT_YDL`.",
  "Content": "# Issue M-14: Title: Inadequate Allowance Handling in convertAndForward Function of `OCT_DAO` & `OCT_YDL`. \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/609 \n\n## Found by \n0xBhumii, recursiveEth\n## Summary\nThe `OCT_DAO:convertAndForward `and `OCT_YDL:convertAndForward `function suffers from inadequate handling of token allowances for the 1inch router. Although allowances are set correctly before converting assets, they are not reset afterward. This can lead to failed transactions if the 1inch router does not utilize the entire allowance due to slippage or other factors.\n\n## Vulnerability Detail\n\nthe issue arises from the lack of allowance reset after interacting with the 1inch router. If the router does not utilize the entire allowance specified due to slippage or other reasons, the allowance will remain unchanged, potentially causing the assertion to fail and the transaction to revert.\n\n## Impact\n\nThe impact of this vulnerability is that transactions may fail due to incorrect allowance management. This could result in inefficiencies in liquidity provision, loss of gas fees because due to asset statement it consume all the gas and won't return anything and convertandTransfer will never be able to transfer asset to DAO.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCT/OCT_DAO.sol#L87\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCT/OCT_YDL.sol#L97\n```javascript\nassert(IERC20(asset).allowance(address(this), router1INCH_V5) == 0);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReset Allowances After Use: After interacting with the Uniswap router and completing the liquidity provision, reset the allowances for the pair assets and ZVE tokens to zero to ensure they are not left with excessive allowances.\n\n\n\n## Discussion\n\n**pseudonaut**\n\nValid\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> borderline low/medium, the report has just generic suggestion without specific POC (exact scenario) when this can actually happen. Normally, when doing a swap, full allowance is used to do it. It appears that 1inch's fillOrderRFQ might not use full allowance if there is no matching order in the orderbook, but I'm not 100% sure. Watson should have provided the POC to prove his point.\n\n\n\n**BiasedMerc**\n\nThis seems like it should be invalid, as mentioned by lead judge, there is no POC or explanation as to how any allowance can be left after interaction with the router, and all explanations and suggestions are generic. \n\nI feel like for this type of issue some sort of written POC should be required to prove the issue, as currently there is no way to prove if this scenario can actually happen. And judge also is unsure if this is really a valid issue from the comment, so it seems the warden has not done an adequate job at proving the issue due to lack of POC. \n\nE.g. #18 describes a similar issue for UniSwap and outlines the exact scenario of how leftover allowance can occur with code-snippets.\n\n**ironsidesec**\n\nIn the vulnerability section, watson says ` If the router does not utilize the entire allowance specified due to slippage or other reasons`\nsubmit a POC to prove that 1inch will operate in a way that allowance will be > 0 in any of the success swap paths, then issue might be valid.\n\nswaps will revert  if the slippage did not match. If swap fails, whole transaction will revert, hence chances for allownce to be > 0 after a successful swap is not possible\n\n\n**Afriaudit**\n\nAs far as I understand here. There was a flaw in the protocol's implementation when engaging with a third party.(in this case uniswap, curve, sushi, 1inch) and the flaw is:\n-give allowance to the third party\n-Third party withdraws from the protocol\n-Protocol fails to reduce allowance left\n-Protocol proceeds to assert allowance = 0\n\nThis implementation will cause recurring reversion when interacting these third parties.\n\nAccording to sherlock rules;\n''In case the same vulnerability appears across multiple places in different contracts, they can be considered duplicates.\nThe exception to this would be if underlying code implementations, impact, and the fixes are different, then they can be treated separately.'' \nAs far as I know the impact and fixes are same making It a dup of #18.  Though the implementation logic is same the exact code Is different, one being uniswap the other being one inch. \nIt will be Interesting to see how this turns out as it will help understand the interpretation of the above sherlock rule.\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/262\n\n\n**armormadeofwoe**\n\nThere are currently 2 separate issues regarding vulnerable `assert` statements in swaps: #18 with UniSwap and this one for 1inch. Since the root cause is the same (flawed dev design choice of using `assert`) why are they considered as separate bugs?\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCT/OCT_DAO.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../Utility/ZivoeSwapper.sol\";\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IZivoeGlobals_OCT_DAO {\n    /// @notice Returns the address of ZivoeDAO.\n    function DAO() external view returns (address);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    /// @return keeper Equals \"true\" if address is a keeper, \"false\" if not.\n    function isKeeper(address) external view returns (bool keeper);\n}\n\n\n\n/// @notice This contract converts assets and forwards them to the DAO.\ncontract OCT_DAO is ZivoeLocker, ZivoeSwapper, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCT_DAO contract.\n    /// @param  DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param  _GBL The ZivoeGlobals contract.\n    constructor(address DAO, address _GBL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n    }\n\n\n\n    // ------------\n    //    Events   \n    // ------------\n\n    /// @notice Emitted during convertAndForward().\n    /// @param  asset The \"asset\" being converted.\n    /// @param  toAsset The ERC20 that we are converting \"asset\" to.\n    /// @param  amountFrom The amount being converted.\n    /// @param  amountTo The amount received from conversion.\n    event AssetConvertedForwarded(address indexed asset, address indexed toAsset, uint256 amountFrom, uint256 amountTo);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLocker().\n    function canPush() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pushToLockerMulti().\n    function canPushMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerMulti().\n    function canPullMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerMultiPartial().\n    function canPullMultiPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Converts an asset and forwards it to the DAO.\n    /// @param  asset The asset to convert.\n    /// @param  toAsset The ERC20 that we are converting \"asset\" to. \n    /// @param  data The payload containing conversion data, consumed by 1INCH_V5.\n    function convertAndForward(address asset, address toAsset, bytes calldata data) external nonReentrant {\n        require(\n            IZivoeGlobals_OCT_DAO(GBL).isKeeper(_msgSender()), \n            \"OCT_DAO::convertAndForward !isKeeper(_msgSender())\"\n        );\n        uint256 amountFrom = IERC20(asset).balanceOf(address(this));\n        IERC20(asset).safeIncreaseAllowance(router1INCH_V5, amountFrom);\n        convertAsset(asset, toAsset, amountFrom, data);\n        assert(IERC20(asset).allowance(address(this), router1INCH_V5) == 0);\n        uint balToAsset = IERC20(toAsset).balanceOf(address(this));\n        emit AssetConvertedForwarded(asset, toAsset, amountFrom, balToAsset);\n        IERC20(toAsset).safeTransfer(IZivoeGlobals_OCT_DAO(GBL).DAO(), balToAsset);\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/lockers/OCT/OCT_YDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../Utility/ZivoeSwapper.sol\";\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IZivoeYDL_OCT_YDL {\n    /// @notice Returns the \"stablecoin\" that will be distributed via YDL.\n    /// @return asset The address of the \"stablecoin\" that will be distributed via YDL.\n    function distributedAsset() external view returns (address asset);\n}\n\ninterface IZivoeGlobals_OCT_YDL {\n    /// @notice Returns the address of the ZivoeYDL contract.\n    function YDL() external view returns (address);\n\n    /// @notice Returns true if an address is whitelisted as a keeper.\n    /// @return keeper Equals \"true\" if address is a keeper, \"false\" if not.\n    function isKeeper(address) external view returns (bool keeper);\n}\n\n\n\n/// @notice This contract converts assets and forwards them to the YDL.\ncontract OCT_YDL is ZivoeLocker, ZivoeSwapper, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    \n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;               /// @dev The ZivoeGlobals contract.\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCT_YDL contract.\n    /// @param  DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param  _GBL The ZivoeGlobals contract.\n    constructor(address DAO, address _GBL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n    }\n\n\n\n    // ------------\n    //    Events   \n    // ------------\n\n    /// @notice Emitted during convertAndForward().\n    /// @param  asset The \"asset\" being converted.\n    /// @param  distributedAsset The ERC20 that we are converting \"asset\" to, based on YDL.distributedAsset().\n    /// @param  amountFrom The amount being converted.\n    /// @param  amountTo The amount of distributedAsset received.\n    event AssetConvertedForwarded(\n        address indexed asset, \n        address indexed distributedAsset, \n        uint256 amountFrom, \n        uint256 amountTo\n    );\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLocker().\n    function canPush() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pushToLockerMulti().\n    function canPushMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerMulti().\n    function canPullMulti() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLockerMultiPartial().\n    function canPullMultiPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Converts an asset to YDL.distributedAsset() and forwards it.\n    /// @param  asset The asset to convert.\n    /// @param  data The payload containing conversion data, consumed by 1INCH_V5.\n    function convertAndForward(address asset, bytes calldata data) external nonReentrant {\n        require(\n            IZivoeGlobals_OCT_YDL(GBL).isKeeper(_msgSender()),\n            \"OCT_YDL::convertAndForward !isKeeper(_msgSender())\"\n        );\n        address distributedAsset = IZivoeYDL_OCT_YDL(IZivoeGlobals_OCT_YDL(GBL).YDL()).distributedAsset();\n        uint256 amountFrom = IERC20(asset).balanceOf(address(this));\n        IERC20(asset).safeIncreaseAllowance(router1INCH_V5, amountFrom);\n        convertAsset(asset, distributedAsset, amountFrom, data);\n        assert(IERC20(asset).allowance(address(this), router1INCH_V5) == 0);\n        uint balDistributedAsset = IERC20(distributedAsset).balanceOf(address(this));\n        emit AssetConvertedForwarded(asset, distributedAsset, amountFrom, balDistributedAsset);\n        IERC20(distributedAsset).safeTransfer(IZivoeGlobals_OCT_YDL(GBL).YDL(), balDistributedAsset);\n    }\n\n}"
    }
  ]
}