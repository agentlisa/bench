{
  "Title": "H-6: Wrong computation of the amountToSellUnit variable",
  "Content": "# Issue H-6: Wrong computation of the amountToSellUnit variable \n\nSource: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/535 \n\n## Found by \n0xRobocop, 0xlmanini, Aymen0909, Bahurum, Bauer, Juntao, Nyx, Proxy, VAD37, Vagner, WATCHPUG, \\_\\_141345\\_\\_, auditsea, carrotsmuggler, immeas, innertia, kiki\\_dev, pengun, qpzm, saidam017, sakshamguruji, toshii, tvdung94\n## Summary\n\nThe variable `amountToSellUnits` is computed wrongly in the code which will lead to an incorrect amount of collateral to be sold.\n\n## Vulnerability Detail\n\nThe `BuyUSSDSellCollateral()` function is used to sell collateral during a peg-down recovery event. The computation of the amount to sell is computed using the following formula:\n\n```solidity\n// @audit-issue Wrong computation\nuint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n```\n\nThe idea is to sell an amount which is equivalent (in USD) to the ratio of `amountToBuyLeftUSD / collateralval`. Flattening the equation it ends up as:\n\n```solidity\nuint256 amountToSellUnits = (collateralBalance * amountToBuyLeftUSD * 1e18) / (collateralval * 1e18 * 1e18);\n\n// Reducing the equation\nuint256 amountToSellUnits = (collateralBalance * amountToBuyLeftUSD) / (collateralval * 1e18);\n```\n\n`amountToBuyLeftUSD` and `collateralval` already have 18 decimals so their decimals get cancelled together which will lead the last 1e18 factor as not necessary.\n\n## Impact\n\nThe contract will sell an incorrect amount of collateral during a peg-down recovery event.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-USSD/blob/6d7a9fdfb1f1ed838632c25b6e1b01748d0bafda/ussd-contracts/contracts/USSDRebalancer.sol#L121\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDelete the last 1e18 factor\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/82",
  "Code": [
    {
      "filename": "ussd-contracts/contracts/USSDRebalancer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n    @dev rebalancer module for USSD ERC20 token. Performs swaps to return USSD/DAI pool balance 1-to-1\n         selling USSD for buying collateral or buying and burning USSD for selling collateral\n */\ncontract USSDRebalancer is AccessControlUpgradeable, IUSSDRebalancer {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // main USSD/DAI pool\n    IUniswapV3Pool public uniPool;\n\n    // USSD token\n    address public USSD;\n\n    // boundary to make rebalancing\n    uint256 private threshold;\n\n    // ratios of collateralization for different collateral accumulating\n    uint256[] public flutterRatios;\n    \n    // base asset for other pool leg (DAI)\n    address private baseAsset;\n\n    // role to perform rebalancer management functions\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(address _ussd) public initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        threshold = 1e4;\n        USSD = _ussd;\n    }\n\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    function setPoolAddress(address _pool) public onlyControl {\n      uniPool = IUniswapV3Pool(_pool);\n    }\n\n    function getPool() public view override returns (address) {\n        return address(uniPool);\n    }\n\n    function setTreshold(uint256 _threshold) public onlyControl {\n      threshold = _threshold;\n    }\n\n    function setFlutterRatios(uint256[] calldata _flutterRatios) public onlyControl {\n      flutterRatios = _flutterRatios;\n    }\n\n    function setBaseAsset(address _baseAsset) public onlyControl {\n      baseAsset = _baseAsset;\n    }\n\n    /// @dev get price estimation to DAI using pool address and uniswap price\n    function getOwnValuation() public view returns (uint256 price) {\n      (uint160 sqrtPriceX96,,,,,,) =  uniPool.slot0();\n      if(uniPool.token0() == USSD) {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))/(1e6) >> (96 * 2);\n      } else {\n        price = uint(sqrtPriceX96)*(uint(sqrtPriceX96))*(1e18 /* 1e12 + 1e6 decimal representation */) >> (96 * 2);\n        // flip the fraction\n        price = (1e24 / price) / 1e12;\n      }\n    }\n\n    /// @dev return pool balances with USSD first\n    function getSupplyProportion() public view returns (uint256, uint256) {\n      uint256 vol1 = IERC20Upgradeable(uniPool.token0()).balanceOf(address(uniPool));\n      uint256 vol2 = IERC20Upgradeable(uniPool.token1()).balanceOf(address(uniPool));\n      if (uniPool.token0() == USSD) {\n        return (vol1, vol2);\n      }\n      return (vol2, vol1);\n    }\n\n    function rebalance() override public {\n      uint256 ownval = getOwnValuation();\n      (uint256 USSDamount, uint256 DAIamount) = getSupplyProportion();\n      if (ownval < 1e6 - threshold) {\n        // peg-down recovery\n        BuyUSSDSellCollateral((USSDamount - DAIamount / 1e12)/2);\n      } else if (ownval > 1e6 + threshold) {\n        // mint and buy collateral\n        // never sell too much USSD for DAI so it 'overshoots' (becomes more in quantity than DAI on the pool)\n        // otherwise could be arbitraged through mint/redeem\n        // the execution difference due to fee should be taken into accounting too\n        // take 1% safety margin (estimated as 2 x 0.5% fee)\n        IUSSD(USSD).mintRebalancer(((DAIamount / 1e12 - USSDamount)/2) * 99 / 100); // mint ourselves amount till balance recover\n        SellUSSDBuyCollateral();\n      }\n    }\n\n    function BuyUSSDSellCollateral(uint256 amountToBuy) internal {\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      //uint amountToBuyLeftUSD = amountToBuy * 1e12 * 1e6 / getOwnValuation();\n      uint amountToBuyLeftUSD = amountToBuy * 1e12;\n      uint DAItosell = 0;\n      // Sell collateral in order of collateral array\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval > amountToBuyLeftUSD) {\n          // sell a portion of collateral and exit\n          if (collateral[i].pathsell.length > 0) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            uint256 amountToSellUnits = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * ((amountToBuyLeftUSD * 1e18 / collateralval) / 1e18) / 1e18;\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, amountToSellUnits);\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          } else {\n            // no need to swap DAI\n            DAItosell = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * amountToBuyLeftUSD / collateralval;\n          }\n          break;\n        } else {\n          // sell all or skip (if collateral is too little, 5% treshold)\n          if (collateralval >= amountToBuyLeftUSD / 20) {\n            uint256 amountBefore = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n            // sell all collateral and move to next one\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathsell, IERC20Upgradeable(collateral[i].token).balanceOf(USSD));\n            amountToBuyLeftUSD -= (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n            DAItosell += (IERC20Upgradeable(baseAsset).balanceOf(USSD) - amountBefore);\n          }\n        }\n      }\n\n      // buy USSD (sell DAI) to burn\n      // never sell too much DAI so USSD 'overshoots' (becomes less in quantity than DAI on the pool)\n      // otherwise could be arbitraged through mint/redeem\n      // the remainder (should be small, due to oracle twap lag) to be left as DAI collateral\n      // the execution difference due to fee should be taken into accounting too\n      // take 1% safety margin (estimated as 2 x 0.5% fee)\n      if (DAItosell > amountToBuy * 1e12 * 99 / 100) {\n        DAItosell = amountToBuy * 1e12 * 99 / 100;\n      }\n\n      if (DAItosell > 0) {\n        if (uniPool.token0() == USSD) {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), DAItosell);\n        } else {\n            IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), DAItosell);\n        }\n      }\n\n      IUSSD(USSD).burnRebalancer(IUSSD(USSD).balanceOf(USSD));\n    }\n\n    function SellUSSDBuyCollateral() internal {\n      uint256 amount = IUSSD(USSD).balanceOf(USSD);\n      // sell for DAI then swap by DAI routes\n      uint256 daibought = 0;\n      if (uniPool.token0() == USSD) {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token0(), hex\"0001f4\", uniPool.token1())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      } else {\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD);\n        IUSSD(USSD).UniV3SwapInput(bytes.concat(abi.encodePacked(uniPool.token1(), hex\"0001f4\", uniPool.token0())), amount);\n        daibought = IERC20Upgradeable(baseAsset).balanceOf(USSD) - daibought; // would revert if not bought\n      }\n\n      // total collateral portions\n      uint256 cf = IUSSD(USSD).collateralFactor();\n      uint256 flutter = 0;\n      for (flutter = 0; flutter < flutterRatios.length; flutter++) {\n        if (cf < flutterRatios[flutter]) {\n          break;\n        }\n      }\n\n      CollateralInfo[] memory collateral = IUSSD(USSD).collateralList();\n      uint portions = 0;\n      uint ownval = (getOwnValuation() * 1e18 / 1e6) * IUSSD(USSD).totalSupply() / 1e6; // 1e18 total USSD value\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          portions++;\n        }\n      }\n\n      for (uint256 i = 0; i < collateral.length; i++) {\n        uint256 collateralval = IERC20Upgradeable(collateral[i].token).balanceOf(USSD) * 1e18 / (10**IERC20MetadataUpgradeable(collateral[i].token).decimals()) * collateral[i].oracle.getPriceUSD() / 1e18;\n        if (collateralval * 1e18 / ownval < collateral[i].ratios[flutter]) {\n          if (collateral[i].token != uniPool.token0() || collateral[i].token != uniPool.token1()) {\n            // don't touch DAI if it's needed to be bought (it's already bought)\n            IUSSD(USSD).UniV3SwapInput(collateral[i].pathbuy, daibought/portions);\n          }\n        }\n      }\n    }\n}"
    }
  ]
}