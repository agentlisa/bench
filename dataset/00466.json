{
  "Title": "H-1: Creating new withdrawal requests in conjunction with `settleEpochFromEigenLayer` will render system unusable",
  "Content": "# Issue H-1: Creating new withdrawal requests in conjunction with `settleEpochFromEigenLayer` will render system unusable \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/4 \n\n## Found by \n0xkaden, AuditorPraise, Aymen0909, Bauer, ComposableSecurity, Drynooo, HSP, KupiaSec, Stiglitz, Thanos, Tricko, almurhasan, aslanbek, bhilare\\_, cu5t0mPe0, deth, eeshenggoh, fnanni, g, giraffe, hash, iamandreiski, jovi, kennedy1030, klaus, lemonmon, lil.eth, monrel, mstpr-brainbot, mussucal, peanuts, popular, sakshamguruji, shaka, thec00n, zraxx, zzykxx\n## Summary\nThis issue pertains to the flow where a user requests to withdraw more funds than are currently present in the `depositPool` and the system must withdraw from Eigenlayer. \n\nUsers are able to create new withdrawal requests for the current epoch while the Eigenlayer withdrawal request is pending, as well as after the epoch has been marked `settled` in `settleEpochFromEigenLayer()`. This is due to the fact that `settleEpochFromEigenLayer()` does not increment the current epoch, as well as that there is no way to fulfill withdrawal requests submitted after the 7 day waiting period has been initiated. Submitting a withdrawal request will result in an inability to progress epochs and a locking of the system. \n\n## Vulnerability Detail\nConsider the system in the following state:\n- We are in epoch 0\n- A user submitted a withdrawal request for an amount greater than what is currently in `depositPool`\n- `rebalance() --> withdrawalQueue_.queueCurrentEpochSettlement()` has been called\n- The system made a request to Eigenlayer for the necessary amount and the withdrawal request is ready to be claimed\n- The next step is to call `RioLRTWithdrawalQueue:settleEpochFromEigenLayer()` [link](https://github.com/sherlock-audit/2024-02-rio-vesting-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L216)\n\nThe function `settleEpochFromEigenLayer()` performs several important tasks - completing pending withdrawals from Eigenlayer, accounting for the amounts received, burning the appropriate amount of LRTs, and marking the epoch as settled. It does NOT increment the epoch counter for the asset - the only way to do that is in `settleCurrentEpoch()`, which is only called in `rebalance()` when there is enough present in the `depositPool` to cover withdrawals. \n\nAfter calling `settleEpochFromEigenLayer()`, the system is in a state where the current epoch has been marked as settled. However, while waiting for the 7 day Eigenlayer delay it is possible that more users sent withdrawal requests. These withdrawal requests would be queued for epoch 0 (and increment `sharesOwed` for epoch 0) , but were not considered when performing the withdrawal from Eigenlayer. There is no way to process these requests, as the epoch has already been settled + we can only call `queueCurrentEpochSettlement` once per epoch due to the `if (epochWithdrawals.aggregateRoot != bytes32(0)) revert WITHDRAWALS_ALREADY_QUEUED_FOR_EPOCH();` check\n\nNotably, users that requested withdrawals have already sent the LRT amount to be burned and are unable to reclaim their funds. \n\nAlso note that there is no access control on `settleEpochFromEigenLayer()`, so as long as the provided withdrawal parameters are correct anybody can call the function. \n\n## Impact\nCritical - system no longer operates, loss of users funds\n\n## Code Snippet\nThe following test can be dropped into `RioLRTWithdrawalQueue.t.sol`\n```solidity\n function test_lockAsset() public {\n        uint8 operatorId = addOperatorDelegator(reETH.operatorRegistry, address(reETH.rewardDistributor));\n        address operatorDelegator = reETH.operatorRegistry.getOperatorDetails(operatorId).delegator;\n\n        // Deposit ETH, rebalance, and verify the validator withdrawal credentials.\n        uint256 depositAmount = (ETH_DEPOSIT_SIZE - address(reETH.depositPool).balance);\n        uint256 withdrawalAmount = 10 ether;\n        assertGt(depositAmount, withdrawalAmount * 2); // We will be withdrawing twice\n        reETH.coordinator.depositETH{value: depositAmount}();\n        vm.prank(EOA, EOA);\n        reETH.coordinator.rebalance(ETH_ADDRESS);\n        uint40[] memory validatorIndices = verifyCredentialsForValidators(reETH.operatorRegistry, 1, 1);\n\n        // Request a withdrawal and rebalance to kick off the Eigenlayer withdrawal process\n        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, withdrawalAmount);\n        skip(reETH.coordinator.rebalanceDelay());\n        vm.prank(EOA, EOA);\n        reETH.coordinator.rebalance(ETH_ADDRESS);\n\n        // Ensure no reETH has been burned yet and process withdrawals.\n        assertEq(reETH.token.totalSupply(), ETH_DEPOSIT_SIZE);\n        verifyAndProcessWithdrawalsForValidatorIndexes(operatorDelegator, validatorIndices);\n\n        // Settle the withdrawal epoch. This marks the epoch as settled and\n        // makes the requested withdrawal amount available to be claimed.\n        uint256 withdrawalEpoch = reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS);\n        IDelegationManager.Withdrawal[] memory withdrawals = new IDelegationManager.Withdrawal[](1);\n        withdrawals[0] = IDelegationManager.Withdrawal({\n            staker: operatorDelegator,\n            delegatedTo: address(1),\n            withdrawer: address(reETH.withdrawalQueue),\n            nonce: 0,\n            startBlock: 1,\n            strategies: BEACON_CHAIN_STRATEGY.toArray(),\n            shares: withdrawalAmount.toArray()\n        });\n        reETH.withdrawalQueue.settleEpochFromEigenLayer(ETH_ADDRESS, withdrawalEpoch, withdrawals, new uint256[](1));\n\n        IRioLRTWithdrawalQueue.EpochWithdrawalSummary memory epochSummary =\n            reETH.withdrawalQueue.getEpochWithdrawalSummary(ETH_ADDRESS, withdrawalEpoch);\n        // Epoch is settled\n        assertTrue(epochSummary.settled);\n\n        // However, the epoch has not been incremented - we're still in epoch 0 even after settlement\n        assertEq(reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS), 0);\n\n        // We can still create new withdrawal requests for this epoch and increase sharesOwed\n        uint256 sharesOwedBefore = epochSummary.sharesOwed;\n        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, withdrawalAmount);\n        epochSummary = reETH.withdrawalQueue.getEpochWithdrawalSummary(ETH_ADDRESS, withdrawalEpoch);\n        // Shares owed has increased\n        assertGt(epochSummary.sharesOwed, sharesOwedBefore);\n\n        // We've received one withdrawalAmount worth of assets from Eigenlayer\n        assertEq(epochSummary.assetsReceived, withdrawalAmount);\n        assertEq(epochSummary.shareValueOfAssetsReceived, withdrawalAmount);\n\n        // Claim what was received from Eigenlayer (== one withdrawalAmount)\n        uint256 balanceBefore = address(this).balance;\n        uint256 amountOut = reETH.withdrawalQueue.claimWithdrawalsForEpoch(\n            IRioLRTWithdrawalQueue.ClaimRequest({asset: ETH_ADDRESS, epoch: withdrawalEpoch})\n        );\n        IRioLRTWithdrawalQueue.UserWithdrawalSummary memory userSummary =\n            reETH.withdrawalQueue.getUserWithdrawalSummary(ETH_ADDRESS, withdrawalEpoch, address(this));\n\n        // The user has been marked as Claimed for this epoch, even though only one withdrawalAmount worth was claimed\n        assertTrue(userSummary.claimed);\n        assertEq(amountOut, withdrawalAmount);\n        assertEq(address(this).balance - balanceBefore, withdrawalAmount);\n        // sharesOwed for this epoch is 2 withdrawals worth (we're sitll missing one)\n        assertEq(epochSummary.sharesOwed, withdrawalAmount * 2);\n\n        // We can't rebalance because withdrawals have already been queued for this epoch\n        // If we can't rebalance, we can't ever get to settleCurrentEpoch() to progress to the next epoch\n        skip(reETH.coordinator.rebalanceDelay());\n        vm.prank(EOA, EOA);\n        vm.expectRevert(0x9a641da5); // WITHDRAWALS_ALREADY_QUEUED_FOR_EPOCH\n        reETH.coordinator.rebalance(ETH_ADDRESS);\n\n        // Current epoch is still 0\n        assertEq(reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS), 0);\n\n        // Reverts in pre-checks because the epoch has been marked as settled\n        vm.expectRevert(0xad29946a); // EPOCH_ALREADY_SETTLED\n        reETH.withdrawalQueue.settleEpochFromEigenLayer(ETH_ADDRESS, withdrawalEpoch, withdrawals, new uint256[](1));\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider incrementing the current epoch as soon as the withdrawal process has been initiated, such that user withdrawal requests sent after an epoch has been queued for settlement will be considered a part of the next epoch\n\n\n\n## Discussion\n\n**solimander**\n\nValid bug - `currentEpochsByAsset[asset] += 1;` should be called in `queueCurrentEpochSettlement`.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/1.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTWithdrawalQueue is IRioLRTWithdrawalQueue, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using FixedPointMathLib for *;\n    using Asset for address;\n    using Array for *;\n\n    /// @notice The primary delegation contract for EigenLayer.\n    IDelegationManager public immutable delegationManager;\n\n    /// @notice Current asset withdrawal epochs. Incoming withdrawals are included\n    /// in the current epoch, which will be processed by the asset manager.\n    mapping(address asset => uint256 epoch) internal currentEpochsByAsset;\n\n    /// @notice The amount of assets owed to users in a given epoch, as well as the state\n    /// of the epoch's withdrawals.\n    mapping(address asset => mapping(uint256 epoch => EpochWithdrawals withdrawals)) internal epochWithdrawalsByAsset;\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    /// @param delegationManager_ The EigenLayer delegation manager.\n    constructor(address issuer_, address delegationManager_) RioLRTCore(issuer_) {\n        delegationManager = IDelegationManager(delegationManager_);\n    }\n\n    /// @notice Initializes the contract.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n    }\n\n    /// @notice Retrieve the current withdrawal epoch for a given asset.\n    /// @param asset The asset to retrieve the current epoch for.\n    function getCurrentEpoch(address asset) public view returns (uint256) {\n        return currentEpochsByAsset[asset];\n    }\n\n    /// @notice Get the amount of strategy shares owed to withdrawers in the current `epoch` for `asset`.\n    /// @param asset The withdrawal asset.\n    function getSharesOwedInCurrentEpoch(address asset) external view returns (uint256 sharesOwed) {\n        sharesOwed = _getEpochWithdrawals(asset, getCurrentEpoch(asset)).sharesOwed;\n    }\n\n    /// @notice Retrieve withdrawal epoch information for a given asset and epoch.\n    /// @param asset The withdrawal asset.\n    /// @param epoch The epoch for which to retrieve the information.\n    function getEpochWithdrawalSummary(address asset, uint256 epoch)\n        external\n        view\n        returns (EpochWithdrawalSummary memory)\n    {\n        EpochWithdrawals storage withdrawals = _getEpochWithdrawals(asset, epoch);\n        return EpochWithdrawalSummary({\n            settled: withdrawals.settled,\n            assetsReceived: withdrawals.assetsReceived,\n            shareValueOfAssetsReceived: withdrawals.shareValueOfAssetsReceived,\n            sharesOwed: withdrawals.sharesOwed,\n            amountToBurnAtSettlement: withdrawals.amountToBurnAtSettlement,\n            aggregateRoot: withdrawals.aggregateRoot\n        });\n    }\n\n    /// @notice Retrieve a user's withdrawal information for a given asset and epoch.\n    /// @param asset The withdrawal asset.\n    /// @param epoch The epoch for which to retrieve the information.\n    /// @param user The address of the user for which to retrieve the information.\n    function getUserWithdrawalSummary(address asset, uint256 epoch, address user)\n        external\n        view\n        returns (UserWithdrawalSummary memory)\n    {\n        return _getEpochWithdrawals(asset, epoch).users[user];\n    }\n\n    /// @notice Withdraws all `asset` owed to the caller in a given epoch.\n    /// @param request The asset claim request.\n    function claimWithdrawalsForEpoch(ClaimRequest calldata request) public returns (uint256 amountOut) {\n        address withdrawer = msg.sender;\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(request.asset, request.epoch);\n        if (!epochWithdrawals.settled) revert EPOCH_NOT_SETTLED();\n\n        UserWithdrawalSummary memory userSummary = epochWithdrawals.users[withdrawer];\n        if (userSummary.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (userSummary.claimed) revert WITHDRAWAL_ALREADY_CLAIMED();\n\n        epochWithdrawals.users[withdrawer].claimed = true;\n\n        amountOut = userSummary.sharesOwed.mulDiv(epochWithdrawals.assetsReceived, epochWithdrawals.sharesOwed);\n        request.asset.transferTo(withdrawer, amountOut);\n\n        emit WithdrawalsClaimedForEpoch(request.epoch, request.asset, withdrawer, amountOut);\n    }\n\n    /// @notice Withdraws owed assets owed to the caller from many withdrawal requests.\n    /// @param requests The withdrawal claim request.\n    function claimWithdrawalsForManyEpochs(ClaimRequest[] calldata requests)\n        external\n        returns (uint256[] memory amountsOut)\n    {\n        uint256 requestLength = requests.length;\n\n        amountsOut = new uint256[](requestLength);\n        for (uint256 i; i < requestLength; ++i) {\n            amountsOut[i] = claimWithdrawalsForEpoch(requests[i]);\n        }\n    }\n\n    /// @notice Queue `sharesOwed` of `asset` to `withdrawer` in the current epoch. These owed shares\n    /// can be claimed as the underlying asset by the withdrawer once the current epoch is settled.\n    /// @param withdrawer The address requesting the withdrawal.\n    /// @param asset The address of the asset being withdrawn.\n    /// @param sharesOwed The amount of shares owed to the withdrawer.\n    /// @param amountIn The amount of restaking tokens pulled from the withdrawer.\n    function queueWithdrawal(address withdrawer, address asset, uint256 sharesOwed, uint256 amountIn)\n        external\n        onlyCoordinator\n    {\n        if (sharesOwed == 0) revert NO_SHARES_OWED();\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        epochWithdrawals.sharesOwed += SafeCast.toUint120(sharesOwed);\n        epochWithdrawals.amountToBurnAtSettlement += amountIn;\n\n        UserWithdrawalSummary storage userSummary = epochWithdrawals.users[withdrawer];\n        userSummary.sharesOwed += SafeCast.toUint120(sharesOwed);\n\n        emit WithdrawalQueued(currentEpoch, asset, withdrawer, sharesOwed, amountIn);\n    }\n\n    /// @notice Settle the current epoch for `asset` using `assetsReceived` from the deposit pool.\n    /// @param asset The address of the withdrawal asset.\n    /// @param assetsReceived The amount of assets received to settle the epoch.\n    /// @param shareValueOfAssetsReceived The value of the assets received in EigenLayer shares.\n    function settleCurrentEpoch(address asset, uint256 assetsReceived, uint256 shareValueOfAssetsReceived)\n        external\n        onlyCoordinator\n    {\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n\n        epochWithdrawals.settled = true;\n        epochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived);\n        epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(shareValueOfAssetsReceived);\n\n        token.burn(epochWithdrawals.amountToBurnAtSettlement);\n        currentEpochsByAsset[asset] += 1;\n\n        emit EpochSettledFromDepositPool(currentEpoch, asset, assetsReceived);\n    }\n\n    /// @notice Queues the current epoch for `asset` settlement via EigenLayer and record\n    /// the amount of assets received from the deposit pool.\n    /// @param asset The address of the withdrawal asset.\n    /// @param assetsReceived The amount of assets received from the deposit pool.\n    /// @param shareValueOfAssetsReceived The value of the assets received in EigenLayer shares.\n    /// @param aggregateRoot The aggregate root of the queued EigenLayer withdrawals.\n    function queueCurrentEpochSettlement(\n        address asset,\n        uint256 assetsReceived,\n        uint256 shareValueOfAssetsReceived,\n        bytes32 aggregateRoot\n    ) external onlyCoordinator {\n        if (aggregateRoot == bytes32(0)) revert INVALID_AGGREGATE_WITHDRAWAL_ROOT();\n\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        if (epochWithdrawals.aggregateRoot != bytes32(0)) revert WITHDRAWALS_ALREADY_QUEUED_FOR_EPOCH();\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n\n        uint256 restakingTokensToBurn;\n        if (assetsReceived > 0) {\n            epochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived);\n            epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(shareValueOfAssetsReceived);\n\n            restakingTokensToBurn = epochWithdrawals.amountToBurnAtSettlement.mulWad(\n                shareValueOfAssetsReceived.divWad(epochWithdrawals.sharesOwed)\n            );\n            token.burn(restakingTokensToBurn);\n\n            epochWithdrawals.amountToBurnAtSettlement -= restakingTokensToBurn;\n        }\n        epochWithdrawals.aggregateRoot = aggregateRoot;\n\n        emit EpochQueuedForSettlementFromEigenLayer(\n            currentEpoch, asset, assetsReceived, shareValueOfAssetsReceived, restakingTokensToBurn, aggregateRoot\n        );\n    }\n\n    /// @notice Settle `epoch` for `asset` using `queuedWithdrawals` from EigenLayer.\n    /// @param asset The address of the withdrawal asset.\n    /// @param epoch The epoch to settle.\n    /// @param queuedWithdrawals The queued withdrawals from EigenLayer.\n    /// @param middlewareTimesIndexes The middleware times indexes for the queued withdrawals.\n    function settleEpochFromEigenLayer(\n        address asset,\n        uint256 epoch,\n        IDelegationManager.Withdrawal[] calldata queuedWithdrawals,\n        uint256[] calldata middlewareTimesIndexes\n    ) external {\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, epoch);\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n        if (epochWithdrawals.aggregateRoot == bytes32(0)) revert WITHDRAWALS_NOT_QUEUED_FOR_EPOCH();\n\n        uint256 queuedWithdrawalCount = queuedWithdrawals.length;\n        if (queuedWithdrawalCount != middlewareTimesIndexes.length) revert INVALID_MIDDLEWARE_TIMES_INDEXES_LENGTH();\n\n        epochWithdrawals.settled = true;\n\n        // forgefmt: disable-next-item\n        uint256 sharesReceivedDuringSettlement = epochWithdrawals.sharesOwed - epochWithdrawals.shareValueOfAssetsReceived;\n\n        // If not ETH, decrease the shares held for the asset. The decrease in queued ETH is\n        // handled on a per-operator basis below.\n        if (asset != ETH_ADDRESS) {\n            assetRegistry().decreaseSharesHeldForAsset(asset, sharesReceivedDuringSettlement);\n        }\n        token.burn(epochWithdrawals.amountToBurnAtSettlement);\n\n        uint256 balanceBefore = asset.getSelfBalance();\n\n        address[] memory assets = asset.toArray();\n        bytes32[] memory roots = new bytes32[](queuedWithdrawalCount);\n\n        IDelegationManager.Withdrawal memory queuedWithdrawal;\n        for (uint256 i; i < queuedWithdrawalCount; ++i) {\n            queuedWithdrawal = queuedWithdrawals[i];\n\n            roots[i] = _computeWithdrawalRoot(queuedWithdrawal);\n            delegationManager.completeQueuedWithdrawal(queuedWithdrawal, assets, middlewareTimesIndexes[i], true);\n\n            // Decrease the amount of ETH queued for withdrawal. We do not need to validate the staker as\n            // the aggregate root will be validated below.\n            if (asset == ETH_ADDRESS) {\n                IRioLRTOperatorDelegator(queuedWithdrawal.staker).decreaseETHQueuedForUserSettlement(\n                    queuedWithdrawal.shares[0]\n                );\n            }\n        }\n        if (epochWithdrawals.aggregateRoot != keccak256(abi.encode(roots))) {\n            revert INVALID_AGGREGATE_WITHDRAWAL_ROOT();\n        }\n        epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(epochWithdrawals.sharesOwed);\n\n        uint256 assetsReceived = asset.getSelfBalance() - balanceBefore;\n        epochWithdrawals.assetsReceived += SafeCast.toUint120(assetsReceived);\n\n        emit EpochSettledFromEigenLayer(epoch, asset, assetsReceived);\n    }\n\n    /// @dev Receives ETH for withdrawals.\n    receive() external payable {}\n\n    /// @dev Returns the keccak256 hash of `withdrawal`.\n    /// @param withdrawal The withdrawal.\n    function _computeWithdrawalRoot(IDelegationManager.Withdrawal memory withdrawal) public pure returns (bytes32) {\n        return keccak256(abi.encode(withdrawal));\n    }\n\n    function _getEpochWithdrawals(address asset, uint256 epoch) internal view returns (EpochWithdrawals storage) {\n        return epochWithdrawalsByAsset[asset][epoch];\n    }\n\n    /// @dev Allows the owner to upgrade the withdrawal queue implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    }
  ]
}