{
  "Title": "H-1: supplyNativeToken will strand ETH in contract if called after ACTION_DEFER_LIQUIDITY_CHECK",
  "Content": "# Issue H-1: supplyNativeToken will strand ETH in contract if called after ACTION_DEFER_LIQUIDITY_CHECK \n\nSource: https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/361 \n\n## Found by \n0x52, CMierez, evilakela\n## Summary\n\nsupplyNativeToken deposits msg.value to the WETH contract. This is very problematic if it is called after ACTION_DEFER_LIQUIDITY_CHECK. Since onDeferredLiqudityCheck creates a new context msg.value will be 0 and no ETH will actually be deposited for the user, causing funds to be stranded in the contract. \n\n## Vulnerability Detail\n\n[TxBuilderExtension.sol#L252-L256](https://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/extensions/TxBuilderExtension.sol#L252-L256)\n\n    function supplyNativeToken(address user) internal nonReentrant {\n        WethInterface(weth).deposit{value: msg.value}();\n        IERC20(weth).safeIncreaseAllowance(address(ironBank), msg.value);\n        ironBank.supply(address(this), user, weth, msg.value);\n    }\n\nsupplyNativeToken uses the context sensitive msg.value to determine how much ETH to send to convert to WETH. After ACTION_DEFER_LIQUIDITY_CHECK is called, it enters a new context in which msg.value is always 0. We can outline the execution path to see where this happens:\n\n`execute > executeInteral > deferLiquidityCheck > ironBank.deferLiquidityCheck > onDeferredLiquidityCheck (new context) > executeInternal > supplyNativeToken`\n\nWhen IronBank makes it's callback to TxBuilderExtension it creates a new context. Since the ETH is not sent along to this new context, msg.value will always be 0. Which will result in no ETH being deposited and the sent ether is left in the contract.\n\nAlthough these funds can be recovered by the admin, it may can easily cause the user to be unfairly liquidated in the meantime since a (potentially significant) portion of their collateral hasn't been deposited. Additionally in conjunction with my other submission on ownable not being initialized correctly, the funds would be completely unrecoverable due to lack of owner.\n\n## Impact\n\nUser funds are indefinitely (potentially permanently) stuck in the contract. Users may be unfairly liquidated due to their collateral not depositing.\n\n## Code Snippet\n\n[TxBuilderExtension.sol#L252-L256](https://github.com/sherlock-audit/2023-05-ironbank/blob/main/ib-v2/src/extensions/TxBuilderExtension.sol#L252-L256)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nmsg.value should be cached at the beginning of the function to preserve it across contexts\n\n\n\n## Discussion\n\n**ibsunhub**\n\nConfirm the issue!\n\nHowever, we believe the correct modification is to pass `msg.value` through the whole external call and make `deferLiquidityCheck` function payable.\n\n**0xffff11**\n\nValid high. I also think the fix from sponsor is most accurate.\n\n**IAm0x52**\n\nPassing through `msg.value` will result in it being nonfunctional in the event that `supplyNativeToken` is called before `ACTION_DEFER_LIQUIDITY_CHECK` since it will deposit msg.value into WETH. Then when it calls `deferLiquidityCheck` it would again attempt to send `msg.value` which would cause it to revert due to lack of funds. \n\nMy suggestion would be to cache msg.value as an internal storage variable (i.e. _msgValue) at the beginning of [execute](https://github.com/sherlock-audit/2023-05-ironbank/blob/9ebf1702b2163b55479624794ab7999392367d2a/ib-v2/src/extensions/TxBuilderExtension.sol#L101). Adjust [supplyNativeToken](https://github.com/sherlock-audit/2023-05-ironbank/blob/9ebf1702b2163b55479624794ab7999392367d2a/ib-v2/src/extensions/TxBuilderExtension.sol#L253-L255) to use that storage variable rather than `msg.value`. After the supply to ironBank reset this variable to 0. This allows you to preserve the msg.value across all contexts\n\n**ibsunhub**\n\nThe situation mentioned is same with #192.\nThe solution sounds viable and better. Will work on a fix according to the recommendation.\n\n**0xffff11**\n\n@ibsunhub  You mean that #192 should be a dup of this one?\n\n**ibsunhub**\n\nNo, just think they are related.\n\n**iamjakethehuman**\n\nEscalate for 10 USDC\nI believe this issue to be of Medium Severity. Here's why:\n1.  It is valid for one asset only (ETH)\n2.  It requires to call two specific operations and in a specific order in order for the issue to occur\n3. The lost ETH can be rescued by the owner of the protocol (we do not take into consideration there is a vulnerability the eth can be stolen by adversary as the Watson has both not mentioned it, nor reported it separately)\n4. The biggest loss that can occur is getting liquidated. This would be the case if the user has no more assets to still supply their account. And even if liquidation is to occur, in worst case scenario, they'd lose up to just 20% of their portfolio in IronBank (max liquidation bonus = 125%, `(125-100)/125 = 20%`.\nWith all these external factors, considering in many cases there would be no loss of funds whatsoever and just in a tiny bit of them there would be a loss of 20%, I believe this to be of Medium severity.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I believe this issue to be of Medium Severity. Here's why:\n> 1.  It is valid for one asset only (ETH)\n> 2.  It requires to call two specific operations and in a specific order in order for the issue to occur\n> 3. The lost ETH can be rescued by the owner of the protocol (we do not take into consideration there is a vulnerability the eth can be stolen by adversary as the Watson has both not mentioned it, nor reported it separately)\n> 4. The biggest loss that can occur is getting liquidated. This would be the case if the user has no more assets to still supply their account. And even if liquidation is to occur, in worst case scenario, they'd lose up to just 20% of their portfolio in IronBank (max liquidation bonus = 125%, `(125-100)/125 = 20%`.\n> With all these external factors, considering in many cases there would be no loss of funds whatsoever and just in a tiny bit of them there would be a loss of 20%, I believe this to be of Medium severity.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ibsunhub**\n\n> The situation mentioned is same with #192. The solution sounds viable and better. Will work on a fix according to the recommendation.\n\nSorry, I mean #198 related to this issue, not #192 .\n\n**C-Mierez**\n\nMy two cents on iamjakethehuman 's escalation.\n> 2. It requires to call two specific operations and in a specific order in order for the issue to occur\n\nI would argue that this set of actions is not \"too\" specific. Deferring liquidity is done to avoid wasting gas by executing `IronBank#_getAccountLiquidity()` multiple times, so you always want to call this at the beginning before performing all other actions (This behaviour/order can even be seen in [`TestTxBuilderExtension_integration.t.sol`](https://github.com/sherlock-audit/2023-05-ironbank-C-Mierez/blob/16ca5d48b856d51bea17cd23dd4161bb2c7470b4/ib-v2/test/extensions/TestTxBuilderExtension_integration.t.sol#L558-L562) as well). Thus having `ACTION_DEFER_LIQUIDITY_CHECK` before any of the problematic `ACTION_X_NATIVE_TOKEN` actions is not far fetched at all, imo.\n\n> 3. The lost ETH can be rescued by the owner of the protocol (we do not take into consideration there is a vulnerability the eth can be stolen by adversary as the Watson has both not mentioned it, nor reported it separately)\n\nI explored this possibility in my own report (#368 ), and I don't think we should just ignore the fact that the ETH stuck in the contract can be stolen. If the ETH were safe then this would just be an inconvenience until the owner comes in, but both facts together create a vector in which the user ***can*** lose their funds without virtually any cost or risk on the malicious actor's side, all due to this implementation flaw on `TxBuilderExtender`\n\n**ib-tycho**\n\nhttps://github.com/ibdotxyz/ib-v2/pull/53\n\n**0xffff11**\n\nThanks for both comments. Imo this issue should be high. I agree, that it is quite likely for it to happen. \n\n'''\nDeferring liquidity is done to avoid wasting gas by executing IronBank#_getAccountLiquidity() multiple times, so you always want to call this at the beginning before performing all other actions (This behaviour/order can even be seen in [TestTxBuilderExtension_integration.t.sol](https://github.com/sherlock-audit/2023-05-ironbank-C-Mierez/blob/16ca5d48b856d51bea17cd23dd4161bb2c7470b4/ib-v2/test/extensions/TestTxBuilderExtension_integration.t.sol#L558-L562) as well).\n'''\nSponsor has also confirmed. This being said, to fully tie together the eth reports, the issue https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/198 should now be valid imo as a medium. Because eth can in fact get stuck in the contract. So I would say, for this issue, keep it as a high and upgrade https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/198 to medium\n\n**ibsunhub**\n\nfix: https://github.com/ibdotxyz/ib-v2/pull/53\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nAffecting only one token can still be a valid high, the given order of operations is not an unlikely scenario. And since this break the assumption of these contracts should not hold eth + it can be stolen as shown in #368,\nMaintaining the severity as is. \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [iamjakethehuman](https://github.com/sherlock-audit/2023-05-ironbank-judging/issues/361/#issuecomment-1608985592): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/84",
  "Code": [
    {
      "filename": "ib-v2/src/extensions/TxBuilderExtension.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/DeferLiquidityCheckInterface.sol\";\nimport \"../interfaces/IronBankInterface.sol\";\nimport \"../interfaces/PTokenInterface.sol\";\nimport \"./interfaces/WethInterface.sol\";\nimport \"./interfaces/WstEthInterface.sol\";\n\ncontract TxBuilderExtension is ReentrancyGuard, Ownable2Step, DeferLiquidityCheckInterface {\n    using SafeERC20 for IERC20;\n\n    /// @notice The action for deferring liquidity check\n    bytes32 public constant ACTION_DEFER_LIQUIDITY_CHECK = \"ACTION_DEFER_LIQUIDITY_CHECK\";\n\n    /// @notice The action for supplying asset\n    bytes32 public constant ACTION_SUPPLY = \"ACTION_SUPPLY\";\n\n    /// @notice The action for borrowing asset\n    bytes32 public constant ACTION_BORROW = \"ACTION_BORROW\";\n\n    /// @notice The action for redeeming asset\n    bytes32 public constant ACTION_REDEEM = \"ACTION_REDEEM\";\n\n    /// @notice The action for repaying asset\n    bytes32 public constant ACTION_REPAY = \"ACTION_REPAY\";\n\n    /// @notice The action for supplying native token\n    bytes32 public constant ACTION_SUPPLY_NATIVE_TOKEN = \"ACTION_SUPPLY_NATIVE_TOKEN\";\n\n    /// @notice The action for borrowing native token\n    bytes32 public constant ACTION_BORROW_NATIVE_TOKEN = \"ACTION_BORROW_NATIVE_TOKEN\";\n\n    /// @notice The action for redeeming native token\n    bytes32 public constant ACTION_REDEEM_NATIVE_TOKEN = \"ACTION_REDEEM_NATIVE_TOKEN\";\n\n    /// @notice The action for repaying native token\n    bytes32 public constant ACTION_REPAY_NATIVE_TOKEN = \"ACTION_REPAY_NATIVE_TOKEN\";\n\n    /// @notice The action for supplying stEth\n    bytes32 public constant ACTION_SUPPLY_STETH = \"ACTION_SUPPLY_STETH\";\n\n    /// @notice The action for borrowing stEth\n    bytes32 public constant ACTION_BORROW_STETH = \"ACTION_BORROW_STETH\";\n\n    /// @notice The action for redeeming stEth\n    bytes32 public constant ACTION_REDEEM_STETH = \"ACTION_REDEEM_STETH\";\n\n    /// @notice The action for repaying stEth\n    bytes32 public constant ACTION_REPAY_STETH = \"ACTION_REPAY_STETH\";\n\n    /// @notice The action for supplying pToken\n    bytes32 public constant ACTION_SUPPLY_PTOKEN = \"ACTION_SUPPLY_PTOKEN\";\n\n    /// @notice The action for redeeming pToken\n    bytes32 public constant ACTION_REDEEM_PTOKEN = \"ACTION_REDEEM_PTOKEN\";\n\n    /// @notice The address of IronBank\n    IronBankInterface public immutable ironBank;\n\n    /// @notice The address of WETH\n    address public immutable weth;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    /**\n     * @notice Construct a new TxBuilderExtension contract\n     * @param ironBank_ The IronBank contract\n     * @param weth_ The WETH contract\n     * @param steth_ The Lido staked ETH contract\n     * @param wsteth_ The Lido wrapped staked ETH contract\n     */\n    constructor(address ironBank_, address weth_, address steth_, address wsteth_) {\n        ironBank = IronBankInterface(ironBank_);\n        weth = weth_;\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    struct Action {\n        bytes32 name;\n        bytes data;\n    }\n\n    /**\n     * @notice Execute a list of actions in order\n     * @param actions The list of actions\n     */\n    function execute(Action[] calldata actions) external payable {\n        executeInternal(msg.sender, actions, 0);\n    }\n\n    /// @inheritdoc DeferLiquidityCheckInterface\n    function onDeferredLiquidityCheck(bytes memory encodedData) external override {\n        require(msg.sender == address(ironBank), \"untrusted message sender\");\n\n        (address initiator, Action[] memory actions, uint256 index) =\n            abi.decode(encodedData, (address, Action[], uint256));\n        executeInternal(initiator, actions, index);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /**\n     * @notice Admin seizes the asset from the contract.\n     * @param recipient The recipient of the seized asset.\n     * @param asset The asset to seize.\n     */\n    function seize(address recipient, address asset) external onlyOwner {\n        IERC20(asset).safeTransfer(recipient, IERC20(asset).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Admin seizes the native token from the contract.\n     * @param recipient The recipient of the seized native token.\n     */\n    function seizeNative(address recipient) external onlyOwner {\n        (bool sent,) = recipient.call{value: address(this).balance}(\"\");\n        require(sent, \"failed to send native token\");\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /**\n     * @dev Execute a list of actions for user in order.\n     * @param user The address of the user\n     * @param actions The list of actions\n     * @param index The index of the action to start with\n     */\n    function executeInternal(address user, Action[] memory actions, uint256 index) internal {\n        for (uint256 i = index; i < actions.length;) {\n            Action memory action = actions[i];\n            if (action.name == ACTION_DEFER_LIQUIDITY_CHECK) {\n                deferLiquidityCheck(user, abi.encode(user, actions, i + 1));\n\n                // Break the loop as we will re-enter the loop after the liquidity check is deferred.\n                break;\n            } else if (action.name == ACTION_SUPPLY) {\n                (address asset, uint256 amount) = abi.decode(action.data, (address, uint256));\n                supply(user, asset, amount);\n            } else if (action.name == ACTION_BORROW) {\n                (address asset, uint256 amount) = abi.decode(action.data, (address, uint256));\n                borrow(user, asset, amount);\n            } else if (action.name == ACTION_REDEEM) {\n                (address asset, uint256 amount) = abi.decode(action.data, (address, uint256));\n                redeem(user, asset, amount);\n            } else if (action.name == ACTION_REPAY) {\n                (address asset, uint256 amount) = abi.decode(action.data, (address, uint256));\n                repay(user, asset, amount);\n            } else if (action.name == ACTION_SUPPLY_NATIVE_TOKEN) {\n                supplyNativeToken(user);\n            } else if (action.name == ACTION_BORROW_NATIVE_TOKEN) {\n                uint256 borrowAmount = abi.decode(action.data, (uint256));\n                borrowNativeToken(user, borrowAmount);\n            } else if (action.name == ACTION_REDEEM_NATIVE_TOKEN) {\n                uint256 redeemAmount = abi.decode(action.data, (uint256));\n                redeemNativeToken(user, redeemAmount);\n            } else if (action.name == ACTION_REPAY_NATIVE_TOKEN) {\n                repayNativeToken(user);\n            } else if (action.name == ACTION_SUPPLY_STETH) {\n                uint256 amount = abi.decode(action.data, (uint256));\n                supplyStEth(user, amount);\n            } else if (action.name == ACTION_BORROW_STETH) {\n                uint256 amount = abi.decode(action.data, (uint256));\n                borrowStEth(user, amount);\n            } else if (action.name == ACTION_REDEEM_STETH) {\n                uint256 amount = abi.decode(action.data, (uint256));\n                redeemStEth(user, amount);\n            } else if (action.name == ACTION_REPAY_STETH) {\n                uint256 amount = abi.decode(action.data, (uint256));\n                repayStEth(user, amount);\n            } else if (action.name == ACTION_SUPPLY_PTOKEN) {\n                (address pToken, uint256 amount) = abi.decode(action.data, (address, uint256));\n                supplyPToken(user, pToken, amount);\n            } else if (action.name == ACTION_REDEEM_PTOKEN) {\n                (address pToken, uint256 amount) = abi.decode(action.data, (address, uint256));\n                redeemPToken(user, pToken, amount);\n            } else {\n                revert(\"invalid action\");\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @dev Defers the liquidity check.\n     * @param user The address of the user\n     * @param data The encoded data\n     */\n    function deferLiquidityCheck(address user, bytes memory data) internal {\n        ironBank.deferLiquidityCheck(user, data);\n    }\n\n    /**\n     * @dev Supplies the asset to Iron Bank.\n     * @param user The address of the user\n     * @param asset The address of the asset to supply\n     * @param amount The amount of the asset to supply\n     */\n    function supply(address user, address asset, uint256 amount) internal nonReentrant {\n        ironBank.supply(user, user, asset, amount);\n    }\n\n    /**\n     * @dev Borrows the asset from Iron Bank.\n     * @param user The address of the user\n     * @param asset The address of the asset to borrow\n     * @param amount The amount of the asset to borrow\n     */\n    function borrow(address user, address asset, uint256 amount) internal nonReentrant {\n        ironBank.borrow(user, user, asset, amount);\n    }\n\n    /**\n     * @dev Redeems the asset to Iron Bank.\n     * @param user The address of the user\n     * @param asset The address of the asset to redeem\n     * @param amount The amount of the asset to redeem\n     */\n    function redeem(address user, address asset, uint256 amount) internal nonReentrant {\n        ironBank.redeem(user, user, asset, amount);\n    }\n\n    /**\n     * @dev Repays the asset to Iron Bank.\n     * @param user The address of the user\n     * @param asset The address of the asset to repay\n     * @param amount The amount of the asset to repay\n     */\n    function repay(address user, address asset, uint256 amount) internal nonReentrant {\n        ironBank.repay(user, user, asset, amount);\n    }\n\n    /**\n     * @dev Wraps the native token and supplies it to Iron Bank.\n     * @param user The address of the user\n     */\n    function supplyNativeToken(address user) internal nonReentrant {\n        WethInterface(weth).deposit{value: msg.value}();\n        IERC20(weth).safeIncreaseAllowance(address(ironBank), msg.value);\n        ironBank.supply(address(this), user, weth, msg.value);\n    }\n\n    /**\n     * @dev Borrows the wrapped native token and unwraps it to the user.\n     * @param user The address of the user\n     * @param borrowAmount The amount of the wrapped native token to borrow\n     */\n    function borrowNativeToken(address user, uint256 borrowAmount) internal nonReentrant {\n        ironBank.borrow(user, address(this), weth, borrowAmount);\n        WethInterface(weth).withdraw(borrowAmount);\n        (bool sent,) = user.call{value: borrowAmount}(\"\");\n        require(sent, \"failed to send native token\");\n    }\n\n    /**\n     * @dev Redeems the wrapped native token and unwraps it to the user.\n     * @param user The address of the user\n     * @param redeemAmount The amount of the wrapped native token to redeem, -1 means redeem all\n     */\n    function redeemNativeToken(address user, uint256 redeemAmount) internal nonReentrant {\n        if (redeemAmount == type(uint256).max) {\n            redeemAmount = ironBank.getSupplyBalance(user, weth);\n        }\n        ironBank.redeem(user, address(this), weth, redeemAmount);\n        WethInterface(weth).withdraw(redeemAmount);\n        (bool sent,) = user.call{value: redeemAmount}(\"\");\n        require(sent, \"failed to send native token\");\n    }\n\n    /**\n     * @dev Wraps the native token and repays it to Iron Bank.\n     * @dev If the amount of the native token is greater than the borrow balance, the excess amount will be sent back to the user.\n     * @param user The address of the user\n     */\n    function repayNativeToken(address user) internal nonReentrant {\n        uint256 repayAmount = msg.value;\n\n        ironBank.accrueInterest(weth);\n        uint256 borrowBalance = ironBank.getBorrowBalance(user, weth);\n        if (repayAmount > borrowBalance) {\n            WethInterface(weth).deposit{value: borrowBalance}();\n            IERC20(weth).safeIncreaseAllowance(address(ironBank), borrowBalance);\n            ironBank.repay(address(this), user, weth, borrowBalance);\n            (bool sent,) = user.call{value: repayAmount - borrowBalance}(\"\");\n            require(sent, \"failed to send native token\");\n        } else {\n            WethInterface(weth).deposit{value: repayAmount}();\n            IERC20(weth).safeIncreaseAllowance(address(ironBank), repayAmount);\n            ironBank.repay(address(this), user, weth, repayAmount);\n        }\n    }\n\n    /**\n     * @dev Wraps the stEth and supplies wstEth to Iron Bank.\n     * @param user The address of the user\n     * @param stEthAmount The amount of the stEth to supply\n     */\n    function supplyStEth(address user, uint256 stEthAmount) internal nonReentrant {\n        IERC20(steth).safeTransferFrom(user, address(this), stEthAmount);\n        IERC20(steth).safeIncreaseAllowance(wsteth, stEthAmount);\n        uint256 wstEthAmount = WstEthInterface(wsteth).wrap(stEthAmount);\n        IERC20(wsteth).safeIncreaseAllowance(address(ironBank), wstEthAmount);\n        ironBank.supply(address(this), user, wsteth, wstEthAmount);\n    }\n\n    /**\n     * @dev Borrows the wstEth and unwraps it to the user.\n     * @param user The address of the user\n     * @param stEthAmount The amount of the stEth to borrow\n     */\n    function borrowStEth(address user, uint256 stEthAmount) internal nonReentrant {\n        uint256 wstEthAmount = WstEthInterface(wsteth).getWstETHByStETH(stEthAmount);\n        ironBank.borrow(user, address(this), wsteth, wstEthAmount);\n        uint256 unwrappedStEthAmount = WstEthInterface(wsteth).unwrap(wstEthAmount);\n        IERC20(steth).safeTransfer(user, unwrappedStEthAmount);\n    }\n\n    /**\n     * @dev Redeems the wstEth and unwraps it to the user.\n     * @param user The address of the user\n     * @param stEthAmount The amount of the stEth to redeem, -1 means redeem all\n     */\n    function redeemStEth(address user, uint256 stEthAmount) internal nonReentrant {\n        uint256 wstEthAmount;\n        if (stEthAmount == type(uint256).max) {\n            ironBank.accrueInterest(wsteth);\n            wstEthAmount = ironBank.getSupplyBalance(user, wsteth);\n        } else {\n            wstEthAmount = WstEthInterface(wsteth).getWstETHByStETH(stEthAmount);\n        }\n        ironBank.redeem(user, address(this), wsteth, wstEthAmount);\n        uint256 unwrappedStEthAmount = WstEthInterface(wsteth).unwrap(wstEthAmount);\n        IERC20(steth).safeTransfer(user, unwrappedStEthAmount);\n    }\n\n    /**\n     * @dev Wraps the stEth and repays wstEth to Iron Bank.\n     * @param user The address of the user\n     * @param stEthAmount The amount of the stEth to repay, -1 means repay all\n     */\n    function repayStEth(address user, uint256 stEthAmount) internal nonReentrant {\n        if (stEthAmount == type(uint256).max) {\n            ironBank.accrueInterest(wsteth);\n            uint256 borrowBalance = ironBank.getBorrowBalance(user, wsteth);\n            stEthAmount = WstEthInterface(wsteth).getStETHByWstETH(borrowBalance) + 1; // add 1 to avoid rounding issue\n        }\n\n        IERC20(steth).safeTransferFrom(user, address(this), stEthAmount);\n        IERC20(steth).safeIncreaseAllowance(wsteth, stEthAmount);\n        uint256 wstEthAmount = WstEthInterface(wsteth).wrap(stEthAmount);\n        IERC20(wsteth).safeIncreaseAllowance(address(ironBank), wstEthAmount);\n        ironBank.repay(address(this), user, wsteth, wstEthAmount);\n    }\n\n    /**\n     * @dev Wraps the underlying and supplies the pToken to Iron Bank.\n     * @param user The address of the user\n     * @param pToken The address of the pToken\n     * @param amount The amount of the pToken to supply\n     */\n    function supplyPToken(address user, address pToken, uint256 amount) internal nonReentrant {\n        address underlying = PTokenInterface(pToken).getUnderlying();\n        IERC20(underlying).safeTransferFrom(user, pToken, amount);\n        PTokenInterface(pToken).absorb(address(this));\n        IERC20(pToken).safeIncreaseAllowance(address(ironBank), amount);\n        ironBank.supply(address(this), user, pToken, amount);\n    }\n\n    /**\n     * @dev Redeems the pToken and unwraps the underlying to the user.\n     * @param user The address of the user\n     * @param pToken The address of the pToken\n     * @param amount The amount of the pToken to redeem\n     */\n    function redeemPToken(address user, address pToken, uint256 amount) internal nonReentrant {\n        if (amount == type(uint256).max) {\n            ironBank.accrueInterest(pToken);\n            amount = ironBank.getSupplyBalance(user, pToken);\n        }\n        ironBank.redeem(user, address(this), pToken, amount);\n        PTokenInterface(pToken).unwrap(amount);\n        address underlying = PTokenInterface(pToken).getUnderlying();\n        IERC20(underlying).safeTransfer(user, amount);\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "ib-v2/src/extensions/TxBuilderExtension.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/access/Ownable2Step.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/DeferLiquidityCheckInterface.sol\";\nimport \"../interfaces/IronBankInterface.sol\";\nimport \"../interfaces/PTokenInterface.sol\";\nimport \"./interfaces/WethInterface.sol\";\nimport \"./interfaces/WstEthInterface.sol\";\n\ncontract TxBuilderExtension is ReentrancyGuard, Ownable2Step, DeferLiquidityCheckInterface {\n    using SafeERC20 for IERC20;\n\n    /// @notice The action for deferring liquidity check\n    bytes32 public constant ACTION_DEFER_LIQUIDITY_CHECK = \"ACTION_DEFER_LIQUIDITY_CHECK\";\n\n    /// @notice The action for supplying asset\n    bytes32 public constant ACTION_SUPPLY = \"ACTION_SUPPLY\";\n\n    /// @notice The action for borrowing asset\n    bytes32 public constant ACTION_BORROW = \"ACTION_BORROW\";\n\n    /// @notice The action for redeeming asset\n    bytes32 public constant ACTION_REDEEM = \"ACTION_REDEEM\";\n\n    /// @notice The action for repaying asset\n    bytes32 public constant ACTION_REPAY = \"ACTION_REPAY\";\n\n    /// @notice The action for supplying native token\n    bytes32 public constant ACTION_SUPPLY_NATIVE_TOKEN = \"ACTION_SUPPLY_NATIVE_TOKEN\";\n\n    /// @notice The action for borrowing native token\n    bytes32 public constant ACTION_BORROW_NATIVE_TOKEN = \"ACTION_BORROW_NATIVE_TOKEN\";\n\n    /// @notice The action for redeeming native token\n    bytes32 public constant ACTION_REDEEM_NATIVE_TOKEN = \"ACTION_REDEEM_NATIVE_TOKEN\";\n\n    /// @notice The action for repaying native token\n    bytes32 public constant ACTION_REPAY_NATIVE_TOKEN = \"ACTION_REPAY_NATIVE_TOKEN\";\n\n    /// @notice The action for supplying stEth\n    bytes32 public constant ACTION_SUPPLY_STETH = \"ACTION_SUPPLY_STETH\";\n\n    /// @notice The action for borrowing stEth\n    bytes32 public constant ACTION_BORROW_STETH = \"ACTION_BORROW_STETH\";\n\n    /// @notice The action for redeeming stEth\n    bytes32 public constant ACTION_REDEEM_STETH = \"ACTION_REDEEM_STETH\";\n\n    /// @notice The action for repaying stEth\n    bytes32 public constant ACTION_REPAY_STETH = \"ACTION_REPAY_STETH\";\n\n    /// @notice The action for supplying pToken\n    bytes32 public constant ACTION_SUPPLY_PTOKEN = \"ACTION_SUPPLY_PTOKEN\";\n\n    /// @notice The action for redeeming pToken\n    bytes32 public constant ACTION_REDEEM_PTOKEN = \"ACTION_REDEEM_PTOKEN\";\n\n    /// @notice The address of IronBank\n    IronBankInterface public immutable ironBank;\n\n    /// @notice The address of WETH\n    address public immutable weth;\n\n    /// @notice The address of Lido staked ETH\n    address public immutable steth;\n\n    /// @notice The address of Lido wrapped staked ETH\n    address public immutable wsteth;\n\n    /**\n     * @notice Construct a new TxBuilderExtension contract\n     * @param ironBank_ The IronBank contract\n     * @param weth_ The WETH contract\n     * @param steth_ The Lido staked ETH contract\n     * @param wsteth_ The Lido wrapped staked ETH contract\n     */\n    constructor(address ironBank_, address weth_, address steth_, address wsteth_) {\n        ironBank = IronBankInterface(ironBank_);\n        weth = weth_;\n        steth = steth_;\n        wsteth = wsteth_;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    struct Action {\n        bytes32 name;\n        bytes data;\n    }\n\n    /**\n     * @notice Execute a list of actions in order\n     * @param actions The list of actions\n     */\n    function execute(Action[] calldata actions) external payable {\n        executeInternal(msg.sender, actions, 0);\n    }\n\n    /// @inheritdoc DeferLiquidityCheckInterface\n    function onDeferredLiquidityCheck(bytes memory encodedData) external override {\n        require(msg.sender == address(ironBank), \"untrusted message sender\");\n\n        (address initiator, Action[] memory actions, uint256 index) =\n            abi.decode(encodedData, (address, Action[], uint256));\n        executeInternal(initiator, actions, index);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /**\n     * @notice Admin seizes the asset from the contract.\n     * @param recipient The recipient of the seized asset.\n     * @param asset The asset to seize.\n     */\n    function seize(address recipient, address asset) external onlyOwner {\n        IERC20(asset).safeTransfer(recipient, IERC20(asset).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Admin seizes the native token from the contract.\n     * @param recipient The recipient of the seized native token.\n     */\n    function seizeNative(address recipient) external onlyOwner {\n        (bool sent,) = recipient.call{value: address(this).balance}(\"\");\n        require(sent, \"failed to send native token\");\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /**\n     * @dev Execute a list of actions for user in order.\n     * @param user The address of the user\n     * @param actions The list of actions\n     * @param index The index of the action to start with\n     */\n    function executeInternal(address user, Action[] memory actions, uint256 index) internal {\n        for (uint256 i = index; i < actions.length;) {\n            Action memory action = actions[i];\n            if (action.name == ACTION_DEFER_LIQUIDITY_CHECK) {\n                deferLiquidityCheck(user, abi.encode(user, actions, i + 1));\n\n                // Break the loop as we will re-enter the loop after the liquidity check is deferred.\n                break;\n            } else if (action.name == ACTION_SUPPLY) {\n                (address asset, uint256 amount) = abi.decode(action.data, (address, uint256));\n                supply(user, asset, amount);\n            } else if (action.name == ACTION_BORROW) {\n                (address asset, uint256 amount) = abi.decode(action.data, (address, uint256));\n                borrow(user, asset, amount);\n            } else if (action.name == ACTION_REDEEM) {\n                (address asset, uint256 amount) = abi.decode(action.data, (address, uint256));\n                redeem(user, asset, amount);\n            } else if (action.name == ACTION_REPAY) {\n                (address asset, uint256 amount) = abi.decode(action.data, (address, uint256));\n                repay(user, asset, amount);\n            } else if (action.name == ACTION_SUPPLY_NATIVE_TOKEN) {\n                supplyNativeToken(user);\n            } else if (action.name == ACTION_BORROW_NATIVE_TOKEN) {\n                uint256 borrowAmount = abi.decode(action.data, (uint256));\n                borrowNativeToken(user, borrowAmount);\n            } else if (action.name == ACTION_REDEEM_NATIVE_TOKEN) {\n                uint256 redeemAmount = abi.decode(action.data, (uint256));\n                redeemNativeToken(user, redeemAmount);\n            } else if (action.name == ACTION_REPAY_NATIVE_TOKEN) {\n                repayNativeToken(user);\n            } else if (action.name == ACTION_SUPPLY_STETH) {\n                uint256 amount = abi.decode(action.data, (uint256));\n                supplyStEth(user, amount);\n            } else if (action.name == ACTION_BORROW_STETH) {\n                uint256 amount = abi.decode(action.data, (uint256));\n                borrowStEth(user, amount);\n            } else if (action.name == ACTION_REDEEM_STETH) {\n                uint256 amount = abi.decode(action.data, (uint256));\n                redeemStEth(user, amount);\n            } else if (action.name == ACTION_REPAY_STETH) {\n                uint256 amount = abi.decode(action.data, (uint256));\n                repayStEth(user, amount);\n            } else if (action.name == ACTION_SUPPLY_PTOKEN) {\n                (address pToken, uint256 amount) = abi.decode(action.data, (address, uint256));\n                supplyPToken(user, pToken, amount);\n            } else if (action.name == ACTION_REDEEM_PTOKEN) {\n                (address pToken, uint256 amount) = abi.decode(action.data, (address, uint256));\n                redeemPToken(user, pToken, amount);\n            } else {\n                revert(\"invalid action\");\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @dev Defers the liquidity check.\n     * @param user The address of the user\n     * @param data The encoded data\n     */\n    function deferLiquidityCheck(address user, bytes memory data) internal {\n        ironBank.deferLiquidityCheck(user, data);\n    }\n\n    /**\n     * @dev Supplies the asset to Iron Bank.\n     * @param user The address of the user\n     * @param asset The address of the asset to supply\n     * @param amount The amount of the asset to supply\n     */\n    function supply(address user, address asset, uint256 amount) internal nonReentrant {\n        ironBank.supply(user, user, asset, amount);\n    }\n\n    /**\n     * @dev Borrows the asset from Iron Bank.\n     * @param user The address of the user\n     * @param asset The address of the asset to borrow\n     * @param amount The amount of the asset to borrow\n     */\n    function borrow(address user, address asset, uint256 amount) internal nonReentrant {\n        ironBank.borrow(user, user, asset, amount);\n    }\n\n    /**\n     * @dev Redeems the asset to Iron Bank.\n     * @param user The address of the user\n     * @param asset The address of the asset to redeem\n     * @param amount The amount of the asset to redeem\n     */\n    function redeem(address user, address asset, uint256 amount) internal nonReentrant {\n        ironBank.redeem(user, user, asset, amount);\n    }\n\n    /**\n     * @dev Repays the asset to Iron Bank.\n     * @param user The address of the user\n     * @param asset The address of the asset to repay\n     * @param amount The amount of the asset to repay\n     */\n    function repay(address user, address asset, uint256 amount) internal nonReentrant {\n        ironBank.repay(user, user, asset, amount);\n    }\n\n    /**\n     * @dev Wraps the native token and supplies it to Iron Bank.\n     * @param user The address of the user\n     */\n    function supplyNativeToken(address user) internal nonReentrant {\n        WethInterface(weth).deposit{value: msg.value}();\n        IERC20(weth).safeIncreaseAllowance(address(ironBank), msg.value);\n        ironBank.supply(address(this), user, weth, msg.value);\n    }\n\n    /**\n     * @dev Borrows the wrapped native token and unwraps it to the user.\n     * @param user The address of the user\n     * @param borrowAmount The amount of the wrapped native token to borrow\n     */\n    function borrowNativeToken(address user, uint256 borrowAmount) internal nonReentrant {\n        ironBank.borrow(user, address(this), weth, borrowAmount);\n        WethInterface(weth).withdraw(borrowAmount);\n        (bool sent,) = user.call{value: borrowAmount}(\"\");\n        require(sent, \"failed to send native token\");\n    }\n\n    /**\n     * @dev Redeems the wrapped native token and unwraps it to the user.\n     * @param user The address of the user\n     * @param redeemAmount The amount of the wrapped native token to redeem, -1 means redeem all\n     */\n    function redeemNativeToken(address user, uint256 redeemAmount) internal nonReentrant {\n        if (redeemAmount == type(uint256).max) {\n            redeemAmount = ironBank.getSupplyBalance(user, weth);\n        }\n        ironBank.redeem(user, address(this), weth, redeemAmount);\n        WethInterface(weth).withdraw(redeemAmount);\n        (bool sent,) = user.call{value: redeemAmount}(\"\");\n        require(sent, \"failed to send native token\");\n    }\n\n    /**\n     * @dev Wraps the native token and repays it to Iron Bank.\n     * @dev If the amount of the native token is greater than the borrow balance, the excess amount will be sent back to the user.\n     * @param user The address of the user\n     */\n    function repayNativeToken(address user) internal nonReentrant {\n        uint256 repayAmount = msg.value;\n\n        ironBank.accrueInterest(weth);\n        uint256 borrowBalance = ironBank.getBorrowBalance(user, weth);\n        if (repayAmount > borrowBalance) {\n            WethInterface(weth).deposit{value: borrowBalance}();\n            IERC20(weth).safeIncreaseAllowance(address(ironBank), borrowBalance);\n            ironBank.repay(address(this), user, weth, borrowBalance);\n            (bool sent,) = user.call{value: repayAmount - borrowBalance}(\"\");\n            require(sent, \"failed to send native token\");\n        } else {\n            WethInterface(weth).deposit{value: repayAmount}();\n            IERC20(weth).safeIncreaseAllowance(address(ironBank), repayAmount);\n            ironBank.repay(address(this), user, weth, repayAmount);\n        }\n    }\n\n    /**\n     * @dev Wraps the stEth and supplies wstEth to Iron Bank.\n     * @param user The address of the user\n     * @param stEthAmount The amount of the stEth to supply\n     */\n    function supplyStEth(address user, uint256 stEthAmount) internal nonReentrant {\n        IERC20(steth).safeTransferFrom(user, address(this), stEthAmount);\n        IERC20(steth).safeIncreaseAllowance(wsteth, stEthAmount);\n        uint256 wstEthAmount = WstEthInterface(wsteth).wrap(stEthAmount);\n        IERC20(wsteth).safeIncreaseAllowance(address(ironBank), wstEthAmount);\n        ironBank.supply(address(this), user, wsteth, wstEthAmount);\n    }\n\n    /**\n     * @dev Borrows the wstEth and unwraps it to the user.\n     * @param user The address of the user\n     * @param stEthAmount The amount of the stEth to borrow\n     */\n    function borrowStEth(address user, uint256 stEthAmount) internal nonReentrant {\n        uint256 wstEthAmount = WstEthInterface(wsteth).getWstETHByStETH(stEthAmount);\n        ironBank.borrow(user, address(this), wsteth, wstEthAmount);\n        uint256 unwrappedStEthAmount = WstEthInterface(wsteth).unwrap(wstEthAmount);\n        IERC20(steth).safeTransfer(user, unwrappedStEthAmount);\n    }\n\n    /**\n     * @dev Redeems the wstEth and unwraps it to the user.\n     * @param user The address of the user\n     * @param stEthAmount The amount of the stEth to redeem, -1 means redeem all\n     */\n    function redeemStEth(address user, uint256 stEthAmount) internal nonReentrant {\n        uint256 wstEthAmount;\n        if (stEthAmount == type(uint256).max) {\n            ironBank.accrueInterest(wsteth);\n            wstEthAmount = ironBank.getSupplyBalance(user, wsteth);\n        } else {\n            wstEthAmount = WstEthInterface(wsteth).getWstETHByStETH(stEthAmount);\n        }\n        ironBank.redeem(user, address(this), wsteth, wstEthAmount);\n        uint256 unwrappedStEthAmount = WstEthInterface(wsteth).unwrap(wstEthAmount);\n        IERC20(steth).safeTransfer(user, unwrappedStEthAmount);\n    }\n\n    /**\n     * @dev Wraps the stEth and repays wstEth to Iron Bank.\n     * @param user The address of the user\n     * @param stEthAmount The amount of the stEth to repay, -1 means repay all\n     */\n    function repayStEth(address user, uint256 stEthAmount) internal nonReentrant {\n        if (stEthAmount == type(uint256).max) {\n            ironBank.accrueInterest(wsteth);\n            uint256 borrowBalance = ironBank.getBorrowBalance(user, wsteth);\n            stEthAmount = WstEthInterface(wsteth).getStETHByWstETH(borrowBalance) + 1; // add 1 to avoid rounding issue\n        }\n\n        IERC20(steth).safeTransferFrom(user, address(this), stEthAmount);\n        IERC20(steth).safeIncreaseAllowance(wsteth, stEthAmount);\n        uint256 wstEthAmount = WstEthInterface(wsteth).wrap(stEthAmount);\n        IERC20(wsteth).safeIncreaseA"
    }
  ]
}