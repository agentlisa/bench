{
  "Title": "[M01] Lack of event emission after sensitive actions",
  "Content": "The [`_getLatestFundingRate` function of the `FundingRateApplier` contract](https://github.com/UMAprotocol/protocol/blob/1631ef7ad29aaeba756ef3b9a01c667e1343df85/packages/core/contracts/financial-templates/common/FundingRateApplier.sol#L215) does not emit relevant events after executing the sensitive actions of setting the `fundingRate`, `updateTime` and `proposalTime`, and transferring the rewards.\n\n\nConsider emitting events after sensitive changes take place, to facilitate tracking and notify off-chain clients following the contractâ€™s activity.\n\n\n**Update**: *Fixed in [PR#2284](https://github.com/UMAprotocol/protocol/pull/2284) and [PR#2311](https://github.com/UMAprotocol/protocol/pull/2311).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/financial-templates/common/FundingRateApplier.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\n\nimport \"../../oracle/interfaces/StoreInterface.sol\";\nimport \"../../oracle/interfaces/FinderInterface.sol\";\nimport \"../../oracle/implementation/Constants.sol\";\n\n// TODO: point this at an interface instead.\nimport \"../../oracle/implementation/OptimisticOracle.sol\";\nimport \"../perpetual-multiparty/ConfigStoreInterface.sol\";\n\nimport \"./FeePayer.sol\";\n\n/**\n * @title FundingRateApplier contract.\n * @notice Provides funding rate payment functionality for the Perpetual contract.\n */\n\nabstract contract FundingRateApplier is FeePayer {\n    using FixedPoint for FixedPoint.Unsigned;\n    using FixedPoint for FixedPoint.Signed;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /****************************************\n     * FUNDING RATE APPLIER DATA STRUCTURES *\n     ****************************************/\n\n    struct FundingRate {\n        // Current funding rate value.\n        FixedPoint.Signed rate;\n        // Identifier to retrieve the funding rate.\n        bytes32 identifier;\n        // Tracks the cumulative funding payments that have been paid to the sponsors.\n        // The multiplier starts at 1, and is updated by computing cumulativeFundingRateMultiplier * (1 + effectivePayment).\n        // Put another way, the cumulativeFeeMultiplier is (1 + effectivePayment1) * (1 + effectivePayment2) ...\n        // For example:\n        // The cumulativeFundingRateMultiplier should start at 1.\n        // If a 1% funding payment is paid to sponsors, the multiplier should update to 1.01.\n        // If another 1% fee is charged, the multiplier should be 1.01^2 (1.0201).\n        FixedPoint.Unsigned cumulativeMultiplier;\n        // Most recent time that the funding rate was updated.\n        uint256 updateTime;\n        // Most recent time that the funding rate was applied and changed the cumulative multiplier.\n        uint256 applicationTime;\n        // The time for the active (if it exists) funding rate proposal. 0 otherwise.\n        uint256 proposalTime;\n    }\n\n    FundingRate public fundingRate;\n\n    // Timestamp used in case of emergency shutdown. 0 if no shutdown has been triggered.\n    uint256 public emergencyShutdownTimestamp;\n\n    // Remote config store managed an owner.\n    ConfigStoreInterface public configStore;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event NewFundingRateMultiplier(\n        uint256 indexed newMultiplier,\n        uint256 lastApplicationTime,\n        uint256 applicationTime,\n        uint256 indexed paymentPeriod,\n        int256 indexed latestFundingRate,\n        int256 periodRate\n    );\n\n    /****************************************\n     *              MODIFIERS               *\n     ****************************************/\n\n    // This is overridden to both pay fees (which is done by applyFundingRate()) and apply the funding rate.\n    modifier fees override {\n        applyFundingRate();\n        _;\n    }\n\n    // Note: this modifier is intended to be used if the caller intends to _only_ pay regular fees.\n    modifier regularFees {\n        payRegularFees();\n        _;\n    }\n\n    /**\n     * @notice Constructs the FundingRateApplier contract. Called by child contracts.\n     * @param _fundingRateIdentifier identifier that tracks the funding rate of this contract.\n     * @param _collateralAddress address of the collateral token.\n     * @param _finderAddress Finder used to discover financial-product-related contracts.\n     * @param _configStoreAddress address of the remote configuration store managed by an external owner.\n     * @param _tokenScaling initial scaling to apply to the token value (i.e. scales the tracking index).\n     * @param _timerAddress address of the timer contract in test envs, otherwise 0x0.\n     */\n    constructor(\n        bytes32 _fundingRateIdentifier,\n        address _collateralAddress,\n        address _finderAddress,\n        address _configStoreAddress,\n        FixedPoint.Unsigned memory _tokenScaling,\n        address _timerAddress\n    ) public FeePayer(_collateralAddress, _finderAddress, _timerAddress) {\n        uint256 currentTime = getCurrentTime();\n        fundingRate.updateTime = currentTime;\n        fundingRate.applicationTime = currentTime;\n\n        // Seed the cumulative multiplier with the token scaling, from which it will be scaled as funding rates are\n        // applied over time.\n        fundingRate.cumulativeMultiplier = _tokenScaling;\n        emergencyShutdownTimestamp = 0;\n\n        fundingRate.identifier = _fundingRateIdentifier;\n        configStore = ConfigStoreInterface(_configStoreAddress);\n    }\n\n    /**\n     * @notice This method takes 4 distinct actions:\n     *\n     * 1. Pays out regular fees.\n     *\n     * 2. If possible, resolves the outstanding funding rate proposal, pulling the result in and paying out the\n     *    rewards.\n     *\n     * 3. Applies the prevailing funding rate over the most recent period.\n     */\n    function applyFundingRate() public regularFees() nonReentrant() {\n        _applyEffectiveFundingRate();\n    }\n\n    /**\n     * @notice Proposes a new funding rate. Proposer receives a reward if correct.\n     * @param rate funding rate to being proposed.\n     * @param timestamp time at which the funding rate was computed.\n     */\n    function proposeNewRate(FixedPoint.Signed memory rate, uint256 timestamp)\n        external\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory totalBond)\n    {\n        require(fundingRate.proposalTime == 0, \"Proposal in progress\");\n\n        // Timestamp must be after the last funding rate update time, within the last 30 minutes, and it cannot be more\n        // than 90 seconds ahead of the block timestamp.\n        uint256 currentTime = getCurrentTime();\n        uint256 updateTime = fundingRate.updateTime;\n        require(\n            timestamp > updateTime && timestamp >= currentTime.sub(30 minutes) && timestamp <= currentTime.add(90),\n            \"Invalid proposal time\"\n        );\n\n        // Set the proposal time in order to allow this contract to track this request.\n        fundingRate.proposalTime = timestamp;\n\n        OptimisticOracle optimisticOracle = _getOptimisticOracle();\n\n        // Set up optimistic oracle.\n        bytes32 identifier = fundingRate.identifier;\n        bytes memory ancillaryData = _getAncillaryData();\n        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\n        totalBond = FixedPoint.Unsigned(\n            optimisticOracle.setBond(\n                identifier,\n                timestamp,\n                ancillaryData,\n                _pfc().mul(_getConfig().proposerBondPct).rawValue\n            )\n        );\n\n        // Pull bond from caller and send to optimistic oracle.\n        if (totalBond.isGreaterThan(0)) {\n            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\n            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\n        }\n\n        optimisticOracle.proposePriceFor(\n            msg.sender,\n            address(this),\n            identifier,\n            timestamp,\n            ancillaryData,\n            rate.rawValue\n        );\n    }\n\n    // Returns a token amount scaled by the current funding rate multiplier.\n    // Note: if the contract has paid fees since it was deployed, the raw\n    // value should be larger than the returned value.\n    function _getFundingRateAppliedTokenDebt(FixedPoint.Unsigned memory rawTokenDebt)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory tokenDebt)\n    {\n        return rawTokenDebt.mul(fundingRate.cumulativeMultiplier);\n    }\n\n    function _getOptimisticOracle() internal view returns (OptimisticOracle) {\n        return OptimisticOracle(finder.getImplementationAddress(OracleInterfaces.OptimisticOracle));\n    }\n\n    function _getConfig() internal view returns (ConfigStoreInterface.ConfigSettings memory) {\n        return configStore.getCurrentConfig();\n    }\n\n    function _getLatestFundingRate() internal returns (FixedPoint.Signed memory) {\n        uint256 proposalTime = fundingRate.proposalTime;\n        if (proposalTime != 0) {\n            // Attempt to update the funding rate.\n            OptimisticOracle optimisticOracle = _getOptimisticOracle();\n            bytes32 identifier = fundingRate.identifier;\n            bytes memory ancillaryData = _getAncillaryData();\n\n            // Try to get the price from the optimistic oracle.\n            try optimisticOracle.getPrice(identifier, proposalTime, ancillaryData) returns (int256 price) {\n                // If successful, figure out the type of request.\n                OptimisticOracle.Request memory request =\n                    optimisticOracle.getRequest(address(this), identifier, proposalTime, ancillaryData);\n                uint256 lastUpdateTime = fundingRate.updateTime;\n\n                // If the request is more recent than the last update then we should update the funding rate.\n                if (proposalTime >= lastUpdateTime) {\n                    // Update funding rates\n                    fundingRate.rate = FixedPoint.Signed(price);\n                    fundingRate.updateTime = proposalTime;\n\n                    // If there was no dispute, send a reward.\n                    if (request.disputer == address(0)) {\n                        FixedPoint.Unsigned memory reward =\n                            _pfc().mul(_getConfig().rewardRatePerSecond).mul(proposalTime.sub(lastUpdateTime));\n                        if (reward.isGreaterThan(0)) {\n                            _adjustCumulativeFeeMultiplier(reward, _pfc());\n                            collateralCurrency.safeTransfer(request.proposer, reward.rawValue);\n                        }\n                    }\n                }\n\n                // Set proposal time to 0 since this proposal has now been resolved.\n                fundingRate.proposalTime = 0;\n            } catch {\n                // Stop tracking if in dispute to allow other proposals to come in.\n                if (\n                    optimisticOracle.getRequest(address(this), identifier, proposalTime, ancillaryData).disputer !=\n                    address(0)\n                ) {\n                    fundingRate.proposalTime = 0;\n                }\n            }\n        }\n        return fundingRate.rate;\n    }\n\n    // Fetches a funding rate from the Store, determines the period over which to compute an effective fee,\n    // and multiplies the current multiplier by the effective fee.\n    // A funding rate < 1 will reduce the multiplier, and a funding rate of > 1 will increase the multiplier.\n    // Note: 1 is set as the neutral rate because there are no negative numbers in FixedPoint, so we decide to treat\n    // values < 1 as \"negative\".\n    function _applyEffectiveFundingRate() internal {\n        // If contract is emergency shutdown, then the funding rate multiplier should no longer change.\n        if (emergencyShutdownTimestamp != 0) {\n            return;\n        }\n\n        uint256 currentTime = getCurrentTime();\n        uint256 paymentPeriod = currentTime.sub(fundingRate.applicationTime);\n\n        FixedPoint.Signed memory _latestFundingRatePerSecond = _getLatestFundingRate();\n\n        FixedPoint.Signed memory periodRate;\n        (fundingRate.cumulativeMultiplier, periodRate) = _calculateEffectiveFundingRate(\n            paymentPeriod,\n            _getLatestFundingRate(),\n            fundingRate.cumulativeMultiplier\n        );\n\n        emit NewFundingRateMultiplier(\n            fundingRate.cumulativeMultiplier.rawValue,\n            fundingRate.applicationTime,\n            currentTime,\n            paymentPeriod,\n            _latestFundingRatePerSecond.rawValue,\n            periodRate.rawValue\n        );\n\n        fundingRate.applicationTime = currentTime;\n    }\n\n    function _calculateEffectiveFundingRate(\n        uint256 paymentPeriodSeconds,\n        FixedPoint.Signed memory fundingRatePerSecond,\n        FixedPoint.Unsigned memory currentCumulativeFundingRateMultiplier\n    )\n        internal\n        pure\n        returns (FixedPoint.Unsigned memory newCumulativeFundingRateMultiplier, FixedPoint.Signed memory periodRate)\n    {\n        // Note: this method uses named return variables to save a little bytecode.\n\n        // The overall formula that this function is performing:\n        //   newCumulativeFundingRateMultiplier =\n        //   (1 + (fundingRatePerSecond * paymentPeriodSeconds)) * currentCumulativeFundingRateMultiplier.\n        FixedPoint.Signed memory ONE = FixedPoint.fromUnscaledInt(1);\n\n        // Multiply the per-second rate over the number of seconds that have elapsed to get the period rate.\n        periodRate = fundingRatePerSecond.mul(SafeCast.toInt256(paymentPeriodSeconds));\n\n        // Add one to create the multiplier to scale the existing fee multiplier.\n        FixedPoint.Signed memory signedPeriodMultiplier = ONE.add(periodRate);\n\n        // Max with 0 to ensure the multiplier isn't negative, then cast to an Unsigned.\n        FixedPoint.Unsigned memory unsignedPeriodMultiplier =\n            FixedPoint.fromSigned(FixedPoint.max(signedPeriodMultiplier, FixedPoint.fromUnscaledInt(0)));\n\n        // Multiply the existing cumulative funding rate multiplier by the computed period multiplier to get the new\n        // cumulative funding rate multiplier.\n        newCumulativeFundingRateMultiplier = currentCumulativeFundingRateMultiplier.mul(unsignedPeriodMultiplier);\n    }\n\n    function _getAncillaryData() internal view returns (bytes memory) {\n        // Note: when ancillary data is passed to the optimistic oracle, it should be tagged with the token address\n        // whose funding rate it's trying to get.\n        return abi.encodePacked(_getTokenAddress());\n    }\n\n    function _getTokenAddress() internal view virtual returns (address);\n}"
    }
  ]
}