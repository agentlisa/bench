{
  "Title": "[L-06] - Unnecessary role check",
  "Content": "\nRole is checked both on the modifier and the function body. Consider removing one:\n\n```solidity\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) { // @audit\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\"); // @audit\n```\n\n[RdpxDecayingBonds.sol#L114-L120](https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/decaying-bonds/RdpxDecayingBonds.sol#L114-L120)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/decaying-bonds/RdpxDecayingBonds.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\ncontract RdpxDecayingBonds is\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  Pausable,\n  AccessControl\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  Counters.Counter private _tokenIdCounter;\n\n  // Create a new role identifier for the minter role\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  // Create a new role identifier for the Rdpx v2 core role\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  // Array of bonds\n  mapping(uint256 => Bond) public bonds;\n\n  // Structure to store the bond information\n  struct Bond {\n    address owner;\n    uint256 expiry;\n    uint256 rdpxAmount;\n  }\n\n  event BondMinted(\n    address to,\n    uint256 bondId,\n    uint256 expiry,\n    uint256 rdpxAmount\n  );\n\n  event EmergencyWithdraw(address sender);\n\n  /*==== CONSTRUCTOR ====*/\n  constructor(\n    string memory _name,\n    string memory _symbol\n  ) ERC721(_name, _symbol) {\n    // Grant the minter role and admin role to deployer\n    _setupRole(MINTER_ROLE, msg.sender);\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _tokenIdCounter.increment();\n  }\n\n  /*============ ADMIN FUNCTIONS ============*/\n\n  /// @notice Pauses the vault for emergency cases\n  /// @dev Can only be called by the owner\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /// @notice Unpauses the vault\n  /// @dev Can only be called by the owner\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   * @param  transferNative Whether should transfer the native currency\n   * @param  to The address to transfer the funds to\n   * @param  amount The amount to transfer\n   * @param  gas The gas to use for the transfer\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens,\n    bool transferNative,\n    address payable to,\n    uint256 amount,\n    uint256 gas\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    if (transferNative) {\n      (bool success, ) = to.call{ value: amount, gas: gas }(\"\");\n      require(success, \"RdpxReserve: transfer failed\");\n    }\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n\n  /// @notice Mints decaying rdpx bonds\n  /// @dev Can only be called by the minter\n  /// @param to address of the user to mint the bonds for\n  /// @param expiry timestamp of the bond expiry\n  /// @param rdpxAmount amount of rdpx to bond\n  function mint(\n    address to,\n    uint256 expiry,\n    uint256 rdpxAmount\n  ) external onlyRole(MINTER_ROLE) {\n    _whenNotPaused();\n    require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n    uint256 bondId = _mintToken(to);\n    bonds[bondId] = Bond(to, expiry, rdpxAmount);\n\n    emit BondMinted(to, bondId, expiry, rdpxAmount);\n  }\n\n  /// @dev Internal function to mint a bond position token\n  /// @param to the address to mint the position to\n  function _mintToken(address to) private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(to, tokenId);\n  }\n\n  /// @notice Decreases the bond amount\n  /// @dev Can only be called by the rdpxV2Core\n  /// @param bondId id of the bond to decrease\n  /// @param amount amount to decrease\n  function decreaseAmount(\n    uint256 bondId,\n    uint256 amount\n  ) public onlyRole(RDPXV2CORE_ROLE) {\n    _whenNotPaused();\n    bonds[bondId].rdpxAmount = amount;\n  }\n\n  /*============ VIEW FUNCTIONS ============*/\n\n  /// @notice returns the bonds owned by an address\n  /// @param _address address of the user\n  function getBondsOwned(\n    address _address\n  ) external view returns (uint256[] memory) {\n    uint256 ownerTokenCount = balanceOf(_address);\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n    for (uint256 i; i < ownerTokenCount; i++) {\n      tokenIds[i] = tokenOfOwnerByIndex(_address, i);\n    }\n    return tokenIds;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  // The following functions are overrides required by Solidity.\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}"
    }
  ]
}