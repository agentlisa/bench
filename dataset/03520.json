{
  "Title": "[M06] Reservoir does not accept ETH",
  "Content": "The [`Reservoir` contract](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L14) has no way to accept `ETH`, even though governance can [execute proposals](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L280-L285) that handle `ETH`.\n\n\nWhether the `Reservoir` contract should handle `ETH` or not, for instance by using `WETH` instead of `ETH`, this expectation should be properly documented. Consider either implementing the functionality to allow the `Rerservoir` contract to handle and drip `ETH` or documenting the reasons behind this choice.\n\n\n***Update:** Fixed in [pull request 24](https://github.com/notional-finance/contracts-v2/pull/24/files) by adding documentation about the design choice.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/external/governance/Reservoir.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Reservoir Contract\n/// @notice Distributes a token to a different contract at a fixed rate. Though not entirely\n/// necessary this contract does give some measure of safety against the Notional contract's token\n/// reserves being drained by an attack. The goal should be to set up a reservoir such that the\n/// Notional contract's target reserves are maintained at some reasonable level.\n/// @dev This contract must be poked via the `drip()` function every so often.\n/// @author Compound, modified by Notional\ncontract Reservoir {\n    using SafeMath for uint256;\n\n    /// @notice The timestamp when the Reservoir started\n    uint256 public immutable DRIP_START;\n\n    /// @notice Tokens per second that to drip to target\n    uint256 public immutable DRIP_RATE;\n\n    /// @notice Reference to token to drip\n    IERC20 public immutable TOKEN;\n\n    /// @notice Target to receive dripped tokens\n    address public immutable TARGET;\n\n    /// @notice Amount that has already been dripped\n    uint256 public dripped;\n\n    /// @notice Constructs a Reservoir\n    /// @param dripRate_ Number of tokens per block to drip\n    /// @param token_ The token to drip\n    /// @param target_ The recipient of dripped tokens\n    constructor(\n        uint256 dripRate_,\n        IERC20 token_,\n        address target_\n    ) {\n        DRIP_START = block.timestamp;\n        DRIP_RATE = dripRate_;\n        TOKEN = token_;\n        TARGET = target_;\n        dripped = 0;\n    }\n\n    /// @notice Drips the maximum amount of tokens to match the drip rate since inception\n    /// @dev emit:Transfer\n    /// @return amountToDrip tokens dripped\n    function drip() public returns (uint256 amountToDrip) {\n        uint256 reservoirBalance = TOKEN.balanceOf(address(this));\n        require(reservoirBalance > 0, \"Reservoir empty\");\n        uint256 blockTime = block.timestamp;\n\n        amountToDrip = DRIP_RATE.mul(blockTime - DRIP_START).sub(dripped);\n        if (amountToDrip > reservoirBalance) amountToDrip = reservoirBalance;\n\n        // Finally, write new `dripped` value and transfer tokens to target\n        dripped = dripped.add(amountToDrip);\n        // No need to do special checking for return codes, here we know that the token\n        // will be compliant because it is the NOTE contract\n        bool success = TOKEN.transfer(TARGET, amountToDrip);\n        require(success, \"Transfer failed\");\n    }\n}"
    }
  ]
}