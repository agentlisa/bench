{
  "Title": "Untested functions in RenderToken",
  "Content": "The `RenderToken` contract implements functions (*e.g.* [holdInEscrow](https://github.com/jeualvarez/Token-Audit/blob/e946177747e57312690775204834b8fca1bbb0d5/contracts/RenderToken.sol#L39) ) that are not being tested in the test suite. Consider testing all functions implemented in contracts to ensure they behave as expected.\n\n\n***Update:** some testing of `holdInEscrow` was done in the `Escrow.js` file, but an additional test for this function was [added](https://github.com/jeualvarez/Token-Audit/blob/master/test/RenderToken.js#L160) to the `RenderToken.js` file.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RenderToken.sol",
      "content": "pragma solidity ^0.4.14;\n\n// Escrow constract\nimport \"./Escrow.sol\";\nimport \"./MigratableERC20.sol\";\n\n/**\n * @title RenderToken\n * @dev ERC20 mintable token\n * The token will be minted by the crowdsale contract only\n */\ncontract RenderToken is Migratable, MigratableERC20, MintableToken {\n\n  string public constant name = \"Render Token\";\n  string public constant symbol = \"RNDR\";\n  uint8 public constant decimals = 18;\n\n  // The address of the contract that manages job balances. Address is used for forwarding tokens\n  // that come in to fund jobs\n  address public escrowContractAddress;\n\n  /**\n   * @dev Constructor\n   * @param _owner because this contract uses proxies, owner must be passed in as a param\n   */\n  function initialize(address _owner, address _legacyToken) public isInitializer(\"RenderToken\", \"0\") {\n    MintableToken.initialize(_owner);\n    MigratableERC20.initialize(_legacyToken);\n  }\n\n  /**\n   * @dev Take tokens prior to beginning a job\n   *\n   * This function is called by the artist, and it will transfer tokens\n   * to a separate escrow contract to be held until the job is completed\n   * @param _jobID is the ID of the job used within the ORC backend\n   * @param _amount is the number of RNDR tokens being held in escrow\n   */\n  function holdInEscrow(string _jobID, uint256 _amount) public {\n    require(transfer(escrowContractAddress, _amount));\n    Escrow(escrowContractAddress).fundJob(_jobID, _amount);\n  }\n\n  function _mint(address _to, uint256 _amount) internal {\n    require(_to != address(0));\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Transfer(address(0), _to, _amount);\n  }\n\n  /**\n   * @dev Set the address of the escrow contract\n   *\n   * This will dictate the contract that will hold tokens in escrow and keep\n   * a ledger of funds available for jobs\n   * @param _escrowAddress see escrowContractAddress\n  */\n  function setEscrowContractAddress(address _escrowAddress) public onlyOwner {\n    escrowContractAddress = _escrowAddress;\n  }\n\n}"
    },
    {
      "filename": "test/RenderToken.js",
      "content": "const BigNumber = web3.BigNumber;\nconst Escrow = artifacts.require('Escrow');\nconst LegacyToken = artifacts.require('LegacyToken');\nconst RenderToken = artifacts.require('RenderToken');\n\nrequire('chai')\n  .use(require('chai-as-promised'))\n  .use(require('chai-bignumber')(BigNumber))\n  .should();\n\n\ncontract('Render Token ', (accounts) => {\n\n  const owner = accounts[0];\n  let renderTokenDecimalFactor = 1000000000000000000;\n  let sampleJob1 = {\n    id: 'SampleJob1',\n    cost: 10 * renderTokenDecimalFactor\n  };\n  let sampleJob2 = {\n    id: 'SampleJob2',\n    cost: 20 * renderTokenDecimalFactor\n  };\n\n  beforeEach(async () => {\n    const renderTokenContractOwner = accounts[0];\n    const escrowContractOwner = accounts[0];\n\n    // Create legacy token for migrations\n    this.legacyToken = await LegacyToken.new('Legacy Token', 'LTX', 18, {from: owner});\n    legacyTokenAddress = await this.legacyToken.address;\n\n    // Create and initialize Render Token contract\n    this.renderToken = await RenderToken.new();\n    this.renderToken.initialize(renderTokenContractOwner, legacyTokenAddress);\n    this.renderTokenAddress = await this.renderToken.address;\n\n    // Create and initialize Escrow contract\n    this.escrow = await Escrow.new();\n    this.escrow.initialize(escrowContractOwner, this.renderTokenAddress);\n    this.escrowAddress = await this.escrow.address;\n\n    // Add funds to accounts\n    let amount = 100 * renderTokenDecimalFactor;\n    for (let account of accounts) {\n      await this.legacyToken.mint(account, amount);\n      let balance = await this.legacyToken.balanceOf(account);\n      await this.legacyToken.approve(this.renderTokenAddress, balance, {from: account});\n      await this.renderToken.migrate({from: account});\n    }\n\n    // Set escrow contract address\n    await this.renderToken.setEscrowContractAddress(this.escrowAddress);\n  });\n\n  describe('Should allow valid transfers of RNDR tokens', () => {\n\n    it('should return correct balances after transfer', async () => {\n      let startBalance0 = Number(await this.renderToken.balanceOf(accounts[0]));\n      let startBalance1 = Number(await this.renderToken.balanceOf(accounts[1]));\n\n      let transferAmount = 100;\n      await this.renderToken.transfer(accounts[1], transferAmount);\n\n      let endBalance0 = Number(await this.renderToken.balanceOf(accounts[0]));\n      let endBalance1 = Number(await this.renderToken.balanceOf(accounts[1]));\n\n      assert.equal(startBalance0 - transferAmount, endBalance0);\n      assert.equal(startBalance1 + transferAmount, endBalance1);\n    });\n\n    it('should throw an error when trying to transfer more than balance', async () => {\n      let sender = accounts[3];\n      let balance = Number(await this.renderToken.balanceOf(sender));\n\n      let transferAmount = balance * 2;\n\n      await this.renderToken.transfer(accounts[2], transferAmount, {from: sender})\n        .should.be.rejectedWith('revert');\n    });\n\n    it('should return correct balances after transfering from another account', async () => {\n      let startBalance0 = Number(await this.renderToken.balanceOf(accounts[0]));\n      let startBalance1 = Number(await this.renderToken.balanceOf(accounts[1]));\n      let startBalance2 = Number(await this.renderToken.balanceOf(accounts[2]));\n\n      let approvalAmount = 100;\n      await this.renderToken.approve(accounts[1], approvalAmount);\n      await this.renderToken.transferFrom(accounts[0], accounts[2], approvalAmount, {from: accounts[1]});\n\n      let endBalance0 = Number(await this.renderToken.balanceOf(accounts[0]));\n      let endBalance1 = Number(await this.renderToken.balanceOf(accounts[1]));\n      let endBalance2 = Number(await this.renderToken.balanceOf(accounts[2]));\n\n      assert.equal(startBalance0 - approvalAmount, endBalance0);\n      assert.equal(startBalance1, endBalance1);\n      assert.equal(startBalance2 + approvalAmount, endBalance2);\n    });\n\n    it('should throw an error when trying to transfer more than allowed', async () => {\n      let approvalAmount = 100;\n      await this.renderToken.approve(accounts[1], approvalAmount);\n\n      await this.renderToken.transferFrom(accounts[0], accounts[2], (approvalAmount * 2), {from: accounts[1]})\n        .should.be.rejectedWith('revert');\n    });\n\n    it('should throw an error when trying to transfer to 0x0', async () => {\n      await this.renderToken.transfer(0x0, 100)\n        .should.be.rejectedWith('revert');\n    });\n\n    it('should throw an error when trying to transferFrom to 0x0', async () => {\n      await this.renderToken.approve(accounts[1], 100);\n      await this.renderToken.transferFrom(accounts[0], 0x0, 100, { from: accounts[1] })\n        .should.be.rejectedWith('revert');\n    });\n  });\n\n\n  describe('Should maintain a record of allowances', () => {\n\n    it('should return the correct allowance amount after approval', async () => {\n      await this.renderToken.approve(accounts[1], 100);\n      let allowance = await this.renderToken.allowance(accounts[0], accounts[1]);\n\n      assert.equal(allowance, 100);\n    });\n\n    it('should allow updates to allowances', async () => {\n      let startApproval = await this.renderToken.allowance(accounts[0], accounts[1]);\n      assert.equal(startApproval, 0);\n\n      await this.renderToken.increaseApproval(accounts[1], 50);\n      let postIncrease = await this.renderToken.allowance(accounts[0], accounts[1]);\n      startApproval.plus(50).should.be.bignumber.equal(postIncrease);\n\n      await this.renderToken.decreaseApproval(accounts[1], 10);\n      let postDecrease = await this.renderToken.allowance(accounts[0], accounts[1]);\n      postIncrease.minus(10).should.be.bignumber.equal(postDecrease);\n    });\n\n    it('should increase by 50 then set to 0 when decreasing by more than 50', async () => {\n      let startApproval = await this.renderToken.allowance(accounts[0], accounts[1]);\n      assert.equal(startApproval, 0);\n\n      await this.renderToken.approve(accounts[1], 50);\n      await this.renderToken.decreaseApproval(accounts[1], 60);\n\n      let postDecrease = await this.renderToken.allowance(accounts[0], accounts[1]);\n      postDecrease.should.be.bignumber.equal(0);\n    });\n  });\n\n  describe('Should allow tokens to be escrowed', () => {\n\n    it('should remove tokens from calling address', async () => {\n      let startBalance = Number(await this.renderToken.balanceOf(accounts[1]));\n      await this.renderToken.holdInEscrow('jobGuid', startBalance, {from: accounts[1]});\n\n      let endBalance = Number(await this.renderToken.balanceOf(accounts[1]));\n      assert.equal(endBalance, 0);\n    });\n  });\n\n  describe('Should allow token migration from existing contract', () => {\n\n    it('should burn old tokens and create new tokens', async () => {\n      let user = accounts[1];\n      let burnAddress = await this.renderToken.BURN_ADDRESS();\n\n      await this.legacyToken.mint(accounts[1], (500 * renderTokenDecimalFactor), {from: owner});\n      let oldTokenOriginalBalance = Number(await this.legacyToken.balanceOf(user));\n      let newTokenOriginalBalance = Number(await this.renderToken.balanceOf(user));\n      let originalBurntBalance = Number(await this.legacyToken.balanceOf(burnAddress));\n\n      await this.legacyToken.approve(this.renderTokenAddress, oldTokenOriginalBalance, {from: user});\n      let allowance = Number(await this.legacyToken.allowance(user, this.renderTokenAddress));\n      assert.equal(oldTokenOriginalBalance, allowance);\n\n      await this.renderToken.migrate({from: user});\n      let oldTokenNewBalance = Number(await this.legacyToken.balanceOf(user));\n      let newTokenNewBalance = Number(await this.renderToken.balanceOf(user));\n      let newBurntBalance = Number(await this.legacyToken.balanceOf(burnAddress));\n\n      assert.equal(originalBurntBalance + oldTokenOriginalBalance, newBurntBalance)\n      assert.equal(oldTokenNewBalance, 0);\n      assert.equal(newTokenOriginalBalance + oldTokenOriginalBalance, newTokenNewBalance);\n    });\n  });\n});"
    }
  ]
}