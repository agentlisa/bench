{
  "Title": "M-14: Incompatibility of Upgradeability Pattern in TitlesGraph Contract",
  "Content": "# Issue M-14: Incompatibility of Upgradeability Pattern in TitlesGraph Contract \n\nSource: https://github.com/sherlock-audit/2024-04-titles-judging/issues/445 \n\n## Found by \n0x73696d616f, 1337, Yu3H0, alexzoid, blackhole, fibonacci, fugazzi, trachev, xiaoming90\n## Summary\n\nThe `TitlesGraph` contract is designed to be upgradeable, utilizing the `UUPSUpgradeable` pattern. However, it's instantiated via a constructor in the `TitlesCore` contract setup. \n\n## Vulnerability Detail\n\nIn the `TitlesCore` contract, `TitlesGraph` is instantiated directly using a constructor rather than being set up as a proxy. This could lead to unexpected behavior when attempting to upgrade the contract, as the proxy would not have access to the initialized state variables or might interact incorrectly with uninitialized storage.\n\n## Impact\n\nInability to leverage the upgradeability.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/TitlesCore.sol#L44-L49\n\n```solidity\ngraph = new TitlesGraph(address(this), msg.sender);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDeploy the `TitlesGraph` contract without initializing state in the constructor. Deploy a proxy that points to the deployed `TitlesGraph` implementation. Correct approach using a proxy pattern for upgradeable contracts:\n```solidity\naddress graphImplementation = address(new TitlesGraph());\ngraph = TitlesGraph(payable(LibClone.deployERC1967(graphImplementation)));\ngraph.initialize(address(this), msg.sender);\n```\n\n\n\n## Discussion\n\n**alexzoid-eth**\n\nEscalate\n\nThis issue is not a duplicate of #272. This is a valid medium issue uncovering the inability of `TitlesGraph` contract upgrade.\n\nPossible duplicates are #87 #142 #170 #180 #209 #281 #319 #342 \n\n**sherlock-admin3**\n\n> Escalate\n> \n> This issue is not a duplicate of #272. This is a valid medium issue uncovering the inability of `TitlesGraph` contract upgrade.\n> \n> Possible duplicates are #87 #142 #170 #180 #209 #281 #319 #342 \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**realfugazzi**\n\nAgree with escalation. Also documented the issue in #170 which has been incorrectly duped as #272 too \n\n**Hash01011122**\n\nResponded in #272.\n\nBorderline low/medium. Tending towards low because in earlier contest issues like this were considered low.\n\n**realfugazzi**\n\n> Responded in #272.\n> \n> Borderline low/medium. Tending towards low because in earlier contest issues like this were considered low.\n\nI think you are confusing this issue with #281, which is an entirely different problem. There are at least 3 different issues being grouped here, see https://github.com/sherlock-audit/2024-04-titles-judging/issues/272#issuecomment-2113628980\n\n**alexzoid-eth**\n\n> Responded in #272.\n> \n> Borderline low/medium. Tending towards low because in earlier contest issues like this were considered low.\n\nMedium due to rules (https://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue): Breaks core contract functionality.\n\n**WangSecurity**\n\nAgree with the escalation, planning to accept it and make a new issue family of medium severity with the following duplicates: \n\n#142, #87, #170, #180, #209, #281, #319, #342, #182\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [alexzoid-eth](https://github.com/sherlock-audit/2024-04-titles-judging/issues/445/#issuecomment-2106685123): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/326",
  "Code": [
    {
      "filename": "wallflower-contract-v2/src/TitlesCore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {LibClone} from \"lib/solady/src/utils/LibClone.sol\";\nimport {LibZip} from \"lib/solady/src/utils/LibZip.sol\";\nimport {OwnableRoles} from \"lib/solady/src/auth/OwnableRoles.sol\";\nimport {Receiver} from \"lib/solady/src/accounts/Receiver.sol\";\nimport {Initializable} from \"lib/solady/src/utils/Initializable.sol\";\nimport {SafeTransferLib} from \"lib/solady/src/utils/SafeTransferLib.sol\";\nimport {UUPSUpgradeable} from \"lib/solady/src/utils/UUPSUpgradeable.sol\";\n\nimport {EnumerableMap} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableMap.sol\";\nimport {EnumerableSet} from \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {Edition} from \"src/editions/Edition.sol\";\nimport {FeeManager} from \"src/fees/FeeManager.sol\";\n\nimport {\n    ADMIN_ROLE,\n    EDITION_PUBLISHER_ROLE,\n    EditionCreated,\n    FeeStrategyUpdated,\n    Metadata,\n    Node,\n    Strategy,\n    Target\n} from \"src/shared/Common.sol\";\nimport {TitlesGraph} from \"src/graph/TitlesGraph.sol\";\n\n/// @title Titles Core\n/// @notice Core contract for the Titles Protocol\ncontract TitlesCore is OwnableRoles, Initializable, UUPSUpgradeable, Receiver {\n    using LibClone for address;\n    using LibZip for bytes;\n    using SafeTransferLib for address;\n\n    address public editionImplementation = address(new Edition());\n    FeeManager public feeManager;\n    TitlesGraph public graph;\n\n    /// @notice Initializes the protocol.\n    /// @param feeReceiver_ The address to receive fees.\n    /// @param splitFactory_ The address of the split factory.\n    function initialize(address feeReceiver_, address splitFactory_) external initializer {\n        _initializeOwner(msg.sender);\n\n        feeManager = new FeeManager(msg.sender, feeReceiver_, splitFactory_);\n        graph = new TitlesGraph(address(this), msg.sender);\n    }\n\n    /// @notice The payload for creating a Work within an {Edition}.\n    struct WorkPayload {\n        Target creator;\n        Node[] attributions;\n        uint256 maxSupply;\n        uint64 opensAt;\n        uint64 closesAt;\n        Strategy strategy;\n        Metadata metadata;\n    }\n\n    /// @notice The payload for creating an {Edition}.\n    struct EditionPayload {\n        WorkPayload work;\n        Metadata metadata;\n    }\n\n    /// @notice Creates an {Edition} with the given payload.\n    /// @param payload_ The compressed payload for creating the {Edition}. See {EditionPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return edition The new {Edition}.\n    function createEdition(bytes calldata payload_, address referrer_)\n        external\n        payable\n        returns (Edition edition)\n    {\n        EditionPayload memory payload = abi.decode(payload_.cdDecompress(), (EditionPayload));\n\n        edition = Edition(editionImplementation.clone());\n\n        // wake-disable-next-line reentrancy\n        edition.initialize(\n            feeManager, graph, payload.work.creator.target, address(this), payload.metadata\n        );\n\n        // wake-disable-next-line unchecked-return-value\n        _publish(edition, payload.work, referrer_);\n\n        emit EditionCreated(\n            address(edition),\n            payload.work.creator.target,\n            payload.work.maxSupply,\n            payload.work.strategy,\n            abi.encode(payload.metadata)\n        );\n    }\n\n    /// @notice Publishes a new Work in the given {Edition} using the given payload.\n    /// @param edition_ The {Edition} to publish the Work in.\n    /// @param payload_ The compressed payload for publishing the Work. See {WorkPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return tokenId The token ID of the new Work.\n    function publish(Edition edition_, bytes calldata payload_, address referrer_)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        if (!edition_.hasAnyRole(msg.sender, EDITION_PUBLISHER_ROLE)) {\n            revert Unauthorized();\n        }\n        WorkPayload memory payload = abi.decode(payload_.cdDecompress(), (WorkPayload));\n        return _publish(edition_, payload, referrer_);\n    }\n\n    /// @notice Publishes a new Work in the given {Edition} using the given payload.\n    /// @param edition_ The {Edition} to publish the Work in.\n    /// @param work_ The payload for publishing the Work. See {EditionPayload}.\n    /// @param referrer_ The address of the referrer.\n    /// @return tokenId The token ID of the new Work.\n    function _publish(Edition edition_, WorkPayload memory work_, address referrer_)\n        internal\n        returns (uint256 tokenId)\n    {\n        // Publish the new Work in the Edition\n        // wake-disable-next-line reentrancy\n        tokenId = edition_.publish(\n            work_.creator.target,\n            work_.maxSupply,\n            work_.opensAt,\n            work_.closesAt,\n            work_.attributions,\n            work_.strategy,\n            work_.metadata\n        );\n\n        // Collect the creation fee\n        // wake-disable-next-line reentrancy\n        feeManager.collectCreationFee{value: msg.value}(edition_, tokenId, msg.sender);\n\n        // Create the fee route for the new Work\n        // wake-disable-next-line reentrancy\n        Target memory feeReceiver = feeManager.createRoute(\n            edition_, tokenId, _attributionTargets(work_.attributions), referrer_\n        );\n\n        // Set the royalty target for the new Work\n        // wake-disable-next-line reentrancy\n        edition_.setRoyaltyTarget(tokenId, feeReceiver.target);\n    }\n\n    /// @notice Sets the implementation address to be cloned for each new {Edition}.\n    /// @param implementation_ The new implementation address.\n    /// @dev Only the owner can call this function.\n    function setEditionImplementation(address implementation_)\n        external\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {\n        editionImplementation = implementation_;\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    /// @dev This function is overridden to restrict access to the owner/admin. No other logic required.\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwnerOrRoles(ADMIN_ROLE)\n    {}\n\n    /// @notice Returns the targets of the given attributions.\n    function _attributionTargets(Node[] memory attributions_)\n        internal\n        pure\n        returns (Target[] memory targets)\n    {\n        targets = new Target[](attributions_.length);\n        for (uint256 i = 0; i < attributions_.length; i++) {\n            targets[i] = attributions_[i].creator;\n        }\n    }\n}"
    }
  ]
}