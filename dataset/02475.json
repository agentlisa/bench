{
  "Title": "M-4: [High] Function MigrateWithdrawal() may set gas limit so high for old withdrawals when migrating them by mistake and they can't be relayed in the L1 and users funds would be lost",
  "Content": "# Issue M-4: [High] Function MigrateWithdrawal() may set gas limit so high for old withdrawals when migrating them by mistake and they can't be relayed in the L1 and users funds would be lost \n\nSource: https://github.com/sherlock-audit/2023-01-optimism-judging/issues/235 \n\n## Found by \nunforgiven\n\n## Summary\nFunction `MigrateWithdrawal()` in migrate.go will turn a LegacyWithdrawal into a bedrock style Withdrawal. it should set a min gas limit value for the withdrawals. to calculate a gas limit contract overestimates it and if the value goes higher than L1 maximum gas in the block then the withdraw can't be relayed in the L1 and users funds would be lost while the withdraw could be possible before the migration it won't be possible after it.\n\n## Vulnerability Detail\nThis is `MigrateWithdrawal()` code:\n```solidity\n// MigrateWithdrawal will turn a LegacyWithdrawal into a bedrock\n// style Withdrawal.\nfunc MigrateWithdrawal(withdrawal *LegacyWithdrawal, l1CrossDomainMessenger *common.Address) (*Withdrawal, error) {\n\t// Attempt to parse the value\n\tvalue, err := withdrawal.Value()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot migrate withdrawal: %w\", err)\n\t}\n\n\tabi, err := bindings.L1CrossDomainMessengerMetaData.GetAbi()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Migrated withdrawals are specified as version 0. Both the\n\t// L2ToL1MessagePasser and the CrossDomainMessenger use the same\n\t// versioning scheme. Both should be set to version 0\n\tversionedNonce := EncodeVersionedNonce(withdrawal.Nonce, new(big.Int))\n\t// Encode the call to `relayMessage` on the `CrossDomainMessenger`.\n\t// The minGasLimit can safely be 0 here.\n\tdata, err := abi.Pack(\n\t\t\"relayMessage\",\n\t\tversionedNonce,\n\t\twithdrawal.Sender,\n\t\twithdrawal.Target,\n\t\tvalue,\n\t\tnew(big.Int),\n\t\twithdrawal.Data,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot abi encode relayMessage: %w\", err)\n\t}\n\n\t// Set the outer gas limit. This cannot be zero\n\tgasLimit := uint64(len(data)*16 + 200_000)\n\n\tw := NewWithdrawal(\n\t\tversionedNonce,\n\t\t&predeploys.L2CrossDomainMessengerAddr,\n\t\tl1CrossDomainMessenger,\n\t\tvalue,\n\t\tnew(big.Int).SetUint64(gasLimit),\n\t\tdata,\n\t)\n\treturn w, nil\n}\n```\nAs you can see it sets the gas limit as `gasLimit := uint64(len(data)*16 + 200_000)` and contract set 16 gas per data byte but in Ethereum when data byte is 0 then the overhead intrinsic gas is 4 and contract overestimate the gas limit by setting 16 gas for each data. this can cause messages with big data(which calculated gas is higher than 30M) to not be relay able in the L1 because if transaction gas set lower than calculated gas then OptimisimPortal would reject it and if gas set higher than calculated gas then miners would reject the transaction. while if code correctly estimated the required gas the gas limit could be lower by the factor of 4.\nfor example a message with about 2M zeros would get gas limit higher than 30M and it won't be withdrawable in the L1 while the real gas limit is 8M which is relayable.\n\n## Impact\nsome withdraw messages from L2 to L1 that could be relayed before the migration can't be relayed after the migration because of the wrong gas estimation.\n\n## Code Snippet\nhttps://github.com/ethereum-optimism/optimism/blob/3f4b3c328153a8aa03611158b6984d624b17c1d9/op-chain-ops/crossdomain/migrate.go#L83-L88\n\n## Tool used\nManual Review\n\n## Recommendation\ncalculate gas estimation correctly, 4 for 0 bytes and 16 for none zero bytes.\n\n## Discussion\n\n**rcstanciu**\n\nComment from Optimism\n\n---\n\n **Description:** Incorrect gas limit calculation for migrated withdrawals\n\n\n **Reason:** This is a legitimate issue.\n\n\n **Action:** Implement correct gas estimation\n\n\n\n**0xunforgiven**\n\nEscalate for 111 USDC\n\nThis should labeled as High because some of old legit withdrawals(L2 -> L1) won't be executed in the L1 after the bedrock migration. Those withdrawals belongs to L2CrossDomainMessages which promised to be delivered in L1.\n\nUsers may lose funds and there is no limit for it. there may be users who wants to withdraw 1M funds with L2StandardBridge and because of this issue their funds would be lost even so the L2StandardBridge is supposed to deliver the funds!\nThe withdrawals with large amount of data isn't that rare, There may be other protocols or users in L2 which uses the bridge to store data in the L1 and send withdrawals with large data to the L2CrossDomainMessenger and because of the issue their withdrawal message won't be finalized in L1 after migration.\n\nIt is true that this would only happen to some of the withdrawal messages but as we have other gas related issues that blocks withdrawal of limited number of withdrawals(#96 which is only happen to withdrawals that would revert if gas was 5K lower and #109 which happened to withdrawals with higher than ~1M gas) and they considered as High so to be fair This issue should be High too.\n\nThis is direct fund loss if it happens to user ETH bridges and also cause L2CrossDomainMessenger's messages to not finalized and be replayable in L1 if it happens to it's withdrawal messages.\n\n**sherlock-admin**\n\n > Escalate for 111 USDC\n> \n> This should labeled as High because some of old legit withdrawals(L2 -> L1) won't be executed in the L1 after the bedrock migration. Those withdrawals belongs to L2CrossDomainMessages which promised to be delivered in L1.\n> \n> Users may lose funds and there is no limit for it. there may be users who wants to withdraw 1M funds with L2StandardBridge and because of this issue their funds would be lost even so the L2StandardBridge is supposed to deliver the funds!\n> The withdrawals with large amount of data isn't that rare, There may be other protocols or users in L2 which uses the bridge to store data in the L1 and send withdrawals with large data to the L2CrossDomainMessenger and because of the issue their withdrawal message won't be finalized in L1 after migration.\n> \n> It is true that this would only happen to some of the withdrawal messages but as we have other gas related issues that blocks withdrawal of limited number of withdrawals(#96 which is only happen to withdrawals that would revert if gas was 5K lower and #109 which happened to withdrawals with higher than ~1M gas) and they considered as High so to be fair This issue should be High too.\n> \n> This is direct fund loss if it happens to user ETH bridges and also cause L2CrossDomainMessenger's messages to not finalized and be replayable in L1 if it happens to it's withdrawal messages.\n\nYou've created a valid escalation for 111 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected as there is insufficient evidence for high severity. \n\n**sherlock-admin**\n\n> Escalation rejected as there is insufficient evidence for high severity. \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/38",
  "Code": [
    {
      "filename": "op-chain-ops/crossdomain/migrate.go",
      "content": "package crossdomain\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/ethereum-optimism/optimism/op-bindings/bindings\"\n\t\"github.com/ethereum-optimism/optimism/op-bindings/predeploys\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n\t\"github.com/ethereum/go-ethereum/log\"\n)\n\nvar (\n\tabiTrue                      = common.Hash{31: 0x01}\n\terrLegacyStorageSlotNotFound = errors.New(\"cannot find storage slot\")\n)\n\n// MigrateWithdrawals will migrate a list of pending withdrawals given a StateDB.\nfunc MigrateWithdrawals(withdrawals []*LegacyWithdrawal, db vm.StateDB, l1CrossDomainMessenger *common.Address, noCheck bool) error {\n\tfor i, legacy := range withdrawals {\n\t\tlegacySlot, err := legacy.StorageSlot()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !noCheck {\n\t\t\tlegacyValue := db.GetState(predeploys.LegacyMessagePasserAddr, legacySlot)\n\t\t\tif legacyValue != abiTrue {\n\t\t\t\treturn fmt.Errorf(\"%w: %s\", errLegacyStorageSlotNotFound, legacySlot)\n\t\t\t}\n\t\t}\n\n\t\twithdrawal, err := MigrateWithdrawal(legacy, l1CrossDomainMessenger)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tslot, err := withdrawal.StorageSlot()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot compute withdrawal storage slot: %w\", err)\n\t\t}\n\n\t\tdb.SetState(predeploys.L2ToL1MessagePasserAddr, slot, abiTrue)\n\t\tlog.Info(\"Migrated withdrawal\", \"number\", i, \"slot\", slot)\n\t}\n\treturn nil\n}\n\n// MigrateWithdrawal will turn a LegacyWithdrawal into a bedrock\n// style Withdrawal.\nfunc MigrateWithdrawal(withdrawal *LegacyWithdrawal, l1CrossDomainMessenger *common.Address) (*Withdrawal, error) {\n\t// Attempt to parse the value\n\tvalue, err := withdrawal.Value()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot migrate withdrawal: %w\", err)\n\t}\n\n\tabi, err := bindings.L1CrossDomainMessengerMetaData.GetAbi()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Migrated withdrawals are specified as version 0. Both the\n\t// L2ToL1MessagePasser and the CrossDomainMessenger use the same\n\t// versioning scheme. Both should be set to version 0\n\tversionedNonce := EncodeVersionedNonce(withdrawal.Nonce, new(big.Int))\n\t// Encode the call to `relayMessage` on the `CrossDomainMessenger`.\n\t// The minGasLimit can safely be 0 here.\n\tdata, err := abi.Pack(\n\t\t\"relayMessage\",\n\t\tversionedNonce,\n\t\twithdrawal.Sender,\n\t\twithdrawal.Target,\n\t\tvalue,\n\t\tnew(big.Int),\n\t\twithdrawal.Data,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot abi encode relayMessage: %w\", err)\n\t}\n\n\t// Set the outer gas limit. This cannot be zero\n\tgasLimit := uint64(len(data)*16 + 200_000)\n\n\tw := NewWithdrawal(\n\t\tversionedNonce,\n\t\t&predeploys.L2CrossDomainMessengerAddr,\n\t\tl1CrossDomainMessenger,\n\t\tvalue,\n\t\tnew(big.Int).SetUint64(gasLimit),\n\t\tdata,\n\t)\n\treturn w, nil\n}"
    }
  ]
}