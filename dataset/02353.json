{
  "Title": "Incorrect or misleading documentation [core and samples]",
  "Content": "Several docstrings and inline comments throughout the code base were found to be incorrect or misleading. In particular:\n\n\n* In `BaseAccount.sol`:\n\t+ [Line 72](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BaseAccount.sol#L72): The docstring defines `sigTimeRange` as “signature and time-range for this operation”, but it contains the signature validity, not the signature itself.\n* In `BLSSignatureAggregator.sol`:\n\t+ [Line 117](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L117): The docstring references a call to `simulateUserOperation`. The function name should be `simulateValidation`.\n* In `EIP4337Manager.sol`:\n\t+ [Line 21](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L21): The docstring states the contract inherits `GnosisSafeStorage`, but it actually inherits `GnosisSafe`.\n* In `EntryPoint.sol`:\n\t+ [Line 180](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L180): The comment does not include [`paymasterAndData`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L30) as one of the dynamic byte arrays being excluded from `MemoryUserOp`.\n\t+ [Line 393](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L393): The docstring states that `_validatePaymasterPrepayment` validates that the paymaster is staked, but the function does not perform this check.\n* In `IPaymaster.sol`:\n\t+ [Lines 25-26](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IPaymaster.sol#L25-L26): The docstring states that the `validUntil` and `validAfter` timestamps are 4 bytes in length, but these are 8-byte (uint64) values.\n* In `IStakeManager.sol`:\n\t+ [Line 7](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L7), [lines 43-44](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L43-L44): Docstrings in this contract refer to staking only for paymasters, implying this is the only entity that should stake. Signature aggregators and factories are also required to stake following the same rules as paymasters.\n\t+ [Line 45](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L45): The docstring makes a reference to the “global unstakeDelaySec”, which no longer exists.\n\t+ [Line 47](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L47): The `DepositInfo` docstring explains that the variable sizes were chosen so that `deposit` and `staked` fit into a single `uint256` word, but the 3rd parameter `stake` will also fit.\n* In `SimpleAccount.sol`:\n\t+ [Line 52](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L52): The comment makes a reference to the `execFromEntryPoint` function, which no longer exists.\n\t+ [Line 57](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L57): The docstring for `execute` says “called directly from owner, not by entryPoint”, but the [`_requireFromEntryPointOrOwner`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L60) function allows `execute` to be called by the EntryPoint. The comment isn’t clear on whether it is a suggestion, or a restriction to be enforced.\n\t+ [Lines 75-79](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L75-L79): The docstring does not match the `initialize` function.\n\t+ [Lines 89-96](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L89-L96): The docstring does not match the `_requireFromEntryPointOrOwner` function.\n* In `IEntryPoint.sol`:\n\t+ [Line 26](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IEntryPoint.sol#L26): The `@success` parameter is listed in the wrong order.\n* In `UserOperation.sol`:\n\t+ [Line 25](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L25): The `callGasLimit` parameter has no `@param` statement.\n\n\n***Update:** Resolved in [pull request #194](https://github.com/eth-infinitism/account-abstraction/pull/194) and [pull request #216](https://github.com/eth-infinitism/account-abstraction/pull/216), which were merged at commits [`faf305e`](https://github.com/eth-infinitism/account-abstraction/commit/faf305e3022ac7daa7cafb141ffe1dc1f936ee6c) and [`1f505c5`](https://github.com/eth-infinitism/account-abstraction/commit/1f505c5889b04a115b1bf09386c0b84cecdad5c4) respectively.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/BaseAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\n/**\n * Basic account implementation.\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\n * specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseAccount is IAccount {\n    using UserOperationLib for UserOperation;\n\n    //return value in case of signature failure, with no time-range.\n    // equivalent to packSigTimeRange(true,0,0);\n    uint256 constant internal SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * helper to pack the return value for validateUserOp\n     * @param sigFailed true if the signature check failed, false, if it succeeded.\n     * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\n     * @param validAfter first timestamp this UserOperation is valid\n     */\n    function packSigTimeRange(bool sigFailed, uint256 validUntil, uint256 validAfter) internal pure returns (uint256) {\n        return uint256(sigFailed ? 1 : 0) | uint256(validUntil << 8) | uint256(validAfter << (64+8));\n    }\n\n    /**\n     * return the account nonce.\n     * subclass should return a nonce value that is used both by _validateAndUpdateNonce, and by the external provider (to read the current nonce)\n     */\n    function nonce() public view virtual returns (uint256);\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\n     */\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address aggregator, uint256 missingAccountFunds)\n    external override virtual returns (uint256 sigTimeRange) {\n        _requireFromEntryPoint();\n        sigTimeRange = _validateSignature(userOp, userOpHash, aggregator);\n        if (userOp.initCode.length == 0) {\n            _validateAndUpdateNonce(userOp);\n        }\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal virtual view {\n        require(msg.sender == address(entryPoint()), \"account: not from EntryPoint\");\n    }\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain-id)\n     * @param aggregator the current aggregator. can be ignored by accounts that don't use aggregators\n     * @return sigTimeRange signature and time-range of this operation\n     *      <byte> sigFailure - (1) to mark signature failure, 0 for valid signature.\n     *      <8-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <8-byte> validAfter - first timestamp this operation is valid\n     *      The an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address aggregator)\n    internal virtual returns (uint256 sigTimeRange);\n\n    /**\n     * validate the current nonce matches the UserOperation nonce.\n     * then it should update the account's state to prevent replay of this UserOperation.\n     * called only if initCode is empty (since \"nonce\" field is used as \"salt\" on account creation)\n     * @param userOp the op to validate.\n     */\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal virtual;\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success,) = payable(msg.sender).call{value : missingAccountFunds, gas : type(uint256).max}(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n}"
    },
    {
      "filename": "contracts/bls/BLSSignatureAggregator.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4 <0.9.0;\npragma abicoder v2;\n\nimport \"../interfaces/IAggregator.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport {BLSOpen} from  \"./lib/BLSOpen.sol\";\nimport \"./IBLSAccount.sol\";\nimport \"./BLSHelper.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * A BLS-based signature aggregator, to validate aggregated signature of multiple UserOps if BLSAccount\n */\ncontract BLSSignatureAggregator is IAggregator {\n    using UserOperationLib for UserOperation;\n\n    bytes32 public constant BLS_DOMAIN = keccak256(\"eip4337.bls.domain\");\n\n    function getUserOpPublicKey(UserOperation memory userOp) public view returns (uint256[4] memory publicKey) {\n        bytes memory initCode = userOp.initCode;\n        if (initCode.length > 0) {\n            publicKey = getTrailingPublicKey(initCode);\n        } else {\n            return IBLSAccount(userOp.sender).getBlsPublicKey();\n        }\n    }\n\n    /**\n     * return the trailing 4 words of input data\n     */\n    function getTrailingPublicKey(bytes memory data) public pure returns (uint256[4] memory publicKey) {\n        uint len = data.length;\n        require(len > 32 * 4, \"data to short for sig\");\n\n        /* solhint-disable-next-line no-inline-assembly */\n        assembly {\n        // actual buffer starts at data+32, so last 128 bytes start at data+32+len-128 = data+len-96\n            let ofs := sub(add(data, len), 96)\n            mstore(publicKey, mload(ofs))\n            mstore(add(publicKey, 32), mload(add(ofs, 32)))\n            mstore(add(publicKey, 64), mload(add(ofs, 64)))\n            mstore(add(publicKey, 96), mload(add(ofs, 96)))\n        }\n    }\n\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature)\n    external view override {\n        require(signature.length == 64, \"BLS: invalid signature\");\n        (uint256[2] memory blsSignature) = abi.decode(signature, (uint256[2]));\n\n        uint userOpsLen = userOps.length;\n        uint256[4][] memory blsPublicKeys = new uint256[4][](userOpsLen);\n        uint256[2][] memory messages = new uint256[2][](userOpsLen);\n        for (uint256 i = 0; i < userOpsLen; i++) {\n\n            UserOperation memory userOp = userOps[i];\n            IBLSAccount blsAccount = IBLSAccount(userOp.sender);\n\n            blsPublicKeys[i] = blsAccount.getBlsPublicKey{gas : 30000}();\n\n            messages[i] = _userOpToMessage(userOp, keccak256(abi.encode(blsPublicKeys[i])));\n        }\n        require(BLSOpen.verifyMultiple(blsSignature, blsPublicKeys, messages), \"BLS: validateSignatures failed\");\n    }\n\n    /**\n     * get a hash of userOp\n     * NOTE: this hash is not the same as UserOperation.hash()\n     *  (slightly less efficient, since it uses memory userOp)\n     */\n    function internalUserOpHash(UserOperation memory userOp) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n                userOp.sender,\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas,\n                keccak256(userOp.paymasterAndData)\n            ));\n    }\n\n    /**\n     * return the BLS \"message\" for the given UserOp.\n     * the account checks the signature over this value  using its public-key\n     */\n    function userOpToMessage(UserOperation memory userOp) public view returns (uint256[2] memory) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _userOpToMessage(userOp, hashPublicKey);\n    }\n\n    function _userOpToMessage(UserOperation memory userOp, bytes32 publicKeyHash) internal view returns (uint256[2] memory) {\n        bytes32 userOpHash = _getUserOpHash(userOp, publicKeyHash);\n        return BLSOpen.hashToPoint(BLS_DOMAIN, abi.encodePacked(userOpHash));\n    }\n\n    //return the public-key hash of a userOp.\n    function _getUserOpPubkeyHash(UserOperation memory userOp) internal view returns (bytes32 hashPublicKey) {\n        return keccak256(abi.encode(getUserOpPublicKey(userOp)));\n    }\n\n    function getUserOpHash(UserOperation memory userOp) public view returns (bytes32) {\n        bytes32 hashPublicKey = _getUserOpPubkeyHash(userOp);\n        return _getUserOpHash(userOp, hashPublicKey);\n    }\n\n    function _getUserOpHash(UserOperation memory userOp, bytes32 hashPublicKey) internal view returns (bytes32) {\n        return keccak256(abi.encode(internalUserOpHash(userOp), hashPublicKey, address(this), block.chainid));\n    }\n\n    /**\n     * validate signature of a single userOp\n     * This method is called after EntryPoint.simulateUserOperation() returns an aggregator.\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(UserOperation calldata userOp)\n    external view returns (bytes memory sigForUserOp) {\n        uint256[2] memory signature = abi.decode(userOp.signature, (uint256[2]));\n        uint256[4] memory pubkey = getUserOpPublicKey(userOp);\n        uint256[2] memory message = userOpToMessage(userOp);\n\n        require(BLSOpen.verifySingle(signature, pubkey, message), \"BLS: wrong sig\");\n        return \"\";\n    }\n\n    //copied from BLS.sol\n    uint256 public  constant N = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatesSignature the aggregated signature\n     */\n    function aggregateSignatures(UserOperation[] calldata userOps) external pure returns (bytes memory aggregatesSignature) {\n        BLSHelper.XY[] memory points = new BLSHelper.XY[](userOps.length);\n        for (uint i = 0; i < points.length; i++) {\n            (uint x, uint y) = abi.decode(userOps[i].signature, (uint, uint));\n            points[i] = BLSHelper.XY(x, y);\n        }\n        BLSHelper.XY memory sum = BLSHelper.sum(points, N);\n        return abi.encode(sum.x, sum.y);\n    }\n\n    /**\n     * allow staking for this aggregator\n     * there is no limit on stake  or delay, but it is not a problem, since it is a permissionless\n     * signature aggregator, which doesn't support unstaking.\n     */\n    function addStake(IEntryPoint entryPoint, uint32 delay) external payable {\n        entryPoint.addStake{value : msg.value}(delay);\n    }\n}"
    },
    {
      "filename": "contracts/gnosis/EIP4337Manager.sol",
      "content": "//SPDX-License-Identifier: GPL\npragma solidity ^0.8.7;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport \"./EIP4337Fallback.sol\";\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\n    using ECDSA for bytes32;\n\n/**\n * Main EIP4337 module.\n * Called (through the fallback module) using \"delegate\" from the GnosisSafe as an \"IAccount\",\n * so must implement validateUserOp\n * holds an immutable reference to the EntryPoint\n * Inherits GnosisSafeStorage so that it can reference the memory storage\n */\ncontract EIP4337Manager is GnosisSafe, IAccount {\n\n    address public immutable eip4337Fallback;\n    address public immutable entryPoint;\n\n    constructor(address anEntryPoint) {\n        entryPoint = anEntryPoint;\n        eip4337Fallback = address(new EIP4337Fallback(address(this)));\n    }\n\n    /**\n     * delegate-called (using execFromModule) through the fallback, so \"real\" msg.sender is attached as last 20 bytes\n     */\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address /*aggregator*/, uint256 missingAccountFunds)\n    external override returns (uint256 sigTimeRange) {\n        address _msgSender = address(bytes20(msg.data[msg.data.length - 20 :]));\n        require(_msgSender == entryPoint, \"account: not from entrypoint\");\n\n        GnosisSafe pThis = GnosisSafe(payable(address(this)));\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        address recovered = hash.recover(userOp.signature);\n        require(threshold == 1, \"account: only threshold 1\");\n        require(pThis.isOwner(recovered), \"account: wrong signature\");\n\n        if (userOp.initCode.length == 0) {\n            require(nonce++ == userOp.nonce, \"account: invalid nonce\");\n        }\n\n        if (missingAccountFunds > 0) {\n            //TODO: MAY pay more than the minimum, to deposit for future transactions\n            (bool success,) = payable(_msgSender).call{value : missingAccountFunds}(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n        return 0;\n    }\n\n    /**\n     * set up a safe as EIP-4337 enabled.\n     * called from the GnosisSafeAccountFactory during construction time\n     * - enable 3 modules (this module, fallback and the entrypoint)\n     * - this method is called with delegateCall, so the module (usually itself) is passed as parameter, and \"this\" is the safe itself\n     */\n    function setup4337Modules(\n        EIP4337Manager manager //the manager (this contract)\n    ) external {\n        GnosisSafe safe = GnosisSafe(payable(this));\n        safe.enableModule(manager.entryPoint());\n        safe.enableModule(manager.eip4337Fallback());\n    }\n\n    /**\n     * replace EIP4337 module, to support a new EntryPoint.\n     * must be called using execTransaction and Enum.Operation.DelegateCall\n     * @param prevModule returned by getCurrentEIP4337Manager\n     * @param oldManager the old EIP4337 manager to remove, returned by getCurrentEIP4337Manager\n     * @param newManager the new EIP4337Manager, usually with a new EntryPoint\n     */\n    function replaceEIP4337Manager(address prevModule, EIP4337Manager oldManager, EIP4337Manager newManager) public {\n\n        GnosisSafe pThis = GnosisSafe(payable(address(this)));\n        address oldFallback = oldManager.eip4337Fallback();\n        require(pThis.isModuleEnabled(oldFallback), \"replaceEIP4337Manager: oldManager is not active\");\n        pThis.disableModule(oldFallback, oldManager.entryPoint());\n        pThis.disableModule(prevModule, oldFallback);\n\n        address eip4337fallback = newManager.eip4337Fallback();\n\n        pThis.enableModule(newManager.entryPoint());\n        pThis.enableModule(eip4337fallback);\n\n        pThis.setFallbackHandler(eip4337fallback);\n\n        validateEip4337(pThis, newManager);\n    }\n\n    /**\n     * Validate this gnosisSafe is callable through the EntryPoint.\n     * the test is might be incomplete: we check that we reach our validateUserOp and fail on signature.\n     *  we don't test full transaction\n     */\n    function validateEip4337(GnosisSafe safe, EIP4337Manager manager) public {\n\n        // this prevent mistaken replaceEIP4337Manager to disable the module completely.\n        // minimal signature that pass \"recover\"\n        bytes memory sig = new bytes(65);\n        sig[64] = bytes1(uint8(27));\n        sig[2] = bytes1(uint8(1));\n        sig[35] = bytes1(uint8(1));\n        UserOperation memory userOp = UserOperation(address(safe), 0, \"\", \"\", 0, 1000000, 0, 0, 0, \"\", sig);\n        UserOperation[] memory userOps = new UserOperation[](1);\n        userOps[0] = userOp;\n        IEntryPoint _entryPoint = IEntryPoint(payable(manager.entryPoint()));\n        try _entryPoint.handleOps(userOps, payable(msg.sender)) {\n            revert(\"validateEip4337: handleOps must fail\");\n        } catch (bytes memory error) {\n            if (keccak256(error) != keccak256(abi.encodeWithSignature(\"FailedOp(uint256,address,string)\", 0, address(0), \"account: wrong signature\"))) {\n                revert(string(error));\n            }\n        }\n    }\n\n    function delegateCall(address to, bytes memory data) internal {\n        bool success;\n        assembly {\n            success := delegatecall(sub(0, 1), to, add(data, 0x20), mload(data), 0, 0)\n        }\n        require(success, \"delegate failed\");\n    }\n\n    /**\n     * enumerate modules, and find the currently active EIP4337 manager (and previous module)\n     * @return prev prev module, needed by replaceEIP4337Manager\n     * @return manager the current active EIP4337Manager\n     */\n    function getCurrentEIP4337Manager(GnosisSafe safe) public view returns (address prev, address manager) {\n\n        prev = address(SENTINEL_MODULES);\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_MODULES, 100);\n        for (uint i = 0; i < modules.length; i++) {\n            address module = modules[i];\n            (bool success,bytes memory ret) = module.staticcall(abi.encodeWithSignature(\"eip4337manager()\"));\n            if (success) {\n                manager = abi.decode(ret, (address));\n                return (prev, manager);\n            }\n            prev = module;\n        }\n        return (address(0), address(0));\n    }\n}"
    },
    {
      "filename": "contracts/core/EntryPoint.sol",
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\n\nimport \"../interfaces/IAggregatedAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\n\ncontract EntryPoint is IEntryPoint, StakeManager {\n\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    // marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex'deaddead';\n\n    /**\n     * for simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value\n     * in case of signature failure, instead of revert.\n     */\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value : amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex into into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\n            collected = _actualGasCost;\n        } catch {\n            bytes32 innerRevertCode;\n            assembly {\n                returndatacopy(0, 0, 32)\n                innerRevertCode := mload(0)\n            }\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if(innerRevertCode == INNER_OUT_OF_GAS) {\n                //report paymaster, since if it is deliberately caused by the bundler,\n                // it must be a revert caused by paymaster.\n                revert FailedOp(opIndex, opInfo.mUserOp.paymaster, \"AA95 out of gas\");\n            }\n\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an \"actualAggregator\" when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\n\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n    unchecked {\n        for (uint256 i = 0; i < opslen; i++) {\n            UserOpInfo memory opInfo = opInfos[i];\n            (uint256 sigTimeRange, uint256 paymasterTimeRange,) = _validatePrepayment(i, ops[i], opInfo, address(0));\n            _validateSigTimeRange(i, opInfo, sigTimeRange, paymasterTimeRange);\n        }\n\n        uint256 collected = 0;\n\n        for (uint256 i = 0; i < opslen; i++) {\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\n        }\n\n        _compensate(beneficiary, collected);\n    } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public {\n\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            totalOps += opsPerAggregator[i].userOps.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (uint256 sigTimeRange, uint256 paymasterTimeRange,) = _validatePrepayment(opIndex, ops[i], opInfo, address(aggregator));\n                _validateSigTimeRange(i, opInfo, sigTimeRange, paymasterTimeRange);\n                opIndex++;\n            }\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    function simulateHandleOp(UserOperation calldata op) external override {\n\n        UserOpInfo memory opInfo;\n\n        (uint256 sigTimeRange, uint256 paymasterTimeRange,) = _validatePrepayment(0, op, opInfo, SIMULATE_FIND_AGGREGATOR);\n        (,uint64 validAfter, uint64 validUntil) = _intersectTimeRange(sigTimeRange, paymasterTimeRange);\n\n        numberMarker();\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        revert ExecutionResult(opInfo.preOpGas, paid, validAfter, validUntil);\n    }\n\n\n    //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(bytes calldata callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint callGasLimit = mUserOp.callGasLimit;\n    unchecked {\n        // handleOps was called with gas limit too low. abort entire bundle.\n        if (gasleft() < callGasLimit + mUserOp.verificationGasLimit + 5000) {\n            assembly {\n                mstore(0, INNER_OUT_OF_GAS)\n                revert(0, 32)\n            }\n        }\n    }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n\n            (bool success,bytes memory result) = address(mUserOp.sender).call{gas : callGasLimit}(callData);\n            if (!success) {\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n    unchecked {\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\n    }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        UserOpInfo memory outOpInfo;\n\n        (uint256 sigTimeRange, uint256 paymasterTimeRange, address aggregator) = _validatePrepayment(0, userOp, outOpInfo, SIMULATE_FIND_AGGREGATOR);\n        StakeInfo memory paymasterInfo = getStakeInfo(outOpInfo.mUserOp.paymaster);\n        StakeInfo memory senderInfo = getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\n            factoryInfo = getStakeInfo(factory);\n        }\n\n        (bool sigFailed, uint64 validAfter, uint64 validUntil) = _intersectTimeRange(sigTimeRange, paymasterTimeRange);\n        ReturnInfo memory returnInfo = ReturnInfo(outOpInfo.preOpGas, outOpInfo.prefund,\n            sigFailed, validAfter, validUntil, getMemoryBytesFromOffset(outOpInfo.contextOffset));\n\n        if (aggregator != address(0)) {\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, getStakeInfo(aggregator));\n            revert ValidationResultWithAggregation(returnInfo, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\n        }\n        revert ValidationResult(returnInfo, senderInfo, factoryInfo, paymasterInfo);\n\n    }\n\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal view returns (uint256 requiredPrefund) {\n    unchecked {\n        //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n        // our security model might call postOp eventually twice\n        uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n        uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\n\n        // TODO: copy logic of gasPrice?\n        requiredPrefund = requiredGas * getUserOpGasPrice(mUserOp);\n    }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0) revert FailedOp(opIndex, address(0), \"AA10 sender already constructed\");\n            address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\n            if (sender1 == address(0)) revert FailedOp(opIndex, address(0), \"AA13 initCode failed or OOG\");\n            if (sender1 != sender) revert FailedOp(opIndex, address(0), \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0) revert FailedOp(opIndex, address(0), \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0 : 20]));\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n        }\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function g"
    }
  ]
}