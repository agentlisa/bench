{
  "Title": "Transfer of wallet ownership can be DoSed — Method 2",
  "Content": "Even if the calls to [`build(address _owner)`](https://github.com/InstaDApp/contract-v2/blob/4863c0c4156af7ded9cdb38b66e5f5e527c4a6d0/contracts/InstaRegistry.sol#L126) are restricted (as mentioned in the issue “Transfer of wallet ownership can be DoSed — Method 1”), an attacker may prevent owners of wallets from transferring ownership. This second method of preventing ownership transfers works as follows.\n\n\nThe attacker can front-run each transaction of the form `setOwner(X)` with a single transaction that performs both of the following functions atomically:\n\n\n1. Calls [`build()`](https://github.com/InstaDApp/contract-v2/blob/4863c0c4156af7ded9cdb38b66e5f5e527c4a6d0/contracts/InstaRegistry.sol#L119) to create a new UserWallet instance that the attacker controls.\n2. Transfers ownership of the new UserWallet instance to address `X` by calling [`setOwner(X)`](https://github.com/InstaDApp/contract-v2/blob/4863c0c4156af7ded9cdb38b66e5f5e527c4a6d0/contracts/UserWallet.sol#L53) on the attacker’s new UserWallet instance.\n\n\n(These two actions can be performed atomically in a single transaction by creating an exploit contract that performs both functions in a single function call.)\n\n\nAs before, this results in `proxies[X]` not being equal to `UserWallet(0)` when the `setOwner(X)` transaction is processed — causing a `revert` at [line 139 of InstaRegistry.sol](https://github.com/InstaDApp/contract-v2/blob/4863c0c4156af7ded9cdb38b66e5f5e527c4a6d0/contracts/InstaRegistry.sol#L139), and thus preventing the honest user from transferring ownership.\n\n\nConsider implementing an “active ownership acceptance” scheme that requires newly proposed owners to accept ownership actively. For example, ownership transfer would be a two-step process where:\n\n\n1. The current owner sets a “pending owner.”\n2. The “pending owner” calls a function (ie: `acceptOwnershipTransfer()`) in order to claim ownership.\n\n\nFor an audited example of this pattern, see [Micah Zoltu’s recoverable wallet](https://github.com/Zoltu/recoverable-wallet/blob/master/contracts/source/recoverable-wallet.sol#L53-L82) contract.\n\n\nThis active ownership acceptance scheme would prevent this method of DoS’ing ownership transfer, as well as prevent accidental burning of UserWallets by inexperienced users transferring their wallet ownership to an inactive address (or to a contract that is not equipped to interact with UserWallets).\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/InstaRegistry.sol",
      "content": "pragma solidity ^0.5.2;\n\nimport \"./UserWallet.sol\";\n\n\n/// @title AddressRegistry\n/// @notice \n/// @dev \ncontract AddressRegistry {\n    event LogSetAddress(string name, address addr);\n\n    /// @notice Registry of role and address\n    mapping(bytes32 => address) registry;\n\n    /**\n     * @dev Check if msg.sender is admin or owner.\n     */\n    modifier isAdmin() {\n        require(\n            msg.sender == getAddress(\"admin\") || \n            msg.sender == getAddress(\"owner\"),\n            \"permission-denied\"\n        );\n        _;\n    }\n\n    /// @dev Get the address from system registry \n    /// @param _name (string)\n    /// @return  (address) Returns address based on role\n    function getAddress(string memory _name) public view returns(address) {\n        return registry[keccak256(abi.encodePacked(_name))];\n    }\n\n    /// @dev Set new address in system registry \n    /// @param _name (string) Role name\n    /// @param _userAddress (string) User Address\n    function setAddress(string memory _name, address _userAddress) public isAdmin {\n        registry[keccak256(abi.encodePacked(_name))] = _userAddress;\n        emit LogSetAddress(_name, _userAddress);\n    }\n}\n\n\n/// @title LogicRegistry\n/// @notice\n/// @dev LogicRegistry \ncontract LogicRegistry is AddressRegistry {\n\n    event LogEnableStaticLogic(address logicAddress);\n    event LogEnableLogic(address logicAddress);\n    event LogDisableLogic(address logicAddress);\n\n    /// @notice Map of static proxy state\n    mapping(address => bool) public logicProxiesStatic;\n    \n    /// @notice Map of logic proxy state\n    mapping(address => bool) public logicProxies;\n\n    /// @dev \n    /// @param _logicAddress (address)\n    /// @return  (bool)\n    function logic(address _logicAddress) public view returns (bool) {\n        if (logicProxiesStatic[_logicAddress] || logicProxies[_logicAddress]) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev \n    /// @param _logicAddress (address)\n    /// @return  (bool)\n    function logicStatic(address _logicAddress) public view returns (bool) {\n        if (logicProxiesStatic[_logicAddress]) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev Sets the static logic proxy to true\n    /// static proxies mostly contains the logic for withdrawal of assets\n    /// and can never be false to freely let user withdraw their assets\n    /// @param _logicAddress (address)\n    function enableStaticLogic(address _logicAddress) public isAdmin {\n        logicProxiesStatic[_logicAddress] = true;\n        emit LogEnableStaticLogic(_logicAddress);\n    }\n\n    /// @dev Enable logic proxy address\n    /// @param _logicAddress (address)\n    function enableLogic(address _logicAddress) public isAdmin {\n        logicProxies[_logicAddress] = true;\n        emit LogEnableLogic(_logicAddress);\n    }\n\n    /// @dev Disable logic proxy address\n    /// @param _logicAddress (address)\n    function disableLogic(address _logicAddress) public isAdmin {\n        logicProxies[_logicAddress] = false;\n        emit LogDisableLogic(_logicAddress);\n    }\n\n}\n\n\n/**\n * @dev Deploys a new proxy instance and sets msg.sender as owner of proxy\n */\ncontract WalletRegistry is LogicRegistry {\n    \n    event Created(address indexed sender, address indexed owner, address proxy);\n    event LogRecord(address indexed currentOwner, address indexed nextOwner, address proxy);\n    \n    /// @notice Address to UserWallet proxy map\n    mapping(address => UserWallet) public proxies;\n    \n    /// @dev Deploys a new proxy instance and sets custom owner of proxy\n    /// Throws if the owner already have a UserWallet\n    /// @return proxy ()\n    function build() public returns (UserWallet proxy) {\n        proxy = build(msg.sender);\n    }\n\n    /// @dev update the proxy record whenever owner changed on any proxy\n    /// Throws if msg.sender is not a proxy contract created via this contract\n    /// @return proxy () UserWallet\n    function build(address _owner) public returns (UserWallet proxy) {\n        require(proxies[_owner] == UserWallet(0), \"multiple-proxy-per-user-not-allowed\");\n        proxy = new UserWallet();\n        proxies[address(this)] = proxy; // will be changed via record() in next line execution\n        proxy.setOwner(_owner);\n        emit Created(msg.sender, _owner, address(proxy));\n    }\n\n    /// @dev Transafers ownership\n    /// @param _currentOwner (address) Current Owner\n    /// @param _nextOwner (address) Next Owner\n    function record(address _currentOwner, address _nextOwner) public {\n        require(msg.sender == address(proxies[_currentOwner]), \"invalid-proxy-or-owner\");\n        require(proxies[_nextOwner] == UserWallet(0), \"multiple-proxy-per-user-not-allowed\");\n        proxies[_nextOwner] = proxies[_currentOwner];\n        proxies[_currentOwner] = UserWallet(0);\n        emit LogRecord(_currentOwner, _nextOwner, address(proxies[_nextOwner]));\n    }\n\n}\n\n\n/// @title InstaRegistry\n/// @dev Initializing Registry\ncontract InstaRegistry is WalletRegistry {\n\n    constructor() public {\n        registry[keccak256(abi.encodePacked(\"admin\"))] = msg.sender;\n        registry[keccak256(abi.encodePacked(\"owner\"))] = msg.sender;\n    }\n}"
    },
    {
      "filename": "contracts/InstaRegistry.sol",
      "content": "pragma solidity ^0.5.2;\n\nimport \"./UserWallet.sol\";\n\n\n/// @title AddressRegistry\n/// @notice \n/// @dev \ncontract AddressRegistry {\n    event LogSetAddress(string name, address addr);\n\n    /// @notice Registry of role and address\n    mapping(bytes32 => address) registry;\n\n    /**\n     * @dev Check if msg.sender is admin or owner.\n     */\n    modifier isAdmin() {\n        require(\n            msg.sender == getAddress(\"admin\") || \n            msg.sender == getAddress(\"owner\"),\n            \"permission-denied\"\n        );\n        _;\n    }\n\n    /// @dev Get the address from system registry \n    /// @param _name (string)\n    /// @return  (address) Returns address based on role\n    function getAddress(string memory _name) public view returns(address) {\n        return registry[keccak256(abi.encodePacked(_name))];\n    }\n\n    /// @dev Set new address in system registry \n    /// @param _name (string) Role name\n    /// @param _userAddress (string) User Address\n    function setAddress(string memory _name, address _userAddress) public isAdmin {\n        registry[keccak256(abi.encodePacked(_name))] = _userAddress;\n        emit LogSetAddress(_name, _userAddress);\n    }\n}\n\n\n/// @title LogicRegistry\n/// @notice\n/// @dev LogicRegistry \ncontract LogicRegistry is AddressRegistry {\n\n    event LogEnableStaticLogic(address logicAddress);\n    event LogEnableLogic(address logicAddress);\n    event LogDisableLogic(address logicAddress);\n\n    /// @notice Map of static proxy state\n    mapping(address => bool) public logicProxiesStatic;\n    \n    /// @notice Map of logic proxy state\n    mapping(address => bool) public logicProxies;\n\n    /// @dev \n    /// @param _logicAddress (address)\n    /// @return  (bool)\n    function logic(address _logicAddress) public view returns (bool) {\n        if (logicProxiesStatic[_logicAddress] || logicProxies[_logicAddress]) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev \n    /// @param _logicAddress (address)\n    /// @return  (bool)\n    function logicStatic(address _logicAddress) public view returns (bool) {\n        if (logicProxiesStatic[_logicAddress]) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev Sets the static logic proxy to true\n    /// static proxies mostly contains the logic for withdrawal of assets\n    /// and can never be false to freely let user withdraw their assets\n    /// @param _logicAddress (address)\n    function enableStaticLogic(address _logicAddress) public isAdmin {\n        logicProxiesStatic[_logicAddress] = true;\n        emit LogEnableStaticLogic(_logicAddress);\n    }\n\n    /// @dev Enable logic proxy address\n    /// @param _logicAddress (address)\n    function enableLogic(address _logicAddress) public isAdmin {\n        logicProxies[_logicAddress] = true;\n        emit LogEnableLogic(_logicAddress);\n    }\n\n    /// @dev Disable logic proxy address\n    /// @param _logicAddress (address)\n    function disableLogic(address _logicAddress) public isAdmin {\n        logicProxies[_logicAddress] = false;\n        emit LogDisableLogic(_logicAddress);\n    }\n\n}\n\n\n/**\n * @dev Deploys a new proxy instance and sets msg.sender as owner of proxy\n */\ncontract WalletRegistry is LogicRegistry {\n    \n    event Created(address indexed sender, address indexed owner, address proxy);\n    event LogRecord(address indexed currentOwner, address indexed nextOwner, address proxy);\n    \n    /// @notice Address to UserWallet proxy map\n    mapping(address => UserWallet) public proxies;\n    \n    /// @dev Deploys a new proxy instance and sets custom owner of proxy\n    /// Throws if the owner already have a UserWallet\n    /// @return proxy ()\n    function build() public returns (UserWallet proxy) {\n        proxy = build(msg.sender);\n    }\n\n    /// @dev update the proxy record whenever owner changed on any proxy\n    /// Throws if msg.sender is not a proxy contract created via this contract\n    /// @return proxy () UserWallet\n    function build(address _owner) public returns (UserWallet proxy) {\n        require(proxies[_owner] == UserWallet(0), \"multiple-proxy-per-user-not-allowed\");\n        proxy = new UserWallet();\n        proxies[address(this)] = proxy; // will be changed via record() in next line execution\n        proxy.setOwner(_owner);\n        emit Created(msg.sender, _owner, address(proxy));\n    }\n\n    /// @dev Transafers ownership\n    /// @param _currentOwner (address) Current Owner\n    /// @param _nextOwner (address) Next Owner\n    function record(address _currentOwner, address _nextOwner) public {\n        require(msg.sender == address(proxies[_currentOwner]), \"invalid-proxy-or-owner\");\n        require(proxies[_nextOwner] == UserWallet(0), \"multiple-proxy-per-user-not-allowed\");\n        proxies[_nextOwner] = proxies[_currentOwner];\n        proxies[_currentOwner] = UserWallet(0);\n        emit LogRecord(_currentOwner, _nextOwner, address(proxies[_nextOwner]));\n    }\n\n}\n\n\n/// @title InstaRegistry\n/// @dev Initializing Registry\ncontract InstaRegistry is WalletRegistry {\n\n    constructor() public {\n        registry[keccak256(abi.encodePacked(\"admin\"))] = msg.sender;\n        registry[keccak256(abi.encodePacked(\"owner\"))] = msg.sender;\n    }\n}"
    },
    {
      "filename": "contracts/UserWallet.sol",
      "content": "pragma solidity ^0.5.2;\n\n/**\n * @title RegistryInterface Interface \n */\ninterface RegistryInterface {\n    function logic(address logicAddr) external view returns (bool);\n    function record(address currentOwner, address nextOwner) external;\n}\n\n\n/**\n * @title Address Registry Record\n */\ncontract AddressRecord {\n\n    /**\n     * @dev address registry of system, logic and wallet addresses\n     */\n    address public registry;\n\n    /**\n     * @dev Throws if the logic is not authorised\n     */\n    modifier logicAuth(address logicAddr) {\n        require(logicAddr != address(0), \"logic-proxy-address-required\");\n        require(RegistryInterface(registry).logic(logicAddr), \"logic-not-authorised\");\n        _;\n    }\n\n}\n\n\n/**\n * @title User Auth\n */\ncontract UserAuth is AddressRecord {\n\n    event LogSetOwner(address indexed owner);\n    address public owner;\n\n    /**\n     * @dev Throws if not called by owner or contract itself\n     */\n    modifier auth {\n        require(isAuth(msg.sender), \"permission-denied\");\n        _;\n    }\n\n    /**\n     * @dev sets new owner\n     */\n    function setOwner(address nextOwner) public auth {\n        RegistryInterface(registry).record(owner, nextOwner);\n        owner = nextOwner;\n        emit LogSetOwner(nextOwner);\n    }\n\n    /**\n     * @dev checks if called by owner or contract itself\n     * @param src is the address initiating the call\n     */\n    function isAuth(address src) public view returns (bool) {\n        if (src == owner) {\n            return true;\n        } else if (src == address(this)) {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n/**\n * @dev logging the execute events\n */\ncontract UserNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 bar,\n        uint wad,\n        bytes fax\n    );\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n        emit LogNote(\n            msg.sig, \n            msg.sender, \n            foo, \n            bar, \n            msg.value,\n            msg.data\n        );\n        _;\n    }\n}\n\n\n/**\n * @title User Owned Contract Wallet\n */\ncontract UserWallet is UserAuth, UserNote {\n\n    event LogExecute(address target, uint srcNum, uint sessionNum);\n\n    /**\n     * @dev sets the \"address registry\", owner's last activity, owner's active period and initial owner\n     */\n    constructor() public {\n        registry = msg.sender;\n        owner = msg.sender;\n    }\n\n    function() external payable {}\n\n    /**\n     * @dev Execute authorised calls via delegate call\n     * @param _target logic proxy address\n     * @param _data delegate call data\n     * @param _src to find the source\n     * @param _session to find the session\n     */\n    function execute(\n        address _target,\n        bytes memory _data,\n        uint _src,\n        uint _session\n    ) \n        public\n        payable\n        note\n        auth\n        logicAuth(_target)\n        returns (bytes memory response)\n    {\n        emit LogExecute(\n            _target,\n            _src,\n            _session\n        );\n        \n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n            let size := returndatasize\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n                case 1 {\n                    // throw if delegatecall failed\n                    revert(add(response, 0x20), size)\n                }\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts/InstaRegistry.sol",
      "content": "pragma solidity ^0.5.2;\n\nimport \"./UserWallet.sol\";\n\n\n/// @title AddressRegistry\n/// @notice \n/// @dev \ncontract AddressRegistry {\n    event LogSetAddress(string name, address addr);\n\n    /// @notice Registry of role and address\n    mapping(bytes32 => address) registry;\n\n    /**\n     * @dev Check if msg.sender is admin or owner.\n     */\n    modifier isAdmin() {\n        require(\n            msg.sender == getAddress(\"admin\") || \n            msg.sender == getAddress(\"owner\"),\n            \"permission-denied\"\n        );\n        _;\n    }\n\n    /// @dev Get the address from system registry \n    /// @param _name (string)\n    /// @return  (address) Returns address based on role\n    function getAddress(string memory _name) public view returns(address) {\n        return registry[keccak256(abi.encodePacked(_name))];\n    }\n\n    /// @dev Set new address in system registry \n    /// @param _name (string) Role name\n    /// @param _userAddress (string) User Address\n    function setAddress(string memory _name, address _userAddress) public isAdmin {\n        registry[keccak256(abi.encodePacked(_name))] = _userAddress;\n        emit LogSetAddress(_name, _userAddress);\n    }\n}\n\n\n/// @title LogicRegistry\n/// @notice\n/// @dev LogicRegistry \ncontract LogicRegistry is AddressRegistry {\n\n    event LogEnableStaticLogic(address logicAddress);\n    event LogEnableLogic(address logicAddress);\n    event LogDisableLogic(address logicAddress);\n\n    /// @notice Map of static proxy state\n    mapping(address => bool) public logicProxiesStatic;\n    \n    /// @notice Map of logic proxy state\n    mapping(address => bool) public logicProxies;\n\n    /// @dev \n    /// @param _logicAddress (address)\n    /// @return  (bool)\n    function logic(address _logicAddress) public view returns (bool) {\n        if (logicProxiesStatic[_logicAddress] || logicProxies[_logicAddress]) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev \n    /// @param _logicAddress (address)\n    /// @return  (bool)\n    function logicStatic(address _logicAddress) public view returns (bool) {\n        if (logicProxiesStatic[_logicAddress]) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev Sets the static logic proxy to true\n    /// static proxies mostly contains the logic for withdrawal of assets\n    /// and can never be false to freely let user withdraw their assets\n    /// @param _logicAddress (address)\n    function enableStaticLogic(address _logicAddress) public isAdmin {\n        logicProxiesStatic[_logicAddress] = true;\n        emit LogEnableStaticLogic(_logicAddress);\n    }\n\n    /// @dev Enable logic proxy address\n    /// @param _logicAddress (address)\n    function enableLogic(address _logicAddress) public isAdmin {\n        logicProxies[_logicAddress] = true;\n        emit LogEnableLogic(_logicAddress);\n    }\n\n    /// @dev Disable logic proxy address\n    /// @param _logicAddress (address)\n    function disableLogic(address _logicAddress) public isAdmin {\n        logicProxies[_logicAddress] = false;\n        emit LogDisableLogic(_logicAddress);\n    }\n\n}\n\n\n/**\n * @dev Deploys a new proxy instance and sets msg.sender as owner of proxy\n */\ncontract WalletRegistry is LogicRegistry {\n    \n    event Created(address indexed sender, address indexed owner, address proxy);\n    event LogRecord(address indexed currentOwner, address indexed nextOwner, address proxy);\n    \n    /// @notice Address to UserWallet proxy map\n    mapping(address => UserWallet) public proxies;\n    \n    /// @dev Deploys a new proxy instance and sets custom owner of proxy\n    /// Throws if the owner already have a UserWallet\n    /// @return proxy ()\n    function build() public returns (UserWallet proxy) {\n        proxy = build(msg.sender);\n    }\n\n    /// @dev update the proxy record whenever owner changed on any proxy\n    /// Throws if msg.sender is not a proxy contract created via this contract\n    /// @return proxy () UserWallet\n    function build(address _owner) public returns (UserWallet proxy) {\n        require(proxies[_owner] == UserWallet(0), \"multiple-proxy-per-user-not-allowed\");\n        proxy = new UserWallet();\n        proxies[address(this)] = proxy; // will be changed via record() in next line execution\n        proxy.setOwner(_owner);\n        emit Created(msg.sender, _owner, address(proxy));\n    }\n\n    /// @dev Transafers ownership\n    /// @param _currentOwner (address) Current Owner\n    /// @param _nextOwner (address) Next Owner\n    function record(address _currentOwner, address _nextOwner) public {\n        require(msg.sender == address(proxies[_currentOwner]), \"invalid-proxy-or-owner\");\n        require(proxies[_nextOwner] == UserWallet(0), \"multiple-proxy-per-user-not-allowed\");\n        proxies[_nextOwner] = proxies[_currentOwner];\n        proxies[_currentOwner] = UserWallet(0);\n        emit LogRecord(_currentOwner, _nextOwner, address(proxies[_nextOwner]));\n    }\n\n}\n\n\n/// @title InstaRegistry\n/// @dev Initializing Registry\ncontract InstaRegistry is WalletRegistry {\n\n    constructor() public {\n        registry[keccak256(abi.encodePacked(\"admin\"))] = msg.sender;\n        registry[keccak256(abi.encodePacked(\"owner\"))] = msg.sender;\n    }\n}"
    },
    {
      "filename": "contracts/source/recoverable-wallet.sol",
      "content": "pragma solidity 0.6.2;\npragma experimental ABIEncoderV2;\n\n/// @notice https://eips.ethereum.org/EIPS/eip-1820\ninterface Erc1820Registry {\n\tfunction setInterfaceImplementer(address _target, bytes32 _interfaceHash, address _implementer) external;\n}\n\n/// @notice https://eips.ethereum.org/EIPS/eip-777\ncontract Erc777TokensRecipient {\n\tconstructor() public {\n\t\t// keccak256(abi.encodePacked(\"ERC777TokensRecipient\")) == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b\n\t\tErc1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n\t}\n\n\t/// @notice called when someone attempts to transfer ERC-777 tokens to this address.  If this function were to throw or doesn't exist, then the token transfer would fail.\n\tfunction tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external { }\n\n\t/// @notice Indicates whether the contract implements the interface `interfaceHash` for the address `_implementer` or not.\n\t/// @param _interfaceHash keccak256 hash of the name of the interface\n\t/// @param _implementer Address for which the contract will implement the interface\n\t/// @return ERC1820_ACCEPT_MAGIC only if the contract implements `interfaceHash` for the address `_implementer`.\n\tfunction canImplementInterfaceForAddress(bytes32 _interfaceHash, address _implementer) external view returns(bytes32) {\n\t\t// keccak256(abi.encodePacked(\"ERC777TokensRecipient\")) == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b\n\t\tif (_implementer == address(this) && _interfaceHash == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b) {\n\t\t\t// keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")) == 0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4\n\t\t\treturn 0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4;\n\t\t} else {\n\t\t\treturn bytes32(0);\n\t\t}\n\t}\n}\n\n/**\n * @dev Library for managing map of recoverer.\n *\n * Original cribbed from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1e0f07751ea0badce1f51bc23578b5b1ddb4b464/contracts/utils/EnumerableSet.sol, but heavily modified.\n */\nlibrary EnumerableMap {\n\tstruct Entry {\n\t\taddress key;\n\t\tuint16 value;\n\t}\n\n\tstruct Map {\n\t\tmapping (address => uint256) index;\n\t\tEntry[] entries;\n\t}\n\n\tfunction initialize(Map storage map) internal {\n\t\t// we initialize it with a placeholder entry in the first position because we treat the array as 1-indexed since 0 is a special index (means no entry in the index)\n\t\tmap.entries.push();\n\t}\n\n\tfunction contains(Map storage map, address key) internal view returns (bool) {\n\t\treturn map.index[key] != 0;\n\t}\n\n\tfunction set(Map storage map, address key, uint16 value) internal {\n\t\tuint256 index = map.index[key];\n\t\tif (index == 0) {\n\t\t\t// create new entry\n\t\t\tEntry memory entry = Entry({ key: key, value: value });\n\t\t\tmap.entries.push(entry);\n\t\t\tmap.index[key] = map.entries.length - 1;\n\t\t} else {\n\t\t\t// update existing entry\n\t\t\tmap.entries[index].value = value;\n\t\t}\n\n\t\trequire(map.entries[map.index[key]].key == key, \"Key at inserted location does not match inserted key.\");\n\t\trequire(map.entries[map.index[key]].value == value, \"Value at inserted location does not match inserted value.\");\n\t}\n\n\tfunction remove(Map storage map, address key) internal {\n\t\t// get the index into entries array that this entry lives at\n\t\tuint256 index = map.index[key];\n\n\t\t// if this key doesn't exist in the index, then we have nothing to do\n\t\tif (index == 0) return;\n\n\t\t// if the entry we are removing isn't the last, overwrite it with the last entry\n\t\tuint256 lastIndex = map.entries.length - 1;\n\t\tif (index != lastIndex) {\n\t\t\tEntry storage lastEntry = map.entries[lastIndex];\n\t\t\tmap.entries[index] = lastEntry;\n\t\t\tmap.index[lastEntry.key] = index;\n\t\t}\n\n\t\t// delete the last entry (if the item we are removing isn't last, it will have been overwritten with the last entry inside the conditional above)\n\t\tmap.entries.pop();\n\n\t\t// delete the index pointer\n\t\tdelete map.index[key];\n\n\t\trequire(map.index[key] == 0, \"Removed key still exists in the index.\");\n\t\trequire(index == lastIndex || map.entries[index].key != key, \"Removed key still exists in the array at original index.\");\n\t}\n\n\tfunction get(Map storage map, address key) internal view returns (uint16) {\n\t\tuint256 index = map.index[key];\n\t\trequire(index != 0, \"Provided key was not in the map.\");\n\t\treturn map.entries[index].value;\n\t}\n\n\t// this function is effectively map.entries.slice(1:), but that doesn't work with storage arrays in this version of solc so we have to do it by hand\n\tfunction enumerate(Map storage map) internal view returns (Entry[] memory) {\n\t\t// output array is one shorter because we use a 1-indexed array\n\t\tEntry[] memory output = new Entry[](map.entries.length - 1);\n\n\t\t// first element in the array is just a placeholder (0,0), so we copy from element 1 to end\n\t\tfor (uint256 i = 1; i < map.entries.length; ++i) {\n\t\t\toutput[i - 1] = map.entries[i];\n\t\t}\n\t\treturn output;\n\t}\n}\n\n/// @notice a smart wallet that is secured against loss of keys by way of backup keys that can be used to recover access with a time delay.\ncontract RecoverableWallet is Erc777TokensRecipient {\n\tusing EnumerableMap for EnumerableMap.Map;\n\n\tevent RecoveryAddressAdded(address indexed newRecoverer, uint16 recoveryDelayInDays);\n\tevent RecoveryAddressRemoved(address indexed oldRecoverer);\n\tevent RecoveryStarted(address indexed newOwner);\n\tevent RecoveryCancelled(address indexed oldRecoverer);\n\tevent RecoveryFinished(address indexed oldOwner, address indexed newOwner);\n\n\taddress public owner;\n\t/// @notice a collection of accounts that are able to recover control of this wallet, mapped to the number of days it takes for each to complete a recovery.\n\t/// @dev the recovery days are also used as a recovery priority, so a recovery address with a lower number of days has a higher recovery priority and can override a lower-priority recovery in progress.\n\tEnumerableMap.Map private recoveryDelaysInDays;\n\t/// @notice the address that is currently trying to recover access to the contract.\n\taddress public activeRecoveryAddress;\n\t/// @notice the time at which the activeRecoveryAddress can take ownership of the contract.\n\tuint256 public activeRecoveryEndTime = uint256(-1);\n\n\t/// @notice a function modifier that ensures the modified function can only be called by the owner of the contract.\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"Only the owner may call this method.\");\n\t\t_;\n\t}\n\n\t/// @notice the modified function can only be called when the wallet is undergoing recovery.\n\tmodifier onlyDuringRecovery() {\n\t\trequire(activeRecoveryAddress != address(0), \"This method can only be called during a recovery.\");\n\t\t_;\n\t}\n\n\t/// @notice the modified function can only be called when the wallet is not undergoing recovery.\n\tmodifier onlyOutsideRecovery() {\n\t\trequire(activeRecoveryAddress == address(0), \"This method cannot be called during a recovery.\");\n\t\t_;\n\t}\n\n\tconstructor(address _initialOwner) public {\n\t\trequire(_initialOwner != address(0), \"Wallet must have an initial owner.\");\n\t\towner = _initialOwner;\n\t\trecoveryDelaysInDays.initialize();\n\t}\n\n\tfunction listRecoverers() external view returns (EnumerableMap.Entry[] memory) {\n\t\treturn recoveryDelaysInDays.enumerate();\n\t}\n\n\tfunction getRecoveryDelayInDays(address recoverer) external view returns (uint16) {\n\t\treturn recoveryDelaysInDays.get(recoverer);\n\t}\n\n\t/// @notice accept ETH transfers into this contract\n\treceive () external payable { }\n\n\t/// @notice add a new recovery address to the wallet with the specified number of day delay\n\t/// @param _newRecoveryAddress the address to be added\n\t/// @param _recoveryDelayInDays the number of days delay between when `_newRecoveryAddress` can initiate a recovery and when it can complete the recovery\n\tfunction addRecoveryAddress(address _newRecoveryAddress, uint16 _recoveryDelayInDays) external onlyOwner onlyOutsideRecovery {\n\t\trequire(_newRecoveryAddress != address(0), \"Recovery address must be supplied.\");\n\t\trecoveryDelaysInDays.set(_newRecoveryAddress, _recoveryDelayInDays);\n\t\temit RecoveryAddressAdded(_newRecoveryAddress, _recoveryDelayInDays);\n\t}\n\n\t/// @notice removes a recovery address from the collection, preventing it from being able to issue recovery operations in the future\n\t/// @param _oldRecoveryAddress the address to remove from the recovery addresses collection\n\tfunction removeRecoveryAddress(address _oldRecoveryAddress) public onlyOwner onlyOutsideRecovery {\n\t\trequire(_oldRecoveryAddress != address(0), \"Recovery address must be supplied.\");\n\t\trecoveryDelaysInDays.remove(_oldRecoveryAddress);\n\t\temit RecoveryAddressRemoved(_oldRecoveryAddress);\n\t}\n\n\t/// @notice starts the recovery process.  must be called by a previously registered recovery address.  recovery will complete in a number of days dependent on the address that initiated the recovery\n\tfunction startRecovery() external {\n\t\trequire(recoveryDelaysInDays.contains(msg.sender), \"Caller is not registered as a recoverer for this wallet.\");\n\t\tuint16 _proposedRecoveryDelayInDays = recoveryDelaysInDays.get(msg.sender);\n\n\t\tbool _inRecovery = activeRecoveryAddress != address(0);\n\t\tif (_inRecovery) {\n\t\t\t// NOTE: the delay for a particular recovery address cannot be changed during recovery nor can addresses be removed during recovery, so we can rely on this being != 0\n\t\t\tuint16 _activeRecoveryDelayInDays = recoveryDelaysInDays.get(activeRecoveryAddress);\n\t\t\trequire(_proposedRecoveryDelayInDays < _activeRecoveryDelayInDays, \"Recovery is already under way and new recoverer doesn't have a higher priority.\");\n\t\t\temit RecoveryCancelled(activeRecoveryAddress);\n\t\t}\n\n\t\tactiveRecoveryAddress = msg.sender;\n\t\tactiveRecoveryEndTime = block.timestamp + _proposedRecoveryDelayInDays * 1 days;\n\t\temit RecoveryStarted(msg.sender);\n\t}\n\n\t/// @notice cancels an active recovery.  can only be called by the current contract owner.  used to cancel a recovery in case the owner key is found\n\t/// @dev cancellation is only reliable if the recovery time has not elapsed\n\tfunction cancelRecovery() public onlyOwner onlyDuringRecovery {\n\t\taddress _recoveryAddress = activeRecoveryAddress;\n\t\tresetRecovery();\n\t\temit RecoveryCancelled(_recoveryAddress);\n\t}\n\n\t/// @notice cancels an active recovery and removes the recovery address from the recoverer collection.  used when a recovery key becomes compromised and attempts to initiate a recovery\n\tfunction cancelRecoveryAndRemoveRecoveryAddress() external onlyOwner onlyDuringRecovery {\n\t\taddress _recoveryAddress = activeRecoveryAddress;\n\t\tcancelRecovery();\n\t\tremoveRecoveryAddress(_recoveryAddress);\n\t}\n\n\t/// @notice finishes the recovery process after the necessary delay has elapsed.  callable by anyone in case the keys controlling the active recovery address have been lost, since once this is called a new recovery (with a potentially lower recovery priority) can begin.\n\tfunction finishRecovery() external onlyDuringRecovery {\n\t\trequire(block.timestamp >= activeRecoveryEndTime, \"You must wait until the recovery delay is over before finishing the recovery.\");\n\n\t\taddress _oldOwner = owner;\n\t\towner = activeRecoveryAddress;\n\t\tresetRecovery();\n\t\temit RecoveryFinished(_oldOwner, owner);\n\t}\n\n\t/// @notice deploy a contract from this contract.\n\t/// @dev uses create2, so the address of the deployed contract will be deterministic\n\t/// @param _value the amount of ETH that should be supplied to the contract creation call\n\t/// @param _data the deployment bytecode to execute\n\t/// @param _salt the salt used for deterministic contract creation.  see documentation at https://eips.ethereum.org/EIPS/eip-1014 for details on how the address is computed\n\tfunction deploy(uint256 _value, bytes calldata _data, uint256 _salt) external payable onlyOwner onlyOutsideRecovery returns (address) {\n\t\trequire(address(this).balance >= _value, \"Wallet does not have enough funds available to deploy the contract.\");\n\t\trequire(_data.length != 0, \"Contract deployment must contain bytecode to deploy.\");\n\t\tbytes memory _data2 = _data;\n\t\taddress newContract;\n\t\t/* solium-disable-next-line */\n\t\tassembly { newContract := create2(_value, add(_data2, 32), mload(_data2), _salt) }\n\t\trequire(newContract != address(0), \"Contract creation returned address 0, indicating failure.\");\n\t\treturn newContract;\n\t}\n\n\t/// @notice executes an arbitrary contract call by this wallet.  allows the wallet to send ETH, transfer tokens, use dapps, etc.\n\t/// @param _to contract address to call or send to\n\t/// @param _value the amount of ETH to attach to the call\n\t/// @param _data the calldata to supply to `_to`\n\t/// @dev `_data` is of the same form used to call a contract from the JSON-RPC API, so for Solidity contract calls it is the target function hash followed by the ABI encoded parameters for that function\n\tfunction execute(address payable _to, uint256 _value, bytes calldata _data) external payable onlyOwner onlyOutsideRecovery returns (bytes memory) {\n\t\trequire(_to != address(0), \"Transaction execution must contain a destination.  If you meant to deploy a contract, use deploy instead.\");\n\t\trequire(address(this).balance >= _value, \"Wallet does not have enough"
    }
  ]
}