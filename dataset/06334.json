{
  "Title": "[H-02] The first disputer might lose funds although his dispute is valid",
  "Content": "\nUsers can dispute the current tree using `disputeTree()` and the governor refunds the dispute funds if the dispute is valid in `resolveDispute()`.\n\n```solidity\n    function disputeTree(string memory reason) external {\n        if (block.timestamp >= endOfDisputePeriod) revert InvalidDispute();\n        IERC20(disputeToken).safeTransferFrom(msg.sender, address(this), disputeAmount);\n        disputer = msg.sender;\n        emit Disputed(reason);\n    }\n\n    /// @notice Resolve the ongoing dispute, if any\n    /// @param valid Whether the dispute was valid\n    function resolveDispute(bool valid) external onlyGovernorOrGuardian {\n        if (disputer == address(0)) revert NoDispute();\n        if (valid) {\n            IERC20(disputeToken).safeTransfer(disputer, disputeAmount);\n            // If a dispute is valid, the contract falls back to the last tree that was updated\n            _revokeTree();\n        } else {\n            IERC20(disputeToken).safeTransfer(msg.sender, disputeAmount);\n            endOfDisputePeriod = _endOfDisputePeriod(uint48(block.timestamp));\n        }\n        disputer = address(0);\n        emit DisputeResolved(valid);\n    }\n```\n\nBut `disputeTree()` can be called again by another disputer although there is an active disputer and `resolveDispute()` refunds to the last disputer only.\n\nIn the worst case, a valid disputer might lose the dispute funds by malicious frontrunners.\n\n1.  A valid disputer creates a dispute using `disputeTree()`.\n2.  As it's valid, the governor calls `resolveDispute(valid = true)` to accept the dispute and refund the funds.\n3.  A malicious user calls `disputeTree()` by front running.\n4.  Then during `resolveDispute(true)`, the dispute funds will be sent to the second disputer and the first disputer will lose the funds although he's valid.\n\n\n### Recommended Mitigation Steps\n\n`disputeTree()` shouldn't allow another dispute when there is an active dispute already.\n\n**[Picodes (Angle) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-06-angle-findings/issues/23#issuecomment-1627817695):**\n > Valid scenario and issue, although this is only a griefing attack, and the governance could still send back the funds to the first dispute using [recoverERC20](https://github.com/AngleProtocol/merkl-contracts/blob/1825925daef8b22d9d6c0a2bc7aab3309342e786/contracts/Distributor.sol#L279).\n> \n> Considering the scenario is very unlikely as it would cost gas to the attacker for nothing, and easily fixable, I think this should be downgraded to Med\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/23#issuecomment-1628643525):**\n > @Picodes - Will keep as High because honest disputers may lose their funds and it requires the governance's additional work to recover.\n\n**[Picodes (Angle) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/23#issuecomment-1629243692):**\n > @hansfriese - indeed but when there is a dispute it requires additional work from the governance anyway. Like the permissions for `resolveDispute` and `recoverERC20`, and `recoverERC20` is even cheaper. So the trust assumptions of the disputer are exactly the same with and without this issue: he trusts the governance to send him back its deposit at some point.\n> \n> This whole `disputeAmount` / `period` thing is meant to prevent spam and to force disputers to behave correctly as they will lose some funds if they don't, so someone using this attack vector also exposes himself to the governance deciding to not accept the dispute and seize the funds. Overall we will of course respect your final decision but still think med is more appropriate here\n\n**[hansfriese (Judge) commented](https://github.com/code-423n4/2023-06-angle-findings/issues/23#issuecomment-1629345550):**\n > @Picodes - I totally understand your point and I'd like to mention two things.\n> - The governance should refund one by one outside of the contract.\n> - While checking `disputeTree()`, I see it doesn't emit the disputer's address and `disputeAmount` which would be changed later. So it wouldn't be that easy to refund in practice.\n> \n> I agree it's between High and Medium and will keep as High.\n\n**[Angle mitigated](https://github.com/code-423n4/2023-07-angle-mitigation/blob/main/README.md#mitigations-to-be-reviewed):**\n> PR: https://github.com/AngleProtocol/merkl-contracts/commit/7402ee6b84789391479c5876b27be23fd579f7b2<br>\n> Applies the suggested fix.\n\n**Status:** Mitigation confirmed. Full details in reports from [Lambda](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/7), [auditor0517](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/23), and [Jeiwan](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/14).\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/Distributor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./utils/UUPSHelper.sol\";\n\nstruct MerkleTree {\n    // Root of a Merkle tree which leaves are `(address user, address token, uint amount)`\n    // representing an amount of tokens accumulated by `user`.\n    // The Merkle tree is assumed to have only increasing amounts: that is to say if a user can claim 1,\n    // then after the amount associated in the Merkle tree for this token should be x > 1\n    bytes32 merkleRoot;\n    // Ipfs hash of the tree data\n    bytes32 ipfsHash;\n}\n\nstruct Claim {\n    uint208 amount;\n    uint48 timestamp;\n}\n\n/// @title Distributor\n/// @notice Allows LPs on AMMs with concentrated liquidity to claim the rewards that were distributed to them\n/// @author Angle Labs. Inc\ncontract Distributor is UUPSHelper {\n    using SafeERC20 for IERC20;\n\n    /// @notice Epoch duration\n    uint32 internal constant _EPOCH_DURATION = 3600;\n\n    // ================================= VARIABLES =================================\n\n    /// @notice Tree of claimable tokens through this contract\n    MerkleTree public tree;\n\n    /// @notice Tree that was in place in the contract before the last `tree` update\n    MerkleTree public lastTree;\n\n    /// @notice Token to deposit to freeze the roots update\n    IERC20 public disputeToken;\n\n    /// @notice `Core` contract handling access control\n    ICore public core;\n\n    /// @notice Address which created the dispute\n    /// @dev Used to store if there is an ongoing dispute\n    address public disputer;\n\n    /// @notice When the current tree will become valid\n    uint48 public endOfDisputePeriod;\n\n    /// @notice Time before which a change in a tree becomes effective, in EPOCH_DURATION\n    uint48 public disputePeriod;\n\n    /// @notice Amount to deposit to freeze the roots update\n    uint256 public disputeAmount;\n\n    /// @notice Mapping user -> token -> amount to track claimed amounts\n    mapping(address => mapping(address => Claim)) public claimed;\n\n    /// @notice Trusted EOAs to update the Merkle root\n    mapping(address => uint256) public canUpdateMerkleRoot;\n\n    /// @notice Whether or not to disable permissionless claiming\n    mapping(address => uint256) public onlyOperatorCanClaim;\n\n    /// @notice user -> operator -> authorisation to claim\n    mapping(address => mapping(address => uint256)) public operators;\n\n    uint256[38] private __gap;\n\n    // =================================== EVENTS ==================================\n\n    event Claimed(address user, address token, uint256 amount);\n    event DisputeAmountUpdated(uint256 _disputeAmount);\n    event Disputed(string reason);\n    event DisputePeriodUpdated(uint48 _disputePeriod);\n    event DisputeResolved(bool valid);\n    event DisputeTokenUpdated(address indexed _disputeToken);\n    event OperatorClaimingToggled(address user, bool isEnabled);\n    event OperatorToggled(address user, address operator, bool isWhitelisted);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event Revoked(); // With this event an indexer could maintain a table (timestamp, merkleRootUpdate)\n    event TreeUpdated(bytes32 merkleRoot, bytes32 ipfsHash, uint48 endOfDisputePeriod);\n    event TrustedToggled(address indexed eoa, bool trust);\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` is the `user` address or is a trusted address\n    modifier onlyTrustedOrUser(address user) {\n        if (user != msg.sender && canUpdateMerkleRoot[msg.sender] != 1 && !core.isGovernorOrGuardian(msg.sender))\n            revert NotTrusted();\n        _;\n    }\n\n    // ================================ CONSTRUCTOR ================================\n\n    constructor() initializer {}\n\n    function initialize(ICore _core) external initializer {\n        if (address(_core) == address(0)) revert ZeroAddress();\n        core = _core;\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal view override onlyGuardianUpgrader(core) {}\n\n    // =============================== MAIN FUNCTION ===============================\n\n    /// @notice Claims rewards for a given set of users\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// who provides the proof and pays the gas: `msg.sender` is used only for addresses that require a trusted operator\n    /// @param users Recipient of tokens\n    /// @param tokens ERC20 claimed\n    /// @param amounts Amount of tokens that will be sent to the corresponding users\n    /// @param proofs Array of hashes bridging from a leaf `(hash of user | token | amount)` to the Merkle root\n    function claim(\n        address[] calldata users,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata proofs\n    ) external {\n        uint256 usersLength = users.length;\n        if (\n            usersLength == 0 ||\n            usersLength != tokens.length ||\n            usersLength != amounts.length ||\n            usersLength != proofs.length\n        ) revert InvalidLengths();\n\n        for (uint256 i; i < usersLength; ) {\n            address user = users[i];\n            address token = tokens[i];\n            uint256 amount = amounts[i];\n\n            // Checking if only an approved operator can claim for `user`\n            if (onlyOperatorCanClaim[user] == 1 && operators[user][msg.sender] == 0) revert NotWhitelisted();\n\n            // Verifying proof\n            bytes32 leaf = keccak256(abi.encode(user, token, amount));\n            if (!_verifyProof(leaf, proofs[i])) revert InvalidProof();\n\n            // Closing reentrancy gate here\n            uint256 toSend = amount - claimed[user][token].amount;\n            claimed[user][token] = Claim(SafeCast.toUint208(amount), uint48(block.timestamp));\n\n            IERC20(token).safeTransfer(user, toSend);\n            emit Claimed(user, token, toSend);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the MerkleRoot that is currently live for the contract\n    function getMerkleRoot() public view returns (bytes32) {\n        if (block.timestamp >= endOfDisputePeriod) return tree.merkleRoot;\n        else return lastTree.merkleRoot;\n    }\n\n    // ============================ GOVERNANCE FUNCTIONS ===========================\n\n    /// @notice Adds or removes EOAs which are trusted to update the Merkle root\n    function toggleTrusted(address eoa) external onlyGovernorOrGuardian {\n        uint256 trustedStatus = 1 - canUpdateMerkleRoot[eoa];\n        canUpdateMerkleRoot[eoa] = trustedStatus;\n        emit TrustedToggled(eoa, trustedStatus == 1);\n    }\n\n    /// @notice Updates Merkle Tree\n    function updateTree(MerkleTree calldata _tree) external {\n        if (\n            disputer != address(0) ||\n            // A trusted address cannot update a tree right after a precedent tree update otherwise it can de facto\n            // validate a tree which has not passed the dispute period\n            ((canUpdateMerkleRoot[msg.sender] != 1 || block.timestamp < endOfDisputePeriod) &&\n                !core.isGovernorOrGuardian(msg.sender))\n        ) revert NotTrusted();\n        MerkleTree memory _lastTree = tree;\n        tree = _tree;\n        lastTree = _lastTree;\n\n        uint48 _endOfPeriod = _endOfDisputePeriod(uint48(block.timestamp));\n        endOfDisputePeriod = _endOfPeriod;\n        emit TreeUpdated(_tree.merkleRoot, _tree.ipfsHash, _endOfPeriod);\n    }\n\n    /// @notice Freezes the Merkle tree update until the dispute is resolved\n    /// @dev Requires a deposit of `disputeToken` that'll be slashed if the dispute is not accepted\n    /// @dev It is only possible to create a dispute for `disputePeriod` after each tree update\n    function disputeTree(string memory reason) external {\n        if (block.timestamp >= endOfDisputePeriod) revert InvalidDispute();\n        IERC20(disputeToken).safeTransferFrom(msg.sender, address(this), disputeAmount);\n        disputer = msg.sender;\n        emit Disputed(reason);\n    }\n\n    /// @notice Resolve the ongoing dispute, if any\n    /// @param valid Whether the dispute was valid\n    function resolveDispute(bool valid) external onlyGovernorOrGuardian {\n        if (disputer == address(0)) revert NoDispute();\n        if (valid) {\n            IERC20(disputeToken).safeTransfer(disputer, disputeAmount);\n            // If a dispute is valid, the contract falls back to the last tree that was updated\n            _revokeTree();\n        } else {\n            IERC20(disputeToken).safeTransfer(msg.sender, disputeAmount);\n            endOfDisputePeriod = _endOfDisputePeriod(uint48(block.timestamp));\n        }\n        disputer = address(0);\n        emit DisputeResolved(valid);\n    }\n\n    /// @notice Allows the governor or the guardian of this contract to fallback to the last version of the tree\n    /// immediately\n    function revokeTree() external onlyGovernorOrGuardian {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        _revokeTree();\n    }\n\n    /// @notice Toggles permissioned claiming for a given user\n    function toggleOnlyOperatorCanClaim(address user) external onlyTrustedOrUser(user) {\n        uint256 oldValue = onlyOperatorCanClaim[user];\n        onlyOperatorCanClaim[user] = 1 - oldValue;\n        emit OperatorClaimingToggled(user, oldValue == 0);\n    }\n\n    /// @notice Toggles whitelisting for a given user and a given operator\n    function toggleOperator(address user, address operator) external onlyTrustedOrUser(user) {\n        uint256 oldValue = operators[user][operator];\n        operators[user][operator] = 1 - oldValue;\n        emit OperatorToggled(user, operator, oldValue == 0);\n    }\n\n    /// @notice Recovers any ERC20 token\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernorOrGuardian {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Sets the dispute period before which a tree update becomes effective\n    function setDisputePeriod(uint48 _disputePeriod) external onlyGovernorOrGuardian {\n        disputePeriod = uint48(_disputePeriod);\n        emit DisputePeriodUpdated(_disputePeriod);\n    }\n\n    /// @notice Sets the token used as a caution during disputes\n    function setDisputeToken(IERC20 _disputeToken) external onlyGovernorOrGuardian {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        disputeToken = _disputeToken;\n        emit DisputeTokenUpdated(address(_disputeToken));\n    }\n\n    /// @notice Sets the amount of `disputeToken` used as a caution during disputes\n    function setDisputeAmount(uint256 _disputeAmount) external onlyGovernorOrGuardian {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        disputeAmount = _disputeAmount;\n        emit DisputeAmountUpdated(_disputeAmount);\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice Fallback to the last version of the tree\n    function _revokeTree() internal {\n        MerkleTree memory _tree = lastTree;\n        endOfDisputePeriod = 0;\n        tree = _tree;\n        emit Revoked();\n        emit TreeUpdated(\n            _tree.merkleRoot,\n            _tree.ipfsHash,\n            (uint48(block.timestamp) / _EPOCH_DURATION) * (_EPOCH_DURATION) // Last hour\n        );\n    }\n\n    /// @notice Returns the end of the dispute period\n    /// @dev treeUpdate is rounded up to next hour and then `disputePeriod` hours are added\n    function _endOfDisputePeriod(uint48 treeUpdate) internal view returns (uint48) {\n        return ((treeUpdate - 1) / _EPOCH_DURATION + 1 + disputePeriod) * (_EPOCH_DURATION);\n    }\n\n    /// @notice Checks the validity of a proof\n    /// @param leaf Hashed leaf data, the starting point of the proof\n    /// @param proof Array of hashes forming a hash chain from leaf to root\n    /// @return true If proof is correct, else false\n    function _verifyProof(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) {\n        bytes32 currentHash = leaf;\n        uint256 proofLength = proof.length;\n        for (uint256 i; i < proofLength; ) {\n            if (currentHash < proof[i]) {\n                currentHash = keccak256(abi.encode(currentHash, proof[i]));\n            } else {\n                currentHash = keccak256(abi.encode(proof[i], currentHash));\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        bytes32 root = getMerkleRoot();\n        if (root == bytes32(0)) revert InvalidUninitializedRoot();\n        return currentHash == root;\n    }\n}"
    },
    {
      "filename": "README.md",
      "content": "# Angle Protocol - Mitigation Review details\n\n- Total Prize Pool: $14,000 USDC\n- [Warden guidelines for C4 mitigation reviews](https://code4rena.notion.site/Guidelines-for-C4-mitigation-reviews-ed10fc5cfbf640bd8dcec66f38b343c4)\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-07-angle-protocol-mitigation-review/submit)\n- Starts July 17, 2023 20:00 UTC\n- Ends July 21, 2023 20:00 UTC \n\n## Important note\n\nEach warden must submit a mitigation review for:\n\n- Every High and Medium finding listed as in-scope below, and\n- one report each for the Gas and QA fixes.\n\nFor the Gas and QA mitigation reports:\n- Submit any new High or Medium issues introduced by the QA and GAS fixes as a newly-introduced High and Medium risk issue.\n\n**Incomplete mitigation reviews will not be eligible for awards.**\n\n## Findings being mitigated\n\nMitigations of all High and Medium issues will be considered in-scope and listed here.\n\n- [H-01: Possible reentrancy during redemption/swap](https://github.com/code-423n4/2023-06-angle-findings/issues/24)\n- [H-02: The first disputer might lose funds although his dispute is valid.](https://github.com/code-423n4/2023-06-angle-findings/issues/23)\n- [H-03: Poor detection of disputed trees allows claiming tokens from a disputed tre](https://github.com/code-423n4/2023-06-angle-findings/issues/10)\n- [M-01: LibHelpers.piecewiseLinear will revert when the value is less than the first element of the array](https://github.com/code-423n4/2023-06-angle-findings/issues/40)\n- [M-02: Unsafe cast in getCollateralRatio()](https://github.com/code-423n4/2023-06-angle-findings/issues/31)\n- [M-03: Read-only reentrancy is possible](https://github.com/code-423n4/2023-06-angle-findings/issues/30)\n- [M-04: estimatedAPR() might return the wrong APR.](https://github.com/code-423n4/2023-06-angle-findings/issues/28)\n- [M-06: Interest is not accrued before parameters are updated in SavingsVest](https://github.com/code-423n4/2023-06-angle-findings/issues/13)\n- [M-07: User may get less tokens than expected when collateral list order changes](https://github.com/code-423n4/2023-06-angle-findings/issues/8)\n\n## Overview of changes\n\nChanges related to High and Medium issues on Merkl can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Merkl prior to final deployment, so including QA and GAS can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\nChanges related to High and Medium issues on Transmuter can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Transmuter prior to final deployment, so including QA and GAS can be found can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\n## Mitigations to be reviewed\n\n### Individual PRs\n\n| URL                                                                                               | Mitigation of | Purpose                                             |\n| ------------------------------------------------------------------------------------------------- | ------------- | --------------------------------------------------- |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | H-01          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/merkl-contracts/commit/7402ee6b84789391479c5876b27be23fd579f7b2  | H-02          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/82d8c0ff37b4a9ad8277cac4aef85f3ca0ad5c7c  | H-03          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/5f7635cdab52b75416309d45f8cd253609c705ff | M-01          | Add an handler for this edge case                   |\n| https://github.com/AngleProtocol/angle-transmuter/commit/6f2ffcb1e89e3bba05c9aa2133ef94347aa42c28 | M-02          | Adds safeCast                                       |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | M-03          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/angle-transmuter/commit/337c65d005bbd8ed6dfa76929d2cae475066756a | M-04          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/94c4e51ae3400a63532e85f04f4081152adc97db | M-06          | Calls `accrues` before updating sensible parameters |\n| https://github.com/AngleProtocol/angle-transmuter/commit/f8d0bf7c4009586f7022d5929359041db3990175 | M-07          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/3c2fe3a956cdd29b632e8d7a20e1fc2ce5e8ac37  | QA & GAS      |                                                     |\n| https://github.com/AngleProtocol/angle-transmuter/commit/66bba3f5dba4ab6307c997e350dfadb13d2a2119 | QA & GAS      |                                                     |\n\n## Out of Scope\n\n- [M-05: uint128 changeAmount might overflow](https://github.com/code-423n4/2023-06-angle-findings/issues/16): we consider that there is no risk here as swaps will be reverting, and that the chances that this happen are infinitesimals"
    }
  ]
}