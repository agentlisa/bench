{
  "Title": "M-2: Lyra vault underestimates the collateral value",
  "Content": "# Issue M-2: Lyra vault underestimates the collateral value \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/242 \n\n## Found by \nhansfriese\n\n## Summary\n\nLyra vault subtracts the withdrawal fee while calculating the collateral value in USD, and it does not match the actual Lyra Pool implementation.\n\n## Vulnerability Detail\n\nThe user's collateral value is estimated using the function `priceCollateralToUSD()` at `Vault_Lyra.sol#L77` as follows.\n\n```solidity\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n        //The LiquidityPool associated with the LP Token is used for pricing\n    ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n    //we have already checked for stale greeks so here we call the basic price function.\n    uint256 tokenPrice = LiquidityPool.getTokenPrice();\n    uint256 withdrawalFee = _getWithdrawalFee(LiquidityPool);\n    uint256 USDValue  = (_amount * tokenPrice) / LOAN_SCALE;\n    //we remove the Liquidity Pool withdrawalFee\n    //as there's no way to remove the LP position without paying this.\n    uint256 USDValueAfterFee = USDValue * (LOAN_SCALE- withdrawalFee)/LOAN_SCALE;\n    return(USDValueAfterFee);\n}\n```\n\nSo it is understood that the withdrawal fee is removed to get the reasonable value of the collateral.\nBut according to the [Lyra Pool implementation](https://github.com/lyra-finance/lyra-protocol/blob/master/contracts/LiquidityPool.sol#L341), the token price used for withdrawal is calculated using the function `_getTotalBurnableTokens`.\nAnd the function `_getTotalBurnableTokens` is as belows.\n\n```solidity\nfunction _getTotalBurnableTokens()\n    internal\n    returns (\n      uint tokensBurnable,\n      uint tokenPriceWithFee,\n      bool stale\n    )\n  {\n    uint burnableLiquidity;\n    uint tokenPrice;\n    (tokenPrice, stale, burnableLiquidity) = _getTokenPriceAndStale();\n\n    if (optionMarket.getNumLiveBoards() != 0) {\n      tokenPriceWithFee = tokenPrice.multiplyDecimal(DecimalMath.UNIT - lpParams.withdrawalFee);\n    } else {\n      tokenPriceWithFee = tokenPrice;//@audit withdrawalFee is not applied if there are no live borads\n    }\n\n    return (burnableLiquidity.divideDecimal(tokenPriceWithFee), tokenPriceWithFee, stale);\n  }\n```\n\nFrom the code, it is clear that the withdrawal fee is subtracted only when the related option market has live boards.\nBecause `Vault_Lyra.sol` applies a withdrawal fee all the time to price the collateral, it means the user's collateral is under-valued.\n\n## Impact\n\nUser's collaterals are under-valued than reasonable and might get to a liquidatable status sooner than expected. A liquidator can abuse this to get an unfair profit by liquidating the user's collateral with the under-estimated value and withdrawing it from the Lyra pool without paying a withdrawal fee.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Isomorph/contracts/Vault_Lyra.sol#L77\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMake sure to apply withdrawal fee consistent to how Lyra pool does.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix\n\n**kree-dotcom**\n\nCurrently this fix looks like it will be quite a lot of alterations. If there is time and it doesn't introduce too many changes for Sherlock to check we will try to fix it. \n\nThe reason is the call added must be made to the optionMarket contract of each collateral, this address is stored as an internal address in liquidityPool and other contracts, therefore to access it we must add another field to Lyra collateral in the collateral book, this would involve altering all collateralBook functions to expect another field as well as other vaults and systems to adhere to this larger model. \n\nAlternatively we can add another mapping to the Vault_Lyra to store the OptionsMarkets and an admin only function to add new ones but this feels like poor design.\n\nLeaving this issue unfixed is unlikely to cause large problems. LiquidityTokens should only have zero live boards if an optionMarket is closed (usually to be depreciated) with zero live boards the collateral should be earning no interest for the owner and therefore they would likely desire to close their loan and redeem their collateral and so not be in a situation to be liquidated.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/LiquidityPool.sol",
      "content": "//SPDX-License-Identifier: ISC\n\npragma solidity 0.8.16;\n\n// Libraries\nimport \"./synthetix/DecimalMath.sol\";\nimport \"./libraries/ConvertDecimals.sol\";\nimport \"openzeppelin-contracts-4.4.1/utils/math/SafeCast.sol\";\n\n// Inherited\nimport \"./synthetix/Owned.sol\";\nimport \"./libraries/SimpleInitializable.sol\";\nimport \"openzeppelin-contracts-4.4.1/security/ReentrancyGuard.sol\";\n\n// Interfaces\nimport \"./interfaces/IERC20Decimals.sol\";\nimport \"./LiquidityToken.sol\";\nimport \"./OptionGreekCache.sol\";\nimport \"./OptionMarket.sol\";\nimport \"./ShortCollateral.sol\";\nimport \"./libraries/PoolHedger.sol\";\nimport \"./BaseExchangeAdapter.sol\";\n\n/**\n * @title LiquidityPool\n * @author Lyra\n * @dev Holds funds from LPs, which are used for the following purposes:\n * 1. Collateralizing options sold by the OptionMarket.\n * 2. Buying options from users.\n * 3. Delta hedging the LPs.\n * 4. Storing funds for expired in the money options.\n */\ncontract LiquidityPool is Owned, SimpleInitializable, ReentrancyGuard {\n  using DecimalMath for uint;\n\n  struct Collateral {\n    // This is the total amount of puts * strike\n    uint quote;\n    // This is the total amount of calls\n    uint base;\n  }\n\n  /// These values are all in quoteAsset amounts.\n  struct Liquidity {\n    // Amount of liquidity available for option collateral and premiums\n    uint freeLiquidity;\n    // Amount of liquidity available for withdrawals - different to freeLiquidity\n    uint burnableLiquidity;\n    // Amount of liquidity reserved for long options sold to traders\n    uint reservedCollatLiquidity;\n    // Portion of liquidity reserved for delta hedging (quote outstanding)\n    uint pendingDeltaLiquidity;\n    // Current value of delta hedge\n    uint usedDeltaLiquidity;\n    // Net asset value, including everything and netOptionValue\n    uint NAV;\n    // longs scaled down by this factor in a contract adjustment event\n    uint longScaleFactor;\n  }\n\n  struct QueuedDeposit {\n    uint id;\n    // Who will receive the LiquidityToken minted for this deposit after the wait time\n    address beneficiary;\n    // The amount of quoteAsset deposited to be converted to LiquidityToken after wait time\n    uint amountLiquidity;\n    // The amount of LiquidityToken minted. Will equal to 0 if not processed\n    uint mintedTokens;\n    uint depositInitiatedTime;\n  }\n\n  struct QueuedWithdrawal {\n    uint id;\n    // Who will receive the quoteAsset returned after burning the LiquidityToken\n    address beneficiary;\n    // The amount of LiquidityToken being burnt after the wait time\n    uint amountTokens;\n    // The amount of quote transferred. Will equal to 0 if process not started\n    uint quoteSent;\n    uint withdrawInitiatedTime;\n  }\n\n  struct LiquidityPoolParameters {\n    // The minimum amount of quoteAsset for a deposit, or the amount of LiquidityToken for a withdrawal\n    uint minDepositWithdraw;\n    // Time between initiating a deposit and when it can be processed\n    uint depositDelay;\n    // Time between initiating a withdrawal and when it can be processed\n    uint withdrawalDelay;\n    // Fee charged on withdrawn funds\n    uint withdrawalFee;\n    // The address of the \"guardian\"\n    address guardianMultisig;\n    // Length of time a deposit/withdrawal since initiation for before a guardian can force process their transaction\n    uint guardianDelay;\n    // Percentage of liquidity that can be used in a contract adjustment event\n    uint adjustmentNetScalingFactor;\n    // Scale amount of long call collateral held by the LP\n    uint callCollatScalingFactor;\n    // Scale amount of long put collateral held by the LP\n    uint putCollatScalingFactor;\n  }\n\n  struct CircuitBreakerParameters {\n    // Percentage of NAV below which the liquidity CB fires\n    uint liquidityCBThreshold;\n    // Length of time after the liq. CB stops firing during which deposits/withdrawals are still blocked\n    uint liquidityCBTimeout;\n    // Difference between the spot and GWAV baseline IVs after which point the vol CB will fire\n    uint ivVarianceCBThreshold;\n    // Difference between the spot and GWAV skew ratios after which point the vol CB will fire\n    uint skewVarianceCBThreshold;\n    // Length of time after the (base) vol. CB stops firing during which deposits/withdrawals are still blocked\n    uint ivVarianceCBTimeout;\n    // Length of time after the (skew) vol. CB stops firing during which deposits/withdrawals are still blocked\n    uint skewVarianceCBTimeout;\n    // When a new board is listed, block deposits/withdrawals\n    uint boardSettlementCBTimeout;\n    // Timeout on deposits and withdrawals in a contract adjustment event\n    uint contractAdjustmentCBTimeout;\n  }\n\n  BaseExchangeAdapter internal exchangeAdapter;\n  OptionMarket internal optionMarket;\n  LiquidityToken internal liquidityToken;\n  ShortCollateral internal shortCollateral;\n  OptionGreekCache internal greekCache;\n  PoolHedger public poolHedger;\n  IERC20Decimals public quoteAsset;\n  IERC20Decimals internal baseAsset;\n\n  mapping(uint => QueuedDeposit) public queuedDeposits;\n  /// @dev The total amount of quoteAsset pending deposit (that hasn't entered the pool)\n  uint public totalQueuedDeposits = 0;\n\n  /// @dev The next queue item that needs to be processed\n  uint public queuedDepositHead = 1;\n  uint public nextQueuedDepositId = 1;\n\n  mapping(uint => QueuedWithdrawal) public queuedWithdrawals;\n  uint public totalQueuedWithdrawals = 0;\n\n  /// @dev The next queue item that needs to be processed\n  uint public queuedWithdrawalHead = 1;\n  uint public nextQueuedWithdrawalId = 1;\n\n  /// @dev Parameters relating to depositing and withdrawing from the Lyra LP\n  LiquidityPoolParameters public lpParams;\n  /// @dev Parameters relating to circuit breakers\n  CircuitBreakerParameters public cbParams;\n\n  // timestamp for when deposits/withdrawals will be available to deposit/withdraw\n  // This checks if liquidity is all used - adds 3 days to block.timestamp if it is\n  // This also checks if vol variance is high - adds 12 hrs to block.timestamp if it is\n  uint public CBTimestamp = 0;\n\n  ////\n  // Other Variables\n  ////\n  /// @dev Amount of collateral locked for outstanding calls and puts sold to users\n  Collateral public lockedCollateral;\n  /// @dev Total amount of quoteAsset reserved for all settled options that have yet to be paid out\n  uint public totalOutstandingSettlements;\n  /// @dev Total value not transferred to this contract for all shorts that didn't have enough collateral after expiry\n  uint public insolventSettlementAmount;\n  /// @dev Total value not transferred to this contract for all liquidations that didn't have enough collateral when liquidated\n  uint public liquidationInsolventAmount;\n\n  /// @dev Quote amount that's protected for LPs in case of AMM insolvencies\n  uint public protectedQuote;\n\n  ///////////\n  // Setup //\n  ///////////\n\n  constructor() Owned() {}\n\n  /// @dev Initialise important addresses for the contract\n  function init(\n    BaseExchangeAdapter _exchangeAdapter,\n    OptionMarket _optionMarket,\n    LiquidityToken _liquidityToken,\n    OptionGreekCache _greekCache,\n    PoolHedger _poolHedger,\n    ShortCollateral _shortCollateral,\n    IERC20Decimals _quoteAsset,\n    IERC20Decimals _baseAsset\n  ) external onlyOwner initializer {\n    exchangeAdapter = _exchangeAdapter;\n    optionMarket = _optionMarket;\n    liquidityToken = _liquidityToken;\n    greekCache = _greekCache;\n    shortCollateral = _shortCollateral;\n    poolHedger = _poolHedger;\n    quoteAsset = _quoteAsset;\n    baseAsset = _baseAsset;\n  }\n\n  ///////////\n  // Admin //\n  ///////////\n\n  /// @notice set `LiquidityPoolParameteres`\n  function setLiquidityPoolParameters(LiquidityPoolParameters memory _lpParams) external onlyOwner {\n    if (\n      !(_lpParams.depositDelay < 365 days &&\n        _lpParams.withdrawalDelay < 365 days &&\n        _lpParams.withdrawalFee < 2e17 &&\n        _lpParams.guardianDelay < 365 days)\n    ) {\n      revert InvalidLiquidityPoolParameters(address(this), _lpParams);\n    }\n\n    lpParams = _lpParams;\n\n    emit LiquidityPoolParametersUpdated(lpParams);\n  }\n\n  /// @notice set `LiquidityPoolParameteres`\n  function setCircuitBreakerParameters(CircuitBreakerParameters memory _cbParams) external onlyOwner {\n    if (\n      !(_cbParams.liquidityCBThreshold < DecimalMath.UNIT &&\n        _cbParams.liquidityCBTimeout < 60 days &&\n        _cbParams.ivVarianceCBTimeout < 60 days &&\n        _cbParams.skewVarianceCBTimeout < 60 days &&\n        _cbParams.boardSettlementCBTimeout < 10 days)\n    ) {\n      revert InvalidCircuitBreakerParameters(address(this), _cbParams);\n    }\n\n    cbParams = _cbParams;\n\n    emit CircuitBreakerParametersUpdated(cbParams);\n  }\n\n  /// @dev Swap out current PoolHedger with a new contract\n  function setPoolHedger(PoolHedger newPoolHedger) external onlyOwner {\n    poolHedger = newPoolHedger;\n    emit PoolHedgerUpdated(poolHedger);\n  }\n\n  /// @notice Allow incorrectly sent funds to be recovered\n  function recoverFunds(IERC20Decimals token, address recipient) external onlyOwner {\n    if (token == quoteAsset || token == baseAsset) {\n      revert CannotRecoverQuoteBase(address(this));\n    }\n    token.transfer(recipient, token.balanceOf(address(this)));\n  }\n\n  //////////////////////////////\n  // Deposits and Withdrawals //\n  //////////////////////////////\n\n  /**\n   * @notice LP will send sUSD into the contract in return for LiquidityToken (representative of their share of the entire pool)\n   *         to be given either instantly (if no live boards) or after the delay period passes (including CBs).\n   *         This action is not reversible.\n   *\n   * @param beneficiary will receive the LiquidityToken after the deposit is processed\n   * @param amountQuote is the amount of sUSD the LP is depositing\n   */\n  function initiateDeposit(address beneficiary, uint amountQuote) external nonReentrant {\n    uint realQuote = amountQuote;\n\n    // Convert to 18 dp for LP token minting\n    amountQuote = ConvertDecimals.convertTo18(amountQuote, quoteAsset.decimals());\n\n    if (beneficiary == address(0)) {\n      revert InvalidBeneficiaryAddress(address(this), beneficiary);\n    }\n    if (amountQuote < lpParams.minDepositWithdraw) {\n      revert MinimumDepositNotMet(address(this), amountQuote, lpParams.minDepositWithdraw);\n    }\n    // getLiquidity will also make deposits pause when the market/global system is paused\n    Liquidity memory liquidity = getLiquidity();\n    if (optionMarket.getNumLiveBoards() == 0) {\n      uint tokenPrice = _getTokenPrice(liquidity.NAV, getTotalTokenSupply());\n\n      uint amountTokens = amountQuote.divideDecimal(tokenPrice);\n      liquidityToken.mint(beneficiary, amountTokens);\n\n      // guaranteed to have long scaling factor of 1 when liv boards == 0\n      protectedQuote = (liquidity.NAV + amountQuote).multiplyDecimal(\n        DecimalMath.UNIT - lpParams.adjustmentNetScalingFactor\n      );\n\n      emit DepositProcessed(msg.sender, beneficiary, 0, amountQuote, tokenPrice, amountTokens, block.timestamp);\n    } else {\n      QueuedDeposit storage newDeposit = queuedDeposits[nextQueuedDepositId];\n\n      newDeposit.id = nextQueuedDepositId++;\n      newDeposit.beneficiary = beneficiary;\n      newDeposit.amountLiquidity = amountQuote;\n      newDeposit.depositInitiatedTime = block.timestamp;\n\n      totalQueuedDeposits += amountQuote;\n\n      emit DepositQueued(msg.sender, beneficiary, newDeposit.id, amountQuote, totalQueuedDeposits, block.timestamp);\n    }\n\n    if (!quoteAsset.transferFrom(msg.sender, address(this), realQuote)) {\n      revert QuoteTransferFailed(address(this), msg.sender, address(this), realQuote);\n    }\n  }\n\n  /**\n   * @notice LP instantly burns LiquidityToken, signalling they wish to withdraw\n   *         their share of the pool in exchange for quote, to be processed instantly (if no live boards)\n   *         or after the delay period passes (including CBs).\n   *         This action is not reversible.\n   *\n   *\n   * @param beneficiary will receive\n   * @param amountLiquidityToken: is the amount of LiquidityToken the LP is withdrawing\n   */\n  function initiateWithdraw(address beneficiary, uint amountLiquidityToken) external nonReentrant {\n    if (beneficiary == address(0)) {\n      revert InvalidBeneficiaryAddress(address(this), beneficiary);\n    }\n\n    Liquidity memory liquidity = getLiquidity();\n    uint tokenPrice = _getTokenPrice(liquidity.NAV, getTotalTokenSupply());\n    uint withdrawalValue = amountLiquidityToken.multiplyDecimal(tokenPrice);\n\n    if (withdrawalValue < lpParams.minDepositWithdraw && amountLiquidityToken < lpParams.minDepositWithdraw) {\n      revert MinimumWithdrawNotMet(address(this), withdrawalValue, lpParams.minDepositWithdraw);\n    }\n\n    if (optionMarket.getNumLiveBoards() == 0 && liquidity.longScaleFactor == DecimalMath.UNIT) {\n      _transferQuote(beneficiary, withdrawalValue);\n\n      protectedQuote = (liquidity.NAV - withdrawalValue).multiplyDecimal(\n        DecimalMath.UNIT - lpParams.adjustmentNetScalingFactor\n      );\n\n      // quoteReceived in the event is in 18dp\n      emit WithdrawProcessed(\n        msg.sender,\n        beneficiary,\n        0,\n        amountLiquidityToken,\n        tokenPrice,\n        withdrawalValue,\n        totalQueuedWithdrawals,\n        block.timestamp\n      );\n    } else {\n      QueuedWithdrawal storage newWithdrawal = queuedWithdrawals[nextQueuedWithdrawalId];\n\n      newWithdrawal.id = nextQueuedWithdrawalId++;\n      newWithdrawal.beneficiary = beneficiary;\n      newWithdrawal.amountTokens = amountLiquidityToken;\n      newWithdrawal.withdrawInitiatedTime = block.timestamp;\n\n      totalQueuedWithdrawals += amountLiquidityToken;\n\n      emit WithdrawQueued(\n        msg.sender,\n        beneficiary,\n        newWithdrawal.id,\n        amountLiquidityToken,\n        totalQueuedWithdrawals,\n        block.timestamp\n      );\n    }\n    liquidityToken.burn(msg.sender, amountLiquidityToken);\n  }\n\n  /// @param limit number of deposit tickets to process in a single transaction to avoid gas limit soft-locks\n  function processDepositQueue(uint limit) external nonReentrant {\n    Liquidity memory liquidity = _getLiquidityAndUpdateCB();\n    uint tokenPrice = _getTokenPrice(liquidity.NAV, getTotalTokenSupply());\n    uint processedDeposits;\n\n    for (uint i = 0; i < limit; ++i) {\n      QueuedDeposit storage current = queuedDeposits[queuedDepositHead];\n      if (!_canProcess(current.depositInitiatedTime, lpParams.depositDelay, queuedDepositHead)) {\n        break;\n      }\n\n      uint amountTokens = current.amountLiquidity.divideDecimal(tokenPrice);\n      liquidityToken.mint(current.beneficiary, amountTokens);\n      current.mintedTokens = amountTokens;\n      processedDeposits += current.amountLiquidity;\n\n      emit DepositProcessed(\n        msg.sender,\n        current.beneficiary,\n        queuedDepositHead,\n        current.amountLiquidity,\n        tokenPrice,\n        amountTokens,\n        block.timestamp\n      );\n      current.amountLiquidity = 0;\n\n      queuedDepositHead++;\n    }\n\n    // only update if deposit processed to avoid changes when CB's are firing\n    if (processedDeposits != 0) {\n      totalQueuedDeposits -= processedDeposits;\n\n      protectedQuote = (liquidity.NAV + processedDeposits).multiplyDecimal(\n        DecimalMath.UNIT - lpParams.adjustmentNetScalingFactor\n      );\n    }\n  }\n\n  /// @param limit number of withdrawal tickets to process in a single transaction to avoid gas limit soft-locks\n  function processWithdrawalQueue(uint limit) external nonReentrant {\n    uint oldQueuedWithdrawals = totalQueuedWithdrawals;\n    for (uint i = 0; i < limit; ++i) {\n      (uint totalTokensBurnable, uint tokenPriceWithFee) = _getBurnableTokensAndAddFee();\n\n      QueuedWithdrawal storage current = queuedWithdrawals[queuedWithdrawalHead];\n\n      if (!_canProcess(current.withdrawInitiatedTime, lpParams.withdrawalDelay, queuedWithdrawalHead)) {\n        break;\n      }\n\n      if (totalTokensBurnable == 0) {\n        break;\n      }\n\n      uint burnAmount = current.amountTokens;\n      if (burnAmount > totalTokensBurnable) {\n        burnAmount = totalTokensBurnable;\n      }\n\n      current.amountTokens -= burnAmount;\n      totalQueuedWithdrawals -= burnAmount;\n\n      uint quoteAmount = burnAmount.multiplyDecimal(tokenPriceWithFee);\n      if (_tryTransferQuote(current.beneficiary, quoteAmount)) {\n        // success\n        current.quoteSent += quoteAmount;\n      } else {\n        // On unknown failure reason, return LP tokens and continue\n        totalQueuedWithdrawals -= current.amountTokens;\n        uint returnAmount = current.amountTokens + burnAmount;\n        liquidityToken.mint(current.beneficiary, returnAmount);\n        current.amountTokens = 0;\n        emit WithdrawReverted(\n          msg.sender,\n          current.beneficiary,\n          queuedWithdrawalHead,\n          tokenPriceWithFee,\n          totalQueuedWithdrawals,\n          block.timestamp,\n          returnAmount\n        );\n        queuedWithdrawalHead++;\n        continue;\n      }\n\n      if (current.amountTokens > 0) {\n        emit WithdrawPartiallyProcessed(\n          msg.sender,\n          current.beneficiary,\n          queuedWithdrawalHead,\n          burnAmount,\n          tokenPriceWithFee,\n          quoteAmount,\n          totalQueuedWithdrawals,\n          block.timestamp\n        );\n        break;\n      }\n      emit WithdrawProcessed(\n        msg.sender,\n        current.beneficiary,\n        queuedWithdrawalHead,\n        burnAmount,\n        tokenPriceWithFee,\n        quoteAmount,\n        totalQueuedWithdrawals,\n        block.timestamp\n      );\n      queuedWithdrawalHead++;\n    }\n\n    // only update if withdrawal processed to avoid changes when CB's are firing\n    // getLiquidity() called again to account for withdrawal fee\n    if (oldQueuedWithdrawals > totalQueuedWithdrawals) {\n      Liquidity memory liquidity = getLiquidity();\n      protectedQuote = liquidity.NAV.multiplyDecimal(DecimalMath.UNIT - lpParams.adjustmentNetScalingFactor);\n    }\n  }\n\n  /// @dev Checks if deposit/withdrawal ticket can be processed\n  function _canProcess(uint initiatedTime, uint minimumDelay, uint entryId) internal returns (bool) {\n    bool validEntry = initiatedTime != 0;\n    // bypass circuit breaker and stale checks if the guardian is calling and their delay has passed\n    bool guardianBypass = msg.sender == lpParams.guardianMultisig &&\n      initiatedTime + lpParams.guardianDelay < block.timestamp;\n    // if minimum delay or circuit breaker timeout hasn't passed, we can't process\n    bool delaysExpired = initiatedTime + minimumDelay < block.timestamp && CBTimestamp < block.timestamp;\n\n    // cannot process if greekCache stale\n    uint spotPrice = exchangeAdapter.getSpotPriceForMarket(\n      address(optionMarket),\n      BaseExchangeAdapter.PriceType.REFERENCE\n    );\n    bool isStale = greekCache.isGlobalCacheStale(spotPrice);\n\n    emit CheckingCanProcess(entryId, !isStale, validEntry, guardianBypass, delaysExpired);\n\n    return validEntry && ((!isStale && delaysExpired) || guardianBypass);\n  }\n\n  function _getBurnableTokensAndAddFee() internal returns (uint burnableTokens, uint tokenPriceWithFee) {\n    (uint tokenPrice, uint burnableLiquidity) = _getTokenPriceAndBurnableLiquidity();\n    tokenPriceWithFee = (optionMarket.getNumLiveBoards() != 0)\n      ? tokenPrice.multiplyDecimal(DecimalMath.UNIT - lpParams.withdrawalFee)\n      : tokenPrice;\n\n    return (burnableLiquidity.divideDecimal(tokenPriceWithFee), tokenPriceWithFee);\n  }\n\n  function _getTokenPriceAndBurnableLiquidity() internal returns (uint tokenPrice, uint burnableLiquidity) {\n    Liquidity memory liquidity = _getLiquidityAndUpdateCB();\n    uint totalTokenSupply = getTotalTokenSupply();\n    tokenPrice = _getTokenPrice(liquidity.NAV, totalTokenSupply);\n\n    return (tokenPrice, liquidity.burnableLiquidity);\n  }\n\n  //////////////////////\n  // Circuit Breakers //\n  //////////////////////\n\n  /// @notice Checks the ivVariance, skewVariance, and liquidity circuit breakers and triggers if necessary\n  function updateCBs() external nonReentrant {\n    _getLiquidityAndUpdateCB();\n  }\n\n  function _updateCBs(\n    Liquidity memory liquidity,\n    uint maxIvVariance,\n    uint maxSkewVariance,\n    int optionValueDebt\n  ) internal {\n    // don't trigger CBs if pool has no open options\n    if (liquidity.reservedCollatLiquidity == 0 && optionValueDebt == 0) {\n      return;\n    }\n\n    uint timeToAdd = 0;\n\n    // if NAV == 0, openAmount will be zero too and _updateCB() won't be called.\n    uint freeLiquidityPercent = liquidity.freeLiquidity.divideDecimal(liquidity.NAV);\n\n    bool ivVarianceThresholdCrossed = maxIvVariance > cbParams.ivVarianceCBThreshold;\n    bool skewVarianceThresholdCrossed = maxSkewVariance > cbParams.skewVarianceCBThreshold;\n    bool liquidityThresholdCrossed = freeLiquidityPercent < cbParams.liquidityCBThreshold;\n    bool contractAdjustmentEvent = liquidity.longScaleFactor != DecimalMath.UNIT;\n\n    if (ivVarianceThresholdCrossed) {\n      timeToAdd = cbParams.ivVarianceCBTimeout;\n    }\n\n    if (skewVarianceThresholdCrossed && cbParams.skewVarianceCBTimeout > timeToAdd) {\n      timeToAdd = cbParams.skewVarianceCBTimeout;\n    }\n\n    if (liquidityThresholdCrossed && cbParams.liquidityCBTimeout > timeToAdd) {\n      timeToAdd = cbParams.liquidityCBTimeout;\n    }\n\n    if (contractAdjustmentEvent && cbParams.contractAdjustmentCBTimeout > timeToAdd) {\n      timeToAdd = cbParams.contractAdjustmentCBTimeout;\n    }\n\n    if (timeToAdd > 0 && CBTimestamp < block.timestamp + timeToAdd) {\n      CBTimestamp = block.timestamp + timeToAdd;\n      emit CircuitBreakerUpdated(\n        CBTimestamp,\n        ivVarianceThresholdCrossed,\n        skewVarianceThresholdCrossed,\n        liquidityThresholdCrossed,\n        contractAdjustmentEvent\n      );\n    }\n  }\n\n  ///////////////////////\n  // Only OptionMarket //\n  ///////////////////////\n\n  /**\n   * @notice Locks quote as collateral when the AMM sells a put option.\n   *\n   * @param amount The amount of quote to lock.\n   * @param freeLiquidity The amount of free collateral that can be locked.\n   */\n  function lockPutCollateral(uint amount, uint freeLiquidity, uint strikeId) external onlyOptionMarket {\n    if (amount.multiplyDecimal(lpParams.putCollatScalingFactor) > freeLiquidity) {\n      revert LockingMoreQuoteThanIsFree(address(this), amount, freeLiquidity, lockedCollateral);\n    }\n\n    _checkCanHedge(amount, true, strikeId);\n\n    lockedCollateral.quote += amount;\n    emit PutCollateralLocked(amount, lockedCollateral.quote);\n  }\n\n  /**\n   * @notice Locks quote as collateral when the AMM sells a call option.\n   *\n   * @param amount The amount of quote to lock.\n   */\n  function lockCallCollateral(\n    uint amount,\n    uint spotPrice,\n    uint freeLiquidity,\n    uint strikeId\n  ) external onlyOptionMarket {\n    _checkCanHedge(amount, false, strikeId);\n\n    if (amount.multiplyDecimal(spotPrice).multiplyDecimal(lpParams.callCollatScalingFactor) > freeLiquidity) {\n      revert LockingMoreQuoteThanIsFree(\n        address(this),\n        amount.multiplyDecimal(spotPrice),\n        freeLiquidity,\n        lockedCollateral\n      );\n    }\n    lockedCollateral.base += amount;\n    emit CallCollateralLocked(amount, lockedCollateral.base);\n  }\n\n  /**\n   * @notice Frees quote collateral when user closes a long put\n   *         and sends them the option premium\n   *\n   * @param amountQuoteFreed The amount of quote to free.\n   */\n  function freePutCollateralAndSendPremium(\n    uint amountQuoteFreed,\n    address recipient,\n    uint totalCost,\n    uint reservedFee,\n    uint longScaleFactor\n  ) external onlyOptionMarket {\n    _freePutCollateral(amountQuoteFreed);\n    _sendPremium(recipient, totalCost.multiplyDecimal(longScaleFactor), reservedFee);\n  }\n\n  /**\n   * @notice Frees/exchange base collateral when user closes a long call\n   *         and sends the option premium to the user\n   *\n   * @param amountBase The amount of base to free and exchange.\n   */\n  function freeCallCollateralAndSendPremium(\n    uint amountBase,\n    address recipient,\n    uint totalCost,\n    uint reservedFee,\n    uint longScaleFactor\n  ) external onlyOptionMarket {\n    _freeCallCollateral(amountBase);\n    _sendPremium(recipient, totalCost.multiplyDecimal(longScaleFactor), reservedFee);\n  }\n\n  /**\n   * @notice Sends premium user selling an option to the pool.\n   * @dev The caller must be the OptionMarket.\n   *\n   * @param recipient The address of the recipient.\n   * @param amountContracts The number of contracts sold to AMM.\n   * @param premium The amount to transfer to the user.\n   * @param freeLiquidity The amount of free collateral liquidity.\n   * @param reservedFee The amount collected by the OptionMarket.\n   */\n  function sendShortPremium(\n    address recipient,\n    uint amountContracts,\n    uint premium,\n    uint freeLiquidity,\n    uint reservedFee,\n    bool isCall,\n    uint strikeId\n  ) external onlyOptionMarket {\n    if (premium + reservedFee > freeLiquidity) {\n      revert SendPremiumNotEnoughCollateral(address(this), premium, reservedFee, freeLiquidity);\n    }\n\n    // only blocks opening new positions if cannot hedge\n    // Since this is opening a short, pool delta exposure is the same direction as if it were a call\n    // (user opens a short call, the pool acquires on a long call)\n    _checkCanHedge(amountContracts, isCall, strikeId);\n    _sendPremium(recipient, premium, reservedFee);\n  }\n\n  /**\n   * @notice Manages collateral at the time of board liquidation, also converting base received from shortCollateral.\n   *\n   * @param insolventSettlements amount of AMM profits not paid by shortCollateral due to user insolvencies.\n   * @param amountQuoteFreed amount of AMM long put quote collateral that can be freed, including ITM profits.\n   * @param amountQuoteReserved amount of AMM quote reserved for long call/put ITM profits.\n   * @param amountBaseFreed amount of AMM long call base collateral that can be freed, including ITM profits.\n   */\n  function boardSettlement(\n    uint insolventSettlements,\n    uint amountQuoteFreed,\n    uint amountQuoteReserved,\n    uint amountBaseFreed\n  ) external onlyOptionMarket returns (uint) {\n    // Update circuit breaker whenever a board is settled, to pause deposits/withdrawals\n    // This allows keepers some time to settle insolvent positions\n    if (block.timestamp + cbParams.boardSettlementCBTimeout > CBTimestamp) {\n      CBTimestamp = block.timestamp + cbParams.boardSettlementCBTimeout;\n      emit BoardSettlementCircuitBreakerUpdated(CBTimestamp);\n    }\n\n    insolventSettlementAmount += insolventSettlements;\n\n    _freePutCollateral(amountQuoteFreed);\n    _freeCallCollateral(amountBaseFreed);\n\n    // If amountQuoteReserved > available liquidity, amountQuoteReserved is scaled down to an available amount\n    Liquidity memory liquidity = getLiquidity(); // calculates total pool value and potential scaling\n\n    totalOutstandingSettlements += amountQuoteReserved.multiplyDecimal(liquidity.longScaleFactor);\n\n    emit BoardSettlement(insolventSettlementAmount, amountQuoteReserved, totalOutstandingSettlements);\n\n    if (address(poolHedger) != address(0)) {\n      poolHedger.resetInteractionDelay();\n    }\n    return liquidity.longScaleFactor;\n  }\n\n  /**\n   * @notice Frees quote when the AMM buys back/settles a put from the user.\n   * @param amountQuote The amount of quote to free.\n   */\n  function _freePutCollateral(uint amountQuote) internal {\n    // In case of rounding errors\n    amountQuote = amountQuote > lockedCollateral.quote ? lockedCollateral.quote : amountQuote;\n    lockedCollateral.quote -= amountQuote;\n    emit PutCollateralFreed(amountQuote, lockedCollateral.quote);\n  }\n\n  /**\n   * @notice Frees quote when the AMM buys back/settles a call from the user.\n   * @param amountBase The amount of base to free.\n   */\n\n  function _freeCallCollateral(uint amountBase) internal {\n    // In case of rounding errors\n    amountBase = amountBase > lockedCollateral.base ? lockedCollateral.base : amountBase;\n    lockedCollateral.base -= amountBase;\n    emit CallCollateralFreed(amountBase, lockedCollateral.base);\n  }\n\n  /**\n   * @notice Sends the premium to a user who is closing a long or opening a short.\n   * @dev The caller must be the OptionMarket.\n   *\n   * @param recipient The address of the recipient.\n   * @param recipientAmount The amount to transfer to the recipient.\n   * @param optionMarketPortion The fee to transfer to the optionMarket.\n   */\n  function _sendPremium(address recipient, uint recipientAmount, uint optionMarketPortion) internal {\n    _transferQuote(recipient, recipientAmount);\n    _transferQuote(address(optionMarket), optionMarketPortion);\n\n    emit PremiumTransferred(recipient, recipientAmount, optionMarketPortion);\n  }\n\n  //////////////////////////\n  // Only ShortCollateral //\n  //////////////////////////\n\n  /**\n   * @notice Transfers long option settlement profits to `user`.\n   * @dev The caller must be the ShortCollateral.\n   *\n   * @param user The address of the user to send the quote.\n   * @param amount The amount of quote to send.\n   */\n  function sendSettlementValue(address user, uint amount) external onlyShortCollateral {\n    // To prevent any potential rounding errors\n    if (amount > totalOutstandingSettlements) {\n      amount = totalOutstandingSettlements;\n    }\n    totalOutstandingSettlements -= amount;\n    _transferQuote(user, amount);\n\n    emit OutstandingSettlementSent(user, amount, totalOutstandingSettlements);\n  }\n\n  /**\n   * @notice Claims AMM profits that were not paid during boardSettlement() due to\n   * total quote insolvencies > total solvent quote collateral.\n   * @dev The caller must be ShortCollateral.\n   *\n   * @param amountQuote The amount of quote to send to the LiquidityPool.\n   */\n  function reclaimInsolventQuote(uint amountQuote) external onlyShortCollateral {\n    Liquidity memory liquidity = getLiquidity();\n    if (amountQuote > liquidity.freeLiquidity) {\n      revert NotEnoughFreeToReclaimInsolvency(address(this), amountQuote, liquidity);\n    }\n    _transferQuote(address(shortCollateral), amountQuote);\n\n    insolventSettlementAmount += amountQuote;\n\n    emit InsolventSettlementAmountUpdated(amountQuote, insolventSettlementAmount);\n  }\n\n  /**\n   * @notice Claims AMM profits that were not paid during boardSettlement() due to\n   * total base insolvencies > total solvent base collateral.\n   * @dev The caller must be ShortCollateral.\n   *\n   * @param amountBase The amount of base to send to the LiquidityPool.\n   */\n  function reclaimInsolventBase(uint amountBase) external onlyShortCollateral {\n    Liquidity memory liquidity = getLiquidity();\n\n    uint freeLiq = ConvertDecimals.convertFrom18(liquidity.freeLiquidity, quoteAsset.decimals());\n\n    if (!quoteAsset.approve(address(exchangeAdapter), freeLiq)) {\n      revert QuoteApprovalFailure(address(this), address(exchangeAdapter), freeLiq);\n    }\n\n    // Assume the inputs and outputs of exchangeAdapter are always 1e18\n    (uint quoteSpent, ) = exchangeAdapter.exchangeToExactBaseWithLimit(\n      address(optionMarket),\n      amountBase,\n      liquidity.freeLiquidity\n    );\n    insolventSettlementAmount += quoteSpent;\n\n    // It is better for the contract to revert if there is not enough here (due to rounding) to keep accounting in\n    // ShortCollateral correct. baseAsset can be donated (sent) to this contract to allow this to pass.\n    uint realBase = ConvertDecimals.convertFrom18(amountBase, baseAsset.decimals());\n    if (realBase > 0 && !baseAsset.transfer(address(shortCollateral), realBase)) {\n      revert BaseTransferFailed(address(this), address(this), address(shortCollateral), realBase);\n    }\n\n    emit InsolventSettlementAmountUpdated(quoteSpent, insolventSettlementAmount);\n  }\n\n  //////////////////////////////\n  // Getting Pool Token Value //\n  //////////////////////////////\n\n  /// @dev Get total number of oustanding LiquidityToken\n  function getTotalTokenSupply() public view returns (uint) {\n    return liquidityToken.totalSupply() + totalQueuedWithdrawals;\n  }\n\n  /**\n   * @notice Get current pool token price and check if market conditions warrant an accurate token price\n   *\n   * @return tokenPrice price of token\n   * @return isStale has global cache not been updated in a long time (if stale, greeks may be inaccurate)\n   * @return circuitBreakerExpiry expiry timestamp of the CircuitBreaker (if not expired, greeks may be inaccurate)\n   */\n  function getTokenPriceWithCheck() external view returns (uint tokenPrice, bool isStale, uint circuitBreakerExpiry) {\n    tokenPrice = getTokenPrice();\n    uint spotPrice = exchangeAdapter.getSpotPriceForMarket(\n      address(optionMarket),\n      BaseExchangeAdapter.PriceType.REFERENCE\n    );\n    isStale = greekCache.isGlobalCacheStale(spotPrice);\n    return (tokenPrice, isStale, CBTim"
    }
  ]
}