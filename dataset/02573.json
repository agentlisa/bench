{
  "Title": "H-6: `msgValue` will not be populated if ETH is the secondary token",
  "Content": "# Issue H-6: `msgValue` will not be populated if ETH is the secondary token \n\nSource: https://github.com/sherlock-audit/2022-12-notional-judging/issues/12 \n\n## Found by \nxiaoming90\n\n## Summary\n\n`msgValue` will not be populated if ETH is the secondary token in the two token leverage vault, leading to a loss of assets as the ETH is not forwarded to the Balancer Pool during a trade.\n\n## Vulnerability Detail\n\nBased on the source code of the two token pool leverage vault, it is possible to deploy a vault to support a Balancer pool with an arbitrary token as the primary token and ETH as the secondary token. The primary token is always the borrowing currency in the vault.\n\nHowever, Line 60 of `TwoTokenPoolUtils._getPoolParams` function below assumes that if one of the two tokens is ETH in the pool, it will always be the primary token or borrowing currency, which is not always the case. If the ETH is set as the secondary token, the `msgValue` will not be populated.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L45\n\n```solidity\nFile: TwoTokenPoolUtils.sol\n44:     /// @notice Returns parameters for joining and exiting Balancer pools\n45:     function _getPoolParams(\n46:         TwoTokenPoolContext memory context,\n47:         uint256 primaryAmount,\n48:         uint256 secondaryAmount,\n49:         bool isJoin\n50:     ) internal pure returns (PoolParams memory) {\n51:         IAsset[] memory assets = new IAsset[](2);\n52:         assets[context.primaryIndex] = IAsset(context.primaryToken);\n53:         assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n54: \n55:         uint256[] memory amounts = new uint256[](2);\n56:         amounts[context.primaryIndex] = primaryAmount;\n57:         amounts[context.secondaryIndex] = secondaryAmount;\n58: \n59:         uint256 msgValue;\n60:         if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n61:             msgValue = amounts[context.primaryIndex];\n62:         }\n63: \n64:         return PoolParams(assets, amounts, msgValue);\n65:     }\n```\n\nAs a result, when the caller joins the Balancer pool, the `params.msgValue` will be empty, and no secondary token (ETH) will be forwarded to the Balancer pool. The ETH will remain stuck in the vault and the caller will receive much fewer BPT tokens in return.\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/BalancerUtils.sol#L49\n\n```solidity\nFile: BalancerUtils.sol\n48:     /// @notice Joins a balancer pool using exact tokens in\n49:     function _joinPoolExactTokensIn(\n50:         PoolContext memory context,\n51:         PoolParams memory params,\n52:         uint256 minBPT\n53:     ) internal returns (uint256 bptAmount) {\n54:         bptAmount = IERC20(address(context.pool)).balanceOf(address(this));\n55:         Deployments.BALANCER_VAULT.joinPool{value: params.msgValue}(\n56:             context.poolId,\n57:             address(this),\n58:             address(this),\n59:             IBalancerVault.JoinPoolRequest(\n60:                 params.assets,\n61:                 params.amounts,\n62:                 abi.encode(\n63:                     IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n64:                     params.amounts,\n65:                     minBPT // Apply minBPT to prevent front running\n66:                 ),\n67:                 false // Don't use internal balances\n68:             )\n69:         );\n70:         bptAmount =\n71:             IERC20(address(context.pool)).balanceOf(address(this)) -\n72:             bptAmount;\n73:     }\n```\n\n## Impact\n\nLoss of assets for the callers as ETH will remain stuck in the vault and not forwarded to the Balancer Pool. Since the secondary token (ETH) is not forwarded to the Balancer pool, the caller will receive much fewer BPT tokens in return when joining the pool.\n\nThis issue affects the deposit and reinvest reward functions of the vault, which means that the depositor will receive fewer strategy tokens in return during depositing, and the vault will receive less BPT in return during reinvesting.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-12-notional/blob/main/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L45\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider populating the `msgValue` if the secondary token is ETH.\n\n```diff\n/// @notice Returns parameters for joining and exiting Balancer pools\nfunction _getPoolParams(\n    TwoTokenPoolContext memory context,\n    uint256 primaryAmount,\n    uint256 secondaryAmount,\n    bool isJoin\n) internal pure returns (PoolParams memory) {\n    IAsset[] memory assets = new IAsset[](2);\n    assets[context.primaryIndex] = IAsset(context.primaryToken);\n    assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n    uint256[] memory amounts = new uint256[](2);\n    amounts[context.primaryIndex] = primaryAmount;\n    amounts[context.secondaryIndex] = secondaryAmount;\n\n    uint256 msgValue;\n    if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n    \tmsgValue = amounts[context.primaryIndex];\n    }\n+   if (isJoin && assets[context.secondaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n+   \tmsgValue = amounts[context.secondaryIndex];\n+   }\n    \n    return PoolParams(assets, amounts, msgValue);\n}\n```\n\n## Discussion\n\n**weitianjie2000**\n\nvalid, will fix\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/31",
  "Code": [
    {
      "filename": "contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    TwoTokenPoolContext, \n    StableOracleContext, \n    PoolParams,\n    DepositParams,\n    TradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Stable2TokenOracleMath} from \"../math/Stable2TokenOracleMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../pool/TwoTokenPoolUtils.sol\";\nimport {ITradingModule, Trade} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TradeHandler for Trade;\n    using TypeConvert for uint256;\n    using StrategyUtils for StrategyContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    /// @notice Returns parameters for joining and exiting Balancer pools\n    function _getPoolParams(\n        TwoTokenPoolContext memory context,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isJoin\n    ) internal pure returns (PoolParams memory) {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[context.primaryIndex] = IAsset(context.primaryToken);\n        assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[context.primaryIndex] = primaryAmount;\n        amounts[context.secondaryIndex] = secondaryAmount;\n\n        uint256 msgValue;\n        if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n            msgValue = amounts[context.primaryIndex];\n        }\n\n        return PoolParams(assets, amounts, msgValue);\n    }\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n            poolContext.primaryToken, poolContext.secondaryToken\n        );\n        require(rate > 0);\n        require(decimals >= 0);\n\n        if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n            rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n        }\n\n        // No overflow in rate conversion, checked above\n        oraclePairPrice = uint256(rate);\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Balancer pool needs to be fully initialized with at least 1024 trades\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StableOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        uint256 oraclePairPrice = _getOraclePairPrice(poolContext, strategyContext.tradingModule);\n        // tokenIndex == 0 because _getOraclePairPrice always returns the price in terms of\n        // the primary currency\n        uint256 spotPrice = oracleContext._getSpotPrice({\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        // Make sure spot price is within oracleDeviationLimit of pairPrice\n        Stable2TokenOracleMath._checkPriceLimit(strategyContext, oraclePairPrice, spotPrice);\n        \n        // Get shares of primary and secondary balances with the provided bptAmount\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        uint256 primaryBalance = poolContext.primaryBalance * bptAmount / totalBPTSupply;\n        uint256 secondaryBalance = poolContext.secondaryBalance * bptAmount / totalBPTSupply;\n\n        // Value the secondary balance in terms of the primary token using the oraclePairPrice\n        uint256 secondaryAmountInPrimary = secondaryBalance * BalancerConstants.BALANCER_PRECISION / oraclePairPrice;\n\n        // Make sure primaryAmount is reported in primaryPrecision\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        primaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / BalancerConstants.BALANCER_PRECISION;\n    }\n\n    function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n        IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        // Allow BPT spender to pull BALANCER_POOL_TOKEN\n        IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) private returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount,\n            useDynamicSlippage: true\n        });\n    }\n\n    function _deposit(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX instead of Balancer when joining\n            (uint256 primarySold, uint256 secondaryBought) = _tradePrimaryForSecondary({\n                poolContext: poolContext,\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minBPT: params.minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        strategyContext.vaultState.totalBPTHeld += bptMinted;\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) private returns (uint256 primaryPurchased) {\n        (TradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (TradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance,\n                useDynamicSlippage: true\n            });\n    }\n\n    function _redeem(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(\n                poolContext, stakingContext, bptClaim, params.minPrimary, params.minSecondary\n            );\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = _sellSecondaryBalance(\n                poolContext, strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n\n        strategyContext.vaultState.totalBPTHeld -= bptClaim;\n        // Update global strategy token balance\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        // prettier-ignore\n        PoolParams memory poolParams = poolContext._getPoolParams( \n            primaryAmount, \n            secondaryAmount,\n            true // isJoin\n        );\n\n        bptMinted = BalancerUtils._joinPoolExactTokensIn({\n            context: poolContext.basePool,\n            params: poolParams,\n            minBPT: minBPT\n        });\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext.basePool.pool.totalSupply()\n        );\n        uint256 bptHeldAfterJoin = strategyContext.vaultState.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n        if (!success) revert Errors.StakeFailed();\n    }\n\n    function _unstakeAndExitPool(\n        TwoTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary,\n        uint256 minSecondary\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        bool success = stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n        if (!success) revert Errors.UnstakeFailed();\n\n        uint256[] memory exitBalances = BalancerUtils._exitPoolExactBPTIn({\n            context: poolContext.basePool,\n            params: poolContext._getPoolParams(minPrimary, minSecondary, false), // isJoin = false\n            bptExitAmount: bptClaim\n        });\n        \n        (primaryBalance, secondaryBalance) \n            = (exitBalances[poolContext.primaryIndex], exitBalances[poolContext.secondaryIndex]);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        StableOracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 bptClaim \n            = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext._getTimeWeightedPrimaryBalance(oracleContext, strategyContext, bptClaim).toInt();\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/pool/BalancerUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IBalancerVault, IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {PoolContext, PoolParams} from \"../../BalancerVaultTypes.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary BalancerUtils {\n    using TokenUtils for IERC20;\n\n    /// @notice Special handling for ETH because UNDERLYING_TOKEN == address(0)\n    /// and Balancer uses WETH\n    function getTokenAddress(address token) internal pure returns (address) {\n        return token == Deployments.ETH_ADDRESS ? address(Deployments.WETH) : address(token);\n    }\n\n    /// @notice Normalizes balances to 1e18 (used by Balancer price oracle functions)\n    function _normalizeBalances(\n        uint256 primaryBalance,\n        uint8 primaryDecimals,\n        uint256 secondaryBalance,\n        uint8 secondaryDecimals\n    ) internal pure returns (uint256 normalizedPrimary, uint256 normalizedSecondary) {\n        if (primaryDecimals == 18) {\n            normalizedPrimary = primaryBalance;\n        } else {\n            uint256 decimalAdjust;\n            unchecked {\n                decimalAdjust = 10**(18 - primaryDecimals);\n            }\n            normalizedPrimary = primaryBalance * decimalAdjust;\n        }\n\n        if (secondaryDecimals == 18) {\n            normalizedSecondary = secondaryBalance;\n        } else {\n            uint256 decimalAdjust;\n            unchecked {\n                decimalAdjust = 10**(18 - secondaryDecimals);\n            }\n            normalizedSecondary = secondaryBalance * decimalAdjust;\n        }\n    }\n\n    /// @notice Joins a balancer pool using exact tokens in\n    function _joinPoolExactTokensIn(\n        PoolContext memory context,\n        PoolParams memory params,\n        uint256 minBPT\n    ) internal returns (uint256 bptAmount) {\n        bptAmount = IERC20(address(context.pool)).balanceOf(address(this));\n        Deployments.BALANCER_VAULT.joinPool{value: params.msgValue}(\n            context.poolId,\n            address(this),\n            address(this),\n            IBalancerVault.JoinPoolRequest(\n                params.assets,\n                params.amounts,\n                abi.encode(\n                    IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                    params.amounts,\n                    minBPT // Apply minBPT to prevent front running\n                ),\n                false // Don't use internal balances\n            )\n        );\n        bptAmount =\n            IERC20(address(context.pool)).balanceOf(address(this)) -\n            bptAmount;\n    }\n\n    /// @notice Exits a balancer pool using exact BPT in\n    function _exitPoolExactBPTIn(\n        PoolContext memory context,\n        PoolParams memory params,\n        uint256 bptExitAmount\n    ) internal returns (uint256[] memory exitBalances) {\n        uint256 numAssets = params.assets.length;\n        exitBalances = new uint256[](numAssets);\n\n        for (uint256 i; i < numAssets; i++) {\n            exitBalances[i] = TokenUtils.tokenBalance(address(params.assets[i]));\n        }\n\n        Deployments.BALANCER_VAULT.exitPool(\n            context.poolId,\n            address(this),\n            payable(address(this)), // Vault will receive the underlying assets\n            IBalancerVault.ExitPoolRequest(\n                params.assets,\n                params.amounts,\n                abi.encode(\n                    IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                    bptExitAmount\n                ),\n                false // Don't use internal balances\n            )\n        );\n\n        for (uint256 i; i < numAssets; i++) {\n            exitBalances[i] = TokenUtils.tokenBalance(address(params.assets[i])) - exitBalances[i];\n        }\n    }\n\n    function _swapGivenIn(\n        bytes32 poolId,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 limit\n    ) internal returns (uint256 amountOut) {\n        amountOut = IERC20(tokenOut).balanceOf(address(this));\n        Deployments.BALANCER_VAULT.swap({\n            singleSwap: IBalancerVault.SingleSwap({\n                poolId: poolId,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: IAsset(tokenIn),\n                assetOut: IAsset(tokenOut),\n                amount: amountIn,\n                userData: new bytes(0)\n            }),\n            funds: IBalancerVault.FundManagement({\n                sender: address(this),\n                fromInternalBalance: false,\n                recipient: payable(address(this)),\n                toInternalBalance: false\n            }),\n            limit: limit,\n            deadline: block.timestamp\n        });\n        amountOut = IERC20(tokenOut).balanceOf(address(this)) - amountOut;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    TwoTokenPoolContext, \n    StableOracleContext, \n    PoolParams,\n    DepositParams,\n    TradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Stable2TokenOracleMath} from \"../math/Stable2TokenOracleMath.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../pool/TwoTokenPoolUtils.sol\";\nimport {ITradingModule, Trade} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TradeHandler for Trade;\n    using TypeConvert for uint256;\n    using StrategyUtils for StrategyContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n    using Stable2TokenOracleMath for StableOracleContext;\n\n    /// @notice Returns parameters for joining and exiting Balancer pools\n    function _getPoolParams(\n        TwoTokenPoolContext memory context,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isJoin\n    ) internal pure returns (PoolParams memory) {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[context.primaryIndex] = IAsset(context.primaryToken);\n        assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[context.primaryIndex] = primaryAmount;\n        amounts[context.secondaryIndex] = secondaryAmount;\n\n        uint256 msgValue;\n        if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n            msgValue = amounts[context.primaryIndex];\n        }\n\n        return PoolParams(assets, amounts, msgValue);\n    }\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n            poolContext.primaryToken, poolContext.secondaryToken\n        );\n        require(rate > 0);\n        require(decimals >= 0);\n\n        if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n            rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n        }\n\n        // No overflow in rate conversion, checked above\n        oraclePairPrice = uint256(rate);\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Balancer pool needs to be fully initialized with at least 1024 trades\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StableOracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        uint256 oraclePairPrice = _getOraclePairPrice(poolContext, strategyContext.tradingModule);\n        // tokenIndex == 0 because _getOraclePairPrice always returns the price in terms of\n        // the primary currency\n        uint256 spotPrice = oracleContext._getSpotPrice({\n            poolContext: poolContext,\n            primaryBalance: poolContext.primaryBalance,\n            secondaryBalance: poolContext.secondaryBalance,\n            tokenIndex: 0\n        });\n\n        // Make sure spot price is within oracleDeviationLimit of pairPrice\n        Stable2TokenOracleMath._checkPriceLimit(strategyContext, oraclePairPrice, spotPrice);\n        \n        // Get shares of primary and secondary balances with the provided bptAmount\n        uint256 totalBPTSupply = poolContext.basePool.pool.totalSupply();\n        uint256 primaryBalance = poolContext.primaryBalance * bptAmount / totalBPTSupply;\n        uint256 secondaryBalance = poolContext.secondaryBalance * bptAmount / totalBPTSupply;\n\n        // Value the secondary balance in terms of the primary token using the oraclePairPrice\n        uint256 secondaryAmountInPrimary = secondaryBalance * BalancerConstants.BALANCER_PRECISION / oraclePairPrice;\n\n        // Make sure primaryAmount is reported in primaryPrecision\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        primaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / BalancerConstants.BALANCER_PRECISION;\n    }\n\n    function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n        IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        // Allow BPT spender to pull BALANCER_POOL_TOKEN\n        IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) private returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount,\n            useDynamicSlippage: true\n        });\n    }\n\n    function _deposit(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX instead of Balancer when joining\n            (uint256 primarySold, uint256 secondaryBought) = _tradePrimaryForSecondary({\n                poolContext: poolContext,\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minBPT: params.minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        strategyContext.vaultState.totalBPTHeld += bptMinted;\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) private returns (uint256 primaryPurchased) {\n        (TradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (TradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance,\n                useDynamicSlippage: true\n            });\n    }\n\n    function _redeem(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 strategyTokens,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(\n                poolContext, stakingContext, bptClaim, params.minPrimary, params.minSecondary\n            );\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = _sellSecondaryBalance(\n                poolContext, strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n\n        strategyContext.vaultState.totalBPTHeld -= bptClaim;\n        // Update global strategy token balance\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        // prettier-ignore\n        PoolParams memory poolParams = poolContext._getPoolParams( \n            primaryAmount, \n            secondaryAmount,\n            true // isJoin\n        );\n\n        bptMinted = BalancerUtils._joinPoolExactTokensIn({\n            context: poolContext.basePool,\n            params: poolParams,\n            minBPT: minBPT\n        });\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext.basePool.pool.totalSupply()\n        );\n        uint256 bptHeldAfterJoin = strategyContext.vaultState.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n        if (!success) revert Errors.StakeFailed();\n    }\n\n    function _unstakeAndExitPool(\n        TwoTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary,\n        uint256 minSecondary\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        bool success = stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n        if (!success) revert Errors.UnstakeFailed();\n\n        uint256[] memory exitBalances = BalancerUtils._exitPoolExactBPTIn({\n            context: poolContext.basePool,\n            params: poolContext._getPoolParams(minPrimary, minSecondary, false), // isJoin = false\n            bptExitAmount: bptClaim\n        });\n        \n        (primaryBalance, secondaryBalance) \n            = (exitBalances[poolContext.primaryIndex], exitBalances[poolContext.secondaryIndex]);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        StableOracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 bptClaim \n            = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext._getTimeWeightedPrimaryBalance(oracleContext, strategyContext, bptClaim).t"
    }
  ]
}