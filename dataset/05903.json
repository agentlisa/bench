{
  "Title": "[H-03] The settle feature will be broken if attacker arbitrarily transfer collateral tokens to the PerpetualAtlanticVaultLP",
  "Content": "\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L199-L205> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L359-L361> \n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L772-L774>\n\n`RdpxV2Core.settle` reverts and the protocol stops.\n\n### Proof of Concept\n\nIf a collateral token(WETH) is arbitrarily sent to PerpetualAtlanticVaultLP, the values of `collateral.balanceOf(address(this))` and `_totalCollateral` will be different.\n\nSince `PerpetualAtlanticVaultLP.subtractLoss` requires that `collateral.balanceOf(address(this))` exactly match with `_totalCollateral - loss`, `PerpetualAtlanticVaultLP.subtractLoss` will be failed if an attacker arbitrarily transfers collateral tokens to the PerpetualAtlanticVaultLP contract.\n\n```solidity\nfunction subtractLoss(uint256 loss) public onlyPerpVault {\n  require(\n    collateral.balanceOf(address(this)) == _totalCollateral - loss,\n    \"Not enough collateral was sent out\"\n  );\n  _totalCollateral -= loss;\n}\n```\n\n<https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L199-L205>\n\nSince there is no function that synchronizes `_totalCollateral` with `collateral.balanceOf(address(this))` without moving tokens, even admin cannot fix.\n\nThis is exploit PoC. Add this test case at `tests/perp-vault/Unit.t.sol`\n\n```solidity\nfunction testSettlePoC() public {\n  weth.mint(address(1), 1 ether);\n  weth.mint(address(777), 1 ether); // give some tokens to attacker\n\n  deposit(1 ether, address(1));\n\n  vault.purchase(1 ether, address(this));\n\n  uint256[] memory ids = new uint256[](1);\n  ids[0] = 0;\n\n  skip(86500); // expire\n\n  priceOracle.updateRdpxPrice(0.010 gwei); // ITM\n  uint256 wethBalanceBefore = weth.balanceOf(address(this));\n  uint256 rdpxBalanceBefore = rdpx.balanceOf(address(this));\n\n  // attack\n  vm.startPrank(address(777), address(777));\n  weth.transfer(address(vaultLp), 1); // send 1 wei of collateral\n  vm.stopPrank();\n\n  vm.expectRevert(\"Not enough collateral was sent out\");\n  vault.settle(ids);\n}\n```\n\n### Recommended Mitigation Steps\n\nUse `>=` instead of `==` at `PerpetualAtlanticVaultLP.subtractLoss`\n\n```diff\nfunction subtractLoss(uint256 loss) public onlyPerpVault {\n  require(\n-   collateral.balanceOf(address(this)) == _totalCollateral - loss,\n+   collateral.balanceOf(address(this)) >= _totalCollateral - loss,\n    \"Not enough collateral was sent out\"\n  );\n  _totalCollateral -= loss;\n}\n```\n\n**[psytama (Dopex) confirmed via duplicate issue 619](https://github.com/code-423n4/2023-08-dopex-findings/issues/619)**\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVaultLP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\n\n// Libraries\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\n\n/**\n * @title PerpetaulAtlanticVault LP Token\n */\ncontract PerpetualAtlanticVaultLP is ERC20, IPerpetualAtlanticVaultLP {\n  using SafeERC20 for IERC20WithBurn;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  // ================================ EVENTS ================================ //\n\n  event Deposit(\n    address indexed caller,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  // ================================ STATE VARIABLES ================================ //\n\n  /// @dev The address of the perpetual Atlantic Vault contract creating the lp token\n  IPerpetualAtlanticVault public perpetualAtlanticVault;\n\n  /// @dev The collateral token\n  ERC20 public collateral;\n\n  /// @dev The symbol reperesenting the underlying asset of the perpetualatlanticvault lp\n  string public underlyingSymbol;\n\n  /// @dev The symbol representing the collateral token of the perpetualatlanticvault lp\n  string public collateralSymbol;\n\n  /// @dev Total collateral available\n  uint256 private _totalCollateral;\n\n  /// @dev Active collateral\n  uint256 private _activeCollateral;\n\n  /// @dev Total rdpx available\n  uint256 private _rdpxCollateral;\n\n  /// @dev address of rdpx token\n  address public rdpx;\n\n  /// @dev address of the rdpx rdpxV2Core contract\n  address public rdpxRdpxV2Core;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /**\n   * @param _perpetualAtlanticVault The address of the perpetual atlantic vault contract creating the lp token\n   * @param _rdpxRdpxV2Core The address of the rdpx rdpxV2Core contract\n   * @param _collateral The address of the collateral asset in the perpetualatlanticvault contract\n   * @param _collateralSymbol The symbol of the collateral asset token\n   * @param _rdpx The address of the rdpx token\n   */\n  constructor(\n    address _perpetualAtlanticVault,\n    address _rdpxRdpxV2Core,\n    address _collateral,\n    address _rdpx,\n    string memory _collateralSymbol\n  )\n    ERC20(\n      \"PerpetualAtlanticVault LP Token\",\n      _collateralSymbol,\n      ERC20(_collateral).decimals()\n    )\n  {\n    require(\n      _perpetualAtlanticVault != address(0) || _rdpx != address(0),\n      \"ZERO_ADDRESS\"\n    );\n    perpetualAtlanticVault = IPerpetualAtlanticVault(_perpetualAtlanticVault);\n    rdpxRdpxV2Core = _rdpxRdpxV2Core;\n    collateralSymbol = _collateralSymbol;\n    rdpx = _rdpx;\n    collateral = ERC20(_collateral);\n\n    symbol = string.concat(_collateralSymbol, \"-LP\");\n\n    collateral.approve(_perpetualAtlanticVault, type(uint256).max);\n    ERC20(rdpx).approve(_perpetualAtlanticVault, type(uint256).max);\n  }\n\n  // ================================ PUBLIC FUNCTIONS ================================ //\n\n  /**\n   * @notice deposit into ERC4626 token\n   * @param assets assets\n   * @param receiver receiver\n   * @return shares shares of LP tokens minted\n   */\n  function deposit(\n    uint256 assets,\n    address receiver\n  ) public virtual returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    perpetualAtlanticVault.updateFunding();\n\n    // Need to transfer before minting or ERC777s could reenter.\n    collateral.transferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    _totalCollateral += assets;\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n  }\n\n  /**\n   * @notice redeem ERC4626 token\n   * @param shares shares\n   * @param receiver receiver\n   * @param owner owner\n   * @return assets native tokens to be received\n   * @return rdpxAmount rdpx tokens to be received\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public returns (uint256 assets, uint256 rdpxAmount) {\n    perpetualAtlanticVault.updateFunding();\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n    (assets, rdpxAmount) = redeemPreview(shares);\n\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    _rdpxCollateral -= rdpxAmount;\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    collateral.transfer(receiver, assets);\n\n    IERC20WithBurn(rdpx).safeTransfer(receiver, rdpxAmount);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n  }\n\n  // ================================ PERP VAULT FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function lockCollateral(uint256 amount) public onlyPerpVault {\n    _activeCollateral += amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function unlockLiquidity(uint256 amount) public onlyPerpVault {\n    _activeCollateral -= amount;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addProceeds(uint256 proceeds) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) >= _totalCollateral + proceeds,\n      \"Not enough collateral token was sent\"\n    );\n    _totalCollateral += proceeds;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function subtractLoss(uint256 loss) public onlyPerpVault {\n    require(\n      collateral.balanceOf(address(this)) == _totalCollateral - loss,\n      \"Not enough collateral was sent out\"\n    );\n    _totalCollateral -= loss;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVaultLP\n  function addRdpx(uint256 amount) public onlyPerpVault {\n    require(\n      IERC20WithBurn(rdpx).balanceOf(address(this)) >= _rdpxCollateral + amount,\n      \"Not enough rdpx token was sent\"\n    );\n    _rdpxCollateral += amount;\n  }\n\n  // ================================ INTERNAL FUNCTUONS ================================ //\n\n  function _convertToAssets(\n    uint256 shares\n  ) internal view virtual returns (uint256 assets, uint256 rdpxAmount) {\n    uint256 supply = totalSupply;\n    return\n      (supply == 0)\n        ? (shares, 0)\n        : (\n          shares.mulDivDown(totalCollateral(), supply),\n          shares.mulDivDown(_rdpxCollateral, supply)\n        );\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address,\n    uint256\n  ) internal virtual {}\n\n  // ================================ VIEWS ================================ //\n\n  /// @notice Returns the total active collateral\n  function activeCollateral() public view returns (uint256) {\n    return _activeCollateral;\n  }\n\n  /// @notice Returns the total collateral\n  function totalCollateral() public view returns (uint256) {\n    return _totalCollateral;\n  }\n\n  /// @notice Returns the total rdpx collateral\n  function rdpxCollateral() public view returns (uint256) {\n    return _rdpxCollateral;\n  }\n\n  /// @notice Returns the total available collateral\n  function totalAvailableCollateral() public view returns (uint256) {\n    return _totalCollateral - _activeCollateral;\n  }\n\n  // ================================ PUBLIC VIEW FUNCTIONS ================================ //\n\n  /// @notice Returns the amount of collateral and rdpx per share\n  function redeemPreview(\n    uint256 shares\n  ) public view returns (uint256, uint256) {\n    return _convertToAssets(shares);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function previewDeposit(uint256 assets) public view returns (uint256) {\n    return convertToShares(assets);\n  }\n\n  /// @notice Returns the amount of shares recieved for a given amount of assets\n  function convertToShares(\n    uint256 assets\n  ) public view returns (uint256 shares) {\n    uint256 supply = totalSupply;\n    uint256 rdpxPriceInAlphaToken = perpetualAtlanticVault.getUnderlyingPrice();\n\n    uint256 totalVaultCollateral = totalCollateral() +\n      ((_rdpxCollateral * rdpxPriceInAlphaToken) / 1e8);\n    return\n      supply == 0 ? assets : assets.mulDivDown(supply, totalVaultCollateral);\n  }\n\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal {\n    require(\n      assets <= totalAvailableCollateral(),\n      \"Not enough available assets to satisfy withdrawal\"\n    );\n    _totalCollateral -= assets;\n  }\n\n  // ================================ MODIFIERS ================================ //\n  modifier onlyPerpVault() {\n    require(\n      msg.sender == address(perpetualAtlanticVault),\n      \"Only the perp vault can call this function\"\n    );\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVault.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IOptionPricing } from \"../interfaces/IOptionPricing.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IVolatilityOracle } from \"../interfaces/IVolatilityOracle.sol\";\n\n/// @title Contract to offer perpetual atlantic rDPX PUT options to the rdpxV2Core contract\n/// @dev Option tokens are in erc20 18 decimals & Strikes are in 1e8 precision\ncontract PerpetualAtlanticVault is\n  IPerpetualAtlanticVault,\n  ReentrancyGuard,\n  Pausable,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  AccessControl,\n  ContractWhitelist\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  /// @dev Token ID counter for write positions\n  Counters.Counter private _tokenIdCounter;\n\n  /// @dev Manager role which handles bootstrapping\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n\n  /// @dev Rdpx v2 core role which can purchase and settle options\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  /// @dev Underlying assets symbol\n  string public underlyingSymbol;\n\n  /// @dev Contract addresses\n  Addresses public addresses;\n\n  /// @dev Collateral Token\n  IERC20WithBurn public collateralToken;\n\n  /// @dev The precision of the collateral token\n  uint256 public collateralPrecision;\n\n  /// @dev tokenId => OptionPosition\n  mapping(uint256 => OptionPosition) public optionPositions;\n\n  /// @dev number of options funding has been accounted for the epoch\n  mapping(uint256 => uint256) public fundingPaymentsAccountedFor;\n\n  /// @dev the funding accounted for the epoch and strike\n  mapping(uint256 => mapping(uint256 => uint256))\n    public fundingPaymentsAccountedForPerStrike;\n\n  /// @dev the total funding for the epoch\n  mapping(uint256 => uint256) public totalFundingForEpoch;\n\n  /// @dev amount of options per strike\n  mapping(uint256 => uint256) public optionsPerStrike;\n\n  /// @dev latest funding update per strike\n  mapping(uint256 => uint256) public latestFundingPerStrike;\n\n  // @dev Funding rate for the epoch\n  mapping(uint256 => uint256) public fundingRates;\n\n  /// @dev the pointer to the lattest funding payment timestamp\n  /// @notice Explain to an end user what this does\n  /// @dev Explain to a developer any extra details\n  /// @return Documents the return variables of a contractâ€™s function state variable\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  uint256 public latestFundingPaymentPointer = 0;\n\n  /// @dev the total number of active options\n  uint256 public totalActiveOptions;\n\n  /// @dev genesis timestamp\n  uint256 public genesis;\n\n  /// @dev the timestamp of the last update where funding was paid for\n  uint256 public lastUpdateTime;\n\n  /// @dev the duration between funding payments\n  uint256 public fundingDuration = 7 days;\n\n  /// @dev the precision to round up to\n  uint256 public roundingPrecision = 1e6;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /// @notice Contract constructor\n  /// @param _name ERC721 name\n  /// @param _symbol ERC721 symbol\n  /// @param _collateralToken Collateral token of the perpetual atlantic vault\n  /// @param _gensis Gensis time for funding calculation\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _collateralToken,\n    uint256 _gensis\n  ) ERC721(_name, _symbol) {\n    _validate(_collateralToken != address(0), 1);\n\n    collateralToken = IERC20WithBurn(_collateralToken);\n    underlyingSymbol = collateralToken.symbol();\n    collateralPrecision = 10 ** collateralToken.decimals();\n    genesis = _gensis;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Add a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be added to the whitelist\n   **/\n  function addToContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Remove a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be removed from the whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Sets (adds) a list of addresses to the address list\n   * @dev    Can only be called by the owner\n   * @param  _optionPricing Address of the option pricing contract\n   * @param  _assetPriceOracle Address of the asset price oracle contract\n   * @param  _volatilityOracle Address of the volatility oracle contract\n   * @param  _feeDistributor Address of the fee distributor contract\n   * @param  _rdpx Address of the rdpx contract\n   * @param  _perpetualAtlanticVaultLP Address of the perpetual atlantic vault lp contract\n   * @param  _rdpxV2Core Address of the rdpx v2 rdpxV2Core contract\n   **/\n  function setAddresses(\n    address _optionPricing,\n    address _assetPriceOracle,\n    address _volatilityOracle,\n    address _feeDistributor,\n    address _rdpx,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxV2Core\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_optionPricing != address(0), 1);\n    _validate(_assetPriceOracle != address(0), 1);\n    _validate(_volatilityOracle != address(0), 1);\n    _validate(_feeDistributor != address(0), 1);\n    _validate(_rdpx != address(0), 1);\n    _validate(_perpetualAtlanticVaultLP != address(0), 1);\n    _validate(_rdpxV2Core != address(0), 1);\n\n    addresses = Addresses({\n      optionPricing: _optionPricing,\n      assetPriceOracle: _assetPriceOracle,\n      volatilityOracle: _volatilityOracle,\n      feeDistributor: _feeDistributor,\n      rdpx: _rdpx,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxV2Core: _rdpxV2Core\n    });\n    collateralToken.safeApprove(\n      addresses.perpetualAtlanticVaultLP,\n      type(uint256).max\n    );\n    emit AddressesSet(addresses);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit EmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Updates the funding duration\n   * @dev    Can only be called by the owner\n   **/\n  function updateFundingDuration(\n    uint256 _fundingDuration\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    fundingDuration = _fundingDuration;\n  }\n\n  function setLpAllowance(bool increase) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    increase\n      ? collateralToken.approve(\n        addresses.perpetualAtlanticVaultLP,\n        type(uint256).max\n      )\n      : collateralToken.approve(addresses.perpetualAtlanticVaultLP, 0);\n  }\n\n  // ================================ TREASURY FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function purchase(\n    uint256 amount,\n    address to\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 premium, uint256 tokenId)\n  {\n    _whenNotPaused();\n    _validate(amount > 0, 2);\n\n    updateFunding();\n\n    uint256 currentPrice = getUnderlyingPrice(); // price of underlying wrt collateralToken\n    uint256 strike = roundUp(currentPrice - (currentPrice / 4)); // 25% below the current price\n    IPerpetualAtlanticVaultLP perpetualAtlanticVaultLp = IPerpetualAtlanticVaultLP(\n        addresses.perpetualAtlanticVaultLP\n      );\n\n    // Check if vault has enough collateral to write the options\n    uint256 requiredCollateral = (amount * strike) / 1e8;\n\n    _validate(\n      requiredCollateral <= perpetualAtlanticVaultLp.totalAvailableCollateral(),\n      3\n    );\n\n    uint256 timeToExpiry = nextFundingPaymentTimestamp() - block.timestamp;\n\n    // Get total premium for all options being purchased\n    premium = calculatePremium(strike, amount, timeToExpiry, 0);\n\n    // Transfer premium from msg.sender to PerpetualAtlantics vault\n    collateralToken.safeTransferFrom(msg.sender, address(this), premium);\n\n    perpetualAtlanticVaultLp.lockCollateral(requiredCollateral);\n    _updateFundingRate(premium);\n\n    // Mint the option tokens\n    tokenId = _mintOptionToken();\n    optionPositions[tokenId] = OptionPosition({\n      strike: strike,\n      amount: amount,\n      positionId: tokenId\n    });\n\n    totalActiveOptions += amount;\n    fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n    optionsPerStrike[strike] += amount;\n\n    // record the number of options funding has been accounted for the epoch and strike\n    fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n      strike\n    ] += amount;\n\n    emit Purchase(strike, amount, premium, to, msg.sender);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function settle(\n    uint256[] memory optionIds\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 ethAmount, uint256 rdpxAmount)\n  {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFunding();\n\n    for (uint256 i = 0; i < optionIds.length; i++) {\n      uint256 strike = optionPositions[optionIds[i]].strike;\n      uint256 amount = optionPositions[optionIds[i]].amount;\n\n      // check if strike is ITM\n      _validate(strike >= getUnderlyingPrice(), 7);\n\n      ethAmount += (amount * strike) / 1e8;\n      rdpxAmount += amount;\n      optionsPerStrike[strike] -= amount;\n      totalActiveOptions -= amount;\n\n      // Burn option tokens from user\n      _burn(optionIds[i]);\n\n      optionPositions[optionIds[i]].strike = 0;\n    }\n\n    // Transfer collateral token from perpetual vault to rdpx rdpxV2Core\n    collateralToken.safeTransferFrom(\n      addresses.perpetualAtlanticVaultLP,\n      addresses.rdpxV2Core,\n      ethAmount\n    );\n    // Transfer rdpx from rdpx rdpxV2Core to perpetual vault\n    IERC20WithBurn(addresses.rdpx).safeTransferFrom(\n      addresses.rdpxV2Core,\n      addresses.perpetualAtlanticVaultLP,\n      rdpxAmount\n    );\n\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).subtractLoss(\n      ethAmount\n    );\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP)\n      .unlockLiquidity(ethAmount);\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addRdpx(\n      rdpxAmount\n    );\n\n    emit Settle(ethAmount, rdpxAmount, optionIds);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function payFunding() external onlyRole(RDPXV2CORE_ROLE) returns (uint256) {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    _validate(\n      totalActiveOptions ==\n        fundingPaymentsAccountedFor[latestFundingPaymentPointer],\n      6\n    );\n\n    collateralToken.safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      totalFundingForEpoch[latestFundingPaymentPointer]\n    );\n    _updateFundingRate(totalFundingForEpoch[latestFundingPaymentPointer]);\n\n    emit PayFunding(\n      msg.sender,\n      totalFundingForEpoch[latestFundingPaymentPointer],\n      latestFundingPaymentPointer\n    );\n\n    return (totalFundingForEpoch[latestFundingPaymentPointer]);\n  }\n\n  // ================================ PUBLIC/EXTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Function to calculate the funding of options for the next epoch\n   * @param  strikes array of strikes to calculate the funding for\n   * @return fundingAmount the funding of options\n   **/\n  function calculateFunding(\n    uint256[] memory strikes\n  ) external nonReentrant returns (uint256 fundingAmount) {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFundingPaymentPointer();\n\n    for (uint256 i = 0; i < strikes.length; i++) {\n      _validate(optionsPerStrike[strikes[i]] > 0, 4);\n      _validate(\n        latestFundingPerStrike[strikes[i]] != latestFundingPaymentPointer,\n        5\n      );\n      uint256 strike = strikes[i];\n\n      uint256 amount = optionsPerStrike[strike] -\n        fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n          strike\n        ];\n\n      uint256 timeToExpiry = nextFundingPaymentTimestamp() -\n        (genesis + ((latestFundingPaymentPointer - 1) * fundingDuration));\n\n      uint256 premium = calculatePremium(\n        strike,\n        amount,\n        timeToExpiry,\n        getUnderlyingPrice()\n      );\n\n      latestFundingPerStrike[strike] = latestFundingPaymentPointer;\n      fundingAmount += premium;\n\n      // Record number of options that funding payments were accounted for, for this epoch\n      fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n\n      // record the number of options funding has been accounted for the epoch and strike\n      fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n        strike\n      ] += amount;\n\n      // Record total funding for this epoch\n      // This does not need to be done in purchase() since it's already accounted for using `addProceeds()`\n      totalFundingForEpoch[latestFundingPaymentPointer] += premium;\n\n      emit CalculateFunding(\n        msg.sender,\n        amount,\n        strike,\n        premium,\n        latestFundingPaymentPointer\n      );\n    }\n  }\n\n  /// @dev Helper function that updates the latest funding payment pointer based on current timestamp\n  function updateFundingPaymentPointer() public {\n    while (block.timestamp >= nextFundingPaymentTimestamp()) {\n      if (lastUpdateTime < nextFundingPaymentTimestamp()) {\n        uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n\n        uint256 startTime = lastUpdateTime == 0\n          ? (nextFundingPaymentTimestamp() - fundingDuration)\n          : lastUpdateTime;\n\n        lastUpdateTime = nextFundingPaymentTimestamp();\n\n        collateralToken.safeTransfer(\n          addresses.perpetualAtlanticVaultLP,\n          (currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n            1e18\n        );\n\n        IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP)\n          .addProceeds(\n            (currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n              1e18\n          );\n\n        emit FundingPaid(\n          msg.sender,\n          ((currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n            1e18),\n          latestFundingPaymentPointer\n        );\n      }\n\n      latestFundingPaymentPointer += 1;\n      emit FundingPaymentPointerUpdated(latestFundingPaymentPointer);\n    }\n  }\n\n  /**\n   * @notice function to transfer funding into the LP in a drip-vested manner\n   * @dev    addProceeds() is invoked to update totalCollateral in LP\n   **/\n  function updateFunding() public {\n    updateFundingPaymentPointer();\n    uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n    uint256 startTime = lastUpdateTime == 0\n      ? (nextFundingPaymentTimestamp() - fundingDuration)\n      : lastUpdateTime;\n    lastUpdateTime = block.timestamp;\n\n    collateralToken.safeTransfer(\n      addresses.perpetualAtlanticVaultLP,\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addProceeds(\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    emit FundingPaid(\n      msg.sender,\n      ((currentFundingRate * (block.timestamp - startTime)) / 1e18),\n      latestFundingPaymentPointer\n    );\n  }\n\n  // ================================ VIEWS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function getUnderlyingPrice() public view returns (uint256) {\n    return IRdpxEthOracle(addresses.assetPriceOracle).getRdpxPriceInEth();\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function getVolatility(uint256 _strike) public view returns (uint256) {\n    return IVolatilityOracle(addresses.volatilityOracle).getVolatility(_strike);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function calculatePremium(\n    uint256 _strike,\n    uint256 _amount,\n    uint256 timeToExpiry,\n    uint256 _price\n  ) public view returns (uint256 premium) {\n    premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n      _strike,\n      _price > 0 ? _price : getUnderlyingPrice(),\n      getVolatility(_strike),\n      timeToExpiry\n    ) * _amount) / 1e8);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function calculatePnl(\n    uint256 price,\n    uint256 strike,\n    uint256 amount\n  ) public pure returns (uint256) {\n    return strike > price ? ((strike - price) * amount) / 1e8 : 0;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function nextFundingPaymentTimestamp()\n    public\n    view\n    returns (uint256 timestamp)\n  {\n    return genesis + (latestFundingPaymentPointer * fundingDuration);\n  }\n\n  /**\n   * @dev Function to round up a value to the roundingPrecision.\n   * @param _strike the strike\n   * @return strike rounded up to the nearest roundingPrecision\n   **/\n  function roundUp(uint256 _strike) public view returns (uint256 strike) {\n    uint256 remainder = _strike % roundingPrecision;\n    if (remainder == 0) {\n      return _strike;\n    } else {\n      return _strike - remainder + roundingPrecision;\n    }\n  }\n\n  // ================================ PRIVATE/HELPER FUNCTIONS ================================ //\n\n  /// @dev Internal function to mint a option token\n  function _mintOptionToken() private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(addresses.rdpxV2Core, tokenId);\n  }\n\n  function _updateFundingRate(uint256 amount) private {\n    if (fundingRates[latestFundingPaymentPointer] == 0) {\n      uint256 startTime;\n      if (lastUpdateTime > nextFundingPaymentTimestamp() - fundingDuration) {\n        startTime = lastUpdateTime;\n      } else {\n        startTime = nextFundingPaymentTimestamp() - fundingDuration;\n      }\n      uint256 endTime = nextFundingPaymentTimestamp();\n      fundingRates[latestFundingPaymentPointer] =\n        (amount * 1e18) /\n        (endTime - startTime);\n    } else {\n      uint256 startTime = lastUpdateTime;\n      uint256 endTime = nextFundingPaymentTimestamp();\n      if (endTime == startTime) return;\n      fundingRates[latestFundingPaymentPointer] =\n        fundingRates[latestFundingPaymentPointer] +\n        ((amount * 1e18) / (endTime - startTime));\n    }\n  }\n\n  /**\n   * @dev    internal function to validate checks\n   * @param  _clause the boolean clause to validate\n   * @param  _errorCode error code for error mapping below\n   **/\n  function _validate(bool _clause, uint256 _errorCode) private pure {\n    if (!_clause) revert PerpetualAtlanticVaultError(_errorCode);\n  }\n\n  // ================================ ERRORS ================================ //\n\n  /**\n   * @dev  Custom Error used to validate checks within the contract's functions.\n   *       The uint256 error code corresponds to an error message.\n   **/\n  error PerpetualAtlanticVaultError(uint256);\n\n  // ================================ Solidity Required Overrides ================================ //\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}\n\n// ERROR CODES\n// E1: \"Zero address\",\n// E2: \"Amount must be greater than 0\",\n// E3: \"Insufficient collateral for purchase\",\n// E4: \"No options for strike\",\n// E5: \"Option strike already funded\",\n// E6: \"All funding payments must be accounted for\",\n// E7: \"Option is not ITM\""
    },
    {
      "filename": "contracts/core/RdpxV2Core.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Contracts\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { ERC721Holder } from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\nimport { RdpxV2Bond } from \"./RdpxV2Bond.sol\";\n\n// Interfaces\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IUniswapV2Router } from \"../uniswap_V2/IUniswapV2Router.sol\";\nimport { IStableSwap } from \"../interfaces/IStableSwap.sol\";\nimport { IRdpxDecayingBonds } from \"../decaying-bonds/IRdpxDecayingBonds.sol\";\nimport { IDpxEthToken } from \"../dpxETH/IDpxEthToken.sol\";\nimport { IPerpetualAtlanticVault } from \"../perp-vault/IPerpetualAtlanticVault.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IDpxEthOracle } from \"../oracles/IDpxEthOracle.sol\";\nimport { IRdpxReserve } from \"../reserve/IRdpxReserve.sol\";\nimport { IRdpxV2Core } from \"./IRdpxV2Core.sol\";\nimport { IRdpxV2ReceiptToken } from \"../interfaces/IRdpxV2ReceiptToken.sol\";\nimport { IReLP } from \"../interfaces/IReLP.sol\";\n\n// Libraries\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title Rdpx V2 Core contract\n/// @author Dopex\n/// @notice The Rdpx V2 Corecontracts handles the bonding mechanism and peg of DpxEth\ncontract RdpxV2Core is\n  IRdpxV2Core,\n  AccessControl,\n  ContractWhitelist,\n  ERC721Holder,\n  Pausable\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20Wi"
    }
  ]
}