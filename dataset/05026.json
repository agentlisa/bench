{
  "Title": "[M-01] Limited availability of `balance_of(...)` method",
  "Content": "\nAccording to the documentation ([online](https://docs.rs/pink/latest/pink/chain_extension/trait.PinkExtBackend.html#tymethod.balance_of) and [in-line](https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/pink/src/chain_extension.rs#L503-L516)), the *availability* of the [balance_of(...)](https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/runtime/extension.rs#L266-L275) method (see code below) should be **any contract** instead of **system only** which is caused by the present `ensure_system` check.\n\n```rust\nfn balance_of(\n    &self,\n    account: ext::AccountId,\n) -> Result<(pink::Balance, pink::Balance), Self::Error> {\n    self.ensure_system()?;    // @audit Availability should be 'any contract' instead of 'system only'\n    let account: AccountId32 = account.convert_to();\n    let total = crate::runtime::Balances::total_balance(&account);\n    let free = crate::runtime::Balances::free_balance(&account);\n    Ok((total, free))\n}\n```\n\nThe [ensure_system(...)](https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/runtime/extension.rs#L145-L151) method returns a `BadOrigin` error in case the caller/origin is not the system contract.\n\n```rust\nfn ensure_system(&self) -> Result<(), DispatchError> {\n    let contract: AccountId32 = self.address.convert_to();\n    if Some(contract) != PalletPink::system_contract() {\n        return Err(DispatchError::BadOrigin);\n    }\n    Ok(())\n}\n```\n\n### Consequence\n\nThe availability of the [balance_of(...)](https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/runtime/extension.rs#L266-L275) method is limited to the system contract instead of being accessible to anyone. Therefore, user contracts relying on this method will inevitably fail.\n\n*For comparison:*\n\nThe `import_latest_system_code(...)` method has consistent *system only* availability according to the [implementation](https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/runtime/extension.rs#L295-L314) and [documentation](https://docs.rs/pink/latest/pink/chain_extension/trait.PinkExtBackend.html#tymethod.import_latest_system_code).\n\n### Proof of Concept\n\nPlease add the test case below to  `phala-blockchain/crates/pink/runtime/tests/test_pink_contract.rs` and run it with `cargo test test_balance_of -- --nocapture`.\n\n```rust\n#[test]\nfn test_balance_of() {\n    const TEST_ADDRESS: AccountId32 = AccountId32::new([255u8; 32]);\n\n    let (mut cluster, checker) = create_cluster();\n\n    let balance = 114514;\n\n    cluster.tx().deposit(TEST_ADDRESS.clone(), balance);\n\n    let result = checker\n        .call()\n        .direct_balance_of(TEST_ADDRESS.convert_to())\n        .query(&mut cluster);\n    assert_eq!(result.unwrap(), (balance, balance));\n}\n```\n\nThe test will fail with a **BadOrigin** error as discussed above:\n\n    called `Result::unwrap()` on an `Err` value: Failed to execute call: BadOrigin\n\n### Recommended Mitigation Steps\n\nRemove the `ensure_system` check from the [balance_of(...)](https://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/runtime/extension.rs#L266-L275) method to ensure availability for **any contract**.\n\n### Assessed type\n\nInvalid Validation\n\n**[kvinwang (Phala) confirmed](https://github.com/code-423n4/2024-03-phala-network-findings/issues/50#issuecomment-2019469089)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-phala-network",
  "Code": [
    {
      "filename": "phala-blockchain/crates/pink/pink/src/chain_extension.rs",
      "content": "use alloc::borrow::Cow;\nuse alloc::string::String;\nuse alloc::vec::Vec;\nuse ink::ChainExtensionInstance;\nuse pink_types::sgx::SgxQuote;\n\npub use http_request::{HttpRequest, HttpRequestError, HttpResponse};\npub use ink::primitives::AccountId;\npub use signing::SigType;\n\nuse crate::{Balance, EcdsaPublicKey, EcdsaSignature, Hash};\npub use pink_types::js::{JsCode, JsValue};\npub use pink_types::result::Result as PinkExtResult;\n\n#[cfg(doc)]\nuse crate::{debug, error, http_get, http_post, http_put, info, warn};\n\nmod http_request;\npub mod signing;\n\n#[cfg(feature = \"std\")]\npub mod test;\n\n#[derive(scale::Encode, scale::Decode, Debug)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct StorageQuotaExceeded;\n\nmod sealed {\n    pub trait Sealed {}\n}\npub trait CodableError: sealed::Sealed {\n    fn encode(&self) -> u32;\n    fn decode(code: u32) -> Option<Self>\n    where\n        Self: Sized;\n}\n\nmacro_rules! impl_codable_error_for {\n    ($t: path) => {\n        impl sealed::Sealed for $t {}\n        impl CodableError for $t {\n            fn encode(&self) -> u32 {\n                1\n            }\n\n            fn decode(code: u32) -> Option<Self> {\n                if code == 1 {\n                    Some(Self)\n                } else {\n                    None\n                }\n            }\n        }\n\n        impl From<ErrorCode> for $t {\n            fn from(value: ErrorCode) -> Self {\n                match <Self as CodableError>::decode(value.0) {\n                    None => crate::panic!(\"chain extension: invalid output\"),\n                    Some(err) => err,\n                }\n            }\n        }\n\n        impl From<scale::Error> for $t {\n            fn from(_value: scale::Error) -> Self {\n                crate::panic!(\"chain_ext: failed to decocde output\")\n            }\n        }\n    };\n}\nimpl_codable_error_for!(StorageQuotaExceeded);\n\npub struct EncodeOutput<T>(pub T);\n\npub trait EncodeOutputFallback {\n    fn encode(self) -> (u32, Vec<u8>);\n}\n\nimpl<T: scale::Encode, E: CodableError> EncodeOutput<Result<T, E>> {\n    pub fn encode(self) -> (u32, Vec<u8>) {\n        match self.0 {\n            Ok(val) => (0, val.encode()),\n            Err(err) => (err.encode(), Vec::new()),\n        }\n    }\n}\n\nimpl<T: scale::Encode> EncodeOutputFallback for EncodeOutput<T> {\n    fn encode(self) -> (u32, Vec<u8>) {\n        (0, self.0.encode())\n    }\n}\n\n#[derive(scale::Encode, scale::Decode, Debug)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct ErrorCode(u32);\n\nimpl ink::env::chain_extension::FromStatusCode for ErrorCode {\n    fn from_status_code(status_code: u32) -> Result<(), Self> {\n        match status_code {\n            0 => Ok(()),\n            _ => Err(ErrorCode(status_code)),\n        }\n    }\n}\n\npub type BatchHttpResult = Result<Vec<Result<HttpResponse, HttpRequestError>>, HttpRequestError>;\n\n/// Extensions for the ink runtime defined by phat contract.\n#[pink_macro::chain_extension]\npub trait PinkExt {\n    type ErrorCode = ErrorCode;\n\n    /// Make a HTTP request.\n    ///\n    /// # Arguments\n    ///\n    /// * `request`: A `HttpRequest` struct containing all the details for the HTTP request.\n    ///\n    /// # Returns\n    ///\n    /// * `HttpResponse` - The response from the HTTP request which contains the status code, headers, and body.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let request = HttpRequest::new(\"https://httpbin.org/get\", \"GET\", Defualt::default(), Defualt::default());\n    /// let response = pink::ext().http_request(request);\n    /// ```\n    ///\n    /// There are also some shortcut macros for this function:\n    /// - [`http_get!`]\n    /// - [`http_post!`]\n    /// - [`http_put!`]\n    ///\n    /// # Availability\n    /// any contract | query only\n    #[ink(extension = 1, handle_status = false)]\n    fn http_request(request: HttpRequest) -> HttpResponse;\n\n    /// Sign a message with a given key.\n    ///\n    /// # Arguments\n    ///\n    /// * `sigtype`: The signature type to use for signing the message.\n    /// * `key`: The private key used for signing the message.\n    /// * `message`: The message to be signed.\n    ///\n    /// # Returns\n    ///\n    /// * `Vec<u8>` - The signed message as a byte vector.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let derived_key = pink::ext().derive_sr25519_key(b\"some salt\".into());\n    /// let message = b\"Hello, world!\";\n    /// let signature = pink::ext().sign(SigType::Sr25519, &key, message);\n    /// let pubkey = pink::ext().get_public_key(SigType::Sr25519, &derived_key);\n    /// let is_valid = pink::ext().verify(SigType::Sr25519, &pubkey, message, &signature);\n    /// ```\n    ///\n    /// # Availability\n    /// For SigType::Sr25519:\n    ///     any contract | query only\n    ///\n    /// For Others:\n    ///     any contract | query | transaction\n    #[ink(extension = 2, handle_status = false)]\n    fn sign(sigtype: SigType, key: &[u8], message: &[u8]) -> Vec<u8>;\n\n    /// Verify a signature.\n    ///\n    /// This method verifies a digital signature given the signature type, public key, message, and signature.\n    ///\n    /// # Arguments\n    ///\n    /// * `sigtype`: The type of signature to verify.\n    /// * `pubkey`: The public key associated with the private key that signed the message.\n    /// * `message`: The original message that was signed.\n    /// * `signature`: The digital signature to verify.\n    ///\n    /// # Returns\n    ///\n    /// * `bool` - `true` if the signature is valid, `false` otherwise.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let derived_key = pink::ext().derive_sr25519_key(b\"some salt\".into());\n    /// let message = b\"Hello, world!\";\n    /// let signature = pink::ext().sign(SigType::Sr25519, &key, message);\n    /// let pubkey = pink::ext().get_public_key(SigType::Sr25519, &derived_key);\n    /// let is_valid = pink::ext().verify(SigType::Sr25519, &pubkey, message, &signature);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 3, handle_status = false)]\n    fn verify(sigtype: SigType, pubkey: &[u8], message: &[u8], signature: &[u8]) -> bool;\n\n    /// Derive a sr25519 key.\n    ///\n    /// This method derives a sr25519 key using the provided salt and the contract private key.\n    /// The derived key is deterministic so it could be used in transactions to sign messages.\n    ///\n    /// The derived key can also be used as a cryptographically secure entropy source.\n    ///\n    /// # Arguments\n    ///\n    /// * `salt`: The salt to use in the key derivation function.\n    ///\n    /// # Returns\n    ///\n    /// * `Vec<u8>` - The derived sr25519 key as a byte vector.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let derived_key = pink::ext().derive_sr25519_key(b\"some salt\".into());\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 4, handle_status = false)]\n    fn derive_sr25519_key(salt: Cow<[u8]>) -> Vec<u8>;\n\n    /// Derive the public key from a private key.\n    ///\n    /// This method takes a signature type and private key and returns the associated public key.\n    ///\n    /// # Arguments\n    ///\n    /// * `sigtype`: The type of signature to generate the public key for.\n    /// * `key`: The private key used to generate the public key.\n    ///\n    /// # Returns\n    ///\n    /// * `Vec<u8>` - The public key associated with the given private key as a byte vector.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let derived_key = pink::ext().derive_sr25519_key(b\"some salt\".into());\n    /// let pubkey = pink::ext().get_public_key(SigType::Sr25519, &derived_key);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 5, handle_status = false)]\n    fn get_public_key(sigtype: SigType, key: &[u8]) -> Vec<u8>;\n\n    /// Set a value in the local cache.\n    ///\n    /// This method sets a value in the local cache with the default expiration time of 7 days.\n    /// To set a custom expiration time, use `cache_set_expiration`.\n    /// Values stored in cache can only be read in query functions.\n    /// Always returns `Ok(())` if it is called from a transaction context.\n    ///\n    /// # Arguments\n    ///\n    /// * `key`: The key used to identify the value in the cache.\n    /// * `value`: The value to be stored in the cache.\n    ///\n    /// # Returns\n    ///\n    /// * `Result<(), StorageQuotaExceeded>` - `Ok(())` or `Err(StorageQuotaExceeded)` if the storage quota is exceeded.\n    ///\n    /// <p style=\"background:rgba(255,181,77,0.16);padding:0.75em;\">\n    /// <strong>Warning:</strong>\n    /// The cache is not guaranteed to be persistent. It may be cleared at any time due\n    ///     to various reasons:\n    ///\n    /// - The cached item is expired.\n    /// - The entire cache in pRuntime is full and a new value needs to be stored (either from the contract itself or\n    ///   other contracts).\n    /// - The worker is restarted.\n    /// </p>\n    ///\n    /// In order to use cache, the contract need to be staked via the phala on-chain API `PhatTokenomic::adjust_stake`.\n    /// All contracts will share the 20MB cache storage by the ratio of stake.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let key = b\"my key\";\n    /// let value = b\"my value\";\n    /// let result = pink::ext().cache_set(key, value);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 6, handle_status = true)]\n    fn cache_set(key: &[u8], value: &[u8]) -> Result<(), StorageQuotaExceeded>;\n\n    /// Set the expiration time of a value in the local cache.\n    ///\n    /// This method sets the expiration time for a given key in the local cache.\n    ///\n    /// # Arguments\n    ///\n    /// * `key`: The key of the value to set the expiration time for.\n    /// * `expire`: The expiration time from now in seconds.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let key = b\"my key\";\n    /// let expire = 60; // 1 minute\n    /// pink::ext().cache_set_expiration(key, expire);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 7, handle_status = false)]\n    fn cache_set_expiration(key: &[u8], expire: u64);\n\n    /// Get a value from the local cache.\n    ///\n    /// This method retrieves a value from the local cache. It can only be used in query functions.\n    /// If called from a transaction context, it will always return `None`.\n    ///\n    /// # Arguments\n    ///\n    /// * `key`: The key used to identify the value in the cache.\n    ///\n    /// # Returns\n    ///\n    /// * `Option<Vec<u8>>` - The value from the cache as a byte vector wrapped in an Option,\n    ///     or `None` if the value does not exist or called in transaction.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let key = b\"my key\";\n    /// let value = pink::ext().cache_get(key);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query\n    #[ink(extension = 8, handle_status = false)]\n    fn cache_get(key: &[u8]) -> Option<Vec<u8>>;\n\n    /// Remove a value from the local cache.\n    ///\n    /// This method removes a value from the local cache and returns the removed value if it existed.\n    /// If called from a transaction context, it will always return `None`.\n    ///\n    /// # Arguments\n    ///\n    /// * `args`: The key used to identify the value in the cache.\n    ///\n    /// # Returns\n    ///\n    /// * `Option<Vec<u8>>` - The removed value as a byte vector wrapped in an Option\n    ///     or `None` if the value did not exist or called in transaction.\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 9, handle_status = false)]\n    fn cache_remove(args: &[u8]) -> Option<Vec<u8>>;\n\n    /// Log a message.\n    ///\n    /// This method logs a message at a given level.\n    ///\n    /// The logs would be shown in the worker log file. Additionally, if a log server\n    /// contract has been deployed in the cluster, the logs would be sent to the log server.\n    /// Users can query the logs via the log server API.\n    ///\n    /// # Arguments\n    ///\n    /// * `level`: The level of the log message.\n    /// * `message`: The message to be logged.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let level = 1;\n    /// let message = \"Hello, world!\";\n    /// pink::ext().log(level, message);\n    /// ```\n    ///\n    /// # Note\n    /// This is the low-level method for logging. It is recommended to use shortcuts macros below instead:\n    ///\n    /// - [`debug!`]\n    /// - [`info!`]\n    /// - [`warn!`]\n    /// - [`error!`]\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 10, handle_status = false)]\n    fn log(level: u8, message: &str);\n\n    /// Get random bytes.\n    ///\n    /// This method generates a vector of random bytes of a given length. It returns random bytes\n    /// generated by hardware RNG. So it is not deterministic and only available in a query context.\n    ///\n    /// # Note\n    /// It always returns an empty vec![] when called in a transaction.\n    ///\n    ///\n    /// # Arguments\n    ///\n    /// * `length`: The length of the random bytes vector.\n    ///\n    /// # Returns\n    ///\n    /// * `Vec<u8>` - A vector of random bytes of the given length.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let length = 32;\n    /// let random_bytes = pink::ext().getrandom(length);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query only\n    #[ink(extension = 11, handle_status = false)]\n    fn getrandom(length: u8) -> Vec<u8>;\n\n    /// Check if it is running in a transaction context.\n    ///\n    /// # Returns\n    ///\n    /// * `bool` - `true` if it is running in a transaction context, `false` if in query.\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[allow(clippy::wrong_self_convention)]\n    #[ink(extension = 12, handle_status = false)]\n    fn is_in_transaction() -> bool;\n\n    /// Sign a prehashed message with a given key.\n    ///\n    /// This method uses the given key and prehashed message to create a ECDSA signature.\n    ///\n    /// # Arguments\n    ///\n    /// * `key`: The private key used for signing the message.\n    /// * `message_hash`: The prehashed message to be signed.\n    ///\n    /// # Returns\n    ///\n    /// * `EcdsaSignature` - The signature of the message.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let key = [0u8; 32]; // replace with actual key\n    /// let message_hash = Hash::zero(); // replace with actual hash\n    /// let signature = pink::ext().ecdsa_sign_prehashed(&key, message_hash);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 13, handle_status = false)]\n    fn ecdsa_sign_prehashed(key: &[u8], message_hash: Hash) -> EcdsaSignature;\n\n    /// Verify a prehashed ECDSA signature.\n    ///\n    /// This method verifies a prehashed ECDSA signature given the signature, prehashed message, and public key.\n    ///\n    /// # Arguments\n    ///\n    /// * `signature`: The ECDSA digital signature to verify.\n    /// * `message_hash`: The prehashed original message that was signed.\n    /// * `pubkey`: The public key associated with the private key that signed the message.\n    ///\n    /// # Returns\n    ///\n    /// * `bool` - `true` if the signature is valid, `false` otherwise.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let signature = EcdsaSignature::default(); // replace with actual signature\n    /// let message_hash = Hash::zero(); // replace with actual hash\n    /// let pubkey = EcdsaPublicKey::default(); // replace with actual pubkey\n    /// let is_valid = pink::ext().ecdsa_verify_prehashed(signature, message_hash, pubkey);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 14, handle_status = false)]\n    fn ecdsa_verify_prehashed(\n        signature: EcdsaSignature,\n        message_hash: Hash,\n        pubkey: EcdsaPublicKey,\n    ) -> bool;\n\n    /// Get the contract id of the preinstalled system contract.\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 15, handle_status = false)]\n    fn system_contract_id() -> AccountId;\n\n    /// Get balance of a given address.\n    ///\n    /// # Arguments\n    ///\n    /// * `account`: The `AccountId` of the contract.\n    ///\n    /// # Returns\n    ///\n    /// * `(Balance, Balance)` - The total and free balance of a given contract.\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 16, handle_status = false)]\n    fn balance_of(account: AccountId) -> (Balance, Balance);\n\n    /// Get the public key of the worker running this query.\n    ///\n    /// # Returns\n    ///\n    /// * `crate::EcdhPublicKey` - The public key of the worker.\n    ///\n    /// # Availability\n    /// any contract | query only\n    #[ink(extension = 17, handle_status = false)]\n    fn worker_pubkey() -> crate::EcdhPublicKey;\n\n    /// Get current millis since Unix epoch.\n    ///\n    /// This method returns the current time as milliseconds since the Unix epoch from the OS.\n    ///\n    /// # Returns\n    ///\n    /// * `u64` - The current time as milliseconds since the Unix epoch from the OS.\n    ///\n    /// # Note\n    /// Because this method uses the OS time, it is not deterministic and may be manipulated by compromised OS.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let current_millis = pink::ext().untrusted_millis_since_unix_epoch();\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query only\n    #[ink(extension = 18, handle_status = false)]\n    fn untrusted_millis_since_unix_epoch() -> u64;\n\n    /// Check whether the code exists in the cluster storage.\n    ///\n    /// # Returns\n    ///\n    /// * `bool` - `true` if the code exists, `false` otherwise.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let code_hash = Hash::zero(); // replace with actual code hash\n    /// let exists = pink::ext().code_exists(code_hash, false);\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 19, handle_status = false)]\n    fn code_exists(code_hash: Hash, sidevm: bool) -> bool;\n\n    /// Import the latest system contract code from chain storage to the cluster storage.\n    ///\n    /// # Returns\n    ///\n    /// * `Option<Hash>` - The code hash of the latest system contract code, or `None` if the import failed.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let payer = AccountId::default(); // replace with actual payer id\n    /// let code_hash = pink::ext().import_latest_system_code(payer);\n    /// ```\n    ///\n    /// # Availability\n    /// system only | query | transaction\n    #[ink(extension = 20, handle_status = false)]\n    fn import_latest_system_code(payer: AccountId) -> Option<Hash>;\n\n    /// Get the version of the current contract runtime.\n    ///\n    /// # Returns\n    ///\n    /// * `(u32, u32)` - The version of the current contract runtime in this cluster as a tuple (major, minor).\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let (major, minor) = pink::ext().runtime_version();\n    /// ```\n    ///\n    /// # Availability\n    /// any contract | query | transaction\n    #[ink(extension = 21, handle_status = false)]\n    fn runtime_version() -> (u32, u32);\n\n    /// Batch HTTP request.\n    ///\n    /// This method sends a batch of HTTP requests with a given timeout and returns the results.\n    ///\n    /// # Arguments\n    ///\n    /// * `requests`: A vector of `HttpRequest` structs containing all the details for the HTTP requests.\n    /// * `timeout_ms`: The timeout for the batch request in milliseconds.\n    ///\n    /// # Returns\n    ///\n    /// * `BatchHttpResult` - A vector of response to eahch HTTP requests.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let requests = vec![\n    ///     HttpRequest::new(\"https://httpbin.org/get\",\n    ///         \"GET\",\n    ///         Default::default(),\n    ///         Default::default(),\n    ///     ),\n    ///     HttpRequest::new(\"https://httpbin.org/post\",\n    ///         \"POST\",\n    ///         Default::default(),\n    ///         b\"Hello, world!\".to_vec(),\n    ///     ),\n    /// ];\n    /// let result = pink::ext().batch_http_request(requests, 5000);\n    ///\n    /// # Runtime version\n    /// 1.1\n    /// ```\n    #[ink(extension = 22, handle_status = true)]\n    fn batch_http_request(requests: Vec<HttpRequest>, timeout_ms: u64) -> BatchHttpResult;\n\n    /// Get current event chain head info\n    ///\n    /// Returns (next event block number, last event block hash)\n    ///\n    /// # Runtime version\n    /// 1.1\n    #[ink(extension = 23, handle_status = false)]\n    fn current_event_chain_head() -> (u64, Hash);\n\n    /// Execute JavaScript code using SideVM through the JsRuntime driver.\n    ///\n    /// # Arguments\n    ///\n    /// * `codes`: Vector of `JsCode` representing JavaScript code to be evaluated.\n    /// * `args`: Vector of `String`, passed into the script as `scriptArgs`.\n    ///\n    /// # Returns\n    ///\n    /// * `JsValue`: Result of the JavaScript expression evaluation.\n    ///\n    /// # Notes\n    /// The underlying JavaScript engine is an extended version of QuickJS, compiled to WebAssembly\n    /// and running inside SideVM. This environment has several limitations compared to more\n    /// traditional JavaScript engines like those in browsers or Node.js. For details on JavaScript\n    /// language features supported, refer to the [official QuickJS documentation](https://bellard.org/quickjs/).\n    ///\n    /// In terms of library features, some basic asynchronous I/O APIs are added to QuickJS, including:\n    /// - [setTimeout/setInterval](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout)\n    /// - [Streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API)\n    /// - [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL)\n    /// - [TextEncoder/Decoder](https://developer.mozilla.org/zh-CN/docs/Web/API/TextEncoder) -\n    ///   Note that this implementation is incomplete. It only supports utf8 encoding/decoding.\n    ///   Additional polyfills may be necessary for other requirements.\n    /// - [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)\n    /// - [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)\n    ///\n    /// # Returning Values from JavaScript to Rust\n    /// There are two methods to return values from JavaScript to Rust:\n    /// - Last Expression Value: By default, the value of the last JavaScript code\n    ///   expression is returned to Rust. However, this can be problematic in asynchronous code.\n    /// - `globalThis.scriptOutput`: If a value is assigned to `globalThis.scriptOutput` within the\n    ///   script, it will be returned to Rust, taking precedence over the last expression's value.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// // Return value via the last expression.\n    /// let js_code = \"console.log('Hello, world!'); scriptArgs[0];\"\n    /// let result = pink::ext().js_eval(vec![js_code.into()], vec![\"bar\".into()]);\n    /// assert_eq!(result, Ok(JsValue::String(\"bar\".to_string())));\n    ///\n    /// // Return value by setting scriptOutput.\n    /// let js_code = r#\"\n    ///     setTimeout(function() {\n    ///         scriptOutput = scriptArgs[0];\n    ///     }, 1000);\n    /// \"#;\n    /// let result = pink::ext().js_eval(vec![js_code.into()], vec![\"bar\".into()]);\n    /// assert_eq!(result, Ok(JsValue::String(\"bar\".to_string())));\n    /// ```\n    ///\n    /// # Runtime version\n    /// 1.2\n    #[ink(extension = 24, handle_status = false)]\n    fn js_eval(codes: Vec<JsCode>, args: Vec<String>) -> JsValue;\n\n    /// Get the SGX quote of the worker running this query.\n    ///\n    /// # Availability\n    /// any contract | query only\n    ///\n    /// # Runtime version\n    /// 1.2\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// use pink::types::sgx::SgxQuote;\n    /// let SgxQuote { attestation_type, quote } = pink::ext().worker_sgx_quote().unwrap();\n    /// ```\n    #[ink(extension = 25, handle_status = false)]\n    fn worker_sgx_quote() -> Option<SgxQuote>;\n}\n\npub fn pink_extension_instance() -> <PinkExt as ChainExtensionInstance>::Instance {\n    <PinkExt as ChainExtensionInstance>::instantiate()\n}"
    },
    {
      "filename": "phala-blockchain/crates/pink/runtime/src/runtime/extension.rs",
      "content": "use std::borrow::Cow;\n\nuse frame_support::traits::Currency;\nuse log::error;\nuse pallet_contracts::chain_extension::{\n    ChainExtension, Environment, Ext, InitState, Result as ExtResult, RetVal,\n};\nuse phala_crypto::sr25519::{Persistence, KDF};\nuse phala_types::contract::ConvertTo;\nuse pink::{\n    chain_extension::{\n        self as ext, HttpRequest, HttpResponse, JsCode, JsValue, PinkExtBackend, SigType,\n        StorageQuotaExceeded,\n    },\n    dispatch_ext_call,\n    types::sgx::SgxQuote,\n    CacheOp, EcdhPublicKey, EcdsaPublicKey, EcdsaSignature, Hash, PinkEvent,\n};\nuse pink_chain_extension::{DefaultPinkExtension, PinkRuntimeEnv};\nuse scale::{Decode, Encode};\nuse sp_runtime::{AccountId32, DispatchError};\n\nuse crate::{capi::OCallImpl, types::AccountId};\n\nuse pink_capi::{types::ExecSideEffects, v1::ocall::OCallsRo};\n\nuse super::{pallet_pink, PinkRuntime, SystemEvents};\nuse crate::runtime::Pink as PalletPink;\ntype Error = pallet_pink::Error<PinkRuntime>;\n\nfn deposit_pink_event(contract: AccountId, event: PinkEvent) {\n    let topics = [pink::PinkEvent::event_topic().into()];\n    let event = super::RuntimeEvent::Contracts(pallet_contracts::Event::ContractEmitted {\n        contract,\n        data: event.encode(),\n    });\n    super::System::deposit_event_indexed(&topics[..], event);\n}\n\npub fn get_side_effects() -> (SystemEvents, ExecSideEffects) {\n    let mut pink_events = Vec::default();\n    let mut ink_events = Vec::default();\n    let mut instantiated = Vec::default();\n    let mut system_events = vec![];\n    for event in super::System::events() {\n        let mut is_private_event = false;\n        if let super::RuntimeEvent::Contracts(ink_event) = &event.event {\n            use pallet_contracts::Event as ContractEvent;\n            match ink_event {\n                ContractEvent::Instantiated {\n                    deployer,\n                    contract: address,\n                } => instantiated.push((deployer.clone(), address.clone())),\n                ContractEvent::ContractEmitted {\n                    contract: address,\n                    data,\n                } => {\n                    if event.topics.len() == 1\n                        && event.topics[0].0 == pink::PinkEvent::event_topic()\n                    {\n                        match pink::PinkEvent::decode(&mut &data[..]) {\n                            Ok(event) => {\n                                pink_events.push((address.clone(), event.clone()));\n                                is_private_event = event.is_private();\n                            }\n                            Err(_) => {\n                                error!(\"Contract emitted an invalid pink event\");\n                            }\n                        }\n                    } else {\n                        ink_events.push((address.clone(), event.topics.clone(), data.clone()));\n                    }\n                }\n                _ => (),\n            }\n        }\n        if !is_private_event {\n            system_events.push(event);\n        }\n    }\n    (\n        system_events,\n        ExecSideEffects::V1 {\n            pink_events,\n            ink_events,\n            instantiated,\n        },\n    )\n}\n\n/// Contract extension for `pink contracts`\n#[derive(Default)]\npub struct PinkExtension;\n\nimpl ChainExtension<PinkRuntime> for PinkExtension {\n    fn call<E: Ext<T = PinkRuntime>>(\n        &mut self,\n        env: Environment<E, InitState>,\n    ) -> ExtResult<RetVal> {\n        let mut env = env.buf_in_buf_out();\n        if env.ext_id() != 0 {\n            error!(target: \"pink\", \"Unknown extension id: {:}\", env.ext_id());\n            return Err(Error::UnknownChainExtensionId.into());\n        }\n\n        let address = env.ext().address().clone();\n        let call_in_query = CallInQuery { address };\n        let mode = OCallImpl.exec_context().mode;\n        let (ret, output) = if mode.is_query() {\n            dispatch_ext_call!(env.func_id(), call_in_query, env)\n        } else {\n            let call = CallInCommand {\n                as_in_query: call_in_query,\n            };\n            dispatch_ext_call!(env.func_id(), call, env)\n        }\n        .ok_or(Error::UnknownChainExtensionFunction)\n        .map_err(|err| {\n            error!(target: \"pink\", \"Called an unregistered `func_id`: {:}\", env.func_id());\n            err\n        })?;\n        env.write(&output, false, None)\n            .or(Err(Error::ContractIoBufferOverflow))?;\n        Ok(RetVal::Converging(ret))\n    }\n\n    fn enabled() -> bool {\n        true\n    }\n}\n\nstruct CallInQuery {\n    address: AccountId,\n}\n\nimpl PinkRuntimeEnv for CallInQuery {\n    type AccountId = AccountId;\n\n    fn address(&self) -> &Self::AccountId {\n        &self.address\n    }\n}\n\nimpl CallInQuery {\n    fn ensure_system(&self) -> Result<(), DispatchError> {\n        let contract: AccountId32 = self.address.convert_to();\n        if Some(contract) != PalletPink::system_contract() {\n            return Err(DispatchError::BadOrigin);\n        }\n        Ok(())\n    }\n    fn address_bytes(&self) -> Vec<u8> {\n        let slice: &[u8] = self.address.as_ref();\n        slice.to_vec()\n    }\n}\n\nimpl PinkExtBackend for CallInQuery {\n    type Error = DispatchError;\n    fn http_request(&self, request: HttpRequest) -> Result<HttpResponse, Self::Error> {\n        OCallImpl\n            .http_request(self.address.clone(), request)\n            .map_err(|err| DispatchError::Other(err.display()))\n    }\n\n    fn batch_http_request(\n        &self,\n        requests: Vec<ext::HttpRequest>,\n        timeout_ms: u64,\n    ) -> Result<ext::BatchHttpResult, Self::Error> {\n        Ok(OCallImpl.batch_http_request(self.address.clone(), requests, timeout_ms))\n    }\n\n    fn sign(\n        &self,\n        sigtype: SigType,\n        key: Cow<[u8]>,\n        message: Cow<[u8]>,\n    ) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).sign(sigtype, key, message)\n    }\n\n    fn verify(\n        &self,\n        sigtype: SigType,\n        pubkey: Cow<[u8]>,\n        message: Cow<[u8]>,\n        signature: Cow<[u8]>,\n    ) -> Result<bool, Self::Error> {\n        DefaultPinkExtension::new(self).verify(sigtype, pubkey, message, signature)\n    }\n\n    fn derive_sr25519_key(&self, salt: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        let privkey = PalletPink::key().ok_or(Error::KeySeedMissing)?;\n        let privkey = sp_core::sr25519::Pair::restore_from_secret_key(&privkey);\n        let contract_address: &[u8] = self.address.as_ref();\n        let derived_pair = privkey\n            .derive_sr25519_pair(&[contract_address, &salt, b\"keygen\"])\n            .or(Err(Error::DeriveKeyFailed))?;\n        let priviate_key = derived_pair.dump_secret_key();\n        let priviate_key: &[u8] = priviate_key.as_ref();\n        Ok(priviate_key.to_vec())\n    }\n\n    fn get_public_key(&self, sigtype: SigType, key: Cow<[u8]>) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).get_public_key(sigtype, key)\n    }\n\n    fn cache_set(\n        &self,\n        key: Cow<[u8]>,\n        value: Cow<[u8]>,\n    ) -> Result<Result<(), StorageQuotaExceeded>, Self::Error> {\n        Ok(OCallImpl.cache_set(self.address_bytes(), key.into_owned(), value.into_owned()))\n    }\n\n    fn cache_set_expiration(&self, key: Cow<[u8]>, expire: u64) -> Result<(), Self::Error> {\n        OCallImpl.cache_set_expiration(self.address_bytes(), key.into_owned(), expire);\n        Ok(())\n    }\n\n    fn cache_get(&self, key: Cow<'_, [u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(OCallImpl.cache_get(self.address_bytes(), key.into_owned()))\n    }\n\n    fn cache_remove(&self, key: Cow<'_, [u8]>) -> Result<Option<Vec<u8>>, Self::Error> {\n        Ok(OCallImpl.cache_remove(self.address_bytes(), key.into_owned()))\n    }\n\n    fn log(&self, level: u8, message: Cow<str>) -> Result<(), Self::Error> {\n        OCallImpl.log_to_server(self.address.clone(), level, message.as_ref().into());\n        DefaultPinkExtension::new(self).log(level, message)\n    }\n\n    fn getrandom(&self, length: u8) -> Result<Vec<u8>, Self::Error> {\n        DefaultPinkExtension::new(self).getrandom(length)\n    }\n\n    fn is_in_transaction(&self) -> Result<bool, Self::Error> {\n        Ok(fal"
    }
  ]
}