{
  "Title": "M-13: setPrincipal fails to approve Notional contract to spend lender's underlying tokens",
  "Content": "# Issue M-13: setPrincipal fails to approve Notional contract to spend lender's underlying tokens \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/41 \n\n## Found by \nminhtrng, bin2chen, neumo, rvierdiiev, Holmgren\n\n## Summary\nIf the **Notional** principal is not set at Marketplace creation, when trying to add it at a later time via **setPrincipal**, the call will not accomplish that the lender approves the notional contract to spend its underlying tokens,  due to passing the zero address as underlying to the lender's approve function.\n\n## Vulnerability Detail\nThe vulnerability lies in line 238 of **Marketplace** contract:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Marketplace.sol#L238\nFunction **approve** of **Lender** contract expects the address of the underlying contract as the first parameter:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L194-L214\nAs the underlying address passed in in the buggy line above is the zero address, **uToken** is also the zero adress and `Safe.approve(uToken, n, max);` just calls approve on the zero address, which does nothing (not even reverting because there's no contract deployed there). \n\n\n## Impact\nIf there was no way for the lender contract to approve the notional address, I would rate this issue as High, but since there is an admin function `function approve(address[] calldata u, address[] calldata a)`, the admin could fix this issue approving the notional contract over the underlying token, making the impact less severe. But in the meantime **Notional**'s lending would revert due to the lack of approval.\n\n## Code Snippet\nThe following test, that can be added in the **MarketPlace.t.sol** file, proves this vulnerability:\n```solidity\nfunction testIssueSetPrincipalNotional() public {\n\n\taddress notional = address(token7);\n\n\taddress[8] memory contracts;\n\tcontracts[0] = address(token0); // Swivel\n\tcontracts[1] = address(token1); // Yield\n\tcontracts[2] = address(token2); // Element\n\tcontracts[3] = address(token3); // Pendle\n\tcontracts[4] = address(token4); // Tempus\n\tcontracts[5] = address(token5); // Sense\n\tcontracts[6] = address(token6); // APWine\n\tcontracts[7] = address(0); // Notional unset at market creation\n\n\tmock_erc20.ERC20(underlying).decimalsReturns(10);\n\tmock_erc20.ERC20 compounding = new mock_erc20.ERC20();\n\ttoken6.futureVaultReturns(address(apwfv));\n\tapwfv.getIBTAddressReturns(address(compounding));\n\n\ttoken3.underlyingYieldTokenReturns(address(compounding));\n\n\tmp.createMarket(\n\t\taddress(underlying),\n\t\tmaturity,\n\t\tcontracts,\n\t\t'test-token',\n\t\t'tt',\n\t\taddress(elementVault),\n\t\taddress(apwineRouter)\n\t);\n\n\t// verify approvals\n\tassertEq(r.approveCalled(), address(compounding));\n\n\t// We verify that the notional address approved for address(0) is unset\n\t(, , address approvedNotional) = l.approveCalled(address(0));\n\tassertEq(approvedNotional, address(0));\n\t// and that the approved notional for address(underlying) is unset\n\t(, , approvedNotional) = l.approveCalled(address(underlying));\n\tassertEq(approvedNotional, address(0));\n\n\t// Then we call setPrincipal for the notional address\n\tmp.setPrincipal(uint8(MarketPlace.Principals.Notional), address(underlying), maturity, notional);\n\n\t// Now we verify that, after the call to setPrincipal, the notional address \n\t// approved for address(0) is the Notional address provided in the call\n\t(, , approvedNotional) = l.approveCalled(address(0));\n\tassertEq(approvedNotional, notional);\n\t// and that the approved notional for address(underlying) is still unset\n\t(, , approvedNotional) = l.approveCalled(address(underlying));\n\tassertEq(approvedNotional, address(0));\n}\n```\n\n## Tool used\n\nForge Tests and manual Review\n\n## Recommendation\nChange this line in Marketplace.sol:\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Marketplace.sol#L238\nwith this:\n`ILender(lender).approve(address(u), address(0), address(0), a);`\n\n## Discussion\n\n**pauliax**\n\nEscalate for 2 USDC.\nBasically, I have described the same issue in a more generic submission: #233\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> Basically, I have described the same issue in a more generic submission: #233\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/Marketplace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC5095.sol';\nimport 'src/lib/Safe.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\n\nimport 'src/interfaces/ILender.sol';\nimport 'src/interfaces/IPool.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\n\nimport 'src/errors/Exception.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the available principals for each loan market.\n/// @notice In addition, this contract routes swap orders between Illuminate PTs and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate, // 0\n        Swivel, // 1\n        Yield, // 2\n        Element, // 3\n        Pendle, // 4\n        Tempus, // 5\n        Sense, // 6\n        Apwine, // 7\n        Notional // 8\n    }\n\n    /// @notice markets are defined by a tuple that points to a fixed length array of principal token addresses.\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set pools, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address[9] tokens,\n        address element,\n        address apwine\n    );\n    /// @notice emitted upon setting a principal token\n    event SetPrincipal(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed principal,\n        uint8 protocol\n    );\n    /// @notice emitted upon swapping with the pool\n    event Swap(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address sold,\n        address bought,\n        uint256 received,\n        uint256 spent,\n        address spender\n    );\n    /// @notice emitted upon minting tokens with the pool\n    event Mint(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 underlyingIn,\n        uint256 principalTokensIn,\n        uint256 minted,\n        address minter\n    );\n    /// @notice emitted upon burning tokens with the pool\n    event Burn(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 tokensBurned,\n        uint256 underlyingReceived,\n        uint256 principalTokensReceived,\n        address burner\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting a pool\n    event SetPool(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed pool\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice initializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    constructor(address r, address l) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market\n    /// @param n name for the Illuminate token\n    /// @param s symbol for the Illuminate token\n    /// @param e address of the Element vault that corresponds to this market\n    /// @param a address of the APWine router that corresponds to this market\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] calldata t,\n        string calldata n,\n        string calldata s,\n        address e,\n        address a\n    ) external authorized(admin) returns (bool) {\n        {\n            // Get the Illuminate principal token for this market (if one exists)\n            address illuminate = markets[u][m][\n                (uint256(Principals.Illuminate))\n            ];\n\n            // If illuminate PT already exists, a new market cannot be created\n            if (illuminate != address(0)) {\n                revert Exception(9, 0, 0, illuminate, address(0));\n            }\n        }\n\n        // Create an Illuminate principal token for the new market\n        address illuminateToken = address(\n            new ERC5095(\n                u,\n                m,\n                redeemer,\n                lender,\n                address(this),\n                n,\n                s,\n                IERC20(u).decimals()\n            )\n        );\n\n        {\n            // create the principal tokens array\n            address[9] memory market = [\n                illuminateToken, // Illuminate\n                t[0], // Swivel\n                t[1], // Yield\n                t[2], // Element\n                t[3], // Pendle\n                t[4], // Tempus\n                t[5], // Sense\n                t[6], // APWine\n                t[7] // Notional\n            ];\n\n            // Set the market\n            markets[u][m] = market;\n\n            // Have the lender contract approve the several contracts\n            ILender(lender).approve(u, e, a, t[7]);\n\n            // Have the redeemer contract approve the Pendle principal token\n            if (t[3] != address(0)) {\n                address underlyingYieldToken = IPendleToken(t[3])\n                    .underlyingYieldToken();\n                IRedeemer(redeemer).approve(underlyingYieldToken);\n            }\n\n            if (t[6] != address(0)) {\n                address futureVault = IAPWineToken(t[6]).futureVault();\n                address interestBearingToken = IAPWineFutureVault(futureVault)\n                    .getIBTAddress();\n                IRedeemer(redeemer).approve(interestBearingToken);\n            }\n\n            emit CreateMarket(u, m, market, e, a);\n        }\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the new principal token\n    /// @return bool true if the principal set, false otherwise\n    function setPrincipal(\n        uint8 p,\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Get the current principal token for the principal token being set\n        address market = markets[u][m][p];\n\n        // Verify that it has not already been set\n        if (market != address(0)) {\n            revert Exception(9, 0, 0, market, address(0));\n        }\n\n        // Set the principal token in the markets mapping\n        markets[u][m][p] = a;\n\n        if (p == uint8(Principals.Pendle)) {\n            // Principal token must be approved for Pendle's redeem\n            address underlyingYieldToken = IPendleToken(a)\n                .underlyingYieldToken();\n            IRedeemer(redeemer).approve(underlyingYieldToken);\n        } else if (p == uint8(Principals.Apwine)) {\n            address futureVault = IAPWineToken(a).futureVault();\n            address interestBearingToken = IAPWineFutureVault(futureVault)\n                .getIBTAddress();\n            IRedeemer(redeemer).approve(interestBearingToken);\n        } else if (p == uint8(Principals.Notional)) {\n            // Principal token must be approved for Notional's lend\n            ILender(lender).approve(address(0), address(0), address(0), a);\n        }\n\n        emit SetPrincipal(u, m, a, p);\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if the admin set, false otherwise\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if the pool set, false otherwise\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Verify that the pool has not already been set\n        address pool = pools[u][m];\n\n        // Revert if the pool already exists\n        if (pool != address(0)) {\n            revert Exception(10, 0, 0, pool, address(0));\n        }\n\n        // Set the pool\n        pools[u][m] = a;\n\n        emit SetPool(u, m, a);\n        return true;\n    }\n\n    /// @notice sells the PT for the underlying via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to sell\n    /// @param s slippage cap, minimum amount of underlying that must be received\n    /// @return uint128 amount of underlying bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Preview amount of underlying received by selling `a` PTs\n        uint256 expected = pool.sellFYTokenPreview(a);\n\n        if (expected < s) {\n            revert Exception(16, expected, s, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            a\n        );\n\n        // Execute the swap\n        uint128 received = pool.sellFYToken(msg.sender, uint128(expected));\n        emit Swap(u, m, address(pool.fyToken()), u, received, a, msg.sender);\n\n        return received;\n    }\n\n    /// @notice buys the PT for the underlying via the pool\n    /// @notice determines how many underlying to sell by using the preview\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to be purchased\n    /// @param s slippage cap, maximum number of underlying that can be sold\n    /// @return uint128 amount of underlying sold\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the amount of base hypothetically required to purchase `a` PTs\n        uint128 expected = pool.buyFYTokenPreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected > s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(\n            IERC20(pool.base()),\n            msg.sender,\n            address(pool),\n            expected\n        );\n\n        // Execute the swap to purchase `a` base tokens\n        uint128 spent = pool.buyFYToken(msg.sender, a, 0);\n        emit Swap(u, m, u, address(pool.fyToken()), a, spent, msg.sender);\n\n        return spent;\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to sell\n    /// @param s slippage cap, minimum number of PTs that must be received\n    /// @return uint128 amount of PT purchased\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the number of PTs received for selling `a` underlying tokens\n        uint128 expected = pool.sellBasePreview(a);\n\n        // Verify slippage does not exceed the one set by the user\n        if (expected < s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n\n        // Execute the swap\n        uint128 received = pool.sellBase(msg.sender, expected);\n\n        emit Swap(u, m, u, address(pool.fyToken()), received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @notice determines how many PTs to sell by using the preview\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to be purchased\n    /// @param s slippage cap, maximum number of PTs that can be sold\n    /// @return uint128 amount of PTs sold\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the amount of PTs hypothetically required to purchase `a` underlying\n        uint256 expected = pool.buyBasePreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected > s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            expected\n        );\n\n        // Execute the swap to purchase `a` underlying tokens\n        uint128 spent = pool.buyBase(msg.sender, a, 0);\n\n        emit Swap(u, m, address(pool.fyToken()), u, a, spent, msg.sender);\n        return spent;\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param b number of base tokens\n    /// @param p the principal token amount being sent\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 number of base tokens passed to the method\n    /// @return uint256 number of yield tokens passed to the method\n    /// @return uint256 the amount of tokens minted.\n    function mint(\n        address u,\n        uint256 m,\n        uint256 b,\n        uint256 p,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), b);\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            p\n        );\n\n        // Mint the tokens and return the leftover assets to the caller\n        (uint256 underlyingIn, uint256 principalTokensIn, uint256 minted) = pool\n            .mint(msg.sender, msg.sender, minRatio, maxRatio);\n\n        emit Mint(u, m, underlyingIn, principalTokensIn, minted, msg.sender);\n        return (underlyingIn, principalTokensIn, minted);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param p amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio maximum ratio of underlying to PT in the pool.\n    /// @return uint256 number of base tokens passed to the method\n    /// @return uint256 number of yield tokens passed to the method\n    /// @return uint256 the amount of tokens minted.\n    function mintWithUnderlying(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 p,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n\n        // Mint the tokens to the user\n        (uint256 underlyingIn, , uint256 minted) = pool.mintWithBase(\n            msg.sender,\n            msg.sender,\n            p,\n            minRatio,\n            maxRatio\n        );\n\n        emit Mint(u, m, underlyingIn, 0, minted, msg.sender);\n        return (underlyingIn, 0, minted);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the amount of liquidity tokens to burn\n    /// @param minRatio minimum ratio of underlying to PT in the pool\n    /// @param maxRatio maximum ratio of underlying to PT in the pool\n    /// @return uint256 amount of LP tokens burned\n    /// @return uint256 amount of base tokens received\n    /// @return uint256 amount of fyTokens received\n    function burn(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 minRatio,\n        uint256 maxRatio\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\n\n        // Burn the tokens\n        (\n            uint256 tokensBurned,\n            uint256 underlyingReceived,\n            uint256 principalTokensReceived\n        ) = pool.burn(msg.sender, msg.sender, minRatio, maxRatio);\n\n        emit Burn(\n            u,\n            m,\n            tokensBurned,\n            underlyingReceived,\n            principalTokensReceived,\n            msg.sender\n        );\n        return (tokensBurned, underlyingReceived, principalTokensReceived);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the amount of liquidity tokens to burn\n    /// @param minRatio minimum ratio of underlying to PT in the pool.\n    /// @param maxRatio minimum ratio of underlying to PT in the pool.\n    /// @return uint256 amount of PT tokens sent to the pool\n    /// @return uint256 amount of underlying tokens returned\n    function burnForUnderlying(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256) {\n        // get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\n\n        // burn the tokens in exchange for underlying tokens\n        (uint256 tokensBurned, uint256 underlyingReceived) = pool.burnForBase(\n            msg.sender,\n            minRatio,\n            maxRatio\n        );\n\n        emit Burn(u, m, tokensBurned, underlyingReceived, 0, msg.sender);\n        return (tokensBurned, underlyingReceived);\n    }\n\n    /// @notice provides an interface to receive principal token addresses from markets\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    function token(\n        address u,\n        uint256 m,\n        uint256 p\n    ) external view returns (address) {\n        return markets[u][m][p];\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param c An array of inputs for each call.\n    function batch(bytes[] calldata c)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](c.length);\n        for (uint256 i; i < c.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                c[i]\n            );\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n            results[i] = result;\n        }\n    }\n}"
    },
    {
      "filename": "src/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol'; // library of MarketPlace specific constructs\nimport 'src/lib/Swivel.sol'; // library of Swivel specific constructs\nimport 'src/lib/Element.sol'; // library of Element specific constructs\nimport 'src/lib/Safe.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusAMM.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/ISensePeriphery.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IElementVault.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/IAPWineRouter.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleToken.sol';\n\n/// @title Lender\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users\n/// @notice The contract holds the principal tokens and mints an ERC-5095 tokens to users to represent their loans\ncontract Lender {\n    /// @notice minimum wait before the admin may withdraw funds or change the fee rate\n    uint256 public constant HOLD = 3 days;\n\n    /// @notice address that is allowed to set and withdraw fees, disable principals, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal token has been paused by the admin\n    mapping(address => mapping(uint256 => bool[9])) public paused;\n\n    /// @notice contract used to execute swaps on Swivel's exchange\n    address public immutable swivelAddr;\n    /// @notice a SushiSwap router used by Pendle to execute swaps\n    address public immutable pendleAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public constant MIN_FEENOMINATOR = 500;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping(address => uint256) public withdrawals;\n\n    /// @notice emitted upon lending to a protocol\n    event Lend(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 returned,\n        uint256 spent,\n        address sender\n    );\n    /// @notice emitted upon minting Illuminate principal tokens\n    event Mint(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount\n    );\n    /// @notice emitted upon scheduling a withdrawal\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted upon blocking a scheduled withdrawal\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n    /// @notice emitted upon scheduling a fee change\n    event ScheduleFeeChange(uint256 when);\n    /// @notice emitted upon blocking a scheduled fee change\n    event BlockFeeChange();\n    /// @notice emitted upon pausing or unpausing of a principal token\n    event PauseMarket(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        address token,\n        bool indexed state\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    modifier unpaused(\n        address u,\n        uint256 m,\n        uint8 p\n    ) {\n        if (paused[u][m][p]) {\n            revert Exception(1, p, 0, address(0), address(0));\n        }\n        _;\n    }\n\n    /// @notice initializes the Lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    constructor(address s, address p) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // approve the underlying for max per given principal\n        for (uint8 i; i != 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).token(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses.\n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        for (uint256 i; i != u.length; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice approves market contracts that require lender approval\n    /// @param u address of an underlying asset\n    /// @param a APWine's router contract\n    /// @param e Element's vault contract\n    /// @param n Notional's token contract\n    function approve(\n        address u,\n        address a,\n        address e,\n        address n\n    ) external authorized(marketPlace) {\n        uint256 max = type(uint256).max;\n        IERC20 uToken = IERC20(u);\n        if (a != address(0)) {\n            Safe.approve(uToken, a, max);\n        }\n        if (e != address(0)) {\n            Safe.approve(uToken, e, max);\n        }\n        if (n != address(0)) {\n            Safe.approve(uToken, n, max);\n        }\n        if (IERC20(u).allowance(address(this), swivelAddr) == 0) {\n            Safe.approve(uToken, swivelAddr, max);\n        }\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (block.timestamp < feeTime) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for Illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on Illuminate\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) external unpaused(u, m, p) returns (bool) {\n        // Fetch the desired principal token\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer the users principal tokens to the lender contract\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n        // Mint the tokens received from the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method for the Illuminate and Yield protocols\n    /// @param p principal va"
    }
  ]
}