{
  "Title": "[G-06]  `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables",
  "Content": "Using the addition operator instead of plus-equals saves **[113 gas](https://gist.github.com/IllIllI000/cbbfb267425b898e5be734d4008d4fe8)**.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: src/ArtGobblers.sol\n\n844:              uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach << 1);\n\n```\nhttps://github.com/code-423n4/2022-09-artgobblers/blob/d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe/src/ArtGobblers.sol#L844\n\n```solidity\nFile: src/Pages.sol\n\n244:              uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);\n\n```\nhttps://github.com/code-423n4/2022-09-artgobblers/blob/d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe/src/Pages.sol#L244\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-09-artgobblers",
  "Code": [
    {
      "filename": "src/ArtGobblers.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/*                                                                              **,/*,\n                                                                     *%@&%#/*,,..........,/(%&@@#*\n                                                                 %@%,..............................#@@%\n                                                              &&,.....,,...............................,/&@*\n                                                            (@*.....**............,/,.......................(@%\n                                                           &&......*,............./,.............**............&@\n                                                          @#......**.............**..............,*........,*,..,@/\n                                                         /@......,/............../,..............,*........../,..*@.\n                                                        #@,......................*.............../,..........**...#/\n                                                      ,@&,.......................................*..........,/....(@\n                                                  *@&(*...................................................../*....(@\n                                                 @(..*%@@&%#(#@@@%%%%%&&@@@@@@@@@&&#(///..........................#@\n                                                 @%/@@@&%&&&@@&%%%%%%%#(/(((/(/(/(/(/(/(/(/(%%&@@@%(/,............#&\n                                                  @@@#/**./@%%%&%#/*************./(%@@@@&(*********(@&&@@@%(.....,&@\n                                                 ,@/.//(&@@/.     .#@%/******./&&*,      ./@&********%@/**(@#@@#,..(@\n                                                 #%****%@.           %@/****./&@      ,.    %&********%@(**&@...(@#.#@\n                                                 &#**./@/  %@&&      .@#****./@*    &@@@@&  .@/******./@@((((@&....(@\n                                                 ##**./&@ ,&@@@,     #@/****./@@      @@.  .@&*******./@%****%@@@(,\n                                                 ,@/**./%@(.      .*@@/********(&@#*,,,,/&@%/*******./@@&&&@@@#\n                                                   @&/**@&/%&&&&&%/**.//////*********./************./@&******@*\n                                                     /@@@@&(////#%&@@&(**./#&@@&(//*************./&@(********#@\n                                                       .@#**.///*****************(#@@@&&&&&@@@@&%(**********./@,\n                                                       @(*****%@#*********************&@#*********************(@\n                                                       @****./@#*./@@#//***.///(%@%*****%@*********************#@\n                                                      #&****./@%************************&@**********************@%\n                                                     .@/******.//*******************./@@(************************@/\n                                                     /@**********************************************************(@,\n                                                     @#*****************************************************%@@@@@@@.\n                                                    *@/*************************************************************#@(\n                                                    @%***************************************************************./@(\n                     /@@&&&@@                     .@/*******************************************************************&@\n                    @%######%@.                   @#***************************./%&&&%(**************#%******************&#\n                    @%######&@%&@@.             ,@(***./&#********************#@&#####%@&*************&%****************./@,\n               &&*,/@%######&@@@*.*@&,         @@****./@&*******************./%@#######%@#***********./@&*****************(@\n              ((...*%@&##%@@,..........,,,,%@&@%/*****&%****************./&@#*%@#######&@*#@%*********./@&*****************(@,\n              (@#....(@%#&&,...,/...........@(*******(@(****************(@/...*%@@@@@@%*....&@@@@&@@@@@@%/%@@##(************(@.\n              ((./(((%@%#&@/,/&@/...........%&*******%@****************./@%,.................#,............/@%***************#@\n              *@@####@@%###%&@(@(...........%&*******%@****************%@,,#%/..............................#@/***************&/\n              (#.....,&&####&@..%%..........%%*****(@@#****************#@,...................................@(***************(@\n              .@@&%%&@@&####&&.............,@(***%@(**********./#%%%%%##&@&#(,...............................#@****************&.\n               &#.....(@%###&@*............%@**%@(*******(&@&%#/////////@%...................................#@***************&@\n                 #@@@@&%####&@&&&,........%@./@%*****(@@%////////////////@@@%,...............................#@**************#@\n                     @@&&&&@@(    /&@@&%%@&@@@%**./&@(///////////////////@%.................................,@(*********./%@&.\n                      (@//@%                @%***&&(//////////////////////(&@(**,,,,./(%&@@@%/*,,****,,***./@@&&&&&&&&#//%@\n                      (@//%@               (@(*#@#////////////////////////////%@@%%%&@@#////%@/***************************&&\n                      (@//%@  .,,,,/#&&&&&&@&*#@#///////////////////////////////@%//&&///////#@(***************************@&(#@@@@@&(*.\n               ,@@@@@&&@//%@,,.,,,,,.,..,,#@./@%////////////////////////////////%@**&&////////(@(**************************&#,,,,,,,,,,,,/(#&@&\n          &@%*,,,,,,,,#@//%@,,,,,,,,,,,,,,&%*#@(////////////////////////////////%@**&&/////////&@**************************#@.,,,.,,.,,&#.,,...,%@\n       (@/,,,,,,,,,,,,(@(/%@,,,,,,,,,,,,,,&%*#@(////////////////////////////////%@./%@/////////#@(*************************&%,,,(%@@@@#*,.     .,/@.\n      &%..    *&@%/,.,#@(*#@*,,.,,,,,,,,,,%@/#@(////////////////////////////////%@**#@/////////#@(*****************.//#%@@@@%%(/,...        ...,,,%&\n     ,@*.,.       ../((%&&@@@&%#((///,,,,,/@&(@(////////////////////////////////@&**#@/////////%@%###%&&&&@@@@@@%%#(**,,,,,,.         ..,,,,,,,,,,%#\n      @(,,,,,..,            ,..   ..,,,**(%%%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%(((,,.,.,,,,,,.,..,,,,.,.,,,,.,..,.,,.,,,,,.,,,,,,,,,.*@%\n       @%,,,,,,,,,,,,,,,.,.,,,      .,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,.,,,,,,#@@,\n        ,@@(,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,.,,.,.,./#%&@@@@@#\n         .@#&@@@@@%*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,/&@@@@@%&@%((((#@@.\n          .@%((((#@@@/#&@@@@&%#/*,.,..,,,,.,,,,,.,.,,,,,,,,,,,,,,,,..,.,..,,...,,,...,,,,,,.,,,,,,,,,,,../#%&@@@@@@@&%((///*********./(((/&&\n             %@&%%#/***********./////(((((((####%%&&@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@&&%%%%%%%%#((((((((%@&#(((((#%@%/*******************./*/\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\nimport {LibGOO} from \"goo-issuance/LibGOO.sol\";\nimport {LogisticVRGDA} from \"VRGDAs/LogisticVRGDA.sol\";\n\nimport {RandProvider} from \"./utils/rand/RandProvider.sol\";\nimport {GobblersERC721} from \"./utils/token/GobblersERC721.sol\";\n\nimport {Goo} from \"./Goo.sol\";\nimport {Pages} from \"./Pages.sol\";\n\n/// @title Art Gobblers NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice An experimental decentralized art factory by Justin Roiland and Paradigm.\ncontract ArtGobblers is GobblersERC721, LogisticVRGDA, Owned, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address of the Pages ERC721 token contract.\n    Pages public immutable pages;\n\n    /// @notice The address which receives gobblers reserved for the team.\n    address public immutable team;\n\n    /// @notice The address which receives gobblers reserved for the community.\n    address public immutable community;\n\n    /// @notice The address of a randomness provider. This provider will initially be\n    /// a wrapper around Chainlink VRF v1, but can be changed in case it is fully sunset.\n    RandProvider public randProvider;\n\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n\n    /// @notice Maximum amount of mintable legendary gobblers.\n    uint256 public constant LEGENDARY_SUPPLY = 10;\n\n    /// @notice Maximum amount of gobblers split between the reserves.\n    /// @dev Set to comprise 20% of the sum of goo mintable gobblers + reserved gobblers.\n    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;\n\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    // prettier-ignore\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY\n        - MINTLIST_SUPPLY\n        - LEGENDARY_SUPPLY\n        - RESERVED_SUPPLY;\n\n    /*//////////////////////////////////////////////////////////////\n                           METADATA CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice URI for gobblers that have yet to be revealed.\n    string public UNREVEALED_URI;\n\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n\n    /// @notice Number of gobblers minted from goo.\n    uint128 public numMintedFromGoo;\n\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Id of the most recently minted non legendary gobbler.\n    /// @dev Will be 0 if no non legendary gobblers have been minted yet.\n    uint128 public currentNonLegendaryId;\n\n    /// @notice The number of gobblers minted to the reserves.\n    uint256 public numMintedForReserves;\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initial legendary gobbler auction price.\n    uint256 public constant LEGENDARY_GOBBLER_INITIAL_START_PRICE = 69;\n\n    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.\n    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;\n\n    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted from goo.\n    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.\n    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);\n\n    /// @notice Struct holding data required for legendary gobbler auctions.\n    struct LegendaryGobblerAuctionData {\n        // Start price of current legendary gobbler auction.\n        uint128 startPrice;\n        // Number of legendary gobblers sold so far.\n        uint128 numSold;\n    }\n\n    /// @notice Data about the current legendary gobbler auction.\n    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last randomness obtained from the rand provider.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint56 lastRevealedId;\n        // Remaining gobblers to be revealed with the current seed.\n        uint56 toBeRevealed;\n        // Whether we are waiting to receive a seed from Chainlink.\n        bool waitingForSeed;\n    }\n\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n\n    /*//////////////////////////////////////////////////////////////\n                            GOBBLED ART STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids gobbled by the gobbler.\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtGobbledByGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event GooBalanceUpdated(address indexed user, uint256 newGooBalance);\n\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);\n\n    event RandomnessFulfilled(uint256 randomness);\n    event RandomnessRequested(address indexed user, uint256 toBeRevealed);\n    event RandProviderUpgraded(address indexed user, RandProvider indexed newRandProvider);\n\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n\n    event ArtGobbled(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error InvalidProof();\n    error AlreadyClaimed();\n    error MintStartPending();\n\n    error SeedPending();\n    error RevealsPending();\n    error RequestTooEarly();\n    error ZeroToBeRevealed();\n    error NotRandProvider();\n\n    error ReserveImbalance();\n\n    error Cannibalism();\n    error OwnerMismatch(address owner);\n\n    error NoRemainingLegendaryGobblers();\n    error CannotBurnLegendary(uint256 gobblerId);\n    error InsufficientGobblerAmount(uint256 cost);\n    error LegendaryAuctionNotStarted(uint256 gobblersLeft);\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);\n\n    error UnauthorizedCaller(address caller);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets VRGDA parameters, mint config, relevant addresses, and URIs.\n    /// @param _merkleRoot Merkle root of mint mintlist.\n    /// @param _mintStart Timestamp for the start of the VRGDA mint.\n    /// @param _goo Address of the Goo contract.\n    /// @param _team Address of the team reserve.\n    /// @param _community Address of the community reserve.\n    /// @param _randProvider Address of the randomness provider.\n    /// @param _baseUri Base URI for revealed gobblers.\n    /// @param _unrevealedUri URI for unrevealed gobblers.\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        Pages _pages,\n        address _team,\n        address _community,\n        RandProvider _randProvider,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri\n    )\n        GobblersERC721(\"Art Gobblers\", \"GOBBLER\")\n        Owned(msg.sender)\n        LogisticVRGDA(\n            69.42e18, // Target price.\n            0.31e18, // Price decay percent.\n            // Max gobblers mintable via VRGDA.\n            toWadUnsafe(MAX_MINTABLE),\n            0.0023e18 // Time scale.\n        )\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n\n        goo = _goo;\n        pages = _pages;\n        team = _team;\n        community = _community;\n        randProvider = _randProvider;\n\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n\n        // Set the starting price for the first legendary gobbler auction.\n        legendaryGobblerAuctionData.startPrice = uint128(LEGENDARY_GOBBLER_INITIAL_START_PRICE);\n\n        // Reveal for initial mint must wait a day from the start of the mint.\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @dev Function does not directly enforce the MINTLIST_SUPPLY limit for gas efficiency. The\n    /// limit is enforced during the creation of the merkle proof, which will be shared publicly.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun, revert.\n        if (mintStart > block.timestamp) revert MintStartPending();\n\n        // If the user has already claimed, revert.\n        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();\n\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();\n\n        hasClaimedMintlistGobbler[msg.sender] = true;\n\n        unchecked {\n            // Overflow should be impossible due to supply cap of 10,000.\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);\n        }\n\n        _mint(msg.sender, gobblerId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a gobbler, paying with goo.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @param useVirtualBalance Whether the cost is paid from the\n    /// user's virtual goo balance, or from their ERC20 goo balance.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoo(uint256 maxPrice, bool useVirtualBalance) external returns (uint256 gobblerId) {\n        // No need to check if we're at MAX_MINTABLE,\n        // gobblerPrice() will revert once we reach it due to its\n        // logistic nature. It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        // Decrement the user's goo balance by the current\n        // price, either from virtual balance or ERC20 balance.\n        useVirtualBalance\n            ? updateUserGooBalance(msg.sender, currentPrice, GooBalanceUpdateType.DECREASE)\n            : goo.burnForGobblers(msg.sender, currentPrice);\n\n        unchecked {\n            ++numMintedFromGoo; // Overflow should be impossible due to the supply cap.\n\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);\n        }\n\n        _mint(msg.sender, gobblerId);\n    }\n\n    /// @notice Gobbler pricing in terms of goo.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    /// @return Current price of a gobbler in terms of goo.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause underflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), numMintedFromGoo);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the legendary gobbler that was minted.\n    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold; // Assign id.\n\n        // If the gobbler id would be greater than the max supply, there are no remaining legendaries.\n        if (gobblerId > MAX_SUPPLY) revert NoRemainingLegendaryGobblers();\n\n        // This will revert if the auction hasn't started yet, no need to check here as well.\n        uint256 cost = legendaryGobblerPrice();\n\n        if (gobblerIds.length < cost) revert InsufficientGobblerAmount(cost);\n\n        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.\n\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n\n            for (uint256 i = 0; i < cost; ++i) {\n                id = gobblerIds[i];\n\n                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);\n\n                require(getGobblerData[id].owner == msg.sender, \"WRONG_FROM\");\n\n                burnedMultipleTotal += getGobblerData[id].emissionMultiple;\n\n                emit Transfer(msg.sender, getGobblerData[id].owner = address(0), id);\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                 LEGENDARY MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            // The legendary's emissionMultiple is 2x the sum of the multiples of the gobblers burned.\n            getGobblerData[gobblerId].emissionMultiple = uint32(burnedMultipleTotal * 2);\n\n            // Update the user's user data struct in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getUserData[msg.sender].lastBalance = uint128(gooBalance(msg.sender)); // Checkpoint balance.\n            getUserData[msg.sender].lastTimestamp = uint64(block.timestamp); // Store time alongside it.\n            getUserData[msg.sender].emissionMultiple += uint32(burnedMultipleTotal); // Update multiple.\n            // We subtract the amount of gobblers burned, and then add 1 to factor in the new legendary.\n            getUserData[msg.sender].gobblersOwned = uint32(getUserData[msg.sender].gobblersOwned - cost + 1);\n\n            // New start price is the max of LEGENDARY_GOBBLER_INITIAL_START_PRICE and cost * 2.\n            legendaryGobblerAuctionData.startPrice = uint120(\n                cost <= LEGENDARY_GOBBLER_INITIAL_START_PRICE / 2 ? LEGENDARY_GOBBLER_INITIAL_START_PRICE : cost * 2\n            );\n            legendaryGobblerAuctionData.numSold += 1; // Increment the # of legendaries sold.\n\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds[:cost]);\n\n            _mint(msg.sender, gobblerId);\n        }\n    }\n\n    /// @notice Calculate the legendary gobbler price in terms of gobblers, according to a linear decay function.\n    /// @dev The price of a legendary gobbler decays as gobblers are minted. The first legendary auction begins when\n    /// 1 LEGENDARY_AUCTION_INTERVAL worth of gobblers are minted, and the price decays linearly while the next interval of\n    /// gobblers are minted. Every time an additional interval is minted, a new auction begins until all legendaries have been sold.\n    /// @return price of legendary gobbler, in terms of gobblers.\n    function legendaryGobblerPrice() public view returns (uint256) {\n        // Retrieve and cache various auction parameters and variables.\n        uint256 startPrice = legendaryGobblerAuctionData.startPrice;\n        uint256 numSold = legendaryGobblerAuctionData.numSold;\n        uint256 mintedFromGoo = numMintedFromGoo;\n\n        unchecked {\n            // The number of gobblers minted at the start of the auction is computed by multiplying the # of\n            // intervals that must pass before the next auction begins by the number of gobblers in each interval.\n            uint256 numMintedAtStart = (numSold + 1) * LEGENDARY_AUCTION_INTERVAL;\n\n            // If not enough gobblers have been minted to start the auction yet, return how many need to be minted.\n            if (numMintedAtStart > mintedFromGoo) revert LegendaryAuctionNotStarted(numMintedAtStart - mintedFromGoo);\n\n            // Compute how many gobblers were minted since the auction began.\n            uint256 numMintedSinceStart = numMintedFromGoo - numMintedAtStart;\n\n            // prettier-ignore\n            // If we've minted the full interval or beyond it, the price has decayed to 0.\n            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;\n            // Otherwise decay the price linearly based on what fraction of the interval has been minted.\n            else return FixedPointMathLib.unsafeDivUp(startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart), LEGENDARY_AUCTION_INTERVAL);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            RANDOMNESS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Request a new random seed for revealing gobblers.\n    /// @dev Can only be called every 24 hours at the earliest.\n    function requestRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();\n\n        // A random seed can only be requested when all gobblers from the previous seed have been revealed.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();\n\n        unchecked {\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n\n            // Compute the number of gobblers to be revealed with the seed.\n            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;\n\n            // Ensure that there are more than 0 gobblers to be revealed,\n            // otherwise the contract could waste LINK revealing nothing.\n            if (toBeRevealed == 0) revert ZeroToBeRevealed();\n\n            // Lock in the number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);\n\n            // We want at most one batch of reveals every 24 hours.\n            // Timestamp overflow is impossible on human timescales.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n\n            emit RandomnessRequested(msg.sender, toBeRevealed);\n        }\n\n        // Call out to the randomness provider.\n        return randProvider.requestRandomBytes();\n    }\n\n    /// @notice Callback from rand provider. Sets randomSeed. Can only be called by the rand provider.\n    /// @param randomness The 256 bits of verifiable randomness provided by the rand provider.\n    function acceptRandomSeed(bytes32, uint256 randomness) external {\n        // The caller must be the randomness provider, revert in the case it's not.\n        if (msg.sender != address(randProvider)) revert NotRandProvider();\n\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n\n        emit RandomnessFulfilled(randomness);\n    }\n\n    /// @notice Upgrade the rand provider contract. Useful if current VRF is sunset.\n    /// @param newRandProvider The new randomness provider contract address.\n    function upgradeRandProvider(RandProvider newRandProvider) external onlyOwner {\n        // Revert if waiting for seed, so we don't interrupt requests in flight.\n        if (gobblerRevealsData.waitingForSeed) revert SeedPending();\n\n        randProvider = newRandProvider; // Update the randomness provider.\n\n        emit RandProviderUpgraded(msg.sender, newRandProvider);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Knuth shuffle to progressively reveal\n    /// new gobblers using entropy from a random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 randomSeed = gobblerRevealsData.randomSeed;\n\n        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;\n\n        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;\n\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert SeedPending();\n\n        // Can't reveal more gobblers than are currently remaining to be revealed with the seed.\n        if (numGobblers > totalRemainingToBeRevealed) revert NotEnoughRemainingToBeRevealed(totalRemainingToBeRevealed);\n\n        // Implements a Knuth shuffle. If something in\n        // here can overflow, we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; ++i) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any legendaries in the swap.\n                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;\n\n                // Randomly pick distance for swap.\n                uint256 distance = randomSeed % remainingIds;\n\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++lastRevealedId;\n\n                /"
    }
  ]
}