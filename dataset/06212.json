{
  "Title": "[H-16] Attacker can block LayerZero channel due to variable gas cost of saving payload",
  "Content": "\n<https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/BaseUSDO.sol#L399> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L442> \n\n<https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L52>\n\nThis is an issue that affects `BaseUSDO`, `BaseTOFT`, and `BaseTapOFT` or all the contracts which are sending and receiving LayerZero messages.\nThe consequence of this is that anyone can with low cost and high frequency keep on blocking the pathway between any two chains, making the whole system unusable.\n\n### Proof of Concept\n\nI will illustrate the concept of blocking the pathway on the example of sending a message through `BaseTOFT’s` [`sendToYAndBorrow`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L290).\nThis function allows the user to mint/borrow `USDO` with some collateral that is wrapped in a `TOFT` and gives the option of transferring minted `USDO` to another chain.\n\nThe attack starts by invoking [`sendToYBAndBorrow`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L290) which delegate calls into [`BaseTOFTMarketModule`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L87).\nIf we look at the implementation inside the `BaseTOFTMarketModule` nothing is validated there except for the `lzPayload` which has the packetType of `PT_YB_SEND_SGL_BORROW`.\n\nThe only validation of the message happens inside the [`LzApp`](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/LzApp.sol#L49) with the configuration which was set.\nWhat is restrained within this configuration is the [`payload size`](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/LzApp.sol#L52), which if not configured defaults to [10k bytes](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/LzApp.sol#L18).\n\nThe application architecture was set up in a way that all the messages regardless of their packetType go through the same `_lzSend` implementation.\nI’m mentioning that because it means that if the project decides to change the default payload size to something smaller(or bigger) it will be dictated by the message with the biggest possible payload size.\n\nI’ve mentioned the [minimum gas enforcement in my other issue](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1207) but even if that is fixed and a high min gas is enforced this is another type of issue.\n\nTo execute the attack we need to pass the following parameters to the function mentioned above:\n\n```solidity\n    function executeAttack() public {\n        address tapiocaOFT = makeAddr(\"TapiocaOFT-AVAX\");\n        tapiocaOFT.sendToYBAndBorrow{value: enough_gas_to_go_through}(\n            address from => // malicious user address\n            address to => // malicious user address\n            lzDstChainId => // any chain lzChainId\n            bytes calldata airdropAdapterParams => // encode in a way to send to remote with minimum gas enforced by the layer zero configuration\n            ITapiocaOFT.IBorrowParams calldata borrowParams, // can be anything\n            ICommonData.IWithdrawParams calldata withdrawParams, // can be anything\n            ICommonData.ISendOptions calldata options, // can be anything\n            ICommonData.IApproval[] calldata approvals // Elaborating on this below\n        )\n    }\n```\n\n`ICommonData.IApproval[] calldata approvals` are going to be fake data so [max payload size limit is reached(10k)](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L105-L112). The `target` of the 1st approval in the array will be the `GasDrainingContract` deployed on the receiving chain and the `permitBorrow = true`.\n\n```solidity\n    contract GasDrainingContract {\n        mapping(uint256 => uint256) public storageVariables;\n    \n        function permitBorrow(\n            address owner,\n            address spender,\n            uint256 value,\n            uint256 deadline,\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        ) external {\n            for (uint256 i = 0; i < 100000; i++) {\n                storageVariables[i] = i;\n            }\n        }\n    }\n```\n\nLet’s take an example of an attacker sending a transaction on the home chain which specifies a 1 million gasLimit for the destination transaction.\n\n1.  Transaction is successfully received inside the [`lzReceive`](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/LzApp.sol#L35) after which it reaches [\\_blockingLzReceive](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/NonblockingLzApp.sol#L25).\n\n2.  This is the first external call and according to [`EIP-150`](https://eips.ethereum.org/EIPS/eip-150) out of 1 million gas:\n\n    *   63/64 or \\~985k would be forwarded to the external call.\n    *   1/64 or \\~15k will be left for the rest of the execution.\n\n3.  The cost of saving a big payload into the [`failedMessages`](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/NonblockingLzApp.sol#L27-L29) and emitting events is higher than 15k.\n\nWhen it comes to 10k bytes it is around 130k gas but even with smaller payloads, it is still significant. It can be tested with the following code:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.19;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\ncontract FailedMessagesTest is Test {\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n\n    function setUp() public {}\n\n    function testFMessagesGas() public {\n        uint16 srcChainid = 1;\n        bytes memory srcAddress = abi.encode(makeAddr(\"Alice\"));\n        uint64 nonce = 10;\n        bytes memory payload = getDummyPayload(9999); // max payload size someone can send is 9999 bytes\n        bytes memory reason = getDummyPayload(2);\n\n        uint256 gasLeft = gasleft();\n        _storeFailedMessage(srcChainid, srcAddress, nonce, payload, reason);\n        emit log_named_uint(\"gas used\", gasLeft - gasleft());\n    }\n\n\n    function _storeFailedMessage(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload,\n        bytes memory _reason\n    ) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function getDummyPayload(uint256 payloadSize) internal pure returns (bytes memory) {\n        bytes memory payload = new bytes(payloadSize);\n        for (uint256 i = 0; i < payloadSize; i++) {\n            payload[i] = bytes1(uint8(65 + i));\n        }\n        return payload;\n    }\n}\n```\n\n</details>\n\n*   If the payload is 9999 bytes the cost of saving it and emitting the event is 131k gas.\n*   Even with a smaller payload of 500 bytes the cost is 32k gas.\n\n4.  If we can drain the 985k gas in the rest of the execution since storing `failedMessages` would fail the pathway would be blocked because this will fail at the level of LayerZero and result in [`StoredPayload`](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/Endpoint.sol#L122-L123).\n\n5.  Let’s continue the execution flow just to illustrate how this would occur, inside the implementation for [`_nonblockingLzReceive`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L442) the `_executeOnDestination` is invoked for the right packet type and there we have another [external call](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L403) which delegatecalls into the right module.\n\nSince it is also an external call only 63/64 gas is forwarded which is roughly:\n\n*   970k would be forwarded to the module\n*   15k reserved for the rest of the function\n\n6.  This 970k gas is used for [`borrow`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L126), and it would be totally drained inside our [malicious GasDraining contract from above](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L187), and then the execution would continue inside the [`executeOnDestination`](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L430) which also fails due to 15k gas not being enough, and finally, it fails inside the [`_blockingLzReceive`](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/NonblockingLzApp.sol#L27) due to out of gas, resulting in blocked pathway.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\n[`_executeOnDestination` storing logic](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L430) is just code duplication and serves no purpose.\nInstead of that you should override the [`_blockingLzReceive`](https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/lzApp/NonblockingLzApp.sol#L24).\n\nCreate a new storage variable called `gasAllocation` which can be set only by the owner and change the implementation to:\n\n```solidity\n(bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft() - gasAllocation, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n```\n\nWhile ensuring that `gasleft() > gasAllocation` in each and every case. This should be enforced on the sending side.\n\nNow this is tricky because as I have shown the gas cost of storing payload varies with payload size meaning the `gasAllocation` needs to be big enough to cover storing max payload size.\n\n### Other occurrences\n\nThis exploit is possible with all the packet types which allow arbitrary execution of some code on the receiving side with something like I showed with the `GasDrainingContract`. Since almost all packets allow this it is a common issue throughout the codebase, but anyway listing below where it can occur in various places:\n\n<details>\n\n### BaseTOFT\n\n*   <https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L205>\n\n*   <https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L204>\n\n*   <https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L111>\n\n*   <https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L221>\n\n*   <https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L118>\n\n### BaseUSDO\n\n*   <https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L191>\n\n*   <https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L190>\n\n*   <https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L104>\n\n*   <https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L93>\n\n*   <https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L206>\n\n*   <https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L103>\n\n### BaseTapOFT\n\n*   <https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L225> Here we would need to pass `IERC20[] memory rewardTokens` as an array of one award token which is our malicious token which implements the `ERC20` and `ISendFrom` interfaces.\n\n</details>\n\nSince inside the `twTap.claimAndSendRewards(tokenID, rewardTokens)` there are no reverts in case the `rewardToken` is\ninvalid we can execute the gas draining attack inside the [`sendFrom`](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L229)\nwhereby `rewardTokens[i]` is our malicious contract.\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1220#issuecomment-1702980386)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/usd0/BaseUSDO.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\n//LZ\nimport \"tapioca-sdk/dist/contracts/token/oft/v2/OFTV2.sol\";\n\n//OZ\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n//TAPIOCA\nimport \"tapioca-periph/contracts/interfaces/IYieldBoxBase.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport \"tapioca-periph/contracts/interfaces/ICommonData.sol\";\n\nimport \"./BaseUSDOStorage.sol\";\nimport \"./modules/USDOLeverageModule.sol\";\nimport \"./modules/USDOMarketModule.sol\";\nimport \"./modules/USDOOptionsModule.sol\";\n\n//\n//                 .(%%%%%%%%%%%%*       *\n//             #%%%%%%%%%%%%%%%%%%%%*  ####*\n//          #%%%%%%%%%%%%%%%%%%%%%#  /####\n//       ,%%%%%%%%%%%%%%%%%%%%%%%   ####.  %\n//                                #####\n//                              #####\n//   #####%#####              *####*  ####%#####*\n//  (#########(              #####     ##########.\n//  ##########             #####.      .##########\n//                       ,####/\n//                      #####\n//  %%%%%%%%%%        (####.           *%%%%%%%%%#\n//  .%%%%%%%%%%     *####(            .%%%%%%%%%%\n//   *%%%%%%%%%%   #####             #%%%%%%%%%%\n//               (####.\n//      ,((((  ,####(          /(((((((((((((\n//        *,  #####  ,(((((((((((((((((((((\n//          (####   ((((((((((((((((((((/\n//         ####*  (((((((((((((((((((\n//                     ,**//*,.\n\n/// @title BaseUSDO contract\n/// @notice Common USDO capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseUSDO is BaseUSDOStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    USDOLeverageModule public leverageModule;\n\n    /// @notice returns the market module\n    USDOMarketModule public marketModule;\n\n    /// @notice returns the options module\n    USDOOptionsModule public optionsModule;\n\n    constructor(\n        address _lzEndpoint,\n        IYieldBoxBase _yieldBox,\n        address _owner,\n        address payable _leverageModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    ) BaseUSDOStorage(_lzEndpoint, _yieldBox) ERC20Permit(\"USDO\") {\n        leverageModule = USDOLeverageModule(_leverageModule);\n        marketModule = USDOMarketModule(_marketModule);\n        optionsModule = USDOOptionsModule(_optionsModule);\n\n        transferOwnership(_owner);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice set the max allowed USDO mintable through flashloan\n    /// @dev can only be called by the owner\n    /// @param _val the new amount\n    function setMaxFlashMintable(uint256 _val) external onlyOwner {\n        emit MaxFlashMintUpdated(maxFlashMint, _val);\n        maxFlashMint = _val;\n    }\n\n    /// @notice set the flashloan fee\n    /// @dev can only be called by the owner\n    /// @param _val the new fee\n    function setFlashMintFee(uint256 _val) external onlyOwner {\n        require(_val < FLASH_MINT_FEE_PRECISION, \"USDO: fee too big\");\n        emit FlashMintFeeUpdated(flashMintFee, _val);\n        flashMintFee = _val;\n    }\n\n    /// @notice set the Conservator address\n    /// @dev conservator can pause the contract\n    /// @param _conservator the new address\n    function setConservator(address _conservator) external onlyOwner {\n        require(_conservator != address(0), \"USDO: address not valid\");\n        emit ConservatorUpdated(conservator, _conservator);\n        conservator = _conservator;\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"USDO: unauthorized\");\n        require(val != paused, \"USDO: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    /// @notice sets/unsets address as minter\n    /// @dev can only be called by the owner\n    /// @param _for role receiver\n    /// @param _status true/false\n    function setMinterStatus(address _for, bool _status) external onlyOwner {\n        allowedMinter[_getChainId()][_for] = _status;\n        emit SetMinterStatus(_for, _status);\n    }\n\n    /// @notice sets/unsets address as burner\n    /// @dev can only be called by the owner\n    /// @param _for role receiver\n    /// @param _status true/false\n    function setBurnerStatus(address _for, bool _status) external onlyOwner {\n        allowedBurner[_getChainId()][_for] = _status;\n        emit SetBurnerStatus(_for, _status);\n    }\n\n    // ************************ //\n    // *** VIEW FUNCTIONS *** //\n    // ************************ //\n    /// @notice returns token's decimals\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                USDOOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                USDOOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits multiHopBuyCollateral\n    /// @param from The user who sells\n    /// @param collateralAmount Extra collateral to be added\n    /// @param borrowAmount Borrowed amount that will be swapped into collateral\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param approvals array\n    function initMultiHopBuy(\n        address from,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                USDOLeverageModule.initMultiHopBuy.selector,\n                from,\n                collateralAmount,\n                borrowAmount,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeAssetAndRepay on Magnetar from the destination layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param adapterParams LZ adapter params\n    /// @param externalData external addresses needed for the operation\n    /// @param removeAndRepayData removeAssetAndRepay params\n    /// @param approvals approvals params\n    function removeAsset(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes calldata adapterParams,\n        ICommonData.ICommonExternalContracts calldata externalData,\n        IUSDOBase.IRemoveAndRepay calldata removeAndRepayData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                USDOMarketModule.removeAsset.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                adapterParams,\n                externalData,\n                removeAndRepayData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice sends USDO to a specific chain and performs a leverage up operation\n    /// @param amount the amount to use\n    /// @param leverageFor the receiver address\n    /// @param lzData LZ specific data\n    /// @param swapData ISwapper specific data\n    /// @param externalData external contracts used for the flow\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                USDOLeverageModule.sendForLeverage.selector,\n                amount,\n                leverageFor,\n                lzData,\n                swapData,\n                externalData\n            ),\n            false\n        );\n    }\n\n    /// @notice sends to YieldBox over layer and lends asset to market\n    /// @param _from sending address\n    /// @param _to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param lendParams lend specific params\n    /// @param approvals approvals specific params\n    /// @param withdrawParams parameter to withdraw the SGL collateral\n    /// @param adapterParams adapter params of the withdrawn collateral\n    function sendAndLendOrRepay(\n        address _from,\n        address _to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        IUSDOBase.ILendOrRepayParams calldata lendParams,\n        ICommonData.IApproval[] calldata approvals,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                USDOMarketModule.sendAndLendOrRepay.selector,\n                _from,\n                _to,\n                lzDstChainId,\n                zroPaymentAddress,\n                lendParams,\n                approvals,\n                withdrawParams,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        } else if (_module == Module.Market) {\n            module = address(marketModule);\n        } else if (_module == Module.Options) {\n            module = address(optionsModule);\n        }\n\n        if (module == address(0)) {\n            revert(\"USDO: module not found\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data,\n        bool _forwardRevert\n    ) private returns (bool success, bytes memory returnData) {\n        success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success && !_forwardRevert) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeOnDestination(\n        Module _module,\n        bytes memory _data,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) private {\n        (bool success, bytes memory returnData) = _executeModule(\n            _module,\n            _data,\n            true\n        );\n        if (!success) {\n            _storeFailedMessage(\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload,\n                returnData\n            );\n        }\n    }\n\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint256 packetType = _payload.toUint256(0);\n\n        if (packetType == PT_YB_SEND_SGL_LEND_OR_REPAY) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    USDOMarketModule.lend.selector,\n                    marketModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_LEVERAGE_MARKET_UP) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    USDOLeverageModule.leverageUp.selector,\n                    leverageModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_REMOVE_ASSET) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    USDOMarketModule.remove.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_MULTIHOP_BUY) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    USDOLeverageModule.multiHop.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_TAP_EXERCISE) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    USDOOptionsModule.exercise.selector,\n                    optionsModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_SEND_FROM) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    USDOOptionsModule.sendFromDestination.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else {\n            packetType = _payload.toUint8(0);\n            if (packetType == PT_SEND) {\n                _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else if (packetType == PT_SEND_AND_CALL) {\n                _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else {\n                revert(\"OFTCoreV2: unknown packet type\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.sendToYBAndBorrow.selector,\n                from,\n                to,\n                lzDstChainId,\n                airdropAdapterParams,\n                borrowParams,\n                withdrawParams,\n                options,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a leverage down operation\n    /// @param amount the amount to use\n    /// @param leverageFor the receiver address\n    /// @param lzData LZ specific data\n    /// @param swapData ISwapper specific data\n    /// @param externalData external contracts used for the flow\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.sendForLeverage.selector,\n                amount,\n                leverageFor,\n                lzData,\n                swapData,\n                externalData\n            ),\n            false\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n\n    //---internal-\n    function _wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual {\n        if (_fromAddress != msg.sender) {\n            require(\n                allowance(_fromAddress, msg.sender) >= _amount,\n                \"TOFT_allowed\"\n            );\n        }\n        IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);\n        _mint(_toAddress, _amount);\n    }\n\n    function _wrapNative(address _toAddress) internal virtual {\n        require(msg.value > 0, \"TOFT_0\");\n        _mint(_toAddress, msg.value);\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) internal virtual {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    //---private---\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        } else if (_module == Module.Strategy) {\n            module = address(strategyModule);\n        } else if (_module == Module.Market) {\n            module = address(marketModule);\n        } else if (_module == Module.Options) {\n            module = address(optionsModule);\n        }\n\n        if (module == address(0)) {\n            revert(\"TOFT_module\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data,\n        bool _forwardRevert\n    ) private returns (bool success, bytes memory returnData) {\n        success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success && !_forwardRevert) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeOnDestination(\n        Module _module,\n        bytes memory _data,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) private {\n        (bool success, bytes memory returnData) = _executeModule(\n            _module,\n            _data,\n            true\n        );\n        if (!success) {\n            _storeFailedMessage(\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload,\n                returnData\n            );\n        }\n    }\n\n    //---LZ---\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint256 packetType = _payload.toUint256(0);\n\n        if (packetType == PT_YB_SEND_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyDeposit.selector,\n                    strategyModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload,\n                    IERC20(address(this))\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_RETRIEVE_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyWithdraw.selector,\n                    _srcChainId,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_LEVERAGE_MARKET_DOWN) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.leverageDown.selector,"
    }
  ]
}