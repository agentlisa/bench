{
  "Title": "calcExpDecayRewards is at risk of overflow reversions",
  "Content": "In the [`RewardsMath`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/RewardsMath.sol) contract the [`calcExpDecayRewards`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/RewardsMath.sol#L30) function takes `timeElapsed` and `halfLife` values as input, puts them into a `Fraction` struct, and then passes them along to the [`MathEx.exp2`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L36) function. There is a [comment in the inline documentation](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/RewardsMath.sol#L27-L29) that\n\n\n\n> because the exponentiation function is limited to an input of up to (and excluding) 16 / ln 2, the input value to this function is limited by `timeElapsed / halfLife < 16 / ln 2`\n> \n> \n\n\nThis is problematic because, for any exponential decay distribution program, `halfLife` is fixed while `timeElapsed` will continue to grow after the program is created. For any such program then, it is only a matter of time before `timeElapsed` exceeds `halfLife` by more than the required ratio to overflow a call to `exp2`.\n\n\nIf `timeElapsed / halfLife` exceeds this limit, then the call will simply [revert in the `exp2` function with an `Overflow` error](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/utility/MathEx.sol#L43). This will cause the entire transaction to revert. Since `calcExpDecayRewards` is called by the [`_tokenAmountToDistribute`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L471-L472) function, which is called by the [`_processRewards`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L378) function, no rewards for a program that reaches such a state will be possible.\n\n\nIn such a scenario where the `timeElapsed` is too large, rather than making the call to `exp2` and then reverting, consider having the `calcExpDecayRewards` function return `totalRewards` without any exponentiation calculation. This will result in minimal error (i.e., `1 * totalRewards` instead of `0.9999998874648253 * totalRewards`), but will prevent the case where a program’s rewards cannot be distributed because too much time elapses from the program’s start.\n\n\n**Update:** *Acknowledged without code changes. The client expressed that the function inputs are safe for timeframes considered practical. In the case of impractical timeframes the impact is acceptable.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/utility/MathEx.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { Fraction, InvalidFraction } from \"./Fraction.sol\";\n\nimport { PPM_RESOLUTION } from \"./Constants.sol\";\n\nuint256 constant ONE = 0x80000000000000000000000000000000;\nuint256 constant LN2 = 0x58b90bfbe8e7bcd5e4f1d9cc01f97b57;\n\nstruct Uint512 {\n    uint256 hi; // 256 most significant bits\n    uint256 lo; // 256 least significant bits\n}\n\nstruct Sint256 {\n    uint256 value;\n    bool isNeg;\n}\n\n/**\n * @dev this library provides a set of complex math operations\n */\nlibrary MathEx {\n    error Overflow();\n\n    /**\n     * @dev returns `2 ^ f` by calculating `e ^ (f * ln(2))`, where `e` is Euler's number:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function exp2(Fraction memory f) internal pure returns (Fraction memory) {\n        uint256 x = MathEx.mulDivF(LN2, f.n, f.d);\n        uint256 y;\n        uint256 z;\n        uint256 n;\n\n        if (x >= (ONE << 4)) {\n            revert Overflow();\n        }\n\n        unchecked {\n            z = y = x % (ONE >> 3); // get the input modulo 2^(-3)\n            z = (z * y) / ONE;\n            n += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n            z = (z * y) / ONE;\n            n += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n            z = (z * y) / ONE;\n            n += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n            z = (z * y) / ONE;\n            n += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n            z = (z * y) / ONE;\n            n += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n            z = (z * y) / ONE;\n            n += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n            z = (z * y) / ONE;\n            n += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n            z = (z * y) / ONE;\n            n += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n            z = (z * y) / ONE;\n            n += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n            z = (z * y) / ONE;\n            n += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n            z = (z * y) / ONE;\n            n += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n            z = (z * y) / ONE;\n            n += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n            z = (z * y) / ONE;\n            n += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n            z = (z * y) / ONE;\n            n += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n            n = n / 0x21c3677c82b40000 + y + ONE; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n            if ((x & (ONE >> 3)) != 0)\n                n = (n * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^(2^-3)\n            if ((x & (ONE >> 2)) != 0)\n                n = (n * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^(2^-2)\n            if ((x & (ONE >> 1)) != 0)\n                n = (n * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^(2^-1)\n            if ((x & (ONE << 0)) != 0)\n                n = (n * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^(2^+0)\n            if ((x & (ONE << 1)) != 0)\n                n = (n * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^(2^+1)\n            if ((x & (ONE << 2)) != 0)\n                n = (n * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^(2^+2)\n            if ((x & (ONE << 3)) != 0)\n                n = (n * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^(2^+3)\n        }\n\n        return Fraction({ n: n, d: ONE });\n    }\n\n    /**\n     * @dev returns a fraction with reduced components\n     */\n    function reducedFraction(Fraction memory fraction, uint256 max) internal pure returns (Fraction memory) {\n        uint256 scale = Math.ceilDiv(Math.max(fraction.n, fraction.d), max);\n        Fraction memory reduced = Fraction({ n: fraction.n / scale, d: fraction.d / scale });\n        if (reduced.d == 0) {\n            revert InvalidFraction();\n        }\n\n        return reduced;\n    }\n\n    /**\n     * @dev returns the weighted average of two fractions\n     */\n    function weightedAverage(\n        Fraction memory fraction1,\n        Fraction memory fraction2,\n        uint256 weight1,\n        uint256 weight2\n    ) internal pure returns (Fraction memory) {\n        return\n            Fraction({\n                n: fraction1.n * fraction2.d * weight1 + fraction1.d * fraction2.n * weight2,\n                d: fraction1.d * fraction2.d * (weight1 + weight2)\n            });\n    }\n\n    /**\n     * @dev returns whether or not the deviation of an offset sample from a base sample is within a permitted range\n     * for example, if the maximum permitted deviation is 5%, then evaluate `95% * base <= offset <= 105% * base`\n     */\n    function isInRange(\n        Fraction memory baseSample,\n        Fraction memory offsetSample,\n        uint32 maxDeviationPPM\n    ) internal pure returns (bool) {\n        Uint512 memory min = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION - maxDeviationPPM));\n        Uint512 memory mid = mul512(baseSample.d, offsetSample.n * PPM_RESOLUTION);\n        Uint512 memory max = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION + maxDeviationPPM));\n        return lte512(min, mid) && lte512(mid, max);\n    }\n\n    /**\n     * @dev returns an `Sint256` positive representation of an unsigned integer\n     */\n    function toPos256(uint256 n) internal pure returns (Sint256 memory) {\n        return Sint256({ value: n, isNeg: false });\n    }\n\n    /**\n     * @dev returns an `Sint256` negative representation of an unsigned integer\n     */\n    function toNeg256(uint256 n) internal pure returns (Sint256 memory) {\n        return Sint256({ value: n, isNeg: true });\n    }\n\n    /**\n     * @dev returns the largest integer smaller than or equal to `x * y / z`\n     */\n    function mulDivF(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        Uint512 memory xy = mul512(x, y);\n\n        // if `x * y < 2 ^ 256`\n        if (xy.hi == 0) {\n            return xy.lo / z;\n        }\n\n        // assert `x * y / z < 2 ^ 256`\n        if (xy.hi >= z) {\n            revert Overflow();\n        }\n\n        uint256 m = _mulMod(x, y, z); // `m = x * y % z`\n        Uint512 memory n = _sub512(xy, m); // `n = x * y - m` hence `n / z = floor(x * y / z)`\n\n        // if `n < 2 ^ 256`\n        if (n.hi == 0) {\n            return n.lo / z;\n        }\n\n        uint256 p = _unsafeSub(0, z) & z; // `p` is the largest power of 2 which `z` is divisible by\n        uint256 q = _div512(n, p); // `n` is divisible by `p` because `n` is divisible by `z` and `z` is divisible by `p`\n        uint256 r = _inv256(z / p); // `z / p = 1 mod 2` hence `inverse(z / p) = 1 mod 2 ^ 256`\n        return _unsafeMul(q, r); // `q * r = (n / p) * inverse(z / p) = n / z`\n    }\n\n    /**\n     * @dev returns the smallest integer larger than or equal to `x * y / z`\n     */\n    function mulDivC(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256) {\n        uint256 w = mulDivF(x, y, z);\n        if (_mulMod(x, y, z) > 0) {\n            if (w >= type(uint256).max) {\n                revert Overflow();\n            }\n\n            return w + 1;\n        }\n        return w;\n    }\n\n    /**\n     * @dev returns the maximum of `n1 - n2` and 0\n     */\n    function subMax0(uint256 n1, uint256 n2) internal pure returns (uint256) {\n        return n1 > n2 ? n1 - n2 : 0;\n    }\n\n    /**\n     * @dev returns the value of `x > y`\n     */\n    function gt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return x.hi > y.hi || (x.hi == y.hi && x.lo > y.lo);\n    }\n\n    /**\n     * @dev returns the value of `x < y`\n     */\n    function lt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return x.hi < y.hi || (x.hi == y.hi && x.lo < y.lo);\n    }\n\n    /**\n     * @dev returns the value of `x >= y`\n     */\n    function gte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return !lt512(x, y);\n    }\n\n    /**\n     * @dev returns the value of `x <= y`\n     */\n    function lte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\n        return !gt512(x, y);\n    }\n\n    /**\n     * @dev returns the value of `x * y`\n     */\n    function mul512(uint256 x, uint256 y) internal pure returns (Uint512 memory) {\n        uint256 p = _mulModMax(x, y);\n        uint256 q = _unsafeMul(x, y);\n        if (p >= q) {\n            return Uint512({ hi: p - q, lo: q });\n        }\n        return Uint512({ hi: _unsafeSub(p, q) - 1, lo: q });\n    }\n\n    /**\n     * @dev returns the value of `x - y`, given that `x >= y`\n     */\n    function _sub512(Uint512 memory x, uint256 y) private pure returns (Uint512 memory) {\n        if (x.lo >= y) {\n            return Uint512({ hi: x.hi, lo: x.lo - y });\n        }\n        return Uint512({ hi: x.hi - 1, lo: _unsafeSub(x.lo, y) });\n    }\n\n    /**\n     * @dev returns the value of `x / pow2n`, given that `x` is divisible by `pow2n`\n     */\n    function _div512(Uint512 memory x, uint256 pow2n) private pure returns (uint256) {\n        uint256 pow2nInv = _unsafeAdd(_unsafeSub(0, pow2n) / pow2n, 1); // `1 << (256 - n)`\n        return _unsafeMul(x.hi, pow2nInv) | (x.lo / pow2n); // `(x.hi << (256 - n)) | (x.lo >> n)`\n    }\n\n    /**\n     * @dev returns the inverse of `d` modulo `2 ^ 256`, given that `d` is congruent to `1` modulo `2`\n     */\n    function _inv256(uint256 d) private pure returns (uint256) {\n        // approximate the root of `f(x) = 1 / x - d` using the newton–raphson convergence method\n        uint256 x = 1;\n        for (uint256 i = 0; i < 8; i++) {\n            x = _unsafeMul(x, _unsafeSub(2, _unsafeMul(x, d))); // `x = x * (2 - x * d) mod 2 ^ 256`\n        }\n        return x;\n    }\n\n    /**\n     * @dev returns `(x + y) % 2 ^ 256`\n     */\n    function _unsafeAdd(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x + y;\n        }\n    }\n\n    /**\n     * @dev returns `(x - y) % 2 ^ 256`\n     */\n    function _unsafeSub(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x - y;\n        }\n    }\n\n    /**\n     * @dev returns `(x * y) % 2 ^ 256`\n     */\n    function _unsafeMul(uint256 x, uint256 y) private pure returns (uint256) {\n        unchecked {\n            return x * y;\n        }\n    }\n\n    /**\n     * @dev returns `x * y % (2 ^ 256 - 1)`\n     */\n    function _mulModMax(uint256 x, uint256 y) private pure returns (uint256) {\n        return mulmod(x, y, type(uint256).max);\n    }\n\n    /**\n     * @dev returns `x * y % z`\n     */\n    function _mulMod(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) private pure returns (uint256) {\n        return mulmod(x, y, z);\n    }\n}"
    }
  ]
}