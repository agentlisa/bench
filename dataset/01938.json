{
  "Title": "M-6: Lack of burn mechanism for JUSD repayments causes oversupply of JUSD",
  "Content": "# Issue M-6: Lack of burn mechanism for JUSD repayments causes oversupply of JUSD \n\nSource: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/306 \n\n## Found by \nRuhum, igingu, immeas, peakbolt\n## Summary\n\n`JUSDBank.repay()` allow users to repay their JUSD debt and interest by transfering in JUSD tokens. Without a burn mechanism, it will cause an oversupply of JUSD that is no longer backed by any collateral.\n\n\n\n\n## Vulnerability Detail\n\n`JUSDBank` receives JUSD tokens for the repayment of debt and interest. However, there are no means to burn these tokens, causing JUSD balance in JUSDBank to keep increasing. \n\nThat will lead to an oversupply of JUSD that is not backed by any collateral. And the oversupply of JUSD will increase significantly during market due to mass repayments from liquidation.\n\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L307-L330\n```Solidity\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n```\n\n## Impact\n\nTo maintain its stability, JUSD must always be backed by more than 1 USD worth of collateral. \n\nWhen there is oversupply of JUSD that is not backed by any collateral, it affects JUSD stability and possibly lead to a depeg event.\n\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L307-L330\n\n\n## Tool used\nManual review\n\n## Recommendation\nInstead of transfering to the JUSDBank upon repayment, consider adding a burn mechanism to reduce the supply of JUSD so that it will be adjusted automatically.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nWill add burn mechanism in the contract\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/JUSDV1/commit/a72604efba3a9cbce997aefde742be4c5036a039\n\n**IAm0x52**\n\nFix looks good. Excess JUSD can now be refunded by the owner\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/70",
  "Code": [
    {
      "filename": "JUSDV1/src/Impl/JUSDBank.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity 0.8.9;\n\nimport \"../Interface/IJUSDBank.sol\";\nimport \"../Interface/IFlashLoanReceive.sol\";\nimport \"./JUSDBankStorage.sol\";\nimport \"./JUSDOperation.sol\";\nimport \"./JUSDView.sol\";\nimport \"./JUSDMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@JOJO/contracts/intf/IDealer.sol\";\nimport {IPriceChainLink} from \"../Interface/IPriceChainLink.sol\";\n\ncontract JUSDBank is IJUSDBank, JUSDOperation, JUSDView, JUSDMulticall {\n    using DecimalMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        maxReservesNum = _maxReservesNum;\n        JUSD = _JUSD;\n        JOJODealer = _JOJODealer;\n        insurance = _insurance;\n        maxPerAccountBorrowAmount = _maxPerAccountBorrowAmount;\n        maxTotalBorrowAmount = _maxTotalBorrowAmount;\n        borrowFeeRate = _borrowFeeRate;\n        t0Rate = JOJOConstant.ONE;\n        primaryAsset = _primaryAsset;\n        lastUpdateTimestamp = uint32(block.timestamp);\n    }\n\n    // --------------------------event-----------------------\n\n    event HandleBadDebt(address indexed liquidatedTrader, uint256 borrowJUSDT0);\n    event Deposit(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        address operator,\n        uint256 amount\n    );\n    event Borrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool isDepositToJOJO\n    );\n    event Repay(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool ifInternal\n    );\n    event Liquidate(\n        address indexed collateral,\n        address indexed liquidator,\n        address indexed liquidated,\n        address operator,\n        uint256 collateralAmount,\n        uint256 liquidatedAmount,\n        uint256 insuranceFee\n    );\n    event FlashLoan(address indexed collateral, uint256 amount);\n\n    /// @notice to ensure msg.sender is from account or msg.sender is the sub account of from\n    /// so that msg.sender can send the transaction\n    modifier isValidOperator(address operator, address client) {\n        require(\n            msg.sender == client || operatorRegistry[client][operator],\n            JUSDErrors.CAN_NOT_OPERATE_ACCOUNT\n        );\n        _;\n    }\n    modifier isLiquidator(address liquidator) {\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], \"liquidator is not in the liquidator white list\");\n        }\n        _;\n    }\n\n    function deposit(\n        address from,\n        address collateral,\n        uint256 amount,\n        address to\n    ) external override nonReentrant isValidOperator(msg.sender, from) {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage user = userInfo[to];\n        //        deposit\n        _deposit(reserve, user, amount, collateral, to, from);\n    }\n\n    function borrow(\n        uint256 amount,\n        address to,\n        bool isDepositToJOJO\n    ) external override nonReentrant nonFlashLoanReentrant{\n        //     t0BorrowedAmount = borrowedAmount /  getT0Rate\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n        require(\n            _isAccountSafeAfterBorrow(user, getTRate()),\n            JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function repay(\n        uint256 amount,\n        address to\n    ) external override nonReentrant returns (uint256) {\n        DataTypes.UserInfo storage user = userInfo[to];\n        uint256 tRate = getTRate();\n        return _repay(user, msg.sender, to, amount, tRate);\n    }\n\n    function withdraw(\n        address collateral,\n        uint256 amount,\n        address to,\n        bool isInternal\n    ) external override nonReentrant nonFlashLoanReentrant{\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, to, msg.sender, isInternal);\n        uint256 tRate = getTRate();\n        require(\n            _isAccountSafe(user, tRate),\n            JUSDErrors.AFTER_WITHDRAW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function liquidate(\n        address liquidated,\n        address collateral,\n        address liquidator,\n        uint256 amount,\n        bytes memory afterOperationParam,\n        uint256 expectPrice\n    )\n        external\n        override\n        isValidOperator(msg.sender, liquidator)\n        nonFlashLoanReentrant\n        returns (DataTypes.LiquidateData memory liquidateData)\n    {\n        uint256 JUSDBorrowedT0 = userInfo[liquidated].t0BorrowBalance;\n        uint256 primaryLiquidatedAmount = IERC20(primaryAsset).balanceOf(\n            liquidated\n        );\n        uint256 primaryInsuranceAmount = IERC20(primaryAsset).balanceOf(\n            insurance\n        );\n        isValidLiquidator(liquidated, liquidator);\n        // 1. calculate the liquidate amount\n        liquidateData = _calculateLiquidateAmount(\n            liquidated,\n            collateral,\n            amount\n        );\n        require(\n        // condition: actual liquidate price < max buy price,\n        // price lower, better\n            (liquidateData.insuranceFee + liquidateData.actualLiquidated).decimalDiv(liquidateData.actualCollateral)\n                <= expectPrice,\n            JUSDErrors.LIQUIDATION_PRICE_PROTECTION\n        );\n        // 2. after liquidation flashloan operation\n        _afterLiquidateOperation(\n            afterOperationParam,\n            amount,\n            collateral,\n            liquidated,\n            liquidateData\n        );\n\n        // 3. price protect\n        require(\n            JUSDBorrowedT0 - userInfo[liquidated].t0BorrowBalance >=\n                liquidateData.actualLiquidatedT0,\n            JUSDErrors.REPAY_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(insurance) -\n                primaryInsuranceAmount >=\n                liquidateData.insuranceFee,\n            JUSDErrors.INSURANCE_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n        emit Liquidate(\n            collateral,\n            liquidator,\n            liquidated,\n            msg.sender,\n            liquidateData.actualCollateral,\n            liquidateData.actualLiquidated,\n            liquidateData.insuranceFee\n        );\n    }\n\n    function handleDebt(\n        address[] calldata liquidatedTraders\n    ) external onlyOwner {\n        for (uint256 i; i < liquidatedTraders.length; i = i + 1) {\n            _handleBadDebt(liquidatedTraders[i]);\n        }\n    }\n\n    function flashLoan(\n        address receiver,\n        address collateral,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external nonFlashLoanReentrant {\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, receiver, msg.sender, false);\n        // repay\n        IFlashLoanReceive(receiver).JOJOFlashLoan(\n            collateral,\n            amount,\n            to,\n            param\n        );\n        require(\n            _isAccountSafe(user, getTRate()),\n            JUSDErrors.AFTER_FLASHLOAN_ACCOUNT_IS_NOT_SAFE\n        );\n        emit FlashLoan(collateral, amount);\n    }\n\n    function _deposit(\n        DataTypes.ReserveInfo storage reserve,\n        DataTypes.UserInfo storage user,\n        uint256 amount,\n        address collateral,\n        address to,\n        address from\n    ) internal {\n        require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n        require(amount != 0, JUSDErrors.DEPOSIT_AMOUNT_IS_ZERO);\n        IERC20(collateral).safeTransferFrom(from, address(this), amount);\n        _addCollateralIfNotExists(user, collateral);\n        user.depositBalance[collateral] += amount;\n        reserve.totalDepositAmount += amount;\n        require(\n            user.depositBalance[collateral] <=\n                reserve.maxDepositAmountPerAccount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n        );\n        require(\n            reserve.totalDepositAmount <= reserve.maxTotalDepositAmount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_TOTAL\n        );\n        emit Deposit(collateral, from, to, msg.sender, amount);\n    }\n\n    //    Pass parameter checking, excluding checking legality\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n        t0TotalBorrowAmount += t0Amount;\n        if (isDepositToJOJO) {\n            IERC20(JUSD).approve(address(JOJODealer), tAmount);\n            IDealer(JOJODealer).deposit(0, tAmount, to);\n        } else {\n            IERC20(JUSD).safeTransfer(to, tAmount);\n        }\n        // Personal account hard cap\n        require(\n            user.t0BorrowBalance.decimalMul(tRate) <= maxPerAccountBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_PER_ACCOUNT\n        );\n        // Global account hard cap\n        require(\n            t0TotalBorrowAmount.decimalMul(tRate) <= maxTotalBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_TOTAL\n        );\n        emit Borrow(from, to, tAmount, isDepositToJOJO);\n    }\n\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n\n    function _withdraw(\n        uint256 amount,\n        address collateral,\n        address to,\n        address from,\n        bool isInternal\n    ) internal {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage fromAccount = userInfo[from];\n        require(amount != 0, JUSDErrors.WITHDRAW_AMOUNT_IS_ZERO);\n        require(\n            amount <= fromAccount.depositBalance[collateral],\n            JUSDErrors.WITHDRAW_AMOUNT_IS_TOO_BIG\n        );\n\n        fromAccount.depositBalance[collateral] -= amount;\n        if (isInternal) {\n            DataTypes.UserInfo storage toAccount = userInfo[to];\n            _addCollateralIfNotExists(toAccount, collateral);\n            toAccount.depositBalance[collateral] += amount;\n            require(\n                toAccount.depositBalance[collateral] <=\n                    reserve.maxDepositAmountPerAccount,\n                JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n            );\n        } else {\n            reserve.totalDepositAmount -= amount;\n            IERC20(collateral).safeTransfer(to, amount);\n        }\n        emit Withdraw(collateral, from, to, amount, isInternal);\n        _removeEmptyCollateral(fromAccount, collateral);\n    }\n\n    function isValidLiquidator(address liquidated, address liquidator) internal view {\n        require(\n            liquidator != liquidated,\n            JUSDErrors.SELF_LIQUIDATION_NOT_ALLOWED\n        );\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], JUSDErrors.LIQUIDATOR_NOT_IN_THE_WHITELIST);\n        }\n    }\n\n    /// @notice liquidate is divided into three steps,\n    // 1. determine whether liquidatedTrader is safe\n    // 2. calculate the collateral amount actually liquidated\n    // 3. transfer the insurance fee\n    function _calculateLiquidateAmount(\n        address liquidated,\n        address collateral,\n        uint256 amount\n    ) internal view returns (DataTypes.LiquidateData memory liquidateData) {\n        DataTypes.UserInfo storage liquidatedInfo = userInfo[liquidated];\n        require(amount != 0, JUSDErrors.LIQUIDATE_AMOUNT_IS_ZERO);\n        require(\n            amount <= liquidatedInfo.depositBalance[collateral],\n            JUSDErrors.LIQUIDATE_AMOUNT_IS_TOO_BIG\n        );\n        uint256 tRate = getTRate();\n        require(\n            _isStartLiquidation(liquidatedInfo, tRate),\n            JUSDErrors.ACCOUNT_IS_SAFE\n        );\n        DataTypes.ReserveInfo memory reserve = reserveInfo[collateral];\n        uint256 price = IPriceChainLink(reserve.oracle).getAssetPrice();\n        uint256 priceOff = price.decimalMul(\n            DecimalMath.ONE - reserve.liquidationPriceOff\n        );\n        uint256 liquidateAmount = amount.decimalMul(priceOff).decimalMul(\n            JOJOConstant.ONE - reserve.insuranceFeeRate\n        );\n        uint256 JUSDBorrowed = liquidatedInfo.t0BorrowBalance.decimalMul(tRate);\n        /*\n        liquidateAmount <= JUSDBorrowed\n        liquidateAmount = amount * priceOff * (1-insuranceFee)\n        actualJUSD = actualCollateral * priceOff\n        insuranceFee = actualCollateral * priceOff * insuranceFeeRate\n        */\n        if (liquidateAmount <= JUSDBorrowed) {\n            liquidateData.actualCollateral = amount;\n            liquidateData.insuranceFee = amount.decimalMul(priceOff).decimalMul(\n                reserve.insuranceFeeRate\n            );\n            liquidateData.actualLiquidatedT0 = liquidateAmount.decimalDiv(\n                tRate\n            );\n            liquidateData.actualLiquidated = liquidateAmount;\n        } else {\n            //            actualJUSD = actualCollateral * priceOff\n            //            = JUSDBorrowed * priceOff / priceOff * (1-insuranceFeeRate)\n            //            = JUSDBorrowed / (1-insuranceFeeRate)\n            //            insuranceFee = actualJUSD * insuranceFeeRate\n            //            = actualCollateral * priceOff * insuranceFeeRate\n            //            = JUSDBorrowed * insuranceFeeRate / (1- insuranceFeeRate)\n            liquidateData.actualCollateral = JUSDBorrowed\n                .decimalDiv(priceOff)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.insuranceFee = JUSDBorrowed\n                .decimalMul(reserve.insuranceFeeRate)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.actualLiquidatedT0 = liquidatedInfo.t0BorrowBalance;\n            liquidateData.actualLiquidated = JUSDBorrowed;\n        }\n\n        liquidateData.liquidatedRemainUSDC = (amount -\n            liquidateData.actualCollateral).decimalMul(price);\n    }\n\n    function _addCollateralIfNotExists(\n        DataTypes.UserInfo storage user,\n        address collateral\n    ) internal {\n        if (!user.hasCollateral[collateral]) {\n            user.hasCollateral[collateral] = true;\n            user.collateralList.push(collateral);\n        }\n    }\n\n    function _removeEmptyCollateral(\n        DataTypes.UserInfo storage user,\n        address collateral\n    ) internal {\n        if (user.depositBalance[collateral] == 0) {\n            user.hasCollateral[collateral] = false;\n            address[] storage collaterals = user.collateralList;\n            for (uint256 i; i < collaterals.length; i = i + 1) {\n                if (collaterals[i] == collateral) {\n                    collaterals[i] = collaterals[collaterals.length - 1];\n                    collaterals.pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    function _afterLiquidateOperation(\n        bytes memory afterOperationParam,\n        uint256 flashloanAmount,\n        address collateral,\n        address liquidated,\n        DataTypes.LiquidateData memory liquidateData\n    ) internal {\n        (address flashloanAddress, bytes memory param) = abi.decode(\n            afterOperationParam,\n            (address, bytes)\n        );\n        _withdraw(\n            flashloanAmount,\n            collateral,\n            flashloanAddress,\n            liquidated,\n            false\n        );\n        param = abi.encode(liquidateData, param);\n        IFlashLoanReceive(flashloanAddress).JOJOFlashLoan(\n            collateral,\n            flashloanAmount,\n            liquidated,\n            param\n        );\n    }\n\n    /// @notice handle the bad debt\n    /// @param liquidatedTrader need to be liquidated\n    function _handleBadDebt(address liquidatedTrader) internal {\n        DataTypes.UserInfo storage liquidatedTraderInfo = userInfo[\n            liquidatedTrader\n        ];\n        uint256 tRate = getTRate();\n        if (\n            liquidatedTraderInfo.collateralList.length == 0 &&\n            _isStartLiquidation(liquidatedTraderInfo, tRate)\n        ) {\n            DataTypes.UserInfo storage insuranceInfo = userInfo[insurance];\n            uint256 borrowJUSDT0 = liquidatedTraderInfo.t0BorrowBalance;\n            insuranceInfo.t0BorrowBalance += borrowJUSDT0;\n            liquidatedTraderInfo.t0BorrowBalance = 0;\n            emit HandleBadDebt(liquidatedTrader, borrowJUSDT0);\n        }\n    }\n}"
    },
    {
      "filename": "JUSDV1/src/Impl/JUSDBank.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity 0.8.9;\n\nimport \"../Interface/IJUSDBank.sol\";\nimport \"../Interface/IFlashLoanReceive.sol\";\nimport \"./JUSDBankStorage.sol\";\nimport \"./JUSDOperation.sol\";\nimport \"./JUSDView.sol\";\nimport \"./JUSDMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@JOJO/contracts/intf/IDealer.sol\";\nimport {IPriceChainLink} from \"../Interface/IPriceChainLink.sol\";\n\ncontract JUSDBank is IJUSDBank, JUSDOperation, JUSDView, JUSDMulticall {\n    using DecimalMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        maxReservesNum = _maxReservesNum;\n        JUSD = _JUSD;\n        JOJODealer = _JOJODealer;\n        insurance = _insurance;\n        maxPerAccountBorrowAmount = _maxPerAccountBorrowAmount;\n        maxTotalBorrowAmount = _maxTotalBorrowAmount;\n        borrowFeeRate = _borrowFeeRate;\n        t0Rate = JOJOConstant.ONE;\n        primaryAsset = _primaryAsset;\n        lastUpdateTimestamp = uint32(block.timestamp);\n    }\n\n    // --------------------------event-----------------------\n\n    event HandleBadDebt(address indexed liquidatedTrader, uint256 borrowJUSDT0);\n    event Deposit(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        address operator,\n        uint256 amount\n    );\n    event Borrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool isDepositToJOJO\n    );\n    event Repay(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool ifInternal\n    );\n    event Liquidate(\n        address indexed collateral,\n        address indexed liquidator,\n        address indexed liquidated,\n        address operator,\n        uint256 collateralAmount,\n        uint256 liquidatedAmount,\n        uint256 insuranceFee\n    );\n    event FlashLoan(address indexed collateral, uint256 amount);\n\n    /// @notice to ensure msg.sender is from account or msg.sender is the sub account of from\n    /// so that msg.sender can send the transaction\n    modifier isValidOperator(address operator, address client) {\n        require(\n            msg.sender == client || operatorRegistry[client][operator],\n            JUSDErrors.CAN_NOT_OPERATE_ACCOUNT\n        );\n        _;\n    }\n    modifier isLiquidator(address liquidator) {\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], \"liquidator is not in the liquidator white list\");\n        }\n        _;\n    }\n\n    function deposit(\n        address from,\n        address collateral,\n        uint256 amount,\n        address to\n    ) external override nonReentrant isValidOperator(msg.sender, from) {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage user = userInfo[to];\n        //        deposit\n        _deposit(reserve, user, amount, collateral, to, from);\n    }\n\n    function borrow(\n        uint256 amount,\n        address to,\n        bool isDepositToJOJO\n    ) external override nonReentrant nonFlashLoanReentrant{\n        //     t0BorrowedAmount = borrowedAmount /  getT0Rate\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n        require(\n            _isAccountSafeAfterBorrow(user, getTRate()),\n            JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function repay(\n        uint256 amount,\n        address to\n    ) external override nonReentrant returns (uint256) {\n        DataTypes.UserInfo storage user = userInfo[to];\n        uint256 tRate = getTRate();\n        return _repay(user, msg.sender, to, amount, tRate);\n    }\n\n    function withdraw(\n        address collateral,\n        uint256 amount,\n        address to,\n        bool isInternal\n    ) external override nonReentrant nonFlashLoanReentrant{\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, to, msg.sender, isInternal);\n        uint256 tRate = getTRate();\n        require(\n            _isAccountSafe(user, tRate),\n            JUSDErrors.AFTER_WITHDRAW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function liquidate(\n        address liquidated,\n        address collateral,\n        address liquidator,\n        uint256 amount,\n        bytes memory afterOperationParam,\n        uint256 expectPrice\n    )\n        external\n        override\n        isValidOperator(msg.sender, liquidator)\n        nonFlashLoanReentrant\n        returns (DataTypes.LiquidateData memory liquidateData)\n    {\n        uint256 JUSDBorrowedT0 = userInfo[liquidated].t0BorrowBalance;\n        uint256 primaryLiquidatedAmount = IERC20(primaryAsset).balanceOf(\n            liquidated\n        );\n        uint256 primaryInsuranceAmount = IERC20(primaryAsset).balanceOf(\n            insurance\n        );\n        isValidLiquidator(liquidated, liquidator);\n        // 1. calculate the liquidate amount\n        liquidateData = _calculateLiquidateAmount(\n            liquidated,\n            collateral,\n            amount\n        );\n        require(\n        // condition: actual liquidate price < max buy price,\n        // price lower, better\n            (liquidateData.insuranceFee + liquidateData.actualLiquidated).decimalDiv(liquidateData.actualCollateral)\n                <= expectPrice,\n            JUSDErrors.LIQUIDATION_PRICE_PROTECTION\n        );\n        // 2. after liquidation flashloan operation\n        _afterLiquidateOperation(\n            afterOperationParam,\n            amount,\n            collateral,\n            liquidated,\n            liquidateData\n        );\n\n        // 3. price protect\n        require(\n            JUSDBorrowedT0 - userInfo[liquidated].t0BorrowBalance >=\n                liquidateData.actualLiquidatedT0,\n            JUSDErrors.REPAY_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(insurance) -\n                primaryInsuranceAmount >=\n                liquidateData.insuranceFee,\n            JUSDErrors.INSURANCE_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n        emit Liquidate(\n            collateral,\n            liquidator,\n            liquidated,\n            msg.sender,\n            liquidateData.actualCollateral,\n            liquidateData.actualLiquidated,\n            liquidateData.insuranceFee\n        );\n    }\n\n    function handleDebt(\n        address[] calldata liquidatedTraders\n    ) external onlyOwner {\n        for (uint256 i; i < liquidatedTraders.length; i = i + 1) {\n            _handleBadDebt(liquidatedTraders[i]);\n        }\n    }\n\n    function flashLoan(\n        address receiver,\n        address collateral,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external nonFlashLoanReentrant {\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, receiver, msg.sender, false);\n        // repay\n        IFlashLoanReceive(receiver).JOJOFlashLoan(\n            collateral,\n            amount,\n            to,\n            param\n        );\n        require(\n            _isAccountSafe(user, getTRate()),\n            JUSDErrors.AFTER_FLASHLOAN_ACCOUNT_IS_NOT_SAFE\n        );\n        emit FlashLoan(collateral, amount);\n    }\n\n    function _deposit(\n        DataTypes.ReserveInfo storage reserve,\n        DataTypes.UserInfo storage user,\n        uint256 amount,\n        address collateral,\n        address to,\n        address from\n    ) internal {\n        require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n        require(amount != 0, JUSDErrors.DEPOSIT_AMOUNT_IS_ZERO);\n        IERC20(collateral).safeTransferFrom(from, address(this), amount);\n        _addCollateralIfNotExists(user, collateral);\n        user.depositBalance[collateral] += amount;\n        reserve.totalDepositAmount += amount;\n        require(\n            user.depositBalance[collateral] <=\n                reserve.maxDepositAmountPerAccount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n        );\n        require(\n            reserve.totalDepositAmount <= reserve.maxTotalDepositAmount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_TOTAL\n        );\n        emit Deposit(collateral, from, to, msg.sender, amount);\n    }\n\n    //    Pass parameter checking, excluding checking legality\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n        t0TotalBorrowAmount += t0Amount;\n        if (isDepositToJOJO) {\n            IERC20(JUSD).approve(address(JOJODealer), tAmount);\n            IDealer(JOJODealer).deposit(0, tAmount, to);\n        } else {\n            IERC20(JUSD).safeTransfer(to, tAmount);\n        }\n        // Personal account hard cap\n        require(\n            user.t0BorrowBalance.decimalMul(tRate) <= maxPerAccountBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_PER_ACCOUNT\n        );\n        // Global account hard cap\n        require(\n            t0TotalBorrowAmount.decimalMul(tRate) <= maxTotalBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_TOTAL\n        );\n        emit Borrow(from, to, tAmount, isDepositToJOJO);\n    }\n\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n\n    function _withdraw(\n        uint256 amount,\n        address collateral,\n        address to,\n        address from,\n        bool isInternal\n    ) internal {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage fromAccount = userInfo[from];\n        require(amount != 0, JUSDErrors.WITHDRAW_AMOUNT_IS_ZERO);\n        require(\n            amount <= fromAccount.depositBalance[collateral],\n            JUSDErrors.WITHDRAW_AMOUNT_IS_TOO_BIG\n        );\n\n        fromAccount.depositBalance[collateral] -= amount;\n        if (isInternal) {\n            DataTypes.UserInfo storage toAccount = userInfo[to];\n            _addCollateralIfNotExists(toAccount, collateral);\n            toAccount.depositBalance[collateral] += amount;\n            require(\n                toAccount.depositBalance[collateral] <=\n                    reserve.maxDepositAmountPerAccount,\n                JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n            );\n        } else {\n            reserve.totalDepositAmount -= amount;\n            IERC20(collateral).safeTransfer(to, amount);\n        }\n        emit Withdraw(collateral, from, to, amount, isInternal);\n        _removeEmptyCollateral(fromAccount, collateral);\n    }\n\n    function isValidLiquidator(address liquidated, address liquidator) internal view {\n        require(\n            liquidator != liquidated,\n            JUSDErrors.SELF_LIQUIDATION_NOT_ALLOWED\n        );\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], JUSDErrors.LIQUIDATOR_NOT_IN_THE_WHITELIST);\n        }\n    }\n\n    /// @notice liquidate is divided into three steps,\n    // 1. determine whether liquidatedTrader is safe\n    // 2. calculate the collateral amount actually liquidated\n    // 3. transfer the insurance fee\n    function _calculateLiquidateAmount(\n        address liquidated,\n        address collateral,\n        uint256 amount\n    ) internal view returns (DataTypes.LiquidateData memory liquidateData) {\n        DataTypes.UserInfo storage liquidatedInfo = userInfo[liquidated];\n        require(amount != 0, JUSDErrors.LIQUIDATE_AMOUNT_IS_ZERO);\n        require(\n            amount <= liquidatedInfo.depositBalance[collateral],\n            JUSDErrors.LIQUIDATE_AMOUNT_IS_TOO_BIG\n        );\n        uint256 tRate = getTRate();\n        require(\n            _isStartLiquidation(liquidatedInfo, tRate),\n            JUSDErrors.ACCOUNT_IS_SAFE\n        );\n        DataTypes.ReserveInfo memory reserve = reserveInfo[collateral];\n        uint256 price = IPriceChainLink(reserve.oracle).getAssetPrice();\n        uint256 priceOff = price.decimalMul(\n            DecimalMath.ONE - reserve.liquidationPriceOff\n        );\n        uint256 liquidateAmount = amount.decimalMul(priceOff).decimalMul(\n            JOJOConstant.ONE - reserve.insuranceFeeRate\n        );\n        uint256 JUSDBorrowed = liquidatedInfo.t0BorrowBalance.decimalMul(tRate);\n        /*\n        liquidateAmount <= JUSDBorrowed\n        liquidateAmount = amount * priceOff * (1-insuranceFee)\n        actualJUSD = actualCollateral * priceOff\n        insuranceFee = actualCollateral * priceOff * insuranceFeeRate\n        */\n        if (liquidateAmount <= JUSDBorrowed) {\n            liquidateData.actualCollateral = amount;\n            liquidateData.insuranceFee = amount.decimalMul(priceOff).decimalMul(\n                reserve.insuranceFeeRate\n            );\n            liquidateData.actualLiquidatedT0 = liquidateAmount.decimalDiv("
    }
  ]
}