{
  "Title": "Malfunction of the `collect_dust` function after the `owner` revocation",
  "Content": "##### Description\nhttps://github.com/banteg/yearn-vesting-escrow/blob/945b5ca09d8bb2d2ad9132df7368cb4992496f6a/contracts/VestingEscrowSimple.vy#L216\nhttps://github.com/banteg/yearn-vesting-escrow/blob/945b5ca09d8bb2d2ad9132df7368cb4992496f6a/contracts/VestingEscrowSimple.vy#L178\nThe issue was identified in the `collect_dust` function. When a `recipient` attempts to withdraw an amount of `self.token` that exceeds the total value, they can claim via the `collect_dust` call after the `self.owner` has invoked the `revoke` function, so the issue arises. In such a scenario, the `self.token` balance of the contract diminishes below the `self.total_locked` value. Consequently, the residual funds or \"dust\" transferred to the contract cannot be collected.\n\n##### Recommendation\nWe recommend modifying the expression located here https://github.com/banteg/yearn-vesting-escrow/blob/945b5ca09d8bb2d2ad9132df7368cb4992496f6a/contracts/VestingEscrowSimple.vy#L216 to:\n```python\namount = amount +self.total_claimed -self._total_vested_at(self.disabled_at)\n```\n\n***\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/VestingEscrowSimple.vy",
      "content": "# @version 0.3.9\n\n\"\"\"\n@title Simple Vesting Escrow\n@author Curve Finance, Yearn Finance\n@license MIT\n@notice Vests ERC20 tokens for a single address\n@dev Intended to be deployed many times via `VotingEscrowFactory`\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\n\nevent Claim:\n    recipient: indexed(address)\n    claimed: uint256\n\n\nevent Revoked:\n    recipient: address\n    owner: address\n    rugged: uint256\n    ts: uint256\n\n\nevent Disowned:\n    owner: address\n\n\nevent SetOpenClaim:\n    state: bool\n\n\nrecipient: public(address)\ntoken: public(ERC20)\nstart_time: public(uint256)\nend_time: public(uint256)\ncliff_length: public(uint256)\ntotal_locked: public(uint256)\ntotal_claimed: public(uint256)\ndisabled_at: public(uint256)\nopen_claim: public(bool)\ninitialized: public(bool)\n\nowner: public(address)\n\n\n@external\ndef __init__():\n    # ensure that the original contract cannot be initialized\n    self.initialized = True\n\n\n@external\ndef initialize(\n    owner: address,\n    token: ERC20,\n    recipient: address,\n    amount: uint256,\n    start_time: uint256,\n    end_time: uint256,\n    cliff_length: uint256,\n    open_claim: bool,\n) -> bool:\n    \"\"\"\n    @notice Initialize the contract\n    @dev This function is seperate from `__init__` because of the factory pattern\n         used in `VestingEscrowFactory.deploy_vesting_contract`. It may be called\n         once per deployment\n    @param owner Owner address\n    @param token Address of the ERC20 token being distributed\n    @param recipient Address to vest tokens for\n    @param amount Amount of tokens being vested for `recipient`\n    @param start_time Epoch time at which token distribution starts\n    @param end_time Time until everything should be vested\n    @param cliff_length Duration after which the first portion vests\n    @param open_claim Switch if anyone can claim for `recipient`\n    \"\"\"\n    assert not self.initialized  # dev: can only initialize once\n    self.initialized = True\n\n    self.token = token\n    self.owner = owner\n    self.start_time = start_time\n    self.end_time = end_time\n    self.cliff_length = cliff_length\n\n    self.recipient = recipient\n    self.disabled_at = end_time  # Set to maximum time\n    self.total_locked = amount\n    self.open_claim = open_claim\n\n    return True\n\n\n@internal\n@view\ndef _total_vested_at(time: uint256 = block.timestamp) -> uint256:\n    start: uint256 = self.start_time\n    end: uint256 = self.end_time\n    locked: uint256 = self.total_locked\n    if time < start + self.cliff_length:\n        return 0\n    return min(locked * (time - start) / (end - start), locked)\n\n\n@internal\n@view\ndef _unclaimed(time: uint256 = block.timestamp) -> uint256:\n    return self._total_vested_at(time) - self.total_claimed\n\n\n@external\n@view\ndef unclaimed() -> uint256:\n    \"\"\"\n    @notice Get the number of unclaimed, vested tokens for recipient\n    @dev If `disown` is activated, limit by the activation timestamp\n    \"\"\"\n    return self._unclaimed(min(block.timestamp, self.disabled_at))\n\n\n@internal\n@view\ndef _locked(time: uint256 = block.timestamp) -> uint256:\n    return min(\n        self.token.balanceOf(self) - self._unclaimed(time),\n        self.total_locked - self._total_vested_at(time),\n    )\n\n\n@external\n@view\ndef locked() -> uint256:\n    \"\"\"\n    @notice Get the number of locked tokens for recipient\n    @dev If `disown` is activated, limit by the activation timestamp\n    \"\"\"\n    return self._locked(min(block.timestamp, self.disabled_at))\n\n\n@external\ndef claim(beneficiary: address = msg.sender, amount: uint256 = max_value(uint256)) -> uint256:\n    \"\"\"\n    @notice Claim tokens which have vested\n    @param beneficiary Address to transfer claimed tokens to\n    @param amount Amount of tokens to claim\n    \"\"\"\n    recipient: address = self.recipient\n    assert msg.sender == recipient or self.open_claim and recipient == beneficiary  # dev: not authorized\n\n    claim_period_end: uint256 = min(block.timestamp, self.disabled_at)\n    claimable: uint256 = min(self._unclaimed(claim_period_end), amount)\n    self.total_claimed += claimable\n\n    assert self.token.transfer(beneficiary, claimable, default_return_value=True)\n    log Claim(beneficiary, claimable)\n\n    return claimable\n\n\n@external\ndef revoke(ts: uint256 = block.timestamp, beneficiary: address = msg.sender):\n    \"\"\"\n    @notice Disable further flow of tokens and clawback the unvested part to `beneficiary`\n            Revoking more than once is futile\n    @dev Owner is set to zero address\n    @param ts Timestamp of the clawback\n    @param beneficiary Recipient of the unvested part\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner  # dev: not owner\n    assert ts >= block.timestamp and ts < self.end_time  # dev: no back to the future\n\n    self.disabled_at = ts\n    ruggable: uint256 = self._locked(ts)\n\n    assert self.token.transfer(beneficiary, ruggable, default_return_value=True)\n\n    self.owner = empty(address)\n\n    log Disowned(owner)\n    log Revoked(self.recipient, owner, ruggable, ts)\n\n\n@external\ndef disown():\n    \"\"\"\n    @notice Renounce owner control of the escrow\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner  # dev: not owner\n    self.owner = empty(address)\n\n    log Disowned(owner)\n\n\n@external\ndef set_open_claim(open_claim: bool):\n    \"\"\"\n    @notice Disallow or let anyone claim tokens for `recipient`\n    \"\"\"\n    assert msg.sender == self.recipient  # dev: not recipient\n    self.open_claim = open_claim\n\n    log SetOpenClaim(open_claim)\n\n\n@external\ndef collect_dust(token: ERC20, beneficiary: address = msg.sender):\n    recipient: address = self.recipient\n    assert msg.sender == recipient or self.open_claim and recipient == beneficiary  # dev: not authorized\n\n    amount: uint256 = token.balanceOf(self)\n    if token == self.token:\n        amount = amount + self.total_claimed - self.total_locked\n\n    assert token.transfer(beneficiary, amount, default_return_value=True)"
    },
    {
      "filename": "contracts/VestingEscrowSimple.vy",
      "content": "# @version 0.3.9\n\n\"\"\"\n@title Simple Vesting Escrow\n@author Curve Finance, Yearn Finance\n@license MIT\n@notice Vests ERC20 tokens for a single address\n@dev Intended to be deployed many times via `VotingEscrowFactory`\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\n\nevent Claim:\n    recipient: indexed(address)\n    claimed: uint256\n\n\nevent Revoked:\n    recipient: address\n    owner: address\n    rugged: uint256\n    ts: uint256\n\n\nevent Disowned:\n    owner: address\n\n\nevent SetOpenClaim:\n    state: bool\n\n\nrecipient: public(address)\ntoken: public(ERC20)\nstart_time: public(uint256)\nend_time: public(uint256)\ncliff_length: public(uint256)\ntotal_locked: public(uint256)\ntotal_claimed: public(uint256)\ndisabled_at: public(uint256)\nopen_claim: public(bool)\ninitialized: public(bool)\n\nowner: public(address)\n\n\n@external\ndef __init__():\n    # ensure that the original contract cannot be initialized\n    self.initialized = True\n\n\n@external\ndef initialize(\n    owner: address,\n    token: ERC20,\n    recipient: address,\n    amount: uint256,\n    start_time: uint256,\n    end_time: uint256,\n    cliff_length: uint256,\n    open_claim: bool,\n) -> bool:\n    \"\"\"\n    @notice Initialize the contract\n    @dev This function is seperate from `__init__` because of the factory pattern\n         used in `VestingEscrowFactory.deploy_vesting_contract`. It may be called\n         once per deployment\n    @param owner Owner address\n    @param token Address of the ERC20 token being distributed\n    @param recipient Address to vest tokens for\n    @param amount Amount of tokens being vested for `recipient`\n    @param start_time Epoch time at which token distribution starts\n    @param end_time Time until everything should be vested\n    @param cliff_length Duration after which the first portion vests\n    @param open_claim Switch if anyone can claim for `recipient`\n    \"\"\"\n    assert not self.initialized  # dev: can only initialize once\n    self.initialized = True\n\n    self.token = token\n    self.owner = owner\n    self.start_time = start_time\n    self.end_time = end_time\n    self.cliff_length = cliff_length\n\n    self.recipient = recipient\n    self.disabled_at = end_time  # Set to maximum time\n    self.total_locked = amount\n    self.open_claim = open_claim\n\n    return True\n\n\n@internal\n@view\ndef _total_vested_at(time: uint256 = block.timestamp) -> uint256:\n    start: uint256 = self.start_time\n    end: uint256 = self.end_time\n    locked: uint256 = self.total_locked\n    if time < start + self.cliff_length:\n        return 0\n    return min(locked * (time - start) / (end - start), locked)\n\n\n@internal\n@view\ndef _unclaimed(time: uint256 = block.timestamp) -> uint256:\n    return self._total_vested_at(time) - self.total_claimed\n\n\n@external\n@view\ndef unclaimed() -> uint256:\n    \"\"\"\n    @notice Get the number of unclaimed, vested tokens for recipient\n    @dev If `disown` is activated, limit by the activation timestamp\n    \"\"\"\n    return self._unclaimed(min(block.timestamp, self.disabled_at))\n\n\n@internal\n@view\ndef _locked(time: uint256 = block.timestamp) -> uint256:\n    return min(\n        self.token.balanceOf(self) - self._unclaimed(time),\n        self.total_locked - self._total_vested_at(time),\n    )\n\n\n@external\n@view\ndef locked() -> uint256:\n    \"\"\"\n    @notice Get the number of locked tokens for recipient\n    @dev If `disown` is activated, limit by the activation timestamp\n    \"\"\"\n    return self._locked(min(block.timestamp, self.disabled_at))\n\n\n@external\ndef claim(beneficiary: address = msg.sender, amount: uint256 = max_value(uint256)) -> uint256:\n    \"\"\"\n    @notice Claim tokens which have vested\n    @param beneficiary Address to transfer claimed tokens to\n    @param amount Amount of tokens to claim\n    \"\"\"\n    recipient: address = self.recipient\n    assert msg.sender == recipient or self.open_claim and recipient == beneficiary  # dev: not authorized\n\n    claim_period_end: uint256 = min(block.timestamp, self.disabled_at)\n    claimable: uint256 = min(self._unclaimed(claim_period_end), amount)\n    self.total_claimed += claimable\n\n    assert self.token.transfer(beneficiary, claimable, default_return_value=True)\n    log Claim(beneficiary, claimable)\n\n    return claimable\n\n\n@external\ndef revoke(ts: uint256 = block.timestamp, beneficiary: address = msg.sender):\n    \"\"\"\n    @notice Disable further flow of tokens and clawback the unvested part to `beneficiary`\n            Revoking more than once is futile\n    @dev Owner is set to zero address\n    @param ts Timestamp of the clawback\n    @param beneficiary Recipient of the unvested part\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner  # dev: not owner\n    assert ts >= block.timestamp and ts < self.end_time  # dev: no back to the future\n\n    self.disabled_at = ts\n    ruggable: uint256 = self._locked(ts)\n\n    assert self.token.transfer(beneficiary, ruggable, default_return_value=True)\n\n    self.owner = empty(address)\n\n    log Disowned(owner)\n    log Revoked(self.recipient, owner, ruggable, ts)\n\n\n@external\ndef disown():\n    \"\"\"\n    @notice Renounce owner control of the escrow\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner  # dev: not owner\n    self.owner = empty(address)\n\n    log Disowned(owner)\n\n\n@external\ndef set_open_claim(open_claim: bool):\n    \"\"\"\n    @notice Disallow or let anyone claim tokens for `recipient`\n    \"\"\"\n    assert msg.sender == self.recipient  # dev: not recipient\n    self.open_claim = open_claim\n\n    log SetOpenClaim(open_claim)\n\n\n@external\ndef collect_dust(token: ERC20, beneficiary: address = msg.sender):\n    recipient: address = self.recipient\n    assert msg.sender == recipient or self.open_claim and recipient == beneficiary  # dev: not authorized\n\n    amount: uint256 = token.balanceOf(self)\n    if token == self.token:\n        amount = amount + self.total_claimed - self.total_locked\n\n    assert token.transfer(beneficiary, amount, default_return_value=True)"
    },
    {
      "filename": "contracts/VestingEscrowSimple.vy",
      "content": "# @version 0.3.9\n\n\"\"\"\n@title Simple Vesting Escrow\n@author Curve Finance, Yearn Finance\n@license MIT\n@notice Vests ERC20 tokens for a single address\n@dev Intended to be deployed many times via `VotingEscrowFactory`\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\n\nevent Claim:\n    recipient: indexed(address)\n    claimed: uint256\n\n\nevent Revoked:\n    recipient: address\n    owner: address\n    rugged: uint256\n    ts: uint256\n\n\nevent Disowned:\n    owner: address\n\n\nevent SetOpenClaim:\n    state: bool\n\n\nrecipient: public(address)\ntoken: public(ERC20)\nstart_time: public(uint256)\nend_time: public(uint256)\ncliff_length: public(uint256)\ntotal_locked: public(uint256)\ntotal_claimed: public(uint256)\ndisabled_at: public(uint256)\nopen_claim: public(bool)\ninitialized: public(bool)\n\nowner: public(address)\n\n\n@external\ndef __init__():\n    # ensure that the original contract cannot be initialized\n    self.initialized = True\n\n\n@external\ndef initialize(\n    owner: address,\n    token: ERC20,\n    recipient: address,\n    amount: uint256,\n    start_time: uint256,\n    end_time: uint256,\n    cliff_length: uint256,\n    open_claim: bool,\n) -> bool:\n    \"\"\"\n    @notice Initialize the contract\n    @dev This function is seperate from `__init__` because of the factory pattern\n         used in `VestingEscrowFactory.deploy_vesting_contract`. It may be called\n         once per deployment\n    @param owner Owner address\n    @param token Address of the ERC20 token being distributed\n    @param recipient Address to vest tokens for\n    @param amount Amount of tokens being vested for `recipient`\n    @param start_time Epoch time at which token distribution starts\n    @param end_time Time until everything should be vested\n    @param cliff_length Duration after which the first portion vests\n    @param open_claim Switch if anyone can claim for `recipient`\n    \"\"\"\n    assert not self.initialized  # dev: can only initialize once\n    self.initialized = True\n\n    self.token = token\n    self.owner = owner\n    self.start_time = start_time\n    self.end_time = end_time\n    self.cliff_length = cliff_length\n\n    self.recipient = recipient\n    self.disabled_at = end_time  # Set to maximum time\n    self.total_locked = amount\n    self.open_claim = open_claim\n\n    return True\n\n\n@internal\n@view\ndef _total_vested_at(time: uint256 = block.timestamp) -> uint256:\n    start: uint256 = self.start_time\n    end: uint256 = self.end_time\n    locked: uint256 = self.total_locked\n    if time < start + self.cliff_length:\n        return 0\n    return min(locked * (time - start) / (end - start), locked)\n\n\n@internal\n@view\ndef _unclaimed(time: uint256 = block.timestamp) -> uint256:\n    return self._total_vested_at(time) - self.total_claimed\n\n\n@external\n@view\ndef unclaimed() -> uint256:\n    \"\"\"\n    @notice Get the number of unclaimed, vested tokens for recipient\n    @dev If `disown` is activated, limit by the activation timestamp\n    \"\"\"\n    return self._unclaimed(min(block.timestamp, self.disabled_at))\n\n\n@internal\n@view\ndef _locked(time: uint256 = block.timestamp) -> uint256:\n    return min(\n        self.token.balanceOf(self) - self._unclaimed(time),\n        self.total_locked - self._total_vested_at(time),\n    )\n\n\n@external\n@view\ndef locked() -> uint256:\n    \"\"\"\n    @notice Get the number of locked tokens for recipient\n    @dev If `disown` is activated, limit by the activation timestamp\n    \"\"\"\n    return self._locked(min(block.timestamp, self.disabled_at))\n\n\n@external\ndef claim(beneficiary: address = msg.sender, amount: uint256 = max_value(uint256)) -> uint256:\n    \"\"\"\n    @notice Claim tokens which have vested\n    @param beneficiary Address to transfer claimed tokens to\n    @param amount Amount of tokens to claim\n    \"\"\"\n    recipient: address = self.recipient\n    assert msg.sender == recipient or self.open_claim and recipient == beneficiary  # dev: not authorized\n\n    claim_period_end: uint256 = min(block.timestamp, self.disabled_at)\n    claimable: uint256 = min(self._unclaimed(claim_period_end), amount)\n    self.total_claimed += claimable\n\n    assert self.token.transfer(beneficiary, claimable, default_return_value=True)\n    log Claim(beneficiary, claimable)\n\n    return claimable\n\n\n@external\ndef revoke(ts: uint256 = block.timestamp, beneficiary: address = msg.sender):\n    \"\"\"\n    @notice Disable further flow of tokens and clawback the unvested part to `beneficiary`\n            Revoking more than once is futile\n    @dev Owner is set to zero address\n    @param ts Timestamp of the clawback\n    @param beneficiary Recipient of the unvested part\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner  # dev: not owner\n    assert ts >= block.timestamp and ts < self.end_time  # dev: no back to the future\n\n    self.disabled_at = ts\n    ruggable: uint256 = self._locked(ts)\n\n    assert self.token.transfer(beneficiary, ruggable, default_return_value=True)\n\n    self.owner = empty(address)\n\n    log Disowned(owner)\n    log Revoked(self.recipient, owner, ruggable, ts)\n\n\n@external\ndef disown():\n    \"\"\"\n    @notice Renounce owner control of the escrow\n    \"\"\"\n    owner: address = self.owner\n    assert msg.sender == owner  # dev: not owner\n    self.owner = empty(address)\n\n    log Disowned(owner)\n\n\n@external\ndef set_open_claim(open_claim: bool):\n    \"\"\"\n    @notice Disallow or let anyone claim tokens for `recipient`\n    \"\"\"\n    assert msg.sender == self.recipient  # dev: not recipient\n    self.open_claim = open_claim\n\n    log SetOpenClaim(open_claim)\n\n\n@external\ndef collect_dust(token: ERC20, beneficiary: address = msg.sender):\n    recipient: address = self.recipient\n    assert msg.sender == recipient or self.open_claim and recipient == beneficiary  # dev: not authorized\n\n    amount: uint256 = token.balanceOf(self)\n    if token == self.token:\n        amount = amount + self.total_claimed - self.total_locked\n\n    assert token.transfer(beneficiary, amount, default_return_value=True)"
    }
  ]
}