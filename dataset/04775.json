{
  "Title": "[L-06] There is no functionality to change the `fee rate model` in the `MagicLP`",
  "Content": "\nWhen creating `MagicLP` using the `create` function in the `factory`, we insert `maintainerFeeRateModel` as the `fee rate model`. \nThis model will be used to calculate the `maintainer fee` in the `MagicLP`.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/periphery/Factory.sol#L86\n```\nfunction create(address baseToken_, address quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_) external returns (address clone) {\n    IMagicLP(clone).init(address(baseToken_), address(quoteToken_), lpFeeRate_, address(maintainerFeeRateModel), i_, k_);\n}\n```\nThere is a functionality to change `maintainerFeeRateModel` in the `factory`.\nhttps://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/periphery/Factory.sol#L105-L112\n```\nfunction setMaintainerFeeRateModel(IFeeRateModel maintainerFeeRateModel_) external onlyOwner {\n    if (address(maintainerFeeRateModel_) == address(0)) {\n        revert ErrZeroAddress();\n    }\n\n    maintainerFeeRateModel = maintainerFeeRateModel_;\n    emit LogSetMaintainerFeeRateModel(maintainerFeeRateModel_);\n}\n```\nThis implies that the `maintainerFeeRateModel` will require updating in the `future`.\nHowever, there's currently no functionality within `MagicLP` to modify the `fee rate model`. \nConsequently, existing `MagicLP`s are unable to alter the `fee rate model`.\n\nPlease add a functionality to change `fee rate model` in the `MagicLP`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/mimswap/periphery/Factory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {LibClone} from \"solady/utils/LibClone.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IMagicLP} from \"/mimswap/interfaces/IMagicLP.sol\";\nimport {MagicLP} from \"/mimswap/MagicLP.sol\";\n\n/// @notice Create and register MagicLP pools\ncontract Factory is Owned {\n    event LogCreated(\n        address clone_,\n        address indexed baseToken_,\n        address indexed quoteToken_,\n        address indexed creator_,\n        uint256 lpFeeRate_,\n        IFeeRateModel maintainerFeeRateModel,\n        uint256 i_,\n        uint256 k_\n    );\n\n    event LogPoolAdded(address baseToken, address quoteToken, address creator, address pool);\n    event LogPoolRemoved(address pool);\n    event LogSetImplementation(address indexed implementation);\n    event LogSetMaintainer(address indexed newMaintainer);\n    event LogSetMaintainerFeeRateModel(IFeeRateModel newMaintainerFeeRateModel);\n\n    error ErrInvalidUserPoolIndex();\n    error ErrZeroAddress();\n\n    address public implementation;\n    IFeeRateModel public maintainerFeeRateModel;\n\n    mapping(address base => mapping(address quote => address[] pools)) public pools;\n    mapping(address creator => address[] pools) public userPools;\n\n    constructor(address implementation_, IFeeRateModel maintainerFeeRateModel_, address owner_) Owned(owner_) {\n        if (implementation_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n        if (address(maintainerFeeRateModel_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n        implementation = implementation_;\n        maintainerFeeRateModel = maintainerFeeRateModel_;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function getPoolCount(address token0, address token1) external view returns (uint256) {\n        return pools[token0][token1].length;\n    }\n\n    function getUserPoolCount(address creator) external view returns (uint256) {\n        return userPools[creator].length;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function predictDeterministicAddress(\n        address creator,\n        address baseToken_,\n        address quoteToken_,\n        uint256 lpFeeRate_,\n        uint256 i_,\n        uint256 k_\n    ) public view returns (address) {\n        return\n            LibClone.predictDeterministicAddress(\n                implementation,\n                _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_),\n                address(this)\n            );\n    }\n\n    function create(address baseToken_, address quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_) external returns (address clone) {\n        address creator = tx.origin;\n\n        bytes32 salt = _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_);\n        clone = LibClone.cloneDeterministic(address(implementation), salt);\n        IMagicLP(clone).init(address(baseToken_), address(quoteToken_), lpFeeRate_, address(maintainerFeeRateModel), i_, k_);\n\n        emit LogCreated(clone, baseToken_, quoteToken_, creator, lpFeeRate_, maintainerFeeRateModel, i_, k_);\n        _addPool(creator, baseToken_, quoteToken_, clone);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setLpImplementation(address implementation_) external onlyOwner {\n        if (implementation_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        implementation = implementation_;\n        emit LogSetImplementation(implementation_);\n    }\n\n    function setMaintainerFeeRateModel(IFeeRateModel maintainerFeeRateModel_) external onlyOwner {\n        if (address(maintainerFeeRateModel_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        maintainerFeeRateModel = maintainerFeeRateModel_;\n        emit LogSetMaintainerFeeRateModel(maintainerFeeRateModel_);\n    }\n\n    /// @notice Register a pool to the list\n    /// Note this doesn't check if the pool is valid or if it's already registered.\n    function addPool(address creator, address baseToken, address quoteToken, address pool) external onlyOwner {\n        _addPool(creator, baseToken, quoteToken, pool);\n    }\n\n    function removePool(\n        address creator,\n        address baseToken,\n        address quoteToken,\n        uint256 poolIndex,\n        uint256 userPoolIndex\n    ) external onlyOwner {\n        address[] storage _pools = pools[baseToken][quoteToken];\n        address pool = _pools[poolIndex];\n        address[] storage _userPools = userPools[creator];\n\n        _pools[poolIndex] = _pools[_pools.length - 1];\n        _pools.pop();\n\n        if (_userPools[userPoolIndex] != pool) {\n            revert ErrInvalidUserPoolIndex();\n        }\n\n        _userPools[userPoolIndex] = _userPools[_userPools.length - 1];\n        _userPools.pop();\n\n        emit LogPoolRemoved(pool);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _addPool(address creator, address baseToken, address quoteToken, address pool) internal {\n        pools[baseToken][quoteToken].push(pool);\n        userPools[creator].push(pool);\n\n        emit LogPoolAdded(baseToken, quoteToken, creator, pool);\n    }\n\n    function _computeSalt(\n        address sender_,\n        address baseToken_,\n        address quoteToken_,\n        uint256 lpFeeRate_,\n        uint256 i_,\n        uint256 k_\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(sender_, implementation, baseToken_, quoteToken_, lpFeeRate_, i_, k_));\n    }\n}"
    },
    {
      "filename": "src/mimswap/periphery/Factory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {LibClone} from \"solady/utils/LibClone.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IMagicLP} from \"/mimswap/interfaces/IMagicLP.sol\";\nimport {MagicLP} from \"/mimswap/MagicLP.sol\";\n\n/// @notice Create and register MagicLP pools\ncontract Factory is Owned {\n    event LogCreated(\n        address clone_,\n        address indexed baseToken_,\n        address indexed quoteToken_,\n        address indexed creator_,\n        uint256 lpFeeRate_,\n        IFeeRateModel maintainerFeeRateModel,\n        uint256 i_,\n        uint256 k_\n    );\n\n    event LogPoolAdded(address baseToken, address quoteToken, address creator, address pool);\n    event LogPoolRemoved(address pool);\n    event LogSetImplementation(address indexed implementation);\n    event LogSetMaintainer(address indexed newMaintainer);\n    event LogSetMaintainerFeeRateModel(IFeeRateModel newMaintainerFeeRateModel);\n\n    error ErrInvalidUserPoolIndex();\n    error ErrZeroAddress();\n\n    address public implementation;\n    IFeeRateModel public maintainerFeeRateModel;\n\n    mapping(address base => mapping(address quote => address[] pools)) public pools;\n    mapping(address creator => address[] pools) public userPools;\n\n    constructor(address implementation_, IFeeRateModel maintainerFeeRateModel_, address owner_) Owned(owner_) {\n        if (implementation_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n        if (address(maintainerFeeRateModel_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n        implementation = implementation_;\n        maintainerFeeRateModel = maintainerFeeRateModel_;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function getPoolCount(address token0, address token1) external view returns (uint256) {\n        return pools[token0][token1].length;\n    }\n\n    function getUserPoolCount(address creator) external view returns (uint256) {\n        return userPools[creator].length;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function predictDeterministicAddress(\n        address creator,\n        address baseToken_,\n        address quoteToken_,\n        uint256 lpFeeRate_,\n        uint256 i_,\n        uint256 k_\n    ) public view returns (address) {\n        return\n            LibClone.predictDeterministicAddress(\n                implementation,\n                _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_),\n                address(this)\n            );\n    }\n\n    function create(address baseToken_, address quoteToken_, uint256 lpFeeRate_, uint256 i_, uint256 k_) external returns (address clone) {\n        address creator = tx.origin;\n\n        bytes32 salt = _computeSalt(creator, baseToken_, quoteToken_, lpFeeRate_, i_, k_);\n        clone = LibClone.cloneDeterministic(address(implementation), salt);\n        IMagicLP(clone).init(address(baseToken_), address(quoteToken_), lpFeeRate_, address(maintainerFeeRateModel), i_, k_);\n\n        emit LogCreated(clone, baseToken_, quoteToken_, creator, lpFeeRate_, maintainerFeeRateModel, i_, k_);\n        _addPool(creator, baseToken_, quoteToken_, clone);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setLpImplementation(address implementation_) external onlyOwner {\n        if (implementation_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        implementation = implementation_;\n        emit LogSetImplementation(implementation_);\n    }\n\n    function setMaintainerFeeRateModel(IFeeRateModel maintainerFeeRateModel_) external onlyOwner {\n        if (address(maintainerFeeRateModel_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        maintainerFeeRateModel = maintainerFeeRateModel_;\n        emit LogSetMaintainerFeeRateModel(maintainerFeeRateModel_);\n    }\n\n    /// @notice Register a pool to the list\n    /// Note this doesn't check if the pool is valid or if it's already registered.\n    function addPool(address creator, address baseToken, address quoteToken, address pool) external onlyOwner {\n        _addPool(creator, baseToken, quoteToken, pool);\n    }\n\n    function removePool(\n        address creator,\n        address baseToken,\n        address quoteToken,\n        uint256 poolIndex,\n        uint256 userPoolIndex\n    ) external onlyOwner {\n        address[] storage _pools = pools[baseToken][quoteToken];\n        address pool = _pools[poolIndex];\n        address[] storage _userPools = userPools[creator];\n\n        _pools[poolIndex] = _pools[_pools.length - 1];\n        _pools.pop();\n\n        if (_userPools[userPoolIndex] != pool) {\n            revert ErrInvalidUserPoolIndex();\n        }\n\n        _userPools[userPoolIndex] = _userPools[_userPools.length - 1];\n        _userPools.pop();\n\n        emit LogPoolRemoved(pool);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _addPool(address creator, address baseToken, address quoteToken, address pool) internal {\n        pools[baseToken][quoteToken].push(pool);\n        userPools[creator].push(pool);\n\n        emit LogPoolAdded(baseToken, quoteToken, creator, pool);\n    }\n\n    function _computeSalt(\n        address sender_,\n        address baseToken_,\n        address quoteToken_,\n        uint256 lpFeeRate_,\n        uint256 i_,\n        uint256 k_\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(sender_, implementation, baseToken_, quoteToken_, lpFeeRate_, i_, k_));\n    }\n}"
    }
  ]
}