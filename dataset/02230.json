{
  "Title": "M-6: An inactive vault can disrupt rebalancing of active vaults",
  "Content": "# Issue M-6: An inactive vault can disrupt rebalancing of active vaults \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/326 \n\n## Found by \nCh\\_301, Jeiwan, evan, immeas, saidam017\n\n## Summary\nAn inactive vault can send its total underlying amount to the `XChainController` and disrupt rebalancing of active vaults by increasing the `underlyingReceived` counter:\n1. if `pushVaultAmounts` is called before `underlyingReceived` overflows, rebalancing of one of the active vault may get stuck since the vault won't receive XChain allocations;\n1. if `pushVaultAmounts` after all active vaults and at least one inactive vault has reported their underlying amounts, rebalancing of all vaults will get stuck.\n## Vulnerability Detail\nRebalancing of vaults starts when [Game.pushAllocationsToController](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L424) is called. The function sends the allocations made by gamers to the `XChainController`. `XChainController` receives them in the [receiveAllocationsFromGame](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L193) function. In the [settleCurrentAllocation](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L224) function, a vault is marked as inactive if it has no allocations and there are no new allocations for the vault. `receiveAllocationsFromGameInt` [remembers](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L213) the [number of active vaults](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L208).\n\nThe next step of the rebalancing process is reporting vault underlying token balances to the `XChainController` by calling [MainVault.pushTotalUnderlyingToController](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L249). As you can see, the function can be called in an inactive vault (the only modifier of the function, `onlyWhenIdle`, doesn't check that `vaultOff` is `false`). `XChainController` receives underlying balances in the [setTotalUnderlying](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L258) function: notice that the function [increases the number of balances it has received](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L288).\n\nNext step is the [XChainController.pushVaultAmounts](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L295) function, which calculates how much tokens each vault should receive after gamers have changed their allocations. The function can be called only [when all active vaults have reported their underlying balances](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L298):\n```solidity\nmodifier onlyWhenUnderlyingsReceived(uint256 _vaultNumber) {\n  require(\n    vaultStage[_vaultNumber].underlyingReceived == vaultStage[_vaultNumber].activeVaults,\n    \"Not all underlyings received\"\n  );\n  _;\n}\n```\n\nHowever, as we saw above, inactive vaults can also report their underlying balances and increase the `underlyingReceived` counter–if this is abused mistakenly or intentionally (e.g. by a malicious actor), vaults may end up in a corrupted state. Since all the functions involved in rebalancing are not restricted (including `pushTotalUnderlyingToController` and `pushVaultAmounts`), a malicious actor can intentionally disrupt accounting of vaults or block a rebalancing.\n## Impact\n1. If an inactive vault reports its underlying balances instead of an active vault (i.e. `pushVaultAmounts` is called when `underlyingReceived` is equal `activeVaults`), the active vault will be excluded from rebalancing and it won't receive updated allocations in the current period. Since the rebalancing interval is 2 weeks, the vault will lose the increased yield that might've been generated thanks to new allocations.\n1. If an inactive vault reports its underlying balances in addition to all active vaults (i.e. `pushVaultAmounts` is called when `underlyingReceived` is greater than `activeVaults`), then `pushVaultAmounts` will always revert and rebalancing will get stuck.\n## Code Snippet\n1. An inactive vault can send its underlying balance to the `XChainController`:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L249\n1. The `XChainController` can receive underlying balances from inactive vaults:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L264\n1. `underlyingReceived` is increased when underlying balances are received:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L288\n1. `pushVaultAmounts` can only be executed when the number of vaults that have reported their balances equals the number of active vaults:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L298\n## Tool used\nManual Review\n## Recommendation\nIn the `MainVault.pushTotalUnderlyingToController` function, consider disallowing inactive vaults (vaults that have `vaultOff` set to `true`) report their underlying balances.\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nLow severity because funds are not at risk and the guardian can reset this.\n\n**Jeiwan**\n\nEscalate for 10 USDC\n\nThis is a medium severity issue. It's true that the guardian can reset `underlyingReceived`, however, the attacker can call [XChainController.pushVaultAmounts](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L295) in the same transaction and proceed rebalancing to the next stage–this cannot be reset by the guardian. I.e. the attacker would report the balance of an inactive vault and call `XChainController.pushVaultAmounts` in the same transaction to apply the effect immediately.\n\nThe `XChainController.pushVaultAmounts` function [rebalances vault amounts](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L301-L307) using the balances they reported (including balances reported by inactive vaults) and [sends cross-chain messages to the vaults](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L322) to let them know their updated balances. The guardian cannot revert rebalancing, thus it won't be able to reset the balance of an inactive vault after `XChainController.pushVaultAmounts` was called.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is a medium severity issue. It's true that the guardian can reset `underlyingReceived`, however, the attacker can call [XChainController.pushVaultAmounts](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L295) in the same transaction and proceed rebalancing to the next stage–this cannot be reset by the guardian. I.e. the attacker would report the balance of an inactive vault and call `XChainController.pushVaultAmounts` in the same transaction to apply the effect immediately.\n> \n> The `XChainController.pushVaultAmounts` function [rebalances vault amounts](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L301-L307) using the balances they reported (including balances reported by inactive vaults) and [sends cross-chain messages to the vaults](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L322) to let them know their updated balances. The guardian cannot revert rebalancing, thus it won't be able to reset the balance of an inactive vault after `XChainController.pushVaultAmounts` was called.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nAfter further discussions with the Sponsor considering this issue a valid medium\n\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> After further discussions with the Sponsor considering this issue a valid medium\n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**Theezr**\n\nFix:\nhttps://github.com/derbyfinance/derby-yield-optimiser/pull/197\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Game.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./DerbyToken.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract Game is ERC721, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  struct Basket {\n    // the vault number for which this Basket was created\n    uint256 vaultNumber;\n    // last period when this Basket got rebalanced\n    uint256 lastRebalancingPeriod;\n    // nr of total allocated tokens\n    int256 nrOfAllocatedTokens;\n    // total build up rewards\n    int256 totalUnRedeemedRewards;\n    // total redeemed rewards\n    int256 totalRedeemedRewards;\n    // (basket => vaultNumber => chainId => allocation)\n    mapping(uint256 => mapping(uint256 => int256)) allocations;\n  }\n\n  struct vaultInfo {\n    // rebalance period of vault, upped at vault rebalance\n    uint256 rebalancingPeriod;\n    // (chainId => vaultAddress)\n    mapping(uint32 => address) vaultAddress;\n    // (chainId => deltaAllocation)\n    mapping(uint256 => int256) deltaAllocationChain;\n    // (chainId => protocolNumber => deltaAllocation)\n    mapping(uint256 => mapping(uint256 => int256)) deltaAllocationProtocol;\n    // (chainId => rebalancing period => protocol id => rewardPerLockedToken).\n    mapping(uint32 => mapping(uint256 => mapping(uint256 => int256))) rewardPerLockedToken;\n  }\n\n  address private dao;\n  address private guardian;\n  address public xProvider;\n  address public homeVault;\n\n  IController public controller;\n  IERC20 public derbyToken;\n\n  // latest basket id\n  uint256 private latestBasketId;\n\n  // array of chainIds e.g [10, 100, 1000];\n  uint32[] public chainIds;\n\n  // interval in Unix timeStamp\n  uint256 public rebalanceInterval; // SHOULD BE REPLACED FOR REALISTIC NUMBER\n\n  // last rebalance timeStamp\n  uint256 public lastTimeStamp;\n\n  // threshold in vaultCurrency e.g USDC for when user tokens will be sold / burned. Must be negative\n  int256 internal negativeRewardThreshold;\n  // percentage of tokens that will be sold at negative rewards\n  uint256 internal negativeRewardFactor;\n\n  // baskets, maps tokenID from BasketToken NFT contract to the Basket struct in this contract.\n  // (basketTokenId => basket struct):\n  mapping(uint256 => Basket) private baskets;\n\n  // (chainId => latestProtocolId): latestProtocolId set by dao\n  mapping(uint256 => uint256) public latestProtocolId;\n\n  // (vaultNumber => vaultInfo struct)\n  mapping(uint256 => vaultInfo) internal vaults;\n\n  // (vaultNumber => chainid => bool): true when vault/ chainid is cross-chain rebalancing\n  mapping(uint256 => mapping(uint32 => bool)) public isXChainRebalancing;\n\n  event PushProtocolAllocations(uint32 chain, address vault, int256[] deltas);\n\n  event PushedAllocationsToController(uint256 vaultNumber, int256[] deltas);\n\n  event BasketId(address owner, uint256 basketId);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Game: only DAO\");\n    _;\n  }\n\n  modifier onlyBasketOwner(uint256 _basketId) {\n    require(msg.sender == ownerOf(_basketId), \"Game: Not the owner of the basket\");\n    _;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"Game: only xProvider\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"Game: only Guardian\");\n    _;\n  }\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    address _derbyToken,\n    address _dao,\n    address _guardian,\n    address _controller\n  ) ERC721(name_, symbol_) {\n    derbyToken = IERC20(_derbyToken);\n    controller = IController(_controller);\n    dao = _dao;\n    guardian = _guardian;\n    lastTimeStamp = block.timestamp;\n  }\n\n  /// @notice Setter for delta allocation in a particulair chainId\n  /// @param _vaultNumber number of vault\n  /// @param _chainId number of chainId\n  /// @param _deltaAllocation delta allocation\n  function addDeltaAllocationChain(\n    uint256 _vaultNumber,\n    uint256 _chainId,\n    int256 _deltaAllocation\n  ) internal {\n    vaults[_vaultNumber].deltaAllocationChain[_chainId] += _deltaAllocation;\n  }\n\n  /// @notice Getter for delta allocation in a particulair chainId\n  /// @param _vaultNumber number of vault\n  /// @param _chainId number of chainId\n  /// @return allocation delta allocation\n  function getDeltaAllocationChain(\n    uint256 _vaultNumber,\n    uint256 _chainId\n  ) public view returns (int256) {\n    return vaults[_vaultNumber].deltaAllocationChain[_chainId];\n  }\n\n  /// @notice Setter for the delta allocation in Protocol vault e.g compound_usdc_01\n  /// @dev Allocation can be negative\n  /// @param _vaultNumber number of vault\n  /// @param _chainId number of chainId\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @param _deltaAllocation Delta allocation in tokens\n  function addDeltaAllocationProtocol(\n    uint256 _vaultNumber,\n    uint256 _chainId,\n    uint256 _protocolNum,\n    int256 _deltaAllocation\n  ) internal {\n    vaults[_vaultNumber].deltaAllocationProtocol[_chainId][_protocolNum] += _deltaAllocation;\n  }\n\n  /// @notice Getter for the delta allocation in Protocol vault e.g compound_usdc_01\n  /// @param _vaultNumber number of vault\n  /// @param _chainId number of chainId\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @return allocation Delta allocation in tokens\n  function getDeltaAllocationProtocol(\n    uint256 _vaultNumber,\n    uint256 _chainId,\n    uint256 _protocolNum\n  ) public view returns (int256) {\n    return vaults[_vaultNumber].deltaAllocationProtocol[_chainId][_protocolNum];\n  }\n\n  /// @notice Setter to set the total number of allocated tokens. Only the owner of the basket can set this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _allocation Number of derby tokens that are allocated towards protocols.\n  function setBasketTotalAllocatedTokens(\n    uint256 _basketId,\n    int256 _allocation\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].nrOfAllocatedTokens += _allocation;\n    require(basketTotalAllocatedTokens(_basketId) >= 0, \"Basket: underflow\");\n  }\n\n  /// @notice function to see the total number of allocated tokens. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Number of derby tokens that are allocated towards protocols.\n  function basketTotalAllocatedTokens(uint256 _basketId) public view returns (int256) {\n    return baskets[_basketId].nrOfAllocatedTokens;\n  }\n\n  /// @notice Setter to set the allocation of a specific protocol by a basketId. Only the owner of the basket can set this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _chainId number of chainId.\n  /// @param _protocolId Id of the protocol of which the allocation is queried.\n  /// @param _allocation Number of derby tokens that are allocated towards this specific protocol.\n  function setBasketAllocationInProtocol(\n    uint256 _basketId,\n    uint256 _chainId,\n    uint256 _protocolId,\n    int256 _allocation\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].allocations[_chainId][_protocolId] += _allocation;\n    require(basketAllocationInProtocol(_basketId, _chainId, _protocolId) >= 0, \"Basket: underflow\");\n  }\n\n  /// @notice function to see the allocation of a specific protocol by a basketId. Only the owner of the basket can view this\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _chainId number of chainId\n  /// @param _protocolId Id of the protocol of which the allocation is queried\n  /// @return int256 Number of derby tokens that are allocated towards this specific protocol\n  function basketAllocationInProtocol(\n    uint256 _basketId,\n    uint256 _chainId,\n    uint256 _protocolId\n  ) public view onlyBasketOwner(_basketId) returns (int256) {\n    return baskets[_basketId].allocations[_chainId][_protocolId];\n  }\n\n  /// @notice Setter for rebalancing period of the basket, used to calculate the rewards\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _vaultNumber number of vault\n  function setBasketRebalancingPeriod(\n    uint256 _basketId,\n    uint256 _vaultNumber\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].lastRebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod + 1;\n  }\n\n  /// @notice function to see the total unredeemed rewards the basket has built up. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Total unredeemed rewards.\n  function basketUnredeemedRewards(\n    uint256 _basketId\n  ) external view onlyBasketOwner(_basketId) returns (int256) {\n    return baskets[_basketId].totalUnRedeemedRewards;\n  }\n\n  /// @notice function to see the total reeemed rewards from the basket. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Total redeemed rewards.\n  function basketRedeemedRewards(\n    uint256 _basketId\n  ) external view onlyBasketOwner(_basketId) returns (int) {\n    return baskets[_basketId].totalRedeemedRewards;\n  }\n\n  /// @notice Mints a new NFT with a Basket of allocations.\n  /// @dev The basket NFT is minted for a specific vault, starts with a zero allocation and the tokens are not locked here.\n  /// @param _vaultNumber Number of the vault. Same as in Router.\n  /// @return basketId The basket Id the user has minted.\n  function mintNewBasket(uint256 _vaultNumber) external returns (uint256) {\n    // mint Basket with nrOfUnAllocatedTokens equal to _lockedTokenAmount\n    baskets[latestBasketId].vaultNumber = _vaultNumber;\n    baskets[latestBasketId].lastRebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod + 1;\n    _safeMint(msg.sender, latestBasketId);\n    latestBasketId++;\n\n    emit BasketId(msg.sender, latestBasketId - 1);\n    return latestBasketId - 1;\n  }\n\n  /// @notice Function to lock xaver tokens to a basket. They start out to be unallocated.\n  /// @param _lockedTokenAmount Amount of xaver tokens to lock inside this contract.\n  function lockTokensToBasket(uint256 _lockedTokenAmount) internal {\n    uint256 balanceBefore = derbyToken.balanceOf(address(this));\n    derbyToken.safeTransferFrom(msg.sender, address(this), _lockedTokenAmount);\n    uint256 balanceAfter = derbyToken.balanceOf(address(this));\n\n    require((balanceAfter - balanceBefore - _lockedTokenAmount) == 0, \"Error lock: under/overflow\");\n  }\n\n  /// @notice Function to unlock xaver tokens. If tokens are still allocated to protocols they first hevae to be unallocated.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _unlockedTokenAmount Amount of derby tokens to unlock and send to the user.\n  function unlockTokensFromBasket(uint256 _basketId, uint256 _unlockedTokenAmount) internal {\n    uint256 tokensBurned = redeemNegativeRewards(_basketId, _unlockedTokenAmount);\n    uint256 tokensToUnlock = _unlockedTokenAmount -= tokensBurned;\n\n    uint256 balanceBefore = derbyToken.balanceOf(address(this));\n    derbyToken.safeTransfer(msg.sender, tokensToUnlock);\n    uint256 balanceAfter = derbyToken.balanceOf(address(this));\n\n    require((balanceBefore - balanceAfter - tokensToUnlock) == 0, \"Error unlock: under/overflow\");\n  }\n\n  /// @notice IMPORTANT: The negativeRewardFactor takes in account an approximation of the price of derby tokens by the dao\n  /// @notice IMPORTANT: This will change to an exact price when there is a derby token liquidity pool\n  /// @notice Calculates if there are any negative rewards and how many tokens to burn\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _unlockedTokens Amount of derby tokens to unlock and send to user\n  /// @return tokensToBurn Amount of derby tokens that are burned\n  function redeemNegativeRewards(\n    uint256 _basketId,\n    uint256 _unlockedTokens\n  ) internal returns (uint256) {\n    int256 unredeemedRewards = baskets[_basketId].totalUnRedeemedRewards;\n    if (unredeemedRewards > negativeRewardThreshold) return 0;\n\n    uint256 tokensToBurn = (uint(-unredeemedRewards) * negativeRewardFactor) / 100;\n    tokensToBurn = tokensToBurn < _unlockedTokens ? tokensToBurn : _unlockedTokens;\n\n    baskets[_basketId].totalUnRedeemedRewards += int((tokensToBurn * 100) / negativeRewardFactor);\n\n    IERC20(derbyToken).safeTransfer(homeVault, tokensToBurn);\n\n    return tokensToBurn;\n  }\n\n  /// @notice rebalances an existing Basket\n  /// @dev First calculates the rewards the basket has built up, then sets the new allocations and communicates the deltas to the vault\n  /// @dev Finally it locks or unlocks tokens\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _deltaAllocations delta allocations set by the user of the basket. Allocations are scaled (so * 1E18).\n  function rebalanceBasket(\n    uint256 _basketId,\n    int256[][] memory _deltaAllocations\n  ) external onlyBasketOwner(_basketId) nonReentrant {\n    uint256 vaultNumber = baskets[_basketId].vaultNumber;\n    for (uint k = 0; k < chainIds.length; k++) {\n      require(!isXChainRebalancing[vaultNumber][chainIds[k]], \"Game: vault is xChainRebalancing\");\n    }\n\n    addToTotalRewards(_basketId);\n    int256 totalDelta = settleDeltaAllocations(_basketId, vaultNumber, _deltaAllocations);\n\n    lockOrUnlockTokens(_basketId, totalDelta);\n    setBasketTotalAllocatedTokens(_basketId, totalDelta);\n    setBasketRebalancingPeriod(_basketId, vaultNumber);\n  }\n\n  /// @notice Internal helper to calculate and settle the delta allocations from baskets\n  /// @dev Sets the total allocations per ChainId, used in XChainController\n  /// @dev Sets the total allocations per protocol number, used in Vaults\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _vaultNumber number of vault\n  /// @param _deltaAllocations delta allocations set by the user of the basket. Allocations are scaled (so * 1E18)\n  /// @return totalDelta total delta allocated tokens of the basket, used in lockOrUnlockTokens\n  function settleDeltaAllocations(\n    uint256 _basketId,\n    uint256 _vaultNumber,\n    int256[][] memory _deltaAllocations\n  ) internal returns (int256 totalDelta) {\n    for (uint256 i = 0; i < _deltaAllocations.length; i++) {\n      int256 chainTotal;\n      uint32 chain = chainIds[i];\n      uint256 latestProtocol = latestProtocolId[chain];\n      require(_deltaAllocations[i].length == latestProtocol, \"Invalid allocation length\");\n\n      for (uint256 j = 0; j < latestProtocol; j++) {\n        int256 allocation = _deltaAllocations[i][j];\n        if (allocation == 0) continue;\n        chainTotal += allocation;\n        addDeltaAllocationProtocol(_vaultNumber, chain, j, allocation);\n        setBasketAllocationInProtocol(_basketId, chain, j, allocation);\n      }\n\n      totalDelta += chainTotal;\n      addDeltaAllocationChain(_vaultNumber, chain, chainTotal);\n    }\n  }\n\n  /// @notice rewards are calculated here.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  function addToTotalRewards(uint256 _basketId) internal onlyBasketOwner(_basketId) {\n    if (baskets[_basketId].nrOfAllocatedTokens == 0) return;\n\n    uint256 vaultNum = baskets[_basketId].vaultNumber;\n    uint256 currentRebalancingPeriod = vaults[vaultNum].rebalancingPeriod;\n    uint256 lastRebalancingPeriod = baskets[_basketId].lastRebalancingPeriod;\n\n    if (currentRebalancingPeriod <= lastRebalancingPeriod) return;\n\n    for (uint k = 0; k < chainIds.length; k++) {\n      uint32 chain = chainIds[k];\n      uint256 latestProtocol = latestProtocolId[chain];\n      for (uint i = 0; i < latestProtocol; i++) {\n        int256 allocation = basketAllocationInProtocol(_basketId, chain, i) / 1E18;\n        if (allocation == 0) continue;\n\n        int256 lastRebalanceReward = getRewardsPerLockedToken(\n          vaultNum,\n          chain,\n          lastRebalancingPeriod,\n          i\n        );\n        int256 currentReward = getRewardsPerLockedToken(\n          vaultNum,\n          chain,\n          currentRebalancingPeriod,\n          i\n        );\n        baskets[_basketId].totalUnRedeemedRewards +=\n          (currentReward - lastRebalanceReward) *\n          allocation;\n      }\n    }\n  }\n\n  /// @notice Internal helper to lock or unlock tokens from the game contract\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _totalDelta total delta allocated tokens of the basket, calculated in settleDeltaAllocations\n  function lockOrUnlockTokens(uint256 _basketId, int256 _totalDelta) internal {\n    if (_totalDelta > 0) {\n      lockTokensToBasket(uint256(_totalDelta));\n    }\n    if (_totalDelta < 0) {\n      int256 oldTotal = basketTotalAllocatedTokens(_basketId);\n      int256 newTotal = oldTotal + _totalDelta;\n      int256 tokensToUnlock = oldTotal - newTotal;\n      require(oldTotal >= tokensToUnlock, \"Not enough tokens locked\");\n\n      unlockTokensFromBasket(_basketId, uint256(tokensToUnlock));\n    }\n  }\n\n  /// @notice Step 1 trigger; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Trigger for Dao to push delta allocations to the xChainController\n  /// @param _vaultNumber Number of vault\n  /// @dev Sends over an array that should match the IDs in chainIds array\n  function pushAllocationsToController(uint256 _vaultNumber) external payable {\n    require(rebalanceNeeded(), \"No rebalance needed\");\n    for (uint k = 0; k < chainIds.length; k++) {\n      require(\n        getVaultAddress(_vaultNumber, chainIds[k]) != address(0),\n        \"Game: not a valid vaultnumber\"\n      );\n      require(\n        !isXChainRebalancing[_vaultNumber][chainIds[k]],\n        \"Game: vault is already rebalancing\"\n      );\n      isXChainRebalancing[_vaultNumber][chainIds[k]] = true;\n    }\n\n    int256[] memory deltas = allocationsToArray(_vaultNumber);\n    IXProvider(xProvider).pushAllocations{value: msg.value}(_vaultNumber, deltas);\n\n    lastTimeStamp = block.timestamp;\n    vaults[_vaultNumber].rebalancingPeriod++;\n\n    emit PushedAllocationsToController(_vaultNumber, deltas);\n  }\n\n  /// @notice Creates delta allocation array for chains matching IDs in chainIds array\n  /// @notice Resets deltaAllocation for chainIds\n  /// @return deltas Array with delta Allocations for all chainIds\n  function allocationsToArray(uint256 _vaultNumber) internal returns (int256[] memory deltas) {\n    deltas = new int[](chainIds.length);\n\n    for (uint256 i = 0; i < chainIds.length; i++) {\n      uint32 chain = chainIds[i];\n      deltas[i] = getDeltaAllocationChain(_vaultNumber, chain);\n      vaults[_vaultNumber].deltaAllocationChain[chain] = 0;\n    }\n  }\n\n  /// @notice Step 6 trigger; Game pushes deltaAllocations to vaults\n  /// @notice Trigger to push delta allocations in protocols to cross chain vaults\n  /// @param _vaultNumber Number of vault\n  /// @param _chain Chain id of the vault where the allocations need to be sent\n  /// @dev Sends over an array where the index is the protocolId\n  function pushAllocationsToVaults(uint256 _vaultNumber, uint32 _chain) external payable {\n    address vault = getVaultAddress(_vaultNumber, _chain);\n    require(vault != address(0), \"Game: not a valid vaultnumber\");\n    require(isXChainRebalancing[_vaultNumber][_chain], \"Vault is not rebalancing\");\n\n    int256[] memory deltas = protocolAllocationsToArray(_vaultNumber, _chain);\n\n    IXProvider(xProvider).pushProtocolAllocationsToVault{value: msg.value}(_chain, vault, deltas);\n\n    emit PushProtocolAllocations(_chain, getVaultAddress(_vaultNumber, _chain), deltas);\n\n    isXChainRebalancing[_vaultNumber][_chain] = false;\n  }\n\n  /// @notice Creates array with delta allocations in protocols for given chainId\n  /// @return deltas Array with allocations where the index matches the protocolId\n  function protocolAllocationsToArray(\n    uint256 _vaultNumber,\n    uint32 _chainId\n  ) internal returns (int256[] memory deltas) {\n    uint256 latestId = latestProtocolId[_chainId];\n    deltas = new int[](latestId);\n\n    for (uint256 i = 0; i < latestId; i++) {\n      deltas[i] = getDeltaAllocationProtocol(_vaultNumber, _chainId, i);\n      vaults[_vaultNumber].deltaAllocationProtocol[_chainId][i] = 0;\n    }\n  }\n\n  /// @notice See settleRewardsInt below\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Rewards per locked token per protocol (each protocol is an element in the array)\n  function settleRewards(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlyXProvider {\n    settleRewardsInt(_vaultNumber, _chainId, _rewards);\n  }\n\n  // basket should not be able to rebalance before this step\n  /// @notice Step 8 end; Vaults push rewardsPerLockedToken to game\n  /// @notice Loops through the array and fills the rewardsPerLockedToken mapping with the values\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function settleRewardsInt(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) internal {\n    uint256 rebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod;\n\n    for (uint256 i = 0; i < _rewards.length; i++) {\n      int256 lastReward = getRewardsPerLockedToken(\n        _vaultNumber,\n        _chainId,\n        rebalancingPeriod - 1,\n        i\n      );\n      vaults[_vaultNumber].rewardPerLockedToken[_chainId][rebalancingPeriod][i] =\n        lastReward +\n        _rewards[i];\n    }\n  }\n\n  /// @notice Getter for rewardsPerLockedToken for given vaultNumber => chainId => rebalancingPeriod => protocolId\n  function getRewardsPerLockedToken(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _rebalancingPeriod,\n    uint256 _protocolId\n  ) internal view returns (int256) {\n    return vaults[_vaultNumber].rewardPerLockedToken[_chainId][_rebalancingPeriod][_protocolId];\n  }\n\n  /// @notice redeem funds from basket in the game.\n  /// @dev makes a call to the vault to make the actual transfer because the vault holds the funds.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  function redeemRewards(uint256 _basketId) external onlyBasketOwner(_basketId) {\n    int256 amount = baskets[_basketId].totalUnRedeemedRewards;\n    require(amount > 0, \"Nothing to claim\");\n\n    baskets[_basketId].totalRedeemedRewards += amount;\n    baskets[_basketId].totalUnRedeemedRewards = 0;\n\n    IVault(homeVault).redeemRewardsGame(uint256(amount), msg.sender);\n  }\n\n  /// @notice Checks if a rebalance is needed based on the set interval\n  /// @return bool True of rebalance is needed, false if not\n  function rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n  }\n\n  /// @notice getter for vault address linked to a chainId\n  function getVaultAddress(uint256 _vaultNumber, uint32 _chainId) internal view returns (address) {\n    return vaults[_vaultNumber].vaultAddress[_chainId];\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /// @notice Getter for guardian address\n  function getGuardian() public view returns (address) {\n    return guardian;\n  }\n\n  /// @notice Getter for chainId array\n  function getChainIds() public view returns (uint32[] memory) {\n    return chainIds;\n  }\n\n  /// @notice Getter for rebalancing period for a vault\n  function getRebalancingPeriod(uint256 _vaultNumber) public view returns (uint256) {\n    return vaults[_vaultNumber].rebalancingPeriod;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Setter for xProvider address\n  /// @param _xProvider new address of xProvider on this chain\n  function setXProvider(address _xProvider) external onlyDao {\n    xProvider = _xProvider;\n  }\n\n  /// @notice Setter for homeVault address\n  /// @param _homeVault new address of homeVault on this chain\n  function setHomeVault(address _homeVault) external onlyDao {\n    homeVault = _homeVault;\n  }\n\n  /// @notice Set minimum interval for the rebalance function\n  /// @param _timestampInternal UNIX timestamp\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyDao {\n    rebalanceInterval = _timestampInternal;\n  }\n\n  /// @notice Setter for DAO address\n  /// @param _dao DAO address\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /// @notice Setter Derby token address\n  /// @param _derbyToken new address of Derby token\n  function setDerbyToken(address _derbyToken) external onlyDao {\n    derbyToken = IERC20(_derbyToken);\n  }\n\n  /// @notice Setter for threshold at which user tokens will be sold / burned\n  /// @param _threshold treshold in vaultCurrency e.g USDC, must be negative\n  function setNegativeRewardThreshold(int256 _threshold) external onlyDao {\n    negativeRewardThreshold = _threshold;\n  }\n\n  /// @notice Setter for negativeRewardFactor\n  /// @param _factor percentage of tokens that will be sold / burned\n  function setNegativeRewardFactor(uint256 _factor) external onlyDao {\n    negativeRewardFactor = _factor;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice setter to link a chainId to a vault address for cross chain functions\n  function setVaultAddress(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    address _address\n  ) external onlyGuardian {\n    vaults[_vaultNumber].vaultAddress[_chainId] = _address;\n  }\n\n  /// @notice Setter for latest protocol Id for given chainId.\n  /// @param _chainId number of chain id set in chainIds array\n  /// @param _latestProtocolId latest protocol Id aka number of supported protocol vaults, starts at 0\n  function setLatestProtocolId(uint32 _chainId, uint256 _latestProtocolId) external onlyGuardian {\n    latestProtocolId[_chainId] = _latestProtocolId;\n  }\n\n  /// @notice Setter for chainId array\n  /// @param _chainIds array of all the used chainIds\n  function setChainIds(uint32[] memory _chainIds) external onlyGuardian {\n    chainIds = _chainIds;\n  }\n\n  /// @notice Guardian function to set state when vault gets stuck for whatever reason\n  function setRebalancingState(\n    uint256 _vaultNumber,\n    uint32 _chain,\n    bool _state\n  ) external onlyGuardian {\n    isXChainRebalancing[_vaultNumber][_chain] = _state;\n  }\n\n  /// @notice Guardian function to set rebalancing period for vaultNumber\n  function setRebalancingPeriod(uint256 _vaultNumber, uint256 _period) external onlyGuardian {\n    vaults[_vaultNumber].rebalancingPeriod = _period;\n  }\n\n  /// @notice Step 8: Guardian function\n  function settleRewardsGuard(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlyGuardian {\n    settleRewardsInt(_vaultNumber, _chainId, _rewards);\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/MainVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"./Vault.sol\";\n\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract MainVault is Vault, VaultToken {\n  using SafeERC20 for IERC20;\n\n  struct UserInfo {\n    // amount in vaultCurrency the vault owes to the user\n    uint256 withdrawalAllowance;\n    // rebalancing period the withdrawal request is made\n    uint256 withdrawalRequestPeriod;\n    // amount in vaultCurrency the vault owes to the user\n    uint256 rewardAllowance;\n    // rebalancing period the reward request is made\n    uint256 rewardRequestPeriod;\n  }\n\n  address public derbyToken;\n  address public game;\n  address public xProvider;\n\n  bool public vaultOff;\n  // True when rewards should be swapped to derby tokens\n  bool public swapRewards;\n\n  // total amount of withdrawal requests for the vault to pull extra during a cross-chain rebalance, will be upped when a user makes a withdrawalRequest\n  // during a cross-chain rebalance the vault will pull extra funds by the amount of totalWithdrawalRequests and the totalWithdrawalRequests will turn into actual reservedFunds\n  uint256 internal totalWithdrawalRequests;\n  uint256 public exchangeRate;\n  uint32 public homeChain;\n  uint256 public amountToSendXChain;\n  uint256 public governanceFee; // Basis points\n  uint256 public maxDivergenceWithdraws;\n\n  string internal allowanceError = \"!Allowance\";\n\n  // (userAddress => userInfo struct)\n  mapping(address => UserInfo) internal userInfo;\n\n  // training\n  bool private training;\n  uint256 private maxTrainingDeposit;\n  mapping(address => bool) private whitelist;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    uint256 _vaultNumber,\n    address _dao,\n    address _game,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  )\n    VaultToken(_name, _symbol, _decimals)\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale)\n  {\n    exchangeRate = _uScale;\n    game = _game;\n    governanceFee = 0;\n    maxDivergenceWithdraws = 1_000_000;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"only xProvider\");\n    _;\n  }\n\n  modifier onlyWhenVaultIsOn() {\n    require(state == State.Idle, \"Rebalancing\");\n    require(!vaultOff, \"Vault is off\");\n    _;\n  }\n\n  modifier onlyWhenIdle() {\n    require(state == State.Idle, \"Rebalancing\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"only game\");\n    _;\n  }\n\n  event PushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  );\n  event RebalanceXChain(uint256 _vaultNumber, uint256 _amount, address _asset);\n  event PushedRewardsToGame(uint256 _vaultNumber, uint32 _chain, int256[] _rewards);\n\n  /// @notice Deposit in Vault\n  /// @dev Deposit VaultCurrency to Vault and mint LP tokens\n  /// @param _amount Amount to deposit\n  /// @param _receiver Receiving adress for the tokens\n  /// @return shares Tokens received by buyer\n  function deposit(\n    uint256 _amount,\n    address _receiver\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n      require(whitelist[msg.sender]);\n      uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n      require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n\n    uint256 balanceBefore = getVaultBalance() - reservedFunds;\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 balanceAfter = getVaultBalance() - reservedFunds;\n\n    uint256 amount = balanceAfter - balanceBefore;\n    shares = (amount * (10 ** decimals())) / exchangeRate;\n\n    _mint(_receiver, shares);\n  }\n\n  /// @notice Withdraw from Vault\n  /// @dev Withdraw VaultCurrency from Vault and burn LP tokens\n  /// @param _amount Amount to withdraw in LP tokens\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @return value Amount received by seller in vaultCurrency\n  function withdraw(\n    uint256 _amount,\n    address _receiver,\n    address _owner\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    require(value > 0, \"!value\");\n\n    require(getVaultBalance() - reservedFunds >= value, \"!funds\");\n\n    _burn(msg.sender, _amount);\n    transferFunds(_receiver, value);\n  }\n\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\n  /// @param _amount Amount to withdraw in LP token\n  function withdrawalRequest(\n    uint256 _amount\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, \"Already a request\");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n  }\n\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\n  /// @dev Will send the user funds and reset the allowance\n  function withdrawAll"
    }
  ]
}