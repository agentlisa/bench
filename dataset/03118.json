{
  "Title": "L2 tokens could get stuck",
  "Content": "The [`release` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118) in the `StakingEscrow` contract allows users to send tokens from the `StakingEscrow` contract to another account on L2. However, in order to preserve the vesting schedule, FORT tokens are NOT allowed to be transferred unless they have been [accounted for by `pendingReward`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L119-L121).\n\n\nTypically if tokens are received as rewards from the staking contract, `pendingReward` will be increased. However, if tokens are sent directly to this contract, it will not increase `pendingReward` and the tokens will not be transferable. Instead, users will only be able to [`bridge`](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L148-L150) their FORT tokens, subjecting them to the vesting schedule on L1.\n\n\nConsider implementing some accounting to allow for users to transfer FORT tokens to this contract, and afterwards transfer them out via the [`release` function](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/vesting/escrow/StakingEscrow.sol#L118). Alternatively, consider making a clear warning to any `StakingEscrow` contract users that FORT tokens transferred to the contract will not be `release`-able and will be subjected to vesting.\n\n\n***Update:** Fixed on [commit `9d821024623005808eddd6765d8260f1d2a2301d` in pull request 55](https://github.com/forta-protocol/forta-token/pull/55/commits/9d821024623005808eddd6765d8260f1d2a2301d). A warning has been added to let users know about this behavior.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vesting/escrow/StakingEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../../token/FortaBridgedPolygon.sol\";\nimport \"../../components/staking/FortaStaking.sol\";\nimport \"../../components/utils/ForwardedContext.sol\";\n\n/**\n * Logic for the escrow that handles vesting tokens, on the child chain, for a vesting wallet\n * on the parent chain. Instances are created as Minimal Proxy Clones.\n *\n * This contract contains some immutable parameters, common to all instances, that are set at\n * construction and some \"normal\" storage-based parameters that are instance specific and set\n * during initialization.\n */\ncontract StakingEscrow is Initializable, ERC165, IRewardReceiver, ForwardedContext, ERC1155Receiver {\n    FortaBridgedPolygon public immutable l2token;\n    FortaStaking public immutable l2staking;\n    address      public           l1vesting;\n    address      public           l2manager;\n    uint256      public           pendingReward;\n\n    modifier onlyManager() {\n        require(_msgSender() == l2manager, \"restricted to manager\");\n        _;\n    }\n\n    modifier vestingBalance(uint256 amount) {\n        require(l2token.balanceOf(address(this)) >= amount + pendingReward, \"rewards should not be bridged or staked\");\n        _;\n    }\n\n    constructor(\n        address      __trustedForwarder,\n        FortaBridgedPolygon __token,\n        FortaStaking __staking\n    ) ForwardedContext(__trustedForwarder) initializer() {\n        l2token   = __token;\n        l2staking = __staking;\n    }\n\n    function initialize(\n        address __l1vesting,\n        address __l2manager\n    ) public initializer {\n        require(__l1vesting != address(0), \"StakingEscrow: __l1vesting cannot be address 0\");\n        require(__l2manager != address(0), \"StakingEscrow: __l1vesting cannot be address 0\");\n        l1vesting = __l1vesting;\n        l2manager = __l2manager;\n    }\n\n    /**\n     * Staking operation: Relay `deposit` calls to the staking contract (with corresponding approval).\n     *\n     * Tokens gained as staking rewards cannot be staked here. They should be released to another account and staked\n     * there.\n     */\n    function deposit(uint8 subjectType, uint256 subject, uint256 stakeValue) public onlyManager() vestingBalance(stakeValue) returns (uint256) {\n        SafeERC20.safeApprove(\n            IERC20(address(l2token)),\n            address(l2staking),\n            stakeValue\n        );\n        return l2staking.deposit(subjectType, subject, stakeValue);\n    }\n\n    /**\n     * Overload: deposit everything\n     */\n    function deposit(uint8 subjectType, uint256 subject) public returns (uint256) {\n        return deposit(subjectType, subject, l2token.balanceOf(address(this)) - pendingReward);\n    }\n\n    /**\n     * Staking operation: Relay `initiateWithdrawal` calls to the staking contract.\n     */\n    function initiateWithdrawal(uint8 subjectType, uint256 subject, uint256 sharesValue) public onlyManager() returns (uint64) {\n        return l2staking.initiateWithdrawal(subjectType, subject, sharesValue);\n    }\n\n    /**\n     * Overload: initiate withdrawal of the full stake amount\n     */\n    function initiateFullWithdrawal(uint8 subjectType, uint256 subject) public returns (uint64) {\n        return initiateWithdrawal(\n            subjectType,\n            subject,\n            l2staking.sharesOf(subjectType, subject, address(this))\n        );\n    }\n\n    /**\n     * Staking operation: Relay `withdrawal` calls to the staking contract.\n     */\n    function withdraw(uint8 subjectType, uint256 subject) public onlyManager() returns (uint256) {\n        return l2staking.withdraw(subjectType, subject);\n    }\n\n    /**\n     * Staking operation: Relay `withdrawal` calls to the staking contract.\n     *\n     * Note: anyone can call that directly on the staking contract. One should not assume rewards claims are done\n     * through this relay function.\n     */\n    function claimReward(uint8 subjectType, uint256 subject) public returns (uint256) {\n        return l2staking.releaseReward(subjectType, subject, address(this));\n    }\n\n    /**\n     * Release reward to any account chosen by the beneficiary. Rewards shouldn't be bridged back to prevent them\n     * from being subject to vesting.\n     *\n     * In addition to releasing rewards, this function can also be used to release any other tokens that would be\n     * sent to this escrow by mistake.\n     */\n    function release(address releaseToken, address receiver, uint256 amount) public onlyManager() {\n        if (address(l2token) == releaseToken) {\n            pendingReward -= amount; // reverts on overflow;\n        }\n\n        SafeERC20.safeTransfer(\n            IERC20(releaseToken),\n            receiver,\n            amount\n        );\n    }\n\n    function releaseAllReward(address receiver) public {\n        release(address(l2token), receiver, pendingReward);\n    }\n\n    /**\n     * Bridge operation: Send token back to the vesting instance on the parent chain.\n     *\n     * Any funds sent to the parent chain will be subject to the vesting schedule there. Consequently, rewards should\n     * not be bridged back, but rather released to another wallet (and potentially bridged back independently).\n     */\n    function bridge(uint256 amount) public onlyManager() vestingBalance(amount) {\n        require(amount > 0, \"StakingEscrow: amount must be > 0\");\n        l2token.withdrawTo(amount, l1vesting);\n    }\n\n    /**\n     * Overload: bridge everything\n     */\n    function bridge() public {\n        bridge(l2token.balanceOf(address(this)) - pendingReward);\n    }\n\n    /**\n     * ERC165 implementation, needed for onRewardReceived.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, ERC1155Receiver) returns (bool) {\n        return\n            interfaceId == type(IRewardReceiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Hook for reward accounting\n     */\n    function onRewardReceived(uint8, uint256, uint256 amount) public {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        pendingReward += amount;\n    }\n\n    /**\n     * This account is going to hold staking shares\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external view returns (bytes4) {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external view returns (bytes4) {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        return this.onERC1155BatchReceived.selector;\n    }\n}"
    },
    {
      "filename": "contracts/vesting/escrow/StakingEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../../token/FortaBridgedPolygon.sol\";\nimport \"../../components/staking/FortaStaking.sol\";\nimport \"../../components/utils/ForwardedContext.sol\";\n\n/**\n * Logic for the escrow that handles vesting tokens, on the child chain, for a vesting wallet\n * on the parent chain. Instances are created as Minimal Proxy Clones.\n *\n * This contract contains some immutable parameters, common to all instances, that are set at\n * construction and some \"normal\" storage-based parameters that are instance specific and set\n * during initialization.\n */\ncontract StakingEscrow is Initializable, ERC165, IRewardReceiver, ForwardedContext, ERC1155Receiver {\n    FortaBridgedPolygon public immutable l2token;\n    FortaStaking public immutable l2staking;\n    address      public           l1vesting;\n    address      public           l2manager;\n    uint256      public           pendingReward;\n\n    modifier onlyManager() {\n        require(_msgSender() == l2manager, \"restricted to manager\");\n        _;\n    }\n\n    modifier vestingBalance(uint256 amount) {\n        require(l2token.balanceOf(address(this)) >= amount + pendingReward, \"rewards should not be bridged or staked\");\n        _;\n    }\n\n    constructor(\n        address      __trustedForwarder,\n        FortaBridgedPolygon __token,\n        FortaStaking __staking\n    ) ForwardedContext(__trustedForwarder) initializer() {\n        l2token   = __token;\n        l2staking = __staking;\n    }\n\n    function initialize(\n        address __l1vesting,\n        address __l2manager\n    ) public initializer {\n        require(__l1vesting != address(0), \"StakingEscrow: __l1vesting cannot be address 0\");\n        require(__l2manager != address(0), \"StakingEscrow: __l1vesting cannot be address 0\");\n        l1vesting = __l1vesting;\n        l2manager = __l2manager;\n    }\n\n    /**\n     * Staking operation: Relay `deposit` calls to the staking contract (with corresponding approval).\n     *\n     * Tokens gained as staking rewards cannot be staked here. They should be released to another account and staked\n     * there.\n     */\n    function deposit(uint8 subjectType, uint256 subject, uint256 stakeValue) public onlyManager() vestingBalance(stakeValue) returns (uint256) {\n        SafeERC20.safeApprove(\n            IERC20(address(l2token)),\n            address(l2staking),\n            stakeValue\n        );\n        return l2staking.deposit(subjectType, subject, stakeValue);\n    }\n\n    /**\n     * Overload: deposit everything\n     */\n    function deposit(uint8 subjectType, uint256 subject) public returns (uint256) {\n        return deposit(subjectType, subject, l2token.balanceOf(address(this)) - pendingReward);\n    }\n\n    /**\n     * Staking operation: Relay `initiateWithdrawal` calls to the staking contract.\n     */\n    function initiateWithdrawal(uint8 subjectType, uint256 subject, uint256 sharesValue) public onlyManager() returns (uint64) {\n        return l2staking.initiateWithdrawal(subjectType, subject, sharesValue);\n    }\n\n    /**\n     * Overload: initiate withdrawal of the full stake amount\n     */\n    function initiateFullWithdrawal(uint8 subjectType, uint256 subject) public returns (uint64) {\n        return initiateWithdrawal(\n            subjectType,\n            subject,\n            l2staking.sharesOf(subjectType, subject, address(this))\n        );\n    }\n\n    /**\n     * Staking operation: Relay `withdrawal` calls to the staking contract.\n     */\n    function withdraw(uint8 subjectType, uint256 subject) public onlyManager() returns (uint256) {\n        return l2staking.withdraw(subjectType, subject);\n    }\n\n    /**\n     * Staking operation: Relay `withdrawal` calls to the staking contract.\n     *\n     * Note: anyone can call that directly on the staking contract. One should not assume rewards claims are done\n     * through this relay function.\n     */\n    function claimReward(uint8 subjectType, uint256 subject) public returns (uint256) {\n        return l2staking.releaseReward(subjectType, subject, address(this));\n    }\n\n    /**\n     * Release reward to any account chosen by the beneficiary. Rewards shouldn't be bridged back to prevent them\n     * from being subject to vesting.\n     *\n     * In addition to releasing rewards, this function can also be used to release any other tokens that would be\n     * sent to this escrow by mistake.\n     */\n    function release(address releaseToken, address receiver, uint256 amount) public onlyManager() {\n        if (address(l2token) == releaseToken) {\n            pendingReward -= amount; // reverts on overflow;\n        }\n\n        SafeERC20.safeTransfer(\n            IERC20(releaseToken),\n            receiver,\n            amount\n        );\n    }\n\n    function releaseAllReward(address receiver) public {\n        release(address(l2token), receiver, pendingReward);\n    }\n\n    /**\n     * Bridge operation: Send token back to the vesting instance on the parent chain.\n     *\n     * Any funds sent to the parent chain will be subject to the vesting schedule there. Consequently, rewards should\n     * not be bridged back, but rather released to another wallet (and potentially bridged back independently).\n     */\n    function bridge(uint256 amount) public onlyManager() vestingBalance(amount) {\n        require(amount > 0, \"StakingEscrow: amount must be > 0\");\n        l2token.withdrawTo(amount, l1vesting);\n    }\n\n    /**\n     * Overload: bridge everything\n     */\n    function bridge() public {\n        bridge(l2token.balanceOf(address(this)) - pendingReward);\n    }\n\n    /**\n     * ERC165 implementation, needed for onRewardReceived.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, ERC1155Receiver) returns (bool) {\n        return\n            interfaceId == type(IRewardReceiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Hook for reward accounting\n     */\n    function onRewardReceived(uint8, uint256, uint256 amount) public {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        pendingReward += amount;\n    }\n\n    /**\n     * This account is going to hold staking shares\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external view returns (bytes4) {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external view returns (bytes4) {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        return this.onERC1155BatchReceived.selector;\n    }\n}"
    },
    {
      "filename": "contracts/vesting/escrow/StakingEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../../token/FortaBridgedPolygon.sol\";\nimport \"../../components/staking/FortaStaking.sol\";\nimport \"../../components/utils/ForwardedContext.sol\";\n\n/**\n * Logic for the escrow that handles vesting tokens, on the child chain, for a vesting wallet\n * on the parent chain. Instances are created as Minimal Proxy Clones.\n *\n * This contract contains some immutable parameters, common to all instances, that are set at\n * construction and some \"normal\" storage-based parameters that are instance specific and set\n * during initialization.\n */\ncontract StakingEscrow is Initializable, ERC165, IRewardReceiver, ForwardedContext, ERC1155Receiver {\n    FortaBridgedPolygon public immutable l2token;\n    FortaStaking public immutable l2staking;\n    address      public           l1vesting;\n    address      public           l2manager;\n    uint256      public           pendingReward;\n\n    modifier onlyManager() {\n        require(_msgSender() == l2manager, \"restricted to manager\");\n        _;\n    }\n\n    modifier vestingBalance(uint256 amount) {\n        require(l2token.balanceOf(address(this)) >= amount + pendingReward, \"rewards should not be bridged or staked\");\n        _;\n    }\n\n    constructor(\n        address      __trustedForwarder,\n        FortaBridgedPolygon __token,\n        FortaStaking __staking\n    ) ForwardedContext(__trustedForwarder) initializer() {\n        l2token   = __token;\n        l2staking = __staking;\n    }\n\n    function initialize(\n        address __l1vesting,\n        address __l2manager\n    ) public initializer {\n        require(__l1vesting != address(0), \"StakingEscrow: __l1vesting cannot be address 0\");\n        require(__l2manager != address(0), \"StakingEscrow: __l1vesting cannot be address 0\");\n        l1vesting = __l1vesting;\n        l2manager = __l2manager;\n    }\n\n    /**\n     * Staking operation: Relay `deposit` calls to the staking contract (with corresponding approval).\n     *\n     * Tokens gained as staking rewards cannot be staked here. They should be released to another account and staked\n     * there.\n     */\n    function deposit(uint8 subjectType, uint256 subject, uint256 stakeValue) public onlyManager() vestingBalance(stakeValue) returns (uint256) {\n        SafeERC20.safeApprove(\n            IERC20(address(l2token)),\n            address(l2staking),\n            stakeValue\n        );\n        return l2staking.deposit(subjectType, subject, stakeValue);\n    }\n\n    /**\n     * Overload: deposit everything\n     */\n    function deposit(uint8 subjectType, uint256 subject) public returns (uint256) {\n        return deposit(subjectType, subject, l2token.balanceOf(address(this)) - pendingReward);\n    }\n\n    /**\n     * Staking operation: Relay `initiateWithdrawal` calls to the staking contract.\n     */\n    function initiateWithdrawal(uint8 subjectType, uint256 subject, uint256 sharesValue) public onlyManager() returns (uint64) {\n        return l2staking.initiateWithdrawal(subjectType, subject, sharesValue);\n    }\n\n    /**\n     * Overload: initiate withdrawal of the full stake amount\n     */\n    function initiateFullWithdrawal(uint8 subjectType, uint256 subject) public returns (uint64) {\n        return initiateWithdrawal(\n            subjectType,\n            subject,\n            l2staking.sharesOf(subjectType, subject, address(this))\n        );\n    }\n\n    /**\n     * Staking operation: Relay `withdrawal` calls to the staking contract.\n     */\n    function withdraw(uint8 subjectType, uint256 subject) public onlyManager() returns (uint256) {\n        return l2staking.withdraw(subjectType, subject);\n    }\n\n    /**\n     * Staking operation: Relay `withdrawal` calls to the staking contract.\n     *\n     * Note: anyone can call that directly on the staking contract. One should not assume rewards claims are done\n     * through this relay function.\n     */\n    function claimReward(uint8 subjectType, uint256 subject) public returns (uint256) {\n        return l2staking.releaseReward(subjectType, subject, address(this));\n    }\n\n    /**\n     * Release reward to any account chosen by the beneficiary. Rewards shouldn't be bridged back to prevent them\n     * from being subject to vesting.\n     *\n     * In addition to releasing rewards, this function can also be used to release any other tokens that would be\n     * sent to this escrow by mistake.\n     */\n    function release(address releaseToken, address receiver, uint256 amount) public onlyManager() {\n        if (address(l2token) == releaseToken) {\n            pendingReward -= amount; // reverts on overflow;\n        }\n\n        SafeERC20.safeTransfer(\n            IERC20(releaseToken),\n            receiver,\n            amount\n        );\n    }\n\n    function releaseAllReward(address receiver) public {\n        release(address(l2token), receiver, pendingReward);\n    }\n\n    /**\n     * Bridge operation: Send token back to the vesting instance on the parent chain.\n     *\n     * Any funds sent to the parent chain will be subject to the vesting schedule there. Consequently, rewards should\n     * not be bridged back, but rather released to another wallet (and potentially bridged back independently).\n     */\n    function bridge(uint256 amount) public onlyManager() vestingBalance(amount) {\n        require(amount > 0, \"StakingEscrow: amount must be > 0\");\n        l2token.withdrawTo(amount, l1vesting);\n    }\n\n    /**\n     * Overload: bridge everything\n     */\n    function bridge() public {\n        bridge(l2token.balanceOf(address(this)) - pendingReward);\n    }\n\n    /**\n     * ERC165 implementation, needed for onRewardReceived.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, ERC1155Receiver) returns (bool) {\n        return\n            interfaceId == type(IRewardReceiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Hook for reward accounting\n     */\n    function onRewardReceived(uint8, uint256, uint256 amount) public {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        pendingReward += amount;\n    }\n\n    /**\n     * This account is going to hold staking shares\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external view returns (bytes4) {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external view returns (bytes4) {\n        require(msg.sender == address(l2staking), \"StakingEscrow: sender must be l2staking\");\n        return this.onERC1155BatchReceived.selector;\n    }\n}"
    }
  ]
}