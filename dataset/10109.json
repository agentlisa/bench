{
  "Title": "[M-04] Fee on transfer tokens do not work within the protocol",
  "Content": "_Submitted by anon_.\n\nFee on transfer tokens transfer less tokens in than what would be expect.\nThis means that the protocol request incorrect amounts when dealing with these tokens.\n\n<https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L256>\n\nThe protocol should use stored token balances instead of transfer for calculating amounts.\n\n**[frank-beard (Kuiper) acknowledged](https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/78)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/78#issuecomment-997464504):**\n> I agree with the finding and the severity.\n> Given a `feeOnTransferToken`, the accounting of the protocol will break.\n>\n> because this is dependent on an external condition (using `feeOnTransferToken`) this is a medium severity finding\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-defiProtocol",
  "Code": [
    {
      "filename": "contracts/contracts/Basket.sol",
      "content": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; // 1 day in blocks\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {\n        return (pendingWeights.tokens, pendingWeights.weights);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public nonReentrant override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        handleFees();\n        uint256 startSupply = totalSupply();\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees() private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else {\n            uint256 startSupply = totalSupply();\n\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.block = block.number;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.block = block.number;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.block = block.number;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.block = block.number;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(publisher);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}"
    }
  ]
}