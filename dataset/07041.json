{
  "Title": "[G-04] Storage",
  "Content": "\nConsider a storage reference in `SubprotocolRegistry` for [`SubprotocolData memory subprotocolData`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L89). This would be cheaper in the case of `SubprotocolAlreadyExists` since that only accesses one of the two slots. And does not negatively impact the happy case. \n\nIt may be considered cleaner syntax since [`subprotocols[_name] = subprotocolData;`](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/SubprotocolRegistry.sol#L99) may then be removed, but that is subjective.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-canto-identity-protocol-contest",
  "Code": [
    {
      "filename": "src/SubprotocolRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./CidSubprotocolNFT.sol\";\n\n/// @title Subprotocol Registry\n/// @notice Enables registration of new subprotocols\ncontract SubprotocolRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee for registering a new subprotocol (100 $NOTE)\n    uint256 public constant REGISTER_FEE = 100 * 10**18;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Wallet that receives fees paid when registering\n    address public immutable cidFeeWallet;\n\n    /// @notice Data that is associated with a subprotocol.\n    /// @dev Data types are chosen such that all data fits in one slot\n    struct SubprotocolData {\n        /// @notice Owner (registrant) of the subprotocol\n        address owner;\n        /// @notice Optional cost in NOTE to add an NFT\n        /// @dev Maximum value is (2^96 - 1) / 10^18 =~ 80 billion. Zero for no fee\n        uint96 fee;\n        address nftAddress;\n        bool ordered;\n        bool primary;\n        bool active;\n    }\n\n    /// @notice Mapping (name => data) that contains all registered subprotocols\n    mapping(string => SubprotocolData) private subprotocols;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event SubprotocolRegistered(\n        address indexed registrar,\n        string indexed name,\n        address indexed nftAddress,\n        bool ordered,\n        bool primary,\n        bool active,\n        uint96 fee\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error SubprotocolAlreadyExists(string name, address owner);\n    error NoTypeSpecified(string name);\n    error NotASubprotocolNFT(address nftAddress);\n\n    /// @notice Sets the reference to the $NOTE contract\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    constructor(address _noteContract, address _cidFeeWallet) {\n        note = ERC20(_noteContract);\n        cidFeeWallet = _cidFeeWallet;\n    }\n\n    /// @notice Register a new subprotocol. There is a 100 $NOTE fee when registering\n    /// @dev The options ordered, primary, active are not mutually exclusive. In practice, only one will be set for most subprotocols,\n    /// but if a subprotocol for instance supports int keys (mapped to one value) and a list of active NFTs, ordered and active is true.\n    /// @param _ordered Ordering allows integers to be used as map keys, to one and only one value\n    /// @param _primary Primary maps string keys to zero or one value\n    /// @param _active Subprotocols that have a list of a active NFTs\n    /// @param _name Name of the subprotocol, has to be unique\n    /// @param _nftAddress Address of the subprotocol NFT. Has to adhere to the CidSubprotocolNFT interface\n    /// @param _fee Fee (in $NOTE) for minting a new token of the subprotocol. Set to 0 if there is no fee. 10% is subtracted from this fee as a CID fee\n    function register(\n        bool _ordered,\n        bool _primary,\n        bool _active,\n        address _nftAddress,\n        string calldata _name,\n        uint96 _fee\n    ) external {\n        SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, REGISTER_FEE);\n        if (!(_ordered || _primary || _active)) revert NoTypeSpecified(_name);\n        SubprotocolData memory subprotocolData = subprotocols[_name];\n        if (subprotocolData.owner != address(0)) revert SubprotocolAlreadyExists(_name, subprotocolData.owner);\n        subprotocolData.owner = msg.sender;\n        subprotocolData.fee = _fee;\n        if (!ERC721(_nftAddress).supportsInterface(type(CidSubprotocolNFT).interfaceId))\n            revert NotASubprotocolNFT(_nftAddress);\n        subprotocolData.nftAddress = _nftAddress;\n        subprotocolData.ordered = _ordered;\n        subprotocolData.primary = _primary;\n        subprotocolData.active = _active;\n        subprotocols[_name] = subprotocolData;\n        emit SubprotocolRegistered(msg.sender, _name, _nftAddress, _ordered, _primary, _active, _fee);\n    }\n\n    /// @notice Getter function to retrieve subprotocol data\n    /// @param _name Name of the subprotocol to query\n    /// @return subprotocolData stored under _name. owner will be set to address(0) if subprotocol does not exist\n    function getSubprotocol(string calldata _name) external view returns (SubprotocolData memory) {\n        return subprotocols[_name];\n    }\n}"
    },
    {
      "filename": "src/SubprotocolRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./CidSubprotocolNFT.sol\";\n\n/// @title Subprotocol Registry\n/// @notice Enables registration of new subprotocols\ncontract SubprotocolRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee for registering a new subprotocol (100 $NOTE)\n    uint256 public constant REGISTER_FEE = 100 * 10**18;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Wallet that receives fees paid when registering\n    address public immutable cidFeeWallet;\n\n    /// @notice Data that is associated with a subprotocol.\n    /// @dev Data types are chosen such that all data fits in one slot\n    struct SubprotocolData {\n        /// @notice Owner (registrant) of the subprotocol\n        address owner;\n        /// @notice Optional cost in NOTE to add an NFT\n        /// @dev Maximum value is (2^96 - 1) / 10^18 =~ 80 billion. Zero for no fee\n        uint96 fee;\n        address nftAddress;\n        bool ordered;\n        bool primary;\n        bool active;\n    }\n\n    /// @notice Mapping (name => data) that contains all registered subprotocols\n    mapping(string => SubprotocolData) private subprotocols;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event SubprotocolRegistered(\n        address indexed registrar,\n        string indexed name,\n        address indexed nftAddress,\n        bool ordered,\n        bool primary,\n        bool active,\n        uint96 fee\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error SubprotocolAlreadyExists(string name, address owner);\n    error NoTypeSpecified(string name);\n    error NotASubprotocolNFT(address nftAddress);\n\n    /// @notice Sets the reference to the $NOTE contract\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    constructor(address _noteContract, address _cidFeeWallet) {\n        note = ERC20(_noteContract);\n        cidFeeWallet = _cidFeeWallet;\n    }\n\n    /// @notice Register a new subprotocol. There is a 100 $NOTE fee when registering\n    /// @dev The options ordered, primary, active are not mutually exclusive. In practice, only one will be set for most subprotocols,\n    /// but if a subprotocol for instance supports int keys (mapped to one value) and a list of active NFTs, ordered and active is true.\n    /// @param _ordered Ordering allows integers to be used as map keys, to one and only one value\n    /// @param _primary Primary maps string keys to zero or one value\n    /// @param _active Subprotocols that have a list of a active NFTs\n    /// @param _name Name of the subprotocol, has to be unique\n    /// @param _nftAddress Address of the subprotocol NFT. Has to adhere to the CidSubprotocolNFT interface\n    /// @param _fee Fee (in $NOTE) for minting a new token of the subprotocol. Set to 0 if there is no fee. 10% is subtracted from this fee as a CID fee\n    function register(\n        bool _ordered,\n        bool _primary,\n        bool _active,\n        address _nftAddress,\n        string calldata _name,\n        uint96 _fee\n    ) external {\n        SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, REGISTER_FEE);\n        if (!(_ordered || _primary || _active)) revert NoTypeSpecified(_name);\n        SubprotocolData memory subprotocolData = subprotocols[_name];\n        if (subprotocolData.owner != address(0)) revert SubprotocolAlreadyExists(_name, subprotocolData.owner);\n        subprotocolData.owner = msg.sender;\n        subprotocolData.fee = _fee;\n        if (!ERC721(_nftAddress).supportsInterface(type(CidSubprotocolNFT).interfaceId))\n            revert NotASubprotocolNFT(_nftAddress);\n        subprotocolData.nftAddress = _nftAddress;\n        subprotocolData.ordered = _ordered;\n        subprotocolData.primary = _primary;\n        subprotocolData.active = _active;\n        subprotocols[_name] = subprotocolData;\n        emit SubprotocolRegistered(msg.sender, _name, _nftAddress, _ordered, _primary, _active, _fee);\n    }\n\n    /// @notice Getter function to retrieve subprotocol data\n    /// @param _name Name of the subprotocol to query\n    /// @return subprotocolData stored under _name. owner will be set to address(0) if subprotocol does not exist\n    function getSubprotocol(string calldata _name) external view returns (SubprotocolData memory) {\n        return subprotocols[_name];\n    }\n}"
    }
  ]
}