{
  "Title": "[L-08] Only 255 action modules can ever be whitelisted",
  "Content": "\nWhen an action module is whitelisted, `incrementMaxActionModuleIdUsed()` is called, which increments `_maxActionModuleIdUsed` and checks that it does not exceed `MAX_ACTION_MODULE_ID_SUPPORTED`:\n\n[StorageLib.sol#L165-L175](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/StorageLib.sol#L165-L175)\n\n```solidity\n    function incrementMaxActionModuleIdUsed() internal returns (uint256) {\n        uint256 incrementedId;\n        assembly {\n            incrementedId := add(sload(MAX_ACTION_MODULE_ID_USED_SLOT), 1)\n            sstore(MAX_ACTION_MODULE_ID_USED_SLOT, incrementedId)\n        }\n        if (incrementedId > MAX_ACTION_MODULE_ID_SUPPORTED) {\n            revert Errors.MaxActionModuleIdReached();\n        }\n        return incrementedId;\n    }\n```\n\n`MAX_ACTION_MODULE_ID_SUPPORTED` is currently declared as `255`:\n\n[StorageLib.sol#L47](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/StorageLib.sol#L47)\n\n```solidity\nuint256 constant MAX_ACTION_MODULE_ID_SUPPORTED = 255;\n```\n\nThis becomes an issue as `_maxActionModuleIdUsed` does not changed when action modules are un-whitelisted, which means that action module IDs cannot be reused:\n\n[GovernanceLib.sol#L105-L107](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/GovernanceLib.sol#L105-L107)\n\n```solidity\n            // The action module with the given address was already whitelisted before, it has an ID already assigned.\n            StorageLib.actionModuleWhitelistData()[actionModule].isWhitelisted = whitelist;\n            id = actionModuleWhitelistData.id;\n```\n\nThis means that only 255 action modules can ever be whitelisted, and governance will not be able to whitelist action modules forever after this limit is exceeded.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/libraries/StorageLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\n\nlibrary StorageLib {\n    // uint256 constant NAME_SLOT = 0;\n    // uint256 constant SYMBOL_SLOT = 1;\n    uint256 constant TOKEN_DATA_MAPPING_SLOT = 2;\n    // uint256 constant BALANCES_SLOT = 3;\n    // uint256 constant TOKEN_APPROVAL_MAPPING_SLOT = 4;\n    // uint256 constant OPERATOR_APPROVAL_MAPPING_SLOT = 5;\n    // Slot 6 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `ownedTokens`.\n    // Slot 7 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `ownedTokensIndex`.\n    // uint256 constant TOTAL_SUPPLY_SLOT = 8;\n    // Slot 9 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `allTokensIndex`.\n    uint256 constant SIG_NONCES_MAPPING_SLOT = 10;\n    uint256 constant LAST_INITIALIZED_REVISION_SLOT = 11; // VersionedInitializable's `lastInitializedRevision` field.\n    uint256 constant PROTOCOL_STATE_SLOT = 12;\n    uint256 constant PROFILE_CREATOR_WHITELIST_MAPPING_SLOT = 13;\n    uint256 constant FOLLOW_MODULE_WHITELIST_MAPPING_SLOT = 14;\n    uint256 constant ACTION_MODULE_WHITELIST_DATA_MAPPING_SLOT = 15;\n    uint256 constant REFERENCE_MODULE_WHITELIST_MAPPING_SLOT = 16;\n    // Slot 17 is deprecated in Lens V2. In V1 it was used for the dispatcher address by profile ID.\n    uint256 constant PROFILE_ID_BY_HANDLE_HASH_MAPPING_SLOT = 18; // Deprecated slot, but still needed for V2 migration.\n    uint256 constant PROFILES_MAPPING_SLOT = 19;\n    uint256 constant PUBLICATIONS_MAPPING_SLOT = 20;\n    // Slot 21 is deprecated in Lens V2. In V1 it was used for the default profile ID by address.\n    uint256 constant PROFILE_COUNTER_SLOT = 22;\n    uint256 constant GOVERNANCE_SLOT = 23;\n    uint256 constant EMERGENCY_ADMIN_SLOT = 24;\n    //////////////////////////////////\n    ///  Introduced in Lens V1.3:  ///\n    //////////////////////////////////\n    uint256 constant TOKEN_GUARDIAN_DISABLING_TIMESTAMP_MAPPING_SLOT = 25;\n    //////////////////////////////////\n    ///   Introduced in Lens V2:   ///\n    //////////////////////////////////\n    uint256 constant DELEGATED_EXECUTOR_CONFIG_MAPPING_SLOT = 26;\n    uint256 constant BLOCKED_STATUS_MAPPING_SLOT = 27;\n    uint256 constant ACTION_MODULES_SLOT = 28;\n    uint256 constant MAX_ACTION_MODULE_ID_USED_SLOT = 29;\n    uint256 constant PROFILE_ROYALTIES_BPS_SLOT = 30;\n\n    uint256 constant MAX_ACTION_MODULE_ID_SUPPORTED = 255;\n\n    function getPublication(uint256 profileId, uint256 pubId)\n        internal\n        pure\n        returns (Types.Publication storage _publication)\n    {\n        assembly {\n            mstore(0, profileId)\n            mstore(32, PUBLICATIONS_MAPPING_SLOT)\n            mstore(32, keccak256(0, 64))\n            mstore(0, pubId)\n            _publication.slot := keccak256(0, 64)\n        }\n    }\n\n    function getProfile(uint256 profileId) internal pure returns (Types.Profile storage _profiles) {\n        assembly {\n            mstore(0, profileId)\n            mstore(32, PROFILES_MAPPING_SLOT)\n            _profiles.slot := keccak256(0, 64)\n        }\n    }\n\n    function getDelegatedExecutorsConfig(uint256 delegatorProfileId)\n        internal\n        pure\n        returns (Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig)\n    {\n        assembly {\n            mstore(0, delegatorProfileId)\n            mstore(32, DELEGATED_EXECUTOR_CONFIG_MAPPING_SLOT)\n            _delegatedExecutorsConfig.slot := keccak256(0, 64)\n        }\n    }\n\n    function tokenGuardianDisablingTimestamp()\n        internal\n        pure\n        returns (mapping(address => uint256) storage _tokenGuardianDisablingTimestamp)\n    {\n        assembly {\n            _tokenGuardianDisablingTimestamp.slot := TOKEN_GUARDIAN_DISABLING_TIMESTAMP_MAPPING_SLOT\n        }\n    }\n\n    function getTokenData(uint256 tokenId) internal pure returns (Types.TokenData storage _tokenData) {\n        assembly {\n            mstore(0, tokenId)\n            mstore(32, TOKEN_DATA_MAPPING_SLOT)\n            _tokenData.slot := keccak256(0, 64)\n        }\n    }\n\n    function blockedStatus(uint256 blockerProfileId)\n        internal\n        pure\n        returns (mapping(uint256 => bool) storage _blockedStatus)\n    {\n        assembly {\n            mstore(0, blockerProfileId)\n            mstore(32, BLOCKED_STATUS_MAPPING_SLOT)\n            _blockedStatus.slot := keccak256(0, 64)\n        }\n    }\n\n    function nonces() internal pure returns (mapping(address => uint256) storage _nonces) {\n        assembly {\n            _nonces.slot := SIG_NONCES_MAPPING_SLOT\n        }\n    }\n\n    function profileIdByHandleHash()\n        internal\n        pure\n        returns (mapping(bytes32 => uint256) storage _profileIdByHandleHash)\n    {\n        assembly {\n            _profileIdByHandleHash.slot := PROFILE_ID_BY_HANDLE_HASH_MAPPING_SLOT\n        }\n    }\n\n    function profileCreatorWhitelisted()\n        internal\n        pure\n        returns (mapping(address => bool) storage _profileCreatorWhitelisted)\n    {\n        assembly {\n            _profileCreatorWhitelisted.slot := PROFILE_CREATOR_WHITELIST_MAPPING_SLOT\n        }\n    }\n\n    function followModuleWhitelisted()\n        internal\n        pure\n        returns (mapping(address => bool) storage _followModuleWhitelisted)\n    {\n        assembly {\n            _followModuleWhitelisted.slot := FOLLOW_MODULE_WHITELIST_MAPPING_SLOT\n        }\n    }\n\n    function actionModuleWhitelistData()\n        internal\n        pure\n        returns (mapping(address => Types.ActionModuleWhitelistData) storage _actionModuleWhitelistData)\n    {\n        assembly {\n            _actionModuleWhitelistData.slot := ACTION_MODULE_WHITELIST_DATA_MAPPING_SLOT\n        }\n    }\n\n    function actionModuleById() internal pure returns (mapping(uint256 => address) storage _actionModules) {\n        assembly {\n            _actionModules.slot := ACTION_MODULES_SLOT\n        }\n    }\n\n    function incrementMaxActionModuleIdUsed() internal returns (uint256) {\n        uint256 incrementedId;\n        assembly {\n            incrementedId := add(sload(MAX_ACTION_MODULE_ID_USED_SLOT), 1)\n            sstore(MAX_ACTION_MODULE_ID_USED_SLOT, incrementedId)\n        }\n        if (incrementedId > MAX_ACTION_MODULE_ID_SUPPORTED) {\n            revert Errors.MaxActionModuleIdReached();\n        }\n        return incrementedId;\n    }\n\n    function referenceModuleWhitelisted()\n        internal\n        pure\n        returns (mapping(address => bool) storage _referenceModuleWhitelisted)\n    {\n        assembly {\n            _referenceModuleWhitelisted.slot := REFERENCE_MODULE_WHITELIST_MAPPING_SLOT\n        }\n    }\n\n    function getGovernance() internal view returns (address _governance) {\n        assembly {\n            _governance := sload(GOVERNANCE_SLOT)\n        }\n    }\n\n    function setGovernance(address newGovernance) internal {\n        assembly {\n            sstore(GOVERNANCE_SLOT, newGovernance)\n        }\n    }\n\n    function getEmergencyAdmin() internal view returns (address _emergencyAdmin) {\n        assembly {\n            _emergencyAdmin := sload(EMERGENCY_ADMIN_SLOT)\n        }\n    }\n\n    function setEmergencyAdmin(address newEmergencyAdmin) internal {\n        assembly {\n            sstore(EMERGENCY_ADMIN_SLOT, newEmergencyAdmin)\n        }\n    }\n\n    function getState() internal view returns (Types.ProtocolState _state) {\n        assembly {\n            _state := sload(PROTOCOL_STATE_SLOT)\n        }\n    }\n\n    function setState(Types.ProtocolState newState) internal {\n        assembly {\n            sstore(PROTOCOL_STATE_SLOT, newState)\n        }\n    }\n\n    function getLastInitializedRevision() internal view returns (uint256 _lastInitializedRevision) {\n        assembly {\n            _lastInitializedRevision := sload(LAST_INITIALIZED_REVISION_SLOT)\n        }\n    }\n\n    function setLastInitializedRevision(uint256 newLastInitializedRevision) internal {\n        assembly {\n            sstore(LAST_INITIALIZED_REVISION_SLOT, newLastInitializedRevision)\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/StorageLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\n\nlibrary StorageLib {\n    // uint256 constant NAME_SLOT = 0;\n    // uint256 constant SYMBOL_SLOT = 1;\n    uint256 constant TOKEN_DATA_MAPPING_SLOT = 2;\n    // uint256 constant BALANCES_SLOT = 3;\n    // uint256 constant TOKEN_APPROVAL_MAPPING_SLOT = 4;\n    // uint256 constant OPERATOR_APPROVAL_MAPPING_SLOT = 5;\n    // Slot 6 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `ownedTokens`.\n    // Slot 7 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `ownedTokensIndex`.\n    // uint256 constant TOTAL_SUPPLY_SLOT = 8;\n    // Slot 9 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `allTokensIndex`.\n    uint256 constant SIG_NONCES_MAPPING_SLOT = 10;\n    uint256 constant LAST_INITIALIZED_REVISION_SLOT = 11; // VersionedInitializable's `lastInitializedRevision` field.\n    uint256 constant PROTOCOL_STATE_SLOT = 12;\n    uint256 constant PROFILE_CREATOR_WHITELIST_MAPPING_SLOT = 13;\n    uint256 constant FOLLOW_MODULE_WHITELIST_MAPPING_SLOT = 14;\n    uint256 constant ACTION_MODULE_WHITELIST_DATA_MAPPING_SLOT = 15;\n    uint256 constant REFERENCE_MODULE_WHITELIST_MAPPING_SLOT = 16;\n    // Slot 17 is deprecated in Lens V2. In V1 it was used for the dispatcher address by profile ID.\n    uint256 constant PROFILE_ID_BY_HANDLE_HASH_MAPPING_SLOT = 18; // Deprecated slot, but still needed for V2 migration.\n    uint256 constant PROFILES_MAPPING_SLOT = 19;\n    uint256 constant PUBLICATIONS_MAPPING_SLOT = 20;\n    // Slot 21 is deprecated in Lens V2. In V1 it was used for the default profile ID by address.\n    uint256 constant PROFILE_COUNTER_SLOT = 22;\n    uint256 constant GOVERNANCE_SLOT = 23;\n    uint256 constant EMERGENCY_ADMIN_SLOT = 24;\n    //////////////////////////////////\n    ///  Introduced in Lens V1.3:  ///\n    //////////////////////////////////\n    uint256 constant TOKEN_GUARDIAN_DISABLING_TIMESTAMP_MAPPING_SLOT = 25;\n    //////////////////////////////////\n    ///   Introduced in Lens V2:   ///\n    //////////////////////////////////\n    uint256 constant DELEGATED_EXECUTOR_CONFIG_MAPPING_SLOT = 26;\n    uint256 constant BLOCKED_STATUS_MAPPING_SLOT = 27;\n    uint256 constant ACTION_MODULES_SLOT = 28;\n    uint256 constant MAX_ACTION_MODULE_ID_USED_SLOT = 29;\n    uint256 constant PROFILE_ROYALTIES_BPS_SLOT = 30;\n\n    uint256 constant MAX_ACTION_MODULE_ID_SUPPORTED = 255;\n\n    function getPublication(uint256 profileId, uint256 pubId)\n        internal\n        pure\n        returns (Types.Publication storage _publication)\n    {\n        assembly {\n            mstore(0, profileId)\n            mstore(32, PUBLICATIONS_MAPPING_SLOT)\n            mstore(32, keccak256(0, 64))\n            mstore(0, pubId)\n            _publication.slot := keccak256(0, 64)\n        }\n    }\n\n    function getProfile(uint256 profileId) internal pure returns (Types.Profile storage _profiles) {\n        assembly {\n            mstore(0, profileId)\n            mstore(32, PROFILES_MAPPING_SLOT)\n            _profiles.slot := keccak256(0, 64)\n        }\n    }\n\n    function getDelegatedExecutorsConfig(uint256 delegatorProfileId)\n        internal\n        pure\n        returns (Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig)\n    {\n        assembly {\n            mstore(0, delegatorProfileId)\n            mstore(32, DELEGATED_EXECUTOR_CONFIG_MAPPING_SLOT)\n            _delegatedExecutorsConfig.slot := keccak256(0, 64)\n        }\n    }\n\n    function tokenGuardianDisablingTimestamp()\n        internal\n        pure\n        returns (mapping(address => uint256) storage _tokenGuardianDisablingTimestamp)\n    {\n        assembly {\n            _tokenGuardianDisablingTimestamp.slot := TOKEN_GUARDIAN_DISABLING_TIMESTAMP_MAPPING_SLOT\n        }\n    }\n\n    function getTokenData(uint256 tokenId) internal pure returns (Types.TokenData storage _tokenData) {\n        assembly {\n            mstore(0, tokenId)\n            mstore(32, TOKEN_DATA_MAPPING_SLOT)\n            _tokenData.slot := keccak256(0, 64)\n        }\n    }\n\n    function blockedStatus(uint256 blockerProfileId)\n        internal\n        pure\n        returns (mapping(uint256 => bool) storage _blockedStatus)\n    {\n        assembly {\n            mstore(0, blockerProfileId)\n            mstore(32, BLOCKED_STATUS_MAPPING_SLOT)\n            _blockedStatus.slot := keccak256(0, 64)\n        }\n    }\n\n    function nonces() internal pure returns (mapping(address => uint256) storage _nonces) {\n        assembly {\n            _nonces.slot := SIG_NONCES_MAPPING_SLOT\n        }\n    }\n\n    function profileIdByHandleHash()\n        internal\n        pure\n        returns (mapping(bytes32 => uint256) storage _profileIdByHandleHash)\n    {\n        assembly {\n            _profileIdByHandleHash.slot := PROFILE_ID_BY_HANDLE_HASH_MAPPING_SLOT\n        }\n    }\n\n    function profileCreatorWhitelisted()\n        internal\n        pure\n        returns (mapping(address => bool) storage _profileCreatorWhitelisted)\n    {\n        assembly {\n            _profileCreatorWhitelisted.slot := PROFILE_CREATOR_WHITELIST_MAPPING_SLOT\n        }\n    }\n\n    function followModuleWhitelisted()\n        internal\n        pure\n        returns (mapping(address => bool) storage _followModuleWhitelisted)\n    {\n        assembly {\n            _followModuleWhitelisted.slot := FOLLOW_MODULE_WHITELIST_MAPPING_SLOT\n        }\n    }\n\n    function actionModuleWhitelistData()\n        internal\n        pure\n        returns (mapping(address => Types.ActionModuleWhitelistData) storage _actionModuleWhitelistData)\n    {\n        assembly {\n            _actionModuleWhitelistData.slot := ACTION_MODULE_WHITELIST_DATA_MAPPING_SLOT\n        }\n    }\n\n    function actionModuleById() internal pure returns (mapping(uint256 => address) storage _actionModules) {\n        assembly {\n            _actionModules.slot := ACTION_MODULES_SLOT\n        }\n    }\n\n    function incrementMaxActionModuleIdUsed() internal returns (uint256) {\n        uint256 incrementedId;\n        assembly {\n            incrementedId := add(sload(MAX_ACTION_MODULE_ID_USED_SLOT), 1)\n            sstore(MAX_ACTION_MODULE_ID_USED_SLOT, incrementedId)\n        }\n        if (incrementedId > MAX_ACTION_MODULE_ID_SUPPORTED) {\n            revert Errors.MaxActionModuleIdReached();\n        }\n        return incrementedId;\n    }\n\n    function referenceModuleWhitelisted()\n        internal\n        pure\n        returns (mapping(address => bool) storage _referenceModuleWhitelisted)\n    {\n        assembly {\n            _referenceModuleWhitelisted.slot := REFERENCE_MODULE_WHITELIST_MAPPING_SLOT\n        }\n    }\n\n    function getGovernance() internal view returns (address _governance) {\n        assembly {\n            _governance := sload(GOVERNANCE_SLOT)\n        }\n    }\n\n    function setGovernance(address newGovernance) internal {\n        assembly {\n            sstore(GOVERNANCE_SLOT, newGovernance)\n        }\n    }\n\n    function getEmergencyAdmin() internal view returns (address _emergencyAdmin) {\n        assembly {\n            _emergencyAdmin := sload(EMERGENCY_ADMIN_SLOT)\n        }\n    }\n\n    function setEmergencyAdmin(address newEmergencyAdmin) internal {\n        assembly {\n            sstore(EMERGENCY_ADMIN_SLOT, newEmergencyAdmin)\n        }\n    }\n\n    function getState() internal view returns (Types.ProtocolState _state) {\n        assembly {\n            _state := sload(PROTOCOL_STATE_SLOT)\n        }\n    }\n\n    function setState(Types.ProtocolState newState) internal {\n        assembly {\n            sstore(PROTOCOL_STATE_SLOT, newState)\n        }\n    }\n\n    function getLastInitializedRevision() internal view returns (uint256 _lastInitializedRevision) {\n        assembly {\n            _lastInitializedRevision := sload(LAST_INITIALIZED_REVISION_SLOT)\n        }\n    }\n\n    function setLastInitializedRevision(uint256 newLastInitializedRevision) internal {\n        assembly {\n            sstore(LAST_INITIALIZED_REVISION_SLOT, newLastInitializedRevision)\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/GovernanceLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\n\nlibrary GovernanceLib {\n    /**\n     * @notice Sets the governance address.\n     *\n     * @param newGovernance The new governance address to set.\n     */\n    function setGovernance(address newGovernance) external {\n        address prevGovernance = StorageLib.getGovernance();\n        StorageLib.setGovernance(newGovernance);\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the emergency admin address.\n     *\n     * @param newEmergencyAdmin The new governance address to set.\n     */\n    function setEmergencyAdmin(address newEmergencyAdmin) external {\n        address prevEmergencyAdmin = StorageLib.getEmergencyAdmin();\n        StorageLib.setEmergencyAdmin(newEmergencyAdmin);\n        emit Events.EmergencyAdminSet(msg.sender, prevEmergencyAdmin, newEmergencyAdmin, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the protocol state, only meant to be called at initialization since\n     * this does not validate the caller.\n     *\n     * @param newState The new protocol state to set.\n     */\n    function initState(Types.ProtocolState newState) external {\n        _setState(newState);\n    }\n\n    /**\n     * @notice Sets the protocol state and validates the caller. The emergency admin can only\n     * pause further (Unpaused => PublishingPaused => Paused). Whereas governance can set any\n     * state.\n     *\n     * @param newState The new protocol state to set.\n     */\n    function setState(Types.ProtocolState newState) external {\n        // NOTE: This does not follow the CEI-pattern, but there is no interaction and this allows to abstract `_setState` logic.\n        Types.ProtocolState prevState = _setState(newState);\n        // If the sender is the emergency admin, prevent them from reducing restrictions.\n        if (msg.sender == StorageLib.getEmergencyAdmin()) {\n            if (newState <= prevState) {\n                revert Errors.EmergencyAdminCanOnlyPauseFurther();\n            }\n        } else if (msg.sender != StorageLib.getGovernance()) {\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        }\n        emit Events.StateSet(msg.sender, prevState, newState, block.timestamp);\n    }\n\n    function _setState(Types.ProtocolState newState) private returns (Types.ProtocolState) {\n        Types.ProtocolState prevState = StorageLib.getState();\n        StorageLib.setState(newState);\n        emit Events.StateSet(msg.sender, prevState, newState, block.timestamp);\n        return prevState;\n    }\n\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external {\n        StorageLib.profileCreatorWhitelisted()[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    function whitelistFollowModule(address followModule, bool whitelist) external {\n        StorageLib.followModuleWhitelisted()[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    function whitelistReferenceModule(address referenceModule, bool whitelist) external {\n        StorageLib.referenceModuleWhitelisted()[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    function whitelistActionModule(address actionModule, bool whitelist) external {\n        Types.ActionModuleWhitelistData memory actionModuleWhitelistData = StorageLib.actionModuleWhitelistData()[\n            actionModule\n        ];\n\n        uint256 id;\n        if (actionModuleWhitelistData.id == 0) {\n            // The action module with the given address wasn't whitelisted before, a new ID is assigned to it.\n            if (!whitelist) {\n                revert Errors.NotWhitelisted();\n            }\n            id = StorageLib.incrementMaxActionModuleIdUsed();\n\n            StorageLib.actionModuleWhitelistData()[actionModule] = Types.ActionModuleWhitelistData(\n                uint248(id),\n                whitelist\n            );\n            StorageLib.actionModuleById()[id] = actionModule;\n        } else {\n            // The action module with the given address was already whitelisted before, it has an ID already assigned.\n            StorageLib.actionModuleWhitelistData()[actionModule].isWhitelisted = whitelist;\n            id = actionModuleWhitelistData.id;\n        }\n        emit Events.ActionModuleWhitelisted(actionModule, id, whitelist, block.timestamp);\n    }\n}"
    }
  ]
}