{
  "Title": "[G-04] With assembly, .call (bool success) transfer can be done gas-optimized",
  "Content": "\nReturn data (bool success,) has to be stored due to EVM architecture, but in a usage like below, ‘out’ and ‘outsize’ values are given (0,0), this storage disappears and gas optimization is provided.\n   (bool success,) = dest.call{value:amount}(\"\");\n bool success; \n assembly {  \n            success := call(gas(), dest, amount, 0, 0)\n     }  \n\n```solidity\nFile: /src/Aquifer.sol\n55   (bool success, bytes memory returnData) = well.call(initFunctionCall);\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Aquifer.sol#L55\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/Aquifer.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {ReentrancyGuard} from \"oz/security/ReentrancyGuard.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\nimport {IWellFunction} from \"src/interfaces/IWellFunction.sol\";\nimport {IAquifer} from \"src/interfaces/IAquifer.sol\";\nimport {Well, IWell, Call, IERC20} from \"src/Well.sol\";\nimport {LibClone} from \"src/libraries/LibClone.sol\";\n\n/**\n * @title Aquifer\n * @author Publius, Silo Chad, Brean\n * @notice Aquifer is a permissionless Well registry and factory.\n * @dev Aquifer deploys Wells by cloning a pre-deployed Well implementation.\n */\ncontract Aquifer is IAquifer, ReentrancyGuard {\n    using SafeCast for uint256;\n    using LibClone for address;\n\n    // A mapping of Well address to the Well implementation addresses\n    // Mapping gets set on Well deployment\n    mapping(address => address) wellImplementations;\n\n    constructor() ReentrancyGuard() {}\n\n    /**\n     * @dev\n     * Use `salt == 0` to deploy a new Well with `create`\n     * Use `salt > 0` to deploy a new Well with `create2`\n     */\n    function boreWell(\n        address implementation,\n        bytes calldata immutableData,\n        bytes calldata initFunctionCall,\n        bytes32 salt\n    ) external nonReentrant returns (address well) {\n        if (immutableData.length > 0) {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(immutableData, salt);\n            } else {\n                well = implementation.clone(immutableData);\n            }\n        } else {\n            if (salt != bytes32(0)) {\n                well = implementation.cloneDeterministic(salt);\n            } else {\n                well = implementation.clone();\n            }\n        }\n\n        if (initFunctionCall.length > 0) {\n            (bool success, bytes memory returnData) = well.call(initFunctionCall);\n            if (!success) {\n                // Next 5 lines are based on https://ethereum.stackexchange.com/a/83577\n                if (returnData.length < 68) revert InitFailed(\"\");\n                assembly {\n                    returnData := add(returnData, 0x04)\n                }\n                revert InitFailed(abi.decode(returnData, (string)));\n            }\n        }\n\n        // The Aquifer address MUST be set, either (a) via immutable data during cloning,\n        // or (b) as a storage variable during an init function call. In either case,\n        // the address MUST match the address of the Aquifer that performed deployment.\n        if (IWell(well).aquifer() != address(this)) {\n            revert InvalidConfig();\n        }\n\n        // Save implementation\n        wellImplementations[well] = implementation;\n\n        emit BoreWell(\n            well,\n            implementation,\n            IWell(well).tokens(),\n            IWell(well).wellFunction(),\n            IWell(well).pumps(),\n            IWell(well).wellData()\n        );\n    }\n\n    function wellImplementation(address well) external view returns (address implementation) {\n        return wellImplementations[well];\n    }\n}"
    }
  ]
}