{
  "Title": "[N-09] srcToken and srcChainId is not updated on old token after migration through changeBridgedToken()",
  "Content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L73)\n\nWhen a token is migrated to another token, the old token still points towards the same srcToken and srcChainId as the new token since they are not updated through changeBridgedToken(). \n\nDue to this external dapps integrating and using these values as reference could run into potential issues. Consider clearing them or changing them to some placeholder data representing the src token and chainId but with a prefix. \n```solidity\nFile: BridgedERC20.sol\n123:     function canonical() public view returns (address, uint256) {\n124:         return (srcToken, srcChainId);\n125:     }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/tokenvault/BridgedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"./LibBridgedToken.sol\";\nimport \"./BridgedERC20Base.sol\";\n\n/// @title BridgedERC20\n/// @notice An upgradeable ERC20 contract that represents tokens bridged from\n/// another chain.\n/// @custom:security-contact security@taiko.xyz\ncontract BridgedERC20 is\n    BridgedERC20Base,\n    IERC20MetadataUpgradeable,\n    ERC20SnapshotUpgradeable,\n    ERC20VotesUpgradeable\n{\n    /// @dev Slot 1.\n    address public srcToken;\n\n    uint8 private __srcDecimals;\n\n    /// @dev Slot 2.\n    uint256 public srcChainId;\n\n    /// @dev Slot 3.\n    address public snapshooter;\n\n    uint256[47] private __gap;\n\n    error BTOKEN_CANNOT_RECEIVE();\n    error BTOKEN_UNAUTHORIZED();\n\n    modifier onlyOwnerOrSnapshooter() {\n        if (msg.sender != owner() && msg.sender != snapshooter) {\n            revert BTOKEN_UNAUTHORIZED();\n        }\n        _;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    /// @param _srcToken The source token address.\n    /// @param _srcChainId The source chain ID.\n    /// @param _decimals The number of decimal places of the source token.\n    /// @param _symbol The symbol of the token.\n    /// @param _name The name of the token.\n    function init(\n        address _owner,\n        address _addressManager,\n        address _srcToken,\n        uint256 _srcChainId,\n        uint8 _decimals,\n        string memory _symbol,\n        string memory _name\n    )\n        external\n        initializer\n    {\n        // Check if provided parameters are valid\n        LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);\n        __Essential_init(_owner, _addressManager);\n        __ERC20_init(_name, _symbol);\n        __ERC20Snapshot_init();\n        __ERC20Votes_init();\n        __ERC20Permit_init(_name);\n\n        // Set contract properties\n        srcToken = _srcToken;\n        srcChainId = _srcChainId;\n        __srcDecimals = _decimals;\n    }\n\n    /// @notice Set the snapshoter address.\n    /// @param _snapshooter snapshooter address.\n    function setSnapshoter(address _snapshooter) external onlyOwner {\n        snapshooter = _snapshooter;\n    }\n\n    /// @notice Creates a new token snapshot.\n    function snapshot() external onlyOwnerOrSnapshooter {\n        _snapshot();\n    }\n\n    /// @notice Gets the name of the token.\n    /// @return The name.\n    function name()\n        public\n        view\n        override(ERC20Upgradeable, IERC20MetadataUpgradeable)\n        returns (string memory)\n    {\n        return LibBridgedToken.buildName(super.name(), srcChainId);\n    }\n\n    /// @notice Gets the symbol of the bridged token.\n    /// @return The symbol.\n    function symbol()\n        public\n        view\n        override(ERC20Upgradeable, IERC20MetadataUpgradeable)\n        returns (string memory)\n    {\n        return LibBridgedToken.buildSymbol(super.symbol());\n    }\n\n    /// @notice Gets the number of decimal places of the token.\n    /// @return The number of decimal places of the token.\n    function decimals()\n        public\n        view\n        override(ERC20Upgradeable, IERC20MetadataUpgradeable)\n        returns (uint8)\n    {\n        return __srcDecimals;\n    }\n\n    /// @notice Gets the canonical token's address and chain ID.\n    /// @return The canonical token's address.\n    /// @return The canonical token's chain ID.\n    function canonical() public view returns (address, uint256) {\n        return (srcToken, srcChainId);\n    }\n\n    function _mintToken(address _account, uint256 _amount) internal override {\n        _mint(_account, _amount);\n    }\n\n    function _burnToken(address _from, uint256 _amount) internal override {\n        _burn(_from, _amount);\n    }\n\n    /// @dev For ERC20SnapshotUpgradeable and ERC20VotesUpgradeable, need to implement the following\n    /// functions\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)\n    {\n        if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();\n        if (paused()) revert INVALID_PAUSE_STATUS();\n        super._beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._afterTokenTransfer(_from, _to, _amount);\n    }\n\n    function _mint(\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._mint(_to, _amount);\n    }\n\n    function _burn(\n        address _from,\n        uint256 _amount\n    )\n        internal\n        override(ERC20Upgradeable, ERC20VotesUpgradeable)\n    {\n        super._burn(_from, _amount);\n    }\n}"
    }
  ]
}