{
  "Title": "M-2: Selling partial base tokens are more profitable then selling in one go",
  "Content": "# Issue M-2: Selling partial base tokens are more profitable then selling in one go \n\nSource: https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/20 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nBandit, mstpr-brainbot\n## Summary\nSelling base tokens partially instead of one go is always more profitable \n## Vulnerability Detail\nFirst, let's write down our formulas of sellBase tokens for quoteTokens:\ng: gamma\ns: spread\nc: coefficient\np: price\nnp: new price (price after selling base tokens) \n\n**g = deltaBase * p * c**\n**deltaQuote = deltaBase * p * (1 - (g + s))**\n**np = p * (1 - g)**\n\nCode snippet for the above formulas:\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/WooPPV2.sol#L591-L619\n\nHere I graphed both `sellQuote` and `sellBase` functions:\nhttps://www.desmos.com/calculator/svmjlxhavw\n\nAs we can observe, if the price is >1 then the selling base tokens (red in the graph) will start decreasing after it reaches the middle value. Same happens vice versa when price is <1 for selling quote tokens (blue in the graph). This heavily incentivise smaller swaps and heavily disincentives bigger swaps. Also, since selling smaller amounts are ALWAYS more profitable, `maxGamma` and `maxNotionalSwap` values can be bypassed without a loss (even for profits) \n\n**Textual PoC:**\nNow, let's do a textual example to see whether selling 20 base tokens is profitable then selling 2 times 10 base tokens\nFor this example, let's assume:\np = 1\nc = 0.01\ns = 0.1 \nand there are no swap fees for simplicity.\n\nFirst, let's sell 20 base tokens:\ng = 20 * 1 * 0.01 = 0.2\ndeltaQuote = 20 * 1 * (1 - (0.1 + 0.1)) = 14\n**quote tokens received will be 14**\n\nNow, let's sell 10 base tokens in 2 times in a single transaction:\ng1 = 10 * 1 * 0.01 = 0.1\ndeltaQuote1 = 10 * 1 * (1- (0.1 + 0.1)) = 8\nnp = 1 * (1 - 0.1) = 0.9\n**received 8 quote tokens in first sell of 10 base tokens**\n\ng2 = 10 * 0.9 * 0.01 = 0.09\ndeltaQuote2 = 10 * 0.9 * (1 - (0.1 + 0.09)) = 7.29\n**received 7.29 quote tokens in second sell of 10 base tokens**\n\n**in total 7.29 + 8 = 15.29 quote tokens received! however, if we were to swap 10 tokens in one go we would end up with 14 quote tokens!** \n\nThis also means that swaps that are not possible because of `maxNotionalSwap` can be divided into partial swaps and the end result would be even higher!\nIf the `maxNotionalSwap` is 100K USDC, someone can swap 2 times 50K USDC to receive even higher amount of quote tokens! Hence, the exploit that happent to WooFi would still be possible and even worse since the partial swaps are better than single go.\n\nHere a test where it compares selling 1000 WETH in one go, 500-500 and 1-1-1-... 1000 times in a single tx:\n```solidity\n// @dev fee is \"100\", coeff = 0.000000001 * 1e18, spread = 0.001 * 1e18 as in the tests\n    // setting fee to a different value is not relevant, attack is still there, just slighly less profitable\n    \n    // @dev sell 1000 in single tx\n    function test_SellBase1Part() public {\n        uint sellWethAmount = 1000 * 1e18;\n        _fundAndApproveAdminAndTapir(1000_0000 * 1e6, sellWethAmount);\n\n        vm.prank(TAPIR);\n        uint receivedUSDC = router.swap(WETH, USDC, sellWethAmount, 0, payable(TAPIR), TAPIR);\n\n        console.log(\"Received USDC\", receivedUSDC);\n        console.log(\"contract usdc balance\", IERC20(USDC).balanceOf(address(pool)));\n    }\n\n    // @dev sell 500-500 in single tx\n    function test_Sell2Parts() public {\n        uint sellWethAmount = 1000 * 1e18;\n        _fundAndApproveAdminAndTapir(1000_0000 * 1e6, sellWethAmount);\n        \n        uint cumulative;\n        for (uint i; i < 2; ++i) {\n            // sell 5 wei dust\n            vm.prank(TAPIR);\n            uint receivedUSDC = router.swap(WETH, USDC, sellWethAmount / 2, 0, payable(TAPIR), TAPIR);\n            (uint128 price, ) = oracle.woPrice(WETH);\n            cumulative += receivedUSDC;\n        }\n\n        console.log(\"Received USDC\", cumulative);\n        console.log(\"contract usdc balance\", IERC20(USDC).balanceOf(address(pool)));\n    }\n\n    // @dev sell 1-1-1-1.... in single tx\n    function test_Sell1000Parts() public {\n        uint sellWethAmount = 1000 * 1e18;\n        _fundAndApproveAdminAndTapir(1000_0000 * 1e6, sellWethAmount);\n        \n        uint cumulative;\n        for (uint i; i < 1000; ++i) {\n            // sell 5 wei dust\n            vm.prank(TAPIR);\n            uint receivedUSDC = router.swap(WETH, USDC, sellWethAmount / 1000, 0, payable(TAPIR), TAPIR);\n            (uint128 price, ) = oracle.woPrice(WETH);\n            cumulative += receivedUSDC;\n        }\n\n        console.log(\"Received USDC\", cumulative);\n        console.log(\"contract usdc balance\", IERC20(USDC).balanceOf(address(pool)));\n    }\n```\n\n**Results:**\nSelling 500-500 instead of 1000 in one go: 3395.800042 USDC more received\nSelling 1-1-1-1-... 1000 times instead 1000 in one go: 6776.505788 USDC more received! \n\n## Impact\nBreaking the `maxNotionalSwap` amount and unfair AMM model\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n\n\n\n\n## Discussion\n\n**fb-alexcq**\n\nThanks for the feedback. This is a known scope when designing our SPMM formula. Again we want to follow up with:\n1. Seems like you're not considering the swap fee\n2. Split into multiple small swaps, only can save users from huge slippage, but it won't cause our protocol lose funds, right?  1000 times for 1 each looks like still not profitable to the attacker, right?\n\n**mstpr**\n\nThe protocol will not lose funds, correct. However, the maxGamma and maxNotionalSwap variables will be rendered useless since partial swaps can be used to bypass these checks, making it even profitable to do so.\n\n\n\n**fb-alexcq**\n\nThis extreme price-deviation case has already been handled by price check (against Chainlink) in our Wooracle's `price` function.\n\n**WangSecurity**\n\nInitially, it was a duplicate of 68, but these are different issues and it presents an unfair formule, therefore, we decided to keep this one as valid.\n\n**WangSecurity**\n\nSponsor said that this AMM model is in fact intended, cause 99% of their swaps are small. But, it wasn't mentioned in the README, therefore, we validate this report as Med due to validation of maxGamma and maxNotionalSwap (core functionality break).\n\n**Banditx0x**\n\n@mstpr I believe the protocol does actually lose funds here:\n\n- The protocol acts as the liquidity provider\n- The net-result for a trader and LP in a trade is zero-sum.\n- If a trader unfairly avoids slippage by gaming the AMM formula, each $ saved by the trader is lost by the LP\n\nLmk your thoughts\n\n**Banditx0x**\n\n@fb-alexcq in response to something you brought up in issue 20 (duplicate):\n\n> Thanks for the feedback.\n> \n> Technically it is okay to avoid huge slippage by splitting into small swaps, right? BTW, is there a way for attacker to get profits (instead of saving the loss) from the split swap? Better to consider there's a 2-5 bps swap fee.\n\nI would like to emphasie that although splitting a very large swap into smaller ones reduces slippage in basically all AMM's, this slippage reduction is due to a trade in between swaps arbitraging the price of the AMM back to the correct price in between your multiple swaps. This is a core invariant of all widely used AMM formulas, and has significant second order consequences as detailed in issue #47 .  Woofi's current formula is different from **any** widely used AMM formula in that it requires no -inbetween price corrections to get this slippage discount.\n\nFor example, in Uniswap v2, Uniswap v3, Curve, Balancer etc it doesn't matter if you swap 100 tokens or 1 token 100 times. As long as _no transactions happen in between_, the tokens returned will be the same.\n\nI'd highly reccomend going back to the old formula which was consistent with this invariant unless it allows another type of vulnerability.\n\n**Banditx0x**\n\nEscalate. \n\nI think it's high severity for above reasons.\n\nPlease consider this issue along with the reasoning provided in #47 . I believe me and @mstpr are providing different perspectives to the issue despite the same root cause. \n\nNote that #47 demonstrates an example with a 2% slippage, and will continue to apply at lower slippage %'s so this actually applies even when 99% of the swaps are small.\n\n> Seems like you're not considering the swap fee\n\nAddressing this: the swap fee is a percentage of the swap size. Therefore splitting a swap into multiple smaller swaps will result in basically the same sum of swap fees.\n\nThe formula allows certain users (one's that optimise and perfectly calculate swap splitting) a lower slippage. Normal users that use the User Interface or don't perfectly calculate their split sizes don't get the same privilege. Giving extremely advanced users lower AMM prices than everybody else is equivalent to loss of funds for the not-so-savvy swappers.\n\n**sherlock-admin2**\n\n> Escalate. \n> \n> I think it's high severity for above reasons.\n> \n> Please consider this issue along with the reasoning provided in #47 . I believe me and @mstpr are providing different perspectives to the issue despite the same root cause. \n> \n> Note that #47 demonstrates an example with a 2% slippage, and will continue to apply at lower slippage %'s so this actually applies even when 99% of the swaps are small.\n> \n> > Seems like you're not considering the swap fee\n> \n> Addressing this: the swap fee is a percentage of the swap size. Therefore splitting a swap into multiple smaller swaps will result in basically the same sum of swap fees.\n> \n> The formula allows certain users (one's that optimise and perfectly calculate swap splitting) a lower slippage. Normal users that use the User Interface or don't perfectly calculate their split sizes don't get the same privilege. Giving extremely advanced users lower AMM prices than everybody else is equivalent to loss of funds for the not-so-savvy swappers.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**mstpr**\n\n@Banditx0x \n\nIf this is design choice, then someone making partial swaps will get more tokens, and yes, this would be loss of funds. Additionally, the maxGamma and maxNotionalSwap can easily be bypassed. \n\nExample:\nIf selling 10 base tokens should receive 5 quote tokens, and if someone selling 2-2-2-2-2 base tokens and receives 7 quote tokens at the end, than the 2 quote tokens would be the loss of protocol since they don't want this to happen in their AMM. Hence, high could be considered. \n\nI think you are right with your comments, if this is design choice, then high would be appropriate. \n\n**WangSecurity**\n\nI believe it should remain medium cause, essentially, it is expected behaviour by the protocol which was confirmed by the sponsor. But, I believe breaking maxGamma and maxNotionalSwap is breaking core functionality, therefore, it's medium and not enough for a high. \n\nI don't say that watsons above are wrong, I see and understand their points and will accept any decision by the head of judging.\n\n**Czar102**\n\nKudos to @Banditx0x @mstpr for the deep understanding of the math.\n\nAs much as I like this finding, I don't think it presents a loss of funds per se, and there are no earnings to the \"exploiters\", the total (and marginal!) slippage still increases as more volume goes in any way. This is a math inconsistency, and I would be considering it as a borderline Low/Medium severity issue.\n\nGiven that an escalation only exists to increase the severity, I'm planning to reject it and leave the issue as is, and I will not consider downgrading this issue.\n\n**fb-alexcq**\n\n@mstpr @Banditx0x   thanks for detailed follow and explanation.\n\nCould you please send me the whole file of your foundry test, so that I can run it here in my environment?  so that to better verify your raised issues.\n\nBTW, could you also try your attach vector on our newly deployed WooPP going live this Monday?  https://arbiscan.io/address/0xed9e3f98bbed560e66b89aac922e29d4596a9642 \nIs that possible to profit or swap for more tokens here in our new version?\n\n\n**mstpr**\n\n@fb-alexcq \nI plugged in the numbers from deployment to my desmos graph. With current values, if someone swaps 14_350 BTC they get \"0\" usdc token in exchange.\n\nAnother example:\nif you sell 1M USDC in one go you get:\n14.41563574 WBTC\n\nif you sell 1M USDC in 1000 iterations (1000, 1000, 1000....) you get:\n14.42278414 WBTC\n\nthe difference is 0.0071484 WBTC, 500$ \n\ntest (directly points the current deployment shared above) \nhttps://gist.github.com/mstpr/0a099688cb48cdc6bec42ceb1c322e8c\n\n**fb-alexcq**\n\nOK. Cool, Thanks.\n\nThis result is with Chainlink Oracle Guardian (+-5%) set up right ?\n\n\n**mstpr**\n\n> Kudos to @Banditx0x @mstpr for the deep understanding of the math.\n> \n> As much as I like this finding, I don't think it presents a loss of funds per se, and there are no earnings to the \"exploiters\", the total (and marginal!) slippage still increases as more volume goes in any way. This is a math inconsistency, and I would be considering it as a borderline Low/Medium severity issue.\n> \n> Given that an escalation only exists to increase the severity, I'm planning to reject it and leave the issue as is, and I will not consider downgrading this issue.\n\nWhat about looking at this angle? \n\nIf this is design choice, then swapping 1M USDC should result at 10 BTC. However, if you swap partially up to 1M USDC then you will end up with say 100 BTC. This 90 BTC difference is basically loss of funds for Woofi considering their design choice, right? \n\n**Czar102**\n\n@mstpr this is not a design choice, this is a math inconsistency, as I noted above.\n\nAs long as \"it's fine\" for the user to get 100 BTC for 1m USDC, then it's not loss of funds, but suboptimal strategy of the 1M USDC <> 10 BTC swapper. But given that the discrepancy in this case is rather minimal (we won't have 90% slippage), I stand by my previous comment.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [banditx0x](https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/20/#issuecomment-2039268858): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/277",
  "Code": [
    {
      "filename": "WooPoolV2/contracts/WooPPV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n/*\n\n░██╗░░░░░░░██╗░█████╗░░█████╗░░░░░░░███████╗██╗\n░██║░░██╗░░██║██╔══██╗██╔══██╗░░░░░░██╔════╝██║\n░╚██╗████╗██╔╝██║░░██║██║░░██║█████╗█████╗░░██║\n░░████╔═████║░██║░░██║██║░░██║╚════╝██╔══╝░░██║\n░░╚██╔╝░╚██╔╝░╚█████╔╝╚█████╔╝░░░░░░██║░░░░░██║\n░░░╚═╝░░░╚═╝░░░╚════╝░░╚════╝░░░░░░░╚═╝░░░░░╚═╝\n\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 WooTrade\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport \"./interfaces/IWooracleV2.sol\";\nimport \"./interfaces/IWooPPV2.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/IWooLendingManager.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n// OpenZeppelin contracts\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// REMOVE IT IN PROD\n// import \"hardhat/console.sol\";\n\n/// @title Woo pool for token swap, version 2.\n/// @notice the implementation class for interface IWooPPV2, mainly for query and swap tokens.\ncontract WooPPV2 is Ownable, ReentrancyGuard, Pausable, IWooPPV2 {\n    /* ----- Type declarations ----- */\n    struct DecimalInfo {\n        uint64 priceDec; // 10**(price_decimal)\n        uint64 quoteDec; // 10**(quote_decimal)\n        uint64 baseDec; // 10**(base_decimal)\n    }\n\n    struct TokenInfo {\n        uint192 reserve; // balance reserve\n        uint16 feeRate; // 1 in 100000; 10 = 1bp = 0.01%; max = 65535\n        uint128 maxGamma; // max range of `balance * k`\n        uint128 maxNotionalSwap; // max volume per swap\n    }\n\n    /* ----- State variables ----- */\n    address constant ETH_PLACEHOLDER_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    uint256 public unclaimedFee; // NOTE: in quote token\n\n    // wallet address --> is admin\n    mapping(address => bool) public isAdmin;\n\n    // wallet address --> is pause role\n    mapping(address => bool) public isPauseRole;\n\n    // token address --> fee rate\n    mapping(address => TokenInfo) public tokenInfos;\n\n    /// @inheritdoc IWooPPV2\n    address public immutable override quoteToken;\n\n    IWooracleV2 public wooracle;\n\n    address public feeAddr;\n\n    mapping(address => IWooLendingManager) public lendManagers;\n\n    /* ----- Modifiers ----- */\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || isAdmin[msg.sender], \"WooPPV2: !admin\");\n        _;\n    }\n\n    modifier onlyAdminOrPauseRole() {\n        require(msg.sender == owner() || isAdmin[msg.sender] || isPauseRole[msg.sender], \"WooPPV2: !isPauseRole\");\n        _;\n    }\n\n    constructor(address _quoteToken) {\n        quoteToken = _quoteToken;\n    }\n\n    function init(address _wooracle, address _feeAddr) external onlyOwner {\n        require(address(wooracle) == address(0), \"WooPPV2: INIT_INVALID\");\n        wooracle = IWooracleV2(_wooracle);\n        feeAddr = _feeAddr;\n    }\n\n    /* ----- External Functions ----- */\n\n    /// @inheritdoc IWooPPV2\n    function tryQuery(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) external view override returns (uint256 toAmount) {\n        if (fromToken == quoteToken) {\n            toAmount = _tryQuerySellQuote(toToken, fromAmount);\n        } else if (toToken == quoteToken) {\n            toAmount = _tryQuerySellBase(fromToken, fromAmount);\n        } else {\n            (toAmount, ) = _tryQueryBaseToBase(fromToken, toToken, fromAmount);\n        }\n    }\n\n    /// @inheritdoc IWooPPV2\n    function query(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) external view override returns (uint256 toAmount) {\n        if (fromToken == quoteToken) {\n            toAmount = _tryQuerySellQuote(toToken, fromAmount);\n        } else if (toToken == quoteToken) {\n            toAmount = _tryQuerySellBase(fromToken, fromAmount);\n        } else {\n            uint256 swapFee;\n            (toAmount, swapFee) = _tryQueryBaseToBase(fromToken, toToken, fromAmount);\n            require(swapFee <= tokenInfos[quoteToken].reserve, \"WooPPV2: INSUFF_QUOTE_FOR_SWAPFEE\");\n        }\n        require(toAmount <= tokenInfos[toToken].reserve, \"WooPPV2: INSUFF_BALANCE\");\n    }\n\n    /// @inheritdoc IWooPPV2\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minToAmount,\n        address to,\n        address rebateTo\n    ) external override returns (uint256 realToAmount) {\n        if (fromToken == quoteToken) {\n            // case 1: quoteToken --> baseToken\n            realToAmount = _sellQuote(toToken, fromAmount, minToAmount, to, rebateTo);\n        } else if (toToken == quoteToken) {\n            // case 2: fromToken --> quoteToken\n            realToAmount = _sellBase(fromToken, fromAmount, minToAmount, to, rebateTo);\n        } else {\n            // case 3: fromToken --> toToken (base to base)\n            realToAmount = _swapBaseToBase(fromToken, toToken, fromAmount, minToAmount, to, rebateTo);\n        }\n    }\n\n    /// @dev OKAY to be public method\n    function claimFee() external nonReentrant {\n        require(feeAddr != address(0), \"WooPPV2: !feeAddr\");\n        uint256 amountToTransfer = unclaimedFee;\n        unclaimedFee = 0;\n        TransferHelper.safeTransfer(quoteToken, feeAddr, amountToTransfer);\n    }\n\n    /// @inheritdoc IWooPPV2\n    /// @dev pool size = tokenInfo.reserve\n    function poolSize(address token) public view override returns (uint256) {\n        return tokenInfos[token].reserve;\n    }\n\n    /// @dev User pool balance (substracted unclaimed fee)\n    function balance(address token) public view returns (uint256) {\n        return token == quoteToken ? _rawBalance(token) - unclaimedFee : _rawBalance(token);\n    }\n\n    function decimalInfo(address baseToken) public view returns (DecimalInfo memory) {\n        return\n            DecimalInfo({\n                priceDec: uint64(10)**(IWooracleV2(wooracle).decimals(baseToken)), // 8\n                quoteDec: uint64(10)**(IERC20Metadata(quoteToken).decimals()), // 18 or 6\n                baseDec: uint64(10)**(IERC20Metadata(baseToken).decimals()) // 18 or 8\n            });\n    }\n\n    /* ----- Admin Functions ----- */\n\n    function setWooracle(address _wooracle) external onlyAdmin {\n        wooracle = IWooracleV2(_wooracle);\n        emit WooracleUpdated(_wooracle);\n    }\n\n    function setFeeAddr(address _feeAddr) external onlyAdmin {\n        feeAddr = _feeAddr;\n        emit FeeAddrUpdated(_feeAddr);\n    }\n\n    function setFeeRate(address token, uint16 rate) external onlyAdmin {\n        require(rate <= 1e5, \"!rate\");\n        tokenInfos[token].feeRate = rate;\n    }\n\n    function setMaxGamma(address token, uint128 maxGamma) external onlyAdmin {\n        tokenInfos[token].maxGamma = maxGamma;\n    }\n\n    function setMaxNotionalSwap(address token, uint128 maxNotionalSwap) external onlyAdmin {\n        tokenInfos[token].maxNotionalSwap = maxNotionalSwap;\n    }\n\n    function setTokenInfo(\n        address token,\n        uint16 _feeRate,\n        uint128 _maxGamma,\n        uint128 _maxNotionalSwap\n    ) external onlyAdmin {\n        tokenInfos[token].feeRate = _feeRate;\n        tokenInfos[token].maxGamma = _maxGamma;\n        tokenInfos[token].maxNotionalSwap = _maxNotionalSwap;\n    }\n\n    function pause() external onlyAdminOrPauseRole {\n        super._pause();\n    }\n\n    function unpause() external onlyAdmin {\n        super._unpause();\n    }\n\n    function setAdmin(address addr, bool flag) external onlyAdmin {\n        require(addr != address(0), \"WooPPV2: !admin\");\n        isAdmin[addr] = flag;\n        emit AdminUpdated(addr, flag);\n    }\n\n    function setPauseRole(address addr, bool flag) external onlyAdmin {\n        isPauseRole[addr] = flag;\n        emit PauseRoleUpdated(addr, flag);\n    }\n\n    function deposit(address token, uint256 amount) public override nonReentrant onlyAdmin {\n        uint256 balanceBefore = balance(token);\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n        uint256 amountReceived = balance(token) - balanceBefore;\n        require(amountReceived >= amount, \"AMOUNT_INSUFF\");\n\n        tokenInfos[token].reserve = uint192(tokenInfos[token].reserve + amount);\n\n        emit Deposit(token, msg.sender, amount);\n    }\n\n    function depositAll(address token) external onlyAdmin {\n        deposit(token, IERC20(token).balanceOf(msg.sender));\n    }\n\n    function repayWeeklyLending(address wantToken) external nonReentrant onlyAdmin returns (uint256 repaidAmount) {\n        IWooLendingManager lendManager = lendManagers[wantToken];\n        lendManager.accureInterest();\n        uint256 amount = lendManager.weeklyRepayment();\n        address repaidToken = lendManager.want();\n        if (amount > 0) {\n            tokenInfos[repaidToken].reserve = uint192(tokenInfos[repaidToken].reserve - amount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), amount);\n            repaidAmount = lendManager.repayWeekly();\n            TransferHelper.safeApprove(repaidToken, address(lendManager), 0);\n        }\n        emit Withdraw(repaidToken, address(lendManager), amount);\n    }\n\n    function repayPrincipal(address wantToken, uint256 principalAmount)\n        external\n        nonReentrant\n        onlyAdmin\n        returns (uint256 repaidAmount)\n    {\n        IWooLendingManager lendManager = lendManagers[wantToken];\n        lendManager.accureInterest();\n\n        uint256 interest = lendManager.borrowedInterest();\n        uint256 perfFee = (lendManager.perfRate() * interest) / 10000;\n\n        uint256 amount = principalAmount + interest + perfFee;\n\n        address repaidToken = lendManager.want();\n        if (amount > 0) {\n            tokenInfos[repaidToken].reserve = uint192(tokenInfos[repaidToken].reserve - amount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), amount);\n            repaidAmount = lendManager.repayPrincipal(principalAmount);\n            TransferHelper.safeApprove(repaidToken, address(lendManager), 0);\n        }\n        emit Withdraw(repaidToken, address(lendManager), amount);\n    }\n\n    function withdraw(address token, uint256 amount) public nonReentrant onlyAdmin {\n        require(tokenInfos[token].reserve >= amount, \"WooPPV2: !amount\");\n        tokenInfos[token].reserve = uint192(tokenInfos[token].reserve - amount);\n        TransferHelper.safeTransfer(token, owner(), amount);\n        emit Withdraw(token, owner(), amount);\n    }\n\n    function withdrawAll(address token) external onlyAdmin {\n        withdraw(token, poolSize(token));\n    }\n\n    function skim(address token) public nonReentrant onlyAdmin {\n        TransferHelper.safeTransfer(token, owner(), balance(token) - tokenInfos[token].reserve);\n    }\n\n    function skimMulTokens(address[] memory tokens) external nonReentrant onlyAdmin {\n        unchecked {\n            uint256 len = tokens.length;\n            for (uint256 i = 0; i < len; i++) {\n                skim(tokens[i]);\n            }\n        }\n    }\n\n    function sync(address token) external nonReentrant onlyAdmin {\n        tokenInfos[token].reserve = uint192(balance(token));\n    }\n\n    /* ----- Owner Functions ----- */\n\n    function setLendManager(IWooLendingManager _lendManager) external onlyOwner {\n        lendManagers[_lendManager.want()] = _lendManager;\n        isAdmin[address(_lendManager)] = true;\n        emit AdminUpdated(address(_lendManager), true);\n    }\n\n    function migrateToNewPool(address token, address newPool) external onlyOwner {\n        require(token != address(0), \"WooPPV2: !token\");\n        require(newPool != address(0), \"WooPPV2: !newPool\");\n\n        tokenInfos[token].reserve = 0;\n\n        uint256 bal = balance(token);\n        TransferHelper.safeApprove(token, newPool, bal);\n        WooPPV2(newPool).depositAll(token);\n\n        emit Migrate(token, newPool, bal);\n    }\n\n    function inCaseTokenGotStuck(address stuckToken) external onlyOwner {\n        if (stuckToken == ETH_PLACEHOLDER_ADDR) {\n            TransferHelper.safeTransferETH(msg.sender, address(this).balance);\n        } else {\n            uint256 amount = IERC20(stuckToken).balanceOf(address(this));\n            TransferHelper.safeTransfer(stuckToken, msg.sender, amount);\n        }\n    }\n\n    /* ----- Private Functions ----- */\n\n    function _tryQuerySellBase(address baseToken, uint256 baseAmount)\n        private\n        view\n        whenNotPaused\n        returns (uint256 quoteAmount)\n    {\n        IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n        (quoteAmount, ) = _calcQuoteAmountSellBase(baseToken, baseAmount, state);\n        uint256 fee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - fee;\n    }\n\n    function _tryQuerySellQuote(address baseToken, uint256 quoteAmount)\n        private\n        view\n        whenNotPaused\n        returns (uint256 baseAmount)\n    {\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n        (baseAmount, ) = _calcBaseAmountSellQuote(baseToken, quoteAmount, state);\n    }\n\n    function _tryQueryBaseToBase(\n        address baseToken1,\n        address baseToken2,\n        uint256 base1Amount\n    ) private view whenNotPaused returns (uint256 base2Amount, uint256 swapFee) {\n        if (\n            baseToken1 == address(0) || baseToken2 == address(0) || baseToken1 == quoteToken || baseToken2 == quoteToken\n        ) {\n            return (0, 0);\n        }\n\n        IWooracleV2.State memory state1 = IWooracleV2(wooracle).state(baseToken1);\n        IWooracleV2.State memory state2 = IWooracleV2(wooracle).state(baseToken2);\n\n        uint64 spread = _maxUInt64(state1.spread, state2.spread) / 2;\n        uint16 feeRate = _maxUInt16(tokenInfos[baseToken1].feeRate, tokenInfos[baseToken2].feeRate);\n\n        state1.spread = spread;\n        state2.spread = spread;\n\n        (uint256 quoteAmount, ) = _calcQuoteAmountSellBase(baseToken1, base1Amount, state1);\n\n        swapFee = (quoteAmount * feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n\n        (base2Amount, ) = _calcBaseAmountSellQuote(baseToken2, quoteAmount, state2);\n    }\n\n    function _sellBase(\n        address baseToken,\n        uint256 baseAmount,\n        uint256 minQuoteAmount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 quoteAmount) {\n        require(baseToken != address(0), \"WooPPV2: !baseToken\");\n        require(to != address(0), \"WooPPV2: !to\");\n        require(baseToken != quoteToken, \"WooPPV2: baseToken==quoteToken\");\n\n        require(balance(baseToken) - tokenInfos[baseToken].reserve >= baseAmount, \"WooPPV2: !BASE\");\n\n        {\n            uint256 newPrice;\n            IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n            (quoteAmount, newPrice) = _calcQuoteAmountSellBase(baseToken, baseAmount, state);\n            IWooracleV2(wooracle).postPrice(baseToken, uint128(newPrice));\n            // console.log('Post new price:', newPrice, newPrice/1e8);\n        }\n\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        require(quoteAmount >= minQuoteAmount, \"WooPPV2: quoteAmount_LT_minQuoteAmount\");\n\n        unclaimedFee = unclaimedFee + swapFee;\n\n        tokenInfos[baseToken].reserve = uint192(tokenInfos[baseToken].reserve + baseAmount);\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve - quoteAmount - swapFee);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(quoteToken, to, quoteAmount);\n        }\n\n        emit WooSwap(\n            baseToken,\n            quoteToken,\n            baseAmount,\n            quoteAmount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    function _sellQuote(\n        address baseToken,\n        uint256 quoteAmount,\n        uint256 minBaseAmount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 baseAmount) {\n        require(baseToken != address(0), \"WooPPV2: !baseToken\");\n        require(to != address(0), \"WooPPV2: !to\");\n        require(baseToken != quoteToken, \"WooPPV2: baseToken==quoteToken\");\n\n        require(balance(quoteToken) - tokenInfos[quoteToken].reserve >= quoteAmount, \"WooPPV2: !QUOTE\");\n\n        uint256 swapFee = (quoteAmount * tokenInfos[baseToken].feeRate) / 1e5;\n        quoteAmount = quoteAmount - swapFee;\n        unclaimedFee = unclaimedFee + swapFee;\n\n        {\n            uint256 newPrice;\n            IWooracleV2.State memory state = IWooracleV2(wooracle).state(baseToken);\n            (baseAmount, newPrice) = _calcBaseAmountSellQuote(baseToken, quoteAmount, state);\n            IWooracleV2(wooracle).postPrice(baseToken, uint128(newPrice));\n            // console.log('Post new price:', newPrice, newPrice/1e8);\n            require(baseAmount >= minBaseAmount, \"WooPPV2: baseAmount_LT_minBaseAmount\");\n        }\n\n        tokenInfos[baseToken].reserve = uint192(tokenInfos[baseToken].reserve - baseAmount);\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve + quoteAmount);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(baseToken, to, baseAmount);\n        }\n\n        emit WooSwap(\n            quoteToken,\n            baseToken,\n            quoteAmount + swapFee,\n            baseAmount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    function _swapBaseToBase(\n        address baseToken1,\n        address baseToken2,\n        uint256 base1Amount,\n        uint256 minBase2Amount,\n        address to,\n        address rebateTo\n    ) private nonReentrant whenNotPaused returns (uint256 base2Amount) {\n        require(baseToken1 != address(0) && baseToken1 != quoteToken, \"WooPPV2: !baseToken1\");\n        require(baseToken2 != address(0) && baseToken2 != quoteToken, \"WooPPV2: !baseToken2\");\n        require(to != address(0), \"WooPPV2: !to\");\n\n        require(balance(baseToken1) - tokenInfos[baseToken1].reserve >= base1Amount, \"WooPPV2: !BASE1_BALANCE\");\n\n        IWooracleV2.State memory state1 = IWooracleV2(wooracle).state(baseToken1);\n        IWooracleV2.State memory state2 = IWooracleV2(wooracle).state(baseToken2);\n\n        uint256 swapFee;\n        uint256 quoteAmount;\n        {\n            uint64 spread = _maxUInt64(state1.spread, state2.spread) / 2;\n            uint16 feeRate = _maxUInt16(tokenInfos[baseToken1].feeRate, tokenInfos[baseToken2].feeRate);\n\n            state1.spread = spread;\n            state2.spread = spread;\n\n            uint256 newBase1Price;\n            (quoteAmount, newBase1Price) = _calcQuoteAmountSellBase(baseToken1, base1Amount, state1);\n            IWooracleV2(wooracle).postPrice(baseToken1, uint128(newBase1Price));\n            // console.log('Post new base1 price:', newBase1Price, newBase1Price/1e8);\n\n            swapFee = (quoteAmount * feeRate) / 1e5;\n        }\n\n        quoteAmount = quoteAmount - swapFee;\n        unclaimedFee = unclaimedFee + swapFee;\n\n        tokenInfos[quoteToken].reserve = uint192(tokenInfos[quoteToken].reserve - swapFee);\n        tokenInfos[baseToken1].reserve = uint192(tokenInfos[baseToken1].reserve + base1Amount);\n\n        {\n            uint256 newBase2Price;\n            (base2Amount, newBase2Price) = _calcBaseAmountSellQuote(baseToken2, quoteAmount, state2);\n            IWooracleV2(wooracle).postPrice(baseToken2, uint128(newBase2Price));\n            // console.log('Post new base2 price:', newBase2Price, newBase2Price/1e8);\n            require(base2Amount >= minBase2Amount, \"WooPPV2: base2Amount_LT_minBase2Amount\");\n        }\n\n        tokenInfos[baseToken2].reserve = uint192(tokenInfos[baseToken2].reserve - base2Amount);\n\n        if (to != address(this)) {\n            TransferHelper.safeTransfer(baseToken2, to, base2Amount);\n        }\n\n        emit WooSwap(\n            baseToken1,\n            baseToken2,\n            base1Amount,\n            base2Amount,\n            msg.sender,\n            to,\n            rebateTo,\n            quoteAmount + swapFee,\n            swapFee\n        );\n    }\n\n    /// @dev Get the pool's balance of the specified token\n    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n    /// @dev forked and curtesy by Uniswap v3 core\n    function _rawBalance(address token) private view returns (uint256) {\n        (bool success, bytes memory data) = token.staticcall(\n            abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\n        );\n        require(success && data.length >= 32, \"WooPPV2: !BALANCE\");\n        return abi.decode(data, (uint256));\n    }\n\n    function _calcQuoteAmountSellBase(\n        address baseToken,\n        uint256 baseAmount,\n        IWooracleV2.State memory state\n    ) private view returns (uint256 quoteAmount, uint256 newPrice) {\n        require(state.woFeasible, \"WooPPV2: !ORACLE_FEASIBLE\");\n\n        DecimalInfo memory decs = decimalInfo(baseToken);\n\n        // gamma = k * price * base_amount; and decimal 18\n        uint256 gamma;\n        {\n            uint256 notionalSwap = (baseAmount * state.price * decs.quoteDec) / decs.baseDec / decs.priceDec;\n            require(notionalSwap <= tokenInfos[baseToken].maxNotionalSwap, \"WooPPV2: !maxNotionalValue\");\n\n            gamma = (baseAmount * state.price * state.coeff) / decs.priceDec / decs.baseDec;\n            require(gamma <= tokenInfos[baseToken].maxGamma, \"WooPPV2: !gamma\");\n\n            // Formula: quoteAmount = baseAmount * oracle.price * (1 - oracle.k * baseAmount * oracle.price - oracle.spread)\n            quoteAmount =\n                (((baseAmount * state.price * decs.quoteDec) / decs.priceDec) *\n                    (uint256(1e18) - gamma - state.spread)) /\n                1e18 /\n                decs.baseDec;\n        }\n\n        // newPrice = oracle.price * (1 - k * oracle.price * baseAmount)\n        newPrice = ((uint256(1e18) - gamma) * state.price) / 1e18;\n    }\n\n    function _calcBaseAmountSellQuote(\n        address baseToken,\n        uint256 quoteAmount,\n        IWooracleV2.State memory state\n    ) private view returns (uint256 baseAmount, uint256 newPrice) {\n        require(state.woFeasible, \"WooPPV2: !ORACLE_FEASIBLE\");\n\n        DecimalInfo memory decs = decimalInfo(baseToken);\n\n        // gamma = k * quote_amount; and decimal 18\n        uint256 gamma;\n        {\n            require(quoteAmount <= tokenInfos[baseToken].maxNotionalSwap, \"WooPPV2: !maxNotionalValue\");\n\n            gamma = (quoteAmount * state.coeff) / decs.quoteDec;\n            require(gamma <= tokenInfos[baseToken].maxGamma, \"WooPPV2: !gamma\");\n\n            // Formula: baseAmount = quoteAmount / oracle.price * (1 - oracle.k * quoteAmount - oracle.spread)\n            baseAmount =\n                (((quoteAmount * decs.baseDec * decs.priceDec) / state.price) *\n                    (uint256(1e18) - gamma - state.spread)) /\n                1e18 /\n                decs.quoteDec;\n        }\n\n        // new_price = oracle.price / (1 - k * quoteAmount)\n        newPrice = (uint256(1e18) * state.price) / (uint256(1e18) - gamma);\n    }\n\n    function _maxUInt16(uint16 a, uint16 b) private pure returns (uint16) {\n        return a > b ? a : b;\n    }\n\n    function _maxUInt64(uint64 a, uint64 b) private pure returns (uint64) {\n        return a > b ? a : b;\n    }\n}"
    }
  ]
}