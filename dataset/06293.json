{
  "Title": "[G-05] Use constants instead of type(uintx).max",
  "Content": "using type(uintx).max can result in higher gas costs because it involves a runtime operation to calculate the maximum value at runtime. This calculation is performed every time the expression is evaluated.\n\nTo save gas, it is recommended to use constants instead of type(uintx).max to represent the maximum value. By declaring a constant with the maximum value, the value is known at compile-time and does not require any runtime calculations.\n\n```solidity\nFile: /src/libraries/LibBytes.sol\n40  require(reserves[0] <= type(uint128).max, \"ByteStorage: too large\");\n\n41  require(reserves[1] <= type(uint128).max, \"ByteStorage: too large\");\n\n49  require(reserves[2 * i] <= type(uint128).max, \"ByteStorage: too large\");\n\n50  require(reserves[2 * i + 1] <= type(uint128).max, \"ByteStorage: too large\");\n\n63  require(reserves[reserves.length - 1] <= type(uint128).max, \"ByteStorage: too large\");\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibBytes.sol#L40\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibBytes.sol#L41\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibBytes.sol#L49\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibBytes.sol#L50\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibBytes.sol#L63\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/libraries/LibBytes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title LibBytes\n * @author Publius\n * @notice Contains byte operations used during storage reads & writes.\n *\n * {LibBytes} tightly packs an array of `uint256` values into `n / 2` storage\n * slots, where `n` is number of items to pack.\n *\n * Each value must be `<= type(uint128).max` in order pack properly.\n */\nlibrary LibBytes {\n    bytes32 private constant ZERO_BYTES = bytes32(0);\n\n    /**\n     * @dev Read the `i`th 32-byte chunk from `data`.\n     */\n    function getBytes32FromBytes(bytes memory data, uint256 i) internal pure returns (bytes32 _bytes) {\n        uint256 index = i * 32;\n        if (index > data.length) {\n            _bytes = ZERO_BYTES;\n        } else {\n            assembly {\n                _bytes := mload(add(add(data, index), 32))\n            }\n        }\n    }\n\n    /**\n     * @dev Store packed uint128 `reserves` starting at storage position `slot`.\n     * Balances are passed as an uint256[], but values must be <= max uint128\n     * to allow for packing into a single storage slot.\n     */\n    function storeUint128(bytes32 slot, uint256[] memory reserves) internal {\n        // Shortcut: two reserves can be packed into one slot without a loop\n        if (reserves.length == 2) {\n            require(reserves[0] <= type(uint128).max, \"ByteStorage: too large\");\n            require(reserves[1] <= type(uint128).max, \"ByteStorage: too large\");\n            assembly {\n                sstore(slot, add(mload(add(reserves, 32)), shl(128, mload(add(reserves, 64)))))\n            }\n        } else {\n            uint256 maxI = reserves.length / 2; // number of fully-packed slots\n            uint256 iByte; // byte offset of the current reserve\n            for (uint256 i; i < maxI; ++i) {\n                require(reserves[2 * i] <= type(uint128).max, \"ByteStorage: too large\");\n                require(reserves[2 * i + 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = i * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(i, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, mload(add(reserves, add(iByte, 64)))))\n                    )\n                }\n            }\n            // If there is an odd number of reserves, create a slot with the last reserve\n            // Since `i < maxI` above, the next byte offset `maxI * 64`\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (reserves.length & 1 == 1) {\n                require(reserves[reserves.length - 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = maxI * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(maxI, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, shr(128, sload(add(slot, mul(maxI, 32))))))\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Read `n` packed uint128 reserves at storage position `slot`.\n     */\n    function readUint128(bytes32 slot, uint256 n) internal view returns (uint256[] memory reserves) {\n        // Initialize array with length `n`, fill it in via assembly\n        reserves = new uint256[](n);\n\n        // Shortcut: two reserves can be quickly unpacked from one slot\n        if (n == 2) {\n            assembly {\n                mstore(add(reserves, 32), shr(128, shl(128, sload(slot))))\n                mstore(add(reserves, 64), shr(128, sload(slot)))\n            }\n            return reserves;\n        }\n\n        uint256 iByte;\n        for (uint256 i = 1; i <= n; ++i) {\n            // `iByte` is the byte position for the current slot:\n            // i        1 2 3 4 5 6\n            // iByte    0 0 1 1 2 2\n            iByte = (i - 1) / 2 * 32;\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (i & 1 == 1) {\n                assembly {\n                    mstore(\n                        // store at index i * 32; i = 0 is skipped by loop\n                        add(reserves, mul(i, 32)),\n                        shr(128, shl(128, sload(add(slot, iByte))))\n                    )\n                }\n            } else {\n                assembly {\n                    mstore(add(reserves, mul(i, 32)), shr(128, sload(add(slot, iByte))))\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/libraries/LibBytes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title LibBytes\n * @author Publius\n * @notice Contains byte operations used during storage reads & writes.\n *\n * {LibBytes} tightly packs an array of `uint256` values into `n / 2` storage\n * slots, where `n` is number of items to pack.\n *\n * Each value must be `<= type(uint128).max` in order pack properly.\n */\nlibrary LibBytes {\n    bytes32 private constant ZERO_BYTES = bytes32(0);\n\n    /**\n     * @dev Read the `i`th 32-byte chunk from `data`.\n     */\n    function getBytes32FromBytes(bytes memory data, uint256 i) internal pure returns (bytes32 _bytes) {\n        uint256 index = i * 32;\n        if (index > data.length) {\n            _bytes = ZERO_BYTES;\n        } else {\n            assembly {\n                _bytes := mload(add(add(data, index), 32))\n            }\n        }\n    }\n\n    /**\n     * @dev Store packed uint128 `reserves` starting at storage position `slot`.\n     * Balances are passed as an uint256[], but values must be <= max uint128\n     * to allow for packing into a single storage slot.\n     */\n    function storeUint128(bytes32 slot, uint256[] memory reserves) internal {\n        // Shortcut: two reserves can be packed into one slot without a loop\n        if (reserves.length == 2) {\n            require(reserves[0] <= type(uint128).max, \"ByteStorage: too large\");\n            require(reserves[1] <= type(uint128).max, \"ByteStorage: too large\");\n            assembly {\n                sstore(slot, add(mload(add(reserves, 32)), shl(128, mload(add(reserves, 64)))))\n            }\n        } else {\n            uint256 maxI = reserves.length / 2; // number of fully-packed slots\n            uint256 iByte; // byte offset of the current reserve\n            for (uint256 i; i < maxI; ++i) {\n                require(reserves[2 * i] <= type(uint128).max, \"ByteStorage: too large\");\n                require(reserves[2 * i + 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = i * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(i, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, mload(add(reserves, add(iByte, 64)))))\n                    )\n                }\n            }\n            // If there is an odd number of reserves, create a slot with the last reserve\n            // Since `i < maxI` above, the next byte offset `maxI * 64`\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (reserves.length & 1 == 1) {\n                require(reserves[reserves.length - 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = maxI * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(maxI, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, shr(128, sload(add(slot, mul(maxI, 32))))))\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Read `n` packed uint128 reserves at storage position `slot`.\n     */\n    function readUint128(bytes32 slot, uint256 n) internal view returns (uint256[] memory reserves) {\n        // Initialize array with length `n`, fill it in via assembly\n        reserves = new uint256[](n);\n\n        // Shortcut: two reserves can be quickly unpacked from one slot\n        if (n == 2) {\n            assembly {\n                mstore(add(reserves, 32), shr(128, shl(128, sload(slot))))\n                mstore(add(reserves, 64), shr(128, sload(slot)))\n            }\n            return reserves;\n        }\n\n        uint256 iByte;\n        for (uint256 i = 1; i <= n; ++i) {\n            // `iByte` is the byte position for the current slot:\n            // i        1 2 3 4 5 6\n            // iByte    0 0 1 1 2 2\n            iByte = (i - 1) / 2 * 32;\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (i & 1 == 1) {\n                assembly {\n                    mstore(\n                        // store at index i * 32; i = 0 is skipped by loop\n                        add(reserves, mul(i, 32)),\n                        shr(128, shl(128, sload(add(slot, iByte))))\n                    )\n                }\n            } else {\n                assembly {\n                    mstore(add(reserves, mul(i, 32)), shr(128, sload(add(slot, iByte))))\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/libraries/LibBytes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title LibBytes\n * @author Publius\n * @notice Contains byte operations used during storage reads & writes.\n *\n * {LibBytes} tightly packs an array of `uint256` values into `n / 2` storage\n * slots, where `n` is number of items to pack.\n *\n * Each value must be `<= type(uint128).max` in order pack properly.\n */\nlibrary LibBytes {\n    bytes32 private constant ZERO_BYTES = bytes32(0);\n\n    /**\n     * @dev Read the `i`th 32-byte chunk from `data`.\n     */\n    function getBytes32FromBytes(bytes memory data, uint256 i) internal pure returns (bytes32 _bytes) {\n        uint256 index = i * 32;\n        if (index > data.length) {\n            _bytes = ZERO_BYTES;\n        } else {\n            assembly {\n                _bytes := mload(add(add(data, index), 32))\n            }\n        }\n    }\n\n    /**\n     * @dev Store packed uint128 `reserves` starting at storage position `slot`.\n     * Balances are passed as an uint256[], but values must be <= max uint128\n     * to allow for packing into a single storage slot.\n     */\n    function storeUint128(bytes32 slot, uint256[] memory reserves) internal {\n        // Shortcut: two reserves can be packed into one slot without a loop\n        if (reserves.length == 2) {\n            require(reserves[0] <= type(uint128).max, \"ByteStorage: too large\");\n            require(reserves[1] <= type(uint128).max, \"ByteStorage: too large\");\n            assembly {\n                sstore(slot, add(mload(add(reserves, 32)), shl(128, mload(add(reserves, 64)))))\n            }\n        } else {\n            uint256 maxI = reserves.length / 2; // number of fully-packed slots\n            uint256 iByte; // byte offset of the current reserve\n            for (uint256 i; i < maxI; ++i) {\n                require(reserves[2 * i] <= type(uint128).max, \"ByteStorage: too large\");\n                require(reserves[2 * i + 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = i * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(i, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, mload(add(reserves, add(iByte, 64)))))\n                    )\n                }\n            }\n            // If there is an odd number of reserves, create a slot with the last reserve\n            // Since `i < maxI` above, the next byte offset `maxI * 64`\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (reserves.length & 1 == 1) {\n                require(reserves[reserves.length - 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = maxI * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(maxI, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, shr(128, sload(add(slot, mul(maxI, 32))))))\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Read `n` packed uint128 reserves at storage position `slot`.\n     */\n    function readUint128(bytes32 slot, uint256 n) internal view returns (uint256[] memory reserves) {\n        // Initialize array with length `n`, fill it in via assembly\n        reserves = new uint256[](n);\n\n        // Shortcut: two reserves can be quickly unpacked from one slot\n        if (n == 2) {\n            assembly {\n                mstore(add(reserves, 32), shr(128, shl(128, sload(slot))))\n                mstore(add(reserves, 64), shr(128, sload(slot)))\n            }\n            return reserves;\n        }\n\n        uint256 iByte;\n        for (uint256 i = 1; i <= n; ++i) {\n            // `iByte` is the byte position for the current slot:\n            // i        1 2 3 4 5 6\n            // iByte    0 0 1 1 2 2\n            iByte = (i - 1) / 2 * 32;\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (i & 1 == 1) {\n                assembly {\n                    mstore(\n                        // store at index i * 32; i = 0 is skipped by loop\n                        add(reserves, mul(i, 32)),\n                        shr(128, shl(128, sload(add(slot, iByte))))\n                    )\n                }\n            } else {\n                assembly {\n                    mstore(add(reserves, mul(i, 32)), shr(128, sload(add(slot, iByte))))\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/libraries/LibBytes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title LibBytes\n * @author Publius\n * @notice Contains byte operations used during storage reads & writes.\n *\n * {LibBytes} tightly packs an array of `uint256` values into `n / 2` storage\n * slots, where `n` is number of items to pack.\n *\n * Each value must be `<= type(uint128).max` in order pack properly.\n */\nlibrary LibBytes {\n    bytes32 private constant ZERO_BYTES = bytes32(0);\n\n    /**\n     * @dev Read the `i`th 32-byte chunk from `data`.\n     */\n    function getBytes32FromBytes(bytes memory data, uint256 i) internal pure returns (bytes32 _bytes) {\n        uint256 index = i * 32;\n        if (index > data.length) {\n            _bytes = ZERO_BYTES;\n        } else {\n            assembly {\n                _bytes := mload(add(add(data, index), 32))\n            }\n        }\n    }\n\n    /**\n     * @dev Store packed uint128 `reserves` starting at storage position `slot`.\n     * Balances are passed as an uint256[], but values must be <= max uint128\n     * to allow for packing into a single storage slot.\n     */\n    function storeUint128(bytes32 slot, uint256[] memory reserves) internal {\n        // Shortcut: two reserves can be packed into one slot without a loop\n        if (reserves.length == 2) {\n            require(reserves[0] <= type(uint128).max, \"ByteStorage: too large\");\n            require(reserves[1] <= type(uint128).max, \"ByteStorage: too large\");\n            assembly {\n                sstore(slot, add(mload(add(reserves, 32)), shl(128, mload(add(reserves, 64)))))\n            }\n        } else {\n            uint256 maxI = reserves.length / 2; // number of fully-packed slots\n            uint256 iByte; // byte offset of the current reserve\n            for (uint256 i; i < maxI; ++i) {\n                require(reserves[2 * i] <= type(uint128).max, \"ByteStorage: too large\");\n                require(reserves[2 * i + 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = i * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(i, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, mload(add(reserves, add(iByte, 64)))))\n                    )\n                }\n            }\n            // If there is an odd number of reserves, create a slot with the last reserve\n            // Since `i < maxI` above, the next byte offset `maxI * 64`\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (reserves.length & 1 == 1) {\n                require(reserves[reserves.length - 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = maxI * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(maxI, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, shr(128, sload(add(slot, mul(maxI, 32))))))\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Read `n` packed uint128 reserves at storage position `slot`.\n     */\n    function readUint128(bytes32 slot, uint256 n) internal view returns (uint256[] memory reserves) {\n        // Initialize array with length `n`, fill it in via assembly\n        reserves = new uint256[](n);\n\n        // Shortcut: two reserves can be quickly unpacked from one slot\n        if (n == 2) {\n            assembly {\n                mstore(add(reserves, 32), shr(128, shl(128, sload(slot))))\n                mstore(add(reserves, 64), shr(128, sload(slot)))\n            }\n            return reserves;\n        }\n\n        uint256 iByte;\n        for (uint256 i = 1; i <= n; ++i) {\n            // `iByte` is the byte position for the current slot:\n            // i        1 2 3 4 5 6\n            // iByte    0 0 1 1 2 2\n            iByte = (i - 1) / 2 * 32;\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (i & 1 == 1) {\n                assembly {\n                    mstore(\n                        // store at index i * 32; i = 0 is skipped by loop\n                        add(reserves, mul(i, 32)),\n                        shr(128, shl(128, sload(add(slot, iByte))))\n                    )\n                }\n            } else {\n                assembly {\n                    mstore(add(reserves, mul(i, 32)), shr(128, sload(add(slot, iByte))))\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/libraries/LibBytes.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title LibBytes\n * @author Publius\n * @notice Contains byte operations used during storage reads & writes.\n *\n * {LibBytes} tightly packs an array of `uint256` values into `n / 2` storage\n * slots, where `n` is number of items to pack.\n *\n * Each value must be `<= type(uint128).max` in order pack properly.\n */\nlibrary LibBytes {\n    bytes32 private constant ZERO_BYTES = bytes32(0);\n\n    /**\n     * @dev Read the `i`th 32-byte chunk from `data`.\n     */\n    function getBytes32FromBytes(bytes memory data, uint256 i) internal pure returns (bytes32 _bytes) {\n        uint256 index = i * 32;\n        if (index > data.length) {\n            _bytes = ZERO_BYTES;\n        } else {\n            assembly {\n                _bytes := mload(add(add(data, index), 32))\n            }\n        }\n    }\n\n    /**\n     * @dev Store packed uint128 `reserves` starting at storage position `slot`.\n     * Balances are passed as an uint256[], but values must be <= max uint128\n     * to allow for packing into a single storage slot.\n     */\n    function storeUint128(bytes32 slot, uint256[] memory reserves) internal {\n        // Shortcut: two reserves can be packed into one slot without a loop\n        if (reserves.length == 2) {\n            require(reserves[0] <= type(uint128).max, \"ByteStorage: too large\");\n            require(reserves[1] <= type(uint128).max, \"ByteStorage: too large\");\n            assembly {\n                sstore(slot, add(mload(add(reserves, 32)), shl(128, mload(add(reserves, 64)))))\n            }\n        } else {\n            uint256 maxI = reserves.length / 2; // number of fully-packed slots\n            uint256 iByte; // byte offset of the current reserve\n            for (uint256 i; i < maxI; ++i) {\n                require(reserves[2 * i] <= type(uint128).max, \"ByteStorage: too large\");\n                require(reserves[2 * i + 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = i * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(i, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, mload(add(reserves, add(iByte, 64)))))\n                    )\n                }\n            }\n            // If there is an odd number of reserves, create a slot with the last reserve\n            // Since `i < maxI` above, the next byte offset `maxI * 64`\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (reserves.length & 1 == 1) {\n                require(reserves[reserves.length - 1] <= type(uint128).max, \"ByteStorage: too large\");\n                iByte = maxI * 64;\n                assembly {\n                    sstore(\n                        add(slot, mul(maxI, 32)),\n                        add(mload(add(reserves, add(iByte, 32))), shl(128, shr(128, sload(add(slot, mul(maxI, 32))))))\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Read `n` packed uint128 reserves at storage position `slot`.\n     */\n    function readUint128(bytes32 slot, uint256 n) internal view returns (uint256[] memory reserves) {\n        // Initialize array with length `n`, fill it in via assembly\n        reserves = new uint256[](n);\n\n        // Shortcut: two reserves can be quickly unpacked from one slot\n        if (n == 2) {\n            assembly {\n                mstore(add(reserves, 32), shr(128, shl(128, sload(slot))))\n                mstore(add(reserves, 64), shr(128, sload(slot)))\n            }\n            return reserves;\n        }\n\n        uint256 iByte;\n        for (uint256 i = 1; i <= n; ++i) {\n            // `iByte` is the byte position for the current slot:\n            // i        1 2 3 4 5 6\n            // iByte    0 0 1 1 2 2\n            iByte = (i - 1) / 2 * 32;\n            // Equivalent to \"i % 2 == 1\", but cheaper.\n            if (i & 1 == 1) {\n                assembly {\n                    mstore(\n                        // store at index i * 32; i = 0 is skipped by loop\n                        add(reserves, mul(i, 32)),\n                        shr(128, shl(128, sload(add(slot, iByte))))\n                    )\n                }\n            } else {\n                assembly {\n                    mstore(add(reserves, mul(i, 32)), shr(128, sload(add(slot, iByte))))\n                }\n            }\n        }\n    }\n}"
    }
  ]
}