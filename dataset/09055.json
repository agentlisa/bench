{
  "Title": "[08] `_callConduitUsingOffsets` depends on compiler behaviour for inter-assembly-block cleanup",
  "Content": "\nThe function `_callConduitUsingOffsets` depends on the compiler not to use the scratch space between assembly blocks. it also performs some Solidity function calls between the two blocks.\n\nA compiler behaviour change would render calling conduits always failing.\n\nFurthermore this function depends on `_revertWithReasonIfOneIsReturned` not disturbing anything (see another relevant issue by us).\n\n### Proof of Concept\n**Context:** [Executor.sol#L498](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/Executor.sol#L498)\n\n```solidity\n        bool success;\n\n        // call the conduit.\n        assembly {\n            // Ensure first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Perform call, placing first word of return data in scratch space.\n            success := call(\n                gas(),\n                conduit,\n                0,\n                callDataOffset,\n                callDataSize,\n                0,\n                OneWord\n            )\n        }\n\n        // <--- If the compiler changes scratch space after this (or even in the helpers below) then it will fail.\n\n        // If the call failed...\n        if (!success) {\n            // Pass along whatever revert reason was given by the conduit.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error.\n            revert InvalidCallToConduit(conduit);\n        }\n\n        // Ensure that the conduit returned the correct magic value.\n        bytes4 result;\n        assembly {\n            // Take value from scratch space and place it on the stack.\n            result := mload(0)\n        }\n\n        // Ensure result was extracted and matches EIP-1271 magic value.\n        if (result != ConduitInterface.execute.selector) {\n            revert InvalidConduit(conduitKey, conduit);\n        }\n```\n\n### Recommended Mitigation Steps\n\n1. Load the scratch space in the first assembly block\n2. Since this function seems to perform \"return-magic-detection\", one could consider replacing most of this with `_doesNotMatchMagic`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/Executor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    ERC20Interface,\n    ERC721Interface,\n    ERC1155Interface\n} from \"../interfaces/AbridgedTokenInterfaces.sol\";\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\nimport { ItemType } from \"./ConsiderationEnums.sol\";\n\nimport { ReceivedItem } from \"./ConsiderationStructs.sol\";\n\nimport { Verifiers } from \"./Verifiers.sol\";\n\nimport { TokenTransferrer } from \"./TokenTransferrer.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title Executor\n * @author 0age\n * @notice Executor contains functions related to processing executions (i.e.\n *         transferring items, either directly or via conduits).\n */\ncontract Executor is Verifiers, TokenTransferrer {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Verifiers(conduitController) {}\n\n    /**\n     * @dev Internal function to transfer a given item, either directly or via\n     *      a corresponding conduit.\n     *\n     * @param item        The item to transfer, including an amount and a\n     *                    recipient.\n     * @param from        The account supplying the item.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transfer(\n        ReceivedItem memory item,\n        address from,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // If the item type indicates Ether or a native token...\n        if (item.itemType == ItemType.NATIVE) {\n            // transfer the native tokens to the recipient.\n            _transferEth(item.recipient, item.amount);\n        } else if (item.itemType == ItemType.ERC20) {\n            // Transfer ERC20 tokens from the source to the recipient.\n            _transferERC20(\n                item.token,\n                from,\n                item.recipient,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        } else if (item.itemType == ItemType.ERC721) {\n            // Transfer ERC721 token from the source to the recipient.\n            _transferERC721(\n                item.token,\n                from,\n                item.recipient,\n                item.identifier,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        } else {\n            // Transfer ERC1155 token from the source to the recipient.\n            _transferERC1155(\n                item.token,\n                from,\n                item.recipient,\n                item.identifier,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer an individual ERC721 or ERC1155 item\n     *      from a given originator to a given recipient. The accumulator will\n     *      be bypassed, meaning that this function should be utilized in cases\n     *      where multiple item transfers can be accumulated into a single\n     *      conduit call. Sufficient approvals must be set, either on the\n     *      respective conduit or on this contract itself.\n     *\n     * @param itemType   The type of item to transfer, either ERC721 or ERC1155.\n     * @param token      The token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param identifier The tokenId to transfer.\n     * @param amount     The amount to transfer.\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\n     *                   if any, to source token approvals from. The zero hash\n     *                   signifies that no conduit should be used, with direct\n     *                   approvals set on this contract.\n     */\n    function _transferIndividual721Or1155Item(\n        ItemType itemType,\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount,\n        bytes32 conduitKey\n    ) internal {\n        // Determine if the transfer is to be performed via a conduit.\n        if (conduitKey != bytes32(0)) {\n            // Use free memory pointer as calldata offset for the conduit call.\n            uint256 callDataOffset;\n\n            // Utilize assembly to place each argument in free memory.\n            assembly {\n                // Retrieve the free memory pointer and use it as the offset.\n                callDataOffset := mload(FreeMemoryPointerSlot)\n\n                // Write ConduitInterface.execute.selector to memory.\n                mstore(callDataOffset, Conduit_execute_signature)\n\n                // Write the offset to the ConduitTransfer array in memory.\n                mstore(\n                    add(\n                        callDataOffset,\n                        Conduit_execute_ConduitTransfer_offset_ptr\n                    ),\n                    Conduit_execute_ConduitTransfer_ptr\n                )\n\n                // Write the length of the ConduitTransfer array to memory.\n                mstore(\n                    add(\n                        callDataOffset,\n                        Conduit_execute_ConduitTransfer_length_ptr\n                    ),\n                    Conduit_execute_ConduitTransfer_length\n                )\n\n                // Write the item type to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferItemType_ptr),\n                    itemType\n                )\n\n                // Write the token to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferToken_ptr),\n                    token\n                )\n\n                // Write the transfer source to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferFrom_ptr),\n                    from\n                )\n\n                // Write the transfer recipient to memory.\n                mstore(add(callDataOffset, Conduit_execute_transferTo_ptr), to)\n\n                // Write the token identifier to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferIdentifier_ptr),\n                    identifier\n                )\n\n                // Write the transfer amount to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferAmount_ptr),\n                    amount\n                )\n            }\n\n            // Perform the call to the conduit.\n            _callConduitUsingOffsets(\n                conduitKey,\n                callDataOffset,\n                OneConduitExecute_size\n            );\n        } else {\n            // Otherwise, determine whether it is an ERC721 or ERC1155 item.\n            if (itemType == ItemType.ERC721) {\n                // Ensure that exactly one 721 item is being transferred.\n                if (amount != 1) {\n                    revert InvalidERC721TransferAmount();\n                }\n\n                // Perform transfer via the token contract directly.\n                _performERC721Transfer(token, from, to, identifier);\n            } else {\n                // Perform transfer via the token contract directly.\n                _performERC1155Transfer(token, from, to, identifier, amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer Ether or other native tokens to a\n     *      given recipient.\n     *\n     * @param to     The recipient of the transfer.\n     * @param amount The amount to transfer.\n     */\n    function _transferEth(address payable to, uint256 amount) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Declare a variable indicating whether the call was successful or not.\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        // If the call fails...\n        if (!success) {\n            // Revert and pass the revert reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error message.\n            revert EtherTransferGenericFailure(to, amount);\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC20 tokens from a given originator\n     *      to a given recipient using a given conduit if applicable. Sufficient\n     *      approvals must be set on this contract or on a respective conduit.\n     *\n     * @param token       The ERC20 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param amount      The amount to transfer.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC20(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Perform the token transfer directly.\n            _performERC20Transfer(token, from, to, amount);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                uint256(1),\n                token,\n                from,\n                to,\n                uint256(0),\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer a single ERC721 token from a given\n     *      originator to a given recipient. Sufficient approvals must be set,\n     *      either on the respective conduit or on this contract itself.\n     *\n     * @param token       The ERC721 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The tokenId to transfer (must be 1 for ERC721).\n     * @param amount      The amount to transfer.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC721(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Ensure that exactly one 721 item is being transferred.\n            if (amount != 1) {\n                revert InvalidERC721TransferAmount();\n            }\n\n            // Perform transfer via the token contract directly.\n            _performERC721Transfer(token, from, to, identifier);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                uint256(2),\n                token,\n                from,\n                to,\n                identifier,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given originator\n     *      to a given recipient. Sufficient approvals must be set, either on\n     *      the respective conduit or on this contract itself.\n     *\n     * @param token       The ERC1155 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The id to transfer.\n     * @param amount      The amount to transfer.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC1155(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Perform transfer via the token contract directly.\n            _performERC1155Transfer(token, from, to, identifier, amount);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                uint256(3),\n                token,\n                from,\n                to,\n                identifier,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit currently held by\n     *      the accumulator if the accumulator contains item transfers (i.e. it\n     *      is \"armed\") and the supplied conduit key does not match the key held\n     *      by the accumulator.\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     */\n    function _triggerIfArmedAndNotAccumulatable(\n        bytes memory accumulator,\n        bytes32 conduitKey\n    ) internal {\n        // Retrieve the current conduit key from the accumulator.\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\n\n        // Perform conduit call if the set key does not match the supplied key.\n        if (accumulatorConduitKey != conduitKey) {\n            _triggerIfArmed(accumulator);\n        }\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit currently held by\n     *      the accumulator if the accumulator contains item transfers (i.e. it\n     *      is \"armed\").\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _triggerIfArmed(bytes memory accumulator) internal {\n        // Exit if the accumulator is not \"armed\".\n        if (accumulator.length != 64) {\n            return;\n        }\n\n        // Retrieve the current conduit key from the accumulator.\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\n\n        // Perform conduit call.\n        _trigger(accumulatorConduitKey, accumulator);\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit corresponding to\n     *      a given conduit key, supplying all accumulated item transfers. The\n     *      accumulator will be \"disarmed\" and reset in the process.\n     *\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _trigger(bytes32 conduitKey, bytes memory accumulator) internal {\n        // Declare variables for offset in memory & size of calldata to conduit.\n        uint256 callDataOffset;\n        uint256 callDataSize;\n\n        // Call the conduit with all the accumulated transfers.\n        assembly {\n            // Call begins at third word; the first is length or \"armed\" status,\n            // and the second is the current conduit key.\n            callDataOffset := add(accumulator, TwoWords)\n\n            // 68 + items * 192\n            callDataSize := add(\n                Accumulator_array_offset_ptr,\n                mul(\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\n                    Conduit_transferItem_size\n                )\n            )\n        }\n\n        // Call conduit derived from conduit key & supply accumulated transfers.\n        _callConduitUsingOffsets(conduitKey, callDataOffset, callDataSize);\n\n        // Reset accumulator length to signal that it is now \"disarmed\".\n        assembly {\n            mstore(accumulator, AccumulatorDisarmed)\n        }\n    }\n\n    /**\n     * @dev Internal function to perform a call to the conduit corresponding to\n     *      a given conduit key based on the offset and size of the calldata in\n     *      question in memory.\n     *\n     * @param conduitKey     A bytes32 value indicating what corresponding\n     *                       conduit, if any, to source token approvals from.\n     *                       The zero hash signifies that no conduit should be\n     *                       used, with direct approvals set on this contract.\n     * @param callDataOffset The memory pointer where calldata is contained.\n     * @param callDataSize   The size of calldata in memory.\n     */\n    function _callConduitUsingOffsets(\n        bytes32 conduitKey,\n        uint256 callDataOffset,\n        uint256 callDataSize\n    ) internal {\n        // Derive the address of the conduit using the conduit key.\n        address conduit = _deriveConduit(conduitKey);\n\n        bool success;\n\n        // call the conduit.\n        assembly {\n            // Ensure first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Perform call, placing first word of return data in scratch space.\n            success := call(\n                gas(),\n                conduit,\n                0,\n                callDataOffset,\n                callDataSize,\n                0,\n                OneWord\n            )\n        }\n\n        // If the call failed...\n        if (!success) {\n            // Pass along whatever revert reason was given by the conduit.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error.\n            revert InvalidCallToConduit(conduit);\n        }\n\n        // Ensure that the conduit returned the correct magic value.\n        bytes4 result;\n        assembly {\n            // Take value from scratch space and place it on the stack.\n            result := mload(0)\n        }\n\n        // Ensure result was extracted and matches EIP-1271 magic value.\n        if (result != ConduitInterface.execute.selector) {\n            revert InvalidConduit(conduitKey, conduit);\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the current conduit key set for\n     *      the accumulator.\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     *\n     * @return accumulatorConduitKey The conduit key currently set for the\n     *                               accumulator.\n     */\n    function _getAccumulatorConduitKey(bytes memory accumulator)\n        internal\n        pure\n        returns (bytes32 accumulatorConduitKey)\n    {\n        // Retrieve the current conduit key from the accumulator.\n        assembly {\n            accumulatorConduitKey := mload(\n                add(accumulator, Accumulator_conduitKey_ptr)\n            )\n        }\n    }\n\n    /**\n     * @dev Internal pure function to place an item transfer into an accumulator\n     *      that collects a series of transfers to execute against a given\n     *      conduit in a single call.\n     *\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     * @param itemType    The type of the item to transfer.\n     * @param token       The token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The tokenId to transfer.\n     * @param amount      The amount to transfer.\n     */\n    function _insert(\n        bytes32 conduitKey,\n        bytes memory accumulator,\n        uint256 itemType,\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    ) internal pure {\n        uint256 elements;\n        // \"Arm\" and prime accumulator if it's not already armed. The sentinel\n        // value is held in the length of the accumulator array.\n        if (accumulator.length == AccumulatorDisarmed) {\n            elements = 1;\n            bytes4 selector = ConduitInterface.execute.selector;\n            assembly {\n                mstore(accumulator, AccumulatorArmed) // \"arm\" the accumulator.\n                mstore(add(accumulator, Accumulator_conduitKey_ptr), conduitKey)\n                mstore(add(accumulator, Accumulator_selector_ptr), selector)\n                mstore(\n                    add(accumulator, Accumulator_array_offset_ptr),\n                    Accumulator_array_offset\n                )\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\n            }\n        } else {\n            // Otherwise, increase the number of elements by one.\n            assembly {\n                elements := add(\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\n                    1\n                )\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\n            }\n        }\n\n        // Insert the item.\n        assembly {\n            let itemPointer := sub(\n                add(accumulator, mul(elements, Conduit_transferItem_size)),\n                Accumulator_itemSizeOffsetDifference\n            )\n            mstore(itemPointer, itemType)\n            mstore(add(itemPointer, Conduit_transferItem_token_ptr), token)\n            mstore(add(itemPointer, Conduit_transferItem_from_ptr), from)\n            mstore(add(itemPointer, Conduit_transferItem_to_ptr), to)\n            mstore(\n                add(itemPointer, Conduit_transferItem_identifier_ptr),\n                identifier\n            )\n            mstore(add(itemPointer, Conduit_transferItem_amount_ptr), amount)\n        }\n    }\n}"
    }
  ]
}