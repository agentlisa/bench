{
  "Title": "M-2: useLoan doesn't allow liqudator to specifiy maximum price",
  "Content": "# Issue M-2: useLoan doesn't allow liqudator to specifiy maximum price \n\nSource: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/25 \n\n## Found by \n0x52\n\n## Summary\n\nuseLoan doesn't allow the liquidator to specify a max price they are will to pay for the collateral they are liquidating. On the surface this doesn't seem like an issue because the price is always decreasing due to the dutch auction. However this can be problematic if the chain the contracts are deployed suffers a reorg attack. This can place the transaction earlier than anticipated and therefore charge the user more than they meant to pay. On Ethereum this is unlikely but this is meant to be deployed on any compatible EVM chain many of which are frequently reorganized.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nLiquidator can be charged more than intended\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L59-L73\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow liquidator to specify a max acceptable price to pay\n\n\n\n## Discussion\n\n**npasquie**\n\nfixed here https://github.com/kairos-loan/kairos-contracts/pull/50\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/56",
  "Code": [
    {
      "filename": "kairos-contracts/src/AuctionFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IAuctionFacet} from \"./interface/IAuctionFacet.sol\";\n\nimport {BuyArg, NFToken, Ray} from \"./DataStructure/Objects.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\nimport {protocolStorage, supplyPositionStorage, ONE, ZERO} from \"./DataStructure/Global.sol\";\n// solhint-disable-next-line max-line-length\nimport {LoanAlreadyRepaid, CollateralIsNotLiquidableYet} from \"./DataStructure/Errors.sol\";\n\n/// @notice handles sale of collaterals being liquidated, following a dutch auction starting at repayment date\ncontract AuctionFacet is IAuctionFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice buy one or multiple NFTs in liquidation\n    /// @param args arguments on what and how to buy\n    function buy(BuyArg[] memory args) external {\n        for (uint256 i = 0; i < args.length; i++) {\n            useLoan(args[i]);\n        }\n    }\n\n    /// @notice gets the price to buy the underlying collateral of the loan\n    /// @param loanId identifier of the loan\n    /// @return price computed price\n    function price(uint256 loanId) public view returns (uint256) {\n        Loan storage loan = protocolStorage().loan[loanId];\n        uint256 loanEndDate = loan.endDate;\n        uint256 timeSinceLiquidable = block.timestamp - loanEndDate;\n\n        checkLoanStatus(loanId);\n\n        /* the decreasing factor controls the evolution of the price from its initial value to 0 (and staying at 0)\n        over the course of the auction duration */\n        Ray decreasingFactor = timeSinceLiquidable >= loan.auction.duration\n            ? ZERO\n            : ONE.sub(timeSinceLiquidable.div(loan.auction.duration));\n\n        /* the estimated value arises from the mean of the loan offer loanToValues used in the loan regarding their\n        share in the collateral usage. This must stay consitent even if less than the full value of the NFT has been\n        used as collateral */\n        uint256 estimatedValue = loan.lent.mul(ONE.div(loan.shareLent));\n\n        /* by mutliplying the estimated price by some factor and slowly decreasing this price over time we aim to\n        make sure a liquidator will buy the NFT at fair market price. */\n        return estimatedValue.mul(loan.auction.priceFactor).mul(decreasingFactor);\n    }\n\n    /// @notice handles buying one NFT\n    /// @param arg arguments on what and how to buy\n    function useLoan(BuyArg memory arg) internal {\n        Loan storage loan = protocolStorage().loan[arg.loanId];\n\n        checkLoanStatus(arg.loanId);\n        uint256 toPay = price(arg.loanId);\n\n        /* store as liquidated and paid before transfers to avoid malicious reentrency, following\n        checks-effects-interaction pattern */\n        loan.payment.liquidated = true;\n        loan.payment.paid = toPay;\n        loan.assetLent.checkedTransferFrom(msg.sender, address(this), toPay);\n        loan.collateral.implem.safeTransferFrom(address(this), arg.to, loan.collateral.id);\n\n        emit Buy(arg.loanId, abi.encode(arg));\n    }\n\n    /// @notice checks that loan is liquidable, revert if not\n    /// @param loanId identifier of the loan\n    function checkLoanStatus(uint256 loanId) internal view {\n        Loan storage loan = protocolStorage().loan[loanId];\n\n        if (block.timestamp < loan.endDate) {\n            revert CollateralIsNotLiquidableYet(loan.endDate, loanId);\n        }\n        if (loan.payment.paid != 0 || loan.payment.liquidated) {\n            revert LoanAlreadyRepaid(loanId);\n        }\n    }\n}"
    }
  ]
}