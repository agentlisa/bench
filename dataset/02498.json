{
  "Title": "H-1: RewardsManager doesn't delete old bucket snapshot info on unstaking",
  "Content": "# Issue H-1: RewardsManager doesn't delete old bucket snapshot info on unstaking \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/183 \n\n## Found by \nhyh\n\n## Summary\n\nRewardsManager's unstake() use `delete stakes[tokenId_]` to clear old stake state, but `snapshot` is the nested mapping in the `StakeInfo` structure and will not be reset this way as delete operation do not traverse through nested mappings as it lacks key set information.\n\n## Vulnerability Detail\n\n`stakes[tokenId_]` gets written on staking and `mapping(uint256 => BucketState) snapshot` is written for the *current* list of buckets. This means if this list persists and there were no bucket changes it's ok as new values will be overwritten on next stake.\n\nBut, if Bob the staker has changed his composition of buckets and his second stake takes place over another set, possibly intersecting with the first one, old part will persist. If then Bob's `positionIndexes = positionManager.getPositionIndexes(tokenId_)` changed after the second stake, say as a result of PositionManager's moveLiquidity(), and indices from the first set were added there, their snapshot values from the first stake will be reused.\n\n## Impact\n\nIf Bob knows this it will be straightforward for him to exploit the mechanics, obtaining extra rewards (interest earned will be counted from the first stake time for old positions) at the expense of other stakers.\n\n## Code Snippet\n\nRewardsManager's unstake() deletes `stakes[tokenId_]`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L187-L203\n\n```solidity\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        if (msg.sender != stakes[tokenId_].owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakes[tokenId_].ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(tokenId_, IPool(ajnaPool).currentBurnEpoch());\n\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).safeTransferFrom(address(this), msg.sender, tokenId_);\n    }\n```\n\n`stakes[tokenId_]` is `StakeInfo` structure:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L76\n\n```solidity\n    mapping(uint256 => StakeInfo) internal stakes;  // tokenID => Stake info\n```\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L21\n\n```solidity\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n```\n\nIt contains `snapshot` mapping elemewnt that will not be cleared on delete:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/interfaces/rewards/IRewardsManagerState.sol#L56-L62\n\n```solidity\nstruct StakeInfo {\n    address ajnaPool;                         // address of the Ajna pool the NFT corresponds to\n    uint96  lastInteractionBurnEpoch;         // last burn event the stake interacted with the rewards contract\n    address owner;                            // owner of the LP NFT\n    uint96  stakingEpoch;                     // epoch at staking time\n    mapping(uint256 => BucketState) snapshot; // the LP NFT's balances and exchange rates in each bucket at the time of staking\n}\n```\n\nPer operation docs:\n\nhttps://docs.soliditylang.org/en/latest/types.html#delete\n\n`So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings`\n\nThis way restaking the `tokenId_` will reuse the old `snapshot` mapping.\n\n`BucketState` structure consists of `rateAtStakeTime` and `lpsAtStakeTime`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/interfaces/rewards/IRewardsManagerState.sol#L64-L67\n\n```solidity\nstruct BucketState {\n    uint256 lpsAtStakeTime;  // [RAY] LP amount the NFT owner is entitled in current bucket at the time of staking\n    uint256 rateAtStakeTime; // [RAY] current bucket exchange rate at the time of staking (RAY)\n}\n```\n\nBoth are written on staking, but only for the list of indices as of time of staking:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L144-L162\n\n```solidity\n    uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n    for (uint256 i = 0; i < positionIndexes.length; ) {\n\n        uint256 bucketId = positionIndexes[i];\n\n        BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n        // record the number of lp tokens in bucket at the time of staking\n        bucketState.lpsAtStakeTime = positionManager.getLPTokens(\n            tokenId_,\n            bucketId\n        );\n        // record the bucket exchange rate at the time of staking\n        bucketState.rateAtStakeTime = IPool(ajnaPool).bucketExchangeRate(bucketId);\n\n        // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n        unchecked { ++i; }\n    }\n```\n\n`rateAtStakeTime` and `lpsAtStakeTime` are used for the accrued interest calculation in the _calculateNextEpochRewards():\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L333-L351\n\n```solidity\n        uint256 bucketRate;\n        if (epoch_ != stakingEpoch_) {\n\n            // if staked in a previous epoch then use the initial exchange rate of epoch\n            bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n        } else {\n\n            // if staked during the epoch then use the bucket rate at the time of staking\n            bucketRate = bucketSnapshot.rateAtStakeTime;\n        }\n\n        // calculate the amount of interest accrued in current epoch\n        uint256 interestEarned = _calculateExchangeRateInterestEarned(\n            ajnaPool_,\n            nextEpoch,\n            bucketIndex,\n            bucketSnapshot.lpsAtStakeTime,\n            bucketRate\n        );\n```\n\nThis happens for the current `positionIndexes = positionManager.getPositionIndexes(tokenId_)`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L272-L292\n\n```solidity\n    function _calculateAndClaimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal returns (uint256 rewards_) {\n\n        address ajnaPool      = stakes[tokenId_].ajnaPool;\n        uint256 lastBurnEpoch = stakes[tokenId_].lastInteractionBurnEpoch;\n        uint256 stakingEpoch  = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastBurnEpoch; epoch < epochToClaim_; ) {\n\n            uint256 nextEpochRewards = _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n```\n\nSay Bob restaked, the `snapshot` persisted. Then if positions changed since the second stake and new indices have been there before (i.e. old ones were *readded*, so they weren't reset on the second stake() as were added later, but their values end up not being void as they were there on the first stake and persisted), then their values will be reused from the first Bob's staking.\n\nThis will expand Bob's interest earned reading:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L368-L398\n\n```solidity\n    /**\n     *  @notice Calculate the amount of interest that has accrued to a lender in a bucket based upon their LPs.\n     *  @param  pool_           Address of the pool whose exchange rates are being checked.\n     *  @param  nextEventEpoch_ The next event epoch to check the exchange rate for.\n     *  @param  bucketIndex_    Index of the bucket to check the exchange rate for.\n     *  @param  bucketLPs       Amount of LPs in bucket.\n     *  @param  exchangeRate_   Exchange rate in current epoch.\n     *  @return interestEarned_ The amount of interest accrued.\n     */\n    function _calculateExchangeRateInterestEarned(\n        address pool_,\n        uint256 nextEventEpoch_,\n        uint256 bucketIndex_,\n        uint256 bucketLPs,\n        uint256 exchangeRate_\n    ) internal view returns (uint256 interestEarned_) {\n\n        if (exchangeRate_ != 0) {\n\n            uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_];\n\n            // calculate interest earned only if next exchange rate is higher than current exchange rate\n            if (nextExchangeRate > exchangeRate_) {\n\n                // calculate the equivalent amount of quote tokens given the stakes lp balance,\n                // and the exchange rate at the next and current burn events\n                interestEarned_ = Maths.rayToWad(Maths.rmul(nextExchangeRate - exchangeRate_, bucketLPs));\n            }\n\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIRewardsManagerState.BucketState doesn't contain any nested structures, so `delete bucketState` will reset it fully:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/interfaces/rewards/IRewardsManagerState.sol#L64-L67\n\n```solidity\nstruct BucketState {\n    uint256 lpsAtStakeTime;  // [RAY] LP amount the NFT owner is entitled in current bucket at the time of staking\n    uint256 rateAtStakeTime; // [RAY] current bucket exchange rate at the time of staking (RAY)\n}\n```\n\nConsider clearing the current stake snapshots on unstaking, for example:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/RewardsManager.sol#L187-L203\n\n```solidity\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        if (msg.sender != stakes[tokenId_].owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakes[tokenId_].ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(tokenId_, IPool(ajnaPool).currentBurnEpoch());\n\n+       uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n+       for (uint256 i = 0; i < positionIndexes.length; ) {\n+           delete stakeInfo.snapshot[positionIndexes[i]]; // BucketState\n+           unchecked { ++i; }\n+       }\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).safeTransferFrom(address(this), msg.sender, tokenId_);\n    }\n```\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/RewardsManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IERC20 }    from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { IERC721 }   from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\nimport { IPool }            from './interfaces/pool/IPool.sol';\nimport { IPositionManager } from './interfaces/position/IPositionManager.sol';\n\nimport { PositionManager }  from './PositionManager.sol';\n\nimport {\n    IRewardsManager,\n    IRewardsManagerOwnerActions,\n    IRewardsManagerState,\n    IRewardsManagerDerivedState\n} from './interfaces/rewards/IRewardsManager.sol';\n\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n\nimport { Maths } from './libraries/internal/Maths.sol';\n\n/**\n *  @title  Rewards (staking) Manager contract\n *  @notice Pool lenders can optionally mint NFT that represents their positions.\n *          The Rewards contract allows pool lenders with positions NFT to stake and earn AJNA tokens. \n *          Lenders with NFTs can:\n *          - stake token\n *          - update bucket exchange rate and earn rewards\n *          - claim rewards\n *          - unstake token\n */\ncontract RewardsManager is IRewardsManager {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as Ajna token lp nft rewards.\n     */\n    uint256 internal constant REWARD_CAP = 0.8 * 1e18;\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as Ajna token update rewards.\n     */\n    uint256 internal constant UPDATE_CAP = 0.1 * 1e18;\n    /**\n     * @notice Reward factor by which to scale the total rewards earned.\n     * @dev ensures that rewards issued to staked lenders in a given pool are less than the ajna tokens burned in that pool.\n     */\n    uint256 internal constant REWARD_FACTOR = 0.5 * 1e18;\n    /**\n     * @notice Reward factor by which to scale rewards earned for updating a buckets exchange rate.\n     */\n    uint256 internal UPDATE_CLAIM_REWARD = 0.05 * 1e18;\n    /**\n     * @notice Time period after a burn event in which buckets exchange rates can be updated.\n     */\n    uint256 internal constant UPDATE_PERIOD = 2 weeks;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;       // tokenID => epoch => bool has claimed\n    mapping(uint256 => uint256)                  public override rewardsClaimed;       // epoch => tokens claimed\n    mapping(uint256 => uint256)                  public override updateRewardsClaimed; // epoch => tokens claimed\n\n    // Mapping of per pool bucket exchange rates at a given burn event.\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal bucketExchangeRates; // poolAddress => bucketIndex => epoch => bucket exchange rate\n\n    mapping(uint256 => StakeInfo) internal stakes;  // tokenID => Stake info\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    address          public immutable ajnaToken;       // address of the AJNA token\n    IPositionManager public immutable positionManager; // The PositionManager contract\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(address ajnaToken_, IPositionManager positionManager_) {\n        ajnaToken = ajnaToken_;\n        positionManager = positionManager_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev revert on:\n     *          - not owner NotOwnerOfDeposit()\n     *          - already claimed AlreadyClaimed()\n     *  @dev emit events:\n     *          - ClaimRewards\n     */\n    function claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external override {\n        if (msg.sender != stakes[tokenId_].owner) revert NotOwnerOfDeposit();\n\n        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n\n        _claimRewards(tokenId_, epochToClaim_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev revert on:\n     *          - not owner NotOwnerOfDeposit()\n     *  @dev emit events:\n     *          - Stake\n     */\n    function stake(\n        uint256 tokenId_\n    ) external override {\n        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);\n\n        // check that msg.sender is owner of tokenId\n        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();\n\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n        stakeInfo.owner    = msg.sender;\n        stakeInfo.ajnaPool = ajnaPool;\n\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // record the staking epoch\n        stakeInfo.stakingEpoch = uint96(curBurnEpoch);\n\n        // initialize last time interaction at staking epoch\n        stakeInfo.lastInteractionBurnEpoch = uint96(curBurnEpoch);\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n\n            uint256 bucketId = positionIndexes[i];\n\n            BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n            // record the number of lp tokens in bucket at the time of staking\n            bucketState.lpsAtStakeTime = positionManager.getLPTokens(\n                tokenId_,\n                bucketId\n            );\n            // record the bucket exchange rate at the time of staking\n            bucketState.rateAtStakeTime = IPool(ajnaPool).bucketExchangeRate(bucketId);\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit Stake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT to this contract\n        IERC721(address(positionManager)).safeTransferFrom(msg.sender, address(this), tokenId_);\n\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            positionIndexes\n        );\n\n        // transfer rewards to sender\n        IERC20(ajnaToken).safeTransfer(msg.sender, updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev revert on:\n     *          - not owner NotOwnerOfDeposit()\n     *  @dev emit events:\n     *          - ClaimRewards\n     *          - Unstake\n     */\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        if (msg.sender != stakes[tokenId_].owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakes[tokenId_].ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(tokenId_, IPool(ajnaPool).currentBurnEpoch());\n\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).safeTransferFrom(address(this), msg.sender, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev emit events:\n     *          - UpdateExchangeRates\n     */\n    function updateBucketExchangeRatesAndClaim(\n        address pool_,\n        uint256[] calldata indexes_\n    ) external override returns (uint256 updateReward) {\n        updateReward = _updateBucketExchangeRates(pool_, indexes_);\n\n        // transfer rewards to sender\n        IERC20(ajnaToken).safeTransfer(msg.sender, updateReward);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /*******************************/\n\n    /// @inheritdoc IRewardsManagerDerivedState\n    function calculateRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external view override returns (uint256 rewards_) {\n\n        address ajnaPool      = stakes[tokenId_].ajnaPool;\n        uint256 lastBurnEpoch = stakes[tokenId_].lastInteractionBurnEpoch;\n        uint256 stakingEpoch  = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastBurnEpoch; epoch < epochToClaim_; ) {\n\n            rewards_ += _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            unchecked { ++epoch; }\n        }\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getStakeInfo(\n        uint256 tokenId_\n    ) external view override returns (address, address, uint256) {\n        return (\n            stakes[tokenId_].owner,\n            stakes[tokenId_].ajnaPool,\n            stakes[tokenId_].lastInteractionBurnEpoch);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked NFT.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_      ID of the staked LP NFT.\n     *  @param  epochToClaim_ The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch).\n     *  @return rewards_      Amount of rewards earned by the NFT.\n     */\n    function _calculateAndClaimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal returns (uint256 rewards_) {\n\n        address ajnaPool      = stakes[tokenId_].ajnaPool;\n        uint256 lastBurnEpoch = stakes[tokenId_].lastInteractionBurnEpoch;\n        uint256 stakingEpoch  = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastBurnEpoch; epoch < epochToClaim_; ) {\n\n            uint256 nextEpochRewards = _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            uint256 nextEpoch = epoch + 1;\n\n            // update epoch token claim trackers\n            rewardsClaimed[nextEpoch]           += nextEpochRewards;\n            isEpochClaimed[tokenId_][nextEpoch] = true;\n\n            rewards_ += nextEpochRewards;\n\n            unchecked { ++epoch; }\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked NFT in next epoch.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_         ID of the staked LP NFT.\n     *  @param  epoch_           The current epoch.\n     *  @param  stakingEpoch_    The epoch in which token was staked.\n     *  @param  ajnaPool_        Address of the pool.\n     *  @param  positionIndexes_ Bucket ids associated with NFT staked.\n     *  @return epochRewards_    Calculated rewards in epoch.\n     */\n    function _calculateNextEpochRewards(\n        uint256 tokenId_,\n        uint256 epoch_,\n        uint256 stakingEpoch_,\n        address ajnaPool_,\n        uint256[] memory positionIndexes_\n    ) internal view returns (uint256 epochRewards_) {\n\n        uint256 nextEpoch = epoch_ + 1;\n        uint256 claimedRewardsInNextEpoch = rewardsClaimed[nextEpoch];\n\n        // iterate through all buckets and calculate epoch rewards for\n        for (uint256 i = 0; i < positionIndexes_.length; ) {\n\n            uint256 bucketIndex = positionIndexes_[i];\n            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n\n            uint256 bucketRate;\n            if (epoch_ != stakingEpoch_) {\n\n                // if staked in a previous epoch then use the initial exchange rate of epoch\n                bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n            } else {\n\n                // if staked during the epoch then use the bucket rate at the time of staking\n                bucketRate = bucketSnapshot.rateAtStakeTime;\n            }\n\n            // calculate the amount of interest accrued in current epoch\n            uint256 interestEarned = _calculateExchangeRateInterestEarned(\n                ajnaPool_,\n                nextEpoch,\n                bucketIndex,\n                bucketSnapshot.lpsAtStakeTime,\n                bucketRate\n            );\n\n            // calculate and accumulate rewards if interest earned\n            if (interestEarned != 0) {\n                epochRewards_ += _calculateNewRewards(\n                    ajnaPool_,\n                    interestEarned,\n                    nextEpoch,\n                    epoch_,\n                    claimedRewardsInNextEpoch\n                );\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of interest that has accrued to a lender in a bucket based upon their LPs.\n     *  @param  pool_           Address of the pool whose exchange rates are being checked.\n     *  @param  nextEventEpoch_ The next event epoch to check the exchange rate for.\n     *  @param  bucketIndex_    Index of the bucket to check the exchange rate for.\n     *  @param  bucketLPs       Amount of LPs in bucket.\n     *  @param  exchangeRate_   Exchange rate in current epoch.\n     *  @return interestEarned_ The amount of interest accrued.\n     */\n    function _calculateExchangeRateInterestEarned(\n        address pool_,\n        uint256 nextEventEpoch_,\n        uint256 bucketIndex_,\n        uint256 bucketLPs,\n        uint256 exchangeRate_\n    ) internal view returns (uint256 interestEarned_) {\n\n        if (exchangeRate_ != 0) {\n\n            uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_];\n\n            // calculate interest earned only if next exchange rate is higher than current exchange rate\n            if (nextExchangeRate > exchangeRate_) {\n\n                // calculate the equivalent amount of quote tokens given the stakes lp balance,\n                // and the exchange rate at the next and current burn events\n                interestEarned_ = Maths.rayToWad(Maths.rmul(nextExchangeRate - exchangeRate_, bucketLPs));\n            }\n\n        }\n    }\n\n    /**\n     *  @notice Calculate new rewards between current and next epoch, based on earned interest.\n     *  @param  ajnaPool_       Address of the pool.\n     *  @param  interestEarned_ The amount of interest accrued to current epoch.\n     *  @param  nextEpoch_      The next burn event epoch to calculate new rewards.\n     *  @param  epoch_          The current burn event epoch to calculate new rewards.\n     *  @return newRewards_     New rewards between current and next burn event epoch.\n     */\n    function _calculateNewRewards(\n        address ajnaPool_,\n        uint256 interestEarned_,\n        uint256 nextEpoch_,\n        uint256 epoch_,\n        uint256 rewardsClaimedInEpoch_\n    ) internal view returns (uint256 newRewards_) {\n        (\n            ,\n            // total interest accumulated by the pool over the claim period\n            uint256 totalBurnedInPeriod,\n            // total tokens burned over the claim period\n            uint256 totalInterestEarnedInPeriod\n        ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);\n\n        // calculate rewards earned\n        newRewards_ = Maths.wmul(\n            REWARD_FACTOR,\n            Maths.wmul(\n                Maths.wdiv(interestEarned_, totalInterestEarnedInPeriod), totalBurnedInPeriod\n            )\n        );\n\n        uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n\n        // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n        if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n\n            // set claim reward to difference between cap and reward\n            newRewards_ = rewardsCapped - rewardsClaimedInEpoch_;\n        }\n    }\n\n    /**\n     *  @notice Claim rewards that have been accumulated by a staked NFT.\n     *  @param  tokenId_      ID of the staked LP NFT.\n     *  @param  epochToClaim_ The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch)\n     */\n    function _claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        address ajnaPool = stakeInfo.ajnaPool;\n\n        // update bucket exchange rates and claim associated rewards\n        uint256 rewardsEarned = _updateBucketExchangeRates(\n            ajnaPool,\n            positionManager.getPositionIndexes(tokenId_)\n        );\n\n        rewardsEarned += _calculateAndClaimRewards(tokenId_, epochToClaim_);\n\n        uint256[] memory burnEpochsClaimed = _getBurnEpochsClaimed(\n            stakeInfo.lastInteractionBurnEpoch,\n            epochToClaim_\n        );\n\n        emit ClaimRewards(\n            msg.sender,\n            ajnaPool,\n            tokenId_,\n            burnEpochsClaimed,\n            rewardsEarned\n        );\n\n        // update last interaction burn event\n        stakeInfo.lastInteractionBurnEpoch = uint96(epochToClaim_);\n\n        uint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));\n\n        if (rewardsEarned > ajnaBalance) rewardsEarned = ajnaBalance;\n\n        // transfer rewards to sender\n        IERC20(ajnaToken).safeTransfer(msg.sender, rewardsEarned);\n    }\n\n    /**\n     *  @notice Retrieve an array of burn epochs from which a depositor has claimed rewards.\n     *  @param  lastInteractionBurnEpoch_ The last burn period in which a depositor interacted with the rewards contract.\n     *  @param  burnEpochToStartClaim_    The most recent burn period from a depostor earned rewards.\n     *  @return burnEpochsClaimed_        Array of burn epochs from which a depositor has claimed rewards.\n     */\n    function _getBurnEpochsClaimed(\n        uint256 lastInteractionBurnEpoch_,\n        uint256 burnEpochToStartClaim_\n    ) internal pure returns (uint256[] memory burnEpochsClaimed_) {\n        uint256 numEpochsClaimed = burnEpochToStartClaim_ - lastInteractionBurnEpoch_;\n\n        burnEpochsClaimed_ = new uint256[](numEpochsClaimed);\n\n        uint256 i;\n        uint256 claimEpoch = lastInteractionBurnEpoch_ + 1;\n        while (claimEpoch <= burnEpochToStartClaim_) {\n            burnEpochsClaimed_[i] = claimEpoch;\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked {\n                ++i;\n                ++claimEpoch;\n            }\n        }\n    }\n\n    /**\n     *  @notice Retrieve the total ajna tokens burned and total interest earned by a pool since a given block.\n     *  @param  pool_                  Address of the Ajna pool to retrieve accumulators of.\n     *  @param  currentBurnEventEpoch_ The latest burn event.\n     *  @param  lastBurnEventEpoch_    The burn event to use as checkpoint since which values have accumulated.\n     *  @return Timestamp of the latest burn event.\n     *  @return Total ajna tokens burned by the pool since the last burn event.\n     *  @return Total interest earned by the pool since the last burn event.\n     */\n    function _getPoolAccumulators(\n        address pool_,\n        uint256 currentBurnEventEpoch_,\n        uint256 lastBurnEventEpoch_\n    ) internal view returns (uint256, uint256, uint256) {\n        (\n            uint256 currentBurnTime,\n            uint256 totalInterestLatest,\n            uint256 totalBurnedLatest\n        ) = IPool(pool_).burnInfo(currentBurnEventEpoch_);\n\n        (\n            ,\n            uint256 totalInterestAtBlock,\n            uint256 totalBurnedAtBlock\n        ) = IPool(pool_).burnInfo(lastBurnEventEpoch_);\n\n        uint256 totalBurned   = totalBurnedLatest   != 0 ? totalBurnedLatest   - totalBurnedAtBlock   : totalBurnedAtBlock;\n        uint256 totalInterest = totalInterestLatest != 0 ? totalInterestLatest - totalInterestAtBlock : totalInterestAtBlock;\n\n        return (\n            currentBurnTime,\n            totalBurned,\n            totalInterest\n        );\n\n    }\n\n    /**\n     *  @notice Update the exchange rate of a list of buckets.\n     *  @dev    Called as part of stakeToken, unstakeToken, and claimRewards, as well as updateBucketExchangeRatesAndClaim.\n     *  @dev    Caller can claim 5% of the rewards that have accumulated to each bucket since the last burn event, if it hasn't already been updated.\n     *  @param  pool_    Address of the pool whose exchange rates are being updated.\n     *  @param  indexes_ List of bucket indexes to be updated.\n     */\n    function _updateBucketExchangeRates(\n        address pool_,\n        uint256[] memory indexes_\n    ) internal returns (uint256 updatedRewards_) {\n        // get the current burn epoch from the given pool\n        uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();\n\n        // update exchange rates only if the pool has not yet burned any tokens without calculating any reward\n        if (curBurnEpoch == 0) {\n            for (uint256 i = 0; i < indexes_.length; ) {\n\n                _updateBucketExchangeRate(\n                    pool_,\n                    indexes_[i],\n                    curBurnEpoch\n                );\n\n                // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                unchecked { ++i; }\n            }\n        }\n\n        else {\n            // retrieve accumulator values used to calculate rewards accrued\n            (\n                uint256 curBurnTime,\n                uint256 totalBurned,\n                uint256 totalInterestEarned\n            ) = _getPoolAccumulators(pool_, curBurnEpoch, curBurnEpoch - 1);\n\n            if (block.timestamp <= curBurnTime + UPDATE_PERIOD) {\n\n                // update exchange rates and calculate rewards if tokens were burned and within allowed time period\n                for (uint256 i = 0; i < indexes_.length; ) {\n\n                    // calculate rewards earned for updating bucket exchange rate\n                    updatedRewards_ += _updateBucketExchangeRateAndCalculateRewards(\n                        pool_,\n                        indexes_[i],\n                        curBurnEpoch,\n                        totalBurned,\n                        totalInterestEarned\n                    );\n\n                    // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                    unchecked { ++i; }\n                }\n\n                uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned);\n                uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];\n\n                // update total tokens claimed for updating bucket exchange rates tracker\n                if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) {\n                    // if update reward is greater than cap, set to remaining difference\n                    updatedRewards_ = rewardsCap - rewardsClaimedInEpoch;\n                }\n\n                // accumulate the full amount of additional rewards\n                updateRewardsClaimed[curBurnEpoch] += updatedRewards_;\n            }\n        }\n\n        // emit event with the list of bucket indexes updated\n        emit UpdateExchangeRates(msg.sender, pool_, indexes_, updatedRewards_);\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket.\n     *  @param  pool_        Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_ Bucket index to update exchange rate.\n     *  @param  burnEpoch_   Current burn epoch of the pool.\n     */\n    function _updateBucketExchangeRate(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_\n    ) internal {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n        }\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket and calculate rewards based on prev exchange rate.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_    Bucket index to update exchange rate.\n     *  @param  burnEpoch_      Current burn epoch of the pool.\n     *  @param  totalBurned_    Total Ajna tokens burned in pool.\n     *  @param  interestEarned_ Total interest rate earned in pool.\n     */\n    function _updateBucketExchangeRateAndCalculateRewards(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_,\n        uint256 totalBurned_,\n        uint256 interestEarned_\n    ) internal returns (uint256 rewards_) {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n\n            // retrieve the bucket exchange rate at the previous epoch\n            uint256 prevBucketExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_ - 1];\n\n            // skip reward calculation if update at the previous epoch was missed\n            // prevents excess rewards from being provided from using a 0 value as an input to the interestFactor calculation below.\n            if (prevBucketExchangeRate != 0) {\n\n                // retrieve current deposit of the bucket\n                (, , , uint256 bucketDeposit, ) = IPool(pool_).bucketInfo(bucketIndex_);\n\n                uint256 burnFactor     = Maths.wmul(totalBurned_, bucketDeposit);\n                uint256 interestFactor = Maths.wdiv(\n                    Maths.WAD - Maths.wdiv(prevBucketExchangeRate, curBucketExchangeRate),\n                    interestEarned_\n                );\n\n                // calculate rewards earned for updating bucket exchange rate \n                rewards_ += Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wmul(burnFactor, interestFactor));\n            }\n        }\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /** @notice Implementing this method allows contracts to receive ERC721 tokens\n     *  @dev https://forum.openzeppelin.com/t/erc721holder-ierc721receiver-and-onerc721received/11828\n     */\n    function onERC721Received(address, address, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n}"
    },
    {
      "filename": "contracts/src/RewardsManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IERC20 }    from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { SafeERC20 } from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport { IERC721 }   from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\nimport { IPool }            from './interfaces/pool/IPool.sol';\nimport { IPositionManager } from './interfaces/position/IPositionManager.sol';\n\nimport { PositionManager }  from './PositionManager.sol';\n\nimport {\n    IRewardsManager,\n    IRewardsManagerOwnerActions,\n    IRewardsManagerState,\n    IRewardsManagerDerivedState\n} from './interfaces/rewards/IRewardsManager.sol';\n\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n\nimport { Maths } from './libraries/internal/Maths.sol';\n\n/**\n *  @title  Rewards (staking) Manager contract\n *  @notice Pool lenders can optionally mint NFT that represents their positions.\n *          The Rewards contract allows pool lenders with positions NFT to stake and earn AJNA tokens. \n *          Lenders with NFTs can:\n *          - stake token\n *          - update bucket exchange rate and earn rewards\n *          - claim rewards\n *          - unstake token\n */\ncontract RewardsManager is IRewardsManager {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as Ajna token lp nft rewards.\n     */\n    uint256 internal constant REWARD_CAP = 0.8 * 1e18;\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as Ajna token update rewards.\n     */\n    uint256 internal constant UPDATE_CAP = 0.1 * 1e18;\n    /**\n     * @notice Reward factor by which to scale the total rewards earned.\n     * @dev ensures that rewards issued to staked lenders in a given pool are less than the ajna tokens burned in that pool.\n     */\n    uint256 internal constant REWARD_FACTOR = 0.5 * 1e18;\n    /**\n     * @notice Reward factor by which to scale rewards earned for updating a buckets exchange rate.\n     */\n    uint256 internal UPDATE_CLAIM_REWARD = 0.05 * 1e18;\n    /**\n     * @notice Time period after a burn event in which buckets exchange rates can be updated.\n     */\n    uint256 internal constant UPDATE_PERIOD = 2 weeks;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;       // tokenID => epoch => bool has claimed\n    mapping(uint256 => uint256)                  public override rewardsClaimed;       // epoch => tokens claimed\n    mapping(uint256 => uint256)                  public override updateRewardsClaimed; // epoch => tokens claimed\n\n    // Mapping of per pool bucket exchange rates at a given burn event.\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal bucketExchangeRates; // poolAddress => bucketIndex => epoch => bucket exchange rate\n\n    mapping(uint256 => StakeInfo) internal stakes;  // tokenID => Stake info\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    address          public immutable ajnaToken;       // address of the AJNA token\n    IPositionManager public immutable positionManager; // The PositionManager contract\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(address ajnaToken_, IPositionManager positionManager_) {\n        ajnaToken = ajnaToken_;\n        positionManager = positionManager_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev revert on:\n     *          - not owner NotOwnerOfDeposit()\n     *          - already claimed AlreadyClaimed()\n     *  @dev emit events:\n     *          - ClaimRewards\n     */\n    function claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external override {\n        if (msg.sender != stakes[tokenId_].owner) revert NotOwnerOfDeposit();\n\n        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n\n        _claimRewards(tokenId_, epochToClaim_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev revert on:\n     *          - not owner NotOwnerOfDeposit()\n     *  @dev emit events:\n     *          - Stake\n     */\n    function stake(\n        uint256 tokenId_\n    ) external override {\n        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);\n\n        // check that msg.sender is owner of tokenId\n        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();\n\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n        stakeInfo.owner    = msg.sender;\n        stakeInfo.ajnaPool = ajnaPool;\n\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // record the staking epoch\n        stakeInfo.stakingEpoch = uint96(curBurnEpoch);\n\n        // initialize last time interaction at staking epoch\n        stakeInfo.lastInteractionBurnEpoch = uint96(curBurnEpoch);\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        for (uint256 i = 0; i < positionIndexes.length"
    }
  ]
}