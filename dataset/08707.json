{
  "Title": "[L-05] Unchecked return value of transferFrom can allow a user to withdraw native token for free",
  "Content": "\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L20\n\nThe Withdrawer contract has a function withdraw() which calls an unsafe transferFrom(). A call to transferFrom is frequently done without checking the results.\nFor certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \"false\" is returned.\nAs explained in https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call\n\nAnd in this function case, if the weth.transferFrom() returns false, it would continue the call to withdraw token from the contract and send it to the caller. Thus a user could withdraw free tokens, and eventually some users will be unable to withdraw their tokens.\n\n### Proof of Concept\n\nhttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/Withdrawer.sol#L26\n\n- Alice calls Withdrawer.withdraw() with 100 as input.\n- Assume weth.transferFrom() fails, returns false but does not revert.\n- weth.withdraw() will run since there was no revert.\n- Alice receives 100 eth for free.\n- This may be possible in a direct call by Alice or a call from\n\nYearnCurveVaultOperator contract in\nhttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L81\n\n### Recommended Mitigation Steps\n\nCheck the result of transferFrom and transfer. Or making use of SafeERC20 library: safeTransfer and safeTransferFrom would be recommended.\n\n## Non-Critical Issue Summary\n\n**[N-01] Missing checks for `address(0x0)` when assigning values to address state variables**<br>\n**[N-02] Adding a return statement when the function defines a named return variable, is redundant**<br>\n**[N-03] Public functions not called by the contract should be declared external instead**<br>\n**[N-04] NatSpec is incomplete**<br>\n**[N-05] Event is missing indexed fields**<br>\n**[N-06] Typos**<br>\n**[N-07] Lack of Event Emission For Critical Functions**<br>\n**[N-08] Too Recent of a Pragma**<br>\n**[N-09] Missing selector check on operator**<br>\n**[N-10] Unused imports**<br>\n**[N-11] Change your imports**<br>\n**[N-12] Add `namesLength > 0` check in `areOperatorsImported()` method**<br>\n**[N-13] Libraries, interfaces, and external imports can be ordered nicely**<br>\n**[N-14] Consider checking the recipient address for existence before making the call**<br>\n**[N-15] Consider using IERC20 type instead of address.**<br>\n**[N-16] setMaxAllowance should be called in the constructor**<br>\n**[N-17] Naming inconsistency - some arguments have `_` at their prefixes but others do not at NestedFactory.sol**<br>\n**[N-18] Use either `_msgSender()` or `msg.sender`**<br>\n**[N-19] `OwnerProxy` can call `selfdestruct()`**<br>\n**[N-20] A magic number should be documented and explained. Use a constant instead**<br>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-06-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/governance/OwnerProxy.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Owner proxy to run atomic actions.\n/// @notice DSProxy-like contract without a cache to simply run\n///         a sequence of atomic actions.\ncontract OwnerProxy is Ownable {\n    /// @notice Execute atomic actions. Only the owner can call this function (e.g. the timelock)\n    /// @param _target Address of the \"script\" to perform a delegatecall\n    /// @param _data The bytes calldata\n    /// @return response The delegatecall response\n    /// @dev Fork from https://github.com/dapphub/ds-proxy/blob/e17a2526ad5c9877ba925ff25c1119f519b7369b/src/proxy.sol#L53\n    /// @dev bytes4 selector must be included in the calldata (_data)\n    function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n        require(_target != address(0), \"OP: INVALID_TARGET\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n            let size := returndatasize()\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                revert(add(response, 0x20), size)\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Withdrawer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./interfaces/external/IWETH.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Native token withdrawer\n/// @dev Withdraw native token from the wrapper contract on behalf\n///      of the sender. Upgradeable proxy contracts are not able to receive\n///      native tokens from contracts via `transfer` (EIP1884), they need a\n///      middleman forwarding all available gas and reverting on errors.\ncontract Withdrawer is ReentrancyGuard {\n    IWETH public immutable weth;\n\n    constructor(IWETH _weth) {\n        weth = _weth;\n    }\n\n    receive() external payable {\n        require(msg.sender == address(weth), \"WD: ETH_SENDER_NOT_WETH\");\n    }\n\n    /// @notice Withdraw native token from wrapper contract\n    /// @param amount The amount to withdraw\n    function withdraw(uint256 amount) external nonReentrant {\n        weth.transferFrom(msg.sender, address(this), amount);\n        weth.withdraw(amount);\n        Address.sendValue(payable(msg.sender), amount);\n    }\n}"
    },
    {
      "filename": "contracts/operators/Yearn/YearnCurveVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../../Withdrawer.sol\";\nimport \"./YearnVaultStorage.sol\";\n\nimport \"./../../libraries/OperatorHelpers.sol\";\nimport \"./../../libraries/ExchangeHelpers.sol\";\nimport \"./../../interfaces/external/IWETH.sol\";\nimport \"../../libraries/StakingLPVaultHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"./../../interfaces/external/IStakingVault/IYearnVault.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\n/// @title Yearn Curve Vault Operator\n/// @notice Deposit/Withdraw in a Yearn Curve vault.\ncontract YearnCurveVaultOperator {\n    YearnVaultStorage public immutable operatorStorage;\n\n    /// @dev ETH address\n    address public immutable eth;\n\n    /// @dev WETH contract\n    IWETH private immutable weth;\n\n    /// @dev Withdrawer\n    Withdrawer private immutable withdrawer;\n\n    constructor(\n        address[] memory vaults,\n        CurvePool[] memory pools,\n        Withdrawer _withdrawer,\n        address _eth,\n        address _weth\n    ) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == pools.length, \"YCVO: INVALID_VAULTS_LENGTH\");\n        operatorStorage = new YearnVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], pools[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n\n        eth = _eth;\n        weth = IWETH(_weth);\n        withdrawer = _withdrawer;\n    }\n\n    /// @notice Add liquidity in a Curve pool that includes ETH,\n    ///         deposit the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function depositETH(\n        address vault,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 ethBalanceBefore = weth.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n\n        // withdraw ETH from WETH\n        withdrawer.withdraw(amount);\n\n        StakingLPVaultHelpers._addLiquidityAndDepositETH(\n            vault,\n            ICurvePoolETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(address(weth)),\n            ethBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Add liquidity in a Curve pool, deposit\n    ///         the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param token The token to add liquidity\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        address token,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = IERC20(token).balanceOf(address(this));\n\n        StakingLPVaultHelpers._addLiquidityAndDeposit(\n            vault,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            token,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(token),\n            tokenBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove ETH liquidity from the Curve pool\n    ///         and receive one of the curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdrawETH(\n        address vault,\n        uint256 amount,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = weth.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            IERC20(address(weth)),\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using int128 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw128(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using uint256 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw256(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity256(\n            vault,\n            amount,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n}"
    }
  ]
}