{
  "Title": "[M-05] Auction payout goes to `AuctionDemo` contract owner, not the token owner",
  "Content": "\nAt the end of an auction in `AuctionDemo`, the highest bidder claims the token, which transfers the token from the token owner to the auction winner. In the same transaction, the token owner should receive the auction payout.\n\nHowever, the function `AuctionDemo::claimAuction()` sends the payout to the `AuctionDemo` contract owner.\n\nThis behavior deviates from the listed [invariant](https://github.com/code-423n4/2023-10-nextgen/tree/main?tab=readme-ov-file#main-invariants):\n\n\n> The highest bidder will receive the token after an auction finishes, the owner of the token will receive the funds and all other participants will get refunded.\n\n1. Auction is started, Alice deployed the `AuctionDemo` contract and Cecilia approved the `AuctionDemo` contract to transfer her tokens to the winning bidder.\n2. Auction is completed. The highest bid was Bob.\n3. Bob claims his winnings. The token is transferred from Cecilia to Bob. The bid from Bob is sent to Alice and Cecilia gets nothing.\n\n### Impact\n\nAny auction executed through `AuctionDemo` will have proceeds sent to the `AuctionDemo` contract owner, not the token owner. The token owner is left without auction proceeds.\n\n### PoC\n\n```javascript\ncontext(\"Auction Sends proceeds to owner of auctiondemo, not the token owner\", () => {\n    it.only(\"should execute\", async () => {\n    const tokenOwner = signers.addr2;\n    const nextGenOwner = signers.owner;\n    const highestBidder = signers.addr3;\n\n    // Auction contract and collections Setup\n    const AuctionDemo = await ethers.getContractFactory(\"auctionDemo\");\n    let auctionDemo = await AuctionDemo.deploy(\n        await contracts.hhMinter.getAddress(),\n        await contracts.hhCore.getAddress(),\n        await contracts.hhAdmin.getAddress()\n    );\n    timestamp = (await ethers.provider.getBlock(await ethers.provider.getBlockNumber())).timestamp;\n\n    await contracts.hhCore.addMinterContract(contracts.hhMinter.getAddress());\n    await contracts.hhCore.createCollection(\n        \"Test Collection 1\",\n        \"Artist 1\",\n        \"For testing\",\n        \"www.test.com\",\n        \"CCO\",\n        \"https://ipfs.io/ipfs/hash/\",\n        \"\",\n        [\"desc\"],\n    );\n    await contracts.hhCore.addRandomizer(1, contracts.hhRandomizer.getAddress());\n    await contracts.hhCore.connect(signers.owner).setCollectionData(1, signers.addr1.getAddress(), 100, 200, timestamp + 250);\n\n    await contracts.hhMinter.setCollectionCosts(1, ethers.parseEther('.1'), ethers.parseEther('.1'), 0, 100, 0, signers.addr1.getAddress())\n    await contracts.hhMinter.setCollectionPhases(1, timestamp + 25, timestamp + 50, timestamp + 100, timestamp + 150, '0x0000000000000000000000000000000000000000000000000000000000000000')\n\n    await ethers.provider.send(\"evm_increaseTime\", [20]);\n    await contracts.hhMinter.connect(nextGenOwner).mintAndAuction(tokenOwner.getAddress(), \"Test Auction 1\", 10, 1, timestamp + 100);\n\n    id1 = 10000000000;\n    await contracts.hhCore.connect(tokenOwner).approve(auctionDemo.getAddress(), id1);\n\n    // Winning auction bid\n    await auctionDemo.connect(highestBidder).participateToAuction(id1, { value: ethers.parseEther('2') });\n\n    // Move past auction end time and claim token\n    await ethers.provider.send(\"evm_setNextBlockTimestamp\", [timestamp + 101]);\n    const transaction = auctionDemo.connect(highestBidder).claimAuction(id1);\n\n    // get owner of auditDemo contract and make sure it's not the token owner for this usecase\n    let owner = await auctionDemo.connect(nextGenOwner).owner();\n    expect(owner).to.not.equal(tokenOwner.getAddress());\n\n    // NextGen owner receives proceeds, token owner receives nothing.\n    await expect(() => transaction).to.changeEtherBalance(nextGenOwner, ethers.parseEther('2'));\n    await expect(() => transaction).to.changeEtherBalance(tokenOwner, 0);\n    expect(await contracts.hhCore.ownerOf(id1)).to.eq(await highestBidder.getAddress());\n    });\n});\n```\n\n### Recommendations\n\nSend the auction proceeds to `ownerOfToken` instead of [owner](https://github.com/code-423n4/2023-10-nextgen/blob/main/hardhat/smart-contracts/AuctionDemo.sol#L113).\n\n[AuctionDemo L113-L114](https://github.com/code-423n4/2023-10-nextgen/blob/main/hardhat/smart-contracts/AuctionDemo.sol#L113-L114)\n\n```diff\n@@ -110,8 +110,8 @@ contract auctionDemo is Ownable {\nfor (uint256 i=0; i< auctionInfoData[_tokenid].length; i ++) {\n    if (auctionInfoData[_tokenid][i].bidder == highestBidder && auctionInfoData[_tokenid][i].bid == highestBid && 112| auctionInfoData[_tokenid][i].status == true) {\n        IERC721(gencore).safeTransferFrom(ownerOfToken, highestBidder, _tokenid);\n-       (bool success, ) = payable(owner()).call{value: highestBid}(\"\");\n-       emit ClaimAuction(owner(), _tokenid, success, highestBid);\n+       (bool success, ) = payable(ownerOfToken).call{value: highestBid}(\"\");\n+       emit ClaimAuction(ownerOfToken, _tokenid, success, highestBid);\n```\n\n### Assessed type\n\nETH-Transfer\n\n**[a2rocket (NextGen) confirmed and commented via duplicate issue #245](https://github.com/code-423n4/2023-10-nextgen-findings/issues/245#issuecomment-1822700002):**\n> The `mintAndAuction` function can only be called by trusted parties. The `_recipient` of that function will be a trusted wallet that will also call `setApprovalForAll()` from the Core contract for the Auction Contract. In our case, the `_recipient` will be the deployer of the Auction contract; at the end of the day, the token owner and auction owner are the same person.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/971#issuecomment-1847923059):**\n > After re-visiting, I consider this submission to be better than [#738](https://github.com/code-423n4/2023-10-nextgen-findings/issues/738) because it also correctly specifies that the `event` should be fixed rather than just the statement. While I cannot penalize submissions for not including the `event` in their proposed remediations, I can mark a submission that cites it and is of equivalent quality as \"best\".\n\n**[MrPotatoMagic (warden) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/971#issuecomment-1848601608):**\n > @0xsomeone, here is why I believe this issue is QA at most:\n> \n> 1. As per the sponsors comments [here](https://github.com/code-423n4/2023-10-nextgen-findings/issues/245#issuecomment-1822700002), the owner of the auction contract and the owner of the token are trusted team's address. This means that whether the funds are sent to either, they are not lost, just that the team needs to make an additional fund transfer on their end (if needed).\n> 2. Although the invariant is broken, it has no impact on the functioning of the protocol.\n> Due to this, I believe the severity should be QA at most.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/971#issuecomment-1848645800):**\n > @MrPotatoMagic, thanks for contributing! The code goes against its specification and breaks an invariant of the protocol. Regardless of severity, an invariant being broken will always be considered a medium-risk issue given that it relates to pivotal functionality in the system being incorrect.\n> \n> In this case, funds are sent to a NextGen address rather than a collection-affiliated address or secondary smart contract meant to facilitate fund disbursements. This has implications tax-wise, implications about trust (i.e. if a 10m auction is held, the stakes of trust are increased significantly), and other such problems. Logistically, it is also a heavy burden to manage multiple auction payments at once, prove which source sent which, and so on.\n> \n> Combining the above with the fact that **a clear invariant of the protocol is broken**, I will maintain the medium-risk rating.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "hardhat/smart-contracts/AuctionDemo.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: Auction Demo Contract\n *  @date: 26-October-2023 \n *  @version: 1.2\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./IMinterContract.sol\";\nimport \"./IERC721.sol\";\nimport \"./Ownable.sol\";\nimport \"./INextGenAdmins.sol\";\n\ncontract auctionDemo is Ownable {\n\n    //events \n\n    event ClaimAuction(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event Refund(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event CancelBid(address indexed _add, uint256 indexed tokenid, uint256 index, bool status, uint256 indexed funds);\n\n    IMinterContract public minter;\n    INextGenAdmins public adminsContract;\n    address gencore;\n\n    // certain functions can only be called by auction winner or admin\n    modifier WinnerOrAdminRequired(uint256 _tokenId, bytes4 _selector) {\n      require(msg.sender == returnHighestBidder(_tokenId) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    constructor (address _minter, address _gencore, address _adminsContract) public {\n        minter = IMinterContract(_minter);\n        gencore = _gencore;\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // auction Bidders\n    struct auctionInfoStru {\n        address bidder;\n        uint256 bid;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => auctionInfoStru[]) public auctionInfoData;\n\n    // claim auctioned\n    mapping (uint256 => bool) public auctionClaim;\n\n    // participate to auction\n\n    function participateToAuction(uint256 _tokenid) public payable {\n        require(msg.value > returnHighestBid(_tokenid) && block.timestamp <= minter.getAuctionEndTime(_tokenid) && minter.getAuctionStatus(_tokenid) == true);\n        auctionInfoStru memory newBid = auctionInfoStru(msg.sender, msg.value, true);\n        auctionInfoData[_tokenid].push(newBid);\n    }\n\n    // get highest bid\n\n    function returnHighestBid(uint256 _tokenid) public view returns (uint256) {\n        uint256 index;\n        if (auctionInfoData[_tokenid].length > 0) {\n            uint256 highBid = 0;\n            for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n                if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                    highBid = auctionInfoData[_tokenid][i].bid;\n                    index = i;\n                }\n            }\n            if (auctionInfoData[_tokenid][index].status == true) {\n                return highBid;\n            } else {\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    // get highest bidder\n\n    function returnHighestBidder(uint256 _tokenid) public view returns (address) {\n        uint256 highBid = 0;\n        uint256 index;\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                index = i;\n            }\n        }\n        if (auctionInfoData[_tokenid][index].status == true) {\n                return auctionInfoData[_tokenid][index].bidder;\n            } else {\n                revert(\"No Active Bidder\");\n        }\n    }\n\n    // claim Token After Auction\n\n    function claimAuction(uint256 _tokenid) public WinnerOrAdminRequired(_tokenid,this.claimAuction.selector){\n        require(block.timestamp >= minter.getAuctionEndTime(_tokenid) && auctionClaim[_tokenid] == false && minter.getAuctionStatus(_tokenid) == true);\n        auctionClaim[_tokenid] = true;\n        uint256 highestBid = returnHighestBid(_tokenid);\n        address ownerOfToken = IERC721(gencore).ownerOf(_tokenid);\n        address highestBidder = returnHighestBidder(_tokenid);\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i ++) {\n            if (auctionInfoData[_tokenid][i].bidder == highestBidder && auctionInfoData[_tokenid][i].bid == highestBid && auctionInfoData[_tokenid][i].status == true) {\n                IERC721(gencore).safeTransferFrom(ownerOfToken, highestBidder, _tokenid);\n                (bool success, ) = payable(owner()).call{value: highestBid}(\"\");\n                emit ClaimAuction(owner(), _tokenid, success, highestBid);\n            } else if (auctionInfoData[_tokenid][i].status == true) {\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit Refund(auctionInfoData[_tokenid][i].bidder, _tokenid, success, highestBid);\n            } else {}\n        }\n    }\n\n    // cancel a single Bid\n\n    function cancelBid(uint256 _tokenid, uint256 index) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        require(auctionInfoData[_tokenid][index].bidder == msg.sender && auctionInfoData[_tokenid][index].status == true);\n        auctionInfoData[_tokenid][index].status = false;\n        (bool success, ) = payable(auctionInfoData[_tokenid][index].bidder).call{value: auctionInfoData[_tokenid][index].bid}(\"\");\n        emit CancelBid(msg.sender, _tokenid, index, success, auctionInfoData[_tokenid][index].bid);\n    }\n\n    // cancel All Bids\n\n    function cancelAllBids(uint256 _tokenid) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        for (uint256 i=0; i<auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bidder == msg.sender && auctionInfoData[_tokenid][i].status == true) {\n                auctionInfoData[_tokenid][i].status = false;\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit CancelBid(msg.sender, _tokenid, i, success, auctionInfoData[_tokenid][i].bid);\n            } else {}\n        }\n    }\n\n    // return Bids\n\n    function returnBids(uint256 _tokenid) public view returns(auctionInfoStru[] memory) {\n        return auctionInfoData[_tokenid];\n    }\n\n}"
    },
    {
      "filename": "hardhat/smart-contracts/AuctionDemo.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: Auction Demo Contract\n *  @date: 26-October-2023 \n *  @version: 1.2\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./IMinterContract.sol\";\nimport \"./IERC721.sol\";\nimport \"./Ownable.sol\";\nimport \"./INextGenAdmins.sol\";\n\ncontract auctionDemo is Ownable {\n\n    //events \n\n    event ClaimAuction(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event Refund(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event CancelBid(address indexed _add, uint256 indexed tokenid, uint256 index, bool status, uint256 indexed funds);\n\n    IMinterContract public minter;\n    INextGenAdmins public adminsContract;\n    address gencore;\n\n    // certain functions can only be called by auction winner or admin\n    modifier WinnerOrAdminRequired(uint256 _tokenId, bytes4 _selector) {\n      require(msg.sender == returnHighestBidder(_tokenId) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    constructor (address _minter, address _gencore, address _adminsContract) public {\n        minter = IMinterContract(_minter);\n        gencore = _gencore;\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // auction Bidders\n    struct auctionInfoStru {\n        address bidder;\n        uint256 bid;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => auctionInfoStru[]) public auctionInfoData;\n\n    // claim auctioned\n    mapping (uint256 => bool) public auctionClaim;\n\n    // participate to auction\n\n    function participateToAuction(uint256 _tokenid) public payable {\n        require(msg.value > returnHighestBid(_tokenid) && block.timestamp <= minter.getAuctionEndTime(_tokenid) && minter.getAuctionStatus(_tokenid) == true);\n        auctionInfoStru memory newBid = auctionInfoStru(msg.sender, msg.value, true);\n        auctionInfoData[_tokenid].push(newBid);\n    }\n\n    // get highest bid\n\n    function returnHighestBid(uint256 _tokenid) public view returns (uint256) {\n        uint256 index;\n        if (auctionInfoData[_tokenid].length > 0) {\n            uint256 highBid = 0;\n            for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n                if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                    highBid = auctionInfoData[_tokenid][i].bid;\n                    index = i;\n                }\n            }\n            if (auctionInfoData[_tokenid][index].status == true) {\n                return highBid;\n            } else {\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    // get highest bidder\n\n    function returnHighestBidder(uint256 _tokenid) public view returns (address) {\n        uint256 highBid = 0;\n        uint256 index;\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                index = i;\n            }\n        }\n        if (auctionInfoData[_tokenid][index].status == true) {\n                return auctionInfoData[_tokenid][index].bidder;\n            } else {\n                revert(\"No Active Bidder\");\n        }\n    }\n\n    // claim Token After Auction\n\n    function claimAuction(uint256 _tokenid) public WinnerOrAdminRequired(_tokenid,this.claimAuction.selector){\n        require(block.timestamp >= minter.getAuctionEndTime(_tokenid) && auctionClaim[_tokenid] == false && minter.getAuctionStatus(_tokenid) == true);\n        auctionClaim[_tokenid] = true;\n        uint256 highestBid = returnHighestBid(_tokenid);\n        address ownerOfToken = IERC721(gencore).ownerOf(_tokenid);\n        address highestBidder = returnHighestBidder(_tokenid);\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i ++) {\n            if (auctionInfoData[_tokenid][i].bidder == highestBidder && auctionInfoData[_tokenid][i].bid == highestBid && auctionInfoData[_tokenid][i].status == true) {\n                IERC721(gencore).safeTransferFrom(ownerOfToken, highestBidder, _tokenid);\n                (bool success, ) = payable(owner()).call{value: highestBid}(\"\");\n                emit ClaimAuction(owner(), _tokenid, success, highestBid);\n            } else if (auctionInfoData[_tokenid][i].status == true) {\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit Refund(auctionInfoData[_tokenid][i].bidder, _tokenid, success, highestBid);\n            } else {}\n        }\n    }\n\n    // cancel a single Bid\n\n    function cancelBid(uint256 _tokenid, uint256 index) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        require(auctionInfoData[_tokenid][index].bidder == msg.sender && auctionInfoData[_tokenid][index].status == true);\n        auctionInfoData[_tokenid][index].status = false;\n        (bool success, ) = payable(auctionInfoData[_tokenid][index].bidder).call{value: auctionInfoData[_tokenid][index].bid}(\"\");\n        emit CancelBid(msg.sender, _tokenid, index, success, auctionInfoData[_tokenid][index].bid);\n    }\n\n    // cancel All Bids\n\n    function cancelAllBids(uint256 _tokenid) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        for (uint256 i=0; i<auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bidder == msg.sender && auctionInfoData[_tokenid][i].status == true) {\n                auctionInfoData[_tokenid][i].status = false;\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit CancelBid(msg.sender, _tokenid, i, success, auctionInfoData[_tokenid][i].bid);\n            } else {}\n        }\n    }\n\n    // return Bids\n\n    function returnBids(uint256 _tokenid) public view returns(auctionInfoStru[] memory) {\n        return auctionInfoData[_tokenid];\n    }\n\n}"
    }
  ]
}