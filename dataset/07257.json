{
  "Title": "[H-11] Malicious strategist could deny borrowers from repaying loan and force liquidation by setting a extremely high vault fee",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L605><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/test/TestHelpers.t.sol#L471>\n\n**Issue:** A malicious strategist can deny the repayment of loans by setting a extremely high vault fee during creation of a public vault. The high vault fee will cause a revert due to a failed integer conversion using SafeCastTo88(). This will lead to forced liquidation of the borrowers when the loans expire outstanding, making them lose their NFT collaterals. (Vault fee is an incentive awarded to strategist on each loan repayment,  where a percentage of the interest payment is allocated to the strategist, in terms of vault shares.)\n\n**High Likelihood:** The strategist could target borrowers by refinancing outstanding loans and transfering the loans to his high fee vault, which does not require the borrowers' consents. This can be achieved as refinancing can be done by anyone and the logic only checks for better interest rate and duration, but not the vault fee. The borrowers will not be aware of the issue, until they attempt to repay the loan. Furthermore, the strategist could specifically target loans that are about to expire, giving little reaction time for borrowers to report the issue.\n\n**Financial gain:** With the ability to force a liquidation, the strategist can possibly stand to gain financially (e.g. by refinancing the loans with a lower liquidationInitialAsk and then bid for the NFT collateral (with high gas fee) during liquidation.\n\nNote: Even if there are no lenders willing to lend to the vault due to the high vault fee, the strategist still can lend to its own vault to faciliate the refinance.\n\n### Proof of Concept\n\nThe bug can be replicated by changing the test case. Set vaultFee parameter to a high value (e.g. 1e13) as shown below in the file /src/test/TestHelpers.t.sol.  Then run testBasicPublicVaultLoan() in AsteriaTest.t.sol. In this test case, we will see that the strategist could create a public vault with a high vaultFee as there is no validation check for it. And any borrower could still proceed to deposit their collateral and take loan without any issues as the vaultFee is only accessed upon loan repayment.\n\n    function _createPublicVault(\n    \taddress strategist,\n    \taddress delegate,\n    \tuint256 epochLength\n    ) internal returns (address publicVault) {\n    \tvm.startPrank(strategist);\n    \t//bps\n    \tpublicVault = ASTARIA_ROUTER.newPublicVault(\n    \t\tepochLength,\n    \t\tdelegate,\n    \t\taddress(WETH9),\n    \t\t\t//uint256(0)\n    \t\t\tuint256(1e13),              //to replicate the bug, change vaultFee parameter from 0 to a high value like 1e13   \n    \t\tfalse,\n    \t\tnew address[](0),\n    \t\tuint256(0)\n    \t);\n    \tvm.stopPrank();\n    }\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/test/TestHelpers.t.sol#L471><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/test/AstariaTest.t.sol#L90>\n\nHowever, when the borrower attempts to repay the loan, it will revert due to a failed integer conversion. As the fee is too high, convertToShare() will return a value that exceeds 88-bit, causing the safeCastTo88() in \\_handleStrategistInterestReward() to fail.\n\n      uint88 feeInShares = convertToShares(fee).safeCastTo88();\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L605>\n\n### Recommended Mitigation Steps\n\nCheck that the vaultFee is within a reasonable range during vault creation.\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#378`](https://github.com/code-423n4/2023-01-astaria-findings/issues/378#event-8415846539)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ERC4626Cloned} from \"gpl/ERC4626-Cloned.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"core/interfaces/IERC20Metadata.sol\";\nimport {ERC20Cloned} from \"gpl/ERC20-Cloned.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {WithdrawProxy} from \"core/WithdrawProxy.sol\";\n\nimport {Math} from \"core/utils/Math.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n\n  uint256 private constant PUBLIC_VAULT_SLOT =\n    uint256(keccak256(\"xyz.astaria.PublicVault.storage.location\")) - 1;\n\n  function asset()\n    public\n    pure\n    virtual\n    override(IAstariaVaultBase, AstariaVaultBase, ERC4626Cloned)\n    returns (address)\n  {\n    return super.asset();\n  }\n\n  function decimals()\n    public\n    pure\n    virtual\n    override(IERC20Metadata)\n    returns (uint8)\n  {\n    return 18;\n  }\n\n  function name()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(asset()).symbol()));\n  }\n\n  function symbol()\n    public\n    view\n    virtual\n    override(IERC20Metadata, VaultImplementation)\n    returns (string memory)\n  {\n    return string(abi.encodePacked(\"AST-V-\", ERC20(asset()).symbol()));\n  }\n\n  function minDepositAmount()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    if (ERC20(asset()).decimals() == uint8(18)) {\n      return 100 gwei;\n    } else {\n      return 10**(ERC20(asset()).decimals() - 1);\n    }\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 assets) {\n    VaultData storage s = _loadStorageSlot();\n    assets = _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override(ERC4626Cloned) returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n\n    VaultData storage s = _loadStorageSlot();\n\n    _redeemFutureEpoch(s, shares, receiver, owner, s.currentEpoch);\n  }\n\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    return\n      _redeemFutureEpoch(_loadStorageSlot(), shares, receiver, owner, epoch);\n  }\n\n  function _redeemFutureEpoch(\n    VaultData storage s,\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) internal virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not in the past\n\n    ERC20Data storage es = _loadERC20Slot();\n\n    if (msg.sender != owner) {\n      uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) {\n        es.allowance[owner][msg.sender] = allowed - shares;\n      }\n    }\n\n    if (epoch < s.currentEpoch) {\n      revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n    }\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n    // check for rounding error since we round down in previewRedeem.\n\n    //this will underflow if not enough balance\n    es.balanceOf[owner] -= shares;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      es.balanceOf[address(this)] += shares;\n    }\n\n    emit Transfer(owner, address(this), shares);\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n  }\n\n  function getWithdrawProxy(uint64 epoch) public view returns (WithdrawProxy) {\n    return WithdrawProxy(_loadStorageSlot().epochData[epoch].withdrawProxy);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return _loadStorageSlot().currentEpoch;\n  }\n\n  function getSlope() public view returns (uint256) {\n    return uint256(_loadStorageSlot().slope);\n  }\n\n  function getWithdrawReserve() public view returns (uint256) {\n    return uint256(_loadStorageSlot().withdrawReserve);\n  }\n\n  function getLiquidationWithdrawRatio() public view returns (uint256) {\n    return uint256(_loadStorageSlot().liquidationWithdrawRatio);\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return uint256(_loadStorageSlot().yIntercept);\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(VaultData storage s, uint64 epoch)\n    internal\n  {\n    if (s.epochData[epoch].withdrawProxy == address(0)) {\n      s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(ROUTER()), // router is the beacon\n          uint8(IAstariaRouter.ImplementationType.WithdrawProxy),\n          asset(), // token\n          address(this), // vault\n          epoch + 1 // claimable epoch\n        )\n      );\n    }\n  }\n\n  function mint(uint256 shares, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n    return super.mint(shares, receiver);\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n\n    uint256 assets = totalAssets();\n\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  function processEpoch() public {\n    // check to make sure epoch is over\n    if (timeToEpochEnd() > 0) {\n      revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n    }\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > 0) {\n      revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n    }\n\n    WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n      s.epochData[s.currentEpoch].withdrawProxy\n    );\n\n    // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n    if (s.currentEpoch != 0) {\n      WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      if (\n        address(previousWithdrawProxy) != address(0) &&\n        previousWithdrawProxy.getFinalAuctionEnd() != 0\n      ) {\n        previousWithdrawProxy.claim();\n      }\n    }\n\n    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n    }\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    s.liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if ((address(currentWithdrawProxy) != address(0))) {\n      uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n      s.liquidationWithdrawRatio = proxySupply\n        .mulDivDown(1e18, totalSupply())\n        .safeCastTo88();\n\n      currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n      uint256 expected = currentWithdrawProxy.getExpected();\n\n      unchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n      _setYIntercept(\n        s,\n        s.yIntercept -\n          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n      );\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n    }\n\n    // increment epoch\n    unchecked {\n      s.currentEpoch++;\n    }\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  function transferWithdrawReserve() public {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.currentEpoch == uint64(0)) {\n      return;\n    }\n\n    address currentWithdrawProxy = s\n      .epochData[s.currentEpoch - 1]\n      .withdrawProxy;\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n\n      // prevent transfer of more assets then are available\n      if (s.withdrawReserve <= withdrawBalance) {\n        withdrawBalance = s.withdrawReserve;\n        s.withdrawReserve = 0;\n      } else {\n        unchecked {\n          s.withdrawReserve -= withdrawBalance.safeCastTo88();\n        }\n      }\n\n      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        withdrawBalance\n      );\n      emit WithdrawReserveTransferred(withdrawBalance);\n    }\n\n    address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;\n    if (\n      s.withdrawReserve > 0 &&\n      timeToEpochEnd() == 0 &&\n      withdrawProxy != address(0)\n    ) {\n      address currentWithdrawProxy = s\n        .epochData[s.currentEpoch - 1]\n        .withdrawProxy;\n      uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(\n        s.withdrawReserve,\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      unchecked {\n        s.withdrawReserve -= drainBalance.safeCastTo88();\n      }\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        drainBalance\n      );\n    }\n  }\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)\n    internal\n    virtual\n    override(VaultImplementation)\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > uint256(0)) {\n      transferWithdrawReserve();\n    }\n    if (timeToEpochEnd() == uint256(0)) {\n      processEpoch();\n    }\n  }\n\n  function _loadStorageSlot() internal pure returns (VaultData storage s) {\n    uint256 slot = PUBLIC_VAULT_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   */\n  function _afterCommitToLien(\n    uint40 lienEnd,\n    uint256 lienId,\n    uint256 lienSlope\n  ) internal virtual override {\n    VaultData storage s = _loadStorageSlot();\n\n    // increment slope for the new lien\n    _accrue(s);\n    unchecked {\n      uint48 newSlope = s.slope + lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n\n    uint64 epoch = getLienEpoch(lienEnd);\n\n    _increaseOpenLiens(s, epoch);\n    emit LienOpen(lienId, epoch);\n  }\n\n  event SlopeUpdated(uint48 newSlope);\n\n  function accrue() public returns (uint256) {\n    return _accrue(_loadStorageSlot());\n  }\n\n  function _accrue(VaultData storage s) internal returns (uint256) {\n    unchecked {\n      s.yIntercept = (_totalAssets(s)).safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n    emit YInterceptChanged(s.yIntercept);\n\n    return s.yIntercept;\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n  function totalAssets()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n  {\n    VaultData storage s = _loadStorageSlot();\n    return _totalAssets(s);\n  }\n\n  function _totalAssets(VaultData storage s) internal view returns (uint256) {\n    uint256 delta_t = block.timestamp - s.last;\n    return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(IERC20, ERC20Cloned)\n    returns (uint256)\n  {\n    return\n      _loadERC20Slot()._totalSupply +\n      _loadStorageSlot().strategistUnclaimedShares;\n  }\n\n  function claim() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VaultData storage s = _loadStorageSlot();\n    uint256 unclaimed = s.strategistUnclaimedShares;\n    s.strategistUnclaimedShares = 0;\n    _mint(msg.sender, unclaimed);\n  }\n\n  function beforePayment(BeforePaymentParams calldata params)\n    external\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n    _accrue(s);\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n    }\n    _handleStrategistInterestReward(s, params.interestOwed, params.amount);\n  }\n\n  function _setSlope(VaultData storage s, uint48 newSlope) internal {\n    s.slope = newSlope;\n    emit SlopeUpdated(newSlope);\n  }\n\n  function decreaseEpochLienCount(uint64 epoch) public onlyLienToken {\n    _decreaseEpochLienCount(_loadStorageSlot(), epoch);\n  }\n\n  function _decreaseEpochLienCount(VaultData storage s, uint64 epoch) internal {\n    s.epochData[epoch].liensOpenForEpoch--;\n    emit LiensOpenForEpochRemaining(\n      epoch,\n      s.epochData[epoch].liensOpenForEpoch\n    );\n  }\n\n  function getLienEpoch(uint64 end) public pure returns (uint64) {\n    return\n      uint256(Math.ceilDiv(end - uint64(START()), EPOCH_LENGTH()) - 1)\n        .safeCastTo64();\n  }\n\n  function getEpochEnd(uint256 epoch) public pure returns (uint64) {\n    return uint256(START() + (epoch + 1) * EPOCH_LENGTH()).safeCastTo64();\n  }\n\n  function _increaseOpenLiens(VaultData storage s, uint64 epoch) internal {\n    unchecked {\n      s.epochData[epoch].liensOpenForEpoch++;\n    }\n  }\n\n  function afterPayment(uint256 computedSlope) public onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    unchecked {\n      s.slope += computedSlope.safeCastTo48();\n    }\n    emit SlopeUpdated(s.slope);\n  }\n\n  /**\n   * @notice After-deposit hook to update the yIntercept of the PublicVault to reflect a capital contribution.\n   * @param assets The amount of assets deposited to the PublicVault.\n   * @param shares The resulting amount of VaultToken shares that were issued.\n   */\n  function afterDeposit(uint256 assets, uint256 shares)\n    internal\n    virtual\n    override\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      s.yIntercept += assets.safeCastTo88();\n    }\n    VIData storage v = _loadVISlot();\n    if (v.depositCap != 0 && totalAssets() >= v.depositCap) {\n      revert InvalidState(InvalidStates.DEPOSIT_CAP_EXCEEDED);\n    }\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  /**\n   * @dev Handles the dilutive fees (on lien repayments) for strategists in VaultTokens.\n   * @param interestOwing the owingInterest for the lien\n   * @param amount The amount that was paid.\n   */\n  function _handleStrategistInterestReward(\n    VaultData storage s,\n    uint256 interestOwing,\n    uint256 amount\n  ) internal virtual {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n      uint88 feeInShares = convertToShares(fee).safeCastTo88();\n      s.strategistUnclaimedShares += feeInShares;\n      emit StrategistFee(feeInShares);\n    }\n  }\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    return ROUTER().LIEN_TOKEN();\n  }\n\n  function handleBuyoutLien(BuyoutLienParams calldata params)\n    public\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n      s.yIntercept += params.increaseYIntercept.safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n\n    _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function updateAfterLiquidationPayment(\n    LiquidationPaymentParams calldata params\n  ) external onlyLienToken {\n    VaultData storage s = _loadStorageSlot();\n    if (params.remaining > 0)\n      _setYIntercept(s, s.yIntercept - params.remaining);\n  }\n\n  function updateVaultAfterLiquidation(\n    uint256 maxAuctionWindow,\n    AfterLiquidationParams calldata params\n  ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {\n    VaultData storage s = _loadStorageSlot();\n\n    _accrue(s);\n    unchecked {\n      _setSlope(s, s.slope - params.lienSlope.safeCastTo48());\n    }\n\n    if (s.currentEpoch != 0) {\n      transferWithdrawReserve();\n    }\n    uint64 lienEpoch = getLienEpoch(params.lienEnd);\n    _decreaseEpochLienCount(s, lienEpoch);\n\n    uint256 timeToEnd = timeToEpochEnd(lienEpoch);\n    if (timeToEnd < maxAuctionWindow) {\n      _deployWithdrawProxyIfNotDeployed(s, lienEpoch);\n      withdrawProxyIfNearBoundary = s.epochData[lienEpoch].withdrawProxy;\n\n      WithdrawProxy(withdrawProxyIfNearBoundary).handleNewLiquidation(\n        params.newAmount,\n        maxAuctionWindow\n      );\n    }\n  }\n\n  function increaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept + amount);\n  }\n\n  modifier onlyLienToken() {\n    require(msg.sender == address(LIEN_TOKEN()));\n    _;\n  }\n\n  function decreaseYIntercept(uint256 amount) public {\n    VaultData storage s = _loadStorageSlot();\n    uint64 currentEpoch = s.currentEpoch;\n    require(\n      currentEpoch != 0 &&\n        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n    );\n    _setYIntercept(s, s.yIntercept - amount);\n  }\n\n  function _setYIntercept(VaultData storage s, uint256 newYIntercept) internal {\n    s.yIntercept = newYIntercept.safeCastTo88();\n    emit YInterceptChanged(s.yIntercept);\n  }\n\n  function timeToEpochEnd() public view returns (uint256) {\n    return timeToEpochEnd(_loadStorageSlot().currentEpoch);\n  }\n\n  function timeToEpochEnd(uint256 epoch) public view returns (uint256) {\n    uint256 epochEnd = START() + ((epoch + 1) * EPOCH_LENGTH());\n\n    if (block.timestamp >= epochEnd) {\n      return uint256(0);\n    }\n\n    return epochEnd - block.timestamp;\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    override\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return timeToEpochEnd() + EPOCH_LENGTH();\n  }\n\n  function timeToSecondEpochEnd() public view returns (uint256) {\n    return _timeToSecondEndIfPublic();\n  }\n}"
    },
    {
      "filename": "src/test/TestHelpers.t.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\nimport {\n  MultiRolesAuthority\n} from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IERC20} from \"core/interfaces/IERC20.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IStrategyValidator} from \"core/interfaces/IStrategyValidator.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {\n  ICollectionValidator,\n  CollectionValidator\n} from \"../strategies/CollectionValidator.sol\";\nimport {\n  UNI_V3Validator,\n  IUNI_V3Validator\n} from \"../strategies/UNI_V3Validator.sol\";\nimport {\n  UniqueValidator,\n  IUniqueValidator\n} from \"../strategies/UniqueValidator.sol\";\nimport {V3SecurityHook} from \"../security/V3SecurityHook.sol\";\nimport {CollateralToken} from \"../CollateralToken.sol\";\nimport {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\";\nimport {VaultImplementation} from \"../VaultImplementation.sol\";\nimport {LienToken} from \"../LienToken.sol\";\nimport {TransferProxy} from \"../TransferProxy.sol\";\nimport {PublicVault} from \"../PublicVault.sol\";\nimport {Vault} from \"../Vault.sol\";\nimport {WithdrawProxy} from \"../WithdrawProxy.sol\";\nimport {Strings2} from \"./utils/Strings2.sol\";\nimport {BeaconProxy} from \"../BeaconProxy.sol\";\n\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {Deploy} from \"core/scripts/deployments/Deploy.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  OrderParameters,\n  OrderComponents,\n  Order,\n  CriteriaResolver,\n  AdvancedOrder,\n  OfferItem,\n  ConsiderationItem,\n  OrderType,\n  Fulfillment,\n  FulfillmentComponent\n} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {ConduitController} from \"seaport/conduit/ConduitController.sol\";\nimport {Conduit} from \"seaport/conduit/Conduit.sol\";\nimport {Consideration} from \"seaport/lib/Consideration.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\n\nstring constant weth9Artifact = \"src/test/WETH9.json\";\n\ncontract TestNFT is MockERC721 {\n  constructor(uint256 size) MockERC721(\"TestNFT\", \"TestNFT\") {\n    for (uint256 i = 0; i < size; ++i) {\n      _mint(msg.sender, i);\n    }\n  }\n}\nimport {BaseOrderTest} from \"lib/seaport/test/foundry/utils/BaseOrderTest.sol\";\n\ncontract ConsiderationTester is BaseOrderTest {\n  function _deployAndConfigureConsideration() public {\n    conduitController = new ConduitController();\n    consideration = new Consideration(address(conduitController));\n\n    //create conduit, update channel\n    conduit = Conduit(\n      conduitController.createConduit(conduitKeyOne, address(this))\n    );\n    conduitController.updateChannel(\n      address(conduit),\n      address(consideration),\n      true\n    );\n  }\n\n  function setUp() public virtual override(BaseOrderTest) {\n    conduitKeyOne = bytes32(uint256(uint160(address(this))) << 96);\n    _deployAndConfigureConsideration();\n\n    vm.label(address(conduitController), \"conduitController\");\n    vm.label(address(consideration), \"consideration\");\n    vm.label(address(conduit), \"conduit\");\n    vm.label(address(this), \"testContract\");\n  }\n}\n\ncontract TestHelpers is Deploy, ConsiderationTester {\n  using CollateralLookup for address;\n  using Strings2 for bytes;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n  uint256 strategistOnePK = uint256(0x1339);\n  uint256 strategistTwoPK = uint256(0x1344); // strategistTwo is delegate for PublicVault created by strategistOne\n  uint256 strategistRoguePK = uint256(0x1559); // strategist who doesn't have a vault\n  address strategistOne = vm.addr(strategistOnePK);\n  address strategistTwo = vm.addr(strategistTwoPK);\n  address strategistRogue = vm.addr(strategistRoguePK);\n\n  address borrower = vm.addr(0x1341);\n  uint256 bidderPK = uint256(2566);\n  uint256 bidderTwoPK = uint256(2567);\n  address bidder = vm.addr(bidderPK);\n  address bidderOne = vm.addr(0x1342);\n  address bidderTwo = vm.addr(bidderTwoPK);\n\n  string private checkpointLabel;\n  uint256 private checkpointGasLeft = 1; // Start the slot warm.\n\n  ILienToken.Details public shortNSweet =\n    ILienToken.Details({\n      maxAmount: 150 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 1 minutes,\n      maxPotentialDebt: 0 ether,\n      liquidationInitialAsk: 500 ether\n    });\n  ILienToken.Details public blueChipDetails =\n    ILienToken.Details({\n      maxAmount: 150 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 10 days,\n      maxPotentialDebt: 0 ether,\n      liquidationInitialAsk: 500 ether\n    });\n  ILienToken.Details public rogueBuyoutLien =\n    ILienToken.Details({\n      maxAmount: 50 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 10 days,\n      maxPotentialDebt: 50 ether,\n      liquidationInitialAsk: 500 ether\n    });\n  ILienToken.Details public standardLienDetails =\n    ILienToken.Details({\n      maxAmount: 50 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 10 days,\n      maxPotentialDebt: 0 ether,\n      liquidationInitialAsk: 500 ether\n    });\n  ILienToken.Details public standardLienDetails2 =\n    ILienToken.Details({\n      maxAmount: 50 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 11 days,\n      maxPotentialDebt: 0 ether,\n      liquidationInitialAsk: 500 ether\n    });\n\n  ILienToken.Details public refinanceLienDetails =\n    ILienToken.Details({\n      maxAmount: 50 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 25 days,\n      maxPotentialDebt: 53 ether,\n      liquidationInitialAsk: 500 ether\n    });\n  ILienToken.Details public refinanceLienDetails2 =\n    ILienToken.Details({\n      maxAmount: 50 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 25 days,\n      maxPotentialDebt: 52 ether,\n      liquidationInitialAsk: 500 ether\n    });\n\n  ILienToken.Details public refinanceLienDetails3 =\n    ILienToken.Details({\n      maxAmount: 50 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 25 days,\n      maxPotentialDebt: 51 ether,\n      liquidationInitialAsk: 500 ether\n    });\n\n  ILienToken.Details public refinanceLienDetails4 =\n    ILienToken.Details({\n      maxAmount: 50 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 25 days,\n      maxPotentialDebt: 55 ether,\n      liquidationInitialAsk: 500 ether\n    });\n\n  enum StrategyTypes {\n    STANDARD,\n    COLLECTION,\n    UNIV3_LIQUIDITY\n  }\n\n  struct Fees {\n    uint256 liquidator;\n    uint256 lender;\n    uint256 borrower;\n  }\n\n  event NewTermCommitment(bytes32 vault, uint256 collateralId, uint256 amount);\n  event Repayment(bytes32 vault, uint256 collateralId, uint256 amount);\n  event Liquidation(bytes32 vault, uint256 collateralId);\n  event NewVault(\n    address strategist,\n    bytes32 vault,\n    bytes32 contentHash,\n    uint256 expiration\n  );\n  event RedeemVault(bytes32 vault, uint256 amount, address indexed redeemer);\n\n  address bidderConduit;\n  bytes32 bidderConduitKey;\n\n  function setUp() public virtual override {\n    testModeDisabled = false;\n    super.setUp();\n    SEAPORT = ConsiderationInterface(address(consideration));\n    deploy();\n\n    WETH9 = new WETH();\n    vm.label(address(WETH9), \"WETH9\");\n    vm.label(address(MRA), \"MRA\");\n    vm.label(address(TRANSFER_PROXY), \"TRANSFER_PROXY\");\n\n    vm.label(address(LIEN_TOKEN), \"LIEN_TOKEN\");\n\n    vm.label(address(COLLATERAL_TOKEN), \"COLLATERAL_TOKEN\");\n\n    vm.label(COLLATERAL_TOKEN.getConduit(), \"collateral conduit\");\n\n    vm.label(address(ASTARIA_ROUTER), \"ASTARIA_ROUTER\");\n\n    V3SecurityHook V3_SECURITY_HOOK = new V3SecurityHook(\n      address(0xC36442b4a4522E871399CD717aBDD847Ab11FE88)\n    );\n\n    CollateralToken.File[] memory ctfiles = new CollateralToken.File[](2);\n\n    ctfiles[0] = ICollateralToken.File({\n      what: ICollateralToken.FileType.AstariaRouter,\n      data: abi.encode(address(ASTARIA_ROUTER))\n    });\n\n    address UNI_V3_NFT = address(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n    ctfiles[1] = ICollateralToken.File({\n      what: ICollateralToken.FileType.SecurityHook,\n      data: abi.encode(UNI_V3_NFT, address(V3_SECURITY_HOOK))\n    });\n\n    COLLATERAL_TOKEN.fileBatch(ctfiles);\n\n    //strategy unique\n    UniqueValidator UNIQUE_STRATEGY_VALIDATOR = new UniqueValidator();\n    //strategy collection\n    CollectionValidator COLLECTION_STRATEGY_VALIDATOR = new CollectionValidator();\n    //strategy univ3\n    UNI_V3Validator UNIV3_LIQUIDITY_STRATEGY_VALIDATOR = new UNI_V3Validator();\n\n    IAstariaRouter.File[] memory files = new IAstariaRouter.File[](3);\n\n    files[0] = IAstariaRouter.File(\n      IAstariaRouter.FileType.StrategyValidator,\n      abi.encode(uint8(1), address(UNIQUE_STRATEGY_VALIDATOR))\n    );\n    files[1] = IAstariaRouter.File(\n      IAstariaRouter.FileType.StrategyValidator,\n      abi.encode(uint8(2), address(COLLECTION_STRATEGY_VALIDATOR))\n    );\n    files[2] = IAstariaRouter.File(\n      IAstariaRouter.FileType.StrategyValidator,\n      abi.encode(uint8(3), address(UNIV3_LIQUIDITY_STRATEGY_VALIDATOR))\n    );\n\n    ASTARIA_ROUTER.fileBatch(files);\n\n    _setupRolesAndCapabilities();\n  }\n\n  function getAmountOwedToLender(\n    uint256 rate,\n    uint256 amount,\n    uint256 duration\n  ) public pure returns (uint256) {\n    return\n      amount +\n      (rate * amount * duration).mulDivDown(1, 365 days).mulDivDown(1, 1e18);\n  }\n\n  function setupLiquidation(address borrower)\n    public\n    returns (address publicVault, ILienToken.Stack[] memory stack)\n  {\n    TestNFT nft = new TestNFT(0);\n    _mintNoDepositApproveRouterSpecific(borrower, address(nft), 99);\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(99);\n\n    // create a PublicVault with a 14-day epoch\n    publicVault = _createPublicVault({\n      strategist: strategistOne,\n      delegate: strategistTwo,\n      epochLength: 14 days\n    });\n\n    // lend 50 ether to the PublicVault as address(1)\n    _lendToVault(\n      Lender({addr: address(1), amountToLend: 50 ether}),\n      publicVault\n    );\n\n    _signalWithdraw(address(1), publicVault);\n\n    ILienToken.Details memory lien = standardLienDetails;\n    lien.duration = 14 days;\n\n    // borrow 10 eth against the dummy NFT\n    vm.startPrank(borrower);\n    (, stack) = _commitToLien({\n      vault: publicVault,\n      strategist: strategistOne,\n      strategistPK: strategistOnePK,\n      tokenContract: tokenContract,\n      tokenId: tokenId,\n      lienDetails: lien,\n      amount: 50 ether,\n      isFirstLien: true\n    });\n    vm.stopPrank();\n\n    vm.warp(block.timestamp + lien.duration);\n  }\n\n  function getFeesForLiquidation(\n    ui"
    }
  ]
}