{
  "Title": "M-1: `getPriceInEth` in  `TellorOracle.sol` doesn't uses the best practices recommended by Tellor which can cause wrong pricing",
  "Content": "# Issue M-1: `getPriceInEth` in  `TellorOracle.sol` doesn't uses the best practices recommended by Tellor which can cause wrong pricing \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/351 \n\n## Found by \nVagner\nThe function `getPriceInEth` it is used to call Tellor oracle to check the prices of different assets but the implementation doesn't respect the best practices recommended by Tellor which can cause wrong pricing.\n## Vulnerability Detail\nTellor team has a **Development Checklist** \nhttps://docs.tellor.io/tellor/getting-data/user-checklists#development-checklist\nthat is important to use when you are using Tellor protocol to protect yourself against stale prices and also to limit dispute attacks. The prices in Tellor protocol can be disputed and changed in case of malicious acting and because of that dispute attacks can happen which would make the prices unstable. `getPriceInEth` calls `getDataBefore`\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L105\nand uses the timestamp returned to check if the prices are stale or not using `DEFAULT_PRICING_TIMEOUT` or `tellorStoredTimeout`\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L107-L112\nThe value of the `DEFAULT_PRICING_TIMEOUT` is 2 hours and the frame of time where a dispute could happen is around 12 hours as per Tellor documentation, which could make `getPriceInEth` revert multiple times because of possible dispute attacks that could happen. The way the Tellor protocol recommends to limit the possibility of dispute attacks is by caching the most recent values and timestamps as can seen here in their example \nhttps://github.com/tellor-io/tellor-caller-liquity/blob/3ed91e4b15f0bac737f2966e36805ade3daf8162/contracts/TellorCaller.sol#L9-L11\nBasically every time data is returned it is checked against the last stored values and in case of a dispute attack it will return the last stored undisputed and accurate value as can be seen here \nhttps://github.com/tellor-io/tellor-caller-liquity/blob/3ed91e4b15f0bac737f2966e36805ade3daf8162/contracts/TellorCaller.sol#L51-L58\nIt is also important to note that the Tellor protocol checks for data returned to not be 0\nhttps://github.com/tellor-io/tellor-caller-liquity/blob/3ed91e4b15f0bac737f2966e36805ade3daf8162/contracts/TellorCaller.sol#L51\nwhich is not done in the `getPriceInEth`, so in the case of a 0 value it will be decoded \nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L114\nand then passed into `_denominationPricing`\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L115\nwhich would return a 0 value that could hurt the protocol.\n## Impact\nMedium of because of wrong pricing or multiple revert in case of dispute attacks\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol#L101-L116\n## Tool used\n\nManual Review\n\n## Recommendation\nI recommend to use the Tellor example in \nhttps://github.com/tellor-io/tellor-caller-liquity/blob/main/contracts/TellorCaller.sol\nand implement mappings to cache the values all the time, similar to how Tellor does it to limit as much as possible dispute attacks and also check for 0 value.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**Trumpero** commented:\n> low, oracle completeness is considered low similar to chainlink round completeness\n\n**thekmj** commented:\n> great analysis\n\n\n\n**VagnerAndrei26**\n\nEscalate\nI don't believe this should be taken as a low because of several factors :\n- firstly, sherlock rules states that Chainlink round completeness check are invalid since the new OCR doesn't rely on rounds for reporting the price, it doesn't state that every round completeness is invalid, because the mechanics may differ from oracle to oracle and in some situations it is important to check for everything\n![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/111457602/91971bf5-44bf-42d2-abff-37b55913f5c1)\n- secondly, because of how Tellor oracle work, anyone can dispute prices and act maliciously by paying the right amount of fees in TRB, that's why the Tellor talks about \"dispute attacks\" and specify why it is important to protect yourself against them, they acknowledge the risk where bad actors could manipulate the prices for their benefits and if a protocol implementing Tellor oracle does not protect themselves against this, it could hurt it.\n- thirdly, it is important when implementing an external protocol, especially an important one like an oracle, to follow their best practices and recommendations since their methods are battle-tested and any mistakes could lead to loss of funds\n\nIn the end, I believe that this should not be treated as a simple `Chainlink round completeness check` , since the mechanics are different and the issue is more complex than that, I believe it should be treated highly since an attack path that could lead to loss of funds by manipulating the price exists, which Tokemak protocol doesn't protect against, as recommender by Tellor.\n\n**sherlock-admin2**\n\n > Escalate\n> I don't believe this should be taken as a low because of several factors :\n> - firstly, sherlock rules states that Chainlink round completeness check are invalid since the new OCR doesn't rely on rounds for reporting the price, it doesn't state that every round completeness is invalid, because the mechanics may differ from oracle to oracle and in some situations it is important to check for everything\n> ![image](https://github.com/sherlock-audit/2023-06-tokemak-judging/assets/111457602/91971bf5-44bf-42d2-abff-37b55913f5c1)\n> - secondly, because of how Tellor oracle work, anyone can dispute prices and act maliciously by paying the right amount of fees in TRB, that's why the Tellor talks about \"dispute attacks\" and specify why it is important to protect yourself against them, they acknowledge the risk where bad actors could manipulate the prices for their benefits and if a protocol implementing Tellor oracle does not protect themselves against this, it could hurt it.\n> - thirdly, it is important when implementing an external protocol, especially an important one like an oracle, to follow their best practices and recommendations since their methods are battle-tested and any mistakes could lead to loss of funds\n> \n> In the end, I believe that this should not be treated as a simple `Chainlink round completeness check` , since the mechanics are different and the issue is more complex than that, I believe it should be treated highly since an attack path that could lead to loss of funds by manipulating the price exists, which Tokemak protocol doesn't protect against, as recommender by Tellor.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**xiaoming9090**\n\nI agree with the escalator that this should be a valid issue. The root cause is that oracle did not cache the most recent values and timestamps per Tellor's recommendation, leading to dispute attacks. This is similar to the issue I mentioned in my report (https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/612).\n\nThis issue (https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/351) and Issue https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/612 should be an issue of its own, and should not be grouped with the rest. Refer to my escalation (https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/612#issuecomment-1748029481) for more details. \n\n**Evert0x**\n\nPlanning to accept escalation and make issue medium\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [VagnerAndrei26](https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/351/#issuecomment-1746485268): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { BaseOracleDenominations, ISystemRegistry } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { IEthValueOracle } from \"src/interfaces/pricing/IEthValueOracle.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\nimport { UsingTellor } from \"usingtellor/UsingTellor.sol\";\n\n/**\n * @title Gets the spot price of tokens that Tellor provides a feed for.\n * @dev Will convert all tokens to Eth pricing regardless of original denomination.\n * @dev Returns 18 decimals of precision.\n */\ncontract TellorOracle is BaseOracleDenominations, UsingTellor {\n    /**\n     * @notice Used to store information about Tellor price queries.\n     * @dev No decimals, all returned in e18 precision.\n     * @param queryId bytes32 queryId for pricing query. See here: https://tellor.io/queryidstation/.\n     * @param pricingTimeout Custom timeout for asset.  If 0, contract will use default defined in\n     *    `BaseOracleDenominations.sol`.\n     * @param denomination Enum representing denomination of price returned.\n     */\n    struct TellorInfo {\n        bytes32 queryId;\n        uint32 pricingTimeout;\n        Denomination denomination;\n    }\n\n    /// @dev Token address to TellorInfo structs.\n    mapping(address => TellorInfo) private tellorQueryInfo;\n\n    /// @notice Emitted when information about a Tellor query is registered.\n    event TellorRegistrationAdded(address token, Denomination denomination, bytes32 _queryId);\n\n    /// @notice Emitted when  information about a Tellor query is removed.\n    event TellorRegistrationRemoved(address token, bytes32 queryId);\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _tellorOracleAddress\n    )\n        // Tellor requires payable address\n        UsingTellor(payable(_tellorOracleAddress))\n        BaseOracleDenominations(_systemRegistry)\n    {\n        Errors.verifyNotZero(_tellorOracleAddress, \"tellor\");\n    }\n\n    /**\n     * @notice Allows permissioned address to set _queryId, denomination for token address.\n     * @param token Address of token to set queryId for.\n     * @param _queryId Bytes32 queryId.\n     * @param denomination Denomination of token.\n     * @param pricingTimeout Custom timeout for queryId if needed.  Can be set to zero\n     *      to use default defined in `BaseOracleDenominations.sol`.\n     */\n    function addTellorRegistration(\n        address token,\n        bytes32 _queryId,\n        Denomination denomination,\n        uint32 pricingTimeout\n    ) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenForQueryId\");\n        Errors.verifyNotZero(_queryId, \"queryId\");\n        if (tellorQueryInfo[token].queryId != bytes32(0)) revert Errors.MustBeZero();\n        tellorQueryInfo[token] =\n            TellorInfo({ queryId: _queryId, denomination: denomination, pricingTimeout: pricingTimeout });\n        emit TellorRegistrationAdded(token, denomination, _queryId);\n    }\n\n    /**\n     * @notice Allows permissioned removal registration for token address.\n     * @param token Token to remove TellorInfo struct for.\n     */\n    function removeTellorRegistration(address token) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenToRemoveRegistration\");\n        bytes32 queryIdBeforeDeletion = tellorQueryInfo[token].queryId;\n        Errors.verifyNotZero(queryIdBeforeDeletion, \"queryIdBeforeDeletion\");\n        delete tellorQueryInfo[token];\n        emit TellorRegistrationRemoved(token, queryIdBeforeDeletion);\n    }\n\n    /**\n     * @notice External function to view TellorInfo struct for token address.\n     * @dev Will return empty struct for unregistered token address.\n     * @param token Address of token to view TellorInfo struct for.\n     */\n    function getQueryInfo(address token) external view returns (TellorInfo memory) {\n        return tellorQueryInfo[token];\n    }\n\n    /**\n     * @dev Tellor always returns prices with 18 decimals of precision for spot pricing, so we do not need\n     *      to worry about increasing or decreasing precision here.  See here:\n     *      https://github.com/tellor-io/dataSpecs/blob/main/types/SpotPrice.md\n     */\n    // slither-disable-start timestamp\n    function getPriceInEth(address tokenToPrice) external returns (uint256) {\n        TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n        uint256 timestamp = block.timestamp;\n        // Giving time for Tellor network to dispute price\n        (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n        uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n        uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n        // Check that something was returned and freshness of price.\n        if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n            revert InvalidDataReturned();\n        }\n\n        uint256 price = abi.decode(value, (uint256));\n        return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n    }\n    // slither-disable-end timestamp\n\n    /// @dev Used to enforce non-existent queryId checks\n    function _getQueryInfo(address token) private view returns (TellorInfo memory tellorInfo) {\n        tellorInfo = tellorQueryInfo[token];\n        Errors.verifyNotZero(tellorInfo.queryId, \"queryId\");\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { BaseOracleDenominations, ISystemRegistry } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { IEthValueOracle } from \"src/interfaces/pricing/IEthValueOracle.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\nimport { UsingTellor } from \"usingtellor/UsingTellor.sol\";\n\n/**\n * @title Gets the spot price of tokens that Tellor provides a feed for.\n * @dev Will convert all tokens to Eth pricing regardless of original denomination.\n * @dev Returns 18 decimals of precision.\n */\ncontract TellorOracle is BaseOracleDenominations, UsingTellor {\n    /**\n     * @notice Used to store information about Tellor price queries.\n     * @dev No decimals, all returned in e18 precision.\n     * @param queryId bytes32 queryId for pricing query. See here: https://tellor.io/queryidstation/.\n     * @param pricingTimeout Custom timeout for asset.  If 0, contract will use default defined in\n     *    `BaseOracleDenominations.sol`.\n     * @param denomination Enum representing denomination of price returned.\n     */\n    struct TellorInfo {\n        bytes32 queryId;\n        uint32 pricingTimeout;\n        Denomination denomination;\n    }\n\n    /// @dev Token address to TellorInfo structs.\n    mapping(address => TellorInfo) private tellorQueryInfo;\n\n    /// @notice Emitted when information about a Tellor query is registered.\n    event TellorRegistrationAdded(address token, Denomination denomination, bytes32 _queryId);\n\n    /// @notice Emitted when  information about a Tellor query is removed.\n    event TellorRegistrationRemoved(address token, bytes32 queryId);\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _tellorOracleAddress\n    )\n        // Tellor requires payable address\n        UsingTellor(payable(_tellorOracleAddress))\n        BaseOracleDenominations(_systemRegistry)\n    {\n        Errors.verifyNotZero(_tellorOracleAddress, \"tellor\");\n    }\n\n    /**\n     * @notice Allows permissioned address to set _queryId, denomination for token address.\n     * @param token Address of token to set queryId for.\n     * @param _queryId Bytes32 queryId.\n     * @param denomination Denomination of token.\n     * @param pricingTimeout Custom timeout for queryId if needed.  Can be set to zero\n     *      to use default defined in `BaseOracleDenominations.sol`.\n     */\n    function addTellorRegistration(\n        address token,\n        bytes32 _queryId,\n        Denomination denomination,\n        uint32 pricingTimeout\n    ) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenForQueryId\");\n        Errors.verifyNotZero(_queryId, \"queryId\");\n        if (tellorQueryInfo[token].queryId != bytes32(0)) revert Errors.MustBeZero();\n        tellorQueryInfo[token] =\n            TellorInfo({ queryId: _queryId, denomination: denomination, pricingTimeout: pricingTimeout });\n        emit TellorRegistrationAdded(token, denomination, _queryId);\n    }\n\n    /**\n     * @notice Allows permissioned removal registration for token address.\n     * @param token Token to remove TellorInfo struct for.\n     */\n    function removeTellorRegistration(address token) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenToRemoveRegistration\");\n        bytes32 queryIdBeforeDeletion = tellorQueryInfo[token].queryId;\n        Errors.verifyNotZero(queryIdBeforeDeletion, \"queryIdBeforeDeletion\");\n        delete tellorQueryInfo[token];\n        emit TellorRegistrationRemoved(token, queryIdBeforeDeletion);\n    }\n\n    /**\n     * @notice External function to view TellorInfo struct for token address.\n     * @dev Will return empty struct for unregistered token address.\n     * @param token Address of token to view TellorInfo struct for.\n     */\n    function getQueryInfo(address token) external view returns (TellorInfo memory) {\n        return tellorQueryInfo[token];\n    }\n\n    /**\n     * @dev Tellor always returns prices with 18 decimals of precision for spot pricing, so we do not need\n     *      to worry about increasing or decreasing precision here.  See here:\n     *      https://github.com/tellor-io/dataSpecs/blob/main/types/SpotPrice.md\n     */\n    // slither-disable-start timestamp\n    function getPriceInEth(address tokenToPrice) external returns (uint256) {\n        TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n        uint256 timestamp = block.timestamp;\n        // Giving time for Tellor network to dispute price\n        (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n        uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n        uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n        // Check that something was returned and freshness of price.\n        if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n            revert InvalidDataReturned();\n        }\n\n        uint256 price = abi.decode(value, (uint256));\n        return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n    }\n    // slither-disable-end timestamp\n\n    /// @dev Used to enforce non-existent queryId checks\n    function _getQueryInfo(address token) private view returns (TellorInfo memory tellorInfo) {\n        tellorInfo = tellorQueryInfo[token];\n        Errors.verifyNotZero(tellorInfo.queryId, \"queryId\");\n    }\n}"
    },
    {
      "filename": "contracts/TellorCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ITellorCaller.sol\";\nimport \"./interfaces/ITellor.sol\";\n/*\n* This contract serves as an example of how to integrate the Tellor oracle into a Liquity-like system. It\n* utilizes a best practice for using Tellor by implementing a time buffer. In addition, by caching the most \n* recent value and timestamp, it also seeks to limit dispute attacks.\n* \n* This contract has a single external function that calls Tellor: getTellorCurrentValue(). \n*\n* The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert, \n* this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n*\n*/\ncontract TellorCaller is ITellorCaller {\n    ITellor public tellor;\n\n    mapping (bytes32 => uint256) public lastStoredTimestamps;\n    mapping (bytes32 => uint256) public lastStoredPrices;\n\n    constructor (address payable _tellorOracleAddress) public {\n        tellor = ITellor(_tellorOracleAddress);\n    }\n\n    /*\n    * getTellorCurrentValue(): retrieves most recent value with a 20 minute time buffer.\n    * This buffer can be updated before deployment.\n    *\n    * @dev Allows the user to get the latest value with a time buffer for the queryId specified\n    * @param _queryId is the queryId to look up the value for\n    * @return ifRetrieve bool true if it is able to retrieve a value and the value's timestamp\n    * @return value the value retrieved, converted from bytes to a uint256 value\n    * @return _timestampRetrieved the value's timestamp\n    */\n    function getTellorCurrentValue(bytes32 _queryId)\n        external\n        override\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n        (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n        uint256 _value = abi.decode(data, (uint256));\n        if (timestamp == 0 || _value == 0) return (false, _value, timestamp);\n        if (timestamp > lastStoredTimestamps[_queryId]) {\n            lastStoredTimestamps[_queryId] = timestamp;\n            lastStoredPrices[_queryId] = _value;\n            return (true, _value, timestamp);\n        } else {\n            return (true, lastStoredPrices[_queryId], lastStoredTimestamps[_queryId]);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/TellorCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ITellorCaller.sol\";\nimport \"./interfaces/ITellor.sol\";\n/*\n* This contract serves as an example of how to integrate the Tellor oracle into a Liquity-like system. It\n* utilizes a best practice for using Tellor by implementing a time buffer. In addition, by caching the most \n* recent value and timestamp, it also seeks to limit dispute attacks.\n* \n* This contract has a single external function that calls Tellor: getTellorCurrentValue(). \n*\n* The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert, \n* this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n*\n*/\ncontract TellorCaller is ITellorCaller {\n    ITellor public tellor;\n\n    mapping (bytes32 => uint256) public lastStoredTimestamps;\n    mapping (bytes32 => uint256) public lastStoredPrices;\n\n    constructor (address payable _tellorOracleAddress) public {\n        tellor = ITellor(_tellorOracleAddress);\n    }\n\n    /*\n    * getTellorCurrentValue(): retrieves most recent value with a 20 minute time buffer.\n    * This buffer can be updated before deployment.\n    *\n    * @dev Allows the user to get the latest value with a time buffer for the queryId specified\n    * @param _queryId is the queryId to look up the value for\n    * @return ifRetrieve bool true if it is able to retrieve a value and the value's timestamp\n    * @return value the value retrieved, converted from bytes to a uint256 value\n    * @return _timestampRetrieved the value's timestamp\n    */\n    function getTellorCurrentValue(bytes32 _queryId)\n        external\n        override\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n        (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n        uint256 _value = abi.decode(data, (uint256));\n        if (timestamp == 0 || _value == 0) return (false, _value, timestamp);\n        if (timestamp > lastStoredTimestamps[_queryId]) {\n            lastStoredTimestamps[_queryId] = timestamp;\n            lastStoredPrices[_queryId] = _value;\n            return (true, _value, timestamp);\n        } else {\n            return (true, lastStoredPrices[_queryId], lastStoredTimestamps[_queryId]);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/TellorCaller.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ITellorCaller.sol\";\nimport \"./interfaces/ITellor.sol\";\n/*\n* This contract serves as an example of how to integrate the Tellor oracle into a Liquity-like system. It\n* utilizes a best practice for using Tellor by implementing a time buffer. In addition, by caching the most \n* recent value and timestamp, it also seeks to limit dispute attacks.\n* \n* This contract has a single external function that calls Tellor: getTellorCurrentValue(). \n*\n* The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert, \n* this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n*\n*/\ncontract TellorCaller is ITellorCaller {\n    ITellor public tellor;\n\n    mapping (bytes32 => uint256) public lastStoredTimestamps;\n    mapping (bytes32 => uint256) public lastStoredPrices;\n\n    constructor (address payable _tellorOracleAddress) public {\n        tellor = ITellor(_tellorOracleAddress);\n    }\n\n    /*\n    * getTellorCurrentValue(): retrieves most recent value with a 20 minute time buffer.\n    * This buffer can be updated before deployment.\n    *\n    * @dev Allows the user to get the latest value with a time buffer for the queryId specified\n    * @param _queryId is the queryId to look up the value for\n    * @return ifRetrieve bool true if it is able to retrieve a value and the value's timestamp\n    * @return value the value retrieved, converted from bytes to a uint256 value\n    * @return _timestampRetrieved the value's timestamp\n    */\n    function getTellorCurrentValue(bytes32 _queryId)\n        external\n        override\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        // retrieve most recent 20+ minute old value for a queryId. the time buffer allows time for a bad value to be disputed\n        (, bytes memory data, uint256 timestamp) = tellor.getDataBefore(_queryId, block.timestamp - 20 minutes);\n        uint256 _value = abi.decode(data, (uint256));\n        if (timestamp == 0 || _value == 0) return (false, _value, timestamp);\n        if (timestamp > lastStoredTimestamps[_queryId]) {\n            lastStoredTimestamps[_queryId] = timestamp;\n            lastStoredPrices[_queryId] = _value;\n            return (true, _value, timestamp);\n        } else {\n            return (true, lastStoredPrices[_queryId], lastStoredTimestamps[_queryId]);\n        }\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { BaseOracleDenominations, ISystemRegistry } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { IEthValueOracle } from \"src/interfaces/pricing/IEthValueOracle.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\nimport { UsingTellor } from \"usingtellor/UsingTellor.sol\";\n\n/**\n * @title Gets the spot price of tokens that Tellor provides a feed for.\n * @dev Will convert all tokens to Eth pricing regardless of original denomination.\n * @dev Returns 18 decimals of precision.\n */\ncontract TellorOracle is BaseOracleDenominations, UsingTellor {\n    /**\n     * @notice Used to store information about Tellor price queries.\n     * @dev No decimals, all returned in e18 precision.\n     * @param queryId bytes32 queryId for pricing query. See here: https://tellor.io/queryidstation/.\n     * @param pricingTimeout Custom timeout for asset.  If 0, contract will use default defined in\n     *    `BaseOracleDenominations.sol`.\n     * @param denomination Enum representing denomination of price returned.\n     */\n    struct TellorInfo {\n        bytes32 queryId;\n        uint32 pricingTimeout;\n        Denomination denomination;\n    }\n\n    /// @dev Token address to TellorInfo structs.\n    mapping(address => TellorInfo) private tellorQueryInfo;\n\n    /// @notice Emitted when information about a Tellor query is registered.\n    event TellorRegistrationAdded(address token, Denomination denomination, bytes32 _queryId);\n\n    /// @notice Emitted when  information about a Tellor query is removed.\n    event TellorRegistrationRemoved(address token, bytes32 queryId);\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _tellorOracleAddress\n    )\n        // Tellor requires payable address\n        UsingTellor(payable(_tellorOracleAddress))\n        BaseOracleDenominations(_systemRegistry)\n    {\n        Errors.verifyNotZero(_tellorOracleAddress, \"tellor\");\n    }\n\n    /**\n     * @notice Allows permissioned address to set _queryId, denomination for token address.\n     * @param token Address of token to set queryId for.\n     * @param _queryId Bytes32 queryId.\n     * @param denomination Denomination of token.\n     * @param pricingTimeout Custom timeout for queryId if needed.  Can be set to zero\n     *      to use default defined in `BaseOracleDenominations.sol`.\n     */\n    function addTellorRegistration(\n        address token,\n        bytes32 _queryId,\n        Denomination denomination,\n        uint32 pricingTimeout\n    ) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenForQueryId\");\n        Errors.verifyNotZero(_queryId, \"queryId\");\n        if (tellorQueryInfo[token].queryId != bytes32(0)) revert Errors.MustBeZero();\n        tellorQueryInfo[token] =\n            TellorInfo({ queryId: _queryId, denomination: denomination, pricingTimeout: pricingTimeout });\n        emit TellorRegistrationAdded(token, denomination, _queryId);\n    }\n\n    /**\n     * @notice Allows permissioned removal registration for token address.\n     * @param token Token to remove TellorInfo struct for.\n     */\n    function removeTellorRegistration(address token) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenToRemoveRegistration\");\n        bytes32 queryIdBeforeDeletion = tellorQueryInfo[token].queryId;\n        Errors.verifyNotZero(queryIdBeforeDeletion, \"queryIdBeforeDeletion\");\n        delete tellorQueryInfo[token];\n        emit TellorRegistrationRemoved(token, queryIdBeforeDeletion);\n    }\n\n    /**\n     * @notice External function to view TellorInfo struct for token address.\n     * @dev Will return empty struct for unregistered token address.\n     * @param token Address of token to view TellorInfo struct for.\n     */\n    function getQueryInfo(address token) external view returns (TellorInfo memory) {\n        return tellorQueryInfo[token];\n    }\n\n    /**\n     * @dev Tellor always returns prices with 18 decimals of precision for spot pricing, so we do not need\n     *      to worry about increasing or decreasing precision here.  See here:\n     *      https://github.com/tellor-io/dataSpecs/blob/main/types/SpotPrice.md\n     */\n    // slither-disable-start timestamp\n    function getPriceInEth(address tokenToPrice) external returns (uint256) {\n        TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n        uint256 timestamp = block.timestamp;\n        // Giving time for Tellor network to dispute price\n        (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n        uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n        uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n        // Check that something was returned and freshness of price.\n        if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n            revert InvalidDataReturned();\n        }\n\n        uint256 price = abi.decode(value, (uint256));\n        return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n    }\n    // slither-disable-end timestamp\n\n    /// @dev Used to enforce non-existent queryId checks\n    function _getQueryInfo(address token) private view returns (TellorInfo memory tellorInfo) {\n        tellorInfo = tellorQueryInfo[token];\n        Errors.verifyNotZero(tellorInfo.queryId, \"queryId\");\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { BaseOracleDenominations, ISystemRegistry } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { IEthValueOracle } from \"src/interfaces/pricing/IEthValueOracle.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\nimport { UsingTellor } from \"usingtellor/UsingTellor.sol\";\n\n/**\n * @title Gets the spot price of tokens that Tellor provides a feed for.\n * @dev Will convert all tokens to Eth pricing regardless of original denomination.\n * @dev Returns 18 decimals of precision.\n */\ncontract TellorOracle is BaseOracleDenominations, UsingTellor {\n    /**\n     * @notice Used to store information about Tellor price queries.\n     * @dev No decimals, all returned in e18 precision.\n     * @param queryId bytes32 queryId for pricing query. See here: https://tellor.io/queryidstation/.\n     * @param pricingTimeout Custom timeout for asset.  If 0, contract will use default defined in\n     *    `BaseOracleDenominations.sol`.\n     * @param denomination Enum representing denomination of price returned.\n     */\n    struct TellorInfo {\n        bytes32 queryId;\n        uint32 pricingTimeout;\n        Denomination denomination;\n    }\n\n    /// @dev Token address to TellorInfo structs.\n    mapping(address => TellorInfo) private tellorQueryInfo;\n\n    /// @notice Emitted when information about a Tellor query is registered.\n    event TellorRegistrationAdded(address token, Denomination denomination, bytes32 _queryId);\n\n    /// @notice Emitted when  information about a Tellor query is removed.\n    event TellorRegistrationRemoved(address token, bytes32 queryId);\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _tellorOracleAddress\n    )\n        // Tellor requires payable address\n        UsingTellor(payable(_tellorOracleAddress))\n        BaseOracleDenominations(_systemRegistry)\n    {\n        Errors.verifyNotZero(_tellorOracleAddress, \"tellor\");\n    }\n\n    /**\n     * @notice Allows permissioned address to set _queryId, denomination for token address.\n     * @param token Address of token to set queryId for.\n     * @param _queryId Bytes32 queryId.\n     * @param denomination Denomination of token.\n     * @param pricingTimeout Custom timeout for queryId if needed.  Can be set to zero\n     *      to use default defined in `BaseOracleDenominations.sol`.\n     */\n    function addTellorRegistration(\n        address token,\n        bytes32 _queryId,\n        Denomination denomination,\n        uint32 pricingTimeout\n    ) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenForQueryId\");\n        Errors.verifyNotZero(_queryId, \"queryId\");\n        if (tellorQueryInfo[token].queryId != bytes32(0)) revert Errors.MustBeZero();\n        tellorQueryInfo[token] =\n            TellorInfo({ queryId: _queryId, denomination: denomination, pricingTimeout: pricingTimeout });\n        emit TellorRegistrationAdded(token, denomination, _queryId);\n    }\n\n    /**\n     * @notice Allows permissioned removal registration for token address.\n     * @param token Token to remove TellorInfo struct for.\n     */\n    function removeTellorRegistration(address token) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenToRemoveRegistration\");\n        bytes32 queryIdBeforeDeletion = tellorQueryInfo[token].queryId;\n        Errors.verifyNotZero(queryIdBeforeDeletion, \"queryIdBeforeDeletion\");\n        delete tellorQueryInfo[token];\n        emit TellorRegistrationRemoved(token, queryIdBeforeDeletion);\n    }\n\n    /**\n     * @notice External function to view TellorInfo struct for token address.\n     * @dev Will return empty struct for unregistered token address.\n     * @param token Address of token to view TellorInfo struct for.\n     */\n    function getQueryInfo(address token) external view returns (TellorInfo memory) {\n        return tellorQueryInfo[token];\n    }\n\n    /**\n     * @dev Tellor always returns prices with 18 decimals of precision for spot pricing, so we do not need\n     *      to worry about increasing or decreasing precision here.  See here:\n     *      https://github.com/tellor-io/dataSpecs/blob/main/types/SpotPrice.md\n     */\n    // slither-disable-start timestamp\n    function getPriceInEth(address tokenToPrice) external returns (uint256) {\n        TellorInfo memory tellorInfo = _getQueryInfo(tokenToPrice);\n        uint256 timestamp = block.timestamp;\n        // Giving time for Tellor network to dispute price\n        (bytes memory value, uint256 timestampRetrieved) = getDataBefore(tellorInfo.queryId, timestamp - 30 minutes);\n        uint256 tellorStoredTimeout = uint256(tellorInfo.pricingTimeout);\n        uint256 tokenPricingTimeout = tellorStoredTimeout == 0 ? DEFAULT_PRICING_TIMEOUT : tellorStoredTimeout;\n\n        // Check that something was returned and freshness of price.\n        if (timestampRetrieved == 0 || timestamp - timestampRetrieved > tokenPricingTimeout) {\n            revert InvalidDataReturned();\n        }\n\n        uint256 price = abi.decode(value, (uint256));\n        return _denominationPricing(tellorInfo.denomination, price, tokenToPrice);\n    }\n    // slither-disable-end timestamp\n\n    /// @dev Used to enforce non-existent queryId checks\n    function _getQueryInfo(address token) private view returns (TellorInfo memory tellorInfo) {\n        tellorInfo = tellorQueryInfo[token];\n        Errors.verifyNotZero(tellorInfo.queryId, \"queryId\");\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/TellorOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { BaseOracleDenominations, ISystemRegistry } from \"src/oracles/providers/base/BaseOracleDenominations.sol\";\nimport { IEthValueOracle } from \"src/interfaces/pricing/IEthValueOracle.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\n\nimport { UsingTellor } from \"usingtellor/UsingTellor.sol\";\n\n/**\n * @title Gets the spot price of tokens that Tellor provides a feed for.\n * @dev Will convert all tokens to Eth pricing regardless of original denomination.\n * @dev Returns 18 decimals of precision.\n */\ncontract TellorOracle is BaseOracleDenominations, UsingTellor {\n    /**\n     * @notice Used to store information about Tellor price queries.\n     * @dev No decimals, all returned in e18 precision.\n     * @param queryId bytes32 queryId for pricing query. See here: https://tellor.io/queryidstation/.\n     * @param pricingTimeout Custom timeout for asset.  If 0, contract will use default defined in\n     *    `BaseOracleDenominations.sol`.\n     * @param denomination Enum representing denomination of price returned.\n     */\n    struct TellorInfo {\n        bytes32 queryId;\n        uint32 pricingTimeout;\n        Denomination denomination;\n    }\n\n    /// @dev Token address to TellorInfo structs.\n    mapping(address => TellorInfo) private tellorQueryInfo;\n\n    /// @notice Emitted when information about a Tellor query is registered.\n    event TellorRegistrationAdded(address token, Denomination denomination, bytes32 _queryId);\n\n    /// @notice Emitted when  information about a Tellor query is removed.\n    event TellorRegistrationRemoved(address token, bytes32 queryId);\n\n    constructor(\n        ISystemRegistry _systemRegistry,\n        address _tellorOracleAddress\n    )\n        // Tellor requires payable address\n        UsingTellor(payable(_tellorOracleAddress))\n        BaseOracleDenominations(_systemRegistry)\n    {\n        Errors.verifyNotZero(_tellorOracleAddress, \"tellor\");\n    }\n\n    /**\n     * @notice Allows permissioned address to set _queryId, denomination for token address.\n     * @param token Address of token to set queryId for.\n     * @param _queryId Bytes32 queryId.\n     * @param denomination Denomination of token.\n     * @param pricingTimeout Custom timeout for queryId if needed.  Can be set to zero\n     *      to use default defined in `BaseOracleDenominations.sol`.\n     */\n    function addTellorRegistration(\n        address token,\n        bytes32 _queryId,\n        Denomination denomination,\n        uint32 pricingTimeout\n    ) external onlyOwner {\n        Errors.verifyNotZero(token, \"tokenForQueryId\");\n        Errors.verifyNotZero(_queryId, \"queryId\");"
    }
  ]
}