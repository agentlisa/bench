{
  "Title": "H-2: Users who deposit extra funds into their Ichi farming positions will lose all their ICHI rewards",
  "Content": "# Issue H-2: Users who deposit extra funds into their Ichi farming positions will lose all their ICHI rewards \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/158 \n\n## Found by \ncarrot, rvierdiiev, minhtrng, obront, sinarette, tives, berndartmueller, 0x52\n\n## Summary\n\nWhen a user deposits extra funds into their Ichi farming position using `openPositionFarm()`, the old farming position will be closed down and a new one will be opened. Part of this process is that their ICHI rewards will be sent to the `IchiVaultSpell.sol` contract, but they will not be distributed. They will sit in the contract until the next user (or MEV bot) calls `closePositionFarm()`, at which point they will be stolen by that user.\n\n## Vulnerability Detail\n\nWhen Ichi farming positions are opened via the `IchiVaultSpell.sol` contract, `openPositionFarm()` is called. It goes through the usual deposit function, but rather than staking the LP tokens directly, it calls `wIchiFarm.mint()`. This function deposits the token into the `ichiFarm`, encodes the deposit as an ERC1155, and sends that token back to the Spell:\n```solidity\nfunction mint(uint256 pid, uint256 amount)\n    external\n    nonReentrant\n    returns (uint256)\n{\n    address lpToken = ichiFarm.lpToken(pid);\n    IERC20Upgradeable(lpToken).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amount\n    );\n    if (\n        IERC20Upgradeable(lpToken).allowance(\n            address(this),\n            address(ichiFarm)\n        ) != type(uint256).max\n    ) {\n        // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n        IERC20Upgradeable(lpToken).safeApprove(\n            address(ichiFarm),\n            type(uint256).max\n        );\n    }\n    ichiFarm.deposit(pid, amount, address(this));\n    // @ok if accIchiPerShare is always changing, so how does this work?\n    // it's basically just saving the accIchiPerShare at staking time, so when you unstake, it can calculate the difference\n    // really fucking smart actually\n    (uint256 ichiPerShare, , ) = ichiFarm.poolInfo(pid);\n    uint256 id = encodeId(pid, ichiPerShare);\n    _mint(msg.sender, id, amount, \"\");\n    return id;\n}\n```\nThe resulting ERC1155 is posted as collateral in the Blueberry Bank.\n\nIf the user decides to add more funds to this position, they simply call `openPositionFarm()` again. The function has logic to check if there is already existing collateral of this LP token in the Blueberry Bank. If there is, it removes the collateral and calls `wIchiFarm.burn()` (which harvests the Ichi rewards and withdraws the LP tokens) before repeating the deposit process.\n```solidity\nfunction burn(uint256 id, uint256 amount)\n    external\n    nonReentrant\n    returns (uint256)\n{\n    if (amount == type(uint256).max) {\n        amount = balanceOf(msg.sender, id);\n    }\n    (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n    _burn(msg.sender, id, amount);\n\n    uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n    ichiFarm.harvest(pid, address(this));\n    ichiFarm.withdraw(pid, amount, address(this));\n\n    // Convert Legacy ICHI to ICHI v2\n    if (ichiRewards > 0) {\n        ICHIv1.safeApprove(address(ICHI), ichiRewards);\n        ICHI.convertToV2(ichiRewards);\n    }\n\n    // Transfer LP Tokens\n    address lpToken = ichiFarm.lpToken(pid);\n    IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n    // Transfer Reward Tokens\n    (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n    uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n    uint256 enIchi = (enIchiPerShare * amount) / 1e18;\n\n    if (enIchi > stIchi) {\n        ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n    }\n    return pid;\n}\n```\nHowever, this deposit process has no logic for distributing the ICHI rewards. Therefore, these rewards will remain sitting in the `IchiVaultSpell.sol` contract and will not reach the user.\n\nFor an example of how this is handled properly, we can look at the opposite function, `closePositionFarm()`. In this case, the same `wIchiFarm.burn()` function is called. But in this case, it's followed up with an explicit call to withdraw the ICHI from the contract to the user.\n```solidity\ndoRefund(ICHI);\n```\nThis `doRefund()` function refunds the contract's full balance of ICHI to the `msg.sender`, so the result is that the next user to call `closePositionFarm()` will steal the ICHI tokens from the original user who added to their farming position.\n\n## Impact\n\nUsers who farm their Ichi LP tokens for ICHI rewards can permanently lose their rewards.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L199-L249\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/wrapper/WIchiFarm.sol#L116-L150\n\nHere is a link to the `harvest()` function  on the IchiFarmV2.sol contract, which is called by `wIchiFarm.sol` and contains the logic for distributing ICHI rewards: https://github.com/ichifarm/ichi-farming/blob/206c44b790fbb2a1e3a655685eb3ab8d793c9f00/contracts/ichiFarmV2.sol#L238-L257\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn the `openPositionFarm()` function, in the section that deals with withdrawing existing collateral, add a line that claims the ICHI rewards for the calling user.\n\n```diff\nif (collSize > 0) {\n    (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n    if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n    if (posCollToken != address(wIchiFarm))\n        revert INCORRECT_COLTOKEN(posCollToken);\n    bank.takeCollateral(collSize);\n    wIchiFarm.burn(collId, collSize);\n+   doRefund(ICHI);\n}\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/spell/IchiVaultSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../libraries/UniV3/UniV3WrappedLibMockup.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\n\ncontract IchiVaultSpell is BasicSpell, IUniswapV3SwapCallback {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Strategy {\n        address vault;\n        uint256 maxPositionSize;\n    }\n\n    /// @dev temperory state used to store uni v3 pool when swapping on uni v3\n    IUniswapV3Pool private swapPool;\n\n    /// @dev strategyId => ichi vault\n    Strategy[] public strategies;\n    /// @dev strategyId => collateral token => maxLTV\n    mapping(uint256 => mapping(address => uint256)) public maxLTV; // base 1e4\n    /// @dev address of ICHI farm wrapper\n    IWIchiFarm public wIchiFarm;\n    /// @dev address of ICHI token\n    address public ICHI;\n\n    event StrategyAdded(uint256 strategyId, address vault, uint256 maxPosSize);\n    event CollateralsSupportAdded(\n        uint256 strategyId,\n        address[] collaterals,\n        uint256[] maxLTVs\n    );\n\n    modifier existingStrategy(uint256 strategyId) {\n        if (strategyId >= strategies.length)\n            revert STRATEGY_NOT_EXIST(address(this), strategyId);\n\n        _;\n    }\n\n    modifier existingCollateral(uint256 strategyId, address col) {\n        if (maxLTV[strategyId][col] == 0)\n            revert COLLATERAL_NOT_EXIST(strategyId, col);\n\n        _;\n    }\n\n    function initialize(\n        IBank _bank,\n        address _werc20,\n        address _weth,\n        address _wichiFarm\n    ) external initializer {\n        __BasicSpell_init(_bank, _werc20, _weth);\n\n        wIchiFarm = IWIchiFarm(_wichiFarm);\n        ICHI = address(wIchiFarm.ICHI());\n        IWIchiFarm(_wichiFarm).setApprovalForAll(address(_bank), true);\n    }\n\n    /**\n     * @notice Owner privileged function to add vault\n     * @param vault Address of ICHI angel vault\n     * @param maxPosSize, USD price based maximum size of a position for given vault, based 1e18\n     */\n    function addStrategy(address vault, uint256 maxPosSize) external onlyOwner {\n        if (vault == address(0)) revert ZERO_ADDRESS();\n        if (maxPosSize == 0) revert ZERO_AMOUNT();\n        strategies.push(Strategy({vault: vault, maxPositionSize: maxPosSize}));\n        emit StrategyAdded(strategies.length - 1, vault, maxPosSize);\n    }\n\n    function addCollateralsSupport(\n        uint256 strategyId,\n        address[] memory collaterals,\n        uint256[] memory maxLTVs\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0)\n            revert INPUT_ARRAY_MISMATCH();\n\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collaterals[i] == address(0)) revert ZERO_ADDRESS();\n            if (maxLTVs[i] == 0) revert ZERO_AMOUNT();\n            maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\n        }\n\n        emit CollateralsSupportAdded(strategyId, collaterals, maxLTVs);\n    }\n\n    function _validateMaxLTV(uint256 strategyId) internal view {\n        uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n        (, address collToken, uint256 collAmount, , , , , ) = bank\n            .getCurrentPositionInfo();\n        uint256 collPrice = bank.oracle().getPrice(collToken);\n        uint256 collValue = (collPrice * collAmount) /\n            10**IERC20Metadata(collToken).decimals();\n\n        if (\n            debtValue >\n            (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR\n        ) revert EXCEED_MAX_LTV();\n    }\n\n    /**\n     * @notice Internal function to deposit assets on ICHI Vault\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of isolated collateral\n     * @param borrowToken Token address to borrow\n     * @param borrowAmount amount to borrow from Bank\n     */\n    function depositInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n\n        // 1. Lend isolated collaterals on compound\n        doLend(collToken, collAmount);\n\n        // 2. Borrow specific amounts\n        doBorrow(borrowToken, borrowAmount);\n\n        // 3. Add liquidity - Deposit on ICHI Vault\n        IICHIVault vault = IICHIVault(strategy.vault);\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 balance = IERC20(borrowToken).balanceOf(address(this));\n        ensureApprove(borrowToken, address(vault));\n        if (isTokenA) {\n            vault.deposit(balance, 0, address(this));\n        } else {\n            vault.deposit(0, balance, address(this));\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(strategyId);\n\n        // 5. Validate Max Pos Size\n        uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n        uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n            10**IICHIVault(strategy.vault).decimals();\n        if (curPosSize > strategy.maxPositionSize)\n            revert EXCEED_MAX_POS_SIZE(strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     */\n    function openPosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Put collateral - ICHI Vault Lp Token\n        address vault = strategies[strategyId].vault;\n        doPutCollateral(vault, IERC20(vault).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault and farm in Ichi Farm\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     * @param farmingPid Pool Id of vault lp on ICHI Farm\n     */\n    function openPositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount,\n        uint256 farmingPid\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        Strategy memory strategy = strategies[strategyId];\n        address lpToken = wIchiFarm.ichiFarm().lpToken(farmingPid);\n        if (strategy.vault != lpToken) revert INCORRECT_LP(lpToken);\n\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Take out collateral\n        (\n            ,\n            ,\n            ,\n            ,\n            address posCollToken,\n            uint256 collId,\n            uint256 collSize,\n\n        ) = bank.getCurrentPositionInfo();\n        if (collSize > 0) {\n            (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n            if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n            if (posCollToken != address(wIchiFarm))\n                revert INCORRECT_COLTOKEN(posCollToken);\n            bank.takeCollateral(collSize);\n            wIchiFarm.burn(collId, collSize);\n        }\n\n        // 5. Deposit on farming pool, put collateral\n        ensureApprove(strategy.vault, address(wIchiFarm));\n        uint256 lpAmount = IERC20(strategy.vault).balanceOf(address(this));\n        uint256 id = wIchiFarm.mint(farmingPid, lpAmount);\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\n    }\n\n    /**\n     * @dev Increase isolated collateral of position\n     * @param token Isolated collateral token address\n     * @param amount Amount of token to increase position\n     */\n    function increasePosition(address token, uint256 amount) external {\n        // 1. Get user input amounts\n        doLend(token, amount);\n    }\n\n    /**\n     * @dev Reduce isolated collateral of position\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of Isolated collateral\n     */\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n\n    function withdrawInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n        IICHIVault vault = IICHIVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Compute repay amount if MAX_INT is supplied (max debt)\n        if (amountRepay == type(uint256).max) {\n            amountRepay = bank.borrowBalanceCurrent(positionId, borrowToken);\n        }\n\n        // 2. Calculate actual amount to remove\n        uint256 amtLPToRemove = vault.balanceOf(address(this)) -\n            amountLpWithdraw;\n\n        // 3. Withdraw liquidity from ICHI vault\n        vault.withdraw(amtLPToRemove, address(this));\n\n        // 4. Swap withdrawn tokens to initial deposit token\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 amountToSwap = IERC20(\n            isTokenA ? vault.token1() : vault.token0()\n        ).balanceOf(address(this));\n        if (amountToSwap > 0) {\n            swapPool = IUniswapV3Pool(vault.pool());\n            swapPool.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                int256(amountToSwap),\n                isTokenA\n                    ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 // Token0 -> Token1\n                    : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, // Token1 -> Token0\n                abi.encode(address(this))\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        doWithdraw(collToken, amountShareWithdraw);\n\n        // 6. Repay\n        doRepay(borrowToken, amountRepay);\n\n        _validateMaxLTV(strategyId);\n\n        // 7. Refund\n        doRefund(borrowToken);\n        doRefund(collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets from ICHI Vault\n     * @param collToken Token address to withdraw (e.g USDC)\n     * @param borrowToken Token address to withdraw (e.g USDC)\n     * @param lpTakeAmt Amount of ICHI Vault LP token to take out from Bank\n     * @param amountRepay Amount to repay the loan\n     * @param amountLpWithdraw Amount of ICHI Vault LP to withdraw from ICHI Vault\n     * @param amountShareWithdraw Amount of Isolated collateral to withdraw from Compound\n     */\n    function closePosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1. Take out collateral\n        doTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n    }\n\n    function closePositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        address vault = strategies[strategyId].vault;\n        (, , , , address posCollToken, uint256 collId, , ) = bank\n            .getCurrentPositionInfo();\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault)\n            revert INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(wIchiFarm))\n            revert INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(lpTakeAmt);\n        wIchiFarm.burn(collId, lpTakeAmt);\n        doCutRewardsFee(ICHI);\n\n        // 2-8. Remove liquidity\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n\n        // 9. Refund ichi token\n        doRefund(ICHI);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n        address payer = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            }\n        } else if (amount1Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/wrapper/WIchiFarm.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../libraries/BBMath.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/ichi/IIchiV2.sol\";\nimport \"../interfaces/ichi/IIchiFarm.sol\";\n\ncontract WIchiFarm is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    IERC20Wrapper,\n    IWIchiFarm\n{\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IIchiV2;\n\n    IERC20Upgradeable public ICHIv1;\n    IIchiV2 public ICHI;\n    IIchiFarm public ichiFarm;\n\n    function initialize(\n        address _ichi,\n        address _ichiv1,\n        address _ichiFarm\n    ) external initializer {\n        __ERC1155_init(\"WIchiFarm\");\n        ICHI = IIchiV2(_ichi);\n        ICHIv1 = IERC20Upgradeable(_ichiv1);\n        ichiFarm = IIchiFarm(_ichiFarm);\n    }\n\n    /// @dev Encode pid, ichiPerShare to ERC1155 token id\n    /// @param pid Pool id (16-bit)\n    /// @param ichiPerShare Ichi amount per share, multiplied by 1e18 (240-bit)\n    function encodeId(uint256 pid, uint256 ichiPerShare)\n        public\n        pure\n        returns (uint256 id)\n    {\n        if (pid >= (1 << 16)) revert BAD_PID(pid);\n        if (ichiPerShare >= (1 << 240))\n            revert BAD_REWARD_PER_SHARE(ichiPerShare);\n        return (pid << 240) | ichiPerShare;\n    }\n\n    /// @dev Decode ERC1155 token id to pid, ichiPerShare\n    /// @param id Token id\n    function decodeId(uint256 id)\n        public\n        pure\n        returns (uint256 pid, uint256 ichiPerShare)\n    {\n        pid = id >> 240; // First 16 bits\n        ichiPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\n    /// @param id Token id\n    function getUnderlyingToken(uint256 id)\n        external\n        view\n        override\n        returns (address)\n    {\n        (uint256 pid, ) = decodeId(id);\n        return ichiFarm.lpToken(pid);\n    }\n\n    /// @dev Mint ERC1155 token for the given pool id.\n    /// @param pid Pool id\n    /// @param amount Token amount to wrap\n    /// @return The token id that got minted.\n    function mint(uint256 pid, uint256 amount)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        address lpToken = ichiFarm.lpToken(pid);\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        if (\n            IERC20Upgradeable(lpToken).allowance(\n                address(this),\n                address(ichiFarm)\n            ) != type(uint256).max\n        ) {\n            // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n            IERC20Upgradeable(lpToken).safeApprove(\n                address(ichiFarm),\n                type(uint256).max\n            );\n        }\n        ichiFarm.deposit(pid, amount, address(this));\n        (uint256 ichiPerShare, , ) = ichiFarm.poolInfo(pid);\n        uint256 id = encodeId(pid, ichiPerShare);\n        _mint(msg.sender, id, amount, \"\");\n        return id;\n    }\n\n    /// @dev Burn ERC1155 token to redeem LP ERC20 token back plus ICHI rewards.\n    /// @param id Token id\n    /// @param amount Token amount to burn\n    /// @return The pool id that that you will receive LP token back.\n    function burn(uint256 id, uint256 amount)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, uint256 stIchiPerShare) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n        ichiFarm.harvest(pid, address(this));\n        ichiFarm.withdraw(pid, amount, address(this));\n\n        // Convert Legacy ICHI to ICHI v2\n        if (ichiRewards > 0) {\n            ICHIv1.safeApprove(address(ICHI), ichiRewards);\n            ICHI.convertToV2(ichiRewards);\n        }\n\n        // Transfer LP Tokens\n        address lpToken = ichiFarm.lpToken(pid);\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n        uint256 stIchi = (stIchiPerShare * amount).divCeil(1e18);\n        uint256 enIchi = (enIchiPerShare * amount) / 1e18;\n\n        if (enIchi > stIchi) {\n            ICHI.safeTransfer(msg.sender, enIchi - stIchi);\n        }\n        return pid;\n    }\n}"
    },
    {
      "filename": "contracts/ichiFarmV2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"./lib/SignedSafeMath.sol\";\n\ncontract ichiFarmV2 is BoringOwnable, BoringBatchable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n    using SignedSafeMath for int256;\n\n    /// @notice Info of each IFV2 user.\n    /// `amount` LP token amount the user has provided.\n    /// `rewardDebt` The amount of ICHI entitled to the user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Info of each IFV2 pool.\n    /// `allocPoint` The amount of allocation points assigned to the pool.\n    /// Also known as the amount of ICHI to distribute per block.\n    struct PoolInfo {\n        uint128 accIchiPerShare;\n        uint64 lastRewardBlock;\n        uint64 allocPoint;\n    }\n\n    /// @dev Address of ICHI contract.\n    IERC20 private immutable ICHI;\n\n    /// @notice Info of each IFV2 pool.\n    PoolInfo[] public poolInfo;\n    /// @notice Address of the LP token for each IFV2 pool.\n    IERC20[] public lpToken;\n    /// @dev List of all added LP tokens.\n    mapping (address => bool) private addedLPs;\n\n    /// @notice Info of each user that stakes LP tokens.\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\n    /// @notice Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint;\n\n    /// @notice ICHI tokens created per block.\n    uint256 public ichiPerBlock;\n\n    /// @dev Extra decimals for pool's accIchiPerShare attribute. Needed in order to accomodate different types of LPs.\n    uint256 private constant ACC_ICHI_PRECISION = 1e18;\n\n    /// @dev nonReentrant flag used to secure functions with external calls.\n    bool private nonReentrant;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount);\n    event LogPoolAddition(uint256 indexed pid, uint256 allocPoint, IERC20 indexed lpToken);\n    event LogSetPool(uint256 indexed pid, uint256 allocPoint);\n    event LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accIchiPerShare);\n    event SetIchiPerBlock(uint256 ichiPerBlock, bool withUpdate);\n\n    /// @param _ichi The ICHI token contract address.\n    /// @param _ichiPerBlock ICHI tokens created per block.\n    constructor(IERC20 _ichi, uint256 _ichiPerBlock) public {\n        ICHI = _ichi;\n        ichiPerBlock = _ichiPerBlock;\n        totalAllocPoint = 0;\n    }\n\n    /// @notice Update number of ICHI tokens created per block. Can only be called by the owner.\n    /// @param _ichiPerBlock ICHI tokens created per block.\n    /// @param _withUpdate true if massUpdatePools should be triggered as well.\n    function setIchiPerBlock(uint256 _ichiPerBlock, bool _withUpdate) external onlyOwner {\n        if (_withUpdate) {\n            massUpdateAllPools();\n        }\n        ichiPerBlock = _ichiPerBlock;\n        emit SetIchiPerBlock(_ichiPerBlock, _withUpdate);\n    }\n\n    /// @notice Set the nonReentrant flag. Could be used to pause/resume the farm operations. Can only be called by the owner.\n    /// @param _val nonReentrant flag value to be set.\n    function setNonReentrant(bool _val) external onlyOwner returns (bool) {\n        nonReentrant = _val;\n        return nonReentrant;\n    }\n\n    /// @notice Returns the number of IFV2 pools.\n    function poolLength() external view returns (uint256 pools) {\n        pools = poolInfo.length;\n    }\n\n    /// @notice Returns the ICHI reward value for a specific pool.\n    function poolIchiReward(uint256 _pid) external view returns (uint256) {\n        if (totalAllocPoint == 0)\n            return 0;\n        return ichiPerBlock.mul(poolInfo[_pid].allocPoint) / totalAllocPoint;\n    }\n\n    /// @notice Returns the total number of LPs staked in the farm.\n    function getLPSupply(uint256 _pid) external view returns (uint256) {\n        uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\n        return lpSupply;\n    }\n\n    /// @notice Add a new LP to the pool. Can only be called by the owner.\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    /// @param allocPoint AP of the new pool.\n    /// @param _lpToken Address of the LP ERC-20 token.\n    function add(uint256 allocPoint, IERC20 _lpToken) external onlyOwner {\n        require(!addedLPs[address(_lpToken)], \"ichiFarmV2::there is already a pool with this LP\");\n        uint256 lastRewardBlock = block.number;\n        totalAllocPoint = totalAllocPoint.add(allocPoint);\n        lpToken.push(_lpToken);\n        addedLPs[address(_lpToken)] = true;\n\n        poolInfo.push(PoolInfo({\n            allocPoint: allocPoint.to64(),\n            lastRewardBlock: lastRewardBlock.to64(),\n            accIchiPerShare: 0\n        }));\n        emit LogPoolAddition(lpToken.length.sub(1), allocPoint, _lpToken);\n    }\n\n    /// @notice Update the given pool's ICHI allocation point. Can only be called by the owner.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @param _allocPoint New AP of the pool.\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\n        poolInfo[_pid].allocPoint = _allocPoint.to64();\n        emit LogSetPool(_pid, _allocPoint);\n    }\n\n    /// @notice View function to see pending ICHI on frontend.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending ICHI reward for a given user.\n    function pendingIchi(uint256 _pid, address _user) external view returns (uint256 pending) {\n        PoolInfo memory pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accIchiPerShare = pool.accIchiPerShare;\n        uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply > 0 && totalAllocPoint > 0) {\n            uint256 blocks = block.number.sub(pool.lastRewardBlock);\n            accIchiPerShare = accIchiPerShare.add(\n                (blocks.mul(ichiPerBlock).mul(pool.allocPoint).mul(ACC_ICHI_PRECISION) / totalAllocPoint) / lpSupply);\n        }\n        pending = int256(user.amount.mul(accIchiPerShare) / ACC_ICHI_PRECISION).sub(user.rewardDebt).toUInt256();\n    }\n\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\n    function massUpdateAllPools() public {\n        uint256 len = poolInfo.length;\n        for (uint256 pid = 0; pid < len; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    /// @notice Update reward variables for specified pools. Be careful of gas spending!\n    /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\n    function massUpdatePools(uint256[] calldata pids) external {\n        uint256 len = pids.length;\n        for (uint256 i = 0; i < len; ++i) {\n            updatePool(pids[i]);\n        }\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\n        pool = poolInfo[pid];\n        if (block.number > pool.lastRewardBlock) {\n            uint256 lpSupply = lpToken[pid].balanceOf(address(this));\n            if (lpSupply > 0 && totalAllocPoint > 0) {\n                uint256 blocks = block.number.sub(pool.lastRewardBlock);\n                pool.accIchiPerShare = pool.accIchiPerShare.add(\n                    ((blocks.mul(ichiPerBlock).mul(pool.allocPoint).mul(ACC_ICHI_PRECISION) / totalAllocPoint) / lpSupply).to128());\n            }\n            pool.lastRewardBlock = block.number.to64();\n            poolInfo[pid] = pool;\n            emit LogUpdatePool(pid, pool.lastRewardBlock, lpSupply, pool.accIchiPerShare);\n        }\n    }\n\n    /// @notice Deposit LP tokens to IFV2 for ICHI allocation.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param amount LP token amount to deposit.\n    /// @param to The receiver of `amount` deposit benefit.\n    function deposit(uint256 pid, uint256 amount, address to) external {\n        require(!nonReentrant, \"ichiFarmV2::nonReentrant - try again\");\n        nonReentrant = true;\n\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo storage user = userInfo[pid][to];\n\n        // Effects\n        user.amount = user.amount.add(amount);\n        user.rewardDebt = user.rewardDebt.add(int256(amount.mul(pool.accIchiPerShare) / ACC_ICHI_PRECISION));\n\n        // Interactions\n        lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Deposit(msg.sender, pid, amount, to);\n        nonReentrant = false;\n    }\n\n    /// @notice Withdraw LP tokens from IFV2.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param amount LP token amount to withdraw.\n    /// @param to Receiver of the LP tokens.\n    function withdraw(uint256 pid, uint256 amount, address to) external {\n        require(!nonReentrant, \"ichiFarmV2::nonReentrant - try again\");\n        nonReentrant = true;\n\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo storage user = userInfo[pid][msg.sender];\n\n        // Effects\n        user.rewardDebt = user.rewardDebt.sub(int256(amount.mul(pool.accIchiPerShare) / ACC_ICHI_PRECISION));\n        user.amount = user.amount.sub(amount);\n\n        // Interactions\n        lpToken[pid].safeTransfer(to, amount);\n\n        emit Withdraw(msg.sender, pid, amount, to);\n        nonReentrant = false;\n    }\n\n    /// @notice Harvest proceeds for transaction sender to `to`.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param to Receiver of ICHI rewards.\n    function harvest(uint256 pid, address to) external {\n        require(!nonReentrant, \"ichiFarmV2::nonReentrant - try again\");\n        nonReentrant = true;\n\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo storage user = userInfo[pid][msg.sender];\n        int256 accumulatedIchi = int256(user.amount.mul(pool.accIchiPerShare) / ACC_ICHI_PRECISION);\n        uint256 _pendingIchi = accumulatedIchi.sub(user.rewardDebt).toUInt256();\n\n        // Effects\n        user.rewardDebt = accumulatedIchi;\n\n        // Interactions\n        if (_pendingIchi > 0) {\n            ICHI.safeTransfer(to, _pendingIchi);\n        }\n\n        emit Harvest(msg.sender, pid, _pendingIchi);\n        nonReentrant = false;\n    }\n\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param to Receiver of the LP tokens.\n    function emergencyWithdraw(uint256 pid, address to) public {\n        require(address(0) != to, \"ichiFarmV2::can't withdraw to address zero\");\n        UserInfo storage user = userInfo[pid][msg.sender];\n        uint256 amount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n        // Note: transfer can fail or succeed if `amount` is zero.\n        lpToken[pid].safeTransfer(to, amount);\n        emit EmergencyWithdraw(msg.sender, pid, amount, to);\n    }\n}"
    }
  ]
}