{
  "Title": "[M-21] EIP1559 rewards received by syndicate during the period when it has no registered knots can be lost",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L218-L220\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L154-L157\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L597-L607\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L610-L627\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L174-L197\n\n\n# Vulnerability details\n\n## Impact\nWhen the `deRegisterKnotFromSyndicate` function is called by the DAO, the `_deRegisterKnot` function is eventually called to execute `numberOfRegisteredKnots -= 1`. It is possible that `numberOfRegisteredKnots` is reduced to 0. During the period when the syndicate has no registered knots, the EIP1559 rewards that are received by the syndicate remain in the syndicate since functions like `updateAccruedETHPerShares` do not include any logics for handling such rewards received by the syndicate. Later, when a new knot is registered and mints the derivatives, the node runner can call the `claimRewardsAsNodeRunner` function to receive half ot these rewards received by the syndicate during the period when it has no registered knots. Yet, because such rewards are received by the syndicate before the new knot mints the derivatives, the node runner should not be entitled to these rewards. Moreover, due to the issue mentioned in my other finding titled \"Staking Funds vault's LP holder cannot claim EIP1559 rewards after derivatives are minted for a new BLS public key that is not the first BLS public key registered for syndicate\", calling the `StakingFundsVault.claimRewards` function by the Staking Funds vault's LP holder reverts so the other half of such rewards is locked in the syndicate. Even if calling the `StakingFundsVault.claimRewards` function by the Staking Funds vault's LP holder does not revert, the Staking Funds vault's LP holder does not deserve the other half of such rewards because these rewards are received by the syndicate before the new knot mints the derivatives. Because these EIP1559 rewards received by the syndicate during the period when it has no registered knots can be unfairly sent to the node runner or remain locked in the syndicate, such rewards are lost.\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/LiquidStakingManager.sol#L218-L220\n```solidity\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n```\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L154-L157\n```solidity\n    function deRegisterKnots(bytes[] calldata _blsPublicKeys) external onlyOwner {\n        updateAccruedETHPerShares();\n        _deRegisterKnots(_blsPublicKeys);\n    }\n```\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L597-L607\n```solidity\n    function _deRegisterKnots(bytes[] calldata _blsPublicKeys) internal {\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            bytes memory blsPublicKey = _blsPublicKeys[i];\n\n            // Do one final snapshot of ETH owed to the collateralized SLOT owners so they can claim later\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(blsPublicKey);\n\n            // Execute the business logic for de-registering the single knot\n            _deRegisterKnot(blsPublicKey);\n        }\n    }\n```\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L610-L627\n```solidity\n    function _deRegisterKnot(bytes memory _blsPublicKey) internal {\n        if (isKnotRegistered[_blsPublicKey] == false) revert KnotIsNotRegisteredWithSyndicate();\n        if (isNoLongerPartOfSyndicate[_blsPublicKey] == true) revert KnotHasAlreadyBeenDeRegistered();\n\n        // We flag that the knot is no longer part of the syndicate\n        isNoLongerPartOfSyndicate[_blsPublicKey] = true;\n\n        // For the free floating and collateralized SLOT of the knot, snapshot the accumulated ETH per share\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] = accumulatedETHPerFreeFloatingShare;\n\n        // We need to reduce `totalFreeFloatingShares` in order to avoid further ETH accruing to shares of de-registered knot\n        totalFreeFloatingShares -= sETHTotalStakeForKnot[_blsPublicKey];\n\n        // Total number of registered knots with the syndicate reduces by one\n        numberOfRegisteredKnots -= 1;\n\n        emit KnotDeRegistered(_blsPublicKey);\n    }\n```\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L174-L197\n```solidity\n    function updateAccruedETHPerShares() public {\n        ...\n        if (numberOfRegisteredKnots > 0) {\n            ...\n        } else {\n            // todo - check else case for any ETH lost\n        }\n    }\n```\n\n## Proof of Concept\nPlease add the following code in `test\\foundry\\LiquidStakingManager.t.sol`.\n\n1. Import `stdError` as follows.\n```solidity\nimport { stdError } from \"forge-std/Test.sol\";\n```\n\n2. Add the following test. This test will pass to demonstrate the described scenario.\n```solidity\n    function testEIP1559RewardsReceivedBySyndicateDuringPeriodWhenItHasNoRegisteredKnotsCanBeLost() public {\n        // set up users and ETH\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n        // do everything from funding a validator within default LSDN to minting derivatives\n        depositStakeAndMintDerivativesForDefaultNetwork(\n            nodeRunner,\n            feesAndMevUser,\n            savETHUser,\n            blsPubKeyFour\n        );\n\n        // send the syndicate some EIP1559 rewards\n        uint256 eip1559Tips = 0.6743 ether;\n        (bool success, ) = manager.syndicate().call{value: eip1559Tips}(\"\");\n        assertEq(success, true);\n\n        // de-register the only knot from the syndicate to send sETH back to the smart wallet\n        IERC20 sETH = IERC20(MockSlotRegistry(factory.slot()).stakeHouseShareTokens(manager.stakehouse()));\n        uint256 sETHBalanceBefore = sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner));\n        vm.startPrank(admin);\n        manager.deRegisterKnotFromSyndicate(getBytesArrayFromBytes(blsPubKeyFour));\n        manager.restoreFreeFloatingSharesToSmartWalletForRageQuit(\n            manager.smartWalletOfNodeRunner(nodeRunner),\n            getBytesArrayFromBytes(blsPubKeyFour),\n            getUint256ArrayFromValues(12 ether)\n        );\n        vm.stopPrank();\n\n        assertEq(\n            sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner)) - sETHBalanceBefore,\n            12 ether\n        );\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // feesAndMevUser, who is the Staking Funds vault's LP holder, can claim rewards accrued up to the point of pulling the plug\n        vm.startPrank(feesAndMevUser);\n        stakingFundsVault.claimRewards(feesAndMevUser, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n\n        uint256 feesAndMevUserEthBalanceBefore = feesAndMevUser.balance;\n        assertEq(feesAndMevUserEthBalanceBefore, (eip1559Tips / 2) - 1);\n\n        // nodeRunner, who is the collateralized SLOT holder for blsPubKeyFour, can claim rewards accrued up to the point of pulling the plug\n        vm.startPrank(nodeRunner);\n        manager.claimRewardsAsNodeRunner(nodeRunner, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(nodeRunner.balance, (eip1559Tips / 2));\n\n        // more EIP1559 rewards are sent to the syndicate, which has no registered knot at this moment        \n        (success, ) = manager.syndicate().call{value: eip1559Tips}(\"\");\n        assertEq(success, true);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // calling the claimRewards function by feesAndMevUser has no effect at this moment\n        vm.startPrank(feesAndMevUser);\n        stakingFundsVault.claimRewards(feesAndMevUser, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(feesAndMevUser.balance, feesAndMevUserEthBalanceBefore);\n\n        // calling the claimRewardsAsNodeRunner function by nodeRunner reverts at this moment\n        vm.startPrank(nodeRunner);\n        vm.expectRevert(\"Nothing received\");\n        manager.claimRewardsAsNodeRunner(nodeRunner, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n\n        // however, the syndicate still holds the EIP1559 rewards received by it during the period when the only knot was de-registered\n        assertEq(manager.syndicate().balance, eip1559Tips + 1);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        vm.deal(nodeRunner, 4 ether);\n        vm.deal(feesAndMevUser, 4 ether);\n        vm.deal(savETHUser, 24 ether);\n\n        // For a different BLS public key, which is blsPubKeyTwo, \n        //   do everything from funding a validator within default LSDN to minting derivatives.\n        depositStakeAndMintDerivativesForDefaultNetwork(\n            nodeRunner,\n            feesAndMevUser,\n            savETHUser,\n            blsPubKeyTwo\n        );\n\n        // calling the claimRewards function by feesAndMevUser reverts at this moment\n        vm.startPrank(feesAndMevUser);\n        vm.expectRevert(stdError.arithmeticError);\n        stakingFundsVault.claimRewards(feesAndMevUser, getBytesArrayFromBytes(blsPubKeyTwo));\n        vm.stopPrank();\n\n        // Yet, calling the claimRewardsAsNodeRunner function by nodeRunner receives half of the EIP1559 rewards\n        //   received by the syndicate during the period when it has no registered knots.\n        // Because such rewards are not received by the syndicate after the derivatives are minted for blsPubKeyTwo,\n        //   nodeRunner does not deserve these for blsPubKeyTwo. \n        vm.startPrank(nodeRunner);\n        manager.claimRewardsAsNodeRunner(nodeRunner, getBytesArrayFromBytes(blsPubKeyTwo));\n        vm.stopPrank();\n        assertEq(nodeRunner.balance, eip1559Tips / 2);\n\n        // Still, half of the EIP1559 rewards that were received by the syndicate\n        //   during the period when the syndicate has no registered knots is locked in the syndicate.\n        assertEq(manager.syndicate().balance, eip1559Tips / 2 + 1);\n    }\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nThe `else` block of the `updateAccruedETHPerShares` function (https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/syndicate/Syndicate.sol#L194-L196) can be updated to include logics that handle the EIP1559 rewards received by the syndicate during the period when it has no registered knots.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/LiquidStakingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper)"
    }
  ]
}