{
  "Title": "[H01] Incorrect use of require in revokeVotes",
  "Content": "The [`revokeVotes` function](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L672) of the `Governance` contract is intended to revoke votes on proposals in the Referendum stage. However, it actually [`requires` all `dequeued` proposals to be in that stage](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L683), which is not necessary during normal operations. Whenever any element of `dequeued` is not within the `Referendum` stage, the `revokeVotes` function will revert. This effectively makes the `revokeVotes` function unusable.\n\n\nInstead of reverting, consider performing [the following operations](https://github.com/celo-org/celo-monorepo/blob/f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/contracts/governance/Governance.sol#L684-L688) if the proposal is within the `Referendum` stage. Otherwise, that iteration of the loop should be treated as a no-op.\n\n\n**Update:** *Fixed in commits [a10bdf3](https://github.com/celo-org/celo-monorepo/commit/a10bdf3e42ecb0667cbe98d287bac02c1da85e93) and [750341b](https://github.com/celo-org/celo-monorepo/commit/750341b6c62a0d8f2641fcbe841d03ed3c7d7ff2).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/Governance.sol",
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\nimport \"./interfaces/IGovernance.sol\";\nimport \"./Proposals.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../common/ExtractFunctionSignature.sol\";\nimport \"../common/InitializableV2.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/IntegerSortedLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title A contract for making, passing, and executing on-chain governance proposals.\n */\ncontract Governance is\n  IGovernance,\n  ICeloVersionedContract,\n  Ownable,\n  InitializableV2,\n  ReentrancyGuard,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using Proposals for Proposals.Proposal;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n  using IntegerSortedLinkedList for SortedLinkedList.List;\n  using BytesLib for bytes;\n  using Address for address payable; // prettier-ignore\n\n  uint256 private constant FIXED_HALF = 500000000000000000000000;\n\n  enum VoteValue { None, Abstain, No, Yes }\n\n  struct UpvoteRecord {\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct VoteRecord {\n    Proposals.VoteValue value;\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct Voter {\n    // Key of the proposal voted for in the proposal queue\n    UpvoteRecord upvote;\n    uint256 mostRecentReferendumProposal;\n    // Maps a `dequeued` index to a voter's vote record.\n    mapping(uint256 => VoteRecord) referendumVotes;\n  }\n\n  struct ContractConstitution {\n    FixidityLib.Fraction defaultThreshold;\n    // Maps a function ID to a corresponding threshold, overriding the default.\n    mapping(bytes4 => FixidityLib.Fraction) functionThresholds;\n  }\n\n  struct HotfixRecord {\n    bool executed;\n    bool approved;\n    uint256 preparedEpoch;\n    mapping(address => bool) whitelisted;\n  }\n\n  // The baseline is updated as\n  // max{floor, (1 - baselineUpdateFactor) * baseline + baselineUpdateFactor * participation}\n  struct ParticipationParameters {\n    // The average network participation in governance, weighted toward recent proposals.\n    FixidityLib.Fraction baseline;\n    // The lower bound on the participation baseline.\n    FixidityLib.Fraction baselineFloor;\n    // The weight of the most recent proposal's participation on the baseline.\n    FixidityLib.Fraction baselineUpdateFactor;\n    // The proportion of the baseline that constitutes quorum.\n    FixidityLib.Fraction baselineQuorumFactor;\n  }\n\n  Proposals.StageDurations public stageDurations;\n  uint256 public queueExpiry;\n  uint256 public dequeueFrequency;\n  address public approver;\n  uint256 public lastDequeue;\n  uint256 public concurrentProposals;\n  uint256 public proposalCount;\n  uint256 public minDeposit;\n  mapping(address => uint256) public refundedDeposits;\n  mapping(address => ContractConstitution) private constitution;\n  mapping(uint256 => Proposals.Proposal) private proposals;\n  mapping(address => Voter) private voters;\n  mapping(bytes32 => HotfixRecord) public hotfixes;\n  SortedLinkedList.List private queue;\n  uint256[] public dequeued;\n  uint256[] public emptyIndices;\n  ParticipationParameters private participationParameters;\n\n  event ApproverSet(address indexed approver);\n\n  event ConcurrentProposalsSet(uint256 concurrentProposals);\n\n  event MinDepositSet(uint256 minDeposit);\n\n  event QueueExpirySet(uint256 queueExpiry);\n\n  event DequeueFrequencySet(uint256 dequeueFrequency);\n\n  event ApprovalStageDurationSet(uint256 approvalStageDuration);\n\n  event ReferendumStageDurationSet(uint256 referendumStageDuration);\n\n  event ExecutionStageDurationSet(uint256 executionStageDuration);\n\n  event ConstitutionSet(address indexed destination, bytes4 indexed functionId, uint256 threshold);\n\n  event ProposalQueued(\n    uint256 indexed proposalId,\n    address indexed proposer,\n    uint256 transactionCount,\n    uint256 deposit,\n    uint256 timestamp\n  );\n\n  event ProposalUpvoted(uint256 indexed proposalId, address indexed account, uint256 upvotes);\n\n  event ProposalUpvoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 revokedUpvotes\n  );\n\n  event ProposalDequeued(uint256 indexed proposalId, uint256 timestamp);\n\n  event ProposalApproved(uint256 indexed proposalId);\n\n  event ProposalVoted(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalVoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalExecuted(uint256 indexed proposalId);\n\n  event ProposalExpired(uint256 indexed proposalId);\n\n  event ParticipationBaselineUpdated(uint256 participationBaseline);\n\n  event ParticipationFloorSet(uint256 participationFloor);\n\n  event ParticipationBaselineUpdateFactorSet(uint256 baselineUpdateFactor);\n\n  event ParticipationBaselineQuorumFactorSet(uint256 baselineQuorumFactor);\n\n  event HotfixWhitelisted(bytes32 indexed hash, address whitelister);\n\n  event HotfixApproved(bytes32 indexed hash);\n\n  event HotfixPrepared(bytes32 indexed hash, uint256 indexed epoch);\n\n  event HotfixExecuted(bytes32 indexed hash);\n\n  modifier hotfixNotExecuted(bytes32 hash) {\n    require(!hotfixes[hash].executed, \"hotfix already executed\");\n    _;\n  }\n\n  modifier onlyApprover() {\n    require(msg.sender == approver, \"msg.sender not approver\");\n    _;\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public InitializableV2(test) {}\n\n  function() external payable {\n    require(msg.data.length == 0, \"unknown method\");\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 2, 1, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry contract.\n   * @param _approver The address that needs to approve proposals to move to the referendum stage.\n   * @param _concurrentProposals The number of proposals to dequeue at once.\n   * @param _minDeposit The minimum CELO deposit needed to make a proposal.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param approvalStageDuration The number of seconds the approver has to approve a proposal\n   *   after it is dequeued.\n   * @param referendumStageDuration The number of seconds users have to vote on a dequeued proposal\n   *   after the approval stage ends.\n   * @param executionStageDuration The number of seconds users have to execute a passed proposal\n   *   after the referendum stage ends.\n   * @param participationBaseline The initial value of the participation baseline.\n   * @param participationFloor The participation floor.\n   * @param baselineUpdateFactor The weight of the new participation in the baseline update rule.\n   * @param baselineQuorumFactor The proportion of the baseline that constitutes quorum.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 approvalStageDuration,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setApprover(_approver);\n    setConcurrentProposals(_concurrentProposals);\n    setMinDeposit(_minDeposit);\n    setQueueExpiry(_queueExpiry);\n    setDequeueFrequency(_dequeueFrequency);\n    setApprovalStageDuration(approvalStageDuration);\n    setReferendumStageDuration(referendumStageDuration);\n    setExecutionStageDuration(executionStageDuration);\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n  /**\n   * @notice Updates the address that has permission to approve proposals in the approval stage.\n   * @param _approver The address that has permission to approve proposals in the approval stage.\n   */\n  function setApprover(address _approver) public onlyOwner {\n    require(_approver != address(0), \"Approver cannot be 0\");\n    require(_approver != approver, \"Approver unchanged\");\n    approver = _approver;\n    emit ApproverSet(_approver);\n  }\n\n  /**\n   * @notice Updates the number of proposals to dequeue at a time.\n   * @param _concurrentProposals The number of proposals to dequeue at at a time.\n   */\n  function setConcurrentProposals(uint256 _concurrentProposals) public onlyOwner {\n    require(_concurrentProposals > 0, \"Number of proposals must be larger than zero\");\n    require(_concurrentProposals != concurrentProposals, \"Number of proposals unchanged\");\n    concurrentProposals = _concurrentProposals;\n    emit ConcurrentProposalsSet(_concurrentProposals);\n  }\n\n  /**\n   * @notice Updates the minimum deposit needed to make a proposal.\n   * @param _minDeposit The minimum CELO deposit needed to make a proposal.\n   */\n  function setMinDeposit(uint256 _minDeposit) public onlyOwner {\n    require(_minDeposit > 0, \"minDeposit must be larger than 0\");\n    require(_minDeposit != minDeposit, \"Minimum deposit unchanged\");\n    minDeposit = _minDeposit;\n    emit MinDepositSet(_minDeposit);\n  }\n\n  /**\n   * @notice Updates the number of seconds before a queued proposal expires.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   */\n  function setQueueExpiry(uint256 _queueExpiry) public onlyOwner {\n    require(_queueExpiry > 0, \"QueueExpiry must be larger than 0\");\n    require(_queueExpiry != queueExpiry, \"QueueExpiry unchanged\");\n    queueExpiry = _queueExpiry;\n    emit QueueExpirySet(_queueExpiry);\n  }\n\n  /**\n   * @notice Updates the minimum number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   */\n  function setDequeueFrequency(uint256 _dequeueFrequency) public onlyOwner {\n    require(_dequeueFrequency > 0, \"dequeueFrequency must be larger than 0\");\n    require(_dequeueFrequency != dequeueFrequency, \"dequeueFrequency unchanged\");\n    dequeueFrequency = _dequeueFrequency;\n    emit DequeueFrequencySet(_dequeueFrequency);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the approval stage.\n   * @param approvalStageDuration The number of seconds proposals stay in the approval stage.\n   */\n  function setApprovalStageDuration(uint256 approvalStageDuration) public onlyOwner {\n    require(approvalStageDuration > 0, \"Duration must be larger than 0\");\n    require(approvalStageDuration != stageDurations.approval, \"Duration unchanged\");\n    stageDurations.approval = approvalStageDuration;\n    emit ApprovalStageDurationSet(approvalStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the referendum stage.\n   * @param referendumStageDuration The number of seconds proposals stay in the referendum stage.\n   */\n  function setReferendumStageDuration(uint256 referendumStageDuration) public onlyOwner {\n    require(referendumStageDuration > 0, \"Duration must be larger than 0\");\n    require(referendumStageDuration != stageDurations.referendum, \"Duration unchanged\");\n    stageDurations.referendum = referendumStageDuration;\n    emit ReferendumStageDurationSet(referendumStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the execution stage.\n   * @param executionStageDuration The number of seconds proposals stay in the execution stage.\n   */\n  function setExecutionStageDuration(uint256 executionStageDuration) public onlyOwner {\n    require(executionStageDuration > 0, \"Duration must be larger than 0\");\n    require(executionStageDuration != stageDurations.execution, \"Duration unchanged\");\n    stageDurations.execution = executionStageDuration;\n    emit ExecutionStageDurationSet(executionStageDuration);\n  }\n\n  /**\n   * @notice Updates the participation baseline.\n   * @param participationBaseline The value of the baseline.\n   */\n  function setParticipationBaseline(uint256 participationBaseline) public onlyOwner {\n    FixidityLib.Fraction memory participationBaselineFrac = FixidityLib.wrap(participationBaseline);\n    require(\n      FixidityLib.isProperFraction(participationBaselineFrac),\n      \"Participation baseline greater than one\"\n    );\n    require(\n      !participationBaselineFrac.equals(participationParameters.baseline),\n      \"Participation baseline unchanged\"\n    );\n    participationParameters.baseline = participationBaselineFrac;\n    emit ParticipationBaselineUpdated(participationBaseline);\n  }\n\n  /**\n   * @notice Updates the floor of the participation baseline.\n   * @param participationFloor The value at which the baseline is floored.\n   */\n  function setParticipationFloor(uint256 participationFloor) public onlyOwner {\n    FixidityLib.Fraction memory participationFloorFrac = FixidityLib.wrap(participationFloor);\n    require(\n      FixidityLib.isProperFraction(participationFloorFrac),\n      \"Participation floor greater than one\"\n    );\n    require(\n      !participationFloorFrac.equals(participationParameters.baselineFloor),\n      \"Participation baseline floor unchanged\"\n    );\n    participationParameters.baselineFloor = participationFloorFrac;\n    emit ParticipationFloorSet(participationFloor);\n  }\n\n  /**\n   * @notice Updates the weight of the new participation in the baseline update rule.\n   * @param baselineUpdateFactor The new baseline update factor.\n   */\n  function setBaselineUpdateFactor(uint256 baselineUpdateFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineUpdateFactorFrac = FixidityLib.wrap(baselineUpdateFactor);\n    require(\n      FixidityLib.isProperFraction(baselineUpdateFactorFrac),\n      \"Baseline update factor greater than one\"\n    );\n    require(\n      !baselineUpdateFactorFrac.equals(participationParameters.baselineUpdateFactor),\n      \"Baseline update factor unchanged\"\n    );\n    participationParameters.baselineUpdateFactor = baselineUpdateFactorFrac;\n    emit ParticipationBaselineUpdateFactorSet(baselineUpdateFactor);\n  }\n\n  /**\n   * @notice Updates the proportion of the baseline that constitutes quorum.\n   * @param baselineQuorumFactor The new baseline quorum factor.\n   */\n  function setBaselineQuorumFactor(uint256 baselineQuorumFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineQuorumFactorFrac = FixidityLib.wrap(baselineQuorumFactor);\n    require(\n      FixidityLib.isProperFraction(baselineQuorumFactorFrac),\n      \"Baseline quorum factor greater than one\"\n    );\n    require(\n      !baselineQuorumFactorFrac.equals(participationParameters.baselineQuorumFactor),\n      \"Baseline quorum factor unchanged\"\n    );\n    participationParameters.baselineQuorumFactor = baselineQuorumFactorFrac;\n    emit ParticipationBaselineQuorumFactorSet(baselineQuorumFactor);\n  }\n\n  /**\n   * @notice Updates the ratio of yes:yes+no votes needed for a specific class of proposals to pass.\n   * @param destination The destination of proposals for which this threshold should apply.\n   * @param functionId The function ID of proposals for which this threshold should apply. Zero\n   *   will set the default.\n   * @param threshold The threshold.\n   * @dev If no constitution is explicitly set the default is a simple majority, i.e. 1:2.\n   */\n  function setConstitution(address destination, bytes4 functionId, uint256 threshold)\n    external\n    onlyOwner\n  {\n    require(destination != address(0), \"Destination cannot be zero\");\n    require(\n      threshold > FIXED_HALF && threshold <= FixidityLib.fixed1().unwrap(),\n      \"Threshold has to be greater than majority and not greater than unanimity\"\n    );\n    if (functionId == 0) {\n      constitution[destination].defaultThreshold = FixidityLib.wrap(threshold);\n    } else {\n      constitution[destination].functionThresholds[functionId] = FixidityLib.wrap(threshold);\n    }\n    emit ConstitutionSet(destination, functionId, threshold);\n  }\n\n  /**\n   * @notice Creates a new proposal and adds it to end of the queue with no upvotes.\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @return The ID of the newly proposed proposal.\n   * @dev The minimum deposit must be included with the proposal, returned if/when the proposal is\n   *   dequeued.\n   */\n  function propose(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    string calldata descriptionUrl\n  ) external payable returns (uint256) {\n    dequeueProposalsIfReady();\n    require(msg.value >= minDeposit, \"Too small deposit\");\n\n    proposalCount = proposalCount.add(1);\n    Proposals.Proposal storage proposal = proposals[proposalCount];\n    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);\n    proposal.setDescriptionUrl(descriptionUrl);\n    queue.push(proposalCount);\n    // solhint-disable-next-line not-rely-on-time\n    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);\n    return proposalCount;\n  }\n\n  /**\n   * @notice Removes a proposal if it is queued and expired.\n   * @param proposalId The ID of the proposal to remove.\n   * @return Whether the proposal was removed.\n   */\n  function removeIfQueuedAndExpired(uint256 proposalId) private returns (bool) {\n    if (isQueued(proposalId) && isQueuedProposalExpired(proposalId)) {\n      queue.remove(proposalId);\n      emit ProposalExpired(proposalId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @notice Requires a proposal is dequeued and removes it if expired.\n   * @param proposalId The ID of the proposal.\n   * @return The proposal storage struct and stage corresponding to `proposalId`.\n   */\n  function requireDequeuedAndDeleteExpired(uint256 proposalId, uint256 index)\n    private\n    returns (Proposals.Proposal storage, Proposals.Stage)\n  {\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(_isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = proposal.getDequeuedStage(stageDurations);\n    if (_isDequeuedProposalExpired(proposal, stage)) {\n      deleteDequeuedProposal(proposal, proposalId, index);\n    }\n    return (proposal, stage);\n  }\n\n  /**\n   * @notice Upvotes a queued proposal.\n   * @param proposalId The ID of the proposal to upvote.\n   * @param lesser The ID of the proposal that will be just behind `proposalId` in the queue.\n   * @param greater The ID of the proposal that will be just ahead `proposalId` in the queue.\n   * @return Whether or not the upvote was made successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   * @dev Reverts if the account has already upvoted a proposal in the queue.\n   */\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n  /**\n   * @notice Returns stage of governance process given proposal is in\n   * @param proposalId The ID of the proposal to query.\n   * @return proposal stage\n   */\n  function getProposalStage(uint256 proposalId) external view returns (Proposals.Stage) {\n    if (proposalId == 0 || proposalId > proposalCount) {\n      return Proposals.Stage.None;\n    }\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    if (isQueued(proposalId)) {\n      return\n        _isQueuedProposalExpired(proposal) ? Proposals.Stage.Expiration : Proposals.Stage.Queued;\n    } else {\n      Proposals.Stage stage = proposal.getDequeuedStage(stageDurations);\n      return _isDequeuedProposalExpired(proposal, stage) ? Proposals.Stage.Expiration : stage;\n    }\n  }\n\n  /**\n   * @notice Revokes an upvote on a queued proposal.\n   * @param lesser The ID of the proposal that will be just behind the previously upvoted proposal\n   *   in the queue.\n   * @param greater The ID of the proposal that will be just ahead of the previously upvoted\n   *   proposal in the queue.\n   * @return Whether or not the upvote was revoked successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   */\n  function revokeUpvote(uint256 lesser, uint256 greater) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    uint256 proposalId = voter.upvote.proposalId;\n    require(proposalId != 0, \"Account has no historical upvote\");\n    removeIfQueuedAndExpired(proposalId);\n    if (queue.contains(proposalId)) {\n      queue.update(\n        proposalId,\n        queue.getValue(proposalId).sub(voter.upvote.weight),\n        lesser,\n        greater\n      );\n      emit ProposalUpvoteRevoked(proposalId, account, voter.upvote.weight);\n    }\n    voter.upvote = UpvoteRecord(0, 0);\n    return true;\n  }\n\n  /**\n   * @notice Approves a proposal in the approval stage.\n   * @param proposalId The ID of the proposal to approve.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the approval was made successfully.\n   */\n  function approve(uint256 proposalId, uint256 index) external onlyApprover returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(!proposal.isApproved(), \"Proposal already approved\");\n    require(stage == Proposals.Stage.Approval, \"Proposal not in approval stage\");\n    proposal.approved = true;\n    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    emit ProposalApproved(proposalId);\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param value Whether to vote yes, no, or abstain.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(proposal.isApproved(), \"Proposal not approved\");\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n    require(weight > 0, \"Voter weight zero\");\n    VoteRecord storage voteRecord = voter.referendumVotes[index];\n    proposal.updateVote(\n      voteRecord.weight,\n      weight,\n      (voteRecord.proposalId == proposalId) ? voteRecord.value : Proposals.VoteValue.None,\n      value\n    );\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    voter.referendumVotes[index] = VoteRecord(value, proposalId, weight);\n    if (proposal.timestamp > proposals[voter.mostRecentReferendumProposal].timestamp) {\n      voter.mostRecentReferendumProposal = proposalId;\n    }\n    emit ProposalVoted(proposalId, account, uint256(value), weight);\n    return true;\n  }\n\n  /* solhint-enable code-complexity */\n\n  /**\n   * @notice Revoke votes on all proposal of sender in the referendum stage.\n   * @return Whether or not all votes of an account was successfully revoked.\n   */\n  function revokeVotes() external nonReentrant returns (bool) {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    for (\n      uint256 dequeueIndex = 0;\n      dequeueIndex < dequeued.length;\n      dequeueIndex = dequeueIndex.add(1)\n    ) {\n      VoteRecord storage voteRecord = voter.referendumVotes[dequeueIndex];\n      (Proposals.Proposal storage proposal, Proposals.Stage stage) =\n        requireDequeuedAndDeleteExpired(voteRecord.proposalId, dequeueIndex); // prettier-ignore\n      require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n      Proposals.VoteValue value = voteRecord.value;\n      proposal.updateVote(voteRecord.weight, 0, value, Proposals.VoteValue.None);\n      proposal.networkWeight = getLockedGold().getTotalLockedGold();\n      emit ProposalVoteRevoked(voteRecord.proposalId, account, uint256(value), voteRecord.weight);\n      delete voter.referendumVotes[dequeueIndex];\n    }\n    voter.mostRecentReferendumProposal = 0;\n    return true;\n  }\n\n  /**\n   * @notice Executes a proposal in the execution stage, removing it from `dequeued`.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the proposal was executed successfully.\n   * @dev Does not remove the proposal if the execution fails.\n   */\n  function execute(uint256 proposalId, uint256 index) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    bool notExpired = proposal.exists();\n    if (notExpired) {\n      require(\n        stage == Proposals.Stage.Execution && _isProposalPassing(proposal),\n        \"Proposal not in execution stage or not passing\"\n      );\n      proposal.execute();\n      emit ProposalExecuted(proposalId);\n      deleteDequeuedProposal(proposal, proposalId, index);\n    }\n    return notExpired;\n  }\n\n  /**\n   * @notice Approves the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be approved.\n   */\n  function approveHotfix(bytes32 hash) external hotfixNotExecuted(hash) onlyApprover {\n    hotfixes[hash].approved = true;\n    emit HotfixApproved(hash);\n  }\n\n  /**\n   * @notice Returns whether given hotfix hash has been whitelisted by given address.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   * @param whitelister Address to check whitelist status of.\n   */\n  function isHotfixWhitelistedBy(bytes32 hash, address whitelister) public view returns (bool) {\n    return hotfixes[hash].whitelisted[whitelister];\n  }\n\n  /**\n   * @notice Whitelists the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   */\n  function whitelistHotfix(bytes32 hash) external hotfixNotExecuted(hash) {\n    hotfixes[hash].whitelisted[msg.sender] = true;\n    emit HotfixWhitelisted(hash, msg.sender);\n  }\n\n  /**\n   * @notice Gives hotfix a prepared epoch for execution.\n   * @param hash The hash of the hotfix to be prepared.\n   */\n  function prepareHotfix(bytes32 hash) external hotfixNotExecuted(hash) {\n    require(isHotfixPassing(hash), \"hotfix not whitelisted by 2f+1 validators\");\n    uint256 epoch = getEpochNumber();\n    require(hotfixes[hash].preparedEpoch < epoch, \"hotfix already prepared for this epoch\");\n    hotfixes[hash].preparedEpoch = epoch;\n    emit HotfixPrepared(hash, epoch);\n  }\n\n  /**\n   * @notice Executes a whitelisted proposal.\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @param salt Arbitrary salt associated with hotfix which guarantees uniqueness of hash.\n   * @dev Reverts if hotfix is already executed, not approved, or not prepared for current epoch.\n   */\n  function executeHotfix(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    bytes32 salt\n  ) external {\n    bytes32 hash = keccak256(abi.encode(values, destinations, data, dataLengths, salt));\n\n    (bool approved, bool executed, uint256 preparedEpoch) = getHotfixRecord(hash);\n    require(!executed, \"hotfix already executed\");\n    require(approved, \"hotfix not approved\");\n    require(preparedEpoch == getEpochNumber(), \"hotfix must be prepared for this epoch\");\n\n    Proposals.makeMem(values, destinations, data, dataLengths, msg.sender, 0).executeMem();\n\n    hotfixes[hash].executed = true;\n    emit HotfixExecuted(hash);\n  }\n\n  /**\n   * @notice Withdraws refunded CELO deposits.\n   * @return Whether or not the withdraw was successful.\n   */\n  function withdraw() external nonReentrant returns (bool) {\n    uint256 value = refundedDeposits[msg.sender];\n    require(value > 0, \"Nothing to withdraw\");\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    refundedDeposits[msg.sender] = 0;\n    msg.sender.sendValue(value);\n    return true;\n  }\n\n  /**\n   * @notice Returns whether or not a particular account is voting on proposals.\n   * @param account The address of the account.\n   * @return Whether or not the account is voting on proposals.\n   */\n  function isVoting(address account) external view returns (bool) {\n    Voter storage voter = voters[account];\n    uint256 upvotedProposal = voter.upvote.proposalId;\n    bool isVotingQueue = upvotedProposal != 0 &&\n      isQueued(upvotedProposal) &&\n      !isQueuedProposalExpired(upvotedProposal);\n    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];\n    bool isVotingReferendum = (proposal.getDequeuedStage(stageDurations) ==\n      Proposals.Stage.Referendum);\n    return isVotingQueue || isVotingReferendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in approval stage.\n   * @return The number of seconds proposals stay in approval stage.\n   */\n  function getApprovalStageDuration() external view returns (uint256) {\n    return stageDurations.approval;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the referendum stage.\n   * @return The number of seconds proposals stay in the referendum stage.\n   */\n  fu"
    }
  ]
}