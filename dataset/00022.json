{
  "Title": "Merkle Tree related contracts will be subject to Cross Chain Replay attacks",
  "Content": "# Merkle Tree related contracts will be subject to Cross Chain Replay attacks\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/SablierV2MerkleLT.sol#L86\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/SablierV2MerkleLT.sol#L86</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/SablierV2MerkleLL.sol#L71\">https://github.com/Cyfrin/2024-05-Sablier/blob/43d7e752a68bba2a1d73d3d6466c3059079ed0c6/v2-periphery/src/SablierV2MerkleLL.sol#L71</a>\n\n\n## Summary\nConsidering Sablier is compatible with any evm chain, this unfortunately opens up the below scenario.\nIn multi-chain deployments, the claim function in the SablierV2MerkleLL & SablierV2MerkleLT contract is vulnerable to front-running and Cross Chain replay attacks.\n\n## Vulnerability Details\nThe claim function in SablierV2MerkleLL relies on Merkle proofs to validate claims. The function generates a Merkle tree leaf by hashing the claim parameters, which are then checked against the Merkle root.\n\n```\nfunction claim(uint256 index, address recipient, uint128 amount, bytes32[] calldata merkleProof)\n    external override returns (uint256 streamId) {\n    // Generate the Merkle tree leaf by hashing the corresponding parameters.\n    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(index, recipient, amount))));\n\n    // Check: validate the function.\n    _checkClaim(index, leaf, merkleProof);\n\n    // Effect: mark the index as claimed.\n    _claimedBitMap.set(index);\n\n    // Interaction: create the stream via {SablierV2LockupLinear}.\n    streamId = LOCKUP_LINEAR.createWithDurations(\n        LockupLinear.CreateWithDurations({\n            sender: admin,\n            recipient: recipient,\n            totalAmount: amount,\n            asset: ASSET,\n            cancelable: CANCELABLE,\n            transferable: TRANSFERABLE,\n            durations: streamDurations,\n            broker: Broker({ account: address(0), fee: ud(0) })\n        })\n    );\n\n    // Log the claim.\n    emit Claim(index, recipient, amount, streamId);\n}\n```\n\nMulti-Chain Deployment and Forks:\n\nThe SablierV2MerkleLL contract is designed to be deployed on multiple EVM-compatible chains. \nThis creates a risk scenario where the same Merkle proof could be used to claim tokens on different chains or forks.\n\n\nAn attacker monitors the mempool across different chains. When a recipient submits a claim transaction on one chain, the attacker replicates it on another chain where the contract is also deployed. This allows the attacker to potentially claim tokens on the other chain before the legitimate recipient.\n\n\nDuring a chain fork, the attacker monitors transactions on the shorter fork. If a recipientâ€™s claim transaction appears on the shorter fork, the attacker can replicate it on the longer fork. The attacker's transaction on the longer fork is processed, allowing them to claim tokens before the legitimate recipient when the shorter fork is discarded.\n\n\n## Impact\nIf a claim is made with an incorrect recipient address due to differences across chains, the tokens will be lost or misdirected.\n\n## Tools Used\nFoundry\n\n## Recommendations\nEIP-712 Signatures.\n\nUse EIP-712 signatures to ensure each claim is unique to the specific chain and contract. This prevents attackers from replaying transactions across different chains.\n\n```\n// Example EIP-712 implementation\nbytes32 domainSeparator = keccak256(\n    abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n        keccak256(bytes(\"SablierV2MerkleLL\")),\n        keccak256(bytes(\"1\")),\n        block.chainid,\n        address(this)\n    )\n);\n\nbytes32 structHash = keccak256(\n    abi.encode(\n        keccak256(\"Claim(uint256 index,address recipient,uint128 amount)\"),\n        index,\n        recipient,\n        amount\n    )\n);\n\nbytes32 digest = keccak256(\n    abi.encodePacked(\n        \"\\x19\\x01\",\n        domainSeparator,\n        structHash\n    )\n);\n\naddress signer = ecrecover(digest, v, r, s);\nrequire(signer == recipient, \"Invalid signature\");\n```\n\nChain ID Verification\nInclude chain ID verification within the claim function to ensure that claims are only valid on the intended chain.\n\n```\nfunction claim(uint256 index, address recipient, uint128 amount, bytes32[] calldata merkleProof, uint256 chainId)\n    external override returns (uint256 streamId) {\n    require(chainId == block.chainid, \"Invalid chain ID\");\n\n    // Generate the Merkle tree leaf by hashing the corresponding parameters.\n    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(index, recipient, amount, chainId))));\n\n    // Check: validate the function.\n    _checkClaim(index, leaf, merkleProof);\n\n    // ... rest of the logic\n}\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clvb9njmy00012dqjyaavpl44",
  "Code": [
    {
      "filename": "v2-periphery/src/SablierV2MerkleLT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.22;\n\nimport { BitMaps } from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { UD60x18, ud60x18, ZERO } from \"@prb/math/src/UD60x18.sol\";\nimport { ISablierV2LockupTranched } from \"@sablier/v2-core/src/interfaces/ISablierV2LockupTranched.sol\";\nimport { Broker, LockupTranched } from \"@sablier/v2-core/src/types/DataTypes.sol\";\n\nimport { SablierV2MerkleLockup } from \"./abstracts/SablierV2MerkleLockup.sol\";\nimport { ISablierV2MerkleLT } from \"./interfaces/ISablierV2MerkleLT.sol\";\nimport { MerkleLockup, MerkleLT } from \"./types/DataTypes.sol\";\n\n/// @title SablierV2MerkleLT\n/// @notice See the documentation in {ISablierV2MerkleLT}.\ncontract SablierV2MerkleLT is\n    ISablierV2MerkleLT, // 2 inherited components\n    SablierV2MerkleLockup // 4 inherited components\n{\n    using BitMaps for BitMaps.BitMap;\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLT\n    ISablierV2LockupTranched public immutable override LOCKUP_TRANCHED;\n\n    /// @dev The tranches with their respective unlock percentages and durations.\n    MerkleLT.TrancheWithPercentage[] internal _tranchesWithPercentages;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructs the contract by initializing the immutable state variables, and max approving the Sablier\n    /// contract.\n    constructor(\n        MerkleLockup.ConstructorParams memory baseParams,\n        ISablierV2LockupTranched lockupTranched,\n        MerkleLT.TrancheWithPercentage[] memory tranchesWithPercentages\n    )\n        SablierV2MerkleLockup(baseParams)\n    {\n        LOCKUP_TRANCHED = lockupTranched;\n\n        // Since Solidity lacks a syntax for copying arrays of structs directly from memory to storage, a manual\n        // approach is necessary. See https://github.com/ethereum/solidity/issues/12783.\n        uint256 count = tranchesWithPercentages.length;\n        for (uint256 i = 0; i < count; ++i) {\n            _tranchesWithPercentages.push(tranchesWithPercentages[i]);\n        }\n\n        // Max approve the Sablier contract to spend funds from the MerkleLockup contract.\n        ASSET.forceApprove(address(LOCKUP_TRANCHED), type(uint256).max);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                           USER-FACING CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLT\n    function getTranchesWithPercentages() external view override returns (MerkleLT.TrancheWithPercentage[] memory) {\n        return _tranchesWithPercentages;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLT\n    function claim(\n        uint256 index,\n        address recipient,\n        uint128 amount,\n        bytes32[] calldata merkleProof\n    )\n        external\n        override\n        returns (uint256 streamId)\n    {\n        // Generate the Merkle tree leaf by hashing the corresponding parameters. Hashing twice prevents second\n        // preimage attacks.\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(index, recipient, amount))));\n\n        // Check: validate the function.\n        _checkClaim(index, leaf, merkleProof);\n\n        // Calculate the tranches based on the unlock percentages.\n        LockupTranched.TrancheWithDuration[] memory tranches = _calculateTranches(amount);\n\n        // Effect: mark the index as claimed.\n        _claimedBitMap.set(index);\n\n        // Interaction: create the stream via {SablierV2LockupTranched}.\n        streamId = LOCKUP_TRANCHED.createWithDurations(\n            LockupTranched.CreateWithDurations({\n                sender: admin,\n                recipient: recipient,\n                totalAmount: amount,\n                asset: ASSET,\n                cancelable: CANCELABLE,\n                transferable: TRANSFERABLE,\n                tranches: tranches,\n                broker: Broker({ account: address(0), fee: ZERO })\n            })\n        );\n\n        // Log the claim.\n        emit Claim(index, recipient, amount, streamId);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                            INTERNAL CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Calculates the tranches based on the claim amount and the unlock percentages for each tranche.\n    function _calculateTranches(uint128 claimAmount)\n        internal\n        view\n        returns (LockupTranched.TrancheWithDuration[] memory tranches)\n    {\n        // Load the tranches in memory (to save gas).\n        MerkleLT.TrancheWithPercentage[] memory tranchesWithPercentages = _tranchesWithPercentages;\n\n        // Declare the variables needed for calculation.\n        uint128 calculatedAmountsSum;\n        UD60x18 claimAmountUD = ud60x18(claimAmount);\n        uint256 trancheCount = tranchesWithPercentages.length;\n        tranches = new LockupTranched.TrancheWithDuration[](trancheCount);\n\n        // Iterate over each tranche to calculate its unlock amount.\n        for (uint256 i = 0; i < trancheCount; ++i) {\n            // Convert the tranche's percentage from the `UD2x18` to the `UD60x18` type.\n            UD60x18 percentage = (tranchesWithPercentages[i].unlockPercentage).intoUD60x18();\n\n            // Calculate the tranche's amount by multiplying the claim amount by the unlock percentage.\n            uint128 calculatedAmount = claimAmountUD.mul(percentage).intoUint128();\n\n            // Create the tranche with duration.\n            tranches[i] = LockupTranched.TrancheWithDuration({\n                amount: calculatedAmount,\n                duration: tranchesWithPercentages[i].duration\n            });\n\n            // Add the calculated tranche amount.\n            calculatedAmountsSum += calculatedAmount;\n        }\n\n        // It should never be the case that the sum of the calculated amounts is greater than the claim amount because\n        // PRBMath always rounds down.\n        assert(calculatedAmountsSum <= claimAmount);\n\n        // Since there can be rounding errors, the last tranche amount needs to be adjusted to ensure the sum of all\n        // tranche amounts equals the claim amount.\n        if (calculatedAmountsSum < claimAmount) {\n            unchecked {\n                tranches[trancheCount - 1].amount += claimAmount - calculatedAmountsSum;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "v2-periphery/src/SablierV2MerkleLL.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.22;\n\nimport { BitMaps } from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ud } from \"@prb/math/src/UD60x18.sol\";\nimport { ISablierV2LockupLinear } from \"@sablier/v2-core/src/interfaces/ISablierV2LockupLinear.sol\";\nimport { Broker, LockupLinear } from \"@sablier/v2-core/src/types/DataTypes.sol\";\n\nimport { SablierV2MerkleLockup } from \"./abstracts/SablierV2MerkleLockup.sol\";\nimport { ISablierV2MerkleLL } from \"./interfaces/ISablierV2MerkleLL.sol\";\nimport { MerkleLockup } from \"./types/DataTypes.sol\";\n\n/// @title SablierV2MerkleLL\n/// @notice See the documentation in {ISablierV2MerkleLL}.\ncontract SablierV2MerkleLL is\n    ISablierV2MerkleLL, // 2 inherited components\n    SablierV2MerkleLockup // 4 inherited components\n{\n    using BitMaps for BitMaps.BitMap;\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                  STATE VARIABLES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLL\n    ISablierV2LockupLinear public immutable override LOCKUP_LINEAR;\n\n    /// @inheritdoc ISablierV2MerkleLL\n    LockupLinear.Durations public override streamDurations;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Constructs the contract by initializing the immutable state variables, and max approving the Sablier\n    /// contract.\n    constructor(\n        MerkleLockup.ConstructorParams memory baseParams,\n        ISablierV2LockupLinear lockupLinear,\n        LockupLinear.Durations memory streamDurations_\n    )\n        SablierV2MerkleLockup(baseParams)\n    {\n        LOCKUP_LINEAR = lockupLinear;\n        streamDurations = streamDurations_;\n\n        // Max approve the Sablier contract to spend funds from the MerkleLockup contract.\n        ASSET.forceApprove(address(LOCKUP_LINEAR), type(uint256).max);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                         USER-FACING NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ISablierV2MerkleLL\n    function claim(\n        uint256 index,\n        address recipient,\n        uint128 amount,\n        bytes32[] calldata merkleProof\n    )\n        external\n        override\n        returns (uint256 streamId)\n    {\n        // Generate the Merkle tree leaf by hashing the corresponding parameters. Hashing twice prevents second\n        // preimage attacks.\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(index, recipient, amount))));\n\n        // Check: validate the function.\n        _checkClaim(index, leaf, merkleProof);\n\n        // Effect: mark the index as claimed.\n        _claimedBitMap.set(index);\n\n        // Interaction: create the stream via {SablierV2LockupLinear}.\n        streamId = LOCKUP_LINEAR.createWithDurations(\n            LockupLinear.CreateWithDurations({\n                sender: admin,\n                recipient: recipient,\n                totalAmount: amount,\n                asset: ASSET,\n                cancelable: CANCELABLE,\n                transferable: TRANSFERABLE,\n                durations: streamDurations,\n                broker: Broker({ account: address(0), fee: ud(0) })\n            })\n        );\n\n        // Log the claim.\n        emit Claim(index, recipient, amount, streamId);\n    }\n}"
    }
  ]
}