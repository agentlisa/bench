{
  "Title": "[H-06] `ConcentratedLiquidityPosition.sol#collect()` Users may get double the amount of yield when they call `collect()` before `burn()`",
  "Content": "_Submitted by WatchPug_\n\nWhen a user calls `ConcentratedLiquidityPosition.sol#collect()` to collect their yield, it calcuates the yield based on `position.pool.rangeFeeGrowth()` and `position.feeGrowthInside0, position.feeGrowthInside1`:\n\n[`ConcentratedLiquidityPosition.sol#L75` L101](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L75-L101)\n\nWhen there are enough tokens in `bento.balanceOf`, it will not call `position.pool.collect()` to collect fees from the pool.\n\nThis makes the user who `collect()` their yield when there is enough balance to get double yield when they call `burn()` to remove liquidity. Because `burn()` will automatically collect fees on the pool contract.\n\n#### Impact\nThe yield belongs to other users will be diluted.\n\n#### Recommended Mitigation Steps\nConsider making `ConcentratedLiquidityPosition.sol#burn()` call `position.pool.collect()` before `position.pool.burn()`. User will need to call `ConcentratedLiquidityPosition.sol#collect()` to collect unclaimed fees after `burn()`.\n\nOr `ConcentratedLiquidityPosition.sol#collect()` can be changed into a `public` method and `ConcentratedLiquidityPosition.sol#burn()` can call it after `position.pool.burn()`.\n\n**[sarangparikh22 (Sushi) confirmed](https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/53)**\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-09-sushitrident-2",
  "Code": [
    {
      "filename": "contracts/pool/concentrated/ConcentratedLiquidityPosition.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"../../interfaces/IMasterDeployer.sol\";\nimport \"../../interfaces/ITridentRouter.sol\";\nimport \"../../libraries/concentratedPool/FullMath.sol\";\nimport \"./TridentNFT.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\nabstract contract ConcentratedLiquidityPosition is TridentNFT {\n    event Mint(address indexed pool, address indexed recipient, uint256 indexed positionId);\n    event Burn(address indexed pool, address indexed owner, uint256 indexed positionId);\n\n    address public immutable wETH;\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n\n    mapping(uint256 => Position) public positions;\n\n    struct Position {\n        IConcentratedLiquidityPool pool;\n        uint128 liquidity;\n        int24 lower;\n        int24 upper;\n        uint256 feeGrowthInside0; /// @dev Per unit of liquidity.\n        uint256 feeGrowthInside1;\n    }\n\n    constructor(address _wETH, address _masterDeployer) {\n        wETH = _wETH;\n        masterDeployer = IMasterDeployer(_masterDeployer);\n        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());\n    }\n\n    function positionMintCallback(\n        address recipient,\n        int24 lower,\n        int24 upper,\n        uint128 amount,\n        uint256 feeGrowthInside0,\n        uint256 feeGrowthInside1\n    ) external returns (uint256 positionId) {\n        require(IMasterDeployer(masterDeployer).pools(msg.sender), \"NOT_POOL\");\n        positions[totalSupply] = Position(IConcentratedLiquidityPool(msg.sender), amount, lower, upper, feeGrowthInside0, feeGrowthInside1);\n        positionId = totalSupply;\n        _mint(recipient);\n        emit Mint(msg.sender, recipient, positionId);\n    }\n\n    function burn(\n        uint256 tokenId,\n        uint128 amount,\n        address recipient,\n        bool unwrapBento\n    ) external {\n        require(msg.sender == ownerOf[tokenId], \"NOT_ID_OWNER\");\n        Position storage position = positions[tokenId];\n        if (position.liquidity < amount) amount = position.liquidity;\n\n        position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento));\n\n        if (amount < position.liquidity) {\n            position.liquidity -= amount;\n        } else {\n            delete positions[tokenId];\n            _burn(tokenId);\n        }\n        emit Burn(address(position.pool), msg.sender, tokenId);\n    }\n\n    function collect(\n        uint256 tokenId,\n        address recipient,\n        bool unwrapBento\n    ) external returns (uint256 token0amount, uint256 token1amount) {\n        require(msg.sender == ownerOf[tokenId], \"NOT_ID_OWNER\");\n\n        Position storage position = positions[tokenId];\n\n        (address token0, address token1) = _getAssets(position.pool);\n\n        {\n            (uint256 feeGrowthInside0, uint256 feeGrowthInside1) = position.pool.rangeFeeGrowth(position.lower, position.upper);\n            token0amount = FullMath.mulDiv(\n                feeGrowthInside0 - position.feeGrowthInside0,\n                position.liquidity,\n                0x100000000000000000000000000000000\n            );\n            token1amount = FullMath.mulDiv(\n                feeGrowthInside1 - position.feeGrowthInside1,\n                position.liquidity,\n                0x100000000000000000000000000000000\n            );\n\n            position.feeGrowthInside0 = feeGrowthInside0;\n            position.feeGrowthInside1 = feeGrowthInside1;\n        }\n\n        uint256 balance0 = bento.balanceOf(token0, address(this));\n        uint256 balance1 = bento.balanceOf(token1, address(this));\n        if (balance0 < token0amount || balance1 < token1amount) {\n            (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);\n\n            uint256 newBalance0 = amount0fees + balance0;\n            uint256 newBalance1 = amount1fees + balance1;\n\n            /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw\n            if (token0amount > newBalance0) token0amount = newBalance0;\n            if (token1amount > newBalance1) token1amount = newBalance1;\n        }\n        _transfer(token0, address(this), recipient, token0amount, unwrapBento);\n        _transfer(token1, address(this), recipient, token1amount, unwrapBento);\n    }\n\n    function _getAssets(IConcentratedLiquidityPool pool) internal view returns (address token0, address token1) {\n        address[] memory pair = pool.getAssets();\n        token0 = pair[0];\n        token1 = pair[1];\n    }\n\n    function _transfer(\n        address token,\n        address from,\n        address to,\n        uint256 shares,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, from, to, 0, shares);\n        } else {\n            bento.transfer(token, from, to, shares);\n        }\n    }\n}"
    }
  ]
}