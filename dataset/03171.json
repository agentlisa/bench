{
  "Title": "[H01] Incorrect prefund calculation [core]",
  "Content": "In order to ensure a user operation can be financed, the maximum amount of gas it could consume is calculated. This depends on the individual gas limits specified in the transaction. Since the paymaster may use `verificationGas` to limit up to three function calls, operations that have a paymaster should multiply `verificationGas` by 3 when calculating the maximum gas. However, the [calculation is inverted](https://github.com/eth-infinitism/account-abstraction/blob/8832d6e04b9f4f706f612261c6e46b3f1745d61a/contracts/UserOperation.sol#L46). This means that valid user operations could fail in two ways:\n\n\n* Operations that do not rely on paymasters will be initially overcharged, and the wallet may have insufficient funds to proceed. It should be noted that wallets with sufficient funds will still have any unused gas (including the overcharge) refunded after the operation is executed.\n* Paymasters that are insufficently staked may nevertheless pass validation, which introduces the possibility that they will be unable to fund the operation. In practice, the excess funds will probably simply be deducted from their stake. Even so, this allows users to craft operations that would unexpectedly cause the paymaster to become unstaked.\n\n\nConsider updating the maximum gas calculation to match the execution behavior.\n\n\n***Update**: Fixed in pull request [#51](https://github.com/eth-infinitism/account-abstraction/pull/51/files).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/UserOperation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.7;\n\nimport \"hardhat/console.sol\";\n\n    struct UserOperation {\n\n        address sender;\n        uint256 nonce;\n        bytes initCode;\n        bytes callData;\n        uint callGas;\n        uint verificationGas;\n        uint preVerificationGas;\n        uint maxFeePerGas;\n        uint maxPriorityFeePerGas;\n        address paymaster;\n        bytes paymasterData;\n        bytes signature;\n    }\n\nlibrary UserOperationLib {\n\n    function getSender(UserOperation calldata userOp) internal pure returns (address ret) {\n        assembly {ret := calldataload(userOp)}\n    }\n\n    //relayer/miner might submit the TX with higher priorityFee, but the user should not\n    // pay above what he signed for.\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint) {\n    unchecked {\n        uint maxFeePerGas = userOp.maxFeePerGas;\n        uint maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        if (maxFeePerGas == maxPriorityFeePerGas) {\n            //legacy mode (for networks that don't support basefee opcode)\n            return min(tx.gasprice, maxFeePerGas);\n        }\n        return min(tx.gasprice, min(maxFeePerGas, maxPriorityFeePerGas + block.basefee));\n    }\n    }\n\n    function requiredGas(UserOperation calldata userOp) internal pure returns (uint) {\n    unchecked {\n        //when using a Paymaster, the verificationGas is used also to cover the postOp call.\n        // our security model might call postOp eventually twice\n        uint mul = userOp.paymaster != address(0) ? 1 : 3;\n        return userOp.callGas + userOp.verificationGas * mul + userOp.preVerificationGas;\n    }\n    }\n\n    function requiredPreFund(UserOperation calldata userOp) internal view returns (uint prefund) {\n    unchecked {\n        return requiredGas(userOp) * gasPrice(userOp);\n    }\n    }\n\n    function hasPaymaster(UserOperation calldata userOp) internal pure returns (bool) {\n        return userOp.paymaster != address(0);\n    }\n\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\n        //lighter signature scheme. must match UserOp.ts#packUserOp\n        bytes calldata sig = userOp.signature;\n        assembly {\n            let ofs := userOp\n            let len := sub(sub(sig.offset, ofs), 32)\n            ret := mload(0x40)\n            mstore(0x40, add(ret, add(len, 32)))\n            mstore(ret, len)\n            calldatacopy(add(ret, 32), ofs, len)\n        }\n        return ret;\n    }\n\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\n        return keccak256(pack(userOp));\n    }\n\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n}"
    }
  ]
}