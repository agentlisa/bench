{
  "Title": "M-3: distributeYield() calls earningsTrancheuse() with outdated emaSTT & emaJTT while calculating senior & junior tranche yield distributions",
  "Content": "# Issue M-3: distributeYield() calls earningsTrancheuse() with outdated emaSTT & emaJTT while calculating senior & junior tranche yield distributions \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/54 \n\n## Found by \nIronsidesec, Nihavent, t0x1c\n## Summary\nThe [distributeYield()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L229-L239) function internally calls `earningsTrancheuse()` on [L232](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L232) which calculates & returns the `_seniorTranche` & `_juniorTranche` yield distribution. However, this call results in `earningsTrancheuse()` using [outdated values of](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L461-L462) `emaSTT` & `emaJTT` on L461-L462 as these variables are updated only on [L238-L239](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L238-L239) _after_ the call to `earningsTrancheuse()` is concluded.\n\n## Code Snippet\n```js\n  File: src/ZivoeYDL.sol\n\n  213:              function distributeYield() external nonReentrant {\n  214:                  require(unlocked, \"ZivoeYDL::distributeYield() !unlocked\"); \n  215:                  require(\n  216:                      block.timestamp >= lastDistribution + daysBetweenDistributions * 86400, \n  217:                      \"ZivoeYDL::distributeYield() block.timestamp < lastDistribution + daysBetweenDistributions * 86400\"\n  218:                  );\n  219:          \n  220:                  // Calculate protocol earnings.\n  221:                  uint256 earnings = IERC20(distributedAsset).balanceOf(address(this));\n  222:                  uint256 protocolEarnings = protocolEarningsRateBIPS * earnings / BIPS;\n  223:                  uint256 postFeeYield = earnings.floorSub(protocolEarnings);\n  224:          \n  225:                  // Update timeline.\n  226:                  distributionCounter += 1;\n  227:                  lastDistribution = block.timestamp;\n  228:          \n  229:                  // Calculate yield distribution (trancheuse = \"slicer\" in French).\n  230:                  (\n  231:                      uint256[] memory _protocol, uint256 _seniorTranche, uint256 _juniorTranche, uint256[] memory _residual\n  232: @--->            ) = earningsTrancheuse(protocolEarnings, postFeeYield); \n  233:          \n  234:                  emit YieldDistributed(_protocol, _seniorTranche, _juniorTranche, _residual);\n  235:                  \n  236:                  // Update ema-based supply values. \n  237:                  (uint256 aSTT, uint256 aJTT) = IZivoeGlobals_YDL(GBL).adjustedSupplies();\n  238: @--->            emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));\n  239: @--->            emaJTT = MATH.ema(emaJTT, aJTT, retrospectiveDistributions.min(distributionCounter));\n                        ...\n                        ...\n```\n\nand\n\n```js\n  File: src/ZivoeYDL.sol\n\n  447:              function earningsTrancheuse(uint256 yP, uint256 yD) public view returns (\n  448:                  uint256[] memory protocol, uint256 senior, uint256 junior, uint256[] memory residual\n  449:              ) {\n  450:                  protocol = new uint256[](protocolRecipients.recipients.length);\n  451:                  residual = new uint256[](residualRecipients.recipients.length);\n  452:                  \n  453:                  // Accounting for protocol earnings.\n  454:                  for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n  455:                      protocol[i] = protocolRecipients.proportion[i] * yP / BIPS;\n  456:                  }\n  457:          \n  458:                  // Accounting for senior and junior earnings.\n  459:                  uint256 _seniorProportion = MATH.seniorProportion(\n  460:                      IZivoeGlobals_YDL(GBL).standardize(yD, distributedAsset),\n  461: @--->                MATH.yieldTarget(emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions),\n  462: @--->                emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions\n  463:                  );\n  464:                  senior = (yD * _seniorProportion) / RAY;\n  465:                  junior = (yD * MATH.juniorProportion(emaSTT, emaJTT, _seniorProportion, targetRatioBIPS)) / RAY; \n  466:                                                                                                                    \n  467:                  // Handle accounting for residual earnings.\n  468:                  yD = yD.floorSub(senior + junior);\n  469:                  for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n  470:                      residual[i] = residualRecipients.proportion[i] * yD / BIPS;\n  471:                  }\n  472:              }\n```\n\n## Vulnerability Detail\nAs the [docs explain](https://docs.zivoe.com/user-docs/yield-distribution#liquidity-providers:~:text=Returns%20are%20calculated%20using%20the%20adjusted%20supply%20of%20tranche%20tokens%2C%20with%20an%20Exponential%20Moving%20Average%20(EMA)%20playing%20a%20significant%20role), the EMA plays a significant role in yield distribution calculations.\n\n> Returns are calculated using the adjusted supply of tranche tokens, with an Exponential Moving Average (EMA) playing a significant role. \n\n> The EMA smoothens the change in the supply of tranche tokens over a look-back period of 2.5 months.\n\nThe EMA is used to calculate the:\n- yield target via a call to [MATH.yieldTarget()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeMath.sol#L113-L121) which expects \"_ema-based supply of zSTT & zJTT_\" as its params.\n- senior tranche yield proportion via a call to [MATH.seniorProportion()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeMath.sol#L59-L70) which again expects ema-based `yT, eSTT & eJTT`.\n\nBoth the above mentioned calls happen inside `earningsTrancheuse()` [here](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L461-L462). The issue is that these global variables `emaSTT and emaJTT` are still outdated and correspond to the ones belonging to the `lastDistribution` timestamp instead of current updated ones. These values are updated only after the call to `earningsTrancheuse()` has concluded [here](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L238-L239).\n\n## Impact\nImagine that in the last 30 days, JTT supply has reduced due to defaulted loans. As a result, the target yield $yT_{real}$ would come down too (i.e. $yT_{real}$ < $yT$ where $yT$ is the protocol calculated incorrect target yield) and the junior tranche ditributable yield will be smaller than before. However if there is excess yield, then the junior tranche would receive more than their fair share since last 30 days have not been considered by the protocol calculations. If the quantum of defaulted loans is high (and hence $yT_{real}$ has dipped significantly), the impact is not only limited to the junior tranche, but then also effects the senior tranche. <br>\n\nOn the flip side an increase in the adjusted supplies of STT and JTT in the last 30 days will have a impact on the smoothened emaSTT and emaJTT, making the values go higher. As a result, target yield $yT_{real}$ would go up too. Thus, it could happen that `yD` is less than $yT_{real}$ but the protocol is oblivious to that due to usage of outdated values. This would result in the protcol using [seniorProportionBase()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeMath.sol#L74) to calculate the senior's yield instead of [seniorProportionShortfall()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeMath.sol#L72). \n<br>\n\nFinally, since at each of these function calls an outdated eSTT is passed as a param, the value returned would be more/less than what it should be, thus causing gain/loss of yield for both the tranches ([juniorProportion()](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeMath.sol#L74) calculation has the same problem).\n<br>\n\n**_Note:_** For the very first distribution i.e. when `distributionCounter = 1`, the values used are from 60 days ago instead of 30 days [as can be seen inside `unlock()`](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/ZivoeYDL.sol#L328-L331), further increasing the margin of error. The 60 day gap has initially been provided by the protocol to allow for more time to bring in initial yield.\n\n## Tool used\nManual Review\n\n## Recommendation\nUpdate the ema values **_before_** calling `earningsTrancheuse()`:\n```diff\n+       // Update ema-based supply values.\n+       (uint256 aSTT, uint256 aJTT) = IZivoeGlobals_YDL(GBL).adjustedSupplies();\n+       emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));\n+       emaJTT = MATH.ema(emaJTT, aJTT, retrospectiveDistributions.min(distributionCounter));\n\n        // Calculate yield distribution (trancheuse = \"slicer\" in French).\n        (\n            uint256[] memory _protocol, uint256 _seniorTranche, uint256 _juniorTranche, uint256[] memory _residual\n        ) = earningsTrancheuse(protocolEarnings, postFeeYield); \n\n        emit YieldDistributed(_protocol, _seniorTranche, _juniorTranche, _residual);\n        \n-       // Update ema-based supply values.\n-       (uint256 aSTT, uint256 aJTT) = IZivoeGlobals_YDL(GBL).adjustedSupplies();\n-       emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));\n-       emaJTT = MATH.ema(emaJTT, aJTT, retrospectiveDistributions.min(distributionCounter));\n```\n\n\n\n## Discussion\n\n**pseudonaut**\n\nNot an issue, the yield that accumulated and is for distribution was generated over the last 30 days and thus should match the initial fix-point of the prior 30 day EMA calculation. There's dilution that occurs with this methodology that we don't want to introduce into our overall accounting system\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium, distributeYield uses outdated ema values, updating them after all calculations. However, the impact is limited, because the expected EMA averaging period is 2 months and it's unlikely that distributeYield is called so rarely that the impact of outdated ema values causes any real issues.\n\n\n\n**panprog**\n\nAfter considering developer's response and intentions, changing this to invalid.\n\nAccording to developers response, this is intentional, because using current EMA (which includes current totalSupply at the time of distribution, which might be manipulated) can introduce some attack vectors from the current totalSupply, so current distribution is done over EMA from the previous period.\n\n**panprog**\n\nSponsor response:\n> we did a run-through on accounting scenarios\nIt is indeed underpaying the depositors\nBy what we think is fair within the system\nAnd manipulation isn't possible because they'd have to deposit and lock up tokens so there's no flash-loan etc.\n\nAgree with sponsor, changing back to Medium\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/263\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeYDL.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./ZivoeMath.sol\";\n\nimport \"./libraries/FloorMath.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IZivoeGlobals_YDL {\n    /// @notice Returns the address of the ZivoeDAO contract.\n    function DAO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n    \n    /// @notice Returns the address of the ZivoeRewards ($zSTT) contract.\n    function stSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($zJTT) contract.\n    function stJTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewards ($ZVE) contract.\n    function stZVE() external view returns (address);\n\n    /// @notice Returns the address of the Timelock contract.\n    function TLC() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeRewardsVesting ($ZVE) vesting contract.\n    function vestZVE() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zSTT) contract.\n    function zSTT() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeTrancheToken ($zJTT) contract.\n    function zJTT() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n\n    /// @notice Returns total circulating supply of zSTT and zJTT, accounting for defaults via markdowns.\n    /// @return zSTTSupply zSTT.totalSupply() adjusted for defaults.\n    /// @return zJTTSupply zJTT.totalSupply() adjusted for defaults.\n    function adjustedSupplies() external view returns (uint256 zSTTSupply, uint256 zJTTSupply);\n\n    /// @notice Handles WEI standardization of a given asset amount (i.e. 6 decimal precision => 18 decimal precision).\n    /// @param  amount The amount of a given \"asset\".\n    /// @param  asset The asset (ERC-20) from which to standardize the amount to WEI.\n    /// @return standardizedAmount The above amount standardized to 18 decimals.\n    function standardize(uint256 amount, address asset) external view returns (uint256 standardizedAmount);\n\n    /// @notice This function will verify if a given stablecoin has been whitelisted for use throughout system.\n    /// @param  stablecoin address of the stablecoin to verify acceptance for.\n    function stablecoinWhitelist(address stablecoin) external view returns (bool);\n}\n\ninterface IZivoeRewards_YDL {\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @param  reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external;\n}\n\n\n\n/// @notice  This contract manages the accounting for distributing yield across multiple contracts.\n///          This contract has the following responsibilities:\n///            - Escrows yield in between distribution periods.\n///            - Manages accounting for yield distribution.\n///            - Supports modification of certain state variables for governance purposes.\n///            - Tracks historical values using EMA (exponential moving average) on 30-day basis.\ncontract ZivoeYDL is Context, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Recipients {\n        address[] recipients;\n        uint256[] proportion;\n    }\n\n    Recipients protocolRecipients;          /// @dev Tracks the distributions for protocol earnings.\n    Recipients residualRecipients;          /// @dev Tracks the distributions for residual earnings.\n\n    address public immutable GBL;           /// @dev The ZivoeGlobals contract.\n\n    address public distributedAsset;        /// @dev The \"stablecoin\" that will be distributed via YDL.\n\n    // Weighted moving averages.\n    uint256 public emaSTT;          /// @dev Weighted moving average for senior tranche size, a.k.a. zSTT.totalSupply().\n    uint256 public emaJTT;          /// @dev Weighted moving average for junior tranche size, a.k.a. zJTT.totalSupply().\n\n    // Indexing.\n    uint256 public distributionCounter;     /// @dev Number of calls to distributeYield().\n    uint256 public lastDistribution;        /// @dev Used for timelock constraint to call distributeYield().\n\n    // Accounting vars (governable).\n    uint256 public targetAPYBIPS = 1000;                /// @dev The target annualized yield for senior tranche.\n    uint256 public targetRatioBIPS = 22000;             /// @dev The target ratio of junior to senior tranche.\n    uint256 public protocolEarningsRateBIPS = 2000;     /// @dev The protocol earnings rate.\n\n    // Accounting vars (constant).\n    uint256 public constant daysBetweenDistributions = 30;   /// @dev Number of days between yield distributions.\n    uint256 public constant retrospectiveDistributions = 6;  /// @dev Retrospective moving average period.\n    \n    bool public unlocked;                   /// @dev Prevents contract from supporting functionality until unlocked.\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant RAY = 10 ** 27;\n\n    ZivoeMath public MATH;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initialize the ZivoeYDL contract.\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _distributedAsset The \"stablecoin\" that will be distributed via YDL.\n    constructor(address _GBL, address _distributedAsset) {\n        GBL = _GBL;\n        distributedAsset = _distributedAsset;\n        MATH = new ZivoeMath();\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during returnAsset().\n    /// @param  asset The asset returned.\n    /// @param  amount The amount of \"asset\" returned to DAO.\n    event AssetReturned(address indexed asset, uint256 amount);\n\n    /// @notice Emitted during updateDistributedAsset().\n    /// @param  oldAsset The old value of distributedAsset.\n    /// @param  newAsset The new value of distributedAsset.\n    event UpdatedDistributedAsset(address indexed oldAsset, address indexed newAsset);\n\n    /// @notice Emitted during updateProtocolEarningsRateBIPS().\n    /// @param  oldValue The old value of protocolEarningsRateBIPS.\n    /// @param  newValue The new value of protocolEarningsRateBIPS.\n    event UpdatedProtocolEarningsRateBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive protocol earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedProtocolRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateRecipients().\n    /// @param  recipients The new recipients to receive residual earnings.\n    /// @param  proportion The proportion distributed across recipients.\n    event UpdatedResidualRecipients(address[] recipients, uint256[] proportion);\n\n    /// @notice Emitted during updateTargetAPYBIPS().\n    /// @param  oldValue The old value of targetAPYBIPS.\n    /// @param  newValue The new value of targetAPYBIPS.\n    event UpdatedTargetAPYBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during updateTargetRatioBIPS().\n    /// @param  oldValue The old value of targetRatioBIPS.\n    /// @param  newValue The new value of targetRatioBIPS.\n    event UpdatedTargetRatioBIPS(uint256 oldValue, uint256 newValue);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  protocol The amount of earnings distributed to protocol earnings recipients.\n    /// @param  senior The amount of earnings distributed to the senior tranche.\n    /// @param  junior The amount of earnings distributed to the junior tranche.\n    /// @param  residual The amount of earnings distributed to residual earnings recipients.\n    event YieldDistributed(uint256[] protocol, uint256 senior, uint256 junior, uint256[] residual);\n\n    /// @notice Emitted during distributeYield().\n    /// @param  asset The \"asset\" being distributed.\n    /// @param  recipient The recipient of the distribution.\n    /// @param  amount The amount distributed.\n    event YieldDistributedSingle(address indexed asset, address indexed recipient, uint256 amount);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice View distribution information for protocol and residual earnings recipients.\n    /// @return protocolEarningsRecipients The destinations for protocol earnings distributions.\n    /// @return protocolEarningsProportion The proportions for protocol earnings distributions.\n    /// @return residualEarningsRecipients The destinations for residual earnings distributions.\n    /// @return residualEarningsProportion The proportions for residual earnings distributions.\n    function viewDistributions() external view returns (\n        address[] memory protocolEarningsRecipients, uint256[] memory protocolEarningsProportion, \n        address[] memory residualEarningsRecipients, uint256[] memory residualEarningsProportion\n    ) {\n        return (\n            protocolRecipients.recipients, \n            protocolRecipients.proportion, \n            residualRecipients.recipients, \n            residualRecipients.proportion\n        );\n    }\n    \n    /// @notice Distributes available yield within this contract to appropriate entities.\n    function distributeYield() external nonReentrant {\n        require(unlocked, \"ZivoeYDL::distributeYield() !unlocked\"); \n        require(\n            block.timestamp >= lastDistribution + daysBetweenDistributions * 86400, \n            \"ZivoeYDL::distributeYield() block.timestamp < lastDistribution + daysBetweenDistributions * 86400\"\n        );\n\n        // Calculate protocol earnings.\n        uint256 earnings = IERC20(distributedAsset).balanceOf(address(this));\n        uint256 protocolEarnings = protocolEarningsRateBIPS * earnings / BIPS;\n        uint256 postFeeYield = earnings.floorSub(protocolEarnings);\n\n        // Update timeline.\n        distributionCounter += 1;\n        lastDistribution = block.timestamp;\n\n        // Calculate yield distribution (trancheuse = \"slicer\" in French).\n        (\n            uint256[] memory _protocol, uint256 _seniorTranche, uint256 _juniorTranche, uint256[] memory _residual\n        ) = earningsTrancheuse(protocolEarnings, postFeeYield); \n\n        emit YieldDistributed(_protocol, _seniorTranche, _juniorTranche, _residual);\n        \n        // Update ema-based supply values.\n        (uint256 aSTT, uint256 aJTT) = IZivoeGlobals_YDL(GBL).adjustedSupplies();\n        emaSTT = MATH.ema(emaSTT, aSTT, retrospectiveDistributions.min(distributionCounter));\n        emaJTT = MATH.ema(emaJTT, aJTT, retrospectiveDistributions.min(distributionCounter));\n\n        // Distribute protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            address _recipient = protocolRecipients.recipients[i];\n            if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _protocol[i]);\n                IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n            else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                uint256 splitBIPS = (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                ) / (\n                    IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                    IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                );\n                uint stZVEAllocation = _protocol[i] * splitBIPS / BIPS;\n                uint vestZVEAllocation = _protocol[i] * (BIPS - splitBIPS) / BIPS;\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(),vestZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n            }\n            else {\n                IERC20(distributedAsset).safeTransfer(_recipient, _protocol[i]);\n                emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n            }\n        }\n\n        // Distribute senior and junior tranche earnings.\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stSTT()).depositReward(distributedAsset, _seniorTranche);\n        IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stJTT()).depositReward(distributedAsset, _juniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stSTT(), _seniorTranche);\n        emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stJTT(), _juniorTranche);\n\n        // Distribute residual earnings.\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            if (_residual[i] > 0) {\n                address _recipient = residualRecipients.recipients[i];\n                if (_recipient == IZivoeGlobals_YDL(GBL).stSTT() ||_recipient == IZivoeGlobals_YDL(GBL).stJTT()) {\n                    IERC20(distributedAsset).safeIncreaseAllowance(_recipient, _residual[i]);\n                    IZivoeRewards_YDL(_recipient).depositReward(distributedAsset, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _protocol[i]);\n                }\n                else if (_recipient == IZivoeGlobals_YDL(GBL).stZVE()) {\n                    uint256 splitBIPS = (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() * BIPS\n                    ) / (\n                        IERC20(IZivoeGlobals_YDL(GBL).stZVE()).totalSupply() + \n                        IERC20(IZivoeGlobals_YDL(GBL).vestZVE()).totalSupply()\n                    );\n                    uint stZVEAllocation = _residual[i] * splitBIPS / BIPS;\n                    uint vestZVEAllocation = _residual[i] * (BIPS - splitBIPS) / BIPS;\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    IERC20(distributedAsset).safeIncreaseAllowance(IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).stZVE()).depositReward(distributedAsset, stZVEAllocation);\n                    IZivoeRewards_YDL(IZivoeGlobals_YDL(GBL).vestZVE()).depositReward(distributedAsset, vestZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).stZVE(), stZVEAllocation);\n                    emit YieldDistributedSingle(distributedAsset, IZivoeGlobals_YDL(GBL).vestZVE(), vestZVEAllocation);\n                }\n                else {\n                    IERC20(distributedAsset).safeTransfer(_recipient, _residual[i]);\n                    emit YieldDistributedSingle(distributedAsset, _recipient, _residual[i]);\n                }\n            }\n        }\n    }\n\n    /// @notice Returns an asset to DAO if not distributedAsset().\n    /// @param asset The asset to return.\n    function returnAsset(address asset) external {\n        require(asset != distributedAsset, \"ZivoeYDL::returnAsset() asset == distributedAsset\");\n        emit AssetReturned(asset, IERC20(asset).balanceOf(address(this)));\n        IERC20(asset).safeTransfer(IZivoeGlobals_YDL(GBL).DAO(), IERC20(asset).balanceOf(address(this)));\n    }\n\n    /// @notice Unlocks this contract for distributions, initializes values.\n    function unlock() external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).ITO(), \n            \"ZivoeYDL::unlock() _msgSender() != IZivoeGlobals_YDL(GBL).ITO()\"\n        );\n\n        unlocked = true;\n        lastDistribution = block.timestamp + 30 days;\n\n        emaSTT = IERC20(IZivoeGlobals_YDL(GBL).zSTT()).totalSupply();\n        emaJTT = IERC20(IZivoeGlobals_YDL(GBL).zJTT()).totalSupply();\n\n        address[] memory protocolRecipientAcc = new address[](2);\n        uint256[] memory protocolRecipientAmt = new uint256[](2);\n\n        protocolRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        protocolRecipientAmt[0] = 6666;\n        protocolRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        protocolRecipientAmt[1] = 3334;\n\n        protocolRecipients = Recipients(protocolRecipientAcc, protocolRecipientAmt);\n\n        address[] memory residualRecipientAcc = new address[](2);\n        uint256[] memory residualRecipientAmt = new uint256[](2);\n\n        residualRecipientAcc[0] = address(IZivoeGlobals_YDL(GBL).stZVE());\n        residualRecipientAmt[0] = 6666;\n        residualRecipientAcc[1] = address(IZivoeGlobals_YDL(GBL).ZVL());\n        residualRecipientAmt[1] = 3334;\n\n        residualRecipients = Recipients(residualRecipientAcc, residualRecipientAmt);\n    }\n\n    /// @notice Updates the distributed asset for this particular contract.\n    /// @param  _distributedAsset The new value for distributedAsset.\n    function updateDistributedAsset(address _distributedAsset) external nonReentrant {\n        require(\n            _distributedAsset != distributedAsset, \n            \"ZivoeYDL::updateDistributedAsset() _distributedAsset == distributedAsset\"\n        );\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateDistributedAsset() _msgSender() != TLC()\"\n        );\n        require(\n            IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset),\n            \"ZivoeYDL::updateDistributedAsset() !IZivoeGlobals_YDL(GBL).stablecoinWhitelist(_distributedAsset)\"\n        );\n        emit UpdatedDistributedAsset(distributedAsset, _distributedAsset);\n        distributedAsset = _distributedAsset;\n    }\n\n    /// @notice Updates the state variable \"protocolEarningsRateBIPS\".\n    /// @param  _protocolEarningsRateBIPS The new value for protocolEarningsRateBIPS.\n    function updateProtocolEarningsRateBIPS(uint256 _protocolEarningsRateBIPS) external {\n        require(\n            _msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _msgSender() != TLC()\"\n        );\n        require(\n            _protocolEarningsRateBIPS <= 9000, \n            \"ZivoeYDL::updateProtocolEarningsRateBIPS() _protocolEarningsRateBIPS > 9000\"\n        );\n        emit UpdatedProtocolEarningsRateBIPS(protocolEarningsRateBIPS, _protocolEarningsRateBIPS);\n        protocolEarningsRateBIPS = _protocolEarningsRateBIPS;\n    }\n\n    /// @notice Updates the protocolRecipients or residualRecipients.\n    /// @param  recipients An array of addresses to which protocol earnings will be distributed.\n    /// @param  proportions An array of ratios relative to the recipients - in BIPS. Sum should equal to 10000.\n    /// @param  protocol Specify \"true\" to update protocol earnings, or \"false\" to update residual earnings.\n    function updateRecipients(address[] memory recipients, uint256[] memory proportions, bool protocol) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateRecipients() _msgSender() != TLC()\");\n        require(\n            recipients.length == proportions.length && recipients.length > 0, \n            \"ZivoeYDL::updateRecipients() recipients.length != proportions.length || recipients.length == 0\"\n        );\n        require(unlocked, \"ZivoeYDL::updateRecipients() !unlocked\");\n\n        uint256 proportionTotal;\n        for (uint256 i = 0; i < recipients.length; i++) {\n            proportionTotal += proportions[i];\n            require(proportions[i] > 0, \"ZivoeYDL::updateRecipients() proportions[i] == 0\");\n            require(recipients[i] != address(0), \"ZivoeYDL::updateRecipients() recipients[i] == address(0)\");\n        }\n\n        require(proportionTotal == BIPS, \"ZivoeYDL::updateRecipients() proportionTotal != BIPS (10,000)\");\n        if (protocol) {\n            emit UpdatedProtocolRecipients(recipients, proportions);\n            protocolRecipients = Recipients(recipients, proportions);\n        }\n        else {\n            emit UpdatedResidualRecipients(recipients, proportions);\n            residualRecipients = Recipients(recipients, proportions);\n        }\n    }\n\n    /// @notice Updates the state variable \"targetAPYBIPS\".\n    /// @param  _targetAPYBIPS The new value for targetAPYBIPS.\n    function updateTargetAPYBIPS(uint256 _targetAPYBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetAPYBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetAPYBIPS(targetAPYBIPS, _targetAPYBIPS);\n        targetAPYBIPS = _targetAPYBIPS;\n    }\n\n    /// @notice Updates the state variable \"targetRatioBIPS\".\n    /// @param  _targetRatioBIPS The new value for targetRatioBIPS.\n    function updateTargetRatioBIPS(uint256 _targetRatioBIPS) external {\n        require(_msgSender() == IZivoeGlobals_YDL(GBL).TLC(), \"ZivoeYDL::updateTargetRatioBIPS() _msgSender() != TLC()\");\n        emit UpdatedTargetRatioBIPS(targetRatioBIPS, _targetRatioBIPS);\n        targetRatioBIPS = _targetRatioBIPS;\n    }\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /// @notice Calculates the distribution of yield (\"earnings\") for the four primary groups.\n    /// @param  yP Yield for the protocol.\n    /// @param  yD Yield for the remaining three groups.\n    /// @return protocol Protocol earnings.\n    /// @return senior Senior tranche earnings.\n    /// @return junior Junior tranche earnings.\n    /// @return residual Residual earnings.\n    function earningsTrancheuse(uint256 yP, uint256 yD) public view returns (\n        uint256[] memory protocol, uint256 senior, uint256 junior, uint256[] memory residual\n    ) {\n        protocol = new uint256[](protocolRecipients.recipients.length);\n        residual = new uint256[](residualRecipients.recipients.length);\n        \n        // Accounting for protocol earnings.\n        for (uint256 i = 0; i < protocolRecipients.recipients.length; i++) {\n            protocol[i] = protocolRecipients.proportion[i] * yP / BIPS;\n        }\n\n        // Accounting for senior and junior earnings.\n        uint256 _seniorProportion = MATH.seniorProportion(\n            IZivoeGlobals_YDL(GBL).standardize(yD, distributedAsset),\n            MATH.yieldTarget(emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions),\n            emaSTT, emaJTT, targetAPYBIPS, targetRatioBIPS, daysBetweenDistributions\n        );\n        senior = (yD * _seniorProportion) / RAY;\n        junior = (yD * MATH.juniorProportion(emaSTT, emaJTT, _seniorProportion, targetRatioBIPS)) / RAY;\n        \n        // Handle accounting for residual earnings.\n        yD = yD.floorSub(senior + junior);\n        for (uint256 i = 0; i < residualRecipients.recipients.length; i++) {\n            residual[i] = residualRecipients.proportion[i] * yD / BIPS;\n        }\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/ZivoeMath.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./libraries/FloorMath.sol\";\n\n\n\n/// @notice  This contract facilitates mathematics, intended solely for the YDL.\ncontract ZivoeMath {\n\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant WAD = 10 ** 18;\n    uint256 private constant RAY = 10 ** 27;\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /**\n        @notice     Calculates the current EMA (exponential moving average).\n        @dev        M * cV + (1 - M) * bV, where our smoothing factor M = 2 / (N + 1)\n        @param      bV  = The base value (typically an EMA from prior calculations).\n        @param      cV  = The current value, which is factored into bV.\n        @param      N   = Number of steps to average over.\n        @return     eV  = EMA-based value given prior and current conditions.\n    */\n    function ema(uint256 bV, uint256 cV, uint256 N) external pure returns (uint256 eV) {\n        assert(N != 0);\n        uint256 M = (WAD * 2).floorDiv(N + 1);\n        eV = ((M * cV) + (WAD - M) * bV).floorDiv(WAD);\n    }\n\n    /**\n        @notice     Calculates proportion of yield attributable to junior tranche.\n        @dev        (Q * eJTT * sP / BIPS).floorDiv(eSTT).min(RAY - sP)\n        @param      eSTT = ema-based supply of zSTT                     (units = WEI)\n        @param      eJTT = ema-based supply of zJTT                     (units = WEI)\n        @param      sP   = Proportion of yield attributable to seniors  (units = RAY)\n        @param      Q    = senior to junior tranche target ratio        (units = BIPS)\n        @return     jP   = Yield attributable to junior tranche in RAY.\n        @dev        Precision of return value, jP, is in RAY (10**27).\n        @dev        The return value for this equation MUST never exceed RAY (10**27).\n    */\n    function juniorProportion(uint256 eSTT, uint256 eJTT, uint256 sP, uint256 Q) external pure returns (uint256 jP) {\n        if (sP <= RAY) { jP = (Q * eJTT * sP / BIPS).floorDiv(eSTT).min(RAY - sP); }\n    }\n\n    /**\n        @notice     Calculates proportion of yield distributble which is attributable to the senior tranche.\n        @param      yD   = yield distributable                      (units = WEI)\n        @param      yT   = ema-based yield target                   (units = WEI)\n        @param      eSTT = ema-based supply of zSTT                 (units = WEI)\n        @param      eJTT = ema-based supply of zJTT                 (units = WEI)\n        @param      Y    = target annual yield for senior tranche   (units = BIPS)\n        @param      Q    = multiple of Y                            (units = BIPS)\n        @param      T    = # of days between distributions          (units = integer)\n        @return     sP   = Proportion of yD attributable to senior tranche.\n        @dev        Precision of return value, sP, is in RAY (10**27).\n    */\n    function seniorProportion(\n        uint256 yD, uint256 yT, uint256 eSTT, uint256 eJTT, uint256 Y, uint256 Q, uint256 T\n    ) external pure returns (uint256 sP) {\n        // Shortfall of yield.\n        if (yD < yT) { sP = seniorProportionShortfall(eSTT, eJTT, Q); } \n        // Excess yield and historical out-performance.\n        else { sP = seniorProportionBase(yD, eSTT, Y, T); }\n    }\n\n    /**\n        @notice     Calculates proportion of yield attributed to senior tranche (no extenuating circumstances).\n        @dev          Y  * eSTT * T\n                    ----------------- *  RAY\n                        (365) * yD\n        @param      yD   = yield distributable                      (units = WEI)\n        @param      eSTT = ema-based supply of zSTT                 (units = WEI)\n        @param      Y    = target annual yield for senior tranche   (units = BIPS)\n        @param      T    = # of days between distributions          (units = integer)\n        @return     sPB  = Proportion of yield attributed to senior tranche in RAY.\n        @dev        Precision of return value, sRB, is in RAY (10**27).\n    */\n    function seniorProportionBase(uint256 yD, uint256 eSTT, uint256 Y, uint256 T) public pure returns (uint256 sPB) {\n        sPB = ((RAY * Y * (eSTT) * T / BIPS) / 365).floorDiv(yD).min(RAY);\n    }\n\n    /**\n        @notice     Calculates proportion of yield attributed to senior tranche (shortfall occurence).\n        @dev                     WAD\n                   --------------------------------  *  RAY\n                             Q * eJTT * WAD / BIPS      \n                    WAD  +   ---------------------\n                                     eSTT\n        @param      eSTT = ema-based supply of zSTT                 (units = WEI)\n        @param      eJTT = ema-based supply of zJTT                 (units = WEI)\n        @param      Q    = senior to junior tranche target ratio    (units = integer)\n        @return     sPS  = Proportion of yield attributed to senior tranche in RAY.\n        @dev        Precision of return value, sPS, is in RAY (10**27).\n    */\n    function seniorProportionShortfall(uint256 eSTT, uint256 eJTT, uint256 Q) public pure returns (uint256 sPS) {\n        sPS = (WAD * RAY).floorDiv(WAD + (Q * eJTT * WAD / BIPS).floorDiv(eSTT)).min(RAY);\n    }\n\n    /**\n        @notice     Calculates amount of annual yield required to meet target rate for both tranches.\n        @dev        (Y * T * (eSTT + eJTT * Q / BIPS) / BIPS) / 365\n        @param      eSTT = ema-based supply of zSTT                  (units = WEI)\n        @param      eJTT = ema-based supply of zJTT                  (units = WEI)\n        @param      Y    = target annual yield for senior tranche   (units = BIPS)\n        @param      Q    = multiple of Y                            (units = BIPS)\n        @param      T    = # of days between distributions          (units = integer)\n        @return     yT   = yield target for the senior and junior tranche combined.\n        @dev        Precision of the return value, yT, is in WEI (10**18).\n    */\n    function yieldTarget(uint256 eSTT, uint256 eJTT, uint256 Y, uint256 Q, uint256 T) public pure returns (uint256 yT) {\n        yT = (Y * T * (eSTT + eJTT * Q / BIPS) / BIPS) / 365;\n    }\n\n}"
    },
    {
      "filename": "zivoe-core-foundry/src/ZivoeMath.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./libraries/FloorMath.sol\";\n\n\n\n/// @notice  This contract facilitates mathematics, intended solely for the YDL.\ncontract ZivoeMath {\n\n    using FloorMath for uint256;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    uint256 private constant BIPS = 10000;\n    uint256 private constant WAD = 10 ** 18;\n    uint256 private constant RAY = 10 ** 27;\n\n\n\n    // ----------\n    //    Math\n    // ----------\n\n    /**\n        @notice     Calculates the current EMA (exponential moving average).\n        @dev        M * cV + (1 - M) * bV, where our smoothing factor M = 2 / (N + 1)\n        @param      bV  = The base value (typically an EMA from prior calculations).\n        @param      cV  = The current value, which is factored into bV.\n        @param      N   = Number of steps to average over.\n        @return     eV  = EMA-based value given prior and current conditions.\n    */\n    function ema(uint256 bV, uint256 cV, uint256 N) external pure returns (uint256 eV) {\n        assert(N != 0);\n        uint256 M = (WAD * 2).floorDiv(N + 1);\n        eV = ((M * cV) + (WAD - M) * bV).floorDiv(WAD);\n    }\n\n    /**\n        @notice     Calculates proportion of yield attributable to junior tranche.\n        @dev        (Q * eJTT * sP / BIPS).floorDiv(eSTT).min(RAY - sP)\n        @param      eSTT = ema-based supply of zSTT                     (units = WEI)\n        @param      eJTT = ema-based supply of zJTT                     (units = WEI)\n        @param      sP   = Proportion of yield attributable to seniors  (units = RAY)\n        @param      Q    = senior to junior tranche target ratio        (units = BIPS)\n        @return     jP   = Yield attributable to junior tranche in RAY.\n        @dev        Precision of return value, jP, is in RAY (10**27).\n        @dev        The return value for this equation MUST never exceed RAY (10**27).\n    */\n    function juniorProportion(uint256 eSTT, uint256 eJTT, uint256 sP, uint256 Q) external pure returns (uint256 jP) {\n        if (sP <= RAY) { jP = (Q * eJTT * sP / BIPS).floorDiv(eSTT).min(RAY - sP); }\n    }\n\n    /**\n        @notice     Calculates proportion of yield distributble which is attributable to the senior tranche.\n        @param      yD   = yield distributable                      (units = WEI)"
    }
  ]
}