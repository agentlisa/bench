{
  "Title": "[N-03] `constant`s should be defined rather than using magic numbers",
  "Content": "\n1.  File: src/BurnableMintableCappedERC20.sol (line [37](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/BurnableMintableCappedERC20.sol#L37))\n\n```solidity\n                                bytes1(0xff),\n```\n\n2.  File: src/ECDSA.sol (line [33](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ECDSA.sol#L33))\n\n```solidity\n        if (signature.length != 65) revert InvalidSignatureLength();\n```\n\n3.  File: src/ECDSA.sol (line [58](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ECDSA.sol#L58))\n\n```solidity\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();\n```\n\n4.  File: src/ECDSA.sol (line [60](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ECDSA.sol#L60))\n\n```solidity\n        if (v != 27 && v != 28) revert InvalidV();\n```\n\n5.  File: src/ECDSA.sol (line [60](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ECDSA.sol#L60))\n\n```solidity\n        if (v != 27 && v != 28) revert InvalidV();\n```\n\n6.  File: src/ERC20Permit.sol (line [44](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ERC20Permit.sol#L44))\n\n```solidity\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');\n```\n\n7.  File: src/ERC20Permit.sol (line [45](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ERC20Permit.sol#L45))\n\n```solidity\n        require(v == 27 || v == 28, 'INV_V');\n```\n\n8.  File: src/ERC20Permit.sol (line [45](https://github.com/code-423n4/2022-04-axelar/blob/f1c8bfc16f82a27797f61cb3a310c0f936dce567/src/ERC20Permit.sol#L45))\n\n```solidity\n        require(v == 27 || v == 28, 'INV_V');\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-axelar",
  "Code": [
    {
      "filename": "src/BurnableMintableCappedERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { MintableCappedERC20 } from './MintableCappedERC20.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract BurnableMintableCappedERC20 is MintableCappedERC20 {\n    // keccak256('token-frozen')\n    bytes32 private constant PREFIX_TOKEN_FROZEN =\n        bytes32(0x1a7261d3a36c4ce4235d10859911c9444a6963a3591ec5725b96871d9810626b);\n\n    // keccak256('all-tokens-frozen')\n    bytes32 private constant KEY_ALL_TOKENS_FROZEN =\n        bytes32(0x75a31d1ce8e5f9892188befc328d3b9bd3fa5037457e881abc21f388471b8d96);\n\n    event Frozen(address indexed owner);\n    event Unfrozen(address indexed owner);\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 capacity\n    ) MintableCappedERC20(name, symbol, decimals, capacity) {}\n\n    function depositAddress(bytes32 salt) public view returns (address) {\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\n        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                bytes1(0xff),\n                                owner,\n                                salt,\n                                keccak256(abi.encodePacked(type(DepositHandler).creationCode))\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function burn(bytes32 salt) public onlyOwner {\n        address account = depositAddress(salt);\n        _burn(account, balanceOf[account]);\n    }\n\n    function _beforeTokenTransfer(\n        address,\n        address,\n        uint256\n    ) internal view override {\n        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN');\n        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN');\n    }\n}"
    },
    {
      "filename": "src/ECDSA.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    error InvalidSignatureLength();\n    error InvalidS();\n    error InvalidV();\n    error InvalidSignature();\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\n        // Check the signature length\n        if (signature.length != 65) revert InvalidSignatureLength();\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();\n\n        if (v != 27 && v != 28) revert InvalidV();\n\n        // If the signature is valid (and not malleable), return the signer address\n        if ((signer = ecrecover(hash, v, r, s)) == address(0)) revert InvalidSignature();\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash));\n    }\n}"
    },
    {
      "filename": "src/ECDSA.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    error InvalidSignatureLength();\n    error InvalidS();\n    error InvalidV();\n    error InvalidSignature();\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\n        // Check the signature length\n        if (signature.length != 65) revert InvalidSignatureLength();\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();\n\n        if (v != 27 && v != 28) revert InvalidV();\n\n        // If the signature is valid (and not malleable), return the signer address\n        if ((signer = ecrecover(hash, v, r, s)) == address(0)) revert InvalidSignature();\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash));\n    }\n}"
    },
    {
      "filename": "src/ECDSA.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    error InvalidSignatureLength();\n    error InvalidS();\n    error InvalidV();\n    error InvalidSignature();\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\n        // Check the signature length\n        if (signature.length != 65) revert InvalidSignatureLength();\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();\n\n        if (v != 27 && v != 28) revert InvalidV();\n\n        // If the signature is valid (and not malleable), return the signer address\n        if ((signer = ecrecover(hash, v, r, s)) == address(0)) revert InvalidSignature();\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash));\n    }\n}"
    },
    {
      "filename": "src/ECDSA.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    error InvalidSignatureLength();\n    error InvalidS();\n    error InvalidV();\n    error InvalidSignature();\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {\n        // Check the signature length\n        if (signature.length != 65) revert InvalidSignatureLength();\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();\n\n        if (v != 27 && v != 28) revert InvalidV();\n\n        // If the signature is valid (and not malleable), return the signer address\n        if ((signer = ecrecover(hash, v, r, s)) == address(0)) revert InvalidSignature();\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash));\n    }\n}"
    },
    {
      "filename": "src/ERC20Permit.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { ERC20 } from './ERC20.sol';\n\nabstract contract ERC20Permit is ERC20 {\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\\x19\\x01';\n\n    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH =\n        bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);\n\n    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')\n    bytes32 private constant PERMIT_SIGNATURE_HASH =\n        bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);\n\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory name) {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_SIGNATURE_HASH,\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function permit(\n        address issuer,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp < deadline, 'EXPIRED');\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');\n        require(v == 27 || v == 28, 'INV_V');\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == issuer, 'INV_SIG');\n\n        // _approve will revert if issuer is address(0x0)\n        _approve(issuer, spender, value);\n    }\n}"
    },
    {
      "filename": "src/ERC20Permit.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { ERC20 } from './ERC20.sol';\n\nabstract contract ERC20Permit is ERC20 {\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\\x19\\x01';\n\n    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH =\n        bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);\n\n    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')\n    bytes32 private constant PERMIT_SIGNATURE_HASH =\n        bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);\n\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory name) {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_SIGNATURE_HASH,\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function permit(\n        address issuer,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp < deadline, 'EXPIRED');\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');\n        require(v == 27 || v == 28, 'INV_V');\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == issuer, 'INV_SIG');\n\n        // _approve will revert if issuer is address(0x0)\n        _approve(issuer, spender, value);\n    }\n}"
    },
    {
      "filename": "src/ERC20Permit.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { ERC20 } from './ERC20.sol';\n\nabstract contract ERC20Permit is ERC20 {\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\\x19\\x01';\n\n    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH =\n        bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);\n\n    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')\n    bytes32 private constant PERMIT_SIGNATURE_HASH =\n        bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);\n\n    mapping(address => uint256) public nonces;\n\n    constructor(string memory name) {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_SIGNATURE_HASH,\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function permit(\n        address issuer,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp < deadline, 'EXPIRED');\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');\n        require(v == 27 || v == 28, 'INV_V');\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == issuer, 'INV_SIG');\n\n        // _approve will revert if issuer is address(0x0)\n        _approve(issuer, spender, value);\n    }\n}"
    }
  ]
}