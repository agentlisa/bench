{
  "Title": "M-12: AuraSpell `openPositionFarm` will revert when the tokens contains `lpToken`",
  "Content": "# Issue M-12: AuraSpell `openPositionFarm` will revert when the tokens contains `lpToken` \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/125 \n\n## Found by \nbitsurfer, nobody2018, twcctop\n\nAuraSpell `openPositionFarm` will revert when the tokens contains lpToken due to array length mismatch\n\n## Vulnerability Detail\n\nIn AuraSpell, the `openPositionFarm` will call `joinPool` in Balancer's vault. But when analyzing the `JoinPoolRequest` struct, we see issue on `maxAmountsIn` and `amountsIn` which can be in different length, thus this will be reverted since in Balancer's vault, this two array should be in the same length.\n\n```js\nFile: AuraSpell.sol\n088:     function openPositionFarm(\n089:         OpenPosParam calldata param,\n090:         uint256 minimumBPT\n091:     )\n...\n095:     {\n...\n110:         /// 3. Add liquidity to the Balancer pool and receive BPT in return.\n111:         {\n...\n128:             if (poolAmountOut != 0) {\n129:                 vault.joinPool(\n130:                     wAuraPools.getBPTPoolId(lpToken),\n131:                     address(this),\n132:                     address(this),\n133:                     IBalancerVault.JoinPoolRequest({\n134:                         assets: tokens,\n135:                         maxAmountsIn: maxAmountsIn,\n136:                         userData: abi.encode(1, amountsIn, _minimumBPT),\n137:                         fromInternalBalance: false\n138:                     })\n139:                 );\n140:             }\n141:         }\n...\n178:     }\n...\n296:     function _getJoinPoolParamsAndApprove(\n297:         address vault,\n298:         address[] memory tokens,\n299:         uint256[] memory balances,\n300:         address lpToken\n301:     ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n...\n304:         uint256 length = tokens.length;\n305:         uint256[] memory maxAmountsIn = new uint256[](length);\n306:         uint256[] memory amountsIn = new uint256[](length);\n307:         bool isLPIncluded;\n308:\n309:         for (i; i != length; ) {\n310:             if (tokens[i] != lpToken) {\n311:                 amountsIn[j] = IERC20(tokens[i]).balanceOf(address(this));\n312:                 if (amountsIn[j] > 0) {\n313:                     _ensureApprove(tokens[i], vault, amountsIn[j]);\n314:                 }\n315:                 ++j;\n316:             } else isLPIncluded = true;\n317:\n318:             maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n319:\n320:             unchecked {\n321:                 ++i;\n322:             }\n323:         }\n324:\n325:         if (isLPIncluded) {\n326:             assembly {\n327:                 mstore(amountsIn, sub(mload(amountsIn), 1))\n328:             }\n329:         }\n...\n345:         return (maxAmountsIn, amountsIn, poolAmountOut);\n346:     }\n```\n\nthese `maxAmountsIn` and `amountsIn` are coming from `_getJoinPoolParamsAndApprove`. And by seeing the function, we can see that there is possible issue when the `tokens[i] == lpToken`.\n\nWhen `tokens[i] == lpToken`, the flag `isLPIncluded` will be true. And will enter this block,\n\n```js\n325:         if (isLPIncluded) {\n326:             assembly {\n327:                 mstore(amountsIn, sub(mload(amountsIn), 1))\n328:             }\n329:         }\n```\n\nthis will decrease the `amountsIn` length. Thus, `amountsIn` and `maxAmountsIn` will be in different length.\n\nIn Balancer's `JoinPoolRequest` struct, the `maxAmountsIn`, and `userData` second decoded bytes (`amountsIn`) should be the same array length, because it will be checked in Balancer.\n\n```js\n133:                     IBalancerVault.JoinPoolRequest({\n134:                         assets: tokens,\n135:                         maxAmountsIn: maxAmountsIn,\n136:                         userData: abi.encode(1, amountsIn, _minimumBPT),\n137:                         fromInternalBalance: false\n138:                     })\n```\n\nTherefore, in this situation, it will be reverted.\n\n## Impact\n\nUser can't open position on AuraSpell when `tokens` contains `lpToken`\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L326-L328\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the assembly code where it will decrease the `amountsIn` length when `isLPIncluded` is true to make sure the array length are same.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title AuraSpell\n/// @author BlueberryProtocol\n/// @notice AuraSpell is the factory contract that\n///         defines how Blueberry Protocol interacts with Aura pools\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev Address of AURA token\n    address public AURA;\n    /// @dev Address of Stash AURA token\n    address public STASH_AURA;\n\n    /// @dev paraswap AugustusSwapper Address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy Address\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract with required parameters.\n    /// @param bank_ Reference to the Bank contract.\n    /// @param werc20_ Reference to the WERC20 contract.\n    /// @param weth_ Address of the wrapped Ether token.\n    /// @param wAuraPools_ Address of the wrapped Aura Pools contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        STASH_AURA = wAuraPools.STASH_AURA();\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Allows the owner to add a new strategy.\n    /// @param bpt Address of the Balancer Pool Token.\n    /// @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n    /// @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n    function addStrategy(\n        address bpt,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(bpt, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Balancer pool and stakes the resultant tokens in Aura.\n    /// @param param Configuration for opening a position.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minimumBPT\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Extract strategy details for the given strategy ID.\n        Strategy memory strategy = strategies[param.strategyId];\n        /// Fetch pool information based on provided farming pool ID.\n        (address lpToken, , , , , ) = wAuraPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow funds based on specified amount\n        _doBorrow(param.borrowToken, param.borrowAmount);\n\n        /// 3. Add liquidity to the Balancer pool and receive BPT in return.\n        {\n            uint256 _minimumBPT = minimumBPT;\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            (\n                uint256[] memory maxAmountsIn,\n                uint256[] memory amountsIn,\n                uint256 poolAmountOut\n            ) = _getJoinPoolParamsAndApprove(\n                    address(vault),\n                    tokens,\n                    balances,\n                    lpToken\n                );\n\n            if (poolAmountOut != 0) {\n                vault.joinPool(\n                    wAuraPools.getBPTPoolId(lpToken),\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest({\n                        assets: tokens,\n                        maxAmountsIn: maxAmountsIn,\n                        userData: abi.encode(1, amountsIn, _minimumBPT),\n                        fromInternalBalance: false\n                    })\n                );\n            }\n        }\n        /// 4. Ensure that the resulting LTV does not exceed maximum allowed value.\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Ensure position size is within permissible limits.\n        _validatePosSize(param.strategyId);\n\n        /// 6. Withdraw existing collaterals and burn the associated tokens.\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                pos.collateralSize\n            );\n            /// Distribute the multiple rewards to users.\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i; i != rewardTokensLength; ) {\n                _doRefundRewards(\n                    rewardTokens[i] == STASH_AURA ? AURA : rewardTokens[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        /// 7. Deposit the tokens in the Aura pool and place the wrapped collateral tokens in the Blueberry Bank.\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    /// @notice Closes a position from Balancer pool and exits the Aura farming.\n    /// @param param Parameters for closing the position\n    /// @param expectedRewards Expected reward amounts for each reward token\n    /// @param swapDatas Data required for swapping reward tokens to the debt token\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Information about the position from Blueberry Bank\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address[] memory rewardTokens;\n        /// Ensure the position's collateral token matches the expected one\n        {\n            address lpToken = strategies[param.strategyId].vault;\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n                revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n            /// 1. Burn the wrapped tokens, retrieve the BPT tokens, and claim the AURA rewards\n            bank.takeCollateral(param.amountPosRemove);\n            (rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                param.amountPosRemove\n            );\n\n            {\n                /// 2. Determine the exact amount of position to remove\n                uint256 amountPosRemove = param.amountPosRemove;\n                if (amountPosRemove == type(uint256).max) {\n                    amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                        address(this)\n                    );\n                }\n\n                /// 3. Parameters for removing liquidity\n                (\n                    uint256[] memory minAmountsOut,\n                    address[] memory tokens,\n                    uint256 borrowTokenIndex\n                ) = _getExitPoolParams(param.borrowToken, lpToken);\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n                );\n            }\n        }\n\n        /// 4. Swap each reward token for the debt token\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\n            /// Refund rest (dust) amount to owner\n            _doRefund(sellToken);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        /// 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 6. Withdraw collateral from the bank and repay the borrowed amount\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        /// Ensure that the Loan to Value (LTV) ratio remains within accepted boundaries\n        _validateMaxLTV(param.strategyId);\n\n        /// 7. Refund any remaining tokens to the owner\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /// @dev Calculate the parameters required for joining a Balancer pool.\n    /// @param vault Address of the Balancer vault\n    /// @param tokens List of tokens in the Balancer pool\n    /// @param balances Balances of tokens in the Balancer pool\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return maxAmountsIn Maximum amounts to deposit for each token\n    /// @return amountsIn Amounts of each token to deposit\n    /// @return poolAmountOut Amount of LP tokens to be received\n    function _getJoinPoolParamsAndApprove(\n        address vault,\n        address[] memory tokens,\n        uint256[] memory balances,\n        address lpToken\n    ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n        uint256 i;\n        uint256 j;\n        uint256 length = tokens.length;\n        uint256[] memory maxAmountsIn = new uint256[](length);\n        uint256[] memory amountsIn = new uint256[](length);\n        bool isLPIncluded;\n\n        for (i; i != length; ) {\n            if (tokens[i] != lpToken) {\n                amountsIn[j] = IERC20(tokens[i]).balanceOf(address(this));\n                if (amountsIn[j] > 0) {\n                    _ensureApprove(tokens[i], vault, amountsIn[j]);\n                }\n                ++j;\n            } else isLPIncluded = true;\n\n            maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (isLPIncluded) {\n            assembly {\n                mstore(amountsIn, sub(mload(amountsIn), 1))\n            }\n        }\n\n        uint256 totalLPSupply = IBalancerPool(lpToken).getActualSupply();\n        /// compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n        uint256 poolAmountOut;\n        for (i = 0; i != length; ) {\n            if ((maxAmountsIn[i] * totalLPSupply) / balances[i] != 0) {\n                poolAmountOut = type(uint256).max;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (maxAmountsIn, amountsIn, poolAmountOut);\n    }\n\n    /// @dev Calculate the parameters required for exiting a Balancer pool.\n    /// @param borrowToken The token to be borrowed\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return minAmountsOut Minimum amounts to receive for each token upon exiting\n    /// @return tokens List of tokens in the Balancer pool\n    /// @return exitTokenIndex Index of the borrowToken in the tokens list\n    function _getExitPoolParams(\n        address borrowToken,\n        address lpToken\n    ) internal view returns (uint256[] memory, address[] memory, uint256) {\n        (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n\n        uint256 length = tokens.length;\n        uint256[] memory minAmountsOut = new uint256[](length);\n        uint256 exitTokenIndex;\n\n        for (uint256 i; i != length; ) {\n            if (tokens[i] == borrowToken) break;\n\n            if (tokens[i] != lpToken) ++exitTokenIndex;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (minAmountsOut, tokens, exitTokenIndex);\n    }\n}"
    }
  ]
}