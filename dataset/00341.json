{
  "Title": "H-8: It is possible to DoS batch auctions by submitting invalid AltBn128 points when bidding",
  "Content": "# Issue H-8: It is possible to DoS batch auctions by submitting invalid AltBn128 points when bidding \n\nSource: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/147 \n\n## Found by \nhash, underdog\n## Summary\n\nBidders can submit invalid points for the AltBn128 elliptic curve. The invalid points will make the decrypting process always revert, effectively DoSing the auction process, and locking funds forever in the protocol.\n\n## Vulnerability Detail\n\nAxis finance supports a sealed-auction type of auctions, which is achieved in the Encrypted Marginal Price Auction module by leveraging the ECIES encryption scheme. Axis will specifically use a simplified ECIES implementation that uses the AltBn128 curve, which is a curve with generator point (1,2) and the following formula:\n\n$$\ny^2 = x^3 + 3\n$$\n\nBidders will submit encrypted bids to the protocol. One of the parameters required to be submitted by the bidders so that bids can later be decrypted is a public key that will be used in the EMPA decryption process:\n\n```solidity\n// EMPAM.sol\n\nfunction _bid(\n        uint96 lotId_, \n        address bidder_,\n        address referrer_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal override returns (uint64 bidId) {\n        // Decode auction data \n        (uint256 encryptedAmountOut, Point memory bidPubKey) = \n            abi.decode(auctionData_, (uint256, Point));\n \n        ...\n\n        // Check that the bid public key is a valid point for the encryption library\n        if (!ECIES.isValid(bidPubKey)) revert Auction_InvalidKey(); \n   \n       ...\n\n        return bidId;\n    }\n```\n\nAs shown in the code snippet, bidders will submit a `bidPubKey`, which consists in an x and y coordinate (this is actually the public key, which can be represented as a point with x and y coordinates over an elliptic curve).\n\nThe `bidPubKey` point will then be validated by the ECIES library’s `isValid()` function. Essentially, this function will perform three checks:\n\n1. Verify that the point provided is on the AltBn128 curve\n2. Ensure the x and y coordinates of the point provided don’t correspond to the generator point (1, 2)\n3. Ensure that the x and y coordinates of the point provided don’t corrspond to the point at infinity (0,0)\n\n```solidity\n// ECIES.sol\n\nfunction isOnBn128(Point memory p) public pure returns (bool) {\n        // check if the provided point is on the bn128 curve y**2 = x**3 + 3, which has generator point (1, 2)\n        return _fieldmul(p.y, p.y) == _fieldadd(_fieldmul(p.x, _fieldmul(p.x, p.x)), 3);\n    }\n \n    /// @notice Checks whether a point is valid. We consider a point valid if it is on the curve and not the generator point or the point at infinity.\n    function isValid(Point memory p) public pure returns (bool) { \n        return isOnBn128(p) && !(p.x == 1 && p.y == 2) && !(p.x == 0 && p.y == 0); \n    }\n```\n\nAlthough these checks are correct, one important check is missing in order to consider that the point is actually a valid point in the AltBn128 curve.\n\nAs a summary, ECC incorporates the concept of [finite fields](https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc#elliptic-curves-over-finite-fields). Essentially, the elliptic curve is considered as a square matrix of size pxp, where p is the finite field (in our case, the finite field defined in Axis’ `ECIES.sol` library is stord in the `FIELD_MODULUS` constant with a value of `21888242871839275222246405745257275088696311157297823662689037894645226208583`). The curve equation then takes this form:\n\n$$\ny2 = x^3 + ax + b  (mod p)\n$$\n\nNote that because the function is now limited to a field of pxp, any point provided that has an x or y coordinate greater than the modulus will fall outside of the matrix, thus being invalid. In other words, if x > p or y > p, the point should be considered invalid. However, as shown in the previous snippet of code, this check is not performed in Axis’ ECIES implementation. \n\nThis enables a malicious bidder to provide an invalid point with an x or y coordinate greater than the field, but that still passes the checked conditions in the ECIES library. The `isValid()` check will pass and the bid will be successfully submitted, although the public key is theoretically invalid. \n\nThis leads us to the second part of the attack. When the auction concludes, the decryption process will begin. The process consists in:\n\n1. Calling the `decryptAndSortBids()` function. This will trigger the internal `_decryptAndSortBids()` function. It is important to note that this function will only set the status of the auction to `Decrypted` if ALL the bids submitted have been decrypted. Otherwise, the auction can’t continue.\n2. `_decryptAndSortBids()` will call the internal `_decrypt()` function for each of the bids submittted\n3. `_decrypt()` will finally call the ECIES’ `decrypt()` function so that the bid can be decrypted: \n    \n    ```solidity\n    // EMPAM.sol\n    \n    function _decrypt(\n            uint96 lotId_,\n            uint64 bidId_,\n            uint256 privateKey_\n        ) internal view returns (uint256 amountOut) {\n            // Load the encrypted bid data\n            EncryptedBid memory encryptedBid = encryptedBids[lotId_][bidId_];\n    \n            // Decrypt the message\n            // We expect a salt calculated as the keccak256 hash of lot id, bidder, and amount to provide some (not total) uniqueness to the encryption, even if the same shared secret is used\n            Bid storage bidData = bids[lotId_][bidId_];\n            uint256 message = ECIES.decrypt(\n                encryptedBid.encryptedAmountOut,\n                encryptedBid.bidPubKey, \n                privateKey_, \n                uint256(keccak256(abi.encodePacked(lotId_, bidData.bidder, bidData.amount))) // @audit-issue [MEDIUM] - Missing bidId in salt creates the edge case where a bid susceptible of being discovered if a user places two bids with the same input amount. Because the same key will be used when performing the XOR, the symmetric key can be extracted, thus potentially revealing the bid amounts.\n            ); \n       \n            \n            ...\n        } \n    ```\n    \n    As shown in the code snippet, one of the parameters passed to the `ECIES.decrypt()`  function will be the `encryptedBid.bidPubKey` (the invalid point provided by the malicious bidder). As we can see, the first step performed by `ECIES.decrypt()` will be to call the `recoverSharedSecret()` function, passing the invalid public key (`ciphertextPubKey_`) and the auction’s global `privateKey_` as parameter:\n    \n    ```solidity\n    // ECIES.sol\n    \n    function decrypt(\n            uint256 ciphertext_,\n            Point memory ciphertextPubKey_,\n            uint256 privateKey_,\n            uint256 salt_\n        ) public view returns (uint256 message_) {\n            // Calculate the shared secret\n            // Validates the ciphertext public key is on the curve and the private key is valid\n            uint256 sharedSecret = recoverSharedSecret(ciphertextPubKey_, privateKey_);\n    \n            ...\n        }\n        \n      function recoverSharedSecret(\n            Point memory ciphertextPubKey_,\n            uint256 privateKey_\n        ) public view returns (uint256) {\n    \t      ...\n    \t      \n            Point memory p = _ecMul(ciphertextPubKey_, privateKey_);\n    \n            return p.x;\n        }\n        \n       function _ecMul(Point memory p, uint256 scalar) private view returns (Point memory p2) {\n            (bool success, bytes memory output) =\n                address(0x07).staticcall{gas: 6000}(abi.encode(p.x, p.y, scalar));\n    \n            if (!success || output.length == 0) revert(\"ecMul failed.\");\n    \n            p2 = abi.decode(output, (Point));\n        }\n    ```\n    \n\nAmong other things, `recoverSharedSecret()` will execute a scalar multiplication between the invalid public key and the global private key via the `ecMul` precompile. This is where the denial of servide will take place.\n\nThe ecMul precompile contract was incorporated in [EIP-196](https://eips.ethereum.org/EIPS/eip-196). Checking the EIP’s [exact semantics section](https://eips.ethereum.org/EIPS/eip-196#exact-semantics), we can see that inputs will be considered invalid if “… any of the field elements (point coordinates) is equal or larger than the field modulus p, the contract fails”. Because the point submitted by the bidder had one of the x or y coordinates bigger than the field modulus p (because Axis never validated that such value was smaller than the field), the call to the ecmul precompile will fail, reverting with the “ecMul failed.” error.\n\nBecause the decryption process expects ALL the bids submitted for an auction to be decrypted prior to actually setting the auctions state to `Decrypted`, if only one bid decryption fails, the decryption process won’t be completed, and the whole auction process (decrypting, settling, …) won’t be executable because the auction never reaches the `Decrypted` state.\n\n## Proof of Concept\n\nThe following proof of concept shows a reproduction of the attack mentioned above. In order to reproduce it, following these steps:\n\n1. Inside `EMPAModuleTest.sol`, change the `_createBidData()` function so that it uses the (21888242871839275222246405745257275088696311157297823662689037894645226208584, 2) point instead of the `_bidPublicKey` variable. This is a valid point as per Axis’ checks, but it is actually invalid given that the x coordinate is greater than the field modulus:\n    \n    ```diff\n    // EMPAModuleTest.t.sol\n    \n    function _createBidData(\n            address bidder_,\n            uint96 amountIn_,\n            uint96 amountOut_\n        ) internal view returns (bytes memory) {\n            uint256 encryptedAmountOut = _encryptBid(_lotId, bidder_, amountIn_, amountOut_);\n     \n    -        return abi.encode(encryptedAmountOut, _bidPublicKey);\n    +        return abi.encode(encryptedAmountOut, Point({x: 21888242871839275222246405745257275088696311157297823662689037894645226208584, y: 2}));\n        }        \n    \n    ```\n    \n2. Paste the following code in `moonraker/test/modules/auctions/EMPA/decryptAndSortBids.t.sol`:\n    \n    ```solidity\n    // decryptAndSortBids.t.sol\n    \n    function testBugdosDecryption()\n            external\n            givenLotIsCreated\n            givenLotHasStarted\n            givenBidIsCreated(_BID_AMOUNT, _BID_AMOUNT_OUT) \n            givenBidIsCreated(_BID_AMOUNT, _BID_AMOUNT_OUT) \n            givenLotHasConcluded  \n            givenPrivateKeyIsSubmitted\n        {\n    \n            vm.expectRevert(\"ecMul failed.\");\n            _module.decryptAndSortBids(_lotId, 1);\n    \n        }\n    ```\n    \n3. Run the test inside `moonraker` with the following command: `forge test --mt testBugdosDecryption`\n\n## Impact\n\nHigh. A malicious bidder can effectively DoS the decryption process, which will prevent all actions in the protocol from being executed. This attack will make all the bids and prefunded auction funds remain stuck forever in the contract, because all the functions related to the post-concluded auction steps expect the bids to be first decrypted.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/auctions/EMPAM.sol#L250\n\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/lib/ECIES.sol#L138\n\nhttps://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/lib/ECIES.sol#L133\n\n## Tool used\n\nManual Review, foundry\n\n## Recommendation\n\nEnsure that the x and y coordinates are smaller than the field modulus inside the `ECIES.sol` `isValid()` function, adding the `p.x < FIELD_MODULUS && p.y < FIELD_MODULUS` check so that invalid points can’t be submitted:\n\n```diff\n// ECIES.sol\n\nfunction isValid(Point memory p) public pure returns (bool) { \n-        return isOnBn128(p) && !(p.x == 1 && p.y == 2) && !(p.x == 0 && p.y == 0); \n+        return isOnBn128(p) && !(p.x == 1 && p.y == 2) && !(p.x == 0 && p.y == 0) && (p.x < FIELD_MODULUS && p.y < FIELD_MODULUS); \n   }\n```\n\n\n\n## Discussion\n\n**0xJem**\n\nDuplicate of https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/185\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Axis-Fi/moonraker/pull/138\n\n\n**10xhash**\n\n> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#138](https://github.com/Axis-Fi/moonraker/pull/138)\n\nFixed\nNow coordinates are checked to be less than FIELD_MODULUS\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/206",
  "Code": [
    {
      "filename": "moonraker/src/modules/auctions/EMPAM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n/// Protocol dependencies\nimport {AuctionModule, Auction} from \"src/modules/Auction.sol\";\nimport {Veecode, toVeecode} from \"src/modules/Modules.sol\";\n\n// Libraries\nimport {FixedPointMathLib as Math} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {ECIES, Point} from \"src/lib/ECIES.sol\";\nimport {MaxPriorityQueue, Queue, Bid as QueueBid} from \"src/lib/MaxPriorityQueue.sol\";\n\ncontract EncryptedMarginalPriceAuctionModule is AuctionModule {\n    using MaxPriorityQueue for Queue;\n\n    // ========== ERRORS ========== //\n    error Auction_InvalidKey();\n    error Auction_WrongState(uint96 lotId); // TODO shift into Auction?\n    error Bid_WrongState(uint96 lotId, uint64 bidId);\n    error NotPermitted(address caller);\n\n    // ========== EVENTS ========== //\n    event BidDecrypted(\n        uint96 indexed lotId, uint64 indexed bidId, uint96 amountIn, uint96 amountOut\n    );\n\n    // ========== DATA STRUCTURES ========== //\n\n    enum BidStatus {\n        Submitted,\n        Decrypted,\n        // Bid status will also be set to claimed if the bid is cancelled/refunded\n        Claimed\n    }\n\n    /// @notice        Core data for a bid\n    ///\n    /// @param         status              The status of the bid\n    /// @param         bidder              The address of the bidder\n    /// @param         amount              The amount of the bid\n    /// @param         minAmountOut        The minimum amount out (not set until the bid is decrypted)\n    /// @param         referrer            The address of the referrer\n    struct Bid {\n        address bidder; // 20 +\n        uint96 amount; // 12 = 32 - end of slot 1\n        uint96 minAmountOut; // 12 +\n        address referrer; // 20 = 32 - end of slot 2\n        BidStatus status; // 1 - slot 3\n    }\n\n    /// @notice        Struct containing data for an encrypted bid\n    ///\n    /// @param         encryptedAmountOut  The encrypted amount out, the bid amount is encrypted with a symmetric key that can be derived from the bidPubKey using the private key for the provided auction public key on the alt_bn128 curve\n    /// @param         bidPubKey           The alt_bn128 public key used to encrypt the amount out (see bid() for more details)\n    struct EncryptedBid {\n        uint256 encryptedAmountOut;\n        Point bidPubKey;\n    }\n\n    /// @notice        Struct containing auction-specific data\n    ///\n    /// @param         status              The status of the auction\n    /// @param         nextBidId           The ID of the next bid to be submitted\n    /// @param         nextDecryptIndex    The index of the next bid to decrypt\n    /// @param         marginalPrice       The marginal price of the auction (determined at settlement, blank before)\n    /// @param         publicKey           The public key used to encrypt bids (a point on the alt_bn128 curve from the generator point (1,2))\n    /// @param         privateKey          The private key used to decrypt bids (not provided until after the auction ends)\n    /// @param         bidIds              The list of bid IDs to decrypt in order of submission, excluding cancelled bids\n    struct AuctionData {\n        uint64 nextBidId; // 8 +\n        uint96 marginalPrice; // 12 +\n        uint96 minPrice; // 12 = 32 - end of slot 1\n        uint64 nextDecryptIndex; // 8 +\n        uint96 minFilled; // 12 +\n        uint96 minBidSize; // 12 = 32 - end of slot 2\n        Auction.Status status; // 1 +\n        uint64 marginalBidId; // 8 = 9 - end of slot 3\n        Point publicKey; // 64 - slots 4 and 5\n        uint256 privateKey; // 32 - slot 6\n        uint64[] bidIds; // slots 7+\n    }\n\n    struct AuctionDataParams {\n        uint96 minPrice;\n        uint24 minFillPercent;\n        uint24 minBidPercent;\n        Point publicKey;\n    }\n\n    /// @dev    Memory only, no need to pack\n    struct MarginalPriceResult {\n        uint96 marginalPrice;\n        uint64 marginalBidId;\n        uint64 partialFillBidId;\n        uint256 totalAmountIn;\n        uint256 capacityExpended;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice Constant for percentages\n    /// @dev    1% = 1_000 or 1e3. 100% = 100_000 or 1e5.\n    uint24 internal constant _MIN_BID_PERCENT = 10; // 0.01%\n\n    /// @notice     Auction-specific data for a lot\n    mapping(uint96 lotId => AuctionData) public auctionData;\n\n    /// @notice     General information about bids on a lot\n    mapping(uint96 lotId => mapping(uint64 bidId => Bid)) public bids;\n\n    /// @notice     Data for encryption information for a specific bid\n    mapping(uint96 lotId => mapping(uint64 bidId => EncryptedBid)) public encryptedBids; // each encrypted amount is 5 slots (length + 4 slots) due to using 1024-bit RSA encryption\n\n    /// @notice     Queue of decrypted bids for a lot (populated on decryption)\n    mapping(uint96 lotId => Queue) public decryptedBids;\n\n    // ========== SETUP ========== //\n\n    constructor(address auctionHouse_) AuctionModule(auctionHouse_) {\n        // Set the minimum auction duration to 1 day initially\n        minAuctionDuration = 1 days;\n    }\n\n    function VEECODE() public pure override returns (Veecode) {\n        return toVeecode(\"01EMPAM\");\n    }\n\n    function TYPE() public pure override returns (Type) {\n        return Type.Auction;\n    }\n\n    // ========== MODIFIERS ========== //\n\n    // ========== AUCTION ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The start and duration of the lot have been validated\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The minimum price is zero\n    ///             - The minimum fill percent is greater than 100%\n    ///             - The minimum bid percent is less than the minimum or greater than 100%\n    ///             - The public key is not valid\n    function _auction(uint96 lotId_, Lot memory lot_, bytes memory params_) internal override {\n        // Decode implementation params\n        AuctionDataParams memory implParams = abi.decode(params_, (AuctionDataParams));\n\n        // Validate params\n\n        // minPrice must not be zero\n        if (implParams.minPrice == 0) revert Auction_InvalidParams();\n\n        // minFillPercent must be less than or equal to 100%\n        if (implParams.minFillPercent > _ONE_HUNDRED_PERCENT) revert Auction_InvalidParams();\n\n        // minBidPercent must be greater than or equal to the global min and less than or equal to 100%\n        if (\n            implParams.minBidPercent < _MIN_BID_PERCENT\n                || implParams.minBidPercent > _ONE_HUNDRED_PERCENT\n        ) {\n            revert Auction_InvalidParams();\n        }\n\n        // publicKey must be a valid point for the encryption library\n        if (!ECIES.isValid(implParams.publicKey)) revert Auction_InvalidParams();\n\n        // Set auction data\n        AuctionData storage data = auctionData[lotId_];\n        data.minPrice = implParams.minPrice;\n        // These calculations won't overflow if capacity doesn't overflow uint96 because the minFillPercent and minBidPercent are both less than or equal to 100%\n        // We round up to be conservative with the minimums\n        data.minFilled = uint96(\n            Math.mulDivUp(\n                uint256(lot_.capacity),\n                uint256(implParams.minFillPercent),\n                uint256(_ONE_HUNDRED_PERCENT)\n            )\n        );\n        data.minBidSize = uint96(\n            Math.mulDivUp(\n                uint256(lot_.capacity), implParams.minBidPercent, uint256(_ONE_HUNDRED_PERCENT)\n            )\n        );\n        data.publicKey = implParams.publicKey;\n        data.nextBidId = 1;\n\n        decryptedBids[lotId_].initialize();\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function assumes the following:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction has not concluded\n    ///\n    ///             This function reverts if:\n    ///             - The auction is active or has not concluded\n    function _cancelAuction(uint96 lotId_) internal override {\n        // Validation\n        // Batch auctions cannot be cancelled once started, otherwise the seller could cancel the auction after bids have been submitted\n        _revertIfLotActive(lotId_);\n\n        // Set auction status to claimed so that bids can be refunded\n        auctionData[lotId_].status = Auction.Status.Claimed;\n    }\n\n    // ========== BID ========== //\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Stores the encrypted bid\n    ///             - Adds the bid ID to the list of bids to decrypt (in `AuctionData.bidIds`)\n    ///             - Returns the bid ID\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///\n    ///             This function reverts if:\n    ///             - The parameters cannot be decoded into the correct format\n    ///             - The amount is less than the minimum bid size for the lot\n    ///             - The bid public key is not valid\n    function _bid(\n        uint96 lotId_,\n        address bidder_,\n        address referrer_,\n        uint96 amount_,\n        bytes calldata auctionData_\n    ) internal override returns (uint64 bidId) {\n        // Decode auction data\n        (uint256 encryptedAmountOut, Point memory bidPubKey) =\n            abi.decode(auctionData_, (uint256, Point));\n\n        // Validate inputs\n\n        // Amount must be at least the minimum bid size at the minimum price\n        uint256 minAmount = Math.mulDivDown(\n            uint256(auctionData[lotId_].minBidSize),\n            uint256(auctionData[lotId_].minPrice),\n            10 ** lotData[lotId_].baseTokenDecimals\n        );\n        if (amount_ < minAmount) revert Auction_AmountLessThanMinimum();\n\n        // Check that the bid public key is a valid point for the encryption library\n        if (!ECIES.isValid(bidPubKey)) revert Auction_InvalidKey();\n\n        // Store bid data\n        bidId = auctionData[lotId_].nextBidId++;\n        Bid storage userBid = bids[lotId_][bidId];\n        userBid.bidder = bidder_;\n        userBid.amount = amount_;\n        userBid.referrer = referrer_;\n        userBid.status = BidStatus.Submitted;\n\n        // Store encrypted amount out and bid public key\n        encryptedBids[lotId_][bidId] = EncryptedBid(encryptedAmountOut, bidPubKey);\n\n        // Push bid ID to list of bids to decrypt\n        auctionData[lotId_].bidIds.push(bidId);\n\n        return bidId;\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as refunded\n    ///             - Removes the bid from the list of bids to decrypt\n    ///             - Returns the amount to be refunded\n    ///\n    ///             The encrypted bid is not deleted from storage, so that the details can be fetched later.\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The bid ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is active\n    ///             - The bid has already been refunded\n    function _refundBid(\n        uint96 lotId_,\n        uint64 bidId_,\n        address\n    ) internal override returns (uint96 refund) {\n        // Set bid status to claimed\n        bids[lotId_][bidId_].status = BidStatus.Claimed;\n\n        // Remove bid from list of bids to decrypt\n        uint64[] storage bidIds = auctionData[lotId_].bidIds;\n        uint256 len = bidIds.length;\n        for (uint256 i; i < len; i++) {\n            if (bidIds[i] == bidId_) {\n                bidIds[i] = bidIds[len - 1];\n                bidIds.pop();\n                break;\n            }\n        }\n\n        // Return the amount to be refunded\n        return bids[lotId_][bidId_].amount;\n    }\n\n    /// @notice     Claims a bid and calculates the paid and payout amounts\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as claimed\n    ///             - Calculates the paid and payout amounts\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The bid ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is not settled\n    ///             - The bid has not already been claimed\n    function _claimBid(\n        uint96 lotId_,\n        uint64 bidId_\n    ) internal returns (BidClaim memory bidClaim, bytes memory auctionOutput_) {\n        // Load bid data\n        Bid storage bidData = bids[lotId_][bidId_];\n\n        // Set the bid status to claimed\n        bidData.status = BidStatus.Claimed;\n\n        // Load the referrer and bidder\n        bidClaim.bidder = bidData.bidder;\n        bidClaim.referrer = bidData.referrer;\n\n        // Calculate the bid price\n        uint256 baseScale = 10 ** lotData[lotId_].baseTokenDecimals;\n        uint96 price = uint96(\n            bidData.minAmountOut == 0\n                ? 0 // TODO technically minAmountOut == 0 should be an infinite price, but need to check that later. Need to be careful we don't introduce a way to claim a bid when we set marginalPrice to type(uint96).max when it cannot be settled.\n                : Math.mulDivUp(uint256(bidData.amount), baseScale, uint256(bidData.minAmountOut))\n        );\n\n        // If the bid price is greater than the marginal price, the bid is filled.\n        // If the bid price is equal to the marginal price and the bid was submitted before or is the marginal bid, the bid is filled.\n        // Auctions that do not meet capacity or price thresholds to settle will have their marginal price set at the maximum uint96\n        // Therefore, all bids will be refunded.\n        // We handle the only potential marginal fill during settlement. All other bids are either completely filled or refunded.\n        uint96 marginalPrice = auctionData[lotId_].marginalPrice;\n        if (\n            price > marginalPrice\n                || (price == marginalPrice && bidId_ <= auctionData[lotId_].marginalBidId)\n        ) {\n            // Payout is calculated using the marginal price of the auction\n            bidClaim.paid = bidData.amount;\n            bidClaim.payout = uint96(Math.mulDivDown(bidClaim.paid, baseScale, marginalPrice));\n        } else {\n            // Bidder is refunded the paid amount and receives no payout\n            bidClaim.paid = bidData.amount;\n        }\n\n        return (bidClaim, auctionOutput_);\n    }\n\n    /// @inheritdoc AuctionModule\n    /// @dev        This function performs the following:\n    ///             - Validates inputs\n    ///             - Marks the bid as claimed\n    ///             - Calculates the paid and payout amounts\n    ///\n    ///             This function assumes:\n    ///             - The lot ID has been validated\n    ///             - The caller has been authorized\n    ///             - The auction is not settled\n    function _claimBids(\n        uint96 lotId_,\n        uint64[] calldata bidIds_\n    ) internal override returns (BidClaim[] memory bidClaims, bytes memory auctionOutput_) {\n        uint256 len = bidIds_.length;\n        bidClaims = new BidClaim[](len);\n        for (uint256 i; i < len; i++) {\n            // Validate\n            _revertIfBidInvalid(lotId_, bidIds_[i]);\n            _revertIfBidClaimed(lotId_, bidIds_[i]);\n\n            (bidClaims[i],) = _claimBid(lotId_, bidIds_[i]);\n        }\n\n        return (bidClaims, auctionOutput_);\n    }\n\n    // ========== DECRYPTION ========== //\n\n    /// @notice         Submits the private key for the auction lot and decrypts an initial number of bids\n    ///                 It does not require gating. If the seller wishes to limit who can call, they can simply not reveal the key to anyone else.\n    ///                 On the other hand, if a key management service is used, then anyone can call it once the key is revealed.\n    ///\n    /// @dev            This function reverts if:\n    ///                 - The lot ID is invalid\n    ///                 - The lot is not active\n    ///                 - The lot has not concluded\n    ///                 - The private key has already been submitted\n    function submitPrivateKey(uint96 lotId_, uint256 privateKey_, uint64 num_) external {\n        // Validation\n        _revertIfLotInvalid(lotId_);\n        _revertIfLotActive(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n\n        // Revert if the private key has already been verified and set\n        if (auctionData[lotId_].privateKey != 0) revert Auction_WrongState(lotId_);\n\n        // Check that the private key is valid for the public key\n        // We assume that all public keys are derived from the same generator: (1, 2)\n        Point memory calcPubKey = ECIES.calcPubKey(Point(1, 2), privateKey_);\n        Point memory pubKey = auctionData[lotId_].publicKey;\n        if (calcPubKey.x != pubKey.x || calcPubKey.y != pubKey.y) revert Auction_InvalidKey();\n\n        // Store the private key\n        auctionData[lotId_].privateKey = privateKey_;\n\n        // Decrypt and sort bids\n        _decryptAndSortBids(lotId_, num_);\n    }\n\n    /// @notice         Decrypts a batch of bids and sorts them by price in descending order\n    /// @dev            This function handles the following:\n    ///                 - Performs state validation\n    ///                 - Iterates over the encrypted bids:\n    ///                     - Decrypts the bid\n    ///                     - Ignores if the bid is incorrectly encrypted\n    ///                     - Does not add to the sorted bid queue if the decrypted amount out is less than the minimum bid size or overflows\n    ///                     - Otherwise, adds to the sorted bid queue for use during settlement\n    ///                 - Determines the next decrypt index\n    ///                 - Sets the auction status to decrypted if all bids have been decrypted\n    ///\n    ///                 This function reverts if:\n    ///                 - The lot ID is invalid\n    ///                 - The lot has not concluded\n    ///                 - The lot has already been decrypted in full\n    ///                 - The private key has not been provided\n    ///\n    /// @param          lotId_          The lot ID of the auction to decrypt bids for\n    /// @param          num_            The number of bids to decrypt. Reduced to the number remaining if greater.\n    function decryptAndSortBids(uint96 lotId_, uint64 num_) external {\n        // Check that lotId is valid\n        _revertIfLotInvalid(lotId_);\n        _revertIfBeforeLotStart(lotId_);\n        _revertIfLotActive(lotId_);\n\n        // Revert if already decrypted or if the private key has not been provided\n        if (\n            auctionData[lotId_].status != Auction.Status.Created\n                || auctionData[lotId_].privateKey == 0\n        ) {\n            revert Auction_WrongState(lotId_);\n        }\n\n        // Decrypt and sort bids\n        _decryptAndSortBids(lotId_, num_);\n    }\n\n    function _decryptAndSortBids(uint96 lotId_, uint64 num_) internal {\n        // Load next decrypt index and min bid size\n        AuctionData storage lotBidData = auctionData[lotId_];\n        uint64 nextDecryptIndex = lotBidData.nextDecryptIndex;\n        uint96 minBidSize = auctionData[lotId_].minBidSize;\n\n        // Check that the number of decrypts is less than or equal to the number of bids remaining to be decrypted\n        // If so, reduce to the number remaining\n        uint64[] storage bidIds = auctionData[lotId_].bidIds;\n        if (num_ > bidIds.length - nextDecryptIndex) {\n            num_ = uint64(bidIds.length) - nextDecryptIndex;\n        }\n\n        // Iterate over the provided number of bids, decrypt them, and then store them in the sorted bid queue\n        // All submitted bids will be marked as decrypted, but only those with valid values will have the minAmountOut set and be stored in the sorted bid queue\n        for (uint64 i; i < num_; i++) {\n            // Load encrypted bid\n            uint64 bidId = bidIds[nextDecryptIndex + i];\n\n            // Decrypt the bid\n            uint96 amountOut;\n            {\n                uint256 result = _decrypt(lotId_, bidId, lotBidData.privateKey);\n\n                // Only set the amount out if it is less than or equal to the maximum value of a uint96\n                if (result <= type(uint96).max) {\n                    amountOut = uint96(result);\n                }\n            }\n\n            // Set bid status to decrypted\n            Bid storage bidData = bids[lotId_][bidId];\n            bidData.status = BidStatus.Decrypted;\n\n            // Only store the decrypt if the amount out is greater than or equal to the minimum bid size\n            if (amountOut > 0 && amountOut >= minBidSize) {\n                // Only store the decrypt if the price does not overflow\n                // We don't need to check for a zero bid price, because the smallest possible bid price is 1, due to the use of mulDivUp\n                // 1 * 10^6 / type(uint96).max = 1\n                if (\n                    Math.mulDivUp(\n                        uint256(bidData.amount),\n                        10 ** lotData[lotId_].baseTokenDecimals,\n                        uint256(amountOut)\n                    ) < type(uint96).max\n                ) {\n                    // Store the decrypt in the sorted bid queue and set the min amount out on the bid\n                    decryptedBids[lotId_].insert(bidId, bidData.amount, amountOut);\n                    bidData.minAmountOut = amountOut;\n                }\n            }\n\n            // Emit event\n            emit BidDecrypted(lotId_, bidId, bidData.amount, amountOut);\n        }\n\n        // Increment next decrypt index\n        auctionData[lotId_].nextDecryptIndex += num_;\n\n        // If all bids have been decrypted, set auction status to decrypted\n        if (auctionData[lotId_].nextDecryptIndex == bidIds.length) {\n            auctionData[lotId_].status = Auction.Status.Decrypted;\n        }\n    }\n\n    function _decrypt(\n        uint96 lotId_,\n        uint64 bidId_,\n        uint256 privateKey_\n    ) internal view returns (uint256 amountOut) {\n        // Load the encrypted bid data\n        EncryptedBid memory encryptedBid = encryptedBids[lotId_][bidId_];\n\n        // Decrypt the message\n        // We expect a salt calculated as the keccak256 hash of lot id, bidder, and amount to provide some (not total) uniqueness to the encryption, even if the same shared secret is used\n        Bid storage bidData = bids[lotId_][bidId_];\n        uint256 message = ECIES.decrypt(\n            encryptedBid.encryptedAmountOut,\n            encryptedBid.bidPubKey,\n            privateKey_,\n            uint256(keccak256(abi.encodePacked(lotId_, bidData.bidder, bidData.amount)))\n        );\n\n        // Convert the message into the amount out\n        // We don't need larger than 16 bytes for a message\n        // To avoid attacks that check for leading zero values, encrypted bids should use a 128-bit random number\n        // as a seed to randomize the message. The seed should be the first 16 bytes.\n        // During encryption, we subtract the seed from the amount out to get a masked value.\n        // After decryption, we can combine them again (adding the seed to the masked value) and get the amount out\n        // This works due to the overflow/underflow properties of modular arithmetic\n        uint128 maskedValue = uint128(message);\n        uint128 seed = uint128(message >> 128);\n\n        // We want to allow underflow here\n        unchecked {\n            amountOut = uint256(maskedValue + seed);\n        }\n    }\n\n    // ========== SETTLEMENT ========== //\n\n    /// @notice         Helper function to get the next bid from the queue and calculate the price\n    /// @dev            This is split into a different function to avoid stack too deep errors\n    ///\n    /// @param          queue_          The queue to get the next bid from\n    /// @param          baseScale_      The scaling factor for the base token\n    /// @return         bidId           The ID of the bid\n    /// @return         amountIn        The amount in of the bid (in quote token units)\n    /// @return         price           The price of the bid (in quote token units), or 0 if it could not be determined\n    function _getNextBid(\n        Queue storage queue_,\n        uint256 baseScale_\n    ) internal returns (uint64 bidId, uint96 amountIn, uint96 price) {\n        bidId = queue_.getMaxId();\n\n        // Load bid info (in quote token units)\n        QueueBid memory qBid = queue_.delMax();\n        amountIn = qBid.amountIn;\n\n        // A zero minAmountOut value should be filtered out during decryption. However, cover the case here to avoid a potential division by zero error that would brick settlement.\n        if (qBid.minAmountOut == 0) {\n            // A zero price would be filtered out being below the minimum price\n            return (bidId, amountIn, 0);\n        }\n\n        // Calculate the price of the bid\n        // Cannot overflow on cast back to uint96. It was checked during decryption.\n        price = uint96(Math.mulDivUp(amountIn, baseScale_, qBid.minAmountOut));\n\n        return (bidId, amountIn, price);\n    }\n\n    /// @notice     Calculates the marginal price of a lot\n    ///\n    /// @param      lotId_          The lot ID of the auction to calculate the marginal price for\n    /// @return     result          The result of the marginal price calculation\n    function _getLotMarginalPrice(uint96 lotId_)\n        internal\n        returns (MarginalPriceResult memory result)\n    {\n        // Cache values used in the loop\n        // Capacity is always in base token units for this auction type\n        uint256 capacity = lotData[lotId_].capacity;\n        uint256 baseScale = 10 ** lotData[lotId_].baseTokenDecimals;\n        AuctionData memory lotAuctionData = auctionData[lotId_];\n\n        // Iterate over bid queue (sorted in descending price) to calculate the marginal clearing price of the auction\n        {\n            Queue storage queue = decryptedBids[lotId_];\n            uint96 lastPrice;\n            uint64 lastBidId;\n            uint256 numBids = queue.getNumBids();\n            for (uint256 i = 0; i < numBids; i++) {\n                // A bid can be considered if:\n                // - the bid price is greater than or equal to the minimum\n                // - previous bids did not fill the capacity\n                //\n                // There is no need to check if the bid is the minimum bid size, as this was checked during decryption\n\n                // Get bid info\n                (uint64 bidId, uint96 amountIn, uint96 price) = _getNextBid(queue, baseScale);\n\n                // If the price is below the minimum price, then determine a marginal price from the previous bids with the knowledge that no other bids will be considered\n                // This will also handle a zero price returned from `_getNextBid()`, since `minPrice` is always greater than zero\n                if (price < lotAuctionData.minPrice) {\n                    // We know that the lastPrice was not sufficient to fill capacity or the loop would have exited\n                    // We check if minimum price can result in a fill. If so, find the exact marginal price between last price and minimum price\n                    // If not, we set the marginal price to the minimum price. Whether the capacity filled meets the minimum filled will be checked later in the settlement process.\n                    if (\n                        lotAuctionData.minPrice == 0\n                            || Math.mulDivDown(result.totalAmountIn, baseScale, lotAuctionData.minPrice)\n                                >= capacity\n                    ) {\n                        result.marginalPrice =\n                            uint96(Math.mulDivUp(result.totalAmountIn, baseScale, capacity));\n                    } else {\n                        result.marginalPrice = lotAuctionData.minPrice; // note this cannot be zero since it is checked above\n                    }\n\n                    // If the marginal price is re-calculated and is the same as the previous, we need to set the marginal bid id, otherwise the previous bid will not be able to claim.\n                    if (lastPrice == result.marginalPrice) {\n                        result.marginalBidId = lastBidId;\n                    }\n\n                    // Update capacity expended with the new marginal price\n                    result.capacityExpended = Math.mulDivDown(\n                        result.totalAmountIn, baseScale, uint256(result.marginalPrice)\n                    );\n                    // marginal bid id can be zero, there are no bids at the marginal price\n\n                    // Exit the outer loop\n                    break;\n                }\n\n                // Check if the auction can clear with the existing bids at a price between current price and last price\n                // There will be no partial fills because we select the price that exactly fills the capacity\n                // Note: totalAmountIn here has not had the current bid added to it\n                result.capacityExpended = Math.mulDivDown(result.totalAmountIn, baseScale, price);\n                if (result.capacityExpended >= capacity) {\n                    result.marginalPrice =\n                        uint96(Math.mulDivUp(result.totalAmountIn, baseScale, capacity));\n\n                    // If the marginal price is re-calculated and is the same as the previous, we need to set the marginal bid id, otherwise the previous bid will not be able to claim.\n                    if (lastPrice == result.marginalPrice) {\n                        result.marginalBidId = lastBidId;\n                    } else {\n                        result.marginalBidId = uint64(0); // we set this to zero so that any bids at the current price are not considered in the case that capacityExpended == capacity\n                    }\n\n                    // Calculate the capacity expended in the same way as before, instead of setting it to `capacity`\n                    // This will normally equal `capacity`, except when rounding would cause the the capacity expended to be slightly less than `capacity`\n                    result.capacityExpended =\n                        Math.mulDivDown(result.totalAmountIn, baseScale, result.marginalPrice); // updated based on the marginal price\n                    break;\n                }\n\n                // The current price will now be considered, so we can set this\n                lastPrice = price;\n                lastBidId = bidId;\n\n                // Increment total amount in\n                result.totalAmountIn += amountIn;\n\n                // Determine total capacity expended at this price (in base token units)\n                // quote scale * base scale / quote scale = base scale\n                result.capacityExpended =\n                    Math.mulDivDown(result.totalAmountIn, baseScale, uint256(price));\n\n                // If total capacity expended is greater than or equal to the capacity, we have found the marginal price\n                // If capacity expended is strictly greater than capacity, then we have a partially filled bid\n                if (result.capacityExpended >= capacity) {\n                    result.marginalPrice = price;\n                    result.marginalBidId = bidId;\n                    if (result.capacityExpended > capacity) {\n                        result.partialFillBidId = bidId;\n                    }\n                    break;\n                }\n\n                // If we have reached the end of the queue, we check the same cases as when the price of a bid is below the minimum price.\n                if (i == numBids - 1) {\n                    // We know that the price was not sufficient to fill capacity or the loop would have exited\n                    // We check if minimum price can result in a complete fill. If so, find the exact marginal price between last price and minimum price\n                    // If not, we set the marginal price to the minimum price. Whether the capacity filled meets the minimum filled will be checked l"
    }
  ]
}