{
  "Title": "H-4: PythOracle:if price.expo is less than 0, wrong prices will be recorded",
  "Content": "# Issue H-4: PythOracle:if price.expo is less than 0, wrong prices will be recorded \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/56 \n\n## Found by \nEmmanuel, minhtrng, panprog\nIn PythOracle#\\_recordPrice function, prices with negative exponents are not handled correctly, leading to a massive deviation in prices.\n\n## Vulnerability Detail\nHere is PythOracle#\\_recordPrice function:\n\n```solidity\n    function _recordPrice(uint256 oracleVersion, PythStructs.Price memory price) private {\n        _prices[oracleVersion] = Fixed6Lib.from(price.price).mul(\n            Fixed6Lib.from(SafeCast.toInt256(10 ** SafeCast.toUint256(price.expo > 0 ? price.expo : -price.expo)))\n        );\n        _publishTimes[oracleVersion] = price.publishTime;\n    }\n```\n\nIf price is 5e-5 for example, it will be recorded as 5e5\nIf price is 5e-6, it will be recorded as 5e6.\n\nAs we can see, there is a massive deviation in recorded price from actual price whenever price's exponent is negative\n\n## Impact\nWrong prices will be recorded.\nFor example,\nIf priceA is 5e-5, and priceB is 5e-6. But due to the wrong conversion,\n\n- There is a massive change in price(5e5 against 5e-5)\n- we know that priceA is ten times larger than priceB, but priceA will be recorded as ten times smaller than priceB.\n  Unfortunately, current payoff functions may not be able to take care of these discrepancies\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L203\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn PythOracle.sol, `_prices` mapping should not be ` mapping(uint256 => Fixed6) private _prices;`\nInstead, it should be ` mapping(uint256 => Price) private _prices;`, where Price is a struct that stores the price and expo:\n\n```solidity\nstruct Price{\n    Fixed6 price,\n    int256 expo\n}\n```\n\nThis way, the price exponents will be preserved, and can be used to scale the prices correctly wherever it is used.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> h\n\n\n\n**arjun-io**\n\nFixed: https://github.com/equilibria-xyz/perennial-v2/pull/53\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/Kept.sol\";\nimport \"../interfaces/IPythFactory.sol\";\n\n/// @title PythOracle\n/// @notice Pyth implementation of the IOracle interface.\n/// @dev One instance per Pyth price feed should be deployed. Multiple products may use the same\n///      PythOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract PythOracle is IPythOracle, Instance, Kept {\n    /// @dev A Pyth update must come at least this long after a version to be valid\n    uint256 constant private MIN_VALID_TIME_AFTER_VERSION = 12 seconds;\n\n    /// @dev A Pyth update must come at most this long after a version to be valid\n    uint256 constant private MAX_VALID_TIME_AFTER_VERSION = 15 seconds;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 constant private GRACE_PERIOD = 1 minutes;\n\n    /// @dev The multiplier for the keeper reward on top of cost\n    UFixed18 constant private KEEPER_REWARD_PREMIUM = UFixed18.wrap(1.5e18);\n\n    /// @dev The fixed gas buffer that is added to the keeper reward\n    uint256 constant private KEEPER_BUFFER = 80_000;\n\n    /// @dev Pyth contract\n    AbstractPyth public immutable pyth;\n\n    /// @dev Pyth price feed id\n    bytes32 public id;\n\n    /// @dev List of all requested oracle versions\n    uint256[] public versionList;\n\n    /// @dev Index in `versionList` of the next version a keeper should commit\n    uint256 public nextVersionIndexToCommit;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from oracle version to when its VAA was published to Pyth\n    mapping(uint256 => uint256) private _publishTimes;\n\n    /// @dev The time when the last committed update was published to Pyth\n    uint256 private _lastCommittedPublishTime;\n\n    /// @dev The oracle version that was most recently committed\n    /// @dev We assume that we cannot commit an oracle version of 0, so `_latestVersion` being 0 means that no version has been committed yet\n    uint256 private _latestVersion;\n\n     /// @notice Initializes the immutable contract state\n     /// @param pyth_ Pyth contract\n    constructor(AbstractPyth pyth_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param id_ price ID for Pyth price feed\n    /// @param chainlinkFeed_ Chainlink price feed for rewarding keeper in DSU\n    /// @param dsu_ Token to pay the keeper reward in\n    function initialize(bytes32 id_, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) external initializer(1) {\n        __Instance__initialize();\n        __UKept__initialize(chainlinkFeed_, dsu_);\n\n        if (!pyth.priceFeedExists(id_)) revert PythOracleInvalidPriceIdError(id_);\n\n        id = id_;\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @dev Original sender to optionally use for callbacks\n    function request(address) external onlyAuthorized {\n        if (versionList.length == 0 || versionList[versionList.length - 1] != block.timestamp) {\n            versionList.push(block.timestamp);\n        }\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return latestVersion Latest oracle version\n    function latest() public view returns (OracleVersion memory latestVersion) {\n        if (_latestVersion == 0) return latestVersion;\n\n        return latestVersion = OracleVersion(_latestVersion, _prices[_latestVersion], true);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IPythFactory(address(factory())).current();\n    }\n\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        Fixed6 price = _prices[timestamp];\n        return OracleVersion(timestamp, price, !price.isZero());\n    }\n\n    /// @notice Returns the next oracle version to commit\n    /// @return version The next oracle version to commit\n    function nextVersionToCommit() external view returns (uint256 version) {\n        if (versionList.length == 0 || nextVersionIndexToCommit >= versionList.length) return 0;\n        return versionList[nextVersionIndexToCommit];\n    }\n\n    /// @notice Commits the price represented by `updateData` to the next version that needs to be committed\n    /// @dev Will revert if there is an earlier versionIndex that could be committed with `updateData`\n    /// @param versionIndex The index of the version to commit\n    /// @param updateData The update data to commit\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, \"\")\n    {\n        // This check isn't necessary since the caller would not be able to produce a valid updateData\n        // with an update time corresponding to a null version, but reverting with a specific error is\n        // clearer.\n        if (nextVersionIndexToCommit >= versionList.length) revert PythOracleNoNewVersionToCommitError();\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n\n        uint256 versionToCommit = versionList[versionIndex];\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(versionToCommit, updateData);\n\n        if (pythPrice.publishTime <= _lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        _lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Ensure that the keeper is committing the earliest possible version\n        if (versionIndex > nextVersionIndexToCommit) {\n            uint256 previousVersion = versionList[versionIndex - 1];\n            // We can only skip the previous version if the grace period has expired\n            if (block.timestamp <= previousVersion + GRACE_PERIOD) revert PythOracleGracePeriodHasNotExpiredError();\n\n            // If the update is valid for the previous version, we can't skip the previous version\n            if (\n                pythPrice.publishTime >= previousVersion + MIN_VALID_TIME_AFTER_VERSION &&\n                pythPrice.publishTime <= previousVersion + MAX_VALID_TIME_AFTER_VERSION\n            ) revert PythOracleUpdateValidForPreviousVersionError();\n        }\n\n        _recordPrice(versionToCommit, pythPrice);\n        nextVersionIndexToCommit = versionIndex + 1;\n        _latestVersion = versionToCommit;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @dev This commit function may pay out a keeper reward if the commited version is valid\n    ///      for the next requested version to commit.\n    /// @param oracleVersion The oracle version to commit\n    /// @param updateData The update data to commit\n    function commit(uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (versionList.length > nextVersionIndexToCommit && oracleVersion >= versionList[nextVersionIndexToCommit]) {\n            commitRequested(nextVersionIndexToCommit, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Oracle version must be more recent than those of the most recently committed version\n        if (oracleVersion <= _latestVersion) revert PythOracleVersionTooOldError();\n\n        _recordPrice(oracleVersion, pythPrice);\n        _latestVersion = oracleVersion;\n    }\n\n    /// @notice Validates that update fees have been paid, and that the VAA represented by `updateData` is within `oracleVersion + MIN_VALID_TIME_AFTER_VERSION` and `oracleVersion + MAX_VALID_TIME_AFTER_VERSION`\n    /// @param oracleVersion The oracle version to validate against\n    /// @param updateData The update data to validate\n    function _validateAndGetPrice(uint256 oracleVersion, bytes calldata updateData) private returns (PythStructs.Price memory price) {\n        bytes[] memory updateDataList = new bytes[](1);\n        updateDataList[0] = updateData;\n        bytes32[] memory idList = new bytes32[](1);\n        idList[0] = id;\n\n        return pyth.parsePriceFeedUpdates{value: pyth.getUpdateFee(updateDataList)}(\n            updateDataList,\n            idList,\n            SafeCast.toUint64(oracleVersion + MIN_VALID_TIME_AFTER_VERSION),\n            SafeCast.toUint64(oracleVersion + MAX_VALID_TIME_AFTER_VERSION)\n        )[0].price;\n    }\n\n    /// @notice Records `price` as a Fixed6 at version `oracleVersion`\n    /// @param oracleVersion The oracle version to record the price at\n    /// @param price The price to record\n    function _recordPrice(uint256 oracleVersion, PythStructs.Price memory price) private {\n        _prices[oracleVersion] = Fixed6Lib.from(price.price)\n            .mul(Fixed6Lib.from(SafeCast.toInt256(10 ** SafeCast.toUint256(price.expo > 0 ? price.expo : -price.expo))));\n        _publishTimes[oracleVersion] = price.publishTime;\n    }\n\n    /// @notice Pulls funds from the factory to reward the keeper\n    /// @param keeperFee The keeper fee to pull\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory) internal override {\n        IPythFactory(address(factory())).claim(UFixed6Lib.from(keeperFee, true));\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    }
  ]
}