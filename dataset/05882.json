{
  "Title": "[04] Typos",
  "Content": "\n- GovernorCountingOverriable.sol ( [#L35](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/treasury/GovernorCountingOverridable.sol#L35) , [#L59](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/treasury/GovernorCountingOverridable.sol#L59) ):\n\n```javascript\n    // @audit Typo - instead of \"specicic\" use \"specific\"\n35: // @dev Tracks state of specicic voters in a single proposal.\n\n    // @audit Typo - instead of \"abstain\" use \"against\"\n59: // @notice The required percentage of \"for\" votes in relation to the total opinionated votes (for and abstain) for\n```\n\n- BondingVotes.sol ([#L65-66](https://github.com/code-423n4/2023-08-livepeer/blob/main/contracts/bonding/BondingVotes.sol#L65-L66)):\n\n```javascript\n    // @audit Typo - instead of \"Notce that...\" use \"Notice that this is different\"\n65: // @dev Stores a list of checkpoints for the total active stake, queryable and mapped by round. Notce that\n66: // differently from bonding checkpoints, it's only accessible on the specific round. To access the checkpoint for a\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-08-livepeer",
  "Code": [
    {
      "filename": "contracts/treasury/GovernorCountingOverridable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol\";\n\nimport \"../bonding/libraries/EarningsPool.sol\";\nimport \"../bonding/libraries/EarningsPoolLIP36.sol\";\n\nimport \"../Manager.sol\";\nimport \"../IController.sol\";\nimport \"../rounds/IRoundsManager.sol\";\nimport \"./IVotes.sol\";\n\n/**\n * @title GovernorCountingOverridable\n * @notice Implements the Counting module from OpenZeppelin Governor with support for delegators overriding their\n * delegated transcoder's vote. This module is used through inheritance by the Governor contract.\n */\nabstract contract GovernorCountingOverridable is Initializable, GovernorUpgradeable {\n    error InvalidVoteType(uint8 voteType);\n    error VoteAlreadyCast();\n\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    /**\n     * @dev Tracks state of specicic voters in a single proposal.\n     */\n    struct ProposalVoterState {\n        bool hasVoted;\n        VoteType support;\n        // This vote deductions state is only necessary to support the case where a delegator might vote before their\n        // transcoder. When that happens, we need to deduct the delegator(s) votes before tallying the transcoder vote.\n        uint256 deductions;\n    }\n\n    /**\n     * @dev Tracks the tallying state for a proposal vote counting logic.\n     */\n    struct ProposalTally {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => ProposalVoterState) voters;\n    }\n\n    // Maps proposal IDs to their corresponding vote tallies.\n    mapping(uint256 => ProposalTally) private _proposalTallies;\n\n    /**\n     * @notice The required percentage of \"for\" votes in relation to the total opinionated votes (for and abstain) for\n     * a proposal to succeed. Represented as a MathUtils percentage value (e.g. 6 decimal places).\n     */\n    uint256 public quota;\n\n    function __GovernorCountingOverridable_init(uint256 _quota) internal onlyInitializing {\n        __GovernorCountingOverridable_init_unchained(_quota);\n    }\n\n    function __GovernorCountingOverridable_init_unchained(uint256 _quota) internal onlyInitializing {\n        quota = _quota;\n    }\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain,against\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 _proposalId, address _account) public view virtual override returns (bool) {\n        return _proposalTallies[_proposalId].voters[_account].hasVoted;\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(uint256 _proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalTally storage tally = _proposalTallies[_proposalId];\n        return (tally.againstVotes, tally.forVotes, tally.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 _proposalId) internal view virtual override returns (bool) {\n        (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) = proposalVotes(_proposalId);\n\n        uint256 totalVotes = againstVotes + forVotes + abstainVotes;\n\n        return totalVotes >= quorum(proposalSnapshot(_proposalId));\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be at least QUOTA of the total votes.\n     */\n    function _voteSucceeded(uint256 _proposalId) internal view virtual override returns (bool) {\n        (uint256 againstVotes, uint256 forVotes, ) = proposalVotes(_proposalId);\n\n        // we ignore abstain votes for vote succeeded calculation\n        uint256 opinionatedVotes = againstVotes + forVotes;\n\n        return forVotes >= MathUtils.percOf(opinionatedVotes, quota);\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 _proposalId,\n        address _account,\n        uint8 _supportInt,\n        uint256 _weight,\n        bytes memory // params\n    ) internal virtual override {\n        if (_supportInt > uint8(VoteType.Abstain)) {\n            revert InvalidVoteType(_supportInt);\n        }\n        VoteType support = VoteType(_supportInt);\n\n        ProposalTally storage tally = _proposalTallies[_proposalId];\n        ProposalVoterState storage voter = tally.voters[_account];\n\n        if (voter.hasVoted) {\n            revert VoteAlreadyCast();\n        }\n        voter.hasVoted = true;\n        voter.support = support;\n\n        _weight = _handleVoteOverrides(_proposalId, tally, voter, _account, _weight);\n\n        if (support == VoteType.Against) {\n            tally.againstVotes += _weight;\n        } else if (support == VoteType.For) {\n            tally.forVotes += _weight;\n        } else {\n            tally.abstainVotes += _weight;\n        }\n    }\n\n    /**\n     * @notice Handles vote overrides that delegators can make to their\n     * corresponding delegated transcoder votes. Usually only the transcoders\n     * vote on proposals, but any delegator can change their part of the vote.\n     * This tracks past votes and deduction on separate mappings in order to\n     * calculate the effective voting power of each vote.\n     * @param _proposalId ID of the proposal being voted on\n     * @param _tally struct where the vote totals are tallied on\n     * @param _voter struct where the specific voter state is tracked\n     * @param _account current user making a vote\n     * @param _weight voting weight of the user making the vote\n     */\n    function _handleVoteOverrides(\n        uint256 _proposalId,\n        ProposalTally storage _tally,\n        ProposalVoterState storage _voter,\n        address _account,\n        uint256 _weight\n    ) internal returns (uint256) {\n        uint256 timepoint = proposalSnapshot(_proposalId);\n        address delegate = votes().delegatedAt(_account, timepoint);\n\n        bool isTranscoder = _account == delegate;\n        if (isTranscoder) {\n            // deduce weight from any previous delegators for this transcoder to\n            // make a vote\n            return _weight - _voter.deductions;\n        }\n\n        // this is a delegator, so add a deduction to the delegated transcoder\n        ProposalVoterState storage delegateVoter = _tally.voters[delegate];\n        delegateVoter.deductions += _weight;\n\n        if (delegateVoter.hasVoted) {\n            // this is a delegator overriding its delegated transcoder vote,\n            // we need to update the current totals to move the weight of\n            // the delegator vote to the right outcome.\n            VoteType delegateSupport = delegateVoter.support;\n\n            if (delegateSupport == VoteType.Against) {\n                _tally.againstVotes -= _weight;\n            } else if (delegateSupport == VoteType.For) {\n                _tally.forVotes -= _weight;\n            } else {\n                assert(delegateSupport == VoteType.Abstain);\n                _tally.abstainVotes -= _weight;\n            }\n        }\n\n        return _weight;\n    }\n\n    /**\n     * @dev Implement in inheriting contract to provide the voting power provider.\n     */\n    function votes() public view virtual returns (IVotes);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "contracts/bonding/BondingVotes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./libraries/EarningsPool.sol\";\nimport \"./libraries/EarningsPoolLIP36.sol\";\nimport \"./libraries/SortedArrays.sol\";\n\nimport \"../ManagerProxyTarget.sol\";\nimport \"./IBondingVotes.sol\";\nimport \"./IBondingManager.sol\";\nimport \"../rounds/IRoundsManager.sol\";\n\n/**\n * @title BondingVotes\n * @dev Checkpointing logic for BondingManager state for historical stake calculations.\n */\ncontract BondingVotes is ManagerProxyTarget, IBondingVotes {\n    using Arrays for uint256[];\n    using SortedArrays for uint256[];\n\n    struct BondingCheckpoint {\n        /**\n         * @dev The amount of bonded tokens to another delegate as of the lastClaimRound.\n         */\n        uint256 bondedAmount;\n        /**\n         * @dev The address of the delegate the account is bonded to. In case of transcoders this is their own address.\n         */\n        address delegateAddress;\n        /**\n         * @dev The amount of tokens delegated from delegators to this account. This is only set for transcoders, which\n         * have to self-delegate first and then have tokens bonded from other delegators.\n         */\n        uint256 delegatedAmount;\n        /**\n         * @dev The last round during which the delegator claimed its earnings. This pegs the value of bondedAmount for\n         * rewards calculation in {EarningsPoolLIP36-delegatorCumulativeStakeAndFees}.\n         */\n        uint256 lastClaimRound;\n        /**\n         * @dev The last round during which the checkpointed account called {BondingManager-reward}. This is needed to\n         * when calculating pending rewards for a delegator to this transcoder, to find the last earning pool available\n         * for a given round. In that case we start from the delegator checkpoint and then fetch its delegate address\n         * checkpoint as well to find the last earning pool.\n         *\n         * Notice that this is the only field that comes from the Transcoder struct in BondingManager, not Delegator.\n         */\n        uint256 lastRewardRound;\n    }\n\n    /**\n     * @dev Stores a list of checkpoints for an account, queryable and mapped by start round. To access the checkpoint\n     * for a given round, find the checkpoint with the highest start round that is lower or equal to the queried round\n     * ({SortedArrays-findLowerBound}) and then fetch the specific checkpoint on the data mapping.\n     */\n    struct BondingCheckpointsByRound {\n        uint256[] startRounds;\n        mapping(uint256 => BondingCheckpoint) data;\n    }\n\n    /**\n     * @dev Stores a list of checkpoints for the total active stake, queryable and mapped by round. Notce that\n     * differently from bonding checkpoints, it's only accessible on the specific round. To access the checkpoint for a\n     * given round, look for the checkpoint in the {data}} and if it's zero ensure the round was actually checkpointed on\n     * the {rounds} array ({SortedArrays-findLowerBound}).\n     */\n    struct TotalActiveStakeByRound {\n        uint256[] rounds;\n        mapping(uint256 => uint256) data;\n    }\n\n    /**\n     * @dev Checkpoints by account (delegators and transcoders).\n     */\n    mapping(address => BondingCheckpointsByRound) private bondingCheckpoints;\n    /**\n     * @dev Total active stake checkpoints.\n     */\n    TotalActiveStakeByRound private totalStakeCheckpoints;\n\n    /**\n     * @dev Modifier to ensure the sender is BondingManager\n     */\n    modifier onlyBondingManager() {\n        _onlyBondingManager();\n        _;\n    }\n\n    /**\n     * @dev Ensures that the provided round is in the past.\n     */\n    modifier onlyPastRounds(uint256 _round) {\n        uint256 currentRound = clock();\n        if (_round >= currentRound) {\n            revert FutureLookup(_round, currentRound == 0 ? 0 : currentRound - 1);\n        }\n        _;\n    }\n\n    /**\n     * @notice BondingVotes constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller) Manager(_controller) {}\n\n    // IVotes interface implementation.\n    // These should not access any storage directly but proxy to the bonding state functions.\n\n    /**\n     * @notice Returns the name of the virtual token implemented by this.\n     */\n    function name() external pure returns (string memory) {\n        return \"Livepeer Voting Power\";\n    }\n\n    /**\n     * @notice Returns the symbol of the token underlying the voting power.\n     */\n    function symbol() external pure returns (string memory) {\n        return \"vLPT\";\n    }\n\n    /**\n     * @notice Returns the decimals places of the token underlying the voting.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @notice Clock is set to match the current round, which is the checkpointing\n     *  method implemented here.\n     */\n    function clock() public view returns (uint48) {\n        return SafeCast.toUint48(roundsManager().currentRound());\n    }\n\n    /**\n     * @notice Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external pure returns (string memory) {\n        return \"mode=livepeer_round\";\n    }\n\n    /**\n     * @notice Returns the current amount of votes that `_account` has.\n     * @dev Keep in mind that since this function should return the votes at the end of the current round, we need to\n     * fetch the bonding state at the next round instead. That because the bonding state reflects the active stake in\n     * the current round, which is the snapshotted stake from the end of the previous round.\n     */\n    function getVotes(address _account) external view returns (uint256) {\n        (uint256 amount, ) = getBondingStateAt(_account, clock() + 1);\n        return amount;\n    }\n\n    /**\n     * @notice Returns the amount of votes that `_account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     * @dev Keep in mind that since this function should return the votes at the end of the _round (or timepoint in OZ\n     * terms), we need to fetch the bonding state at the next round instead. That because the bonding state reflects the\n     * active stake in the current round, which is the snapshotted stake from the end of the previous round.\n     */\n    function getPastVotes(address _account, uint256 _round) external view onlyPastRounds(_round) returns (uint256) {\n        (uint256 amount, ) = getBondingStateAt(_account, _round + 1);\n        return amount;\n    }\n\n    /**\n     * @notice Returns the current total supply of votes available.\n     * @dev This value is the sum of all *active* stake, which is not necessarily the sum of all voting power.\n     * Bonded stake that is not part of the top 100 active transcoder set is still given voting power, but is not\n     * considered here.\n     * @dev Keep in mind that since this function should return the votes at the end of the current round, we need to\n     * fetch the total active stake at the next round instead. That because the active stake in the current round is the\n     * snapshotted stake from the end of the previous round.\n     */\n    function totalSupply() external view returns (uint256) {\n        return getTotalActiveStakeAt(clock() + 1);\n    }\n\n    /**\n     * @notice Returns the total supply of votes available at a specific round in the past.\n     * @dev This value is the sum of all *active* stake, which is not necessarily the sum of all voting power.\n     * Bonded stake that is not part of the top 100 active transcoder set is still given voting power, but is not\n     * considered here.\n     * @dev Keep in mind that since this function should return the votes at the end of the _round (or timepoint in OZ\n     * terms), we need to fetch the total active stake at the next round instead. That because the active stake in the\n     * current round is the snapshotted stake from the end of the previous round.\n     */\n    function getPastTotalSupply(uint256 _round) external view onlyPastRounds(_round) returns (uint256) {\n        return getTotalActiveStakeAt(_round + 1);\n    }\n\n    /**\n     * @notice Returns the delegate that _account has chosen. This means the delegated transcoder address in case of\n     * delegators, and the account's own address for transcoders (self-delegated).\n     * @dev Keep in mind that since this function should return the delegate at the end of the current round, we need to\n     * fetch the bonding state at the next round instead. That because the bonding state reflects the active stake in\n     * the current round, or the snapshotted stake from the end of the previous round.\n     */\n    function delegates(address _account) external view returns (address) {\n        (, address delegateAddress) = getBondingStateAt(_account, clock() + 1);\n        return delegateAddress;\n    }\n\n    /**\n     * @notice Returns the delegate that _account had chosen in a specific round in the past.\n     * @dev This is an addition to the IERC5805 interface to support our custom vote counting logic that allows\n     * delegators to override their transcoders votes. See {GovernorCountingOverridable-_handleVoteOverrides}.\n     * @dev Keep in mind that since this function should return the delegate at the end of the _round (or timepoint in\n     * OZ terms), we need to fetch the bonding state at the next round instead. That because the bonding state reflects\n     * the active stake in the current round, which is the snapshotted stake from the end of the previous round.\n     */\n    function delegatedAt(address _account, uint256 _round) external view onlyPastRounds(_round) returns (address) {\n        (, address delegateAddress) = getBondingStateAt(_account, _round + 1);\n        return delegateAddress;\n    }\n\n    /**\n     * @notice Delegation through BondingVotes is not supported.\n     */\n    function delegate(address) external pure {\n        revert MustCallBondingManager(\"bond\");\n    }\n\n    /**\n     * @notice Delegation through BondingVotes is not supported.\n     */\n    function delegateBySig(\n        address,\n        uint256,\n        uint256,\n        uint8,\n        bytes32,\n        bytes32\n    ) external pure {\n        revert MustCallBondingManager(\"bondFor\");\n    }\n\n    // BondingManager checkpointing hooks\n\n    /**\n     * @notice Called by the BondingManager when the bonding state of an account changes.\n     * @dev Since we checkpoint \"delegator\" and \"transcoder\" states, this is called both for the delegator and for the\n     * transcoder when any change is made to the bonds, including when rewards are calculated or claimed.\n     * @param _account The account whose bonding state changed\n     * @param _startRound The round from which the bonding state will be active. This is normally the next round.\n     * @param _bondedAmount From {BondingManager-Delegator-bondedAmount}\n     * @param _delegateAddress From {BondingManager-Delegator-delegateAddress}\n     * @param _delegatedAmount From {BondingManager-Transcoder-delegatedAmount}\n     * @param _lastClaimRound From {BondingManager-Delegator-lastClaimRound}\n     * @param _lastRewardRound From {BondingManager-Transcoder-lastRewardRound}\n     */\n    function checkpointBondingState(\n        address _account,\n        uint256 _startRound,\n        uint256 _bondedAmount,\n        address _delegateAddress,\n        uint256 _delegatedAmount,\n        uint256 _lastClaimRound,\n        uint256 _lastRewardRound\n    ) external virtual onlyBondingManager {\n        if (_startRound != clock() + 1) {\n            revert InvalidStartRound(_startRound, clock() + 1);\n        } else if (_lastClaimRound >= _startRound) {\n            revert FutureLastClaimRound(_lastClaimRound, _startRound - 1);\n        }\n\n        BondingCheckpoint memory previous;\n        if (hasCheckpoint(_account)) {\n            previous = getBondingCheckpointAt(_account, _startRound);\n        }\n\n        BondingCheckpointsByRound storage checkpoints = bondingCheckpoints[_account];\n\n        BondingCheckpoint memory bond = BondingCheckpoint({\n            bondedAmount: _bondedAmount,\n            delegateAddress: _delegateAddress,\n            delegatedAmount: _delegatedAmount,\n            lastClaimRound: _lastClaimRound,\n            lastRewardRound: _lastRewardRound\n        });\n        checkpoints.data[_startRound] = bond;\n\n        // now store the startRound itself in the startRounds array to allow us\n        // to find it and lookup in the above mapping\n        checkpoints.startRounds.pushSorted(_startRound);\n\n        onBondingCheckpointChanged(_account, previous, bond);\n    }\n\n    /**\n     * @notice Called by the BondingManager when the total active stake changes.\n     * @dev This is called only from the {BondingManager-setCurrentRoundTotalActiveStake} function to set the total\n     * active stake in the current round.\n     * @param _totalStake From {BondingManager-currentRoundTotalActiveStake}\n     * @param _round The round for which the total active stake is valid. This is normally the current round.\n     */\n    function checkpointTotalActiveStake(uint256 _totalStake, uint256 _round) external virtual onlyBondingManager {\n        if (_round != clock()) {\n            revert InvalidTotalStakeCheckpointRound(_round, clock());\n        }\n\n        totalStakeCheckpoints.data[_round] = _totalStake;\n        totalStakeCheckpoints.rounds.pushSorted(_round);\n    }\n\n    /**\n     * @notice Returns whether an account already has any checkpoint.\n     */\n    function hasCheckpoint(address _account) public view returns (bool) {\n        return bondingCheckpoints[_account].startRounds.length > 0;\n    }\n\n    // Historical stake access functions\n\n    /**\n     * @dev Gets the checkpointed total active stake at a given round.\n     * @param _round The round for which we want to get the total active stake.\n     */\n    function getTotalActiveStakeAt(uint256 _round) public view virtual returns (uint256) {\n        if (_round > clock() + 1) {\n            revert FutureLookup(_round, clock() + 1);\n        }\n\n        uint256 exactCheckpoint = totalStakeCheckpoints.data[_round];\n        if (exactCheckpoint > 0) {\n            return exactCheckpoint;\n        }\n\n        uint256[] storage initializedRounds = totalStakeCheckpoints.rounds;\n        uint256 upper = initializedRounds.findUpperBound(_round);\n        if (upper == 0) {\n            // Return a zero voting power supply for any round before the first checkpoint. This also happens if there\n            // are no checkpoints at all.\n            return 0;\n        } else if (upper < initializedRounds.length) {\n            // Use the checkpoint from the next initialized round, which got the next total active stake checkpointed.\n            uint256 nextInitedRound = initializedRounds[upper];\n            return totalStakeCheckpoints.data[nextInitedRound];\n        } else {\n            // Here the _round is after any initialized round, so grab its stake from nextRoundTotalActiveStake()\n            return bondingManager().nextRoundTotalActiveStake();\n        }\n    }\n\n    /**\n     * @notice Gets the bonding state of an account at a given round.\n     * @dev In the case of delegators it is the amount they are delegating to a transcoder, while for transcoders this\n     * includes all the stake that has been delegated to them (including self-delegated).\n     * @param _account The account whose bonding state we want to get.\n     * @param _round The round for which we want to get the bonding state. Normally a proposal's vote start round.\n     * @return amount The active stake of the account at the given round including any accrued rewards. In case of\n     * transcoders this also includes all the amount delegated towards them by other delegators.\n     * @return delegateAddress The address the account delegated to. Will be equal to _account in case of transcoders.\n     */\n    function getBondingStateAt(address _account, uint256 _round)\n        public\n        view\n        virtual\n        returns (uint256 amount, address delegateAddress)\n    {\n        BondingCheckpoint storage bond = getBondingCheckpointAt(_account, _round);\n\n        delegateAddress = bond.delegateAddress;\n        bool isTranscoder = delegateAddress == _account;\n\n        if (bond.bondedAmount == 0) {\n            amount = 0;\n        } else if (isTranscoder) {\n            // Address is a registered transcoder so we use its delegated amount. This includes self and delegated stake\n            // as well as any accrued rewards, even unclaimed ones\n            amount = bond.delegatedAmount;\n        } else {\n            // Address is NOT a registered transcoder so we calculate its cumulative stake for the voting power\n            amount = delegatorCumulativeStakeAt(bond, _round);\n        }\n    }\n\n    /**\n     * @dev Reacts to changes in the bonding checkpoints of an account by emitting the corresponding events.\n     */\n    function onBondingCheckpointChanged(\n        address _account,\n        BondingCheckpoint memory previous,\n        BondingCheckpoint memory current\n    ) internal {\n        address previousDelegate = previous.delegateAddress;\n        address newDelegate = current.delegateAddress;\n        if (previousDelegate != newDelegate) {\n            emit DelegateChanged(_account, previousDelegate, newDelegate);\n        }\n\n        bool isTranscoder = newDelegate == _account;\n        bool wasTranscoder = previousDelegate == _account;\n        // we want to register zero \"delegate votes\" when the account is/was not a transcoder\n        uint256 previousDelegateVotes = wasTranscoder ? previous.delegatedAmount : 0;\n        uint256 currentDelegateVotes = isTranscoder ? current.delegatedAmount : 0;\n        if (previousDelegateVotes != currentDelegateVotes) {\n            emit DelegateVotesChanged(_account, previousDelegateVotes, currentDelegateVotes);\n        }\n\n        // Always send delegator events since transcoders are delegators themselves. The way our rewards work, the\n        // delegator voting power calculated from events will only reflect their claimed stake without pending rewards.\n        if (previous.bondedAmount != current.bondedAmount) {\n            emit DelegatorBondedAmountChanged(_account, previous.bondedAmount, current.bondedAmount);\n        }\n    }\n\n    /**\n     * @dev Gets the checkpointed bonding state of an account at a round. This works by looking for the last checkpoint\n     * at or before the given round and using the checkpoint of that round. If there hasn't been checkpoints since then\n     * it means that the state hasn't changed.\n     * @param _account The account whose bonding state we want to get.\n     * @param _round The round for which we want to get the bonding state.\n     * @return The {BondingCheckpoint} pointer to the checkpoints storage.\n     */\n    function getBondingCheckpointAt(address _account, uint256 _round)\n        internal\n        view\n        returns (BondingCheckpoint storage)\n    {\n        if (_round > clock() + 1) {\n            revert FutureLookup(_round, clock() + 1);\n        }\n\n        BondingCheckpointsByRound storage checkpoints = bondingCheckpoints[_account];\n\n        // Most of the time we will be calling this for a transcoder which checkpoints on every round through reward().\n        // On those cases we will have a checkpoint for exactly the round we want, so optimize for that.\n        BondingCheckpoint storage bond = checkpoints.data[_round];\n        if (bond.bondedAmount > 0) {\n            return bond;\n        }\n\n        uint256 startRoundIdx = checkpoints.startRounds.findLowerBound(_round);\n        if (startRoundIdx == checkpoints.startRounds.length) {\n            // No checkpoint at or before _round, so return the zero BondingCheckpoint value. This also happens if there\n            // are no checkpoints for _account. The voting power will be zero until the first checkpoint is made.\n            return bond;\n        }\n\n        uint256 startRound = checkpoints.startRounds[startRoundIdx];\n        return checkpoints.data[startRound];\n    }\n\n    /**\n     * @dev Gets the cumulative stake of a delegator at any given round. Differently from the bonding manager\n     * implementation, we can calculate the stake at any round through the use of the checkpointed state. It works by\n     * re-using the bonding manager logic while changing only the way that we find the earning pool for the end round.\n     * @param bond The {BondingCheckpoint} of the delegator at the given round.\n     * @param _round The round for which we want to get the cumulative stake.\n     * @return The cumulative stake of the delegator at the given round.\n     */\n    function delegatorCumulativeStakeAt(BondingCheckpoint storage bond, uint256 _round)\n        internal\n        view\n        returns (uint256)\n    {\n        EarningsPool.Data memory startPool = getTranscoderEarningsPoolForRound(\n            bond.delegateAddress,\n            bond.lastClaimRound\n        );\n\n        (uint256 rewardRound, EarningsPool.Data memory endPool) = getLastTranscoderRewardsEarningsPool(\n            bond.delegateAddress,\n            _round\n        );\n\n        if (rewardRound < bond.lastClaimRound) {\n            // If the transcoder hasn't called reward() since the last time the delegator claimed earnings, there wil be\n            // no rewards to add to the delegator's stake so we just return the originally bonded amount.\n            return bond.bondedAmount;\n        }\n\n        (uint256 stakeWithRewards, ) = EarningsPoolLIP36.delegatorCumulativeStakeAndFees(\n            startPool,\n            endPool,\n            bond.bondedAmount,\n            0\n        );\n        return stakeWithRewards;\n    }\n\n    /**\n     * @notice Returns the last initialized earning pool for a transcoder at a given round.\n     * @dev Transcoders are just delegators with a self-delegation, so we find their last checkpoint before or at the\n     * provided _round and use its lastRewardRound value to grab the calculated earning pool. The only case where this\n     * returns a zero earning pool is if the transcoder had never called reward() before _round.\n     * @param _transcoder Address of the transcoder to look for\n     * @param _round Past round at which we want the valid earning pool from\n     * @return rewardRound Round in which the returned earning pool was calculated.\n     * @return pool EarningsPool.Data struct with the last initialized earning pool.\n     */\n    function getLastTranscoderRewardsEarningsPool(address _transcoder, uint256 _round)\n        internal\n        view\n        returns (uint256 rewardRound, EarningsPool.Data memory pool)\n    {\n        BondingCheckpoint storage bond = getBondingCheckpointAt(_transcoder, _round);\n        rewardRound = bond.lastRewardRound;\n\n        if (rewardRound > 0) {\n            pool = getTranscoderEarningsPoolForRound(_transcoder, rewardRound);\n\n            if (pool.cumulativeRewardFactor == 0) {\n                // Invalid state: a lastRewardRound is registered but there's no recorded earnings pool.\n                revert MissingEarningsPool(_transcoder, rewardRound);\n            }\n        }\n    }\n\n    /**\n     * @dev Proxy for {BondingManager-getTranscoderEarningsPoolForRound} that returns an EarningsPool.Data struct.\n     */\n    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)\n        internal\n        view\n        returns (EarningsPool.Data memory pool)\n    {\n        (\n            pool.totalStake,\n            pool.transcoderRewardCut,\n            pool.transcoderFeeShare,\n            pool.cumulativeRewardFactor,\n            pool.cumulativeFeeFactor\n        ) = bondingManager().getTranscoderEarningsPoolForRound(_transcoder, _round);\n    }\n\n    // Manager/Controller helpers\n\n    /**\n     * @dev Return BondingManager interface\n     */\n    function bondingManager() internal view returns (IBondingManager) {\n        return IBondingManager(controller.getContract(keccak256(\"BondingManager\")));\n    }\n\n    /**\n     * @dev Return IRoundsManager interface\n     */\n    function roundsManager() internal view returns (IRoundsManager) {\n        return IRoundsManager(controller.getContract(keccak256(\"RoundsManager\")));\n    }\n\n    /**\n     * @dev Ensure the sender is BondingManager\n     */\n    function _onlyBondingManager() internal view {\n        if (ms"
    }
  ]
}