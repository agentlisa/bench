{
  "Title": "repayAndWithdraw Will Frequently Fail for Full Repayments",
  "Content": "Within the [`repayWithdraw` function](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/IonHandlerBase.sol#L131) of the `IonHandlerBase` contract, the amount to repay is specified in units of WETH. As a result of inaccuracies in [converting this to `normalizedDebt` units](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/IonHandlerBase.sol#L144-L148), when attempting to repay an account's full borrow, this function is likely to fail. Inaccuracies may arise from rounding incorrectly, or from the transaction being mined at a different time than the user anticipates and [interest accrual](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/IonHandlerBase.sol#L146) being unexpected.\n\n\nIf a user attempts to pay off their entire borrow and the [computed `normalizedDebtToRepay`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/IonHandlerBase.sol#L148) is too high or too low, the call may revert. In case `normalizedDebtToRepay` is higher than a vault's `normalizedDebt`, the [addition of the negated `normalizedDebtToRepay` will revert](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L663) since the value [should be less than `0`](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L1131). In case that `normalizedDebtToRepay` is too low, the [vault is likely to be dusty, causing a revert](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/IonPool.sol#L707-L708).\n\n\nConsider refactoring the `repayAndWithdraw` function to include a \"max repayment\" logical branch. Consider using the value `repayAmount == uint.max` to indicate a full repayment, for example. Note that this will require changes to the [transfer of WETH](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/IonHandlerBase.sol#L132) since the amount of WETH will need to be computed on-the-fly, and will require [an accurate rate](https://github.com/Ion-Protocol/ion-protocol/blob/98e282514ac5827196b49f688938e1e44709505a/src/flash/handlers/base/IonHandlerBase.sol#L145) to do so. Alternatively, consider making a separate function for full repayment, and informing users, at multiple places, of the risk of failure when using the regular `repayAndWithdraw` function for full or near-full repayments.\n\n\n***Update:** Resolved in [pull request #22](https://github.com/Ion-Protocol/ion-protocol/pull/22).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/flash/handlers/base/IonHandlerBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { IWETH9 } from \"src/interfaces/IWETH9.sol\";\nimport { GemJoin } from \"src/join/GemJoin.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @dev There a couple things to consider here from a security perspective. The\n * first one is that the flashloan callback must only be callable from the\n * Balancer vault. This ensures that nobody can pass arbitrary data to the\n * callback from initiating a separate flashloan. The second one is that the\n * flashloan must only be initialized from this contract. This is a trickier one\n * to enforce since Balancer flashloans are not EIP-3156 compliant and do not\n * pass on the initiator through the callback. To get around this, an inverse\n * reentrancy lock of sorts is used. The lock is set to 2 when a flashloan is initiated\n * and set to 1 once the callback execution terminates. If the lock is not 2\n * when the callback is called, then the flashloan was not initiated by this\n * contract and the tx is reverted.\n *\n * This contract currently deposits directly into LST contract 1:1. It should be\n * noted that a more favorable trade could be possible via DEXs.\n */\nabstract contract IonHandlerBase {\n    using SafeERC20 for IERC20;\n    using WadRayMath for uint256;\n\n    error CannotSendEthToContract();\n    error FlashloanRepaymentTooExpensive(uint256 repaymentAmount, uint256 maxRepaymentAmount);\n\n    enum AmountToBorrow {\n        IS_MIN,\n        IS_MAX\n    }\n\n    IWETH9 immutable WETH;\n    uint8 immutable ILK_INDEX;\n    IonPool immutable POOL;\n    GemJoin immutable JOIN;\n    IERC20 immutable LST_TOKEN;\n    Whitelist immutable WHITELIST;\n\n    modifier onlyWhitelistedBorrowers(uint8, bytes32[] memory proof) {\n        WHITELIST.isWhitelistedBorrower(ILK_INDEX, msg.sender, proof);\n        _;\n    }\n\n    constructor(uint8 _ilkIndex, IonPool _ionPool, GemJoin _gemJoin, Whitelist _whitelist) {\n        POOL = _ionPool;\n        ILK_INDEX = _ilkIndex;\n\n        IWETH9 _weth = IWETH9(address(_ionPool.underlying()));\n        WETH = _weth;\n\n        address ilkAddress = POOL.getIlkAddress(_ilkIndex);\n        LST_TOKEN = IERC20(ilkAddress);\n\n        JOIN = _gemJoin;\n\n        WHITELIST = _whitelist;\n\n        _weth.approve(address(_ionPool), type(uint256).max);\n        IERC20(ilkAddress).approve(address(_gemJoin), type(uint256).max);\n    }\n\n    /**\n     *\n     * @param amountCollateral amount of collateral to deposit.\n     * @param amountToBorrow amount of WETH to borrow. Due to rounding, true borrow amount might be slightly less.\n     * @param proof merkle proof that the user is whitelisted.\n     */\n    function depositAndBorrow(\n        uint256 amountCollateral,\n        uint256 amountToBorrow,\n        bytes32[] calldata proof\n    )\n        external\n        onlyWhitelistedBorrowers(ILK_INDEX, proof)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), amountCollateral);\n        _depositAndBorrow(msg.sender, msg.sender, amountCollateral, amountToBorrow, AmountToBorrow.IS_MAX);\n    }\n\n    /**\n     * @param vaultHolder the user who will be responsible for repaying debt\n     * @param receiver the user who receives the borrowed funds\n     * @param amountCollateral to move into vault\n     * @param amountToBorrow out of the vault [WAD]\n     * @param amountToBorrowType whether the `amountToBorrow` is a min or max.\n     * This will dictate the rounding direction when converting to normalized\n     * amount. If it is a minimum, then the rounding will be rounded up. If it\n     * is a maximum, then the rounding will be rounded down.\n     */\n    function _depositAndBorrow(\n        address vaultHolder,\n        address receiver,\n        uint256 amountCollateral,\n        uint256 amountToBorrow,\n        AmountToBorrow amountToBorrowType\n    )\n        internal\n    {\n        JOIN.join(address(this), amountCollateral);\n\n        POOL.depositCollateral(ILK_INDEX, vaultHolder, address(this), amountCollateral, new bytes32[](0));\n\n        uint256 currentRate = POOL.rate(ILK_INDEX);\n        (,, uint256 newRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ILK_INDEX);\n        uint256 rateAfterAccrual = currentRate + newRateIncrease;\n\n        uint256 normalizedAmountToBorrow;\n        if (amountToBorrowType == AmountToBorrow.IS_MIN) {\n            normalizedAmountToBorrow = amountToBorrow.rayDivUp(rateAfterAccrual);\n        } else {\n            normalizedAmountToBorrow = amountToBorrow.rayDivDown(rateAfterAccrual);\n        }\n\n        if (amountToBorrow != 0) {\n            POOL.borrow(ILK_INDEX, vaultHolder, receiver, normalizedAmountToBorrow, new bytes32[](0));\n        }\n    }\n\n    /**\n     * @param debtToRepay in eth terms\n     * @param collateralToWithdraw in collateral terms\n     */\n    function repayAndWithdraw(uint256 debtToRepay, uint256 collateralToWithdraw) external {\n        WETH.transferFrom(msg.sender, address(this), debtToRepay);\n        _repayAndWithdraw(msg.sender, msg.sender, collateralToWithdraw, debtToRepay);\n    }\n\n    function _repayAndWithdraw(\n        address vaultHolder,\n        address receiver,\n        uint256 collateralToWithdraw,\n        uint256 debtToRepay\n    )\n        internal\n    {\n        uint256 currentRate = POOL.rate(ILK_INDEX);\n        (,, uint256 newRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ILK_INDEX);\n        uint256 rateAfterAccrual = currentRate + newRateIncrease;\n\n        uint256 normalizedDebtToRepay = debtToRepay.rayDivDown(rateAfterAccrual);\n\n        POOL.repay(ILK_INDEX, vaultHolder, address(this), normalizedDebtToRepay);\n\n        POOL.withdrawCollateral(ILK_INDEX, vaultHolder, address(this), collateralToWithdraw);\n\n        JOIN.exit(receiver, collateralToWithdraw);\n    }\n\n    /**\n     * @dev To allow unwrapping of WETH into ETH\n     */\n    receive() external payable {\n        if (msg.sender != address(WETH)) revert CannotSendEthToContract();\n    }\n}"
    },
    {
      "filename": "src/flash/handlers/base/IonHandlerBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { IWETH9 } from \"src/interfaces/IWETH9.sol\";\nimport { GemJoin } from \"src/join/GemJoin.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @dev There a couple things to consider here from a security perspective. The\n * first one is that the flashloan callback must only be callable from the\n * Balancer vault. This ensures that nobody can pass arbitrary data to the\n * callback from initiating a separate flashloan. The second one is that the\n * flashloan must only be initialized from this contract. This is a trickier one\n * to enforce since Balancer flashloans are not EIP-3156 compliant and do not\n * pass on the initiator through the callback. To get around this, an inverse\n * reentrancy lock of sorts is used. The lock is set to 2 when a flashloan is initiated\n * and set to 1 once the callback execution terminates. If the lock is not 2\n * when the callback is called, then the flashloan was not initiated by this\n * contract and the tx is reverted.\n *\n * This contract currently deposits directly into LST contract 1:1. It should be\n * noted that a more favorable trade could be possible via DEXs.\n */\nabstract contract IonHandlerBase {\n    using SafeERC20 for IERC20;\n    using WadRayMath for uint256;\n\n    error CannotSendEthToContract();\n    error FlashloanRepaymentTooExpensive(uint256 repaymentAmount, uint256 maxRepaymentAmount);\n\n    enum AmountToBorrow {\n        IS_MIN,\n        IS_MAX\n    }\n\n    IWETH9 immutable WETH;\n    uint8 immutable ILK_INDEX;\n    IonPool immutable POOL;\n    GemJoin immutable JOIN;\n    IERC20 immutable LST_TOKEN;\n    Whitelist immutable WHITELIST;\n\n    modifier onlyWhitelistedBorrowers(uint8, bytes32[] memory proof) {\n        WHITELIST.isWhitelistedBorrower(ILK_INDEX, msg.sender, proof);\n        _;\n    }\n\n    constructor(uint8 _ilkIndex, IonPool _ionPool, GemJoin _gemJoin, Whitelist _whitelist) {\n        POOL = _ionPool;\n        ILK_INDEX = _ilkIndex;\n\n        IWETH9 _weth = IWETH9(address(_ionPool.underlying()));\n        WETH = _weth;\n\n        address ilkAddress = POOL.getIlkAddress(_ilkIndex);\n        LST_TOKEN = IERC20(ilkAddress);\n\n        JOIN = _gemJoin;\n\n        WHITELIST = _whitelist;\n\n        _weth.approve(address(_ionPool), type(uint256).max);\n        IERC20(ilkAddress).approve(address(_gemJoin), type(uint256).max);\n    }\n\n    /**\n     *\n     * @param amountCollateral amount of collateral to deposit.\n     * @param amountToBorrow amount of WETH to borrow. Due to rounding, true borrow amount might be slightly less.\n     * @param proof merkle proof that the user is whitelisted.\n     */\n    function depositAndBorrow(\n        uint256 amountCollateral,\n        uint256 amountToBorrow,\n        bytes32[] calldata proof\n    )\n        external\n        onlyWhitelistedBorrowers(ILK_INDEX, proof)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), amountCollateral);\n        _depositAndBorrow(msg.sender, msg.sender, amountCollateral, amountToBorrow, AmountToBorrow.IS_MAX);\n    }\n\n    /**\n     * @param vaultHolder the user who will be responsible for repaying debt\n     * @param receiver the user who receives the borrowed funds\n     * @param amountCollateral to move into vault\n     * @param amountToBorrow out of the vault [WAD]\n     * @param amountToBorrowType whether the `amountToBorrow` is a min or max.\n     * This will dictate the rounding direction when converting to normalized\n     * amount. If it is a minimum, then the rounding will be rounded up. If it\n     * is a maximum, then the rounding will be rounded down.\n     */\n    function _depositAndBorrow(\n        address vaultHolder,\n        address receiver,\n        uint256 amountCollateral,\n        uint256 amountToBorrow,\n        AmountToBorrow amountToBorrowType\n    )\n        internal\n    {\n        JOIN.join(address(this), amountCollateral);\n\n        POOL.depositCollateral(ILK_INDEX, vaultHolder, address(this), amountCollateral, new bytes32[](0));\n\n        uint256 currentRate = POOL.rate(ILK_INDEX);\n        (,, uint256 newRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ILK_INDEX);\n        uint256 rateAfterAccrual = currentRate + newRateIncrease;\n\n        uint256 normalizedAmountToBorrow;\n        if (amountToBorrowType == AmountToBorrow.IS_MIN) {\n            normalizedAmountToBorrow = amountToBorrow.rayDivUp(rateAfterAccrual);\n        } else {\n            normalizedAmountToBorrow = amountToBorrow.rayDivDown(rateAfterAccrual);\n        }\n\n        if (amountToBorrow != 0) {\n            POOL.borrow(ILK_INDEX, vaultHolder, receiver, normalizedAmountToBorrow, new bytes32[](0));\n        }\n    }\n\n    /**\n     * @param debtToRepay in eth terms\n     * @param collateralToWithdraw in collateral terms\n     */\n    function repayAndWithdraw(uint256 debtToRepay, uint256 collateralToWithdraw) external {\n        WETH.transferFrom(msg.sender, address(this), debtToRepay);\n        _repayAndWithdraw(msg.sender, msg.sender, collateralToWithdraw, debtToRepay);\n    }\n\n    function _repayAndWithdraw(\n        address vaultHolder,\n        address receiver,\n        uint256 collateralToWithdraw,\n        uint256 debtToRepay\n    )\n        internal\n    {\n        uint256 currentRate = POOL.rate(ILK_INDEX);\n        (,, uint256 newRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ILK_INDEX);\n        uint256 rateAfterAccrual = currentRate + newRateIncrease;\n\n        uint256 normalizedDebtToRepay = debtToRepay.rayDivDown(rateAfterAccrual);\n\n        POOL.repay(ILK_INDEX, vaultHolder, address(this), normalizedDebtToRepay);\n\n        POOL.withdrawCollateral(ILK_INDEX, vaultHolder, address(this), collateralToWithdraw);\n\n        JOIN.exit(receiver, collateralToWithdraw);\n    }\n\n    /**\n     * @dev To allow unwrapping of WETH into ETH\n     */\n    receive() external payable {\n        if (msg.sender != address(WETH)) revert CannotSendEthToContract();\n    }\n}"
    },
    {
      "filename": "src/flash/handlers/base/IonHandlerBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IonPool } from \"src/IonPool.sol\";\nimport { IWETH9 } from \"src/interfaces/IWETH9.sol\";\nimport { GemJoin } from \"src/join/GemJoin.sol\";\nimport { WadRayMath } from \"src/libraries/math/WadRayMath.sol\";\nimport { Whitelist } from \"src/Whitelist.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @dev There a couple things to consider here from a security perspective. The\n * first one is that the flashloan callback must only be callable from the\n * Balancer vault. This ensures that nobody can pass arbitrary data to the\n * callback from initiating a separate flashloan. The second one is that the\n * flashloan must only be initialized from this contract. This is a trickier one\n * to enforce since Balancer flashloans are not EIP-3156 compliant and do not\n * pass on the initiator through the callback. To get around this, an inverse\n * reentrancy lock of sorts is used. The lock is set to 2 when a flashloan is initiated\n * and set to 1 once the callback execution terminates. If the lock is not 2\n * when the callback is called, then the flashloan was not initiated by this\n * contract and the tx is reverted.\n *\n * This contract currently deposits directly into LST contract 1:1. It should be\n * noted that a more favorable trade could be possible via DEXs.\n */\nabstract contract IonHandlerBase {\n    using SafeERC20 for IERC20;\n    using WadRayMath for uint256;\n\n    error CannotSendEthToContract();\n    error FlashloanRepaymentTooExpensive(uint256 repaymentAmount, uint256 maxRepaymentAmount);\n\n    enum AmountToBorrow {\n        IS_MIN,\n        IS_MAX\n    }\n\n    IWETH9 immutable WETH;\n    uint8 immutable ILK_INDEX;\n    IonPool immutable POOL;\n    GemJoin immutable JOIN;\n    IERC20 immutable LST_TOKEN;\n    Whitelist immutable WHITELIST;\n\n    modifier onlyWhitelistedBorrowers(uint8, bytes32[] memory proof) {\n        WHITELIST.isWhitelistedBorrower(ILK_INDEX, msg.sender, proof);\n        _;\n    }\n\n    constructor(uint8 _ilkIndex, IonPool _ionPool, GemJoin _gemJoin, Whitelist _whitelist) {\n        POOL = _ionPool;\n        ILK_INDEX = _ilkIndex;\n\n        IWETH9 _weth = IWETH9(address(_ionPool.underlying()));\n        WETH = _weth;\n\n        address ilkAddress = POOL.getIlkAddress(_ilkIndex);\n        LST_TOKEN = IERC20(ilkAddress);\n\n        JOIN = _gemJoin;\n\n        WHITELIST = _whitelist;\n\n        _weth.approve(address(_ionPool), type(uint256).max);\n        IERC20(ilkAddress).approve(address(_gemJoin), type(uint256).max);\n    }\n\n    /**\n     *\n     * @param amountCollateral amount of collateral to deposit.\n     * @param amountToBorrow amount of WETH to borrow. Due to rounding, true borrow amount might be slightly less.\n     * @param proof merkle proof that the user is whitelisted.\n     */\n    function depositAndBorrow(\n        uint256 amountCollateral,\n        uint256 amountToBorrow,\n        bytes32[] calldata proof\n    )\n        external\n        onlyWhitelistedBorrowers(ILK_INDEX, proof)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), amountCollateral);\n        _depositAndBorrow(msg.sender, msg.sender, amountCollateral, amountToBorrow, AmountToBorrow.IS_MAX);\n    }\n\n    /**\n     * @param vaultHolder the user who will be responsible for repaying debt\n     * @param receiver the user who receives the borrowed funds\n     * @param amountCollateral to move into vault\n     * @param amountToBorrow out of the vault [WAD]\n     * @param amountToBorrowType whether the `amountToBorrow` is a min or max.\n     * This will dictate the rounding direction when converting to normalized\n     * amount. If it is a minimum, then the rounding will be rounded up. If it\n     * is a maximum, then the rounding will be rounded down.\n     */\n    function _depositAndBorrow(\n        address vaultHolder,\n        address receiver,\n        uint256 amountCollateral,\n        uint256 amountToBorrow,\n        AmountToBorrow amountToBorrowType\n    )\n        internal\n    {\n        JOIN.join(address(this), amountCollateral);\n\n        POOL.depositCollateral(ILK_INDEX, vaultHolder, address(this), amountCollateral, new bytes32[](0));\n\n        uint256 currentRate = POOL.rate(ILK_INDEX);\n        (,, uint256 newRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ILK_INDEX);\n        uint256 rateAfterAccrual = currentRate + newRateIncrease;\n\n        uint256 normalizedAmountToBorrow;\n        if (amountToBorrowType == AmountToBorrow.IS_MIN) {\n            normalizedAmountToBorrow = amountToBorrow.rayDivUp(rateAfterAccrual);\n        } else {\n            normalizedAmountToBorrow = amountToBorrow.rayDivDown(rateAfterAccrual);\n        }\n\n        if (amountToBorrow != 0) {\n            POOL.borrow(ILK_INDEX, vaultHolder, receiver, normalizedAmountToBorrow, new bytes32[](0));\n        }\n    }\n\n    /**\n     * @param debtToRepay in eth terms\n     * @param collateralToWithdraw in collateral terms\n     */\n    function repayAndWithdraw(uint256 debtToRepay, uint256 collateralToWithdraw) external {\n        WETH.transferFrom(msg.sender, address(this), debtToRepay);\n        _repayAndWithdraw(msg.sender, msg.sender, collateralToWithdraw, debtToRepay);\n    }\n\n    function _repayAndWithdraw(\n        address vaultHolder,\n        address receiver,\n        uint256 collateralToWithdraw,\n        uint256 debtToRepay\n    )\n        internal\n    {\n        uint256 currentRate = POOL.rate(ILK_INDEX);\n        (,, uint256 newRateIncrease,,) = POOL.calculateRewardAndDebtDistribution(ILK_INDEX);\n        uint256 rateAfterAccrual = currentRate + newRateIncrease;\n\n        uint256 normalizedDebtToRepay = debtToRepay.rayDivDown(rateAfterAccrual);\n\n        POOL.repay(ILK_INDEX, vaultHolder, address(this), normalizedDebtToRepay);\n\n        POOL.withdrawCollateral(ILK_INDEX, vaultHolder, address(this), collateralToWithdraw);\n\n        JOIN.exit(receiver, collateralToWithdraw);\n    }\n\n    /**\n     * @dev To allow unwrapping of WETH into ETH\n     */\n    receive() external payable {\n        if (msg.sender != address(WETH)) revert CannotSendEthToContract();\n    }\n}"
    }
  ]
}