{
  "Title": "[G-14] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require` or `if` statement",
  "Content": "```\nrequire(a <= b); x = b - a => require(a <= b); unchecked { x = b - a } \nif(a <= b); x = b - a => if(a <= b); unchecked { x = b - a }\n```\nThis will stop the check for overflow and underflow so it will save gas.\n\n2 results - 2 files:\n\n```solidity\ncontracts/smart-contract-wallet/aa-4337/core/StakeManager.sol:\n  116         DepositInfo storage info = deposits[msg.sender];\n  117         require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n  118:         info.deposit = uint112(info.deposit - withdrawAmount);\n```\n[StakeManager.sol#L118](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol#L118)\n\n```solidity\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  56        uint256 currentBalance = paymasterIdBalances[msg.sender];\n  57        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n  58:       paymasterIdBalances[msg.sender] -= amount;\n ```\n[VerifyingSingletonPaymaster.sol#L58](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L58)\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/aa-4337/core/StakeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    function getDepositInfo(address account) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    // internal method to return just the stake info\n    function getStakeInfo(address addr) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /// return the deposit (for gas payment) of the account\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    function internalIncrementDeposit(address account, uint256 amount) internal {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        require(newAmount <= type(uint112).max, \"deposit overflow\");\n        info.deposit = uint112(newAmount);\n    }\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) public payable {\n        internalIncrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(account, info.deposit);\n    }\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(_unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(_unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake < type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            _unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, _unstakeDelaySec);\n    }\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(info.withdrawTime <= block.timestamp, \"Stake withdrawal is not due\");\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success,) = withdrawAddress.call{value : stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = uint112(info.deposit - withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable reason-string */\nimport \"../../BasePaymaster.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../PaymasterHelpers.sol\";\n// import \"../samples/Signatures.sol\";\n\n\n/**\n * A sample paymaster that uses external service to decide whether to pay for the UserOp.\n * The paymaster trusts an external signer to sign the transaction.\n * The calling user must pass the UserOp to that external signer first, which performs\n * whatever off-chain verification before signing the UserOp.\n * Note that this signature is NOT a replacement for wallet signature:\n * - the paymaster signs to agree to PAY for GAS.\n * - the wallet signs to prove identity and wallet ownership.\n */\ncontract VerifyingSingletonPaymaster is BasePaymaster {\n\n    using ECDSA for bytes32;\n    // possibly //  using Signatures for UserOperation;\n    using UserOperationLib for UserOperation;\n    using PaymasterHelpers for UserOperation;\n    using PaymasterHelpers for bytes;\n    using PaymasterHelpers for PaymasterData;\n\n    mapping(address => uint256) public paymasterIdBalances;\n\n    address public verifyingSigner;\n\n    constructor(IEntryPoint _entryPoint, address _verifyingSigner) BasePaymaster(_entryPoint) {\n        require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n        require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n        verifyingSigner = _verifyingSigner;\n    }\n\n    function deposit() public virtual override payable {\n        revert(\"Deposit must be for a paymasterId. Use depositFor\");\n    }\n\n    /**\n     * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees\n     */\n    function depositFor(address paymasterId) public payable {\n        require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n        require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n        paymasterIdBalances[paymasterId] += msg.value;\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public override {\n        uint256 currentBalance = paymasterIdBalances[msg.sender];\n        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n        paymasterIdBalances[msg.sender] -= amount;\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    \n    /**\n    this function will let owner change signer\n    */\n    function setSigner( address _newVerifyingSigner) external onlyOwner{\n        require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n        verifyingSigner = _newVerifyingSigner;\n    }\n\n    /**\n     * return the hash we're going to sign off-chain (and validate on-chain)\n     * this method is called by the off-chain service, to sign the request.\n     * it is called on-chain from the validatePaymasterUserOp, to validate the signature.\n     * note that this signature covers all fields of the UserOperation, except the \"paymasterAndData\",\n     * which will carry the signature itself.\n     */\n    function getHash(UserOperation calldata userOp)\n    public pure returns (bytes32) {\n        //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        return keccak256(abi.encode(\n                userOp.getSender(),\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas\n            ));\n    }\n\n    /**\n     * verify our external signer signed this request.\n     * the \"paymasterAndData\" is expected to be the paymaster and a signature over the entire request params\n     */\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    external view override returns (bytes memory context, uint256 deadline) {\n        (requiredPreFund);\n        bytes32 hash = getHash(userOp);\n\n        PaymasterData memory paymasterData = userOp.decodePaymasterData();\n        uint256 sigLength = paymasterData.signatureLength;\n\n        //ECDSA library supports both 64 and 65-byte long signatures.\n        // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n        require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n        require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n        return (userOp.paymasterContext(paymasterData), 0);\n    }\n\n    /**\n   * @dev Executes the paymaster's payment conditions\n   * @param mode tells whether the op succeeded, reverted, or if the op succeeded but cause the postOp to revert\n   * @param context payment conditions signed by the paymaster in `validatePaymasterUserOp`\n   * @param actualGasCost amount to be paid to the entry point in wei\n   */\n  function _postOp(\n    PostOpMode mode,\n    bytes calldata context,\n    uint256 actualGasCost\n  ) internal virtual override {\n    (mode);\n    // (mode,context,actualGasCost); // unused params\n    PaymasterContext memory data = context.decodePaymasterContext();\n    address extractedPaymasterId = data.paymasterId;\n    paymasterIdBalances[extractedPaymasterId] -= actualGasCost;\n  }\n\n}"
    }
  ]
}