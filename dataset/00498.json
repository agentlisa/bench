{
  "Title": "M-2: User wrapped tokens get stuck in master router because of incorrect calculation",
  "Content": "# Issue M-2: User wrapped tokens get stuck in master router because of incorrect calculation \n\nSource: https://github.com/sherlock-audit/2024-02-jala-swap-judging/issues/146 \n\n## Found by \nArabadzhiev, C1rdan, cawfree, den\\_sosnovskyi, jah, mahmud, merlinboii, recursiveEth, yotov721\n## Summary\nSwapping exact tokens for ETH swaps underlying token amount, not wrapped token amount and this causes wrapped tokens to get stuck in the contract.\n\n## Vulnerability Detail\nIn the protocol the `JalaMasterRouter` is used to swap tokens with less than 18 decimals. It is achieved by wrapping the underlying tokens and interacting with the `JalaRouter02`. **Wrapping** the token gives it decimals 18 (18 - token.decimals()). There are also functions that swap with native ETH. \n\nIn the `swapExactTokensForETH` function the tokens are transferred from the user to the Jala master router, **wrapped**, approved to `JalaRouter2` and then `IJalaRouter02::swapExactTokensForETH()` is called with **the amount of tokens to swap**, to address, deadline and path. \n\nThe amount of tokens to swap that is passed, is the amount before the wrap. Hence the wrappedAmount - underlyingAmount is stuck. \n\nAdd the following test to `JalaMasterRouter.t.sol` and run with `forge test --mt testswapExactTokensForETHStuckTokens -vvv`\n```javascript\n    function testswapExactTokensForETHStuckTokens() public {\n        address wrappedTokenA = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(address(tokenA));\n\n        tokenA.approve(address(wrapperFactory), type(uint256).max);\n        wrapperFactory.wrap(address(this), address(tokenA), 100);\n\n        IERC20(wrappedTokenA).approve(address(router), 100 ether);\n        router.addLiquidityETH{value: 100 ether}(wrappedTokenA, 100 ether, 0, 0, address(this), type(uint40).max);\n\n        address pairAddress = factory.getPair(address(WETH), wrapperFactory.wrappedTokenFor(address(tokenA)));\n\n        uint256 pairBalance = JalaPair(pairAddress).balanceOf(address(this));\n\n        address[] memory path = new address[](2);\n        path[0] = wrappedTokenA;\n        path[1] = address(WETH);\n\n        vm.startPrank(user0);\n        console.log(\"ETH user balance before:       \", user0.balance);\n        console.log(\"TokenA user balance before:    \", tokenA.balanceOf(user0));\n        console.log(\"WTokenA router balance before: \", IERC20(wrappedTokenA).balanceOf(address(masterRouter)));\n\n        tokenA.approve(address(masterRouter), 550);\n        masterRouter.swapExactTokensForETH(address(tokenA), 550, 0, path, user0, type(uint40).max);\n        vm.stopPrank();\n\n        console.log(\"ETH user balance after:       \", user0.balance);\n        console.log(\"TokenA user balance after:    \", tokenA.balanceOf(user0));\n        console.log(\"WTokenA router balance after: \", IERC20(wrappedTokenA).balanceOf(address(masterRouter)));\n    }\n```\n\n\n## Impact\nUser wrapped tokens get stuck in router contract. The can be stolen by someone performing a `swapExactTokensForTokens()` because it uses the whole balance of the contract when swapping: `IERC20(wrappedTokenIn).balanceOf(address(this))` \n```solidity\n        amounts = IJalaRouter02(router).swapExactTokensForTokens(\n            IERC20(wrappedTokenIn).balanceOf(address(this)),\n            amountOutMin,\n            path,\n            address(this),\n            deadline\n        );\n```\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-jala-swap/blob/main/jalaswap-dex-contract/contracts/JalaMasterRouter.sol#L284-L301\n\n## Tool used\nManual Review, foundry\n\n## Recommendation\nIn `JalaMasterRouter::swapExactTokensForETH()` multiply the `amountIn` by decimal off set of the token:\n```diff\n    function swapExactTokensForETH(\n        address originTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override returns (uint256[] memory amounts) {\n        address wrappedTokenIn = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(originTokenAddress);\n\n        require(path[0] == wrappedTokenIn, \"MS: !path\");\n\n        TransferHelper.safeTransferFrom(originTokenAddress, msg.sender, address(this), amountIn);\n        _approveAndWrap(originTokenAddress, amountIn);\n        IERC20(wrappedTokenIn).approve(router, IERC20(wrappedTokenIn).balanceOf(address(this)));\n\n+        uint256 decimalOffset = IChilizWrappedERC20(wrappedTokenIn).getDecimalsOffset();\n+        amounts = IJalaRouter02(router).swapExactTokensForETH(amountIn * decimalOffset, amountOutMin, path, to, deadline);\n-        amounts = IJalaRouter02(router).swapExactTokensForETH(amountIn , amountOutMin, path, to, deadline);\n    }\n```\n\n\n\n## Discussion\n\n**nevillehuang**\n\nIf a sufficient slippage (which is users responsibility) is set, this will at most cause a revert, so medium severity is more appropriate. (The PoC set slippage to zero)\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/jalaswap/jalaswap-dex-contract/commit/9ed6e8f4f6ad762ef7b747ca2d367f6cfd78973e.\n\n**spacegliderrrr**\n\nfix looks good, right amount is now passed to the router\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/233",
  "Code": [
    {
      "filename": "jalaswap-dex-contract/contracts/JalaMasterRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IJalaRouter02.sol\";\nimport \"./interfaces/IJalaMasterRouter.sol\";\nimport \"./interfaces/IChilizWrapperFactory.sol\";\nimport \"./interfaces/IChilizWrappedERC20.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./libraries/JalaLibrary.sol\";\nimport \"./libraries/TransferHelper.sol\";\n\n// This is a Master Router contract that wrap under 18 decimal token\n// and interact with router to addliqudity and swap tokens.\ncontract JalaMasterRouter is IJalaMasterRouter {\n    address public immutable factory;\n    address public immutable WETH;\n    address public immutable router;\n    address public immutable wrapperFactory;\n\n    constructor(address _factory, address _wrapperFactory, address _router, address _WETH) {\n        factory = _factory;\n        wrapperFactory = _wrapperFactory;\n        router = _router;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        require(msg.sender == WETH || msg.sender == router, \"MS: !Wrong Sender\"); // only accept ETH via fallback from the WETH and router contract\n    }\n\n    function wrapTokensAndaddLiquidity(\n        // only use wrapTokensAndaddLiquidity to create pool.\n        address tokenA, // origin token\n        address tokenB, // origin token\n        uint256 amountADesired, // unwrapped.\n        uint256 amountBDesired, // unwrapped.\n        uint256 amountAMin, // unwrapped\n        uint256 amountBMin, // unwrapped\n        address to,\n        uint256 deadline\n    ) public virtual override returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\n        // get token from user\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, address(this), amountADesired);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, address(this), amountBDesired);\n\n        address wrappedTokenA = _approveAndWrap(tokenA, amountADesired);\n        address wrappedTokenB = _approveAndWrap(tokenB, amountBDesired);\n\n        uint256 tokenAOffset = IChilizWrappedERC20(wrappedTokenA).getDecimalsOffset();\n        uint256 tokenBOffset = IChilizWrappedERC20(wrappedTokenB).getDecimalsOffset();\n\n        IERC20(wrappedTokenA).approve(router, IERC20(wrappedTokenA).balanceOf(address(this))); // no need for check return value, bc addliquidity will revert if approve was declined.\n        IERC20(wrappedTokenB).approve(router, IERC20(wrappedTokenB).balanceOf(address(this)));\n\n        // add liquidity\n        (amountA, amountB, liquidity) = IJalaRouter02(router).addLiquidity(\n            wrappedTokenA,\n            wrappedTokenB,\n            amountADesired * tokenAOffset,\n            amountBDesired * tokenBOffset,\n            amountAMin * tokenAOffset,\n            amountBMin * tokenBOffset,\n            to,\n            deadline\n        );\n        _unwrapAndTransfer(wrappedTokenA, to);\n        _unwrapAndTransfer(wrappedTokenB, to);\n    }\n\n    function wrapTokenAndaddLiquidityETH(\n        // only use wrapTokenAndaddLiquidityETH to create pool.\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external payable virtual override returns (uint256 amountToken, uint256 amountETH, uint256 liquidity) {\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amountTokenDesired);\n        address wrappedToken = _approveAndWrap(token, amountTokenDesired);\n\n        uint256 tokenOffset = IChilizWrappedERC20(wrappedToken).getDecimalsOffset();\n\n        IERC20(wrappedToken).approve(router, IERC20(wrappedToken).balanceOf(address(this))); // no need for check return value, bc addliquidity will revert if approve was declined.\n\n        (amountToken, amountETH, liquidity) = IJalaRouter02(router).addLiquidityETH{value: msg.value}(\n            wrappedToken,\n            amountTokenDesired * tokenOffset,\n            amountTokenMin * tokenOffset,\n            amountETHMin,\n            to,\n            deadline\n        );\n\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n        _unwrapAndTransfer(wrappedToken, to);\n    }\n\n    function removeLiquidityAndUnwrapToken(\n        address tokenA, // token origin addr\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external virtual override returns (uint256 amountA, uint256 amountB) {\n        address wrappedTokenA = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(tokenA);\n        address wrappedTokenB = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(tokenB);\n        address pair = JalaLibrary.pairFor(factory, wrappedTokenA, wrappedTokenB);\n        TransferHelper.safeTransferFrom(pair, msg.sender, address(this), liquidity);\n\n        IERC20(pair).approve(router, liquidity);\n\n        (amountA, amountB) = IJalaRouter02(router).removeLiquidity(\n            wrappedTokenA,\n            wrappedTokenB,\n            liquidity,\n            amountAMin,\n            amountBMin,\n            address(this),\n            deadline\n        );\n\n        uint256 tokenAOffset = IChilizWrappedERC20(wrappedTokenA).getDecimalsOffset();\n        uint256 tokenBOffset = IChilizWrappedERC20(wrappedTokenB).getDecimalsOffset();\n        uint256 tokenAReturnAmount = (amountA / tokenAOffset) * tokenAOffset;\n        uint256 tokenBReturnAmount = (amountB / tokenBOffset) * tokenBOffset;\n\n        IERC20(wrappedTokenA).approve(wrapperFactory, tokenAReturnAmount); // no need for check return value, bc addliquidity will revert if approve was declined.\n        IERC20(wrappedTokenB).approve(wrapperFactory, tokenBReturnAmount); // no need for check return value, bc addliquidity will revert if approve was declined.\n\n        if (tokenAReturnAmount > 0) {\n            IChilizWrapperFactory(wrapperFactory).unwrap(to, wrappedTokenA, tokenAReturnAmount);\n        }\n        if (tokenBReturnAmount > 0) {\n            IChilizWrapperFactory(wrapperFactory).unwrap(to, wrappedTokenB, tokenBReturnAmount);\n        }\n\n        // transfer dust as wrapped token\n        if (amountA - tokenAReturnAmount > 0) {\n            TransferHelper.safeTransfer(wrappedTokenA, to, amountA - tokenAReturnAmount);\n        }\n        if (amountB - tokenBReturnAmount > 0) {\n            TransferHelper.safeTransfer(wrappedTokenB, to, amountB - tokenBReturnAmount);\n        }\n    }\n\n    function removeLiquidityETHAndUnwrap(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public virtual override returns (uint256 amountToken, uint256 amountETH) {\n        address wrappedToken = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(token);\n        address pair = JalaLibrary.pairFor(factory, wrappedToken, address(WETH));\n        TransferHelper.safeTransferFrom(pair, msg.sender, address(this), liquidity);\n\n        IERC20(pair).approve(router, liquidity);\n\n        (amountToken, amountETH) = IJalaRouter02(router).removeLiquidityETH(\n            wrappedToken,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n\n        uint256 tokenOffset = IChilizWrappedERC20(wrappedToken).getDecimalsOffset();\n        uint256 tokenReturnAmount = (amountToken / tokenOffset) * tokenOffset;\n\n        IERC20(wrappedToken).approve(wrapperFactory, tokenReturnAmount); // no need for check return value, bc addliquidity will revert if approve was declined.\n\n        if (tokenReturnAmount > 0) {\n            IChilizWrapperFactory(wrapperFactory).unwrap(to, wrappedToken, tokenReturnAmount);\n        }\n        // transfer dust as wrapped token\n        if (amountToken - tokenReturnAmount > 0) {\n            TransferHelper.safeTransfer(wrappedToken, to, amountToken - tokenReturnAmount);\n        }\n\n        (bool success, ) = to.call{value: address(this).balance}(\"\");\n        require(success);\n    }\n\n    function swapExactTokensForTokens(\n        address originTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override returns (uint256[] memory amounts, address reminderTokenAddress, uint256 reminder) {\n        address wrappedTokenIn = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(originTokenAddress);\n\n        require(path[0] == wrappedTokenIn, \"MS: !path\");\n\n        TransferHelper.safeTransferFrom(originTokenAddress, msg.sender, address(this), amountIn);\n        _approveAndWrap(originTokenAddress, amountIn);\n        IERC20(wrappedTokenIn).approve(router, IERC20(wrappedTokenIn).balanceOf(address(this)));\n\n        amounts = IJalaRouter02(router).swapExactTokensForTokens(\n            IERC20(wrappedTokenIn).balanceOf(address(this)),\n            amountOutMin,\n            path,\n            address(this),\n            deadline\n        );\n        (reminderTokenAddress, reminder) = _unwrapAndTransfer(path[path.length - 1], to);\n    }\n\n    // function swapTokensForExactTokens(\n    //     address originTokenAddress,\n    //     uint256 amountOut,\n    //     uint256 amountInMax,\n    //     address[] calldata path,\n    //     address to,\n    //     uint256 deadline\n    // ) external virtual returns (uint256[] memory amounts, address reminderTokenAddress, uint256 reminder) {\n    //     address wrappedTokenIn = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(originTokenAddress);\n\n    //     require(path[0] == wrappedTokenIn, \"MS: !path\");\n    //     address wrappedTokenOut = path[path.length - 1];\n    //     uint256 tokenOutOffset = IChilizWrappedERC20(wrappedTokenOut).getDecimalsOffset();\n\n    //     amounts = JalaLibrary.getAmountsIn(factory, amountOut*tokenOutOffset, path);\n\n    //     TransferHelper.safeTransferFrom(originTokenAddress, msg.sender, address(this), amounts[0]);\n    //     IERC20(originTokenAddress).approve(wrapperFactory, amounts[0]); // no need for check return value, bc addliquidity will revert if approve was declined.\n    //     IChilizWrapperFactory(wrapperFactory).wrap(address(this), originTokenAddress, amounts[0]);\n    //     IERC20(wrappedTokenIn).approve(router, IERC20(wrappedTokenIn).balanceOf(address(this)));\n\n    //     IJalaRouter02(router).swapTokensForExactTokens( // no need to get return value\n    //         amountOut*tokenOutOffset,\n    //         amountInMax,\n    //         path,\n    //         address(this),\n    //         deadline\n    //     );\n\n    //     uint256 balanceOut = IERC20(wrappedTokenOut).balanceOf(address(this));\n    //     uint256 tokenOutReturnAmount = (balanceOut / tokenOutOffset) * tokenOutOffset;\n\n    //     IERC20(wrappedTokenOut).approve(wrapperFactory, tokenOutReturnAmount); // no need for check return value, bc addliquidity will revert if approve was declined.\n\n    //     if (tokenOutReturnAmount > 0) {\n    //         IChilizWrapperFactory(wrapperFactory).unwrap(to, wrappedTokenOut, tokenOutReturnAmount);\n    //     }\n\n    //     // transfer dust as wrapped token\n    //     if (IERC20(wrappedTokenOut).balanceOf(address(this)) > 0) {\n    //         reminderTokenAddress = address(wrappedTokenOut);\n    //         reminder = IERC20(wrappedTokenOut).balanceOf(address(this));\n    //         TransferHelper.safeTransfer(wrappedTokenOut, to, IERC20(wrappedTokenOut).balanceOf(address(this)));\n    //     }\n    // }\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        virtual\n        override\n        returns (uint256[] memory amounts, address reminderTokenAddress, uint256 reminder)\n    {\n        amounts = IJalaRouter02(router).swapExactETHForTokens{value: msg.value}(\n            amountOutMin,\n            path,\n            address(this),\n            deadline\n        );\n        (reminderTokenAddress, reminder) = _unwrapAndTransfer(path[path.length - 1], to);\n    }\n\n    function swapExactTokensForETH(\n        address originTokenAddress,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override returns (uint256[] memory amounts) {\n        address wrappedTokenIn = IChilizWrapperFactory(wrapperFactory).wrappedTokenFor(originTokenAddress);\n\n        require(path[0] == wrappedTokenIn, \"MS: !path\");\n\n        TransferHelper.safeTransferFrom(originTokenAddress, msg.sender, address(this), amountIn);\n        _approveAndWrap(originTokenAddress, amountIn);\n        IERC20(wrappedTokenIn).approve(router, IERC20(wrappedTokenIn).balanceOf(address(this)));\n\n        amounts = IJalaRouter02(router).swapExactTokensForETH(amountIn, amountOutMin, path, to, deadline);\n    }\n\n    function _unwrapAndTransfer(\n        address wrappedTokenOut,\n        address to\n    ) private returns (address reminderTokenAddress, uint256 reminder) {\n        // address wrappedTokenOut = path[path.length - 1];\n        uint256 balanceOut = IERC20(wrappedTokenOut).balanceOf(address(this));\n        if (balanceOut == 0) return (reminderTokenAddress, reminder);\n\n        uint256 tokenOutOffset = IChilizWrappedERC20(wrappedTokenOut).getDecimalsOffset();\n        uint256 tokenOutReturnAmount = (balanceOut / tokenOutOffset) * tokenOutOffset;\n\n        IERC20(wrappedTokenOut).approve(wrapperFactory, tokenOutReturnAmount); // no need for check return value, bc addliquidity will revert if approve was declined.\n\n        if (tokenOutReturnAmount > 0) {\n            IChilizWrapperFactory(wrapperFactory).unwrap(to, wrappedTokenOut, tokenOutReturnAmount);\n        }\n\n        // transfer dust as wrapped token\n        if (IERC20(wrappedTokenOut).balanceOf(address(this)) > 0) {\n            reminderTokenAddress = address(wrappedTokenOut);\n            reminder = IERC20(wrappedTokenOut).balanceOf(address(this));\n            TransferHelper.safeTransfer(wrappedTokenOut, to, IERC20(wrappedTokenOut).balanceOf(address(this)));\n        }\n    }\n\n    function _approveAndWrap(address token, uint256 amount) private returns (address wrappedToken) {\n        IERC20(token).approve(wrapperFactory, amount); // no need for check return value, bc addliquidity will revert if approve was declined.\n        wrappedToken = IChilizWrapperFactory(wrapperFactory).wrap(address(this), token, amount);\n    }\n}"
    }
  ]
}