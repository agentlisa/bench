{
  "Title": "[M-19] Strategist can transfer user funds to themselves",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathPair.sol#L324\n\n\n# Vulnerability details\n\n## Impact\nThe strategist is able to use user funds to trade on the RubiconMarket. They can abuse this to transfer user funds to themselves.\n\nA strategist having access to user funds seems to be a deliberate design choice. But, I believe it's important to note how dangerous that is.\n\n## Proof of Concept\n1. Strategist opens up an offer through [placeMarketMakingTrades()](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathPair.sol#L324) where a token is sold for very cheap\n2. Strategist accepts the offer within the same transaction using their private wallet\n\n## Tools Used\nnone\n\n## Recommended Mitigation Steps\nThere's no easy way to fix this since it's a big part of the protocol. You'd have to overhaul the whole thing.\n\nYou could minimize the dmg by limiting the amount of funds a strategist has access to\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/rubiconPools/BathPair.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract allows a strategist to use user funds in order to market make for a Rubicon pair\n/// @notice The BathPair is the admin for the pair's liquidity and has many security checks in place\n/// @notice This contract is also where strategists claim rewards for successful market making\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IStrategistUtility.sol\";\n\ncontract BathPair {\n    /// *** Libraries ***\n    using SafeMath for uint256;\n    using SafeMath for uint16;\n\n    /// *** Storage Variables ***\n\n    /// @notice The Bath House admin of this contract; used with onlyBathHouse()\n    address public bathHouse;\n\n    /// @notice The Rubicon Market strategists direct all activity towards. There is only one market, RubiconMarket.sol, in the Rubicon Protocol\n    address public RubiconMarketAddress;\n\n    /// @notice The initialization status of BathPair\n    bool public initialized;\n\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    int128 internal deprecatedStorageVarKept420Proxy;\n\n    /// @notice Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress ðŸ“ˆ\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256 public deprecatedStorageVarKept4Proxy;\n\n    /// @dev The id of the last StrategistTrade made by any strategist on this contract\n    /// @dev This value is globally unique, and increments with every trade\n    uint256 internal last_stratTrade_id;\n\n    /// @notice The total amount of successful offer fills that all strategists have made for a given asset\n    mapping(address => uint256) public totalFillsPerAsset;\n\n    /// @notice Unique id => StrategistTrade created in marketMaking call\n    mapping(uint256 => StrategistTrade) public strategistTrades;\n\n    /// @notice Map a strategist to their outstanding order IDs\n    mapping(address => mapping(address => mapping(address => uint256[])))\n        public outOffersByStrategist;\n\n    /// @notice Tracks the market-kaing fill amounts on a per-asset basis of a strategist\n    /// @dev strategist => erc20asset => fill amount per asset;\n    mapping(address => mapping(address => uint256)) public strategist2Fills;\n\n    /// *** Structs ***\n\n    struct order {\n        uint256 pay_amt;\n        IERC20 pay_gem;\n        uint256 buy_amt;\n        IERC20 buy_gem;\n    }\n\n    struct StrategistTrade {\n        uint256 askId;\n        uint256 askPayAmt;\n        address askAsset;\n        uint256 bidId;\n        uint256 bidPayAmt;\n        address bidAsset;\n        address strategist;\n        uint256 timestamp;\n    }\n\n    /// *** Events ***\n\n    /// @notice Log a new market-making trade placed by a strategist, resulting in a StrategitTrade\n    event LogStrategistTrade(\n        uint256 strategistTradeID,\n        bytes32 askId,\n        bytes32 bidId,\n        address askAsset,\n        address bidAsset,\n        uint256 timestamp,\n        address strategist\n    );\n\n    /// @notice Logs the cancellation of a StrategistTrade\n    event LogScrubbedStratTrade(\n        uint256 strategistIDScrubbed,\n        uint256 assetFill,\n        address assetAddress,\n        address bathAssetAddress,\n        uint256 quoteFill,\n        address quoteAddress,\n        address bathQuoteAddress\n    );\n\n    /// @notice Log when a strategist claims their market-making rewards (effectively a rebate for good performance)\n    event LogStrategistRewardClaim(\n        address strategist,\n        address asset,\n        uint256 amountOfReward,\n        uint256 timestamp\n    );\n\n    /// *** External Functions ***\n\n    /// @notice Constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage\n    function initialize(uint256 _maxOrderSizeBPS, int128 _shapeCoefNum)\n        external\n    {\n        require(!initialized);\n        address _bathHouse = msg.sender; //Assume the initializer is BathHouse\n        require(\n            IBathHouse(_bathHouse).getMarket() !=\n                address(0x0000000000000000000000000000000000000000) &&\n                IBathHouse(_bathHouse).initialized(),\n            \"BathHouse not initialized\"\n        );\n        bathHouse = _bathHouse;\n\n        RubiconMarketAddress = IBathHouse(_bathHouse).getMarket();\n\n        // Shape variables for dynamic inventory management\n        /// *** DEprecate but keep storage variable on OP\n        deprecatedStorageVarKept4Proxy = _maxOrderSizeBPS;\n\n        /// @dev A deprecated storage variable! Turns out order books are elegant and complex math is simply computed off-chain, and priced in on-chain orders at the speed of Ethereum L2s!\n        deprecatedStorageVarKept420Proxy = _shapeCoefNum;\n\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyBathHouse() {\n        require(msg.sender == bathHouse);\n        _;\n    }\n\n    modifier onlyApprovedStrategist(address targetStrategist) {\n        require(\n            IBathHouse(bathHouse).isApprovedStrategist(targetStrategist) ==\n                true,\n            \"you are not an approved strategist - bathPair\"\n        );\n        _;\n    }\n\n    // *** Internal Functions ***\n\n    /// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n    /// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 - reserveRatio in practice assuming strategists use all available liquidity.\n    function enforceReserveRatio(\n        address underlyingAsset,\n        address underlyingQuote\n    )\n        internal\n        view\n        returns (address bathAssetAddress, address bathQuoteAddress)\n    {\n        bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingAsset\n        );\n        bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingQuote\n        );\n        require(\n            (\n                IBathToken(bathAssetAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n            \"Failed to meet asset pool reserve ratio\"\n        );\n        require(\n            (\n                IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n            \"Failed to meet quote pool reserve ratio\"\n        );\n    }\n\n    /// @notice Log whenever a strategist rebalances a fill amount and log the amount while incrementing total fills for that specific asset\n    /// @dev Only log fills for each strategist in an asset specific manner\n    /// @dev Goal is to map a strategist to a fill\n    function logFill(\n        uint256 amt,\n        address strategist,\n        address asset\n    ) internal {\n        strategist2Fills[strategist][asset] += amt;\n        totalFillsPerAsset[asset] += amt;\n    }\n\n    /// @notice Internal function to provide the next unique StrategistTrade ID\n    function _next_id() internal returns (uint256) {\n        last_stratTrade_id++;\n        return last_stratTrade_id;\n    }\n\n    /// @notice This function results in the removal of the Strategist Trade (bid and/or ask on Rubicon Market) from the books and it being deleted from the contract\n    /// @dev The local array of strategist IDs that exists for any given strategist [query via getOutstandingStrategistTrades()] acts as an acitve RAM for outstanding strategist trades\n    /// @dev Cancels outstanding orders and manages the ledger of outstandingAmount() on bathTokens as Strategist Trades are cancelled/scrubbed or expired\n    function handleStratOrderAtID(uint256 id) internal {\n        StrategistTrade memory info = strategistTrades[id];\n        address _asset = info.askAsset;\n        address _quote = info.bidAsset;\n\n        address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _asset\n        );\n        address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _quote\n        );\n        order memory offer1 = getOfferInfo(info.askId); //ask\n        order memory offer2 = getOfferInfo(info.bidId); //bid\n        uint256 askDelta = info.askPayAmt - offer1.pay_amt;\n        uint256 bidDelta = info.bidPayAmt - offer2.pay_amt;\n\n        // if real\n        if (info.askId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (askDelta > 0) {\n                logFill(askDelta, info.strategist, info.askAsset);\n                IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);\n                // not a full fill\n                if (askDelta != info.askPayAmt) {\n                    IBathToken(bathAssetAddress).cancel(\n                        info.askId,\n                        info.askPayAmt.sub(askDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too\n            }\n        }\n\n        // if real\n        if (info.bidId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (bidDelta > 0) {\n                logFill(bidDelta, info.strategist, info.bidAsset);\n                IBathToken(bathQuoteAddress).removeFilledTradeAmount(bidDelta);\n                // not a full fill\n                if (bidDelta != info.bidPayAmt) {\n                    IBathToken(bathQuoteAddress).cancel(\n                        info.bidId,\n                        info.bidPayAmt.sub(bidDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathQuoteAddress).cancel(info.bidId, info.bidPayAmt); // pass amount too\n            }\n        }\n\n        // Delete the order from outOffersByStrategist\n        uint256 target = getIndexFromElement(\n            id,\n            outOffersByStrategist[_asset][_quote][info.strategist]\n        );\n        uint256[] storage current = outOffersByStrategist[_asset][_quote][\n            info.strategist\n        ];\n        current[target] = current[current.length - 1];\n        current.pop(); // Assign the last value to the value we want to delete and pop, best way to do this in solc AFAIK\n\n        emit LogScrubbedStratTrade(\n            id,\n            askDelta,\n            _asset,\n            bathAssetAddress,\n            bidDelta,\n            _quote,\n            bathQuoteAddress\n        );\n    }\n\n    /// @notice Get information about a Rubicon Market offer and return it as an order\n    function getOfferInfo(uint256 id) internal view returns (order memory) {\n        (\n            uint256 ask_amt,\n            IERC20 ask_gem,\n            uint256 bid_amt,\n            IERC20 bid_gem\n        ) = IRubiconMarket(RubiconMarketAddress).getOffer(id);\n        order memory offerInfo = order(ask_amt, ask_gem, bid_amt, bid_gem);\n        return offerInfo;\n    }\n\n    /// @notice A function that returns the index of uid from array\n    /// @dev uid must be in array for the purposes of this contract to enforce outstanding trades per strategist are tracked correctly\n    function getIndexFromElement(uint256 uid, uint256[] storage array)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        bool assigned = false;\n        for (uint256 index = 0; index < array.length; index++) {\n            if (uid == array[index]) {\n                _index = index;\n                assigned = true;\n                return _index;\n            }\n        }\n        require(assigned, \"Didnt Find that element in live list, cannot scrub\");\n    }\n\n    // *** External Functions - Only Approved Strategists ***\n\n    /// @notice Key entry point for strategists to use Bath Token (LP) funds to place market-making trades on the Rubicon Order Book\n    function placeMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n        // Require at least one order is non-zero\n        require(\n            (askNumerator > 0 && askDenominator > 0) ||\n                (bidNumerator > 0 && bidDenominator > 0),\n            \"one order must be non-zero\"\n        );\n\n        address _underlyingAsset = tokenPair[0];\n        address _underlyingQuote = tokenPair[1];\n\n        (\n            address bathAssetAddress,\n            address bathQuoteAddress\n        ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n        require(\n            bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // Calculate new bid and/or ask\n        order memory ask = order(\n            askNumerator,\n            IERC20(_underlyingAsset),\n            askDenominator,\n            IERC20(_underlyingQuote)\n        );\n        order memory bid = order(\n            bidNumerator,\n            IERC20(_underlyingQuote),\n            bidDenominator,\n            IERC20(_underlyingAsset)\n        );\n\n        // Place new bid and/or ask\n        // Note: placeOffer returns a zero if an incomplete order\n        uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n            ask.pay_amt,\n            ask.pay_gem,\n            ask.buy_amt,\n            ask.buy_gem\n        );\n\n        uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n            bid.pay_amt,\n            bid.pay_gem,\n            bid.buy_amt,\n            bid.buy_gem\n        );\n\n        // Strategist trade is recorded so they can get paid and the trade is logged for time\n        StrategistTrade memory outgoing = StrategistTrade(\n            newAskID,\n            ask.pay_amt,\n            _underlyingAsset,\n            newBidID,\n            bid.pay_amt,\n            _underlyingQuote,\n            msg.sender,\n            block.timestamp\n        );\n\n        // Give each trade a unique id for easy handling by strategists\n        id = _next_id();\n        strategistTrades[id] = outgoing;\n        // Allow strategists to easily call a list of their outstanding offers\n        outOffersByStrategist[_underlyingAsset][_underlyingQuote][msg.sender]\n            .push(id);\n\n        emit LogStrategistTrade(\n            id,\n            bytes32(outgoing.askId),\n            bytes32(outgoing.bidId),\n            outgoing.askAsset,\n            outgoing.bidAsset,\n            block.timestamp,\n            outgoing.strategist\n        );\n    }\n\n    /// @notice A function to batch together many placeMarketMakingTrades() in a single transaction\n    function batchMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length,\n            \"not all order lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            placeMarketMakingTrades(\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice A function to requote an outstanding order and replace it with a new Strategist Trade\n    /// @dev Note that this function will create a new unique id for the requote'd ID due to the low-level functionality\n    function requote(\n        uint256 id,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) {\n        // 1. Scrub strat trade\n        scrubStrategistTrade(id);\n\n        // 2. Place another\n        placeMarketMakingTrades(\n            tokenPair,\n            askNumerator,\n            askDenominator,\n            bidNumerator,\n            bidDenominator\n        );\n    }\n\n    /// @notice A function to batch together many requote() calls in a single transaction\n    /// @dev Ids and input are indexed through to execute requotes\n    function batchRequoteOffers(\n        uint256[] memory ids,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length &&\n                ids.length == askNumerators.length,\n            \"not all input lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            requote(\n                ids[index],\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice - function to rebalance fill between two pools\n    function rebalancePair(\n        uint256 assetRebalAmt, //amount of ASSET in the quote buffer\n        uint256 quoteRebalAmt, //amount of QUOTE in the asset buffer\n        address _underlyingAsset,\n        address _underlyingQuote\n    ) external onlyApprovedStrategist(msg.sender) {\n        address _bathHouse = bathHouse;\n        address _bathAssetAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingAsset\n        );\n        address _bathQuoteAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingQuote\n        );\n        require(\n            _bathAssetAddress != address(0) && _bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // This should be localized to the bathToken in future versions\n        uint16 stratReward = IBathHouse(_bathHouse).getBPSToStrats();\n\n        // Simply rebalance given amounts\n        if (assetRebalAmt > 0) {\n            IBathToken(_bathQuoteAddress).rebalance(\n                _bathAssetAddress,\n                _underlyingAsset,\n                stratReward,\n                assetRebalAmt\n            );\n        }\n        if (quoteRebalAmt > 0) {\n            IBathToken(_bathAssetAddress).rebalance(\n                _bathQuoteAddress,\n                _underlyingQuote,\n                stratReward,\n                quoteRebalAmt\n            );\n        }\n    }\n\n    /// @notice Function to attempt inventory risk tail off on an AMM\n    /// @dev This function calls the strategist utility which handles the trade and returns funds to LPs\n    function tailOff(\n        address targetPool,\n        address tokenToHandle,\n        address targetToken,\n        address _stratUtil, // delegatecall target\n        uint256 amount, //fill amount to handle\n        uint256 hurdle, //must clear this on tail off\n        uint24 _poolFee\n    ) external onlyApprovedStrategist(msg.sender) {\n        // transfer here\n        uint16 stratRewardBPS = IBathHouse(bathHouse).getBPSToStrats();\n\n        IBathToken(targetPool).rebalance(\n            _stratUtil,\n            tokenToHandle,\n            stratRewardBPS,\n            amount\n        );\n\n        // Should always exceed hurdle given amountOutMinimum\n        IStrategistUtility(_stratUtil).UNIdump(\n            amount.sub((stratRewardBPS.mul(amount)).div(10000)),\n            tokenToHandle,\n            targetToken,\n            hurdle,\n            _poolFee,\n            targetPool\n        );\n    }\n\n    /// @notice Cancel an outstanding strategist offers and return funds to LPs while logging fills\n    function scrubStrategistTrade(uint256 id)\n        public\n        onlyApprovedStrategist(msg.sender)\n    {\n        require(\n            msg.sender == strategistTrades[id].strategist,\n            \"you are not the strategist that made this order\"\n        );\n        handleStratOrderAtID(id);\n    }\n\n    /// @notice Batch scrub outstanding strategist trades and return funds to LPs\n    function scrubStrategistTrades(uint256[] memory ids)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        for (uint256 index = 0; index < ids.length; index++) {\n            uint256 _id = ids[index];\n            scrubStrategistTrade(_id);\n        }\n    }\n\n    /// @notice Function where strategists claim rewards proportional to their quantity of fills\n    /// @dev This function should allow a strategist to claim ERC20s sitting on this contract (earned via rebalancing) relative to their share or strategist activity on the pair\n    /// @dev Provide the pair on which you want to claim rewards\n    function strategistBootyClaim(address asset, address quote)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        uint256 fillCountA = strategist2Fills[msg.sender][asset];\n        uint256 fillCountQ = strategist2Fills[msg.sender][quote];\n        if (fillCountA > 0) {\n            uint256 booty = (\n                fillCountA.mul(IERC20(asset).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[asset]);\n            IERC20(asset).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                asset,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[asset] -= fillCountA;\n            strategist2Fills[msg.sender][asset] -= fillCountA;\n        }\n        if (fillCountQ > 0) {\n            uint256 booty = (\n                fillCountQ.mul(IERC20(quote).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[quote]);\n            IERC20(quote).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                quote,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[quote] -= fillCountQ;\n            strategist2Fills[msg.sender][quote] -= fillCountQ;\n        }\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The goal of this function is to enable a means to retrieve all outstanding orders a strategist has live in the books\n    /// @dev This is helpful to manage orders as well as track all strategist orders (like their RAM of StratTrade IDs) and place any would-be constraints on strategists\n    function getOutstandingStrategistTrades(\n        address asset,\n        address quote,\n        address strategist\n    ) public view returns (uint256[] memory) {\n        return outOffersByStrategist[asset][quote][strategist];\n    }\n}"
    }
  ]
}