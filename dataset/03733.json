{
  "Title": "[M02] _resolveContract return value can cause failure",
  "Content": "The [`_resolveContract` function](https://github.com/graphprotocol/contracts/blob/cab50f4975580d71cb43b5731a62b86d07d951bc/contracts/governance/Managed.sol#L132) of the `Managed` contract attempts to retrieve the address of a contract given the `keccak256` representation of its name passed in as the `_nameHash` parameter. The `_resolveContract` function returns the cached value if it exists but otherwise returns the result of calling the `controller`‘s `getContractProxy` method. The `getContractProxy` method can return the zero-address either in the case the contract is never set or if it is [unset](https://github.com/graphprotocol/contracts/blob/cab50f4975580d71cb43b5731a62b86d07d951bc/contracts/governance/Controller.sol#L69).\n\n\nThe return value of `_resolveContract` is expected to be a contract satisfying one of many interfaces so that other functions can call its methods. But, when the returned value is the zero-address, these attempts to call its methods will fail because the zero-address does not have a fallback function.\n\n\nFollowing the “fail early and loudly” principle, consider including specific and informative error-handling structures to avoid unexpected failures.\n\n\n**Update:** *Acknowledged but not fixed. The Graph did not include that check because it is a “frequently used function, with low probability to be zero” and they were “concerned about the gas cost of doing that check”.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/governance/Managed.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"./IManaged.sol\";\nimport \"./IController.sol\";\n\nimport \"../curation/ICuration.sol\";\nimport \"../epochs/IEpochManager.sol\";\nimport \"../rewards/IRewardsManager.sol\";\nimport \"../staking/IStaking.sol\";\nimport \"../token/IGraphToken.sol\";\n\n/**\n * @title Graph Managed contract\n * @dev The Managed contract provides an interface for contracts to interact with the Controller\n * Inspired by Livepeer:\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\n */\ncontract Managed {\n    // Controller that contract is registered with\n    IController public controller;\n    mapping(bytes32 => address) public addressCache;\n    uint256[10] private __gap;\n\n    event ParameterUpdated(string param);\n    event SetController(address controller);\n\n    function _notPartialPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n        require(!controller.partialPaused(), \"Partial-paused\");\n    }\n\n    function _notPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n    }\n\n    function _onlyGovernor() internal view {\n        require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n    }\n\n    modifier notPartialPaused {\n        _notPartialPaused();\n        _;\n    }\n\n    modifier notPaused {\n        _notPaused();\n        _;\n    }\n\n    // Check if sender is controller\n    modifier onlyController() {\n        require(msg.sender == address(controller), \"Caller must be Controller\");\n        _;\n    }\n\n    modifier onlyGovernor() {\n        _onlyGovernor();\n        _;\n    }\n\n    /**\n     * @dev Initialize the controller\n     */\n    function _initialize(address _controller) internal {\n        _setController(_controller);\n    }\n\n    /**\n     * @notice Set Controller. Only callable by current controller\n     * @param _controller Controller contract address\n     */\n    function setController(address _controller) external onlyController {\n        _setController(_controller);\n    }\n\n    /**\n     * @dev Set controller.\n     * @param _controller Controller contract address\n     */\n    function _setController(address _controller) internal {\n        require(_controller != address(0), \"Controller must be set\");\n        controller = IController(_controller);\n        emit SetController(_controller);\n    }\n\n    /**\n     * @dev Return Curation interface\n     * @return Curation contract registered with Controller\n     */\n    function curation() internal view returns (ICuration) {\n        return ICuration(_resolveContract(keccak256(\"Curation\")));\n    }\n\n    /**\n     * @dev Return EpochManager interface\n     * @return Epoch manager contract registered with Controller\n     */\n    function epochManager() internal view returns (IEpochManager) {\n        return IEpochManager(_resolveContract(keccak256(\"EpochManager\")));\n    }\n\n    /**\n     * @dev Return RewardsManager interface\n     * @return Rewards manager contract registered with Controller\n     */\n    function rewardsManager() internal view returns (IRewardsManager) {\n        return IRewardsManager(_resolveContract(keccak256(\"RewardsManager\")));\n    }\n\n    /**\n     * @dev Return Staking interface\n     * @return Staking contract registered with Controller\n     */\n    function staking() internal view returns (IStaking) {\n        return IStaking(_resolveContract(keccak256(\"Staking\")));\n    }\n\n    /**\n     * @dev Return GraphToken interface\n     * @return Graph token contract registered with Controller\n     */\n    function graphToken() internal view returns (IGraphToken) {\n        return IGraphToken(_resolveContract(keccak256(\"GraphToken\")));\n    }\n\n    /**\n     * @dev Resolve a contract address from the cache or the Controller if not found\n     * @return Address of the contract\n     */\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\n        address contractAddress = addressCache[_nameHash];\n        if (contractAddress == address(0)) {\n            contractAddress = controller.getContractProxy(_nameHash);\n        }\n        return contractAddress;\n    }\n\n    /**\n     * @dev Cache a contract address from the Controller registry\n     */\n    function _syncContract(string memory name) internal {\n        bytes32 nameHash = keccak256(abi.encodePacked(name));\n        address contractAddress = controller.getContractProxy(nameHash);\n        if (addressCache[nameHash] != contractAddress) {\n            addressCache[nameHash] = contractAddress;\n        }\n    }\n\n    /**\n     * @dev Sync protocol contract addresses from the Controller registry\n     */\n    function syncAllContracts() external {\n        _syncContract(\"Curation\");\n        _syncContract(\"EpochManager\");\n        _syncContract(\"RewardsManager\");\n        _syncContract(\"Staking\");\n        _syncContract(\"GraphToken\");\n    }\n}"
    }
  ]
}